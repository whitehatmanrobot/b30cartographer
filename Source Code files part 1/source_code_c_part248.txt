               {
                    /* Is the dimension a simple "*" ? */

                    nextTok = ourScanner->scanLookAhead();
                    if  (nextTok == tkComma || nextTok == tkRBrack)
                    {
                        ourScanner->scan();
                        dimThis->ddNoDim = true;
                        break;
                    }
                }

                // Fall through ...

            default:

                /* Parse the dimension expression and save it */

                dimThis->ddLoTree  = parseExprComma();

                /* Is there an upper bound as well? */

                if  (ourScanner->scanTok.tok == tkDot2)
                {
                    ourScanner->scan();
                    dimThis->ddHiTree = parseExprComma();
                }
                else
                {
                    dimThis->ddHiTree = NULL;
                }

                break;

            case tkComma:
            case tkRBrack:

                if  (!isManaged)
                    parseComp->cmpError(ERRnoDimDcl);

                dimThis->ddNoDim = true;
                break;
            }

            if  (ourScanner->scanTok.tok != tkComma)
                break;

            if  (!isManaged)
                parseComp->cmpError(ERRua2manyDims);

            ourScanner->scan();
        }

        chkCurTok(tkRBrack, ERRnoRbrack);
    }

    return  dimList;
}

/*****************************************************************************
 *
 *  Given a list of argument types, create an argument list descriptor. The
 *  caller supplies the count so that can we check that a NULL terminates
 *  the list.
 */

void    _cdecl      parser::parseArgListNew(ArgDscRec & argDsc,
                                            unsigned    argCnt,
                                            bool        argNames, ...)
{
    va_list         args;

    ArgDef          list = NULL;
    ArgDef          last = NULL;
    ArgDef          desc;

    va_start(args, argNames);

    /* Clear the arglist descriptor */

#if MGDDATA
    argDsc = new ArgDscRec;
#else
    memset(&argDsc, 0, sizeof(argDsc));
#endif

    /* Save the argument count */

    argDsc.adCount = argCnt;

    while (argCnt--)
    {
        TypDef          argType;
        Ident           argName = NULL;

        argType = va_arg(args, TypDef); assert(argType);

        if  (argNames)
        {
            const   char *  argNstr;

            argNstr = (const char *)(va_arg(args, int)); assert(argNstr);
            argName = parseHash->hashString(argNstr);
        }

        /* Create an argument entry */

#if MGDDATA
        desc = new ArgDef;
#else
        desc =    (ArgDef)parseAllocPerm->nraAlloc(sizeof(*desc));
#endif

        desc->adType  = argType;
        desc->adName  = argName;

#ifdef  DEBUG
        desc->adIsExt = false;
#endif

        /* Append the argument to the end of the list */

        if  (list)
            last->adNext = desc;
        else
            list         = desc;

        last = desc;
    }

    if  (last)
        last->adNext = NULL;

    argDsc.adArgs = list;

    /* Make sure the list terminates with a NULL where we expect it */

#if defined(__IL__) && defined(_MSC_VER)
    assert(va_arg(args,    int) ==    0);
#else
    assert(va_arg(args, void *) == NULL);
#endif

    va_end(args);
}

/*****************************************************************************
 *
 *  Parse a function parameter list declaration.
 */

void                parser::parseArgList(OUT ArgDscRec REF argDsc)
{
    Compiler        ourComp    = parseComp;
//  SymTab          ourSymTab  = parseStab;
    Scanner         ourScanner = parseScan;


    assert(ourScanner->scanTok.tok == tkLParen);


    /* Clear the arglist descriptor */

#if MGDDATA
    argDsc = new ArgDscRec;
#else
    memset(&argDsc, 0, sizeof(argDsc));
#endif

    /* Are there any arguments at all? */

    if  (ourScanner->scan() == tkRParen)
    {
        /* Empty argument list */

        argDsc.adArgs    = NULL;

        /* Swallow the closing ")" */

        ourScanner->scan();
    }
    else
    {
        /* Recursively parse the argument list */

        argDsc.adArgs = parseArgListRec(argDsc);
    }
}

/*****************************************************************************
 *
 *  Recursive helper that parses a function parameter list.
 */

ArgDef              parser::parseArgListRec(ArgDscRec &argDsc)
{
    declMods        mods;
    TypDef          type;
    Ident           name;
    ArgDef          next;
    ArgDef          arec;
    SymXinfo        attr;

    Compiler        ourComp    = parseComp;
//  SymTab          ourSymTab  = parseStab;
    Scanner         ourScanner = parseScan;

    unsigned        argFlags   = 0;
    constVal        argDef;

    /* Check for a parameter mode and ellipsis */

MODE:

    switch (ourScanner->scanTok.tok)
    {
        unsigned        attrMask;
        genericBuff     attrAddr;
        size_t          attrSize;
        SymDef          attrCtor;

    case tkIN:
        ourScanner->scan();
        break;

    case tkBYREF:
        argFlags |= ARGF_MODE_REF;
        goto EXT_ARG;

    case tkOUT:
        argFlags |= ARGF_MODE_OUT;
        goto EXT_ARG;

    case tkINOUT:
        argFlags |= ARGF_MODE_INOUT;

    EXT_ARG:

        /* We know we will need a "big" argument record */

        argDsc.adExtRec = true;

        ourScanner->scan();
        break;

    case tkEllipsis:

        if  (ourScanner->scan() == tkRParen)
            ourScanner->scan();
        else
            parseComp->cmpError(ERRnoRparen);

        argDsc.adVarArgs = true;

        return  NULL;

    case tkATTRIBUTE:

        attrCtor = parseAttribute(ATGT_Parameters, attrMask,
                                                   attrAddr,
                                                   attrSize);

        if  (attrSize)
            attr = parseComp->cmpAddXtraInfo(attr, attrCtor, attrMask, attrSize, attrAddr);
        else
            attr = NULL;    

        goto GOT_ATTR;

    case tkLBrack:

        attr = parseBrackAttr(true, ATTR_MASK_NATIVE_TYPE);

    GOT_ATTR:

        if  (attr)
        {
            argDsc.adExtRec = true;
            argDsc.adAttrs  = true;

            argFlags |= ARGF_MARSH_ATTR;
        }

        if  (ourScanner->scanTok.tok == tkIN   ) goto MODE;
        if  (ourScanner->scanTok.tok == tkOUT  ) goto MODE;
        if  (ourScanner->scanTok.tok == tkINOUT) goto MODE;
        break;
    }

    /* Parse any leading modifiers */

    parseDeclMods(ACL_DEFAULT, &mods);

    /* Parse the type specification */

    type = parseTypeSpec(&mods, true);

    /* Parse the declarator */

//  static int x; if (++x == 0) forceDebugBreak();

    name = parseDeclarator(&mods, type, DN_OPTIONAL, &type, NULL, true);

    if  (!name && ourComp->cmpConfig.ccPedantic)
        ourComp->cmpWarn(WRNnoArgName);

    /* Is the argument a reference or an unmanaged array? */

    switch (type->tdTypeKind)
    {
    case TYP_REF:

        /* Is this the implicit reference to a managed class? */

        if  (type->tdIsImplicit)
        {
            assert(type->tdRef.tdrBase->tdClass.tdcRefTyp == type);
            break;
        }

        /* Strip the reference and check for "void &" */

        type = type->tdRef.tdrBase;

        if  (type->tdTypeKind == TYP_VOID)
        {
            if  (argFlags & (ARGF_MODE_OUT|ARGF_MODE_INOUT))
                parseComp->cmpError(ERRbyref2refany);

            type = parseStab->stIntrinsicType(TYP_REFANY);
            break;
        }

        /* Record the argument mode */

        argFlags |= ARGF_MODE_REF;

        /* We know we will need a "big" argument record */

        argDsc.adExtRec = true;

        break;

    case TYP_VOID:

        /* Special case: "(void)" */

        if  (argDsc.adCount == 0 && ourScanner->scanTok.tok == tkRParen)
        {
            parseComp->cmpWarn(WRNvoidFnc);
            ourScanner->scan();
            return  NULL;
        }

        parseComp->cmpError(ERRbadVoid);
        break;

    case TYP_FNC:

        /* Function types implicitly become pointers */

        type = parseStab->stNewRefType(TYP_PTR, type);
        break;

    case TYP_ARRAY:

        if  (!type->tdIsManaged)
        {
            /* Change the type to a pointer to the element */

            type = parseStab->stNewRefType(TYP_PTR, type->tdArr.tdaElem);
        }

        break;
    }

    /* Check the inside of the type */

    if  (type->tdTypeKind > TYP_lastIntrins)
        ourComp->cmpBindType(type, false, false);

    /* Is there a default argument value? */

    if  (ourScanner->scanTok.tok == tkAsg)
    {
        /* Swallow the "=" and parse the default value */

        ourScanner->scan();

        parseConstExpr(argDef, NULL, type);

        /* Flag the fact that we have a default value */

        argFlags |= ARGF_DEFVAL;

        /* We'll need a "big" argument record */

        argDsc.adDefs   = true;
        argDsc.adExtRec = true;
    }

    /* Is there another argument? */

    next = NULL;

    if  (ourScanner->scanTok.tok == tkComma)
    {
        ourScanner->scan();

        next = parseArgListRec(argDsc);
    }
    else
    {
        if      (ourScanner->scanTok.tok == tkRParen)
        {
            ourScanner->scan();
        }
        else
            parseComp->cmpError(ERRnoRparen);
    }

    /* Check for duplicate names */

    if  (name)
    {
        for (arec = next; arec; arec = arec->adNext)
        {
            if  (arec->adName == name)
            {
                parseComp->cmpError(ERRdupArg, name);
                break;
            }
        }
    }

    /* Allocate the argument descriptor */

    if  (argDsc.adExtRec)
    {
        ArgExt          xrec;

#if MGDDATA
        xrec = new ArgExt;
#else
        xrec =    (ArgExt)parseAllocPerm->nraAlloc(sizeof(*xrec));
#endif

        xrec->adFlags  = argFlags;
        xrec->adDefVal = argDef;
        xrec->adAttrs  = attr;

        arec = xrec;
    }
    else
    {
#if MGDDATA
        arec = new ArgDef;
#else
        arec =    (ArgDef)parseAllocPerm->nraAlloc(sizeof(*arec));
#endif
    }

    arec->adNext  = next;
    arec->adType  = type;
    arec->adName  = name;

#ifdef  DEBUG
    arec->adIsExt = argDsc.adExtRec;
#endif

    /* Increment the total argument count and return */

    argDsc.adCount++;

    return  arec;
}

/*****************************************************************************
 *
 *  Swallow source text until one of the specified tokens is reached.
 */

void                parser::parseResync(tokens delim1, tokens delim2)
{
    Scanner         ourScanner = parseScan;

    while (ourScanner->scan() != tkEOF)
    {
        if  (ourScanner->scanTok.tok == delim1)
            return;
        if  (ourScanner->scanTok.tok == delim2)
            return;

        if  (ourScanner->scanTok.tok == tkLCurly)
            return;
        if  (ourScanner->scanTok.tok == tkRCurly)
            return;
    }
}

/*****************************************************************************
 *
 *  Add a new entry to a list of tree nodes.
 */

Tree                parser::parseAddToNodeList(      Tree       nodeList,
                                               INOUT Tree   REF nodeLast,
                                                     Tree       nodeAdd)
{
    Tree            nodeTemp;

    /* Create a new tree list node and append it at the end */

    nodeTemp = parseCreateOperNode(TN_LIST, nodeAdd, NULL);

    if  (nodeList)
    {
        assert(nodeLast);

        nodeLast->tnOp.tnOp2 = nodeTemp;

        nodeLast = nodeTemp;

        return  nodeList;
    }
    else
    {
        nodeLast = nodeTemp;
        return  nodeTemp;
    }
}

/*****************************************************************************
 *
 *  See if we have an abstract type spec + declarator followed by the given
 *  token. When 'isCast' is non-zero we also check if whatever follows the
 *  next token (which must be tkRParen) is an operand or operator. If the
 *  type is found, its type descriptor is returned and the current token
 *  will be the 'nxtTok' that follows the type.
 */

TypDef              parser::parseCheck4type(tokens nxtTok, bool isCast)
{
    Scanner         ourScanner = parseScan;

    unsigned        ecnt;
    declMods        mods;
    TypDef          type;
    scanPosTP       tpos;

    Token           tsav;
    unsigned        line;

    /* Can the current token possibly start a type? */

    if  (!parseHash->tokenBegsTyp(ourScanner->scanTok.tok))
        return  NULL;

    /* Start recording tokens so that we can back up later */

    tpos = ourScanner->scanTokMarkPos(tsav, line);

    /*
        See if have a type - note that we can't allow types to be declared
        right now, since we're recording tokens. We also don't want any
        errors to be reported - if the type doesn't look right we'll tell
        the caller without issuing any error messages.
      */

    ecnt = parseComp->cmpStopErrorMessages();

    assert(parseNoTypeDecl == false);
    parseNoTypeDecl = true;

           parseDeclMods(ACL_DEFAULT, &mods);
    type = parseTypeSpec(&mods, true);

    parseNoTypeDecl = false;

    /* Does it still look like we could have a type? */

    if  (!parseComp->cmpRestErrorMessages(ecnt) && type)
    {
        ecnt = parseComp->cmpStopErrorMessages();

        /* Parse the declarator */

        parseDeclarator(&mods, type, DN_NONE, NULL, NULL, false);

        /* Did the above call try to issue any errors? */

        if  (!parseComp->cmpRestErrorMessages(ecnt))
        {
            /* No - it still looks like a type, is it followed by 'nxtTok' ? */

            if  (ourScanner->scanTok.tok == nxtTok)
            {
                unsigned        prec;
                treeOps         oper;

                /* Do we require a cast check? */

                if  (!isCast)
                    goto ITS_TYPE;

                /* Is the "(type)" sequence followed by an operator or terminator? */

                parseScan->scan();

                if  (parseHash->tokenIsUnop (parseScan->scanTok.tok, &prec, &oper) && oper != TN_NONE)
                    goto ITS_TYPE;

                if  (parseHash->tokenIsBinop(parseScan->scanTok.tok, &prec, &oper) && oper != TN_NONE)
                    goto RST_NTYP;

                switch (ourScanner->scanTok.tok)
                {
                case tkID:
                case tkTHIS:
                case tkBASECLASS:

                case tkNEW:
                case tkTHROW:
                case tkREFADDR:

                case tkColon2:
                case tkLParen:

                case tkNULL:
                case tkTRUE:
                case tkFALSE:
                case tkIntCon:
                case tkLngCon:
                case tkFltCon:
                case tkDblCon:
                case tkStrCon:

                case tkAnd:
                case tkAdd:
                case tkSub:
                case tkMul:
                case tkBang:
                case tkTilde:

                    goto ITS_TYPE;
                }
            }
        }
    }

    /* Looks like it's not a cast after all, backtrack and parse "(expr)" */

RST_NTYP:

    ourScanner->scanTokRewind(tpos, line, &tsav);

    return  NULL;

ITS_TYPE:

    /* We can't allow types to be declared right now since we're replaying tokens */

    assert(parseNoTypeDecl == false); parseNoTypeDecl = true;

    /* It looks like a type; backtrack and parse it as such */

    ourScanner->scanTokRewind(tpos, line, &tsav);

#ifdef  DEBUG
    unsigned        errs = parseComp->cmpErrorCount;
#endif

    /* Parse (optional) modifiers and the base type spec */

           parseDeclMods(ACL_DEFAULT, &mods);
    type = parseTypeSpec(&mods, true);

    /* Parse the declarator */

    parseDeclarator(&mods, type, DN_NONE, &type, NULL, true);

    /* Allow types to be declared once again */

    parseNoTypeDecl = false;

    /* We should not have received any errors, right? */

    assert(errs == parseComp->cmpErrorCount);

    /* Make sure we find the token we expect to follow */

    assert(ourScanner->scanTok.tok == nxtTok);

    return  type;
}

/*****************************************************************************
 *
 *  Parse either "(type)expr" or "(expr)", it's actually pretty hard to tell
 *  these apart.
 */

Tree                parser::parseCastOrExpr()
{
    Scanner         ourScanner = parseScan;

    TypDef          type;
    Tree            tree;

//  static int x; if (++x == 0) forceDebugBreak();

    assert(ourScanner->scanTok.tok == tkLParen); ourScanner->scan();

    /* Can the token after the opening "(" possibly start a type? */

    if  (parseHash->tokenBegsTyp(ourScanner->scanTok.tok))
    {
        type = parseCheck4type(tkRParen, true);
        if  (type)
        {
            /* Consume the ")" that we know follows the type */

            assert(ourScanner->scanTok.tok == tkRParen); ourScanner->scan();

            /* Create the cast node and parse the operand */

            tree = parseCreateOperNode(TN_CAST, parseExpr(99, NULL), NULL);
            tree->tnFlags |= TNF_EXP_CAST;

            /* Store the target type in the cast node and we're done */

            tree->tnType = type;

            return  tree;
        }
    }

    /* This cannot be a cast, process as parenthesised expression */

    tree = parseExpr(0, NULL);
    tree->tnFlags |= TNF_PAREN;

    chkCurTok(tkRParen, ERRnoRparen);

    return  tree;
}

/*****************************************************************************
 *
 *  Swallow an expression without analyzing it at all.
 */

void                parser::parseExprSkip()
{
    unsigned        parens = 0;

    Scanner         ourScanner = parseScan;

    for (;;)
    {
        switch (ourScanner->scan())
        {
        case tkSColon:
        case tkLCurly:
        case tkRCurly:
            return;

        case tkLParen:
            parens++;
            break;

        case tkRParen:
            if  (!parens)
                return;
            parens--;
            break;

        case tkComma:
            if  (!parens)
                return;
            break;
        }
    }
}

/*****************************************************************************
 *
 *  Parse a list of expressions.
 */

Tree                parser::parseExprList(tokens endTok)
{
    Tree            argList = NULL;
    Tree            argLast = NULL;

    Scanner         ourScanner = parseScan;

//  static int x; if (++x == 0) forceDebugBreak();

    /* Make sure things look kosher */

    assert((ourScanner->scanTok.tok == tkLParen && endTok == tkRParen) ||
           (ourScanner->scanTok.tok == tkLBrack && endTok == tkRBrack));

    /* Special case: check for an empty list */

    if  (ourScanner->scan() == endTok)
    {
        ourScanner->scan();
        return  NULL;
    }

    for (;;)
    {
        Tree            argTree;

        /* Parse the next value */

        argTree = parseExprComma();

        /* Add the expression to the list */

        argList = parseAddToNodeList(argList, argLast, argTree);

        /* Are there more arguments? */

        if  (ourScanner->scanTok.tok != tkComma)
            break;

        ourScanner->scan();
    }

    /* Issue an error if the ")" or "]" is not there */

    if  (ourScanner->scanTok.tok != endTok)
    {
        parseComp->cmpError((endTok == tkRParen) ? ERRnoRparen
                                                 : ERRnoRbrack);
    }
    else
    {
        /* Consume the ")" or "]" */

        ourScanner->scan();
    }

    return  argList;
}

/*****************************************************************************
 *
 *  Parse an XML class ctor argument list.
 */

#ifdef  SETS

Tree                parser::parseXMLctorArgs(SymDef clsSym)
{
    Scanner         ourScanner = parseScan;

    Tree            argList = NULL;
    Tree            argLast = NULL;

    SymDef          memList = clsSym->sdScope.sdScope.sdsChildList;

    /* Make sure we're dealing with an appropriate class type */

    assert(clsSym->sdClass.sdcXMLelems);

    /* Make sure we're at the opening "(" of the argument list */

    assert(ourScanner->scanTok.tok == tkLParen);

    if  (ourScanner->scan() != tkRParen)
    {
        for (;;)
        {
            Tree            argTree;
            SymDef          memSym;

            /* Locate the next instance data member of the class */

            memList = parseComp->cmpNextInstDM(memList, &memSym);
            if  (!memList)
            {
                /* Here we have no more members, there better be a "..." */

                if  (!clsSym->sdClass.sdcXMLextend)
                    parseComp->cmpError(ERRnewXMLextra);
            }

            /* Parse the next value, checking for the special case of "{}" */

            if  (ourScanner->scanTok.tok == tkLCurly)
            {
                if  (memSym)
                {
                    TypDef          type = memSym->sdType;

                    if  (type->tdTypeKind != TYP_ARRAY ||
                         type->tdIsManaged == false)
                    {
                        parseComp->cmpError(ERRnewXMLbadlc, memSym->sdName);
                        goto SKIP_ARR;
                    }

                    argTree = parseInitExpr();
                }
                else
                {
                    /* Something is terribly wrong, skip the {} thing */

                SKIP_ARR:

                    ourScanner->scanSkipText(tkLCurly, tkRCurly);

                    argTree = parseCreateErrNode();
                }
            }
            else
                argTree = parseExprComma();

            /* Add the expression to the list */

            argList = parseAddToNodeList(argList, argLast, argTree);

            /* Any more arguments present? */

            if  (ourScanner->scanTok.tok != tkComma)
                break;

            ourScanner->scan();
        }
    }

    /* Are any member initializers missing? */

    if  (parseComp->cmpNextInstDM(memList, NULL))
        parseComp->cmpError(ERRnewXML2few);

    /* Make sure the trailing ")" is present */

    chkCurTok(tkRParen, ERRnoRparen);

    return  argList;
}

#endif

/*****************************************************************************
 *
 *  Parse an expression term (e.g. a constant, variable, 'this').
 */

Tree                parser::parseTerm(Tree tree)
{
    Scanner         ourScanner = parseScan;

    if  (tree == NULL)
    {
        /*
            Note:   if you add any new tokens below that can start
                    an expression, don't forget to add them to the
                    parseCastOrExpr() function as well.
         */

//      static int x; if (++x == 0) forceDebugBreak();

        switch  (ourScanner->scanTok.tok)
        {
        case tkID:

#if 0

            /* Check for the "typename(expr)" style of cast */

            if  (parseIsTypeSpec(false))
                goto NEW_CAST;

#endif

            /* The identifier may be or have been a qualified name */

            if  (ourScanner->scanTok.tok == tkID)
            {
                tokens          nxtTok = ourScanner->scanLookAhead();
                Ident           name   = ourScanner->scanTok.id.tokIdent;

                if  (nxtTok == tkDot || nxtTok == tkColon2)
                {
                    parseNameUse(false, true, true);

                    if  (ourScanner->scanTok.tok != tkID)
                        goto QUALID;
                }

                ourScanner->scan();

                tree = parseCreateNameNode(name);
                break;
            }

        QUALID:

            if  (ourScanner->scanTok.tok != tkQUALID)
            {
                if  (ourScanner->scanTok.tok == tkHACKID)
                {
                    tree = parseCreateUSymNode(ourScanner->scanTok.hackid.tokHackSym);
                    tree = parseCreateOperNode(TN_TYPEOF, tree, NULL);
                    ourScanner->scan();
                    break;
                }
                else
                {
                    /* This should only happen after errors */

                    assert(parseComp->cmpErrorCount ||
                           parseComp->cmpErrorMssgDisabled);

                    return  parseCreateErrNode();
                }
            }

            tree = parseCreateUSymNode(ourScanner->scanTok.qualid.tokQualSym,
                                       ourScanner->scanTok.qualid.tokQualScp);

            ourScanner->scan();
            break;

        case tkQUALID:

            /* Check for the "typename(expr)" style of cast */

            if  (parseIsTypeSpec(false))
                goto NEW_CAST;

            tree = parseCreateUSymNode(ourScanner->scanTok.qualid.tokQualSym,
                                       ourScanner->scanTok.qualid.tokQualScp);
            ourScanner->scan();
            break;

        case tkIntCon:
            tree = parseCreateIconNode(ourScanner->scanTok.intCon.tokIntVal,
                                       ourScanner->scanTok.intCon.tokIntTyp);
            ourScanner->scan();
            break;

        case tkLngCon:
            tree = parseCreateLconNode(ourScanner->scanTok.lngCon.tokLngVal,
                                       ourScanner->scanTok.lngCon.tokLngTyp);
            ourScanner->scan();
            break;

        case tkFltCon:
            tree = parseCreateFconNode(ourScanner->scanTok.fltCon.tokFltVal);
            ourScanner->scan();
            break;

        case tkDblCon:
            tree = parseCreateDconNode(ourScanner->scanTok.dblCon.tokDblVal);
            ourScanner->scan();
            break;

        case tkStrCon:
            tree = parseCreateSconNode(ourScanner->scanTok.strCon.tokStrVal,
                                       ourScanner->scanTok.strCon.tokStrLen,
                                       ourScanner->scanTok.strCon.tokStrType,
                                       ourScanner->scanTok.strCon.tokStrWide);

            while (ourScanner->scan() == tkStrCon)
            {
                tree = parseCreateSconNode(ourScanner->scanTok.strCon.tokStrVal,
                                           ourScanner->scanTok.strCon.tokStrLen,
                                           ourScanner->scanTok.strCon.tokStrType,
                                           ourScanner->scanTok.strCon.tokStrWide,
                                           tree);
            }
            break;

        case tkTHIS:
            tree = parseCreateOperNode(TN_THIS, NULL, NULL);
            if  (ourScanner->scan() == tkLParen)
            {
                parseBaseCTcall = true;
                parseThisCTcall = true;
            }
            break;

        case tkBASECLASS:
            tree = parseCreateOperNode(TN_BASE, NULL, NULL);
            if  (ourScanner->scan() == tkLParen)
                parseBaseCTcall = true;
            break;

        case tkNULL:
            tree = parseCreateOperNode(TN_NULL, NULL, NULL);
            ourScanner->scan();
            break;

        case tkLParen:       // "(" expr ")"
            tree = parseCastOrExpr();
            break;

        case tkTRUE:
            ourScanner->scan();
            tree = parseCreateBconNode(1);
            break;

        case tkFALSE:
            ourScanner->scan();
            tree = parseCreateBconNode(0);
            break;

        case tkNEW:
            tree = parseNewExpr();
            break;

        case tkDELETE:
            ourScanner->scan();
            tree = parseCreateOperNode(TN_DELETE , parseExpr(), NULL);
            break;

        case tkARRAYLEN:
            chkNxtTok(tkLParen, ERRnoLparen);
            tree = parseCreateOperNode(TN_ARR_LEN, parseExpr(), NULL);
            chkCurTok(tkRParen, ERRnoRparen);
            break;

        case tkREFADDR:
            chkNxtTok(tkLParen, ERRnoLparen);
            tree = parseCreateOperNode(TN_REFADDR, parseExprComma(), NULL);
            if  (ourScanner->scanTok.tok == tkComma)
            {
                Tree            typx;

                ourScanner->scan();

                typx = tree->tnOp.tnOp2 = parseCreateOperNode(TN_NONE, NULL, NULL);
                typx->tnType = parseType();
            }
            else
                parseComp->cmpError(ERRnoComma);
            chkCurTok(tkRParen, ERRnoRparen);
            break;

        default:

            if  (parseIsTypeSpec(false))
            {
                declMods        mods;
                TypDef          type;

            NEW_CAST:

                /* What we expect here is "type(expr)" */

                parseDeclMods(ACL_DEFAULT, &mods);

                type = parseTypeSpec(&mods, true);
                if  (!type)
                    return  parseCreateErrNode();

                /* Make sure the expected "(" is present */

                if  (ourScanner->scanTok.tok != tkLParen)
                {


                    parseDeclarator(&mods, type, DN_OPTIONAL, &type, NULL, true);

                    /* We'll let the compiler decide what to do with this thing */

                    tree = parseCreateOperNode(TN_TYPE, NULL, NULL);
                    tree->tnType = type;

                    return  tree;
                }
                ourScanner->scan();

                /* Create the cast node and parse the operand */

                tree = parseCreateOperNode(TN_CAST, parseExpr(0, NULL), NULL);
                tree->tnFlags |= TNF_EXP_CAST;

                chkCurTok(tkRParen, ERRnoRparen);

                /* Store the target type in the cast node and we're done */

                tree->tnType = type;
                break;
            }

            tree = parseCreateErrNode(ERRsyntax);
            parseResync(tkNone, tkNone);
            break;
        }
    }

    /* Check for any post-fix operators */

    for (;;)
    {
        switch  (ourScanner->scanTok.tok)
        {
            Tree            index;

        case tkDot:
            if  (ourScanner->scan() == tkID)
            {
                tree = parseCreateOperNode(TN_DOT,
                                           tree,
                                           parseCreateNameNode(ourScanner->scanTok.id.tokIdent));
                ourScanner->scan();
                break;
            }
            return parseCreateErrNode(ERRnoIdent);

        case tkArrow:
            if  (ourScanner->scan() == tkID)
            {
                tree = parseCreateOperNode(TN_ARROW,
                                           tree,
                                           parseCreateNameNode(ourScanner->scanTok.id.tokIdent));
                ourScanner->scan();
                break;
            }
            return parseCreateErrNode(ERRnoIdent);

#ifdef  SETS
        case tkDot2:
            if  (ourScanner->scan() == tkID)
            {
                tree = parseCreateOperNode(TN_DOT2,
                                           tree,
                                           parseCreateNameNode(ourScanner->scanTok.id.tokIdent));
                ourScanner->scan();
                break;
            }
            return parseCreateErrNode(ERRnoIdent);
#endif

        case tkLParen:

            /* Special case: va_arg takes a type as its second argument */

            if  (tree->tnOper == TN_NAME && tree->tnName.tnNameId == parseComp->cmpIdentVAget)
            {
                Tree            arg1;
                Tree            arg2;

                ourScanner->scan();

                /* va_arg expects an expression followed by a type */

                arg1 = parseExprComma();

                /* Do we have a second argument ? */

                if  (ourScanner->scanTok.tok == tkComma)
                {
                    TypDef          type;

                    ourScanner->scan();

                    /* We should have a type followed by ")" */

                    type = parseType();
                    if  (type)
                    {
                        if  (ourScanner->scanTok.tok == tkRParen)
                        {
                            /* Everything looks OK, consume the ")" */

                            ourScanner->scan();

                            /* Create a call with the two arguments */

                            arg2 = parseCreateOperNode(TN_TYPE, NULL, NULL);
                            arg2->tnType = type;
                            arg2 = parseCreateOperNode(TN_LIST, arg2, NULL);
                            arg1 = parseCreateOperNode(TN_LIST, arg1, arg2);
                            tree = parseCreateOperNode(TN_CALL, tree, arg1);

                            break;
                        }

                        parseComp->cmpError(ERRnoRparen);
                    }
                }
                else
                {
                    parseComp->cmpError(ERRbadVAarg);
                }

                /* Something went wrong, we should perform error recovery */

                return parseCreateErrNode();
            }

            tree = parseCreateOperNode(TN_CALL , tree, parseExprList(tkRParen));
            break;

        case tkLBrack:

            index = parseExprList(tkRBrack);

            if  (index)
            {
                assert(index->tnOper == TN_LIST);
                if  (index->tnOp.tnOp2 == NULL)
                    index = index->tnOp.tnOp1;

                tree = parseCreateOperNode(TN_INDEX, tree, index);
                break;
            }


            return parseCreateErrNode(ERRnoDim);

        case tkInc:
            tree = parseCreateOperNode(TN_INC_POST, tree, NULL);
            ourScanner->scan();
            break;

        case tkDec:
            tree = parseCreateOperNode(TN_DEC_POST, tree, NULL);
            ourScanner->scan();
            break;

#ifdef  SETS

            Ident           iden;
            Tree            name;
            Tree            coll;
            Tree            actx;
            Tree            decl;
            Tree            svld;

        case tkLBrack2:

            /* Check for an explicit range variable */

            iden = NULL;

            if  (ourScanner->scan() == tkID)
            {
                switch (ourScanner->scanLookAhead())
                {
                case tkSUCHTHAT:
                case tkSORTBY:

                    /* Create a declaration entry for the iteration variable */

                    iden = ourScanner->scanTok.id.tokIdent;
                    name = parseLclDclMake(iden, NULL, NULL, 0, false);

                    if  (ourScanner->scan() != tkSORTBY)
                    {
                        assert(ourScanner->scanTok.tok == tkSUCHTHAT);
                        ourScanner->scan();
                    }

                    break;
                }
            }

            /* If there was an explicit variable, invent an implicit one */

            if  (!iden)
                name = parseLclDclMake(parseComp->cmpNewAnonymousName(), NULL, NULL, 0, false);

            /* Preserve the current declaration list value(s) */

            svld = parseLastDecl; parseLastDecl = NULL;

            /* Add a new block entry to the current scope list */

            decl = parseCreateNode(TN_BLOCK);

            decl->tnBlock.tnBlkStmt   = NULL;
            decl->tnBlock.tnBlkDecl   = NULL;
            decl->tnBlock.tnBlkParent = parseCurScope;
                                        parseCurScope = decl;

            /* Add the declaration entry for the iteration variable */

            name->tnFlags |= TNF_VAR_UNREAL;
            parseLclDclDecl(name);

            /* Create the various nodes that will hold the subtrees */

            coll = parseCreateOperNode(TN_LIST  , decl, tree);
            actx = parseCreateOperNode(TN_LIST  , NULL, NULL);
            tree = parseCreateOperNode(TN_INDEX2, coll, actx);

            switch (ourScanner->scanTok.tok)
            {
                Tree            sortList;
                Tree            sortLast;

                Tree            ndcl;
                Tree            nsvl;

            default:

                /* Presumably we have a filtering predicate */

                actx->tnOp.tnOp1 = parseExprComma();

                if  (ourScanner->scanTok.tok == tkRBrack2)
                {
                    ourScanner->scan();
                    break;
                }

                if  (ourScanner->scanTok.tok != tkColon &&
                     ourScanner->scanTok.tok != tkSORTBY)
                {
                    parseComp->cmpError(ERRnoSortTerm);
                    return parseCreateErrNode();
                }

                // Fall through ...

            case tkColon:
            case tkSORTBY:

                /* We have a sort term */

                sortList = NULL;
                sortLast = NULL;

                /* Do we have both a filter and a sort ? */

                if  (actx->tnOp.tnOp1)
                {
                    /* Preserve the current declaration list value(s) */

                    nsvl = parseLastDecl; parseLastDecl = NULL;

                    /* We have both a filter and a sort, create another scope */

                    ndcl = parseCreateNode(TN_BLOCK);

                    /* WARNING: The scope nesting is "inside out", be careful */

                    ndcl->tnBlock.tnBlkStmt   = NULL;
                    ndcl->tnBlock.tnBlkDecl   = NULL;
                    ndcl->tnBlock.tnBlkParent = parseCurScope;
                                                parseCurScope = ndcl;

                    /* Add the declaration entry for the iteration variable */

                    if  (iden == NULL)
                         iden = parseComp->cmpNewAnonymousName();

                    name = parseLclDclMake(iden, NULL, NULL, 0, false);
                    name->tnFlags |= TNF_VAR_UNREAL;
                    parseLclDclDecl(name);
                }

                /* Process a list of sort terms */

                do
                {
                    Tree            sortNext = parseCreateOperNode(TN_LIST, NULL, NULL);

                    /* Check for a sort direction indicator */

                    switch (ourScanner->scan())
                    {
                    case tkDES:
                        sortNext->tnFlags |= TNF_LIST_DES;
                    case tkASC:
                        ourScanner->scan();
                        break;
                    }

                    /* Parse the next sort value */

                    sortNext->tnOp.tnOp1 = parseExprComma();

                    /* Append the entry to the list */

                    if  (sortLast)
                        sortLast->tnOp.tnOp2 = sortNext;
                    else
                        sortList             = sortNext;

                    sortLast = sortNext;
                }
                while (ourScanner->scanTok.tok == tkComma);

                /* There better be a "]]" at the end */

                if  (ourScanner->scanTok.tok != tkRBrack2)
                {
                    parseComp->cmpError(ERRnoCmRbr2);
                    tree = parseCreateErrNode();
                }
                else
                    ourScanner->scan();

                /* Are we creating a nested scope/expression ? */

                if  (actx->tnOp.tnOp1)
                {
                    assert(ndcl && ndcl->tnOper == TN_BLOCK);

                    /* Record where the scope of the declaration ended */

                    ndcl->tnBlock.tnBlkSrcEnd = ourScanner->scanGetTokenLno();

                    parseCurScope = ndcl->tnBlock.tnBlkParent;
                    parseLastDecl = nsvl;

                    /* Create the outer sort expression */

                    tree = parseCreateOperNode(TN_LIST, ndcl, tree);
                    tree = parseCreateOperNode(TN_SORT, tree, sortList);
                }
                else
                {
                    /* Store the sort list in the tree */

                    actx->tnOp.tnOp2 = sortList;
                }
            }

            /* Pop the block scope that we've created */

            assert(decl && decl->tnOper == TN_BLOCK);

            /* Record where the scope of the declaration ended */

            decl->tnBlock.tnBlkSrcEnd = ourScanner->scanGetTokenLno();

            parseCurScope = decl->tnBlock.tnBlkParent;
            parseLastDecl = svld;
            break;

#endif

        default:
            return tree;
        }
    }
}

/*****************************************************************************
 *
 *  Parse a sub-expression at the specified precedence level. If 'tree' is
 *  non-zero, we've already parsed the initial operand (and 'tree' is that
 *  operand).
 */

Tree                parser::parseExpr(unsigned minPrec, Tree tree)
{
    Scanner         ourScanner = parseScan;

    unsigned        prec;
    treeOps         oper;

    /* Should we check for a unary operator? */

    if  (tree == NULL)
    {
        /* Is the current token a unary operator? */

        if  (!parseHash->tokenIsUnop(ourScanner->scanTok.tok, &prec, &oper) ||
             oper == TN_NONE)
        {
            /* There is no unary operator */

            tree = parseTerm();
        }
        else
        {
            /* Swallow the unary operator and check for some special cases */

            ourScanner->scan();

            switch (oper)
            {
                TypDef          type;

            default:

                /* This is the "normal" unary operator case */

                tree = parseCreateOperNode(oper, parseExpr(prec, NULL), NULL);
                break;

            case TN_SIZEOF:

                chkCurTok(tkLParen, ERRnoLparen);

                /* Do we have a type or an expression? */

                type = parseCheck4type(tkRParen);
                if  (type)
                {
                    /* "sizeof" is not allowed on some types */

                    switch(type->tdTypeKind)
                    {
                    case TYP_UNDEF:
                        tree = parseCreateErrNode();
                        break;

                    case TYP_VOID:
                    case TYP_FNC:
                        tree = parseCreateErrNode(ERRbadSizeof);
                        break;

                    default:
                        tree = parseCreateOperNode(oper, NULL, NULL);
                        tree->tnType = type;
                        break;
                    }
                }
                else
                {
                    /* Presumably we have "sizeof(expr)" */

                    tree = parseCreateOperNode(oper, parseExpr(), NULL);
                }

                /* Make sure we have the closing ")" */

                chkCurTok(tkRParen, ERRnoRparen);

                tree = parseTerm(tree);
                break;

            case TN_TYPEOF:

                chkCurTok(tkLParen, ERRnoLparen);

                /* Do we have a type or an expression? */

                type = parseCheck4type(tkRParen);
                if  (type)
                {
                    TypDef          btyp = type;
                    var_types       bvtp = btyp->tdTypeKindGet();

                    switch (bvtp)
                    {
                    case TYP_CLASS:
                        break;

                    case TYP_REF:
                    case TYP_PTR:
                        btyp = btyp->tdRef.tdrBase;
                        bvtp = btyp->tdTypeKindGet();
                        break;
                    }

                    if  (!btyp->tdIsManaged)
                    {
                        if  (bvtp > TYP_lastIntrins)
                        {
                            parseComp->cmpError(ERRtypeidOp, type);
                            return parseCreateErrNode();
                        }

                        type = parseComp->cmpFindStdValType(bvtp);
                    }

                    tree = parseCreateOperNode(oper, NULL, NULL);
                    tree->tnType = type;
                }
                else
                {
                    /* This looks like "typeid(expr)" */

                    tree = parseCreateOperNode(oper, parseExpr(), NULL);
                }

                /* Make sure we have the closing ")" */

                chkCurTok(tkRParen, ERRnoRparen);

                tree = parseTerm(tree);
                break;

#ifdef  SETS
            case TN_ALL:
            case TN_EXISTS:
            case TN_FILTER:
            case TN_GROUPBY:
            case TN_PROJECT:
            case TN_SORT:
            case TN_UNIQUE:
                tree = parseSetExpr(oper);
                break;
#endif

            case TN_DEFINED:

                tree = parseCreateIconNode(ourScanner->scanChkDefined(), TYP_INT);

                /* Make sure we have the closing ")" */

                chkNxtTok(tkRParen, ERRnoRparen);
                break;
            }
        }
    }

    /* Process a sequence of operators and operands */

    for (;;)
    {
        Tree            qc;

        /* Is the current token an operator? */

        if  (!parseHash->tokenIsBinop(ourScanner->scanTok.tok, &prec, &oper))
            break;

        if  (oper == TN_NONE)
            break;

        assert(prec);

        if  (prec < minPrec)
            break;

        /* Special case: equal precedence */

        if  (prec == minPrec)
        {
            /* Assignment operators are right-associative */

            if  (!(TreeNode::tnOperKind(oper) & TNK_ASGOP))
                break;
        }

        /* Precedence is high enough -- we'll take the operator */

        tree = parseCreateOperNode(oper, tree, NULL);

        /* Consume the operator token */

        ourScanner->scan();

        /* Check for some special cases */

        switch (oper)
        {
            Tree            op1;
            Tree            op2;

        default:

            /* Parse the operand and store it in the operator node */

            tree->tnOp.tnOp2 = parseExpr(prec, NULL);
            break;

        case TN_ISTYPE:

            /* Parse the type and store it in the operator node */

            tree->tnType = parseTypeSpec(NULL, true);
            break;

        case TN_QMARK:

            /* Parse the first ":" branch */

            qc = parseExpr(prec - 1, NULL);

            /* We must have ":" at this point */

            chkCurTok(tkColon, ERRnoColon);

            /* Parse the second expression and insert the ":" node */

            tree->tnOp.tnOp2 = parseCreateOperNode(TN_COLON, qc, parseExpr(2, NULL));
            break;

        case TN_OR:
        case TN_AND:
        case TN_XOR:

            op2 = tree->tnOp.tnOp2 = parseExpr(prec, NULL);
            op1 = tree->tnOp.tnOp1;

            /* Check for the commnon mistake of saying "x & y == z" */

            if  ((op1->tnOperKind() & TNK_RELOP) && !(op1->tnFlags & TNF_PAREN) ||
                 (op2->tnOperKind() & TNK_RELOP) && !(op2->tnFlags & TNF_PAREN))
            {
                parseComp->cmpWarn(WRNoperPrec);
            }

            break;
        }
    }

    return  tree;
}

/*****************************************************************************
 *
 *  Parse and evaluate a compile-time constant expression. If the caller knows
 *  the type the expression is supposed to evaluate to, it can be passed in as
 *  'dstt', but this argument can also be NULL to indicate that any type is OK.
 *  If the 'nonCnsPtr' argument is non-zero, it is OK for the expression to be
 *  non-constant, and if a non-constant expression is encountered the value at
 *  '*nonCnsPtr' will be set to the non-constant bound expression tree.
 */

bool                parser::parseConstExpr(OUT constVal REF valRef,
                                               Tree         tree,
                                               TypDef       dstt,
                                               Tree     *   nonCnsPtr)
{
    unsigned        curLno;

    Compiler        ourComp    = parseComp;
    Scanner         ourScanner = parseScan;

    /* Assume that we won't have a string */

    valRef.cvIsStr = false;
    valRef.cvHasLC = false;

    /* Parse the expression if the caller hasn't supplied a tree */

    if  (!tree)
        tree = parseExprComma();

    ourScanner->scanGetTokenPos(&curLno);
    tree = parseComp->cmpBindExpr(tree);
    ourScanner->scanSetTokenPos( curLno);

    if  (dstt)
    {
        if  (dstt == CMP_ANY_STRING_TYPE)
        {
            if  (tree->tnOper == TN_CNS_STR)
                dstt = NULL;
            else
                dstt = ourComp->cmpStringRef();
        }

        if  (dstt)
            tree = parseComp->cmpCoerceExpr(tree, dstt, false);
    }

    tree = parseComp->cmpFoldExpression(tree);

    switch (tree->tnOper)
    {
        ConstStr        cnss;

    case TN_CNS_INT:
        valRef.cvValue.cvIval = tree->tnIntCon.tnIconVal;
        break;

    case TN_CNS_LNG:
        valRef.cvValue.cvLval = tree->tnLngCon.tnLconVal;
        break;

    case TN_CNS_FLT:
        valRef.cvValue.cvFval = tree->tnFltCon.tnFconVal;
        break;

    case TN_CNS_DBL:
        valRef.cvValue.cvDval = tree->tnDblCon.tnDconVal;
        break;

    case TN_CNS_STR:

#if MGDDATA
        cnss = new ConstStr;
#else
        cnss =    (ConstStr)parseAllocPriv.nraAlloc(sizeof(*cnss));
#endif

        valRef.cvValue.cvSval = cnss;
        valRef.cvIsStr        = true;
        valRef.cvHasLC        = tree->tnStrCon.tnSconLCH;

        cnss->csStr = tree->tnStrCon.tnSconVal;
        cnss->csLen = tree->tnStrCon.tnSconLen;

        break;

    case TN_NULL:
        valRef.cvValue.cvIval = 0;
        break;

    default:

        if  (nonCnsPtr)
        {
            *nonCnsPtr = tree;
            return  false;
        }

        parseComp->cmpError(ERRnoCnsExpr);

        // Fall through ...

    case TN_ERROR:

        valRef.cvVtyp         = TYP_UNDEF;
        valRef.cvType         = parseStab->stIntrinsicType(TYP_UNDEF);

        return  false;
    }

    valRef.cvType = tree->tnType;
    valRef.cvVtyp = tree->tnVtypGet();

    parseComp->cmpErrorTree = NULL;

    return  true;
}

/*****************************************************************************
 *
 *  Parse a (possibly qualified) name reference and return the corresponding
 *  symbol (or NULL in case of an error).
 */

SymDef              parser::parseNameUse(bool typeName,
                                         bool keepName, bool chkOnly)
{
    name_space      nameSP = (name_space)(NS_TYPE|NS_NORM);
    Ident           name;
    SymDef          scp;
    SymDef          sym;

    Scanner         ourScanner = parseScan;
    SymTab          ourSymTab  = parseStab;


    scp = NULL;

    if  (ourScanner->scanTok.tok == tkColon2)
    {
        sym = parseComp->cmpGlobalNS;
        goto NXTID;
    }

    assert(ourScanner->scanTok.tok == tkID);

    /* Lookup the initial name */

    name = ourScanner->scanTok.id.tokIdent;

    if  (parseLookupSym(name))
        return  NULL;

//  static int x; if (++x == 0) forceDebugBreak();

    switch (ourScanner->scanLookAhead())
    {
    case tkDot:
    case tkColon2:
        if  (typeName)
        {
            sym = ourSymTab->stLookupSym(name, NS_CONT);
            if  (sym)
                break;
        }
        sym = ourSymTab->stLookupSym(name, (name_space)(NS_NORM|NS_TYPE));
        break;

    default:
        sym = ourSymTab->stLookupSym(name, nameSP);
        break;
    }

    if  (!sym)
    {
        if  (chkOnly)
            return  NULL;

        parseComp->cmpError(ERRundefName, name);

        /* Swallow the rest of the name */

    ERR:

        for (;;)
        {
            // UNDONE: The following doesn't always work, need to pay attention to 'chkOnly'

            switch (ourScanner->scan())
            {
            case tkID:
            case tkDot:
            case tkColon2:
                continue;

            default:
                return  ourSymTab->stErrSymbol;
            }
        }
    }

    /* Make sure we have access to the symbol */

    if  (sym->sdSymKind != SYM_FNC)
        parseComp->cmpCheckAccess(sym);

    /* Process any further names */

    for (;;)
    {
        SymDef          tmp;

        switch (ourScanner->scanLookAhead())
        {
        case tkDot:
        case tkColon2:

            /* Have we gone far enough already? */

            if  (sym->sdHasScope())
                break;

            // Fall through ....

        default:

            if  (keepName)
                ourScanner->scanSetQualID(NULL, sym, scp);
            else
                ourScanner->scan();

            return sym;
        }

        ourScanner->scan();

    NXTID:

        /* The "." or "::" better be followed by an identifier */

        if  (ourScanner->scan() != tkID)
        {


            parseComp->cmpError(ERRnoIdent);
            goto ERR;
        }

        name = ourScanner->scanTok.id.tokIdent;

        /* Make sure the current scope is appropriate, and lookup the name in it */

        switch (sym->sdSymKind)
        {
        case SYM_NAMESPACE:
            tmp = ourSymTab->stLookupNspSym(name, nameSP, sym);
            if  (tmp)
                break;
            if  (sym == parseComp->cmpGlobalNS)
                parseComp->cmpError(ERRnoGlobNm,      name);
            else
                parseComp->cmpError(ERRnoNspMem, sym, name);
            goto ERR;

        case SYM_CLASS:
            tmp = ourSymTab->stLookupAllCls(name, sym, nameSP, CS_DECLSOON);
            if  (tmp)
                break;
            parseComp->cmpError(ERRnoClsMem, sym, name);
            goto ERR;

        case SYM_ENUM:
            tmp = ourSymTab->stLookupScpSym(name, sym);
            if  (tmp)
                break;
            parseComp->cmpError(ERRnoClsMem, sym, name);
            goto ERR;

        default:
            parseComp->cmpError(ERRnoTPmems, sym);
            goto ERR;
        }

        /* Switch to the new symbol and continue */

        scp = sym;
        sym = tmp;
    }
}

/*****************************************************************************
 *
 *  Create a declaration node for the given local variable / argument.
 */

Tree                parser::parseLclDclMake(Ident name, TypDef   type,
                                                        Tree     init,
                                                        unsigned mods,
                                                        bool     arg)
{
    Tree            decl;
    Tree            info;

    /* Create an entry for this declaration */

    decl = parseCreateNode(TN_VAR_DECL);

    /* Combine the name with the optional initializer */

    info = parseCreateNameNode(name);

    if  (init)
    {
        decl->tnFlags |= TNF_VAR_INIT;
        info = parseCreateOperNode(TN_LIST, info, init);
    }

    decl->tnDcl.tnDclInfo = info;
    decl->tnDcl.tnDclSym  = NULL;
    decl->tnDcl.tnDclNext = NULL;

    /* Set any flags that need setting */

    if  (arg)
        decl->tnFlags |= TNF_VAR_ARG;

    if  (mods & DM_STATIC)
        decl->tnFlags |= TNF_VAR_STATIC;
    if  (mods & DM_CONST)
        decl->tnFlags |= TNF_VAR_CONST;
    if  (mods & DM_SEALED)
        decl->tnFlags |= TNF_VAR_SEALED;

    /* Store the declared type in the declaration node */

    decl->tnType = type;

    return  decl;
}

/*****************************************************************************
 *
 *  Add the given declaration node to the current declaration list.
 */

void                parser::parseLclDclDecl(Tree decl)
{
    /* Insert the declaration in the current scope */

    if  (parseLastDecl)
    {
        /* Not the first declaration, append to the list */

        assert(parseLastDecl->tnOper          == TN_VAR_DECL);
        assert(parseLastDecl->tnDcl.tnDclNext == NULL);

        parseLastDecl->tnDcl.tnDclNext = decl;
    }
    else
    {
        Tree            curBlk = parseCurScope;

        /* It's the first declaration, start the decl list */

        assert(curBlk && curBlk->tnOper == TN_BLOCK);

        curBlk->tnBlock.tnBlkDecl = decl;
    }

    parseLastDecl = decl;

    /* Keep track of how many non-static/non-const/real locals we've declared */

    if  (!(decl->tnFlags & (TNF_VAR_STATIC|TNF_VAR_CONST|TNF_VAR_UNREAL)))
        parseLclVarCnt++;
}

/*****************************************************************************
 *
 *  Look for the given name in the current local scopes.
 */

Tree                parser::parseLookupSym(Ident name)
{
    Tree            scope;

    for (scope = parseCurScope;
         scope;
         scope = scope->tnBlock.tnBlkParent)
    {
        Tree            decl;

        assert(scope->tnOper == TN_BLOCK);

        for (decl = scope->tnBlock.tnBlkDecl;
             decl;
             decl = decl->tnDcl.tnDclNext)
        {
            Tree            vnam;

            assert(decl->tnOper == TN_VAR_DECL);

            vnam = decl->tnDcl.tnDclInfo;
            if  (decl->tnFlags & TNF_VAR_INIT)
            {
                assert(vnam->tnOper == TN_LIST);

                vnam = vnam->tnOp.tnOp1;
            }

            assert(vnam->tnOper == TN_NAME);

            if  (vnam->tnName.tnNameId == name)
                return  decl;
        }
    }

    return  NULL;
}

/*****************************************************************************
 *
 *  Parse an initializer - this could be a simple expression or a "{}"-style
 *  array/class initializer.
 */

Tree                parser::parseInitExpr()
{
    Scanner         ourScanner = parseScan;

    scanPosTP       iniFpos;
    unsigned        iniLine;

    Tree            init;

    iniFpos = ourScanner->scanGetTokenPos(&iniLine);

    if  (ourScanner->scanTok.tok == tkLCurly)
    {
        ourScanner->scanSkipText(tkLCurly, tkRCurly);
        if  (ourScanner->scanTok.tok == tkRCurly)
            ourScanner->scan();
    }
    else
    {
        ourScanner->scanSkipText(tkNone, tkNone, tkComma);
    }

    init = parseCreateNode(TN_SLV_INIT);
    init->tnInit.tniSrcPos.dsdBegPos = iniFpos;
    init->tnInit.tniSrcPos.dsdSrcLno = iniLine;
//  init->tnInit.tniSrcPos.dsdSrcCol = iniCol;
//  init->tnInit.tniSrcPos.dsdEndPos = ourScanner->scanGetFilePos();
    init->tnInit.tniCompUnit         = ourScanner->scanGetCompUnit();

    return  init;
}

/*****************************************************************************
 *
 *  Parse a try/catch/except/finally statement.
 */

Tree                parser::parseTryStmt()
{
    Tree            tryStmt;
    Tree            hndList = NULL;
    Tree            hndLast = NULL;

    Scanner         ourScanner = parseScan;

    assert(ourScanner->scanTok.tok == tkTRY);

    if  (ourScanner->scan() != tkLCurly)
        parseComp->cmpError(ERRtryNoBlk);

    tryStmt = parseCreateOperNode(TN_TRY, parseFuncStmt(), NULL);

    /* The next thing must be except or catch/finally */

    switch (ourScanner->scanTok.tok)
    {
        Tree            hndThis;

    case tkEXCEPT:

        chkNxtTok(tkLParen, ERRnoLparen);
        hndList = parseCreateOperNode(TN_EXCEPT, parseExpr(), NULL);
        chkCurTok(tkRParen, ERRnoRparen);

        if  (ourScanner->scanTok.tok != tkLCurly)
            parseComp->cmpError(ERRnoLcurly);

        hndList->tnOp.tnOp2 = parseFuncStmt();
        break;

    case tkCATCH:

        /* Parse a series of catches, optionally followed by "finally" */

        do
        {
            declMods        mods;
            TypDef          type;
            Ident           name;
            Tree            decl;
            Tree            body;

            assert(ourScanner->scanTok.tok == tkCATCH);

            /* Process the initial "catch(type name)" */

            chkNxtTok(tkLParen, ERRnoLparen);

            /* Parse any leading modifiers */

            parseDeclMods(ACL_DEFAULT, &mods);

            /* Make sure no modifiers are present */

            if  (mods.dmMod)
                parseComp->cmpModifierError(ERRlvModifier, mods.dmMod);

            /* Parse the type specification */

            type = parseTypeSpec(&mods, true);

            /* Parse the declarator */

            name = parseDeclarator(&mods, type, DN_OPTIONAL, &type, NULL, true);

            /* Make sure the expected ")" is present */

            chkCurTok(tkRParen, ERRnoRparen);

            /* Create a declaration node and pass it indirectly to parseBlock() */

            decl = parseTryDecl = parseLclDclMake(name, type, NULL, 0, false);

            /* Parse the body of the catch block and create a "catch" node */

            if  (ourScanner->scanTok.tok == tkLCurly)
            {
                body = parseFuncBlock(parseComp->cmpGlobalNS);
            }
            else
            {
                body = parseCreateErrNode(ERRnoLcurly);

                parseFuncStmt();
            }

            hndThis = parseCreateOperNode(TN_CATCH, decl, body);

            /* Add the handler to the list and check for more */

            hndList = parseAddToNodeList(hndList, hndLast, hndThis);
        }
        while (ourScanner->scanTok.tok == tkCATCH);

        /* Is there a finally at the end? */

        if  (ourScanner->scanTok.tok != tkFINALLY)
            break;

        // Fall through ....

    case tkFINALLY:

        if  (ourScanner->scan() != tkLCurly)
            parseComp->cmpError(ERRnoLcurly);

        tryStmt->tnFlags |= TNF_BLK_HASFIN;

        hndThis = parseCreateOperNode(TN_FINALLY, parseFuncStmt(), NULL);

        if  (hndList)
            hndList = parseAddToNodeList(hndList, hndLast, hndThis);
        else
            hndList = hndThis;

        break;

    default:
        parseComp->cmpError(ERRnoHandler);
        break;
    }

    tryStmt->tnOp.tnOp2 = hndList;

    return  tryStmt;
}

/*****************************************************************************
 *
 *  Parse a single statement.
 */

Tree                parser::parseFuncStmt(bool stmtOpt)
{
    Scanner         ourScanner = parseScan;

    Tree            tree;

//  static int x; if (++x == 0) forceDebugBreak();

    /* See what sort of a statement we have here */

    switch (ourScanner->scanTok.tok)
    {
        bool            isLabel;
        bool            isDecl;

        Tree            cond;
        Tree            save;
        Tree            svld;

    case tkID:

        /*
            This is a difficult case - both declarations of local
            variables as well as statement expressions can start
            with an identifier. In C++ the ambiguity is resolved
            by lookahead - if the thing can possibly be a variable
            declaration, it is; otherwise it's an expression. The
            problem is that (unlimited) token lookahead is very
            expensive, and even people have a hard time figuring
            out what is what. Thus, we use a simple rule: if the
            thing is a declaration that starts with a name, that
            name must be known to be a type name.
         */

        isLabel = false;
        isDecl  = parseIsTypeSpec(false, &isLabel);

        if  (isLabel)
        {
            Tree            label;
            Ident           name;

            assert(ourScanner->scanTok.tok == tkID);
            name = ourScanner->scanTok.id.tokIdent;

            /* Allocate a label entry and add it to the list */

            label = parseCreateOperNode(TN_LABEL, parseCreateNameNode(name),
                                                  parseLabelList);
            parseLabelList = label;

            assert(ourScanner->scanTok.tok == tkID);
                   ourScanner->scan();
            assert(ourScanner->scanTok.tok == tkColon);
                   ourScanner->scan();

            /* Do we have (or require) a "real" statement here? */

            if  (!stmtOpt || (ourScanner->scanTok.tok != tkRCurly &&
                              ourScanner->scanTok.tok != tkSColon))
            {
                tree = parseFuncStmt();

                if  (tree)
                {
                    label->tnOp.tnOp2 = parseCreateOperNode(TN_LIST,
                                                            tree,
                                                            label->tnOp.tnOp2);
                }
            }

            return  label;
        }

        if  (isDecl)
            goto DECL;
        else
            goto EXPR;

    default:

        /* Is this a declaration? */

        if  (parseHash->tokenBegsTyp(ourScanner->scanTok.tok))
        {
            unsigned        mbad;
            declMods        mods;
            TypDef          btyp;
            Tree            last;

        DECL:

            /* Here we have a local declaration */

            tree = last = NULL;

            /* Parse any leading modifiers */

            parseDeclMods(ACL_DEFAULT, &mods);

            /* Make sure no weird modifiers are present */

            mbad = (mods.dmMod & ~(DM_STATIC|DM_CONST));
            if  (mbad)
                parseComp->cmpModifierError(ERRlvModifier, mbad);

            if  (mods.dmAcc != ACL_DEFAULT)
                parseComp->cmpError(ERRlvAccess);

            /* Parse the type specification */

            btyp = parseTypeSpec(&mods, true);

            /* Parse the declarator list */

            for (;;)
            {
                Ident           name;
                Tree            init;
                Tree            decl;
                TypDef          type;

                /* Parse the next declarator */

                name = parseDeclarator(&mods, btyp, DN_REQUIRED, &type, NULL, true);

                /* Make sure we have a non-NULL type */

                if  (type && name)
                {
                    Tree            prev;

                    /* Check for a redeclaration */

                    if  (parseComp->cmpConfig.ccPedantic)
                    {
                        /* Check all the local scopes */

                        prev = parseLookupSym(name);
                    }
                    else
                    {
                        Tree            save;

                        /* Check only the current local scope */

                        save = parseCurScope->tnBlock.tnBlkParent;
                               parseCurScope->tnBlock.tnBlkParent = NULL;
                        prev = parseLookupSym(name);
                               parseCurScope->tnBlock.tnBlkParent = save;
                    }

                    if  (prev)
                    {
                        parseComp->cmpError(ERRredefLcl, name);
                        name = NULL;
                    }
                }
                else
                {
                    name = NULL;
                    type = parseStab->stIntrinsicType(TYP_UNDEF);
                }

                /* Is there an initializer? */

                init = NULL;

                if  (ourScanner->scanTok.tok == tkAsg)
                {
                    /* Is the variable static or auto? */

                    if  (mods.dmMod & DM_STATIC)
                    {
                        /* This could be a "{}"-style initializer */

                        ourScanner->scan();

                        init = parseInitExpr();
                    }
                    else
                    {
                        /* Swallow the "=" and parse the initializer expression */

                        if  (ourScanner->scan() == tkLCurly)
                        {
                            init = parseInitExpr();
                        }
                        else
                            init = parseExprComma();
                    }
                }

                /* Add the declaration to the list */

                decl = parseLclDclMake(name, type, init, mods.dmMod, false);
                       parseLclDclDecl(decl);
                tree = parseAddToNodeList(tree, last, decl);

                /* Are there any more declarations? */

                if  (ourScanner->scanTok.tok != tkComma)
                    break;

                ourScanner->scan();
            }

            break;
        }

        /* We have an expression statement */

    EXPR:

        tree = parseExpr();
        break;

    case tkLCurly:
        return  parseFuncBlock();

    case tkIF:

        tree = parseCreateOperNode(TN_IF, NULL, NULL);

        chkNxtTok(tkLParen, ERRnoLparen);
        tree->tnOp.tnOp1 = parseExpr();
        chkCurTok(tkRParen, ERRnoRparen);
        tree->tnOp.tnOp2 = parseFuncStmt();

        /*
            Check for the presence of an "else" clause. Note that we want
            to end up with the following tree for 'if' without 'else':

                IF(cond,stmt)

            If the 'else' clause is present, we want to create this tree
            instead:

                IF(cond,LIST(true_stmt,false_stmt))

            We also set 'TNF_IF_HASELSE' to indicate that the 'else' part
            is present.
         */

        if  (ourScanner->scanTok.tok == tkELSE)
        {
            ourScanner->scan();

            tree->tnOp.tnOp2 = parseCreateOperNode(TN_LIST, tree->tnOp.tnOp2,
                                                            parseFuncStmt());

            tree->tnFlags |= TNF_IF_HASELSE;
        }

        return  tree;

    case tkRETURN:

        tree = (ourScanner->scan() == tkSColon) ? NULL
                                                : parseExpr();

        tree = parseCreateOperNode(TN_RETURN, tree, NULL);
        break;

    case tkTHROW:

        tree = parseCreateOperNode(TN_THROW, NULL, NULL);

        if  (ourScanner->scan() != tkSColon)
            tree->tnOp.tnOp1 = parseExpr();

        break;

    case tkWHILE:

        chkNxtTok(tkLParen, ERRnoLparen);
        cond = parseExpr();
        chkCurTok(tkRParen, ERRnoRparen);

        return  parseCreateOperNode(TN_WHILE, cond, parseFuncStmt());

    case tkDO:

        ourScanner->scan();

        tree = parseCreateOperNode(TN_DO, parseFuncStmt(), NULL);

        if  (ourScanner->scanTok.tok == tkWHILE)
        {
            chkNxtTok(tkLParen, ERRnoLparen);
            tree->tnOp.tnOp2 = parseExpr();
            chkCurTok(tkRParen, ERRnoRparen);
        }
        else
        {
            parseComp->cmpError(ERRnoWhile);
        }
        return  tree;

    case tkSWITCH:

        chkNxtTok(tkLParen, ERRnoLparen);
        cond = parseExpr();
        chkCurTok(tkRParen, ERRnoRparen);

        /* Save the current switch, insert ours and parse the body */

        save = parseCurSwitch;
        tree = parseCurSwitch = parseCreateOperNode(TN_SWITCH, NULL, NULL);

        tree->tnSwitch.tnsValue    = cond;
        tree->tnSwitch.tnsCaseList =
        tree->tnSwitch.tnsCaseLast = NULL;
        tree->tnSwitch.tnsStmt     = parseFuncStmt();

        /* Restore the previous switch context and return */

        parseCurSwitch = save;

        return  tree;

    case tkCASE:

        if  (!parseCurSwitch)
            parseComp->cmpError(ERRbadCase);

        ourScanner->scan();

        cond = parseExpr();

    ADD_CASE:

        tree = parseCreateOperNode(TN_CASE, NULL, NULL);

        chkCurTok(tkColon, ERRnoColon);

        tree->tnCase.tncValue = cond;
        tree->tnCase.tncLabel = NULL;
        tree->tnCase.tncNext  = NULL;

        if  (parseCurSwitch)
        {
            if  (parseCurSwitch->tnSwitch.tnsCaseList)
                parseCurSwitch->tnSwitch.tnsCaseLast->tnCase.tncNext = tree;
            else
                parseCurSwitch->tnSwitch.tnsCaseList                 = tree;

            parseCurSwitch->tnSwitch.tnsCaseLast = tree;
        }

        return  tree;

    case tkDEFAULT:

        if  (!parseCurSwitch)
            parseComp->cmpError(ERRbadDefl);

        ourScanner->scan();

        cond = NULL;

        goto ADD_CASE;

    case tkFOR:

        save = NULL;

        if  (ourScanner->scan() == tkLParen)
        {
            Tree            init = NULL;
            Tree            incr = NULL;
            Tree            body = NULL;
            Tree            forx = parseCreateOperNode(TN_FOR, NULL, NULL);

            /* The "init-expr/decl" is optional */

            if  (ourScanner->scan() != tkSColon)
            {
                /* Is there a declaration? */

                if  (parseHash->tokenBegsTyp(ourScanner->scanTok.tok))
                {
                    declMods        mods;
                    TypDef          btyp;
                    TypDef          type;
                    Ident           name;

                    /* If we have an identifier, it's a bit tricker */

                    if  (ourScanner->scanTok.tok == tkID)
                    {
                        if  (!parseIsTypeSpec(false))
                            goto FOR_EXPR;
                    }

                    /* Preserve the current declaration list value(s) */

                    svld = parseLastDecl; parseLastDecl = NULL;

                    /* Add a new block entry to the current scope list */

                    save = parseCreateNode(TN_BLOCK);

                    save->tnFlags            |= TNF_BLK_FOR;
                    save->tnBlock.tnBlkStmt   = NULL;
                    save->tnBlock.tnBlkDecl   = NULL;
                    save->tnBlock.tnBlkParent = parseCurScope;
                                                parseCurScope = save;

                    /* Parse any leading modifiers */

                    clearDeclMods(&mods);
                    parseDeclMods(ACL_DEFAULT, &mods);

                    /* Parse the type specification */

                    btyp = parseTypeSpec(&mods, true);

                    /* Parse a series of declarators */

                    for (;;)
                    {
                        Tree            decl;
                        Tree            init;

                        /* Get the next declarator */

                        name = parseDeclarator(&mods, btyp, DN_REQUIRED, &type, NULL, true);

                        /* Is there an initializer? */

                        if  (ourScanner->scanTok.tok == tkAsg)
                        {
                            ourScanner->scan();

                            init = parseExprComma();
                        }
                        else
                            init = NULL;

                        /* Add the declaration to the list */

                        decl = parseLclDclMake(name, type, init, mods.dmMod, false);
                               parseLclDclDecl(decl);

                        /* Are there more declarators? */

                        if  (ourScanner->scanTok.tok != tkComma)
                            break;

                        ourScanner->scan();
                    }

                    init = save;
                }
                else
                {
                    /* Here the initializer is a simple expression */

                FOR_EXPR:

                    init = parseExpr(); assert(init->tnOper != TN_LIST);
                }

                /* There better be a semicolon here */

                if  (ourScanner->scanTok.tok != tkSColon)
                {
                    parseComp->cmpError(ERRnoSemic);

                    /* Maybe they just forgot the other expressions? */

                    if  (ourScanner->scanTok.tok == tkRParen)
                        goto FOR_BODY;
                    else
                        goto BAD_FOR;
                }
            }

            assert(ourScanner->scanTok.tok == tkSColon);

            /* The "cond-expr" is optional */

            cond = NULL;

            if  (ourScanner->scan() != tkSColon)
            {
                cond = parseExpr();

                /* There better be a semicolon here */

                if  (ourScanner->scanTok.tok != tkSColon)
                {
                    parseComp->cmpError(ERRnoSemic);

                    /* Maybe they just forgot the other expressions? */

                    if  (ourScanner->scanTok.tok == tkRParen)
                        goto FOR_BODY;
                    else
                        goto BAD_FOR;
                }
            }

            assert(ourScanner->scanTok.tok == tkSColon);

            /* The "incr-expr" is optional */

            if  (ourScanner->scan() != tkRParen)
            {
                incr = parseExpr();

                /* There better be a ")" here */

                if  (ourScanner->scanTok.tok != tkRParen)
                {
                    parseComp->cmpError(ERRnoRparen);
                    goto BAD_FOR;
                }
            }

        FOR_BODY:

            assert(ourScanner->scanTok.tok == tkRParen); ourScanner->scan();

            body = parseFuncBlock();

            /* Fill in the "for" node to hold all the components */

            forx->tnOp.tnOp1 = parseCreateOperNode(TN_LIST, init, cond);
            forx->tnOp.tnOp2 = parseCreateOperNode(TN_LIST, incr, body);

            /* Pop the block scope if we created one */

            if  (save)
            {
                assert(save->tnOper == TN_BLOCK && save == init);

                /* Figure out where the scope of the declaration ended */

                if  (body && body->tnOper == TN_BLOCK)
                    save->tnBlock.tnBlkSrcEnd = body->tnBlock.tnBlkSrcEnd;
                else
                    save->tnBlock.tnBlkSrcEnd = ourScanner->scanGetTokenLno();

                parseCurScope = save->tnBlock.tnBlkParent;
                parseLastDecl = svld;
            }

            return  forx;
        }
        else
        {
            parseComp->cmpError(ERRnoLparen);

        BAD_FOR:

            parseResync(tkNone, tkNone);

            /* Pop the block scope if we created one */

            if  (save)
            {
                parseCurScope = save->tnBlock.tnBlkParent;
                parseLastDecl = svld;
            }

            tree = parseCreateErrNode();
        }
        break;

    case tkASSERT:

        if  (ourScanner->scan() != tkLParen)
        {
            tree = parseCreateErrNode(ERRnoLparen);
            break;
        }

        if  (parseComp->cmpConfig.ccAsserts)
        {
            ourScanner->scan();
            cond = parseExpr();
        }
        else
        {
            ourScanner->scanSkipText(tkLParen, tkRParen);
            cond = NULL;
        }

        chkCurTok(tkRParen, ERRnoRparen);

        tree = parseCreateOperNode(TN_ASSERT, cond, NULL);
        break;

    case tkBREAK:
        tree = parseCreateOperNode(TN_BREAK   , NULL, NULL);
        if  (ourScanner->scan() == tkID)
        {
            tree->tnOp.tnOp1 = parseCreateNameNode(ourScanner->scanTok.id.tokIdent);
            ourScanner->scan();
        }
        break;

    case tkCONTINUE:
        tree = parseCreateOperNode(TN_CONTINUE, NULL, NULL);
        if  (ourScanner->scan() == tkID)
        {
            tree->tnOp.tnOp1 = parseCreateNameNode(ourScanner->scanTok.id.tokIdent);
            ourScanner->scan();
        }
        break;

    case tkELSE:
        parseComp->cmpError(ERRbadElse);
        ourScanner->scan();
        return  parseFuncStmt();

    case tkGOTO:
        parseHadGoto = true;
        if  (ourScanner->scan() == tkID)
        {
            tree = parseCreateNameNode(parseScan->scanTok.id.tokIdent);
            ourScanner->scan();
            tree = parseCreateOperNode(TN_GOTO, tree, NULL);
        }
        else
        {
            tree = parseCreateErrNode(ERRnoIdent);
        }
        break;

    case tkTRY:
        return  parseTryStmt();

    case tkEXCLUSIVE:

        chkNxtTok(tkLParen, ERRnoLparen);
        cond = parseExpr();
        chkCurTok(tkRParen, ERRnoRparen);

        return  parseCreateOperNode(TN_EXCLUDE, cond, parseFuncStmt());

#ifdef  SETS

    case tkCONNECT:

        tree = parseCreateOperNode(TN_CONNECT, NULL, NULL);

        chkNxtTok(tkLParen, ERRnoLparen);
        tree->tnOp.tnOp1 = parseExprComma();
        chkCurTok(tkComma , ERRnoComma );
        tree->tnOp.tnOp2 = parseExprComma();
        chkCurTok(tkRParen, ERRnoRparen);

        break;

    case tkFOREACH:

        tree = parseCreateOperNode(TN_FOREACH, NULL, NULL);

        if  (ourScanner->scan() != tkLParen)
        {
            tree = parseCreateErrNode(ERRnoLparen);
            break;
        }

        if  (ourScanner->scan() == tkID)
        {
            Ident           name = parseScan->scanTok.id.tokIdent;

            if  (ourScanner->scan() == tkIN)
            {
                Tree            decl;

                /* Swallow the "in" token */

                ourScanner->scan();

                /* Preserve the current declaration list value(s) */

                svld = parseLastDecl; parseLastDecl = NULL;

                /* Add a new block entry to the current scope list */

                decl = parseCreateNode(TN_BLOCK);

                decl->tnFlags            |= TNF_BLK_FOR;
                decl->tnBlock.tnBlkStmt   = NULL;
                decl->tnBlock.tnBlkDecl   = NULL;
                decl->tnBlock.tnBlkParent = parseCurScope;
                                            parseCurScope = decl;

                /* Create and add a declaration entry for the iteration variable */

                parseLclDclDecl(parseLclDclMake(name, NULL, NULL, 0, false));

                /* Parse the collection expression */

                tree->tnOp.tnOp1 = parseCreateOperNode(TN_LIST, decl, parseExpr());

                /* Make sure we have a closing ")" */

                chkCurTok(tkRParen, ERRnoRparen);

                /* The loop body follows */

                tree->tnOp.tnOp2 = parseFuncBlock();

                /* Remove the block scope we have created */

                assert(decl->tnOper == TN_BLOCK);

                /* Record where the scope of the iteration variable ended */

                decl->tnBlock.tnBlkSrcEnd = ourScanner->scanGetTokenLno();

                /* Pop the scope (returning to the enclosing one) */

                parseCurScope = decl->tnBlock.tnBlkParent;
                parseLastDecl = svld;
            }
            else
            {
                tree = parseCreateErrNode(ERRnoIN);
            }
        }
        else
        {
            tree = parseCreateErrNode(ERRnoIdent);
        }

        return  tree;

#endif

    case tkSColon:
        tree = NULL;
        break;
    }

    if  (ourScanner->scanTok.tok == tkSColon)
    {
        ourScanner->scan();
    }
    else
    {
        if  (tree == NULL || tree->tnOper != TN_ERROR)
        {
            tree = parseCreateErrNode(ERRnoSemic);
            ourScanner->scanSkipText(tkNone, tkNone);
        }
    }

    return  tree;
}

/*****************************************************************************
 *
 *  Parse a statement block (the current token is assumed to be "{", except
 *  when this is the body of a loop statement).
 */

Tree                parser::parseFuncBlock(SymDef fsym)
{
    Scanner         ourScanner = parseScan;

    Tree            stmtBlock;
    Tree            stmtList = NULL;
    Tree            stmtLast = NULL;

    Tree            saveLastDecl;

    /* Preserve the current declaration list value(s) */

    saveLastDecl = parseLastDecl; parseLastDecl = NULL;

    /* Add a new block entry to the current scope list */

    stmtBlock = parseCreateNode(TN_BLOCK);

    stmtBlock->tnBlock.tnBlkStmt   = NULL;
    stmtBlock->tnBlock.tnBlkDecl   = NULL;
    stmtBlock->tnBlock.tnBlkParent = parseCurScope;
                                     parseCurScope = stmtBlock;

    /* Is this the outermost function scope? */

    if  (fsym)
    {
        TypDef          ftyp;
        ArgDef          args;

        /* Special case: injected local variable declaration */

        if  (fsym == parseComp->cmpGlobalNS)
        {
            stmtBlock->tnFlags |= TNF_BLK_CATCH;

            parseLclDclDecl(parseTryDecl);

            stmtBlock->tnBlock.tnBlkStmt = parseAddToNodeList(stmtBlock->tnBlock.tnBlkStmt,
                                                              stmtLast,
                                                              parseTryDecl);
            goto BODY;
        }

        /* Add declarations for all the arguments */

        ftyp = fsym->sdType; assert(ftyp && ftyp->tdTypeKind == TYP_FNC);

        for (args = ftyp->tdFnc.tdfArgs.adArgs; args; args = args->adNext)
        {
            Tree            decl;

            /* Create a declaration node for the argument */

            decl = parseLclDclMake(args->adName, args->adType, NULL, 0, true);
                   parseLclDclDecl(decl);

            /* Add the declaration to the list */

            stmtBlock->tnBlock.tnBlkStmt = parseAddToNodeList(stmtBlock->tnBlock.tnBlkStmt,
                                                              stmtLast,
                                                              decl);
        }

#ifdef  SETS
        if  (fsym->sdFnc.sdfFunclet) goto DONE;
#endif

        /* Reset the local variable count, we don't want to count args */

        parseLclVarCnt = 0;
    }
    else
    {
        if  (ourScanner->scanTok.tok != tkLCurly)
        {
            Tree            body = parseFuncStmt(true);

            if  (body)
                stmtBlock->tnBlock.tnBlkStmt = parseCreateOperNode(TN_LIST, body, NULL);

            stmtBlock->tnBlock.tnBlkSrcEnd = ourScanner->scanGetTokenLno();
            goto DONE;
        }
    }

BODY:

    /* Parse the contents of the block */

    assert(ourScanner->scanTok.tok == tkLCurly); ourScanner->scan();

    while (ourScanner->scanTok.tok != tkRCurly)
    {
        if  (ourScanner->scanTok.tok == tkSColon)
        {
            ourScanner->scan();
        }
        else
        {
            Tree            stmtNext;

            /* Parse the next statement and add it to the list */

            stmtNext = parseFuncStmt(true);

            if  (stmtNext)
            {
                stmtBlock->tnBlock.tnBlkStmt = parseAddToNodeList(stmtBlock->tnBlock.tnBlkStmt,
                                                                  stmtLast,
                                                                  stmtNext);
            }
        }

        /* See if have any more statements */

        if  (ourScanner->scanTok.tok == tkEOF)
            goto DONE;
    }

    /* We should be sitting at the closing "}" now, remember its position */

    assert(ourScanner->scanTok.tok == tkRCurly);
    stmtBlock->tnBlock.tnBlkSrcEnd = ourScanner->scanGetTokenLno();
    ourScanner->scan();

DONE:

    /* Pop the block scope */

    parseCurScope = stmtBlock->tnBlock.tnBlkParent;

    /* Restore the saved declaration list value(s) */

    parseLastDecl = saveLastDecl;

    return  stmtBlock;
}

/*****************************************************************************
 *
 *  Parse a function body.
 */

Tree                parser::parseFuncBody(SymDef fsym, Tree     *labels,
                                                       unsigned *locals,
                                                       bool     *hadGoto,
                                                       bool     *baseCT,
                                                       bool     *thisCT)
{
    Tree            block;

    /* We haven't seen any local declarations/labels/switches/etc. yet */

    parseLastDecl   = NULL;
    parseLabelList  = NULL;
    parseCurSwitch  = NULL;
    parseLclVarCnt  = 0;
    parseHadGoto    = false;

    /* We haven't see a call to a base/this constructor */

    parseBaseCTcall = false;
    parseThisCTcall = false;

    /* Parse the outermost function statement block */

    setErrorTrap(parseComp);
    begErrorTrap
    {
        assert(parseCurScope == NULL);

        /* Do we have a base class ctor call ? */

        if  (parseScan->scanTok.tok == tkColon)
        {
            Scanner         ourScanner = parseScan;

            SymDef          clsSym;
            Tree            baseCT;
            TypDef          baseTyp;

            /* We should find a call to the base class ctor */

            parseBaseCTcall = true;

            /* Make sure we have a base class */

            clsSym = fsym->sdParent;

            if  (!clsSym || clsSym->sdSymKind != SYM_CLASS)
            {
            BCT_BAD:
                parseComp->cmpError(ERRnoBaseInit);
                goto BCT_ERR;
            }

            baseTyp = clsSym->sdType->tdClass.tdcBase;
            if  (!baseTyp)
                goto BCT_BAD;

            switch (ourScanner->scan())
            {
            case tkID:

                /* The name better match the base class */

                if  (ourScanner->scanTok.id.tokIdent != baseTyp->tdClass.tdcSymbol->sdName)
                    goto BCT_BAD;
                break;

            case tkBASECLASS:
                break;

            default:
                parseComp->cmpError(ERRnoBaseInit);
                goto BCT_ERR;
            }

            /* Parse the base ctor argument list */

            if  (parseScan->scan() != tkLParen)
                goto BCT_BAD;

            baseCT = parseCreateOperNode(TN_CALL, parseCreateOperNode(TN_BASE, NULL, NULL),
                                                  parseExprList(tkRParen));

            /* The body of the ctor better follow */

            if  (ourScanner->scanTok.tok != tkLCurly)
            {
                parseComp->cmpError(ERRnoLcurly);

            BCT_ERR:

                /* Try to find the "{" of the body */

                UNIMPL(!"skip to '{' of the ctor body");
            }
            else
            {
                /* Process the body of the ctor */

                block = parseFuncBlock(fsym);

                /* Insert the base ctor call into the ctor body */

                if  (block)
                {
                    Tree            body = block->tnBlock.tnBlkStmt;

                    assert(block->tnOper == TN_BLOCK);
                    assert(body == NULL || body->tnOper == TN_LIST);

                    block->tnBlock.tnBlkStmt = parseCreateOperNode(TN_LIST,
                                                                   baseCT,
                                                                   body);
                }
            }
        }
        else
            block = parseFuncBlock(fsym);

        assert(parseCurScope == NULL);

        /* End of the error trap's "normal" block */

        endErrorTrap(parseComp);
    }
    chkErrorTrap(fltErrorTrap(parseComp, _exception_code(), NULL)) // _exception_info()))
    {
        /* Begin the error trap's cleanup block */

        hndErrorTrap(parseComp);

        block         = NULL;
        parseCurScope = NULL;
    }

    *labels  = parseLabelList;
    *locals  = parseLclVarCnt;
    *baseCT  = parseBaseCTcall;
    *thisCT  = parseThisCTcall;
    *hadGoto = parseHadGoto;

    return  block;
}

/*****************************************************************************
 *
 *  Return true if the current thing in the source file looks like a type.
 */

bool                parser::parseIsTypeSpec(bool noLookup, bool *labChkPtr)
{
    SymDef          tsym;
    tokens          nextTok;

    /* If it's clearly not a type specifier, we're done */

    if  (!parseHash->tokenBegsTyp(parseScan->scanTok.tok))
        return  false;

    /* Is there a leading scope operator? */

    if  (parseScan->scanTok.tok == tkColon2)
        goto QUALID;

    /* Do we have a qualified symbol? */

    if  (parseScan->scanTok.tok == tkQUALID)
    {
        tsym = parseScan->scanTok.qualid.tokQualSym;
        goto CHKSYM;
    }

    /* If it's an identifier, we have more checking to do */

    if  (parseScan->scanTok.tok != tkID)
        return  true;

    /* We have an identifier, see if it's a type or not */

    nextTok = parseScan->scanLookAhead();

    switch (nextTok)
    {
        Ident           name;

    case tkDot:
    case tkColon2:

        if  (noLookup)
            goto QUALCHK;

    QUALID:

        /* Here we have a qualified name, find the symbol it denotes */

        tsym = parseNameUse(true, true, true);
        if  (!tsym || parseScan->scanTok.tok != tkQUALID)
            return  false;

        break;

    case tkColon:

        if  (labChkPtr)
        {
            *labChkPtr = true;
            return  false;
        }

        return false;

    case tkLParen:

        // for now always assume that this is a function call

    case tkAsg:
    case tkAsgAdd:
    case tkAsgSub:
    case tkAsgMul:
    case tkAsgDiv:
    case tkAsgMod:
    case tkAsgAnd:
    case tkAsgXor:
    case tkAsgOr:
    case tkAsgLsh:
    case tkAsgRsh:
    case tkAsgCnc:

    case tkArrow:

    case tkIntCon:
    case tkLngCon:
    case tkFltCon:
    case tkDblCon:
    case tkStrCon:

        /* Just a short-cut to give up quicker ... */

        return  false;

    default:

        /* We have a simple identifier, see whether it's defined */

        name = parseScan->scanTok.id.tokIdent;

        if  (noLookup)
        {
            /* We can't really do lookups, so use heuristics */

        QUALCHK:

            for (;;)
            {
                switch (parseScan->scan())
                {
                case tkID:
                case tkAnd:
                case tkMul:
                case tkLBrack:
                    // UNDONE: add more things that start a type
                    return  true;

                case tkLParen:
                    // ISSUE: what's the right thing to do here?
                    return  true;

                case tkColon2:
                case tkDot:

                    if  (parseScan->scan() != tkID)
                        return  false;

                    continue;

                default:
                    return  false;
                }
            }
        }

        if  (nextTok == tkID)
        {
            /* Sure looks like a type, don't it? */

            tsym = parseStab->stLookupSym(name, NS_TYPE);
            if  (tsym)
                break;
        }

        /* If it's a local name, it can't be a type */

        if  (parseLookupSym(name))
            return  false;

        /* Look for a non-local name */

        tsym = parseStab->stLookupSym(name, (name_space)(NS_NORM|NS_TYPE));
        break;
    }

CHKSYM:

    /* We might have found a symbol, see if it represents a type */

    if  (tsym)
    {
        switch (tsym->sdSymKind)
        {
        case SYM_ENUM:
        case SYM_CLASS:
        case SYM_TYPEDEF:
        case SYM_NAMESPACE:
            return  true;
        }
    }

    return  false;
}

/*****************************************************************************
 *
 *  Return non-zero if the given operator may throw an exception.
 */

bool                TreeNode::tnOperMayThrow()
{
    // ISSUE: Are we missing any operations that could cause an exception?

    switch (tnOper)
    {
    case TN_DIV:
    case TN_MOD:
        return  varTypeIsIntegral(tnVtypGet());

    case TN_NEW:
    case TN_CALL:
    case TN_INDEX:
        return  true;
    }

    return  false;
}

/*****************************************************************************
 *
 *  Parse a "new" expression - this usually allocates a class or an array.
 */

Tree                parser::parseNewExpr()
{
    declMods        mods;
    TypDef          type;

    bool            mgdSave;

    Tree             newExpr;
    Tree            initExpr = NULL;

    Scanner         ourScanner = parseScan;

//  static int x; if (++x == 0) forceDebugBreak();

    /* Swallow the "new" token and check for management */

    assert(ourScanner->scanTok.tok == tkNEW);

    mgdSave = parseComp->cmpManagedMode;

    switch (ourScanner->scan())
    {
    case tkMANAGED:
        parseComp->cmpManagedMode = true;
        ourScanner->scan();
        break;

    case tkUNMANAGED:
        parseComp->cmpManagedMode = false;
        ourScanner->scan();
        break;
    }

    /* Check for any modifiers */

    parseDeclMods(ACL_DEFAULT, &mods);

    /* Make sure the modifiers are reasonable */

    if  (mods.dmMod & (DM_ALL & ~(DM_MANAGED|DM_UNMANAGED)))
    {
        UNIMPL(!"report bad new mod");
    }

    /* Parse the type specification */

    type = parseTypeSpec(&mods, true);
    if  (!type)
    {
        // ISSUE: probably should resync and return err node

    ERR:

        parseComp->cmpManagedMode = mgdSave;
        return  NULL;
    }

    /* Check for the special case of "classname(args)" */

    if  (ourScanner->scanTok.tok == tkLParen)
    {
        switch (type->tdTypeKind)
        {
        case TYP_CLASS:
            assert(type->tdClass.tdcValueType || !type->tdIsManaged);
            break;

        case TYP_REF:
            type = type->tdRef.tdrBase;
            assert(type->tdTypeKind == TYP_CLASS);
            assert(type->tdIsManaged);
            assert(type->tdClass.tdcValueType == false);
            break;

        case TYP_ENUM:

            if  (type->tdIsManaged)
                break;

            // Fall through ...

        default:

            if  (type->tdTypeKind > TYP_lastIntrins)
                goto NON_CLS;

            type = parseComp->cmpFindStdValType(type->tdTypeKindGet());
            break;

        case TYP_UNDEF:
            return  parseCreateErrNode();
        }

        /* Parse the ctor argument list */

#ifdef  SETS
        if  (type->tdTypeKind == TYP_CLASS && type->tdClass.tdcSymbol->sdClass.sdcXMLelems)
            initExpr = parseXMLctorArgs(type->tdClass.tdcSymbol);
        else
#endif
        initExpr = parseExprList(tkRParen);
    }
    else
    {
        /* Parse the declarator */

NON_CLS:

        // ISSUE: Can't tell whether "char[size]" s/b a managed array or not!

        parseDeclarator(&mods, type, DN_NONE, &type, NULL, true);
        if  (!type)
            goto ERR;

        type = parseComp->cmpDirectType(type);

        /* What kind of a type is being allocated? */

        switch (type->tdTypeKind)
        {
        case TYP_REF:

            type = type->tdRef.tdrBase;
            assert(type->tdTypeKind == TYP_CLASS);

            // Fall through ...

        case TYP_CLASS:

            if  (ourScanner->scanTok.tok == tkLParen)
                initExpr = parseExprList(tkRParen);

            break;

        case TYP_ARRAY:

            if  (ourScanner->scanTok.tok == tkLCurly)
                initExpr = parseInitExpr();

            break;

        default:

            /* Presumably an unmanaged allocation */

            type = parseStab->stNewRefType(TYP_PTR, type);
            break;
        }
    }

    newExpr = parseCreateOperNode(TN_NEW, initExpr, NULL);
    newExpr->tnType = type;

    parseComp->cmpManagedMode = mgdSave;

    return  newExpr;
}

/*****************************************************************************
 *
 *  Swallow a security 'action' specifier.
 */

struct  capDesc
{
    const   char *      cdName;
    CorDeclSecurity     cdSpec;
};

CorDeclSecurity     parser::parseSecAction()
{
    const   char *  name;
    CorDeclSecurity spec;

    capDesc      *  capp;

    static
    capDesc         caps[] =
    {
        { "request",      dclRequest          },
        { "demand",       dclDemand           },
//      { "assert",       dclAssert           },
        { "deny",         dclDeny             },
        { "permitonly",   dclPermitOnly       },
        { "linkcheck",    dclLinktimeCheck    },
        { "inheritcheck", dclInheritanceCheck },

        {     NULL      , dclActionNil        }
    };

    if  (parseScan->scanTok.tok != tkID)
    {
        if  (parseScan->scanTok.tok == tkASSERT)
        {
            parseScan->scan();
            return  dclAssert;
        }

        UNIMPL("weird security spec, what to do?");
    }

    name = parseScan->scanTok.id.tokIdent->idSpelling();

    for (capp = caps; ; capp++)
    {
        if  (!capp->cdName)
        {
            parseComp->cmpGenError(ERRbadSecActn, name);
            spec = capp->cdSpec;
            break;
        }

        if  (!strcmp(name, capp->cdName))
        {
            spec = capp->cdSpec;
            break;
        }
    }

    parseScan->scan();

    return  spec;
}

/*****************************************************************************
 *
 *  Parse a capability specifier.
 */

SecurityInfo        parser::parseCapability(bool forReal)
{
    Scanner         ourScanner = parseScan;

    CorDeclSecurity spec;
    SecurityInfo    info = NULL;

    assert(ourScanner->scanTok.tok == tkCAPABILITY); ourScanner->scan();

    /* The security action comes first */

    spec = parseSecAction();

    /* Next comes the expression that yields the GUID/url */

    if  (forReal)
    {
        constVal        cval;

        if  (parseConstExpr(cval, NULL, parseComp->cmpStringRef(), NULL))
        {
            assert(cval.cvIsStr);

            /* Allocate and fill in a security descriptor */

#if MGDDATA
            info = new SecurityInfo;
#else
            info =    (SecurityInfo)parseAllocPerm->nraAlloc(sizeof(*info));
#endif

            info->sdSpec    = spec;
            info->sdIsPerm  = false;
            info->sdCapbStr = cval.cvValue.cvSval;
        }
    }
    else
    {
        parseComp->cmpErrorMssgDisabled++;
        parseExprComma();
        parseComp->cmpErrorMssgDisabled--;
    }

    return  info;
}

/*****************************************************************************
 *
 *  Parse a permission specifier.
 */

SecurityInfo        parser::parsePermission(bool forReal)
{
    Scanner         ourScanner = parseScan;

    CorDeclSecurity spec;
    SecurityInfo    info = NULL;

    SymDef          clss = NULL;

    PairList        list = NULL;
    PairList        last = NULL;

//  __permission deny   UIPermission(unrestricted=true) void f(){}
//  __permission demand UIPermission(unrestricted=true) void g(){}

    assert(ourScanner->scanTok.tok == tkPERMISSION); ourScanner->scan();

    /* The security action comes first */

    spec = parseSecAction();

    /* Next comes a reference to a class name */

    if  (forReal)
    {
        clss = parseNameUse(true, false, false);

        if  (clss && clss->sdSymKind != SYM_CLASS)
            parseComp->cmpError(ERRnoClassName);
    }
    else
        parseQualName(false);

    /* Now we expect a parenthesised list of [name=value] pairs */

    if  (ourScanner->scanTok.tok != tkLParen)
    {
        parseComp->cmpError(ERRnoLparen);
        // ISSUE: error recovery?
        return  NULL;
    }

    for (;;)
    {
        Ident           name;

        /* First we must have an identifier */

        if  (ourScanner->scan() != tkID)
        {
            parseComp->cmpError(ERRnoIdent);
            UNIMPL(!"error recovery");
        }

        name = ourScanner->scanTok.id.tokIdent;

        /* Next comes the "= value" part */

        if  (ourScanner->scan() != tkAsg)
        {
            parseComp->cmpError(ERRnoEqual);
            UNIMPL(!"error recovery");
        }

        ourScanner->scan();

        if  (forReal)
        {
            PairList        next;

            /* Allocate and fill in a pair entry and append it to the list */

#if MGDDATA
            next = new PairList;
#else
            next =    (PairList)parseAllocPerm->nraAlloc(sizeof(*next));
#endif

            next->plName  = name;
            next->plNext  = NULL;

            if  (last)
                last->plNext = next;
            else
                list         = next;
            last = next;

            /* Fill in the value */

            switch (ourScanner->scanTok.tok)
            {
            case tkFALSE:
                next->plValue = false;
                ourScanner->scan();
                break;

            case tkTRUE:
                next->plValue = true;
                ourScanner->scan();
                break;

            default:
                UNIMPL(!"sorry, only true/false supported for now");
            }
        }
        else
        {
            parseExprComma();
        }

        /* Do we have any more values? */

        if  (ourScanner->scanTok.tok != tkComma)
            break;
    }

    chkCurTok(tkRParen, ERRnoRparen);

    if  (forReal)
    {
        /* Allocate and fill in a security descriptor */

#if MGDDATA
        info = new SecurityInfo;
#else
        info =    (SecurityInfo)parseAllocPerm->nraAlloc(sizeof(*info));
#endif

        info->sdSpec           = spec;
        info->sdIsPerm         = true;
        info->sdPerm.sdPermCls = clss;
        info->sdPerm.sdPermVal = list;
    }

    return  info;
}

/*****************************************************************************
 *
 *  Parse a formal paremeter list for a generic class.
 */

GenArgDscF          parser::parseGenFormals()
{
    Scanner         ourScanner = parseScan;

    GenArgDscF      paramList;
    GenArgDscF      paramLast;
    GenArgDscF      paramNext;

    assert(ourScanner->scanTok.tok == tkLT);

    for (paramList = paramLast = NULL;;)
    {
        /* We should have "class foo" here */

        if  (ourScanner->scan() != tkCLASS)
        {
            parseComp->cmpError(ERRnoClsGt);

        ERR:

            parseScan->scanSkipText(tkNone, tkNone, tkGT);

            if  (ourScanner->scanTok.tok == tkGT)
                ourScanner->scan();

            return  NULL;
        }

        if  (ourScanner->scan() != tkID)
        {
            parseComp->cmpError(ERRnoIdent);
            goto ERR;
        }

        /* Add a new entry to the parameter list */

#if MGDDATA
        paramNext = new GenArgRecF;
#else
        paramNext =    (GenArgRecF*)parseAllocPerm->nraAlloc(sizeof(*paramNext));
#endif

        paramNext->gaName = ourScanner->scanTok.id.tokIdent;
#ifdef  DEBUG
        paramNext->gaBound = false;
#endif
        paramNext->gaNext  = NULL;

        if  (paramLast)
             paramLast->gaNext = paramNext;
        else
             paramList         = paramNext;

        paramLast = paramNext;

        /* Check for (optional) base class and/or interfaces */

        if  (ourScanner->scan() == tkColon)
        {
            UNIMPL(!"generic arg - skip base spec");
        }

        if  (ourScanner->scanTok.tok == tkIMPLEMENTS)
        {
            UNIMPL(!"generic arg - skip intf spec");
        }

        if  (ourScanner->scanTok.tok == tkINCLUDES)
        {
            UNIMPL(!"generic arg - skip incl spec");
        }

        /* Are there any more arguments? */

        if  (ourScanner->scanTok.tok == tkGT)
            break;

        if  (ourScanner->scanTok.tok == tkComma)
            continue;

        parseComp->cmpError(ERRnoCmGt);
        goto ERR;
    }

    assert(ourScanner->scanTok.tok == tkGT); ourScanner->scan();

    return  paramList;
}

/*****************************************************************************
 *
 *  Parse a generic class actual paremeter list, i.e. "cls<arg,arg,..>". As a
 *  special case, the caller may pass in an optional second argument and in
 *  that case we pretend that the type was the single argument given for the
 *  specific type.
 */

SymDef              parser::parseSpecificType(SymDef clsSym, TypDef elemTp)
{
    Scanner         ourScanner = parseScan;
    Compiler        ourComp    = parseComp;

    GenArgDscF      formals;

    GenArgDscA      argList;
    GenArgDscA      argLast;
    GenArgDscA      argNext;

    SymList         instList;

    SymDef          instSym;

    assert(clsSym);
    assert(clsSym->sdSymKind == SYM_CLASS);
    assert(clsSym->sdClass.sdcGeneric  != false);
    assert(clsSym->sdClass.sdcSpecific == false);

    /* Before we do anything, make sure the generic class is declared */

    if  (clsSym->sdCompileState < CS_DECLARED)
        ourComp->cmpDeclSym(clsSym);

    /* Special case: caller-supplied single argument */

    if  (elemTp)
    {
        /* Create an actual argument list with a single entry */

        if  (ourComp->cmpGenArgAfree)
        {
            argNext = ourComp->cmpGenArgAfree;
                      ourComp->cmpGenArgAfree = (GenArgDscA)argNext->gaNext;

            assert(argNext->gaBound == true);
        }
        else
        {
#if MGDDATA
            argNext = new GenArgRecA;
#else
            argNext =    (GenArgRecA*)parseAllocPerm->nraAlloc(sizeof(*argNext));
#endif
        }

        argNext->gaType  = elemTp;
#ifdef  DEBUG
        argNext->gaBound = true;
#endif
        argNext->gaNext  = NULL;

        argList =
        argLast = argNext;

        goto GOT_ARGS;
    }

    /* Process the list of the actual arguments */

    argList = argLast = NULL;

    /* We should be sitting at the opening "<" of the argument list */

    assert(ourScanner->scanTok.tok == tkLT);

    ourScanner->scanNestedGT(+1);

    for (formals = (GenArgDscF)clsSym->sdClass.sdcArgLst;
         formals;
         formals = (GenArgDscF)formals->gaNext)
    {
        TypDef          argType;

        assert(formals->gaBound == false);

        /* Make sure there is another argument */

        if  (ourScanner->scan() == tkGT)
        {
            ourComp->cmpError(ERRmisgGenArg, formals->gaName);

            UNIMPL(!"need to flag the instance type as bogus, right?");
            break;
        }

        /* Parse the actual type */

        argType = parseType();

        /* The type better be a managed class/interface */

        if  (argType->tdTypeKind != TYP_REF)
        {
        ARG_ERR:
            ourComp->cmpGenError(ERRgenArg, formals->gaName->idSpelling());
            argType = NULL;
        }
        else
        {
            argType = argType->tdRef.tdrBase;

            if  (argType->tdTypeKind != TYP_CLASS || !argType->tdIsManaged)
                goto ARG_ERR;

            /* Verify that the actual type satisfies all requirements */

            if  (formals->gaBase)
            {
                if  (!ourComp->cmpIsBaseClass(formals->gaBase, argType))
                {
                    ourComp->cmpGenError(ERRgenArgBase, formals->gaName->idSpelling(),
                                                        formals->gaBase->tdClass.tdcSymbol->sdSpelling());
                }
            }

            if  (formals->gaIntf)
            {
                UNIMPL(!"check intf");
            }
        }

        /* Add an entry to the actual argument list */

        if  (ourComp->cmpGenArgAfree)
        {
            argNext = ourComp->cmpGenArgAfree;
                      ourComp->cmpGenArgAfree = (GenArgDscA)argNext->gaNext;

            assert(argNext->gaBound == true);
        }
        else
        {
#if MGDDATA
            argNext = new GenArgRecA;
#else
            argNext =    (GenArgRecA*)parseAllocPerm->nraAlloc(sizeof(*argNext));
#endif
        }

        argNext->gaType  = argType;

#ifdef  DEBUG
        argNext->gaBound = true;
#endif

        argNext->gaNext  = NULL;

        if  (argLast)
             argLast->gaNext = argNext;
        else
             argList         = argNext;

        argLast = argNext;

        if  (ourScanner->scanTok.tok == tkComma)
            continue;

        if  (formals->gaNext)
        {
            if  (ourScanner->scanTok.tok == tkGT)
                ourComp->cmpError(ERRmisgGenArg, formals->gaName);
            else
                ourComp->cmpError(ERRnoComma);

            UNIMPL(!"need to flag the instance type as bogus, right?");
        }

        break;
    }

    if  (ourScanner->scanTok.tok != tkGT)
    {
        ourComp->cmpError(ERRnoGt);

        if  (ourScanner->scanTok.tok == tkComma)
        {
            /* Presumably we have excess arguments, so skip them */

            UNIMPL(!"swallow excess args, skip to closing '>'");
        }
    }
    else
        ourScanner->scan();

    ourScanner->scanNestedGT(-1);

GOT_ARGS:

    /* Look for an existing instance that matches ours */

    for (instList = clsSym->sdClass.sdcInstances;
         instList;
         instList = instList->slNext)
    {
        GenArgDscA      arg1;
        GenArgDscA      arg2;

        assert(instList->slSym->sdSymKind == SYM_CLASS);
        assert(instList->slSym->sdClass.sdcGeneric  == false);
        assert(instList->slSym->sdClass.sdcSpecific != false);

        /* Compare the argument types */

        arg1 = argList;
        arg2 = (GenArgDscA)instList->slSym->sdClass.sdcArgLst;

        do
        {
            TypDef          typ1 = arg1->gaType;
            TypDef          typ2 = arg2->gaType;

            assert(arg1 && arg1->gaBound);
            assert(arg2 && arg2->gaBound);

            /* If this argument doesn't match, give up on this instance */

            if  (!symTab::stMatchTypes(typ1, typ2))
                goto CHK_NXT;

#ifdef  SETS

            /* If the types are similar but different classes, no match */

            if  (typ1 != typ2 && typ1->tdTypeKind == TYP_CLASS
                              && typ1->tdClass.tdcSymbol->sdClass.sdcPODTclass)
            {
                goto CHK_NXT;
            }

#endif

            arg1 = (GenArgDscA)arg1->gaNext;
            arg2 = (GenArgDscA)arg2->gaNext;
        }
        while (arg1);

        /* Looks like we've got ourselves a match! */

        assert(arg2 == NULL);

        /* Move the argument list we've created to the free list */

        argLast->gaNext = ourComp->cmpGenArgAfree;
                          ourComp->cmpGenArgAfree = argList;

        /* Return the existing instance symbol */

        return  instList->slSym;

    CHK_NXT:;

    }

    /* Declare a new instance symbol + type */

    instSym = parseStab->stDeclareSym(clsSym->sdName,
                                      SYM_CLASS,
                                      NS_HIDE,
                                      clsSym->sdParent);

    instSym->sdAccessLevel        = clsSym->sdAccessLevel;
    instSym->sdIsManaged          = clsSym->sdIsManaged;
    instSym->sdClass.sdcFlavor    = clsSym->sdClass.sdcFlavor;
    instSym->sdCompileState       = CS_KNOWN;

    instSym->sdClass.sdcSpecific  = true;
    instSym->sdClass.sdcArgLst    = argList;
    instSym->sdClass.sdcGenClass  = clsSym;
    instSym->sdClass.sdcHasBodies = clsSym->sdClass.sdcHasBodies;

    /* Set the base class of the instance equal to the generic type */

    instSym->sdTypeGet()->tdClass.tdcBase = clsSym->sdType;

    /* Add the class to the list of instances of the generic class */

#if MGDDATA
    instList = new SymList;
#else
    instList =    (SymList)parseAllocPerm->nraAlloc(sizeof(*instList));
#endif

    instList->slSym  = instSym;
    instList->slNext = clsSym->sdClass.sdcInstances;
                       clsSym->sdClass.sdcInstances = instList;

    return  instSym;
}

/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************
 *
 *  Parse a collection/set expression - all/unique/exists/filter/etc.
 */

Tree                parser::parseSetExpr(treeOps oper)
{
    Tree            name;
    Tree            expr;
    Tree            decl;
    Tree            coll;
    Tree            dccx;
    Tree            svld;

    bool            cscp;

    tokens          iniTok;

    Scanner         ourScanner = parseScan;

    /* Create the main operator node */

    assert(oper == TN_ALL     ||
           oper == TN_EXISTS  ||
           oper == TN_FILTER  ||
           oper == TN_GROUPBY ||
           oper == TN_PROJECT ||
           oper == TN_SORT    ||
           oper == TN_UNIQUE);

    expr = parseCreateOperNode(oper, NULL, NULL);

    /* Make sure we have '(' */

    iniTok = ourScanner->scanTok.tok;

    if  (iniTok == tkLParen)
        ourScanner->scan();
    else
        parseComp->cmpError(ERRnoLparen);

    /* Is this a projection ? */

    if  (oper == TN_PROJECT)
    {
        TypDef          tgtType;

        bool            implScp = false;

        Tree            argList = NULL;
        Tree            argLast = NULL;

        /* We'll definitely need to open a scope */

        cscp = true;

        /* Preserve the current declaration list value(s) */

        svld = parseLastDecl; parseLastDecl = NULL;

        /* Add a new block entry to the current scope list */

        decl = parseCreateNode(TN_BLOCK);

        decl->tnBlock.tnBlkStmt   = NULL;
        decl->tnBlock.tnBlkDecl   = NULL;
        decl->tnBlock.tnBlkParent = parseCurScope;
                                    parseCurScope = decl;

        /* Process any and all operands */

        if  (ourScanner->scanTok.tok != tkColon &&
             ourScanner->scanTok.tok != tkRParen)
        {
            for (;;)
            {
                Ident           argIden;
                Tree            argName;
                Tree            argDesc;

                /* Check for an explicit range variable declaration */

                if  (ourScanner->scanTok.tok == tkID && ourScanner->scanLookAhead() == tkIN)
                {
                    argIden = ourScanner->scanTok.id.tokIdent;
                    argName = parseLclDclMake(argIden, NULL, NULL, 0, false);

                    ourScanner->scan(); assert(ourScanner->scanTok.tok == tkIN);
                    ourScanner->scan();
                }
                else
                {
                    if  (implScp)
                        parseComp->cmpError(ERRmultImpl);

                    implScp = true;

                    argIden = parseComp->cmpNewAnonymousName();
                    argName = parseLclDclMake(argIden, NULL, NULL, 0, false);
                }

                /* Create a list entry for the operand */

                argDesc = parseCreateOperNode(TN_LIST, parseCreateNameNode(argIden),
                                                       parseExprComma());

                argList = parseAddToNodeList(argList, argLast, argDesc);

                /* Insert the declaration entry for the iteration variable */

                argName->tnFlags |= TNF_VAR_UNREAL;
                parseLclDclDecl(argName);

                /* Are there any more arguments? */

                if  (parseScan->scanTok.tok != tkComma)
                    break;

                parseScan->scan();
            }
        }

        if  (ourScanner->scanTok.tok != tkColon)
        {
            expr = parseCreateErrNode(ERRnoColon);
            goto DONE;
        }

        /* Next thing better be a typename of {} declaration */

        switch (ourScanner->scan())
        {
        case tkUNION:
        case tkCLASS:
        case tkSTRUCT:
            UNIMPL("for now just say 'typename' or '{ ... }' please");

        case tkLCurly:
            tgtType = parseAnonType(argList);
            break;

        default:
            UNIMPL("trying to use a typename or something?");

            /* UNDONE: Make sure the type is an acceptable one */

            break;
        }

        /* The last thing better be a ")" */

        if  (ourScanner->scanTok.tok != tkRParen)
        {
            expr = parseCreateErrNode(ERRnoRparen);
            goto DONE;
        }

        expr->tnType     = tgtType;
        expr->tnOp.tnOp1 = argList;
        expr->tnOp.tnOp2 = decl;

        goto DONE;
    }

    /* Check for an explicit range variable declaration */

    if  (ourScanner->scanTok.tok == tkID && ourScanner->scanLookAhead() == tkIN)
    {
        name = parseLclDclMake(ourScanner->scanTok.id.tokIdent, NULL, NULL, 0, false);
        cscp = true;

        ourScanner->scan(); assert(ourScanner->scanTok.tok == tkIN);
        ourScanner->scan();
    }
    else
    {
        name = NULL;
        cscp = false;
    }

    /* Next we should have the collection expression */

    coll = parseExpr();
    dccx = parseCreateOperNode(TN_LIST, NULL, coll);

    /* Store the list node in the operator node */

    expr->tnOp.tnOp1 = dccx;

    /* Is there a constraint/ordering specification ? */

    if  (ourScanner->scanTok.tok == tkColon)
    {
        /* We certainly need to create a scope */

        cscp = true;

        /* Preserve the current declaration list value(s) */

        svld = parseLastDecl; parseLastDecl = NULL;

        /* Add a new block entry to the current scope list */

        decl = parseCreateNode(TN_BLOCK);

        decl->tnBlock.tnBlkStmt   = NULL;
        decl->tnBlock.tnBlkDecl   = NULL;
        decl->tnBlock.tnBlkParent = parseCurScope;
                                    parseCurScope = decl;

        /* Insert the declaration entry for the iteration variable */

        if  (!name)
            name = parseLclDclMake(parseComp->cmpNewAnonymousName(), NULL, NULL, 0, false);

        name->tnFlags |= TNF_VAR_UNREAL;
        parseLclDclDecl(name);

        /* Swallow the colon and parse the filter/sort part */

        ourScanner->scan();

        if  (oper == TN_SORT)
        {
            Tree            sortList = NULL;
            Tree            sortLast = NULL;

            for (;;)
            {
                Tree            sortNext = parseCreateOperNode(TN_LIST, NULL, NULL);

                /* Check for a sort direction indicator */

                switch (ourScanner->scanTok.tok)
                {
                case tkDES:
                    sortNext->tnFlags |= TNF_LIST_DES;
                case tkASC:
                    ourScanner->scan();
                    break;
                }

                /* Parse the next sort value */

                sortNext->tnOp.tnOp1 = parseExprComma();

                /* Append the entry to the list */

                if  (sortLast)
                    sortLast->tnOp.tnOp2 = sortNext;
                else
                    sortList             = sortNext;

                sortLast = sortNext;

                /* Are there more arguments? */

                if  (ourScanner->scanTok.tok != tkComma)
                    break;

                ourScanner->scan();
            }

            expr->tnOp.tnOp2 = sortList;
        }
        else
        {
            expr->tnOp.tnOp2 = parseExpr();
        }
    }
    else
    {
        /* The operand better be an [[ ]] operator */

        if  (coll->tnOper != TN_INDEX2 || oper == TN_SORT || cscp)
        {
            expr = parseCreateErrNode(ERRnoSetCons);
            decl = NULL;
        }
        else
        {
            Tree            list;
            Tree            filt;

            /* The [[]] expression should have a filter but no sort */

            list = coll->tnOp.tnOp2; assert(list && list->tnOper == TN_LIST);
            filt = list->tnOp.tnOp1;

            /* Any sort clause would be meaningless in this context */

            if  (list->tnOp.tnOp2)
                return  parseCreateErrNode(ERRignSort);

            assert(filt);

            /* Update the collection / filter / declaration values */

            list = coll->tnOp.tnOp1; assert(list && list->tnOper == TN_LIST);

            decl             = list->tnOp.tnOp1; assert(decl);
            dccx->tnOp.tnOp2 = list->tnOp.tnOp2;
            expr->tnOp.tnOp2 = filt;
        }
    }

    /* Store the declaration in the proper place within the expression */

    dccx->tnOp.tnOp1 = decl; assert(decl == NULL || decl->tnOper == TN_BLOCK);

DONE:

    /* Remove the block scope if we have created one */

    if  (cscp)
    {
        assert(decl);

        /* Record where the scope of the declaration ended */

        decl->tnBlock.tnBlkSrcEnd = ourScanner->scanGetTokenLno();

        /* Pop the scope (returning to the enclosing one) */

        parseCurScope = decl->tnBlock.tnBlkParent;
        parseLastDecl = svld;
    }

    /* Check for the closing ')' before returning */

    if  (ourScanner->scanTok.tok == tkRParen)
        ourScanner->scan();
    else if (iniTok == tkLParen)
        parseComp->cmpError(ERRnoRparen);

    return  expr;
}

/*****************************************************************************/
#endif//SETS
/*****************************************************************************
 *
 *  Parse a custom attribute thingie. When parsing "for real" (i.e. when the
 *  value of "tgtMask" is non-zero), we actually create the serialized blob
 *  value and return the constructor that is to be called.
 */

SymDef              parser::parseAttribute(unsigned         tgtMask,
                                       OUT unsigned     REF useMask,
                                       OUT genericBuff  REF blobAddr,
                                       OUT size_t       REF blobSize)
{
    SymDef          clsSym;
    Tree            args;

    Scanner         ourScanner = parseScan;

    assert(ourScanner->scanTok.tok == tkATTRIBUTE);

    if  (!tgtMask)
    {
        /* First skip the class name that's supposed to follow */

        do
        {
            if  (ourScanner->scan() != tkID)
            {
                parseComp->cmpError(ERRnoIdent);
                return  NULL;
            }

            ourScanner->scan();
        }
        while (ourScanner->scanTok.tok == tkDot ||
               ourScanner->scanTok.tok == tkColon2);

        if  (ourScanner->scanTok.tok != tkLParen)
        {
            parseComp->cmpError(ERRnoRparen);
            return  NULL;
        }

        ourScanner->scanSkipText(tkLParen, tkRParen);
        chkCurTok(tkRParen, ERRnoRparen);

        return  NULL;
    }

    /* The first thing better be a class marked as "attribute" */

    ourScanner->scan();

    clsSym = parseNameUse(true, false, false);

    if  (clsSym)
    {
        if  (clsSym->sdSymKind == SYM_CLASS) // && clsSym->sdClass.sdcAttribute)
        {
//          ctrSym = parseStab->stLookupOperND(OVOP_CTOR_INST, clsSym);
        }
        else
        {
            if  (clsSym->sdSymKind != SYM_ERR)
                parseComp->cmpErrorQnm(ERRnotAclass, clsSym);

            clsSym = NULL;
        }
    }

    /* Now parse the ctor argument list */

    args = parseExprList(tkRParen);

    /* If we had no errors, go process the ctor call */

    if  (clsSym)
    {
        SymDef          ctrSym;

        /* Let the compiler take care of binding the sucker */

        ctrSym = parseComp->cmpBindAttribute(clsSym, args, tgtMask,
                                                           useMask, blobAddr,
                                                                    blobSize);
        if  (ctrSym)
            return  ctrSym;
    }

    /* Something went wrong, return an empty blob / NULL ctor */

    blobAddr = NULL;
    blobSize = 0;

    return  NULL;
}

/*****************************************************************************
 *
 *  Parse an [attribute] thing or a linkage specifier: extern("linkname").
 */

#ifndef __SMC__
extern  const char    *     attrNames[];    // in macros.*
#endif

SymXinfo            parser::parseBrackAttr(bool     forReal,
                                           unsigned OKmask,
                                           DeclMod  modsPtr)
{
    Scanner         ourScanner = parseScan;

    char    *       DLLname;
    char    *       SYMname;
    callingConvs    callCnv;
    unsigned        strVal;
    bool            lstErr;

    constVal        cval;
    const   char *  name;
    unsigned        attr;

    if  (ourScanner->scanTok.tok == tkEXTERN)
    {
        SymXinfoLnk     entry;

        assert(modsPtr);

        /* The caller has already checked that "(" follows */

        ourScanner->scan(); assert(ourScanner->scanTok.tok == tkLParen);

        /* The next thing should be the linkage name */

        if  (ourScanner->scan() != tkStrCon)
        {
        NO_STR:
            parseComp->cmpError(ERRnoLinkStr);
            parseResync(tkLParen, tkRParen);
            return  NULL;
        }

        /* Are we just skipping the thing for now ? */

        if  (!forReal)
        {
            if  (ourScanner->scanLookAhead() == tkComma)
            {
                ourScanner->scan();

                if  (ourScanner->scan() != tkStrCon)
                    goto NO_STR;
            }

            chkNxtTok(tkRParen, ERRnoRparen);

            parseDeclMods(ACL_DEFAULT, modsPtr); modsPtr->dmMod |= DM_EXTERN;

            return  NULL;
        }

        DLLname = NULL;
        SYMname = NULL;
        strVal  = 0;
        lstErr  = false;

        /* Is there a separate string for the entry point ? */

        if  (ourScanner->scanLookAhead() == tkComma)
        {
            size_t          strLen;

            /* Save the DLL name string */

            strLen  = ourScanner->scanTok.strCon.tokStrLen;
            DLLname = (char*)parseAllocPerm->nraAlloc(roundUp(strLen+1));
            memcpy(DLLname, ourScanner->scanTok.strCon.tokStrVal, strLen+1);

            /* We should have a comma followed by another string */

            ourScanner->scan();

            if  (ourScanner->scan() != tkStrCon)
                goto NO_STR;

            /* Save the entry point name string */

            strLen  = ourScanner->scanTok.strCon.tokStrLen;
            SYMname = (char*)parseAllocPerm->nraAlloc(roundUp(strLen+1));
            memcpy(SYMname, ourScanner->scanTok.strCon.tokStrVal, strLen+1);
        }
        else
        {
            const   char *  str = ourScanner->scanTok.strCon.tokStrVal;
            size_t          len = ourScanner->scanTok.strCon.tokStrLen;

            const   char *  col;

            /* The string should have the format "DLLname:entrypoint" */

            col = strchr(str, ':');

            if  (col && col > str && col < str + len - 1)
            {
                size_t          DLLnlen;
                size_t          SYMnlen;

                DLLnlen = col - str;
                SYMnlen = str + len - col;

#if MGDDATA
                UNIMPL(!"save nane strings");
#else
                DLLname = (char*)parseAllocPerm->nraAlloc(roundUp(DLLnlen+1));
                SYMname = (char*)parseAllocPerm->nraAlloc(roundUp(SYMnlen+1));

                memcpy(DLLname, str  , DLLnlen); DLLname[DLLnlen] = 0;
                memcpy(SYMname, col+1, SYMnlen); SYMname[SYMnlen] = 0;
#endif

            }
            else
            {
                parseComp->cmpError(ERRbadLinkStr);
            }
        }

        chkNxtTok(tkRParen, ERRnoRparen);

        /* default to "cdecl" for extern-style imports */

        callCnv = CCNV_CDECL;

    SAVE_LINK:

//      printf("DLL name: '%s'\n", DLLname);
//      printf("SYM name: '%s'\n", SYMname);

        /* Allocate a linkage descriptor and save the info */

#if MGDDATA
        entry = new SymXinfoLnk;
#else
        entry =    (SymXinfoLnk)parseAllocPerm->nraAlloc(sizeof(*entry));
#endif

        entry->xiKind = XI_LINKAGE;
        entry->xiNext = NULL;

        entry->xiLink.ldDLLname = DLLname;
        entry->xiLink.ldSYMname = SYMname;
        entry->xiLink.ldStrings = strVal;
        entry->xiLink.ldLastErr = lstErr;
        entry->xiLink.ldCallCnv = callCnv;

        /* Grab any further modifiers that might be present */

        if  (modsPtr)
        {
            parseDeclMods(ACL_DEFAULT, modsPtr);
                                       modsPtr->dmMod |= DM_EXTERN;
        }

        return  entry;
    }

    /* Here we must have a bracketed attribute deal */

    assert(ourScanner->scanTok.tok == tkLBrack);

    /* Skip the "[" and make sure an attribute name follows */

    if  (ourScanner->scan() == tkID)
    {
        name = ourScanner->scanTok.id.tokIdent->idSpelling();
    }
    else
    {
        if  (ourScanner->scanTok.tok > tkKwdLast)
        {
        ATTR_ERR:
            parseComp->cmpError(ERRbadAttr);

        ATTR_SKIP:
            parseResync(tkRBrack, tkNone);
            if  (ourScanner->scanTok.tok == tkRBrack)
                ourScanner->scan();
            return  NULL;
        }

        name = parseHash->tokenToIdent(ourScanner->scanTok.tok)->idSpelling();
    }

    /* Check for a recognized attribute name [linear search via strcmp - hmm ...] */

    for (attr = 0; attr < ATTR_COUNT; attr++)
    {
        if  (!strcmp(name, attrNames[attr]))
        {
            /* Match - make sure the attribute is acceptable here */

            if  (!(OKmask & (1 << attr)) && OKmask)
            {
                parseComp->cmpError(ERRplcAttr);
                goto ATTR_SKIP;
            }

            switch (attr)
            {
            case ATTR_SYS_IMPORT:
                goto LINK;

            case ATTR_GUID:

                // [guid(string)]

                if  (ourScanner->scan() == tkLParen)
                {
                    SymXinfoAtc     entry;

                    if  (ourScanner->scan() == tkRParen)
                        goto ATTR_ERR;

                    if  (forReal)
                    {
                        if  (parseConstExpr(cval, NULL, parseComp->cmpStringRef(), NULL))
                        {
                            AtComment       adesc;
                            GUID            GUID;

                            assert(cval.cvIsStr);

                            /* Make sure the string is valid */

                            if  (parseGUID(cval.cvValue.cvSval->csStr, &GUID, false))
                                goto ATTR_ERR;

                            /* create an @comment thing */

#if MGDDATA
                            adesc = new AtComment;
#else
                            adesc =    (AtComment)parseAllocPerm->nraAlloc(sizeof(*adesc));
#endif

                            adesc->atcFlavor              = AC_COM_REGISTER;
                            adesc->atcNext                = NULL;
                            adesc->atcInfo.atcReg.atcGUID = cval.cvValue.cvSval;
                            adesc->atcInfo.atcReg.atcDual = false;


#if MGDDATA
                            entry = new SymXinfoAtc;
#else
                            entry =    (SymXinfoAtc)parseAllocPerm->nraAlloc(sizeof(*entry));
#endif

                            entry->xiKind    = XI_ATCOMMENT;
                            entry->xiNext    = NULL;
                            entry->xiAtcInfo = adesc;
                        }
                    }
                    else
                    {
                        parseExprSkip(); entry = NULL;
                    }

                    if  (ourScanner->scanTok.tok != tkRParen)
                        goto ATTR_ERR;

                    if  (ourScanner->scan()      != tkRBrack)
                        goto ATTR_ERR;

                    ourScanner->scan();

                    return  entry;
                }
                goto ATTR_ERR;

            case ATTR_SYS_STRUCT:

                // [sysstruct(charset=CharacterSet::Unicode,pack=4)]

                if  (ourScanner->scan() == tkLParen)
                {
                    AtComment       adesc;
                    SymXinfoAtc     entry;

                    int             cset = 0;
                    unsigned        pack = 0;

                    if  (ourScanner->scan() == tkRParen)
                        goto END_SS;

                    for (;;)
                    {
                        if  (ourScanner->scanTok.tok != tkID)
                            goto ATTR_ERR;

                        name = ourScanner->scanTok.id.tokIdent->idSpelling();

                        if  (ourScanner->scan() != tkAsg)
                            goto ATTR_ERR;

                        ourScanner->scan();

                        if      (!strcmp(name, "pack"))
                        {
                            if  (forReal)
                            {
                                if  (parseConstExpr(cval, NULL, parseComp->cmpTypeUint, NULL))
                                {
                                    pack = cval.cvValue.cvIval;

                                    if  (pack !=  1 &&
                                         pack !=  2 &&
                                         pack !=  4 &&
                                         pack !=  8 &&
                                         pack != 16)
                                    {
                                        goto ATTR_ERR;
                                    }
                                }
                            }
                            else
                            {
                                if  (pack)
                                    goto ATTR_ERR;

                                parseExprSkip(); pack = 1;
                            }
                        }
                        else if (!strcmp(name, "charset"))
                        {
                            if  (forReal)
                            {
                                if  (parseConstExpr(cval, NULL, parseComp->cmpCharSetGet()->sdType, NULL))
                                    cset = cval.cvValue.cvIval;
                            }
                            else
                            {
                                if  (cset)
                                    goto ATTR_ERR;

                                parseExprSkip(); cset = 1;
                            }
                        }
                        else
                            goto ATTR_ERR;

                        if  (ourScanner->scanTok.tok != tkComma)
                            break;

                        ourScanner->scan();
                    }

                    if  (ourScanner->scanTok.tok != tkRParen)
                        goto ATTR_ERR;

                END_SS:

                    if  (ourScanner->scan() != tkRBrack)
                        goto ATTR_ERR;

                    ourScanner->scan();

                    if  (!forReal)
                        return  NULL;

                    /* create an @comment thing */

#if MGDDATA
                    adesc = new AtComment;
#else
                    adesc =    (AtComment)parseAllocPerm->nraAlloc(sizeof(*adesc));
#endif

                    adesc->atcFlavor                    = AC_DLL_STRUCT;
                    adesc->atcNext                      = NULL;
                    adesc->atcInfo.atcStruct.atcStrings = cset;
                    adesc->atcInfo.atcStruct.atcPack    = pack;

#if MGDDATA
                    entry = new SymXinfoAtc;
#else
                    entry =    (SymXinfoAtc)parseAllocPerm->nraAlloc(sizeof(*entry));
#endif

                    entry->xiKind    = XI_ATCOMMENT;
                    entry->xiNext    = NULL;
                    entry->xiAtcInfo = adesc;

                    return  entry;
                }
                goto ATTR_ERR;

            case ATTR_NATIVE_TYPE:

                // nativetype(NativeType.xxxx,size=123)

                if  (ourScanner->scan() == tkLParen)
                {
                    SymXinfoCOM     entry = NULL;
                    MarshalInfo     adesc;

                    int             type  = -1;
                    int             sbtp  = -1;
                    int             size  = -1;

                    const   char *  custG = NULL;
                    const   char *  custC = NULL;
                    SymDef          custT = NULL;

                    int             amIn  = 0;
                    int             amOut = 0;

                    /* The first thing must be the type itself */

                    ourScanner->scan();

                    if  (forReal)
                    {
                        if  (parseConstExpr(cval, NULL, parseComp->cmpNatTypeGet()->sdType, NULL))
                            type = cval.cvValue.cvIval;
                    }
                    else
                        parseExprSkip();

                    /* Is there more stuff ? */

                    while (ourScanner->scanTok.tok == tkComma)
                    {
                        /* Check for "size=" and the others */

                        if  (ourScanner->scan() != tkID)
                        {
                            if      (ourScanner->scanTok.tok == tkIN)
                                amIn  = true;
                            else if (ourScanner->scanTok.tok == tkOUT)
                                amOut = true;
                            else
                                goto ATTR_ERR;

                            ourScanner->scan();
                            continue;
                        }

                        name = ourScanner->scanTok.id.tokIdent->idSpelling();

                        if  (ourScanner->scan() != tkAsg)
                            goto ATTR_ERR;

                        ourScanner->scan();

                        if      (!strcmp(name, "size"))
                        {
                            if  (forReal)
                            {
                                if  (parseConstExpr(cval, NULL, parseComp->cmpTypeUint, NULL))
                                    size = cval.cvValue.cvIval;
                            }
                            else
                            {
                                if  (type != NATIVE_TYPE_FIXEDSYSSTRING &&
                                     type != NATIVE_TYPE_FIXEDARRAY     && type != -1)
                                {
                                    goto ATTR_ERR;
                                }

                                parseExprSkip();
                            }
                        }
                        else if (!strcmp(name, "subtype"))
                        {
                            if  (forReal)
                            {
                                if  (parseConstExpr(cval, NULL, parseComp->cmpNatTypeGet()->sdType, NULL))
                                    sbtp = cval.cvValue.cvIval;
                            }
                            else
                            {
                                if  (type != NATIVE_TYPE_ARRAY     &&
                                     type != NATIVE_TYPE_SAFEARRAY && type != -1)
                                {
                                    goto ATTR_ERR;
                                }

                                parseExprSkip();
                            }
                        }
                        else if (!strcmp(name, "marshalcomtype"))
                        {
                            if  (forReal)
                            {
                                if  (parseConstExpr(cval, NULL, parseComp->cmpStringRef(), NULL))
                                {
                                    assert(cval.cvIsStr);

                                    custG = cval.cvValue.cvSval->csStr;
                                }
                            }
                            else
                            {
                                if  (type != NATIVE_TYPE_CUSTOMMARSHALER)
                                    goto ATTR_ERR;

                                parseExprSkip();
                            }
                        }
                        else if (!strcmp(name, "marshalclass"))
                        {
                            if  (forReal)
                            {
                                if  (ourScanner->scanTok.tok != tkID)
                                {
                                    parseComp->cmpError(ERRnoClassName);
                                    parseExprSkip();
                                }
                                else
                                {
                                    SymDef          tsym;

                                    tsym = parseNameUse(true, false);
                                    if  (tsym)
                                    {
                                        if  (tsym->sdSymKind == SYM_CLASS)
                                            custT = tsym;
                                        else
                                            parseComp->cmpError(ERRnoClassName);
                                    }
                                }
                            }
                            else
                            {
                                if  (type != NATIVE_TYPE_CUSTOMMARSHALER)
                                    goto ATTR_ERR;

                                parseExprSkip();
                            }
                        }
                        else if (!strcmp(name, "marshalcookie"))
                        {
                            if  (forReal)
                            {
                                if  (parseConstExpr(cval, NULL, parseComp->cmpStringRef(), NULL))
                                {
                                    assert(cval.cvIsStr);

                                    custC = cval.cvValue.cvSval->csStr;
                                }
                            }
                            else
                            {
                                if  (type != NATIVE_TYPE_CUSTOMMARSHALER)
                                    goto ATTR_ERR;

                                parseExprSkip();
                            }
                        }
                        else
                            goto ATTR_ERR;
                    }

                    if  (ourScanner->scanTok.tok != tkRParen)
                        goto ATTR_ERR;
                    if  (ourScanner->scan()      != tkRBrack)
                        goto ATTR_ERR;

                    ourScanner->scan();

                    if  (forReal)
                    {
                        if  (type == NATIVE_TYPE_CUSTOMMARSHALER)
                        {
                            marshalExt *    bdesc;

                            bdesc = (marshalExt*)parseAllocPerm->nraAlloc(sizeof(*bdesc));

                            if  (custG == NULL)
                                parseComp->cmpGenWarn(WRNgeneric, "no custom marshalling GUID specified, this may not work - should this be an error?");
                            if  (custT == NULL)
                                parseComp->cmpGenWarn(WRNgeneric, "no custom marshalling type specified, this may not work - should this be an error?");

                            bdesc->marshCustG = custG;
                            bdesc->marshCustC = custC;
                            bdesc->marshCustT = custT;

                            adesc = bdesc;
                        }
                        else
                        {
                            adesc = (MarshalInfo)parseAllocPerm->nraAlloc(sizeof(*adesc));
                        }

                        adesc->marshType    = type;
                        adesc->marshSubTp   = sbtp;
                        adesc->marshSize    = size;

                        adesc->marshModeIn  = amIn;
                        adesc->marshModeOut = amOut;

#if MGDDATA
                        entry = new SymXinfoCOM;
#else
                        entry =    (SymXinfoCOM)parseAllocPerm->nraAlloc(sizeof(*entry));
#endif
                        entry->xiKind       = XI_MARSHAL;
                        entry->xiCOMinfo    = adesc;
                        entry->xiNext       = NULL;
                    }

                    return  entry;
                }
                goto ATTR_ERR;

            default:
                NO_WAY(!"unexpected attribute");
                return  NULL;
            }
        }
    }

    /* Don't know this attribute, issue a warning and skip over it */

    if  (!forReal)
        parseComp->cmpGenWarn(WRNunkAttr, name);

    goto ATTR_SKIP;

LINK:

    // [sysimport(dll="kernel32", name="VirtualAlloc",charset=)]

    DLLname = NULL;
    SYMname = NULL;
    strVal  = 0;
    lstErr  = false;

    if  (ourScanner->scan() != tkLParen)
        goto ATTR_ERR;

    do
    {
        unsigned        kind;

        static
        const char *    names[] =
        {
            "dll", "name", "charset", "setLastError"
        };

        /* We expect the attribute name to be next */

        if  (ourScanner->scan() != tkID)
            goto ATTR_ERR;

        name = ourScanner->scanTok.id.tokIdent->idSpelling();

        for (kind = 0; kind < arraylen(names); kind++)
        {
            if  (!strcmp(name, names[kind]))
                goto LINK_GOTN;
        }

        goto ATTR_ERR;

    LINK_GOTN:

        if  (ourScanner->scan() != tkAsg)
            goto ATTR_ERR;

        ourScanner->scan();

        if  (!forReal)
        {
            parseExprSkip();
            continue;
        }

        switch (kind)
        {
        case 0:
        case 1:

            if  (parseConstExpr(cval, NULL, CMP_ANY_STRING_TYPE, NULL))
            {
                char    *       saveNm;
                size_t          saveLn;

                assert(cval.cvIsStr);

                /* Save the DLL/entry string */

                saveLn = cval.cvValue.cvSval->csLen;
#if MGDDATA
                UNIMPL(!"save name string on managed heap");
#else
                saveNm = (char*)parseAllocPerm->nraAlloc(roundUp(saveLn+1));
                memcpy(saveNm, cval.cvValue.cvSval->csStr, saveLn);
#endif
                saveNm[saveLn] = 0;

                if  (kind)
                    SYMname = saveNm;
                else
                    DLLname = saveNm;
            }
            break;

        case 2:

            if  (parseConstExpr(cval, NULL, parseComp->cmpCharSetGet()->sdType, NULL))
                strVal = cval.cvValue.cvIval;

            break;

        case 3:

            if  (parseConstExpr(cval, NULL, parseComp->cmpTypeBool, NULL))
                lstErr = cval.cvValue.cvIval != 0;

            break;

        default:
            goto ATTR_ERR;
        }
    }
    while (ourScanner->scanTok.tok == tkComma);

    /* default to "winapi" for sysimport-style imports */

    callCnv = CCNV_WINAPI;

    /* Make the closing ")]" is present */

    if  (ourScanner->scanTok.tok != tkRParen)
        goto ATTR_ERR;
    if  (ourScanner->scan()      != tkRBrack)
        goto ATTR_ERR;

    ourScanner->scan();

    /* All went OK, create the linkage descriptor if appropriate */

    if  (forReal)
        goto SAVE_LINK;

    return  NULL;
}

/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************
 *
 *  Parse an anonymous type declaration.
 */

TypDef              parser::parseAnonType(Tree args)
{
    Scanner         ourScanner = parseScan;

    SymDef          clsSym;
    TypDef          clsTyp;

    assert(ourScanner->scanTok.tok == tkLCurly);

    /* Declare an anonymous class symbol */

    clsSym = parseStab->stDeclareSym(parseComp->cmpNewAnonymousName(),
                                     SYM_CLASS,
                                     NS_HIDE,
                                     parseComp->cmpGlobalNS);

    clsSym->sdIsManaged       = true;
    clsSym->sdAccessLevel     = ACL_DEFAULT;
    clsSym->sdClass.sdcFlavor = STF_CLASS;

    clsTyp = parseStab->stNewClsType(clsSym);

    while (ourScanner->scan() != tkRCurly)
    {
        TypDef          baseTp;
        declMods        memMods;

        /* Check for the special case "= member" */

        if  (ourScanner->scanTok.tok == tkAsg)
        {
            UNIMPL("=member NYI");
            continue;
        }

        /* Parse the type specifier */

        baseTp = parseTypeSpec(&memMods, false);

        /* Parse the declarator list */

        for (;;)
        {
            Ident           memName;
            TypDef          memType;
            Tree            memInit;
            SymDef          memSym;

            /* Get the next member's name and type */

            memName = parseDeclarator(&memMods, baseTp, DN_OPTIONAL, &memType, NULL, true);
            if  (!memName)
                memName = parseComp->cmpNewAnonymousName();

            /* Declare the member symbol */

            memSym = parseStab->stDeclareSym(memName,
                                             SYM_VAR,
                                             NS_NORM,
                                             clsSym);

            memSym->sdType        = memType;
            memSym->sdAccessLevel = ACL_PUBLIC;
            memSym->sdIsMember    = true;

            /* There better be an initializer */

            if  (ourScanner->scanTok.tok != tkAsg)
            {
                UNIMPL("member initializer missing, not sure what to do"); memInit = NULL;
            }
            else
            {
                ourScanner->scan();

                /* Parse the initializer expression */

                memInit = parseExprComma();
            }

            /* Save the initializer tree in the member */

            memSym->sdVar.sdvInitExpr = memInit;

            /* Are there any more declarators? */

            if  (ourScanner->scanTok.tok != tkComma)
                break;

            ourScanner->scan();
        }

        /* Are there any more member declarations ? */

        if  (ourScanner->scanTok.tok != tkSColon)
            break;
    }

    chkCurTok(tkRCurly, ERRnoRcurly);

    parseComp->cmpDeclDefCtor(clsSym);

    if  (clsSym->sdClass.sdcFlavor == STF_CLASS)
        clsTyp->tdClass.tdcBase = parseComp->cmpClassObject->sdType;

    clsSym->sdCompileState       = CS_DECLARED;
    clsSym->sdClass.sdcPODTclass = true;

    parseComp->cmpClassDefCnt++;

    return  clsTyp;
}

/*****************************************************************************/
#endif//SETS
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\mdnames.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//      operator        string used in metadata

MD_NAME(NONE          , NULL)

MD_NAME(ADD           , "op_Addition")
MD_NAME(SUB           , "op_Subtraction")
MD_NAME(MUL           , "op_Multiply")
MD_NAME(DIV           , "op_Division")
MD_NAME(MOD           , "op_Modulus")

MD_NAME(OR            , "op_BitwiseOr")
MD_NAME(XOR           , "op_ExclusiveOr")
MD_NAME(AND           , "op_BitwiseAnd")

MD_NAME(LSH           , "op_LeftShift")
MD_NAME(RSH           , "op_RightShift")
MD_NAME(RSZ           , "op_UnsignedRightShift")

MD_NAME(CNC           , "op_Concat")

MD_NAME(EQ            , "op_Equality")
MD_NAME(NE            , "op_Inequality")

MD_NAME(LT            , "op_LessThan")
MD_NAME(LE            , "op_LessThanOrEqual")
MD_NAME(GE            , "op_GreaterThanOrEqual")
MD_NAME(GT            , "op_GreaterThan")

MD_NAME(LOG_AND       , "op_LogicalAnd")
MD_NAME(LOG_OR        , "op_LogicalOr")

MD_NAME(LOG_NOT       , "op_LogicalNot")
MD_NAME(NOT           , "op_OnesComplement")

MD_NAME(NOP           , "op_UnaryPlus")
MD_NAME(NEG           , "op_UnaryNegation")

MD_NAME(INC           , "op_Increment")
MD_NAME(DEC           , "op_Decrement")

MD_NAME(ASG           , "op_Assignment")

MD_NAME(ASG_ADD       , "op_AdditionAssignment")
MD_NAME(ASG_SUB       , "op_SubtractionAssignment")
MD_NAME(ASG_MUL       , "op_MultiplicationAssignment")
MD_NAME(ASG_DIV       , "op_DivisionAssignment")
MD_NAME(ASG_MOD       , "op_ModulusAssignment")

MD_NAME(ASG_AND       , "op_BitwiseOrAssignment")
MD_NAME(ASG_XOR       , "op_ExclusiveOrAssignment")
MD_NAME(ASG_OR        , "op_BitwiseAndAssignment")

MD_NAME(ASG_LSH       , "op_LeftShiftAssignment")
MD_NAME(ASG_RSH       , "op_RightShiftAssignment")
MD_NAME(ASG_RSZ       , "op_UnsignedRightShiftAssignment")

MD_NAME(ASG_CNC       , "op_ConcatAssignment")

MD_NAME(CTOR_INST     , ".ctor")
MD_NAME(CTOR_STAT     , ".cctor")

MD_NAME(FINALIZER     , "op_Finalize")      // ?????

MD_NAME(CONV_IMP      , "op_Implicit")
MD_NAME(CONV_EXP      , "op_Explicit")

MD_NAME(EQUALS        , "op_Equals")
MD_NAME(COMPARE       , "op_Compare")

MD_NAME(PROP_GET      , "get_")
MD_NAME(PROP_SET      , "set_")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\options.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef CMDOPT
#error  Need to define CMDOPT before including this file!
#endif

//     basename     type           max. phase   default

CMDOPT(Quiet      , bool         , CPH_NONE   , false      )// -q     quiet    mode
CMDOPT(SafeMode   , bool         , CPH_NONE   , false      )// -S     typesafe mode
CMDOPT(Pedantic   , bool         , CPH_NONE   , false      )// -P     pedantic mode
CMDOPT(ChkUseDef  , bool         , CPH_NONE   , true       )// -U     flag unitialized local variable use

CMDOPT(BaseLibs   , const char * , CPH_NONE   , ""         )// -s     import MSCORLIB.DLL metadata
CMDOPT(SuckList   , StrList      , CPH_NONE   , NULL       )// -mname import additional   metadata
CMDOPT(SuckLast   , StrList      , CPH_NONE   , NULL       )// -mname import additional   metadata
CMDOPT(PathList   , StrList      , CPH_NONE   , NULL       )// -spath additional path to search for MD
CMDOPT(PathLast   , StrList      , CPH_NONE   , NULL       )// -spath additional path to search for MD

CMDOPT(OutBase    , unsigned     , CPH_NONE   , 0          )// -b     output file virtual addr base
CMDOPT(OutSize    , unsigned     , CPH_NONE   , 0          )// -b@xxx output file max. size
CMDOPT(OutDLL     , bool         , CPH_NONE   , false      )// -d     output a DLL (not an EXE)

CMDOPT(Subsystem  , unsigned     , CPH_NONE   , IMAGE_SUBSYSTEM_WINDOWS_CUI)// -W Windows subsystem.

CMDOPT(NoDefines  , bool         , CPH_NONE   , false      )// -u     ignore #define directives
CMDOPT(MacList    , StrList      , CPH_NONE   , NULL       )// -M     macro definition(s) - list head
CMDOPT(MacLast    , StrList      , CPH_NONE   , NULL       )// -M     macro definition(s) - list tail


CMDOPT(StrValCmp  , bool         , CPH_PARSING, false      )// -r     string value compares
CMDOPT(StrCnsDef  , unsigned     , CPH_PARSING, 0          )// -Sx    default string constant type (SA/SU/SM)

CMDOPT(OldStyle   , bool         , CPH_PARSING, false      )// -c     default to old-style declararions

CMDOPT(NewMDnames , bool         , CPH_NONE   , true       )// -N     new metadata naming convention

CMDOPT(Asserts    , unsigned char, CPH_NONE   , 0          )// -A     enable asserts

CMDOPT(AlignVal   , unsigned char, CPH_NONE   , sizeof(int))// -a#    default alignment

CMDOPT(GenDebug   , bool         , CPH_NONE   , false      )// -Zi    generate full debug info
CMDOPT(LineNums   , bool         , CPH_NONE   , false      )// -Zl    generate line# info
CMDOPT(ParamNames , bool         , CPH_NONE   , false      )// -Zn    generate parameter names

CMDOPT(OutFileName, const char * , CPH_NONE   , NULL       )// -O     output file name

#ifdef  DEBUG
CMDOPT(Verbose    , int          , CPH_NONE   , false      )// -v     verbose
CMDOPT(DispCode   , bool         , CPH_NONE   , false      )// -p     display generated MSIL code
CMDOPT(DispILcd   , bool         , CPH_NONE   , false      )// -pd    display generated MSIL code (detailed)
#endif

CMDOPT(OutGUID    , GUID         , CPH_NONE   , NULL       )// -CG    PE image GUID
CMDOPT(OutName    , const char * , CPH_NONE   , NULL       )// -CN    PE image name
CMDOPT(RCfile     , const char * , CPH_NONE   , NULL       )// -CR    RC file to be added
CMDOPT(MainCls    , const char * , CPH_NONE   , NULL       )// -CM    name of class with main method
CMDOPT(SkipATC    , bool         , CPH_NONE   , false      )// -CS    ignore "@" comments

CMDOPT(ModList    , StrList      , CPH_NONE   , NULL       )// -zm    add module   to manifest
CMDOPT(ModLast    , StrList      , CPH_NONE   , NULL       )// -zm    add module   to manifest

CMDOPT(MRIlist    , StrList      , CPH_NONE   , NULL       )// -zr    add resource to manifest
CMDOPT(MRIlast    , StrList      , CPH_NONE   , NULL       )// -zr    add resource to manifest

#ifdef  OLD_IL
CMDOPT(OILgen     , bool         , CPH_NONE   , false      )// -o     generate old MSIL
CMDOPT(OILlink    , bool         , CPH_NONE   , true       )// -ol    generate old MSIL and link the result
CMDOPT(OILkeep    , bool         , CPH_NONE   , false      )// -ok    generate old MSIL: keep the temp files
CMDOPT(OILopt     , bool         , CPH_NONE   , false      )// -ox    generate old MSIL: max. opt for speed
CMDOPT(OILopts    , bool         , CPH_NONE   , false      )// -os    generate old MSIL: max. opt for size
CMDOPT(OILasm     , bool         , CPH_NONE   , false      )// -oa    generate old MSIL: create .asm file
CMDOPT(OILcod     , bool         , CPH_NONE   , false      )// -oc    generate old MSIL: create .cod file
CMDOPT(OILcgen    , const char * , CPH_NONE   , NULL       )// -og    path to  old MSIL code generator
#endif

CMDOPT(RecDir     , bool         , CPH_NONE   , false      )// -R     recurse into source dirs

CMDOPT(WarnLvl    , signed char  , CPH_NONE   , 1          )// -w     warning level
CMDOPT(WarnErr    , bool         , CPH_NONE   , false      )// -wx    warnings -> errors

CMDOPT(MaxErrs    , unsigned     , CPH_NONE   , 50         )// -n     max # of errors

CMDOPT(Assembly   , bool         , CPH_NONE   , true       )// -z     generate assembly
CMDOPT(AsmNoPubTp , bool         , CPH_PARSING, false      )// -zt    don't include types in assembly
CMDOPT(AsmNonCLS  , bool         , CPH_PARSING, false      )// -zn    assembly is non-compliant

CMDOPT(AmbigHack  , bool         , CPH_NONE   , false      )// -X     don't flag ambiguous using lookups

CMDOPT(AsynchIO   , bool         , CPH_NONE   , false      )// -i     overlapped file input

CMDOPT(Tgt64bit   , bool         , CPH_NONE   , false      )// -6     target 64-bit architecture
CMDOPT(IntEnums   , bool         , CPH_NONE   , false      )// -e     map enums to ints

CMDOPT(TestMask   , unsigned     , CPH_PARSING, 0          )// -T     compiler testing

#undef  CMDOPT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\parser.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _PARSER_H_
#define _PARSER_H_
/*****************************************************************************/
#ifndef _ERROR_H_
#include "error.h"
#endif
/*****************************************************************************/
#ifndef _HASH_H_
#include "hash.h"
#endif
/*****************************************************************************/
#ifndef _SCAN_H_
#include "scan.h"
#endif
/*****************************************************************************/
#ifndef _ALLOC_H_
#include "alloc.h"
#endif
/*****************************************************************************
 *
 *  When we re-enter the parser, we have to save the current state so that
 *  the "outer" calls don't get screwed.
 */

DEFMGMT
struct  parserState
{
    bool                psSaved;
    scannerState        psScanSt;
    SymDef              psCurComp;
};

/*****************************************************************************
 *
 *  The following holds the current "using" state and is used whenever we
 *  introduce a new "using" region (so that the state on entry to that
 *  region can be restored).
 */

DEFMGMT
struct  usingState
{
    UseList             usUseList;
    UseList             usUseDesc;
};

/*****************************************************************************/

DEFMGMT
class parser
{
        /*********************************************************************/
        /*  Initialization and finalization - call once per lifetime.        */
        /*********************************************************************/

public:

        int             parserInit(Compiler comp);
        void            parserDone();

        /*********************************************************************/
        /*  Main entry point to prepare the given source text for parsing    */
        /*********************************************************************/

public:

        SymDef          parsePrepSrc(stringBuff     file,
                                     QueuedFile     fileBuff,
                                     const  char  * srcText,
                                     SymTab         symtab);

        /*********************************************************************/
        /*  The following keeps track of which hash table(s) to use, etc.    */
        /*********************************************************************/

private:

        Compiler        parseComp;
        SymTab          parseStab;
        HashTab         parseHash;
        Scanner         parseScan;

        norls_allocator parseAllocPriv;     // private temp allocator

        block_allocator*parseAllocTemp;     // allocator to use for symtab
        norls_allocator*parseAllocPerm;     // allocator to use for hashtab

        /*********************************************************************/
        /*  Members used for processing declarations and "using" clauses     */
        /*********************************************************************/

public:
        void            parseUsingInit();
        void            parseUsingDone();

private:
        SymDef          parseCurSym;
        SymDef          parseCurCmp;

        UseList         parseCurUseList;
        UseList         parseCurUseDesc;

        usingState      parseInitialUse;

        void            parseUsingScpBeg(  OUT usingState REF state, SymDef owner);
        void            parseUsingDecl();
        void            parseUsingScpEnd(IN    usingState REF state);

        void            parseInsertUses (INOUT usingState REF state, SymDef inner,
                                                                     SymDef outer);
        void            parseInsertUsesR(                            SymDef inner,
                                                                     SymDef outer);
        void            parseRemoveUses (IN    usingState REF state);

public:
        UseList         parseInsertUses (UseList useList, SymDef inner);

        /*********************************************************************/
        /*  Methods used for parsing declarations and other things           */
        /*********************************************************************/

private:

        bool            parseOldStyle;

        bool            parseNoTypeDecl;

        bool            parseBaseCTcall;
        bool            parseThisCTcall;

        GenArgDscF      parseGenFormals();

public:
        SymDef          parseSpecificType(SymDef clsSym, TypDef elemTp = NULL);
private:

        TypDef          parseCheck4type(tokens          nxtTok,
                                        bool            isCast = false);

        TypDef          parseDclrtrTerm(dclrtrName      nameMode,
                                        bool            forReal,
                                        DeclMod         modsPtr,
                                        TypDef          baseType,
                                        TypDef  *     * baseRef,
                                        Ident         * nameRet,
                                        QualName      * qualRet);

        CorDeclSecurity parseSecAction();

public:

        SymDef          parseAttribute (unsigned        tgtMask,
                                    OUT unsigned    REF useMask,
                                    OUT genericBuff REF blobAddr,
                                    OUT size_t      REF blobSize);

        SecurityInfo    parseCapability(bool            forReal = false);
        SecurityInfo    parsePermission(bool            forReal = false);

        SymXinfo        parseBrackAttr (bool            forReal,
                                        unsigned        OKmask,
                                        DeclMod         modsPtr = NULL);

        void            parseDeclMods  (accessLevels    defAcc,
                                        DeclMod         mods);

        bool            parseIsTypeSpec(bool            noLookup,
                                        bool          * labChkPtr = NULL);

        Ident           parseDeclarator(DeclMod         mods,
                                        TypDef          baseType,
                                        dclrtrName      nameMode,
                                        TypDef        * typeRet,
                                        QualName      * qualRet,
                                        bool            forReal);

        TypDef          parseTypeSpec  (DeclMod         mods,
                                        bool            forReal);

private:

#ifdef  SETS
        TypDef          parseAnonType  (Tree            args);
        Tree            parseSetExpr   (treeOps         oper);
#endif

        bool            parseIsCtorDecl(SymDef          clsSym);

        SymDef          parseNameUse   (bool            typeName,
                                        bool            keepName,
                                        bool            chkOnly = false);

        Tree            parseInitExpr();

        TypDef          parseType();

        DimDef          parseDimList   (bool            isManaged);

        ArgDef          parseArgListRec(    ArgDscRec   & argDsc);

public:

        void            parseArgList   (OUT ArgDscRec REF argDsc);

        void    _cdecl  parseArgListNew(    ArgDscRec   & argDsc,
                                            unsigned      argCnt,
                                            bool          argNames, ...);

private:

        QualName        parseQualNRec  (unsigned        depth,
                                        Ident           name1,
                                        bool            allOK);

        QualName        parseQualName  (bool            allOK)
        {
            assert(parseComp->cmpScanner->scanTok.tok == tkID);

            return      parseQualNRec(0,  NULL, allOK);
        }

        QualName        parseQualName  (Ident name1, bool allOK)
        {
            assert(parseComp->cmpScanner->scanTok.tok == tkDot ||
                   parseComp->cmpScanner->scanTok.tok == tkColon2);

            return      parseQualNRec(0, name1, allOK);
        }

        void            chkCurTok(int tok, int err);
        void            chkNxtTok(int tok, int err);

public:

        void            parseResync(tokens delim1, tokens delim2);

        /*********************************************************************/
        /*  The following keeps track of default alignment (pragma pack)     */
        /*********************************************************************/

private:

        unsigned        parseAlignStack;
        unsigned        parseAlignStLvl;

public:

        unsigned        parseAlignment;

        void            parseAlignSet (unsigned align);
        void            parseAlignPush();
        void            parseAlignPop ();

        /*********************************************************************/
        /*  The following methods are used to allocate parse tree nodes      */
        /*********************************************************************/

private:
        Tree            parseAllocNode();

public:
        Tree            parseCreateNode    (treeOps     op);

        Tree            parseCreateUSymNode(SymDef      sym,
                                            SymDef      scp = NULL);
        Tree            parseCreateNameNode(Ident       name);
        Tree            parseCreateOperNode(treeOps     op,
                                            Tree        op1,
                                            Tree        op2);
        Tree            parseCreateBconNode(int         val);
        Tree            parseCreateIconNode(__int32     ival,
                                            var_types   typ = TYP_INT);
        Tree            parseCreateLconNode(__int64     lval,
                                            var_types   typ = TYP_LONG);
        Tree            parseCreateFconNode(float       fval);
        Tree            parseCreateDconNode(double      dval);
        Tree            parseCreateSconNode(stringBuff  sval,
                                            size_t      slen,
                                            unsigned    type,
                                            int         wide,
                                            Tree        addx = NULL);

        Tree            parseCreateErrNode (unsigned    errn = 0);

        /*********************************************************************/
        /*  The following methods display parse trees                        */
        /*********************************************************************/

#ifdef  DEBUG

public:
        void            parseDispTreeNode(Tree tree, unsigned indent, const char *name = NULL);
        void            parseDispTree    (Tree tree, unsigned indent = 0);

#endif

        /*********************************************************************/
        /*  The following methods are used to parse expressions              */
        /*********************************************************************/

        Tree            parseAddToNodeList (      Tree      nodeList,
                                            INOUT Tree  REF nodeLast,
                                                  Tree      nodeAdd);

private:

#ifdef  SETS
        Tree            parseXMLctorArgs(SymDef clsSym);
#endif
        Tree            parseNewExpr();
        Tree            parseExprList(tokens endTok);
        Tree            parseCastOrExpr();
        Tree            parseTerm(Tree tree = NULL);
        Tree            parseExpr(unsigned prec, Tree pt);

public:
        Tree            parseExpr()
        {
            return  parseExpr(0, NULL);
        }

        Tree            parseExprComma()
        {
            return  parseExpr(1, NULL); // assumes that precedence of "," is 1
        }

        void            parseExprSkip();

        bool            parseConstExpr(OUT constVal REF valPtr,
                                           Tree         expr  = NULL,
                                           TypDef       dstt  = NULL,
                                           Tree  *      ncPtr = NULL);

        /*********************************************************************/
        /*  The following methods are used to parse function bodies          */
        /*********************************************************************/

        Tree            parseLastDecl;
        Tree            parseCurScope;

        Tree            parseLabelList;
        unsigned        parseLclVarCnt;

        Tree            parseCurSwitch;

        bool            parseHadGoto;

        Tree            parseTryDecl;
        Tree            parseTryStmt();

        Tree            parseFuncBody  (SymDef      fsym,
                                        Tree     *  labels,
                                        unsigned *  locals,
                                        bool     *  hadGoto,
                                        bool     *  baseCT,
                                        bool     *  thisCT);

        Tree            parseFuncBlock (SymDef      fsym = NULL);

        Tree            parseFuncStmt  (bool        stmtOpt = false);

        void            parseLclDclDecl(Tree        decl);
        Tree            parseLclDclMake(Ident       name,
                                        TypDef      type,
                                        Tree        init,
                                        unsigned    mods,
                                        bool        arg);


        Tree            parseLookupSym (Ident       name);

        /*********************************************************************/
        /*  Record source text information about a namespace or class        */
        /*********************************************************************/

private:

        SymDef          parsePrepSym      (SymDef   parent,
                                           declMods mods,
                                           tokens   defTok, scanPosTP dclFpos,
                                                            unsigned  dclLine);

        DefList         parseMeasureSymDef(SymDef   sym,
                                           declMods mods  , scanPosTP dclFpos,
                                                            unsigned  dclLine);

        /*********************************************************************/
        /*  Prepare the given section of the source for parsing              */
        /*********************************************************************/

private:

        bool            parseReadingText;

#ifdef  DEBUG
        unsigned        parseReadingTcnt;
#endif

public:

        void            parsePrepText (DefSrc                def,
                                       SymDef                compUnit,
                                         OUT parserState REF save);

        void            parseDoneText (INOUT parserState REF save);

        void            parseSetErrPos(DefSrc                def,
                                       SymDef                compUnit);
};

/*****************************************************************************/

const
TypDef  CMP_ANY_STRING_TYPE = (TypDef)0xFEEDBEEF;

/*****************************************************************************/
#ifndef _INLINES_H_
#include "inlines.h"
#endif
/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\pewrite.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/*****************************************************************************
 *
 *  Return the size of the hint/name table entry for the given name.
 */

inline
size_t              hintNameSize(WPEname name)
{
    /* Is this a "real" name or is it an import by ordinal? */

    if  (*name->PEnmSpelling() == '#')
    {
        return 0;
    }
    else
    {
        return  2 + (name->PEnmNlen + 2) & ~1;
    }
}

/*****************************************************************************
 *
 *  Initialize the name hash table.
 */

void                WPEhashTab::WPEhashInit(Compiler         comp,
                                            norls_allocator *alloc,
                                            unsigned         count)
{
    WPEname *       buck;
    size_t          size;

    /* Figure out the size of the bucket table and allocate/clear it */

    size = count * sizeof(*buck);
    buck = (WPEname*)alloc->nraAlloc(size);
    memset(buck, 0, size);

    /* Initialize all the other fields */

    WPEhashSize   = count;
    WPEhashMask   = count - 1;
    WPEhashComp   = comp;
    WPEhashAlloc  = alloc;
    WPEhashTable  = buck;
    WPEhashStrLen = 0;
}

/*****************************************************************************
 *
 *  Find/add the given name to the import name table ('owner' specifies the
 *  DLL that the import belongs to). The value at '*isNewPtr' will be set to
 *  true if the name was not in the table and has been added.
 */

WPEndef             WPEhashTab::WPEhashName(const char *name,
                                            WPEimpDLL   owner, bool *isNewPtr)
{
    bool            isNew;

    WPEname         nameEnt;
    WPEndef         nameDsc;

    assert(owner);

    /* Look for an existing entry that matches the name */

    nameEnt = WPEhashName(name, &isNew);

    if  (!isNew && (nameEnt->PEnmFlags & PENMF_IMP_NAME))
    {
        /* Existing import - look for a matching entry on the owning DLL */

        for (nameDsc = nameEnt->PEnmDefs;
             nameDsc;
             nameDsc = nameDsc->PEndNext)
        {
            assert(nameDsc->PEndName == nameEnt);

            if  (nameDsc->PEndDLL == owner)
            {
                *isNewPtr = false;

                return  nameDsc;
            }
        }
    }
    else
    {
        /* New import - record the name's offset within the name/hint table */

        nameEnt->PEnmOffs   = WPEhashStrLen;

        /* Remember that this entry is an import */

        nameEnt->PEnmFlags |= PENMF_IMP_NAME;

        /* Update the total name table size */

        WPEhashStrLen += hintNameSize(nameEnt);
    }

    /* Add a new DLL to the list of import definitions */

    nameDsc = (WPEndef)WPEhashAlloc->nraAlloc(sizeof(*nameDsc));

    nameDsc->PEndName      = nameEnt;

    nameDsc->PEndNext      = nameEnt->PEnmDefs;
                             nameEnt->PEnmDefs = nameDsc;

    nameDsc->PEndDLL       = owner;

    /* Append to the DLL's linked list of imports */

    nameDsc->PEndNextInDLL = NULL;

    if  (owner->PEidImpList)
        owner->PEidImpLast->PEndNextInDLL = nameDsc;
    else
        owner->PEidImpList                = nameDsc;

    owner->PEidImpLast = nameDsc;

    /* Tell the caller that we've create a new import entry */

    *isNewPtr = true;

    return  nameDsc;
}

/*****************************************************************************
 *
 *  Find/add the given name to the import name table. The value at '*isNewPtr'
 *  will be set to true if the name was not in the table and has been added.
 */

WPEname             WPEhashTab::WPEhashName(const char *name, bool *isNewPtr)
{
    WPEname    *    lastPtr;
    unsigned        hash;
    WPEname         nm;
    size_t          sz;

    size_t          nlen = strlen(name);
    unsigned        hval = hashTab::hashComputeHashVal(name);

    /* Mask the appropriate bits from the hash value */

    hash = hval & WPEhashMask;

    /* Search the hash table for an existing match */

    lastPtr = &WPEhashTable[hash];

    for (;;)
    {
        nm = *lastPtr;
        if  (!nm)
            break;

        /* Check whether the hash value and identifier lengths match */

        if  (nm->PEnmHash == hval && nm->PEnmNlen == nlen)
        {
            if  (!memcmp(nm->PEnmName, name, nlen+1))
            {
                *isNewPtr = false;
                return  nm;
            }
        }

        lastPtr = &nm->PEnmNext;
    }

    /* Figure out the size to allocate */

    sz  = sizeof(*nm);

    /* Include space for name string + terminating null and round the size */

    sz +=   sizeof(int) + nlen;
    sz &= ~(sizeof(int) - 1);

    /* Allocate space for the identifier */

    nm = (WPEname)WPEhashAlloc->nraAlloc(sz);

    /* Insert the identifier into the hash list */

    *lastPtr = nm;

    /* Fill in the identifier record */

    nm->PEnmNext   = NULL;
    nm->PEnmFlags  = 0;
    nm->PEnmHash   = hval;
    nm->PEnmNlen   = nlen;
    nm->PEnmDefs   = NULL;

    /* Copy the name string */

    memcpy(nm->PEnmName, name, nlen+1);

    *isNewPtr = true;

    return  nm;
}

/*****************************************************************************
 *
 *  Add an import to the import tables. Returns a cookie for the import that
 *  can later be used to obtain the actual address of the corresponding IAT
 *  entry.
 */

void    *           writePE::WPEimportAdd(const char *DLLname,
                                          const char *impName)
{
    WPEname         nameDLL;
    WPEndef         nameImp;
    WPEimpDLL       DLLdesc;
    bool            newName;

    /* Hash the DLL name first */

    nameDLL = WPEimpHash->WPEhashName(DLLname, &newName);

    /* Look for an existing DLL entry with a matching name */

    if  (newName)
    {
        /* New DLL name - make sure we update the total string length */

        WPEimpDLLstrLen += (nameDLL->PEnmNlen + 1) & ~1;
    }
    else
    {
        for (DLLdesc = WPEimpDLLlist; DLLdesc; DLLdesc = DLLdesc->PEidNext)
        {
            if  (DLLdesc->PEidName == nameDLL)
                goto GOT_DSC;
        }
    }

    /* The DLL is not known, add a new entry for it */

    DLLdesc = (WPEimpDLL)WPEalloc->nraAlloc(sizeof(*DLLdesc));

    DLLdesc->PEidName    = nameDLL;
    DLLdesc->PEidIndex   = WPEimpDLLcnt++;
    DLLdesc->PEidImpCnt  = 0;
    DLLdesc->PEidImpList =
    DLLdesc->PEidImpLast = NULL;
    DLLdesc->PEidNext    = NULL;

    /* Append the DLL entry to the end of the DLL list */

    if  (WPEimpDLLlast)
        WPEimpDLLlast->PEidNext = DLLdesc;
    else
        WPEimpDLLlist           = DLLdesc;

    WPEimpDLLlast = DLLdesc;

GOT_DSC:

    /* We've got the DLL entry, now look for an existing import from it */

    nameImp = WPEimpHash->WPEhashName(impName, DLLdesc, &newName);

    if  (newName)
    {
        /* This is a new import, make a note of it */

        nameImp->PEndIndex = DLLdesc->PEidImpCnt++;
    }

    return  nameImp;
}

/*****************************************************************************
 *
 *  The following maps a section id to its name string.
 */

const   char        writePE::WPEsecNames[PE_SECT_count][IMAGE_SIZEOF_SHORT_NAME] =
{
    ".text",
    ".data",
    ".rdata",
    ".rsrc",
    ".reloc",
};

const   char    *   writePE::WPEsecName(WPEstdSects sect)
{
    assert(sect < PE_SECT_count);

    assert(strcmp(WPEsecNames[PE_SECT_text ], ".text" ) == 0);
    assert(strcmp(WPEsecNames[PE_SECT_data ], ".data" ) == 0);
    assert(strcmp(WPEsecNames[PE_SECT_rdata], ".rdata") == 0);
    assert(strcmp(WPEsecNames[PE_SECT_rsrc ], ".rsrc" ) == 0);
    assert(strcmp(WPEsecNames[PE_SECT_reloc], ".reloc") == 0);

    return  WPEsecNames[sect];
}

/*****************************************************************************
 *
 *  Initialize an instance of the PE writer for the specified output file,
 *  using the given memory allocator. Returns false on success.
 */

bool                writePE::WPEinit(Compiler comp, norls_allocator*alloc)
{
    unsigned        offs;

    static
    BYTE            entryCode[16] =
    {
        0xFF, 0x25
    };

    /* We don't know the name of the output file yet */

#ifndef NDEBUG
    WPEoutFnam  = NULL;
#endif

    /* Initialize/clear/record various things */

    WPEcomp     = comp;
    WPEalloc    = alloc;

    WPEsectCnt  = 0;

    memset(&WPEsections, 0, sizeof(WPEsections));
    memset(&WPEsecTable, 0, sizeof(WPEsecTable));

#ifdef  DEBUG
    WPEstrPoolBase = 0xBEEFCAFE;
#endif

    /* Create the standard sections */

    WPEaddSection(PE_SECT_text , 0, MAX_PE_TEXT_SIZE);
    WPEaddSection(PE_SECT_rdata, 0, MAX_PE_RDTA_SIZE);
    WPEaddSection(PE_SECT_data , 0, MAX_PE_DATA_SIZE);

    /* If we're creating a DLL, we'll need to output relocations */

    //if  (comp->cmpConfig.ccOutDLL)
        WPEaddSection(PE_SECT_reloc, 0, 0);

    /* Initialize the import table logic */

    WPEimportInit();

    /* Initialize the RC file import logic */

    WPEinitRCimp();

    /* Add the appropriate import for the entry point */

    WPEcorMain = WPEimportAdd("MSCOREE.DLL", comp->cmpConfig.ccOutDLL ? "_CorDllMain"
                                                                      : "_CorExeMain");

    /* Reserve space for the entry point code */

    offs = WPEsecAddData(PE_SECT_text, entryCode, sizeof(entryCode)); assert(offs == 0);

    WPEdebugDirDataSize = 0;
    WPEdebugDirSize     = 0;
    WPEdebugDirData     = NULL;

    return  false;
}

/*****************************************************************************
 *
 *  Set the name of the output file, this function has to be called (and at the
 *  right time) if an output file is to be generated!
 */

void                writePE::WPEsetOutputFileName(const char *outfile)
{
    char    *       buff;

    assert(WPEoutFnam == NULL);

    /* Make a durable copy of the file name, can't trust those callers */

    WPEoutFnam = buff = (char *)WPEalloc->nraAlloc(roundUp(strlen(outfile) + 1));

    strcpy(buff, outfile);
}

/*****************************************************************************
 *
 *  Add a new section with the given name to the PE file.
 */

void                writePE::WPEaddSection(WPEstdSects sect, unsigned attrs,
                                                             size_t   maxSz)
{
    BYTE          * buff;
    PEsection       sec;

    assert(WPEsectCnt < PEmaxSections);
    sec = WPEsections + WPEsectCnt++;

    /* Make sure the max. size is rounded */

    assert((maxSz % OS_page_size) == 0);

    /* Allocate the uncommitted buffer */

    buff = maxSz ? (BYTE *)VirtualAlloc(NULL, maxSz, MEM_RESERVE, PAGE_READWRITE)
                 : NULL;

    /* Initialize the section state */

    sec->PEsdBase     =
    sec->PEsdNext     = buff;
    sec->PEsdLast     = buff;
    sec->PEsdEndp     = buff + maxSz;

    sec->PEsdRelocs   = NULL;

#ifdef  DEBUG
    sec->PEsdIndex    = sect;
    sec->PEsdFinished = false;
#endif

    /* Record the entry in the table */

    WPEsecTable[sect] = sec;
}

/*****************************************************************************
 *
 *  Reserve a given amount of space in the specified section.
 */

unsigned            writePE::WPEsecRsvData(WPEstdSects sect, size_t         size,
                                                             size_t         align,
                                                         OUT memBuffPtr REF outRef)
{
    PEsection       sec = WPEgetSection(sect);

    unsigned        ofs;
    BYTE        *   nxt;

    assert(align ==  1 ||
           align ==  2 ||
           align ==  4 ||
           align ==  8 ||
           align == 16);

    /* Compute the offset of the new data */

    ofs = sec->PEsdNext - sec->PEsdBase;

    /* Do we need to align the allocation? */

    if  (align > 1)
    {
        /* Pad if necessary */

        if  (ofs & (align - 1))
        {
            WPEsecRsvData(sect, align - (ofs & (align - 1)), 1, outRef);

            ofs = sec->PEsdNext - sec->PEsdBase;

            assert((ofs & (align - 1)) == 0);
        }
    }

    /* See if we have enough committed space in the buffer */

    nxt = sec->PEsdNext + size;

    if  (nxt > sec->PEsdLast)
    {
        size_t          tmp;
        BYTE    *       end;

        /* Round up the desired end-point */

        tmp  = ofs + size;
        tmp +=  (OS_page_size - 1);
        tmp &= ~(OS_page_size - 1);

        end  = sec->PEsdBase + tmp;

        /* Make sure we're not at the end of the buffer */

        if  (end > sec->PEsdEndp)
            WPEcomp->cmpFatal(ERRnoMemory);

        /* Commit some more memory */

        if  (!VirtualAlloc(sec->PEsdLast, end - sec->PEsdLast, MEM_COMMIT, PAGE_READWRITE))
            WPEcomp->cmpFatal(ERRnoMemory);

        /* Update the 'last' pointer */

        sec->PEsdLast = end;
    }

    /* Return the address of the first byte to the caller and update it */

    outRef = sec->PEsdNext;
             sec->PEsdNext = nxt;

    return  ofs;
}

/*****************************************************************************
 *
 *  Append the given blob of data to the specified section.
 */

unsigned            writePE::WPEsecAddData(WPEstdSects sect, genericBuff data,
                                                             size_t      size)
{
    memBuffPtr      dest;
    unsigned        offs;

    offs = WPEsecRsvData(sect, size, 1, dest);

    memcpy(dest, data, size);

    return  offs;
}

/*****************************************************************************
 *
 *  Returns the address of the data of a section at the given offset.
 */

memBuffPtr          writePE::WPEsecAdrData(WPEstdSects sect, unsigned    offs)
{
    PEsection       sec = WPEgetSection(sect);

    assert(offs <= (unsigned)(sec->PEsdNext - sec->PEsdBase));

    return  sec->PEsdBase + offs;
}

/*****************************************************************************
 *
 *  Returns the relative offset of the data area within the section.
 */

unsigned            writePE::WPEsecAddrOffs(WPEstdSects sect, memBuffPtr addr)
{
    PEsection       sec = WPEgetSection(sect);

    assert(addr >= sec->PEsdBase);
    assert(addr <= sec->PEsdNext);

    return addr -  sec->PEsdBase;
}

/*****************************************************************************
 *
 *  Reserve space in the code section of the given size and return the address
 *  of where the code bytes are to be copied and the corresponding RVA.
 */

unsigned            writePE::WPEallocCode(size_t size,
                                          size_t align, OUT memBuffPtr REF dataRef)
{
    return  CODE_BASE_RVA + WPEsecRsvData(PE_SECT_text, size, align, dataRef);
}

/*****************************************************************************
 *
 *  Reserve space for the given amount of string data and return the address
 *  of where the string pool contents are to be copied. This routine must be
 *  called exactly once (just before the PE file is closed), and the base of
 *  the space reserved here will be used to process all string data fixups.
 */

void                writePE::WPEallocString(size_t size,
                                            size_t align, OUT memBuffPtr REF dataRef)
{
    /* Allocate the space and remember the relative offset */

    WPEstrPoolBase = WPEsecRsvData(PE_SECT_data, size, align, dataRef);
}

/*****************************************************************************
 *
 *  Record a fixup: the datum being fixed up is within section 'ssrc' at
 *  offset 'offs', and the value there is to be updated by the base RVA
 *  of section 'sdst'.
 */

void                writePE::WPEsecAddFixup(WPEstdSects ssrc,
                                            WPEstdSects sdst, unsigned offs)
{
    PEsection       sec = WPEgetSection(ssrc);
    PEreloc         rel = (PEreloc)WPEalloc->nraAlloc(sizeof(*rel));

    /* Make sure the offset is within range */

    assert(offs <= WPEsecNextOffs(ssrc));

    /* Add the relocation to the section's list */

    rel->perSect = sdst; assert(rel->perSect == (unsigned)sdst);
    rel->perOffs = offs; assert(rel->perOffs == (unsigned)offs);

    rel->perNext = sec->PEsdRelocs;
                   sec->PEsdRelocs = rel;
}

/*****************************************************************************
 *
 *  Initialize the import tracking logic.
 */

void                writePE::WPEimportInit()
{
    WPEhash         hash;

    /* Create and initialize the name hash table */

    hash = WPEimpHash = (WPEhash)WPEalloc->nraAlloc(sizeof(*hash));
    hash->WPEhashInit(WPEcomp, WPEalloc);

    /* Initialize all the other import table-related values */

    WPEimpDLLcnt    = 0;
    WPEimpDLLlist   =
    WPEimpDLLlast   = NULL;

    WPEimpDLLstrLen = 0;
}

/*****************************************************************************
 *
 *  Finalize the import table logic and return the total size of the import
 *  tables.
 */

size_t              writePE::WPEimportDone(unsigned offs)
{
    WPEimpDLL       DLLdesc;

    size_t          temp;
    size_t          tsiz;

    size_t          size = 0;

    /* Reserve space for the IAT's */

    WPEimpOffsIAT  = offs;

    for (DLLdesc = WPEimpDLLlist, tsiz = 0;
         DLLdesc;
         DLLdesc = DLLdesc->PEidNext)
    {
        /* Record the base offset of this IAT */

        DLLdesc->PEidIATbase = offs;

        /* Compute the size of the IAT (it's null-terminated) */

        temp  = sizeof(void *) * (DLLdesc->PEidImpCnt + 1);

        /* Reserve space for the IAT */

        size += temp;
        offs += temp;
        tsiz += temp;
    }

    WPEimpSizeIAT  = tsiz;

    /* Next comes the import directory table */

    WPEimpOffsIDT  = offs;

    /* The import directory is NULL-terminated */

    temp  = (WPEimpDLLcnt + 1) * sizeof(IMAGE_IMPORT_DESCRIPTOR);
    size += temp;
    offs += temp;

    WPEimpSizeIDT  = temp;

    /* Next comes the import lookup table */

    WPEimpOffsLook = offs;

    for (DLLdesc = WPEimpDLLlist;
         DLLdesc;
         DLLdesc = DLLdesc->PEidNext)
    {
        /* Record the base offset of this lookup table */

        DLLdesc->PEidILTbase = offs;

        /* Compute the size of the ILT (it's null-terminated) */

        temp  = sizeof(void *) * (DLLdesc->PEidImpCnt + 1);

        /* Reserve space for the ILT */

        size += temp;
        offs += temp;
    }

    /* Next comes the hint/name table */

    WPEimpOffsName = offs;

    size += WPEimpHash->WPEhashStrLen;
    offs += WPEimpHash->WPEhashStrLen;

    /* The last thing is the DLL name table */

    WPEimpOffsDLLn = offs;

    size += WPEimpDLLstrLen;
    offs += WPEimpDLLstrLen;

    /* Record the total size of all the tables */

    WPEimpSizeAll  = size;

    return  size;
}

/*****************************************************************************
 *
 *  Write the import table to the output file.
 */

void                writePE::WPEimportGen(OutFile outf, PEsection sect)
{
    unsigned        baseFile = sect->PEsdAddrFile;
    unsigned        baseRVA  = sect->PEsdAddrRVA;

    unsigned        nextIAT;
    unsigned        nextName;
    unsigned        nextLook;
    unsigned        nextDLLn;

    WPEimpDLL       DLLdesc;

    assert(outf->outFileOffset() == baseFile);

#ifdef  DEBUG
    if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("\n");
#endif

    /* Output the IAT entries s for all import of all DLL's */

    assert(outf->outFileOffset() == baseFile + WPEimpOffsIAT);

    nextName = baseRVA + WPEimpOffsName;

    for (DLLdesc = WPEimpDLLlist;
         DLLdesc;
         DLLdesc = DLLdesc->PEidNext)
    {
        WPEndef         imp;

        assert(DLLdesc->PEidIATbase == outf->outFileOffset() - baseFile);

#ifdef  DEBUG
        if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("IAT starts at %04X           for '%s'\n", outf->outFileOffset(), DLLdesc->PEidName->PEnmSpelling());
#endif

        /* For each import, output the RVA of its hint/name table entry */

        for (imp = DLLdesc->PEidImpList; imp; imp = imp->PEndNextInDLL)
        {
            WPEname         name = imp->PEndName;

            assert(name->PEnmFlags & PENMF_IMP_NAME);

#ifdef  DEBUG
            if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("    entry --> %04X           for '%s.%s'\n", nextName, DLLdesc->PEidName->PEnmSpelling(), name->PEnmSpelling());
#endif

            outf->outFileWriteData(&nextName, sizeof(nextName));

            nextName += hintNameSize(name);
        }

        /* Output a null entry to terminate the table */

        outf->outFileWritePad(sizeof(nextName));
    }

#ifdef  DEBUG
    if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("\n");
#endif

    /* Output the import directory */

    assert(outf->outFileOffset() == baseFile + WPEimpOffsIDT);

    nextIAT  = baseRVA + WPEimpOffsIAT;
    nextLook = baseRVA + WPEimpOffsLook;
    nextDLLn = baseRVA + WPEimpOffsDLLn;

    for (DLLdesc = WPEimpDLLlist;
         DLLdesc;
         DLLdesc = DLLdesc->PEidNext)
    {
        IMAGE_IMPORT_DESCRIPTOR impDsc;

#ifdef  DEBUG
        if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("IDT entry --> %04X/%04X/%04X for '%s'\n", nextIAT, nextLook, nextDLLn, DLLdesc->PEidName->PEnmSpelling());
#endif

        /* Fill in the entry and append it to the file */

        impDsc.Characteristics = nextLook;
        impDsc.TimeDateStamp   = 0;
        impDsc.ForwarderChain  = 0;
        impDsc.Name            = nextDLLn;
        impDsc.FirstThunk      = nextIAT;

        outf->outFileWriteData(&impDsc, sizeof(impDsc));

        /* Update the offsets for the next entry */

        nextIAT  += sizeof(void *) * (DLLdesc->PEidImpCnt + 1);
        nextLook += sizeof(void *) * (DLLdesc->PEidImpCnt + 1);;
        nextDLLn += (DLLdesc->PEidName->PEnmNlen + 1) & ~1;
    }

    /* Output a null entry to terminate the table */

    outf->outFileWritePad(sizeof(IMAGE_IMPORT_DESCRIPTOR));

#ifdef  DEBUG
    if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("\n");
#endif

    /* Output the lookup table */

    assert(outf->outFileOffset() == baseFile + WPEimpOffsLook);

    nextName = baseRVA + WPEimpOffsName;
    nextDLLn = baseRVA + WPEimpOffsDLLn;

    for (DLLdesc = WPEimpDLLlist;
         DLLdesc;
         DLLdesc = DLLdesc->PEidNext)
    {
        WPEndef         imp;

        assert(DLLdesc->PEidILTbase == outf->outFileOffset() - baseFile);

#ifdef  DEBUG
        if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("ILT starts at %04X           for '%s'\n", outf->outFileOffset(), DLLdesc->PEidName->PEnmSpelling());
#endif

        /* For each import, output the RVA of its hint/name table entry */

        for (imp = DLLdesc->PEidImpList; imp; imp = imp->PEndNextInDLL)
        {
            WPEname         name = imp->PEndName;

            assert(name->PEnmFlags & PENMF_IMP_NAME);

#ifdef  DEBUG
        if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("    entry --> %04X           for '%s.%s'\n", nextName, DLLdesc->PEidName->PEnmSpelling(), name->PEnmSpelling());
#endif

            outf->outFileWriteData(&nextName, sizeof(nextName));

            nextName += hintNameSize(name);
        }

        /* Output a null entry to terminate the table */

        outf->outFileWritePad(sizeof(nextName));
    }

#ifdef  DEBUG
    if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("\n");
#endif

    /* Output the hint/name table */

    assert(outf->outFileOffset() == baseFile + WPEimpOffsName);

    for (DLLdesc = WPEimpDLLlist;
         DLLdesc;
         DLLdesc = DLLdesc->PEidNext)
    {
        WPEndef         imp;
        unsigned        one = 1;

#ifdef  DEBUG
        if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("HNT starts at %04X           for '%s'\n", outf->outFileOffset(), DLLdesc->PEidName->PEnmSpelling());
#endif

        /* For each import, output the RVA of its hint/name table entry */

        for (imp = DLLdesc->PEidImpList; imp; imp = imp->PEndNextInDLL)
        {
            WPEname         name = imp->PEndName;

            assert(name->PEnmFlags & PENMF_IMP_NAME);

#ifdef  DEBUG
            if  (WPEcomp->cmpConfig.ccVerbose >= 2)  printf("    entry  at %04X               '%s.%s'\n", outf->outFileOffset(), DLLdesc->PEidName->PEnmSpelling(), name->PEnmSpelling());
#endif

            outf->outFileWriteData(&one, 2);
            outf->outFileWriteData(name->PEnmName, name->PEnmNlen+1);

            /* Padd if the name has an even size (odd with null terminator) */

            if  (!(name->PEnmNlen & 1))
                outf->outFileWriteByte(0);
        }
    }

#ifdef  DEBUG
    if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("\n");
#endif

    /* Finally, output the DLL name table */

    assert(outf->outFileOffset() == baseFile + WPEimpOffsDLLn);

    for (DLLdesc = WPEimpDLLlist;
         DLLdesc;
         DLLdesc = DLLdesc->PEidNext)
    {
        WPEname         name = DLLdesc->PEidName;

#ifdef  DEBUG
        if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("DLL entry  at %04X               '%s'\n", outf->outFileOffset(), name->PEnmSpelling());
#endif

        outf->outFileWriteData(name->PEnmName, name->PEnmNlen+1);

        /* Padd if the name has an even size (odd with null terminator) */

        if  (!(name->PEnmNlen & 1))
            outf->outFileWriteByte(0);
    }
}

/*****************************************************************************
 *
 *  Token remapping logic.
 */

#if     MD_TOKEN_REMAP

struct  tokenMap;
typedef tokenMap  * TokenMapper;

struct  tokenMap : IMapToken
{
    unsigned        refCount;

    virtual HRESULT _stdcall QueryInterface(REFIID iid, void **ppv);
    virtual ULONG   _stdcall AddRef();
    virtual ULONG   _stdcall Release();
    virtual HRESULT _stdcall Map(unsigned __int32 oldToken, unsigned __int32 newToken);
};

HRESULT
_stdcall            tokenMap::QueryInterface(REFIID iid, void **ppv)
{
    if      (iid == IID_IUnknown)
    {
        *ppv = (void *)this;
        return S_OK;
    }
    else if (iid == IID_IMapToken)
    {
        *ppv = (void *)this;
        return S_OK;
    }
    else
        return E_NOINTERFACE;
}

ULONG
_stdcall            tokenMap::AddRef()
{
    return ++refCount;
}

ULONG
_stdcall            tokenMap::Release()
{
    unsigned i = --refCount;

#ifndef __SMC__

    if (i == 0)
        delete this;

#endif

    return i;
}

HRESULT
_stdcall            tokenMap::Map(unsigned __int32 oldToken, unsigned __int32 newToken)
{
    UNIMPL(!"token remapper called, this is NYI");

    return E_NOTIMPL;
}

#endif

/*****************************************************************************/

static
char                COFFmagic[4] = { 'P', 'E', 0, 0 };

/*****************************************************************************
 *
 *  Finish writing the output file, flush it and close it. Returns false if
 *  successful.
 */

bool                writePE::WPEdone(mdToken entryTok, bool errors)
{
    unsigned        fileOffs;
    unsigned        fImgSize;
    unsigned        filePad;

    unsigned        DOS_hdrOffs, DOS_hdrSize;
    unsigned        COFFhdrOffs, COFFhdrSize;
    unsigned        OPTLhdrOffs, OPTLhdrSize;
    unsigned        sectTabOffs, sectTabSize;

    unsigned        virtBase;
    unsigned        virtOffs;

    unsigned        sectNum;
    PEsection       sectPtr;

    unsigned        entryOfs;
    unsigned        entryAdr;
    unsigned    *   ecodePtr;

    unsigned        codeOffs, codeVirt, codeSize;
    unsigned        rdatOffs, rdatVirt, rdatSize;
    unsigned        dataOffs, dataVirt, dataSize;
    unsigned        rsrcOffs, rsrcVirt, rsrcSize;
    unsigned        rlocOffs, rlocVirt, rlocSize;
    unsigned       /*bssOffs,*/          bssSize;

    unsigned        strPoolRVA;
    unsigned        strPoolAdr;

    OutFile         outf;

#ifdef  DLL
    void    *       fileBuff;
#endif

    static
    BYTE            DOSstub[] =
    {
        /*0040*/ 0x0E,              //  PUSH    CS
        /*0041*/ 0x1F,              //  POP     DS
        /*0042*/ 0xE8, 0x00, 0x00,  //  CALL    $+3
        /*0045*/ 0x5A,              //  POP     DX
        /*0046*/ 0x83, 0xC2, 0x0D,  //  ADD     DX,+0D
        /*0049*/ 0xB4, 0x09,        //  MOV     AH,09
        /*004B*/ 0xCD, 0x21,        //  INT     21
        /*004D*/ 0xB8, 0x01, 0x4C,  //  MOV     AX,4C01
        /*0050*/ 0xCD, 0x21,        //  INT     21
        /*0052*/ "This program cannot be run in DOS mode\r\n$\0\0\0\0"
    };

    static
    IMAGE_DOS_HEADER fileHdrTemplate =
    {
        0x5A4D,                     // magic
        0x0090,                     // bytes in last page
        0x0003,                     // number of pages
             0,                     // relocations
        0x0004,                     // header size
             0,                     // min extra
        0xFFFF,                     // max extra
             0,                     // initial SS
        0x0080,                     // initial SP
             0,                     // checksum
             0,                     // initial IP
             0,                     // initial CS
        0x0040,                     // reloc table
             0,                     // overlay num
            {0},                    // reserved
             0,                     // OEM id
             0,                     // OEM info
            {0},                    // reserved
        0x0080,                     // addr of new header
    };

    IMAGE_DOS_HEADER        fileHdr;

    IMAGE_FILE_HEADER       COFFhdr;
    time_t                  COFFstamp;

    IMAGE_OPTIONAL_HEADER   OPTLhdr;

    /* Bail if there were any compilation errors */

    if  (errors)
    {
        // UNDONE: Free up all resources, etc.

        return true;
    }

    /* Drop any image sections that are empty */

    for (sectNum = 0; sectNum < PE_SECT_count; sectNum++)
    {
        /* Get hold of the section entry */

        sectPtr = WPEsecTable[sectNum];
        if  (!sectPtr)
            continue;

        assert(sectPtr->PEsdIndex == (int)sectNum);

        /* Is this section empty? */

        if  (sectPtr->PEsdNext == sectPtr->PEsdBase)
        {
            /* The ".rdata" section is never empty */

            if  (sectNum == PE_SECT_rdata)
                continue;

            /* Don't drop non-empty ".rsrc"/".reloc" sections */

            if  (sectNum == PE_SECT_rsrc  && WPErsrcSize)
                continue;
            if  (sectNum == PE_SECT_reloc /*&& WPEcomp->cmpConfig.ccOutDLL*/)
                continue;

            /* Drop this section from the table */

            WPEsecTable[sectNum] = NULL; WPEsectCnt--;
        }
    }

    /* Figure out the virtual base address of the image */

    if  (WPEcomp->cmpConfig.ccOutBase)
    {
        size_t          align;

        /* The base must be a multiple of 64K, at least */

        align = (PEvirtAlignment >= 64*1024) ? PEvirtAlignment
                                             : 64*1024;

        /* The base address was specified, make sure it's aligned */

        virtBase  = WPEcomp->cmpConfig.ccOutBase;

        virtBase +=  (align - 1);
        virtBase &= ~(align - 1);

        /* The base must be at least 0x400000 */

        if  (virtBase < 0x400000)
             virtBase = 0x400000;
    }
    else
    {
        /* Use the default base address */

        virtBase  = WPEcomp->cmpConfig.ccOutDLL ? 0x10000000
                                                : 0x00400000;
    }

    WPEvirtBase = virtBase;

    /* Count/reserve space for the file headers */

    fileOffs    = 0;

    /* The first thing is the DOS hader */

    DOS_hdrSize = sizeof(IMAGE_DOS_HEADER);
    DOS_hdrOffs = fileOffs;
                  fileOffs += 0xB8; // DOS_hdrSize;

    /* The PE/COFF headers are next */

    COFFhdrSize = sizeof(IMAGE_FILE_HEADER) + 4;    // 4 bytes = "magic" signature
    COFFhdrOffs = fileOffs;
                  fileOffs += COFFhdrSize;

    OPTLhdrSize = sizeof(IMAGE_OPTIONAL_HEADER);
    OPTLhdrOffs = fileOffs;
                  fileOffs += OPTLhdrSize;

    /* Next comes the section table */

    sectTabSize = sizeof(IMAGE_SECTION_HEADER) * WPEsectCnt;
    sectTabOffs = fileOffs;
                  fileOffs += sectTabSize;

    /* Allocate space for the various sections (properly aligning them) */

    virtOffs = PEvirtAlignment;

    /* Figure out the RVA of the main entry point */

    entryOfs = virtOffs;        // UNDONE: Compute RVA of entry point
    entryAdr = entryOfs + 2;

#ifdef  DEBUG

    if  (WPEcomp->cmpConfig.ccVerbose >= 2)
    {
        printf("DOS  header is at 0x%04X (size=0x%02X)\n", DOS_hdrOffs, DOS_hdrSize);
        printf("COFF header is at 0x%04X (size=0x%02X)\n", COFFhdrOffs, COFFhdrSize);
        printf("Opt. header is at 0x%04X (size=0x%02X)\n", OPTLhdrOffs, OPTLhdrSize);
        printf("Section tab is at 0x%04X (size=0x%02X)\n", sectTabOffs, sectTabSize);
        printf("Section[0]  is at 0x%04X\n"              , fileOffs);
    }

#endif

    dataVirt = dataSize =
    rlocVirt = rlocSize =
    rsrcVirt = rsrcSize = bssSize = fImgSize = 0;

    for (sectNum = 0; sectNum < PE_SECT_count; sectNum++)
    {
        size_t          size;
        unsigned        attr;

        /* Get hold of the section entry */

        sectPtr = WPEsecTable[sectNum];
        if  (!sectPtr)
            continue;

        assert(sectPtr->PEsdIndex == (int)sectNum);

        /* Each section must be properly aligned */

        fileOffs = (fileOffs + (PEfileAlignment-1)) & ~(PEfileAlignment-1);
        virtOffs = (virtOffs + (PEvirtAlignment-1)) & ~(PEvirtAlignment-1);

        /* Figure out how much data we've stored in the section */

        size = sectPtr->PEsdSizeData = sectPtr->PEsdNext - sectPtr->PEsdBase;

        /* What kind of a section is this? */

        switch (sectNum)
        {
        case PE_SECT_text:

            /* Check the RVA of the section */

            assert(virtOffs == CODE_BASE_RVA);

            /* Below we'll patch the entry point code sequence */

            ecodePtr = (unsigned *)(sectPtr->PEsdBase + 2);

            /* Remember the code size and base offset */

            codeSize = size;
            codeOffs = fileOffs;
            codeVirt = virtOffs;

            assert(codeVirt == CODE_BASE_RVA);

            attr     = IMAGE_SCN_CNT_CODE  |
                       IMAGE_SCN_MEM_READ  |
                       IMAGE_SCN_MEM_EXECUTE;
            break;

        case PE_SECT_data:

            /* Record the RVA of the .rdata section */

            WPEdataRVA = virtOffs;

            /* Now we can set the RVA's of all global variables */

            WPEcomp->cmpSetGlobMDoffs(virtOffs);

            /* Figure out the size and flags for the section */

            dataSize = size;
            dataOffs = fileOffs;
            dataVirt = virtOffs;

            attr     = IMAGE_SCN_MEM_READ  |
                       IMAGE_SCN_MEM_WRITE |
                       IMAGE_SCN_CNT_INITIALIZED_DATA;
            break;

        case PE_SECT_rdata:

            /* Record the RVA of the .rdata section */

            WPErdatRVA = virtOffs;

            /* Patch the entry code sequence */

            *ecodePtr   = virtOffs + virtBase;

            /* Finish up the import directory */

            size       += WPEimportDone(size);

            /* Reserve space for the CLR header and metadata */

            size       += WPEgetCOMplusSize(size);

            /* Reserve space for the Debug Directory and our one entry */

            size       += WPEgetDebugDirSize(size);

            /* Remember the offset and size of the section */

            rdatSize    = size;
            rdatOffs    = fileOffs;
            rdatVirt    = virtOffs;

            attr        = IMAGE_SCN_MEM_READ  |
                          IMAGE_SCN_CNT_INITIALIZED_DATA;
            break;

        case PE_SECT_rsrc:

            /* Record the RVA and size of the .rdata section */

            WPErsrcRVA  = virtOffs;
            size        = sectPtr->PEsdSizeData = WPErsrcSize;

            /* Remember the offset and size of the section */

            rsrcSize    = size;
            rsrcOffs    = fileOffs;
            rsrcVirt    = virtOffs;

            attr        = IMAGE_SCN_MEM_READ  |
                          IMAGE_SCN_CNT_INITIALIZED_DATA;
            break;

        case PE_SECT_reloc:

            //assert(WPEcomp->cmpConfig.ccOutDLL);

            /* The following is kind of lame, but it's good enough for now */

            sectPtr->PEsdSizeData = size = 4 + 4 + 2 * 2;    // space for 2 fixups

            /* Remember the offset and size of the section */

            rlocSize    = size;
            rlocOffs    = fileOffs;
            rlocVirt    = virtOffs;

            attr        = IMAGE_SCN_MEM_READ        |
                          IMAGE_SCN_MEM_DISCARDABLE |
                          IMAGE_SCN_CNT_INITIALIZED_DATA;

            break;

        default:
            UNIMPL(!"check for unusual section type");
        }

#ifdef  DEBUG
        if  (WPEcomp->cmpConfig.ccVerbose >= 2) printf("  Section hdr #%u at 0x%04X = %08X (size=0x%04X)\n", sectNum, fileOffs, virtOffs, size);
#endif

        /* Update the rounded-up file image size */

        fImgSize += roundUp(size, PEvirtAlignment);

        /* Record the flags (read/write, execute, and so on */

        sectPtr->PEsdFlags    = attr;

        /* Assign a file and virtual base offset to the section */

        sectPtr->PEsdAddrFile = fileOffs;
                                fileOffs += size;

        sectPtr->PEsdAddrRVA  = virtOffs;
                                virtOffs += size;
    }

    /* Compute the total image size, including the headers */
    fImgSize += DOS_hdrSize +                                                  
                COFFhdrSize +
                OPTLhdrSize +
                sectTabSize;

    /* Make sure the size isn't too big */

    if  (virtOffs > WPEcomp->cmpConfig.ccOutSize && WPEcomp->cmpConfig.ccOutSize)
        WPEcomp->cmpGenWarn(WRNpgm2big, virtOffs, WPEcomp->cmpConfig.ccOutSize);

    /* The file size has to be a page multiple [ISSUE: why?] */

    fileOffs = roundUp(fileOffs, PEfileAlignment);

    /* Figure out the RVA of the string pool */

    strPoolRVA = WPEstrPoolBase + dataVirt;
    strPoolAdr = strPoolRVA + virtBase;

    WPEcomp->cmpSetStrCnsOffs(strPoolRVA);

    /* Start writing to the output file */

    outf = WPEoutFile = (OutFile)WPEalloc->nraAlloc(sizeof(*outf));

#ifdef  DLL
    if  (*WPEoutFnam == ':' && !stricmp(WPEoutFnam, ":memory:"))
    {
        fileBuff = VirtualAlloc(NULL, fileOffs, MEM_COMMIT, PAGE_READWRITE);
        if  (!fileBuff)
            WPEcomp->cmpFatal(ERRnoMemory);

        outf->outFileOpen(WPEcomp, fileBuff);

        WPEcomp->cmpOutputFile = fileBuff;
    }
    else
#endif
        outf->outFileOpen(WPEcomp, WPEoutFnam);

    /* Fill in the DOS file header */

    fileHdr        = fileHdrTemplate;

    fileHdr.e_cblp = (fileOffs        & 511);
    fileHdr.e_cp   = (fileOffs + 511) / 512;

    /* Write out the DOS header */

    outf->outFileWriteData(&fileHdr, sizeof(fileHdr));

    /* Write out the DOS stub */

    assert(outf->outFileOffset() == 16U*fileHdr.e_cparhdr);
    outf->outFileWriteData(DOSstub, sizeof(DOSstub));

    /* Next comes the COFF header */

    assert(outf->outFileOffset() == (unsigned)fileHdr.e_lfanew);
    outf->outFileWriteData(COFFmagic, sizeof(COFFmagic));

    /* Compute the timedate stamp */

    time(&COFFstamp);

    /* Fill in and write out the COFF header */

    COFFhdr.Machine                     = IMAGE_FILE_MACHINE_I386;
    COFFhdr.NumberOfSections            = WPEsectCnt;
    COFFhdr.TimeDateStamp               = COFFstamp;
    COFFhdr.PointerToSymbolTable        = 0;
    COFFhdr.NumberOfSymbols             = 0;
    COFFhdr.SizeOfOptionalHeader        = sizeof(OPTLhdr);
    COFFhdr.Characteristics             = IMAGE_FILE_EXECUTABLE_IMAGE    |
                                          IMAGE_FILE_32BIT_MACHINE       |
                                          IMAGE_FILE_LINE_NUMS_STRIPPED  |
                                          IMAGE_FILE_LOCAL_SYMS_STRIPPED;

    if  (WPEcomp->cmpConfig.ccOutDLL)
        COFFhdr.Characteristics |= IMAGE_FILE_DLL;
    //else
    //    COFFhdr.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;

    outf->outFileWriteData(&COFFhdr, sizeof(COFFhdr));

    /* Next comes the optional COFF header */

    memset(&OPTLhdr, 0, sizeof(OPTLhdr));

    OPTLhdr.Magic                       = IMAGE_NT_OPTIONAL_HDR_MAGIC;
    OPTLhdr.MajorLinkerVersion          = 7;
//  OPTLhdr.MinorLinkerVersion          = 0;
    OPTLhdr.SizeOfCode                  = roundUp(codeSize, PEfileAlignment);
    OPTLhdr.SizeOfInitializedData       = roundUp(dataSize, PEfileAlignment) + 0x400;
    OPTLhdr.SizeOfUninitializedData     = roundUp( bssSize, PEfileAlignment);
    OPTLhdr.AddressOfEntryPoint         = entryOfs;
    OPTLhdr.BaseOfCode                  = codeVirt;
#ifndef HOST_IA64
    OPTLhdr.BaseOfData                  = dataVirt;
#endif
    OPTLhdr.ImageBase                   = virtBase;
    OPTLhdr.SectionAlignment            = PEvirtAlignment;
    OPTLhdr.FileAlignment               = PEfileAlignment;
    OPTLhdr.MajorOperatingSystemVersion = 4;
    OPTLhdr.MinorOperatingSystemVersion = 0;
//  OPTLhdr.Win32VersionValue           = 0;
    OPTLhdr.SizeOfImage                 = roundUp(fImgSize, PEvirtAlignment);

    OPTLhdr.SizeOfHeaders               = roundUp(sizeof(fileHdr  ) +
                                                  sizeof(DOSstub  ) +
                                                  sizeof(COFFmagic) +
                                                  sizeof(OPTLhdr  ), PEfileAlignment);
//  OPTLhdr.MajorImageVersion           = 0;
//  OPTLhdr.MinorImageVersion           = 0;
    OPTLhdr.MajorSubsystemVersion       = 4;
//  OPTLhdr.MinorSubsystemVersion       = 0;
//  OPTLhdr.Win32VersionValue           = 0;
    OPTLhdr.Subsystem                   = WPEcomp->cmpConfig.ccSubsystem;
//  OPTLhdr.DllCharacteristics          = 0;
    OPTLhdr.SizeOfStackReserve          = 0x100000;
    OPTLhdr.SizeOfStackCommit           = 0x1000;
    OPTLhdr.SizeOfHeapReserve           = 0x100000;
    OPTLhdr.SizeOfHeapCommit            = 0x1000;
//  OPTLhdr.LoaderFlags                 = 0;
    OPTLhdr.NumberOfRvaAndSizes         = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;

    /* Fill in the dictionary */

    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT        ].VirtualAddress = WPEimpOffsIDT+rdatVirt;
    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT        ].Size           = WPEimpSizeIDT;

    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT           ].VirtualAddress = WPEimpOffsIAT+rdatVirt;
    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT           ].Size           = WPEimpSizeIAT;

    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE      ].VirtualAddress = rsrcVirt;
    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE      ].Size           = rsrcSize;

    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC     ].VirtualAddress = rlocVirt;
    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC     ].Size           = rlocSize;

    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress = WPEcomPlusOffs+rdatVirt;
    OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size           = sizeof(IMAGE_COR20_HEADER);

    if (WPEdebugDirDataSize != 0)
    {
        OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG         ].VirtualAddress = WPEdebugDirOffs+rdatVirt;
        OPTLhdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG         ].Size           = WPEdebugDirSize;
    }

    /* Write out the optional header */

    outf->outFileWriteData(&OPTLhdr, sizeof(OPTLhdr));

    /* Write out the section table */

    for (sectNum = 0; sectNum < PE_SECT_count; sectNum++)
    {
        size_t                  dataSize;
        IMAGE_SECTION_HEADER    sectHdr;

        /* Get hold of the section entry */

        sectPtr = WPEsecTable[sectNum];
        if  (!sectPtr)
            continue;

        assert(sectPtr->PEsdIndex == (int)sectNum);

        dataSize = sectPtr->PEsdSizeData;

        /* The import table (and CLR/debugger goo) size is added to .rdata */

        if  (sectNum == PE_SECT_rdata)
        {
            dataSize += WPEimpSizeAll   +
                        WPEcomPlusSize  +
                        WPEdebugDirSize +
                        WPEdebugDirDataSize;
        }

        memcpy(&sectHdr.Name, WPEsecName((WPEstdSects)sectNum), sizeof(sectHdr.Name));

        sectHdr.Misc.VirtualSize     = dataSize;
        sectHdr.VirtualAddress       = sectPtr->PEsdAddrRVA;
        sectHdr.SizeOfRawData        = roundUp(dataSize, PEfileAlignment);
        sectHdr.PointerToRawData     = sectPtr->PEsdAddrFile;
        sectHdr.PointerToRelocations = 0;
        sectHdr.PointerToLinenumbers = 0;
        sectHdr.NumberOfRelocations  = 0;
        sectHdr.NumberOfLinenumbers  = 0;
        sectHdr.Characteristics      = sectPtr->PEsdFlags;

        /* Write out the section table entry */

        outf->outFileWriteData(&sectHdr, sizeof(sectHdr));
    }

    /* Output the contents of all the sections */

    for (sectNum = 0; sectNum < PE_SECT_count; sectNum++)
    {
        size_t          padSize;

        /* Get hold of the section entry */

        sectPtr = WPEsecTable[sectNum];
        if  (!sectPtr)
            continue;

        assert(sectPtr->PEsdIndex == (int)sectNum);

        /* Pad to get to the next file alignment boundary */

        padSize = sectPtr->PEsdAddrFile - outf->outFileOffset(); assert((int)padSize >= 0);

        if  (padSize)
            outf->outFileWritePad(padSize);

        /* Output the contents of the section */

        switch (sectNum)
        {
        case PE_SECT_rdata:

            /* First we output the import table */

            WPEimportGen     (outf, sectPtr);

            /* Output the CLR data */

            WPEgenCOMplusData(outf, sectPtr, entryTok);

            /* Output the CLR data */

            WPEgenDebugDirData(outf, sectPtr, COFFstamp);

            /* Are there any relocs in this section? */

            if  (sectPtr->PEsdRelocs)
            {
                UNIMPL(!"relocs in .rdata - can this happen?");
            }

            break;

        case PE_SECT_rsrc:

            WPEgenRCcont(outf, sectPtr);
            break;

        case PE_SECT_reloc:
            {
                unsigned    temp;

                /* Output the page RVA and total fixup block size */

                temp = CODE_BASE_RVA; outf->outFileWriteData(&temp, 4);
                temp = 4 + 4 + 2 * 2; outf->outFileWriteData(&temp, 4);

                /* Output the first  offset + type pair */

                assert(entryAdr - CODE_BASE_RVA < 0x1000);

                temp = (IMAGE_REL_BASED_HIGHLOW << 12) + (entryAdr - CODE_BASE_RVA);
                outf->outFileWriteData(&temp, 2);

                /* Output the second offset + type pair */

                temp = 0;
                outf->outFileWriteData(&temp, 2);
            }
            break;

        default:

            /* Are there any relocs in this section? */

            if  (sectPtr->PEsdRelocs)
            {
                PEreloc         rel;

                for (rel = sectPtr->PEsdRelocs; rel; rel = rel->perNext)
                {
                    unsigned        adjustv;
                    PEsection       sectDst;
                    BYTE        *   patch;

                    /* Is this a string pool fixup? */

                    if  (rel->perSect == PE_SECT_string)
                    {
                        /* Adjust by the RVA of the string pool */

                        adjustv = (sectNum == PE_SECT_text) ? strPoolRVA
                                                            : strPoolAdr;

                        /* Make sure the string pool has been allocated */

                        assert(WPEstrPoolBase != 0xBEEFCAFE);
                    }
                    else
                    {
                        /* Get hold of the target section */

                        sectDst = WPEgetSection((WPEstdSects)rel->perSect);

                        /* The value needs to be adjusted by the section's RVA */

                        adjustv = sectDst->PEsdAddrRVA;
                    }

                    /* Compute the address to be patched */

                    patch = sectPtr->PEsdBase + rel->perOffs;

                    /* Make sure the patched value is within the section */

                    assert(patch + sizeof(int) <= sectPtr->PEsdNext);

                    /* Update the value with the section's RVA */

#ifdef  DEBUG
//                  printf("Reloc patch: %04X -> %04X\n", *(unsigned *)patch, *(unsigned *)patch + adjustv);
#endif

                    *(unsigned *)patch += adjustv;
                }
            }

            /* Output the contents of the section */

            outf->outFileWriteData(sectPtr->PEsdBase, sectPtr->PEsdSizeData);
            break;
        }
    }

    /* Pad the file to a multiple of page size */

    filePad = fileOffs - outf->outFileOffset();

    if  (filePad)
    {
        assert((int)filePad > 0);
        assert((int)filePad < PEfileAlignment);

        outf->outFileWritePad(filePad);
    }

    /* Tell the compiler that we're just about done */

    WPEcomp->cmpOutputFileDone(outf);

    /* Close the output file and we're done */

    outf->outFileDone();

    if  (!WPEcomp->cmpConfig.ccQuiet)
        printf("%u bytes written to '%s'\n", fileOffs, WPEoutFnam);

    return  false;
}

/*****************************************************************************
 *
 *  Finalize CLR / metadata output and return the total size of the CLR
 *  tables.
 */

size_t              writePE::WPEgetCOMplusSize(unsigned offs)
{
    DWORD           temp;
    size_t          size = 0;

    /* Remember the base offset of the CLR section */

    WPEcomPlusOffs  = offs;

    temp  = sizeof(IMAGE_COR20_HEADER);
    offs += temp;
    size += temp;

    /* Get the final size of the metadata */

    if  (WPEwmde->GetSaveSize(cssAccurate, &temp))
        WPEcomp->cmpFatal(ERRopenCOR);  // UNDONE: issue a more meaningful error

    WPEmetaDataSize = temp;
    WPEmetaDataOffs = offs;

    offs += temp;
    size += temp;

    /* Add the size of the vtable section, if any */

    size += WPEcomp->cmpVtableCount * sizeof(IMAGE_COR_VTABLEFIXUP);

    /* Remember the size of all of the CLR tables */

    WPEcomPlusSize  = size;

    return  size;
}

/*****************************************************************************
 *
 *  Write the CLR table (and metadata) to the output file.
 */

void                writePE::WPEgenCOMplusData(OutFile outf, PEsection sect,
                                                             mdToken   entryTok)
{
    unsigned        baseFile = WPEmetaDataOffs + sect->PEsdAddrFile;
    unsigned        baseRVA  = WPEmetaDataOffs + sect->PEsdAddrRVA;

    unsigned        vtabSize = WPEcomp->cmpVtableCount * sizeof(IMAGE_COR_VTABLEFIXUP);

    IMAGE_COR20_HEADER  COMhdr;

    /* Fill in the CLR header */

    memset(&COMhdr, 0, sizeof(COMhdr));

    COMhdr.cb                          = sizeof(COMhdr);
    COMhdr.MajorRuntimeVersion         = 2;
    COMhdr.MinorRuntimeVersion         = 0;
    COMhdr.Flags                       = COMIMAGE_FLAGS_ILONLY;
    COMhdr.EntryPointToken             = entryTok;

    COMhdr.MetaData    .VirtualAddress = baseRVA;
    COMhdr.MetaData    .Size           = WPEmetaDataSize;

    COMhdr.VTableFixups.VirtualAddress = vtabSize ? baseRVA + WPEmetaDataSize : 0;
    COMhdr.VTableFixups.Size           = vtabSize;

    /* Write the CLR header to the file */

    outf->outFileWriteData(&COMhdr, sizeof(COMhdr));

    /* Output the metadata */

//  printf("Writing %u bytes of MD\n", WPEmetaDataSize);

    void    *       MDbuff = LowLevelAlloc(WPEmetaDataSize);
    if  (!MDbuff)
        WPEcomp->cmpFatal(ERRnoMemory);

    if  (WPEwmde->SaveToMemory(MDbuff, WPEmetaDataSize))
        WPEcomp->cmpFatal(ERRmetadata);

    outf->outFileWriteData(MDbuff, WPEmetaDataSize);

    LowLevelFree(MDbuff);

    /* Shut down the RC file import logic */

    WPEdoneRCimp();

    /* Append any unmanaged vtable entries to the end */

    if  (vtabSize)
    {
        SymList                 vtbls;
        IMAGE_COR_VTABLEFIXUP   fixup;
#ifndef NDEBUG
        unsigned                count = 0;
#endif

        for (vtbls = WPEcomp->cmpVtableList; vtbls; vtbls = vtbls->slNext)
        {
            SymDef                  vtabSym = vtbls->slSym;

            assert(vtabSym->sdSymKind == SYM_VAR);
            assert(vtabSym->sdVar.sdvIsVtable);

            fixup.RVA   = vtabSym->sdVar.sdvOffset + WPEdataRVA;
            fixup.Count = vtabSym->sdParent->sdClass.sdcVirtCnt;
            fixup.Type  = COR_VTABLE_32BIT;

#ifndef NDEBUG
            count++;
#endif

            outf->outFileWriteData(&fixup, sizeof(fixup));
        }

        assert(count == WPEcomp->cmpVtableCount);
    }
}

/*****************************************************************************
 *
 *  Finalize Debug Directory output and return the total size of the data
 *  tables.
 */

size_t              writePE::WPEgetDebugDirSize(unsigned offs)
{
    DWORD           temp;
    size_t          size = 0;

    /* Only emit the directory if there is data to be emitted */

    if (WPEdebugDirDataSize == 0)
        return 0;

    /* Remember the base offset of the CLR section */

    WPEdebugDirOffs  = offs;

    temp  = sizeof(WPEdebugDirIDD) + WPEdebugDirDataSize;
    offs += temp;
    size += temp;

    /* Remember the size of just the debug directory */

    WPEdebugDirSize  = sizeof(WPEdebugDirIDD);

    /*
     * Return the size of both the directory and the data the
     * directory will point to. This is so that we reserve enough
     * space in the section for everything.
     */

    return  size;
}

/*****************************************************************************
 *
 *  Write the Debug Directory (and data) to the output file.
 */

void                writePE::WPEgenDebugDirData(OutFile outf,
                                                PEsection sect,
                                                DWORD timestamp)
{
    /* Only emit the directory if there is data to be emitted */

    if (WPEdebugDirDataSize == 0)
        return;

    /* We have to set the timestamp and the addresses */

    WPEdebugDirIDD.TimeDateStamp    = timestamp;
    WPEdebugDirIDD.AddressOfRawData = 0;

    /* The data for this entry goes right after it */

    WPEdebugDirIDD.PointerToRawData = WPEdebugDirOffs + sizeof(WPEdebugDirIDD)
                                                      + sect->PEsdAddrFile;

    /* Emit the directory entry */

    outf->outFileWriteData(&WPEdebugDirIDD, sizeof(WPEdebugDirIDD));

    /* Emit the data */

    outf->outFileWriteData(WPEdebugDirData, WPEdebugDirDataSize);
}

/*****************************************************************************
 *
 *  Initialize and shut down the RC file import logic.
 */

void                writePE::WPEinitRCimp()
{
    WPErsrcFile =
    WPErsrcFmap = 0;
    WPErsrcSize = 0;
}

void                writePE::WPEdoneRCimp()
{
    if  (WPErsrcFmap) { CloseHandle(WPErsrcFmap);WPErsrcFmap = 0; }
    if  (WPErsrcFile) { CloseHandle(WPErsrcFile);WPErsrcFile = 0; }
}

/*****************************************************************************
 *
 *  Add a resource file to the output.
 */

bool                writePE::WPEaddRCfile(const char *filename)
{
    _Fstat          fileInfo;

    HANDLE          fileFile = 0;
    HANDLE          fileFMap = 0;

    size_t          fileSize;
    const   BYTE  * fileBase;

    cycleCounterPause();

    /* See if the source file exists */

    if  (_stat(filename, &fileInfo))
        WPEcomp->cmpGenFatal(ERRopenRdErr, filename);

    /* Open the file (we know it exists, but we check for errors anyway) */

    fileFile = CreateFileA(filename, GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
    if  (!fileFile)
        WPEcomp->cmpGenFatal(ERRopenRdErr, filename);

    /* Create a mapping on the input file */

    fileFMap = CreateFileMappingA(fileFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if  (!fileFMap)
    {
    ERR:
        if  (fileFMap) CloseHandle(fileFMap);
        if  (fileFile) CloseHandle(fileFile);

        return  true;
    }

    /* Map the whole file into memory for easy access */

    fileSize = fileInfo.st_size;
    fileBase = (const BYTE*)MapViewOfFileEx(fileFMap, FILE_MAP_READ, 0, 0, 0, NULL);
    if  (!fileBase)
        goto ERR;

    cycleCounterResume();

    /* We've got the file in memory, make sure the header looks OK */

    IMAGE_FILE_HEADER * hdrPtr = (IMAGE_FILE_HEADER *)fileBase;

    if  (hdrPtr->Machine              != IMAGE_FILE_MACHINE_I386  ||
//       hdrPtr->Characteristics      != IMAGE_FILE_32BIT_MACHINE ||
         hdrPtr->NumberOfSections     == 0                        ||
         hdrPtr->SizeOfOptionalHeader != 0)
    {
        WPEcomp->cmpGenFatal(ERRbadInputFF, filename, "resource");
    }

    /* Add up the size of all the interesting sections */

    IMAGE_SECTION_HEADER *  sectTab = (IMAGE_SECTION_HEADER*)(hdrPtr+1);
    unsigned                sectCnt = hdrPtr->NumberOfSections;

    do
    {
        if  (sectTab->Characteristics & IMAGE_SCN_MEM_DISCARDABLE)
            continue;

//      printf("Section %8s: size = %04X, char = %04X\n", sectTab->Name, sectTab->SizeOfRawData);

        WPErsrcSize += sectTab->SizeOfRawData;
    }
    while (++sectTab, --sectCnt);

    WPErsrcFmap = fileFMap;
    WPErsrcFile = fileFile;
    WPErsrcBase = fileBase;

    WPEaddSection(PE_SECT_rsrc, 0, roundUp(WPErsrcSize, OS_page_size));

    /* Indicate success to the caller */

    return  false;
}

/*****************************************************************************
 *
 *  Output the contents of the resource file to the output image.
 */

void                writePE::WPEgenRCcont(OutFile  outf, PEsection sect)
{
    unsigned                baseRVA  = sect->PEsdAddrRVA;

    const   BYTE *          fileBase = WPErsrcBase;

    IMAGE_FILE_HEADER     * hdrPtr   = (IMAGE_FILE_HEADER   *)fileBase;

    IMAGE_SECTION_HEADER  * sectTab  = (IMAGE_SECTION_HEADER*)(hdrPtr+1);
    unsigned                sectCnt  = hdrPtr->NumberOfSections;
    unsigned                sectRVA;

    IMAGE_SYMBOL  *         symTab   = NULL;
    unsigned                symCnt   = 0;

    if  (hdrPtr->PointerToSymbolTable)
    {
        IMAGE_SYMBOL  *         symPtr;
        unsigned                symNum;
        size_t                  symSiz;

        IMAGE_SECTION_HEADER  * sectPtr = sectTab;
        int                     sectNum = 1;

        /* Make a copy of the symbol table */

        symCnt = symNum = hdrPtr->NumberOfSymbols;
        symSiz = symCnt * sizeof(*symTab);
        symTab = symPtr = (IMAGE_SYMBOL*)WPEalloc->nraAlloc(symSiz);

        memcpy(symTab, fileBase + hdrPtr->PointerToSymbolTable, symSiz);

        /* Fill in the address of the symbols that refer to sections */

        sectRVA = baseRVA;

        do
        {
            if  (symPtr->StorageClass  == IMAGE_SYM_CLASS_STATIC &&
                 symPtr->SectionNumber > 0)
            {
                if  (symPtr->SectionNumber != sectNum)
                {
                    for (sectNum = 1, sectRVA  = baseRVA, sectPtr = sectTab;
                         sectNum < symPtr->SectionNumber;
                         sectNum++)
                    {
                        if  (!(sectPtr->Characteristics & IMAGE_SCN_MEM_DISCARDABLE))
                            sectRVA += sectPtr->SizeOfRawData;

                        sectPtr += 1;
                    }
                }

                if  (!(sectPtr->Characteristics & IMAGE_SCN_MEM_DISCARDABLE))
                {
                    if  (symPtr->Value != 0)
                    {
                        UNIMPL("hang on - a COFF symbol with a value, what now?");
                    }

                    symPtr->Value = sectRVA;

//                  char temp[9]; memcpy(temp, symPtr->N.ShortName, sizeof(symPtr->N.ShortName)); temp[8] = 0;
//                  printf("Symbol  %8s: sect=%u RVA=%08X\n", temp, sectNum, sectRVA);

                    sectRVA += sectPtr->SizeOfRawData;
                }

                sectPtr += 1;
                sectNum += 1;
            }
        }
        while (++symPtr, --symNum);
    }

    /* Output the sections to the output file */

    sectRVA = baseRVA;

    do
    {
        unsigned        relCnt;

        const   BYTE  * sectAdr;
        size_t          sectSiz;

        if  (sectTab->Characteristics & IMAGE_SCN_MEM_DISCARDABLE)
            continue;

        /* Figure out the address/size of the section contents in memory */

        sectAdr = sectTab->PointerToRawData + fileBase;
        sectSiz = sectTab->   SizeOfRawData;

        /* Are there any relocs in this section? */

        relCnt  = sectTab->NumberOfRelocations;
        if  (relCnt)
        {
            BYTE              * buffAdr;
            IMAGE_RELOCATION  * relTab = (IMAGE_RELOCATION*)(fileBase + sectTab->PointerToRelocations);

            /* Make a copy of the section so we can scribble on it */

            buffAdr = (BYTE*)WPEalloc->nraAlloc(roundUp(sectSiz));
            memcpy(buffAdr, sectAdr, sectSiz); sectAdr = buffAdr;

            do
            {
                unsigned                symNum = relTab->SymbolTableIndex;
                IMAGE_SYMBOL          * symPtr = symTab + symNum;
                IMAGE_SECTION_HEADER  * sectTmp;

//              printf("Reloc at offs %04X: symbol = %u, type = %u\n", relTab->VirtualAddress,
//                                                                     relTab->SymbolTableIndex,
//                                                                     relTab->Type);

                if  (relTab->Type != IMAGE_REL_I386_DIR32NB)
                {
                    UNIMPL("unrecognized fixup type found in .res file");
                }

                assert(symNum < symCnt);

                if  (symPtr->StorageClass != IMAGE_SYM_CLASS_STATIC)
                {
                    UNIMPL("unrecognized fixup target symbol found in .res file");
                }

                assert(symPtr->SectionNumber  >  0);
                assert(symPtr->SectionNumber  <= (int)hdrPtr->NumberOfSections);

//              printf("Fixup location @ %04X\n", relTab->VirtualAddress);
//              printf("Fixup   symbol @ %08X\n", symPtr->Value);
//              printf("Fixup section  #  u  \n", symPtr->SectionNumber);

                sectTmp = sectTab + symPtr->SectionNumber;

//              printf("Section offset = %08X\n", sectTab->VirtualAddress);
//              printf("Section size   = %04X\n", sectTab->SizeOfRawData);

                assert(relTab->VirtualAddress >= 0);
                assert(relTab->VirtualAddress <  sectTmp->SizeOfRawData);

                *(int*)(sectAdr + relTab->VirtualAddress) += symPtr->Value;
            }
            while (++relTab, --relCnt);
        }

        /* Append the section to the output file */

        outf->outFileWriteData(sectAdr, sectSiz);

        sectRVA += sectTab->SizeOfRawData;
    }
    while (++sectTab, --sectCnt);
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\outfile.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include "outfile.h"

/*****************************************************************************/

#include <io.h>
#include <conio.h>
#include <fcntl.h>
#include <sys/stat.h>

/*****************************************************************************
 *
 *  Open an output file by path name; the 'buffSize' paremeter specifies
 *  the output buffer size, and 'buffAddr' (when NULL) is the address of
 *  a caller-supplied output buffer (if NULL, we allocate one locally).
 */

void                outFile::outFileOpen(Compiler       comp,
                                         const char *   name,
                                         bool           tempFile,
                                         size_t         buffSize,
                                         char *         buffAddr)
{
    outFileComp      = comp;

    /* Assume we won't be allocating a buffer */

    outFileBuffAlloc = false;
    outFileBuffAddr  = buffAddr;

    /* Save the output file name (for error messages and deletion upon error) */

    strcpy(outFileName, name);

    /* Open/create the output file */

    cycleCounterPause();
    outFileHandle = _open(name, _O_WRONLY|_O_BINARY|_O_CREAT|_O_TRUNC|_O_SEQUENTIAL, _S_IWRITE|_S_IREAD);
    cycleCounterResume();

    if  (outFileHandle == -1)
        comp->cmpGenFatal(ERRopenWrErr, name);

    /* Use default buffer size if caller didn't choose */

    if  (!buffSize)
        buffSize = 4*1024;      // 4K seems a good size

    outFileBuffSize = buffSize;

    /* Do we need to allocate a buffer? */

    if  (!buffAddr)
    {
        outFileBuffAddr = (char *)VirtualAlloc(NULL, buffSize, MEM_COMMIT, PAGE_READWRITE);
        if  (!outFileBuffAddr)
            comp->cmpFatal(ERRnoMemory);
        outFileBuffAlloc = true;
    }

    /* Set the next and last free byte values */

    outFileBuffNext = outFileBuffAddr;
    outFileBuffLast = outFileBuffAddr + outFileBuffSize;

    /* We are at the beginning of the file */

    outFileBuffOffs = 0;
}

#ifdef  DLL

void                outFile::outFileOpen(Compiler comp, void *dest)
{
    outFileBuffAlloc = false;
    outFileBuffAddr  = (char*)dest;
    outFileBuffSize  = UINT_MAX;
    outFileBuffOffs  = 0;

    outFileBuffNext  = outFileBuffAddr;
    outFileBuffLast  = outFileBuffAddr + outFileBuffSize;

    outFileHandle    = -1; strcpy(outFileName, ":memory:");
}

#endif
/*****************************************************************************
 *
 *  Flush and close the file.
 */

void                outFile::outFileClose()
{
    if  (outFileHandle == -1)
        return;

    assert(outFileBuffAddr);
    assert(outFileBuffNext >= outFileBuffAddr);
    assert(outFileBuffNext <  outFileBuffLast);

    /* Flush the output buffer */

    outFileFlushBuff();

    /* Free up the output buffer if we allocated it on the heap */

    if  (outFileBuffAlloc)
    {
        VirtualFree(outFileBuffAddr, 0, MEM_RELEASE);
                    outFileBuffAddr = NULL;
    }

#ifndef NDEBUG

    /* To catch any abuses, zero everything */

    outFileBuffAddr =
    outFileBuffNext =
    outFileBuffLast = NULL;

#endif

    /* Close the file */

    cycleCounterPause();
    _close(outFileHandle); outFileHandle = -1;
    cycleCounterResume();
}

/*****************************************************************************
 *
 *  Close the given file, free up the resources owned by it, and (optionally)
 *  delete it.
 */

void                outFile::outFileDone(bool delFlag)
{
    /* If we're not deleting the file, make sure the output buffer is flushed */

    if  (!delFlag)
        outFileClose();

    cycleCounterPause();

    /* Close the file */

    if  (outFileHandle != -1)
    {
        _close(outFileHandle);
               outFileHandle = -1;
    }

    /* Delete the file if the caller wishes so */

    if  (delFlag)
        _unlink(outFileName);

    cycleCounterResume();

    /* Free up the output buffer if we allocated it on the heap */

    if  (outFileBuffAlloc)
    {
        VirtualFree(outFileBuffAddr, 0, MEM_RELEASE);
                    outFileBuffAddr = NULL;
    }
}

/*****************************************************************************
 *
 *  Flush whatever is in the output buffer, and reset it to be empty.
 */

void                outFile::outFileFlushBuff()
{
    /* Compute the number of bytes waiting to be written */

    size_t          size = outFileBuffNext - outFileBuffAddr;

    /* Now that we know the size, reset the buffer pointer */

    outFileBuffNext = outFileBuffAddr;

    /* If there was anything in the buffer, write it out */

    if  (size)
    {
        size_t          written;

        cycleCounterPause();
        written = _write(outFileHandle, outFileBuffAddr, size);
        cycleCounterResume();

        if  (written != size)
            outFileComp->cmpGenFatal(ERRwriteErr, outFileName);

        /* Update the current buffer offset */

        outFileBuffOffs += size;
    }
}

/*****************************************************************************
 *
 *  Write the given number of bytes from the specified address.
 */

void                outFile::outFileWriteData(const void *data, size_t size)
{
    assert  (size);

    for (;;)
    {
        size_t      room;
        size_t      copy;

        /* Figure out how much room is in the output buffer */

        room = outFileBuffLast - outFileBuffNext; assert(room);

        /* We'll copy "min(room, size)" bytes */

        copy = room;
        if  (copy > size)
            copy = size;

        memcpy(outFileBuffNext, data, copy); outFileBuffNext += copy;

        /* Did we fill all of the remaining buffer space? */

        if  (copy == room)
        {
            assert(outFileBuffNext == outFileBuffLast);

            outFileFlushBuff();
        }

        /* Did we copy everything? */

        size -= copy;
        if  (!size)
            return;

        /* We have more data to write */

        *(char **)&data += copy;
    }
}

/*****************************************************************************/
#ifdef  OLD_IL
/*****************************************************************************
 *
 *  Go back to the given offset in the output file and patch one byte.
 */

void        outFile::outFilePatchByte(unsigned long offset, int value)
{
    /* We must be patching something that is already written */

    assert(outFileOffset() > offset);

    /* Has the byte being patched gone to disk? */

    if  (outFileBuffOffs > offset)
    {
        /* Make sure we remember the correct file position */

        assert((unsigned long)outFileBuffOffs == (unsigned long)_lseek(outFileHandle, 0, SEEK_CUR));

        /* Seek to the patch position */

        _lseek(outFileHandle, offset, SEEK_SET);

        /* Write the patch value out */

        if  (_write(outFileHandle, &value, 1) != 1)
            outFileComp->cmpGenFatal(ERRwriteErr, outFileName);

        /* Seek back to where we were to begin with */

        _lseek(outFileHandle, outFileBuffOffs, SEEK_SET);
    }
    else
    {
        /* The patch byte must be in the output buffer */

        outFileBuffAddr[offset - outFileBuffOffs] = value;
    }
}

/*****************************************************************************
 *
 *  Go back to the given offset in the output file and patch the given
 *  number of bytes with a new value.
 */

void        outFile::outFilePatchData(unsigned long offset,
                                      const void *  data,
                                      size_t        size)
{
    /* We must be patching something that is already written */

    assert(outFileOffset() >= offset + size);

    /* Has the entire section being patched gone to disk? */

    if  (outFileBuffOffs >= offset + size)
    {
        /* Make sure we remember the correct file position */

        assert((unsigned long)outFileOffset() == (unsigned long)_lseek(outFileHandle, 0, SEEK_CUR));

        /* Seek to the patch position */

        _lseek(outFileHandle, offset, SEEK_SET);

        /* Write the patch value out */

        if  (_write(outFileHandle, data, size) != (int)size)
            outFileComp->cmpGenFatal(ERRwriteErr, outFileName);

        /* Seek back to where we were to begin with */

        _lseek(outFileHandle, outFileBuffOffs, SEEK_SET);

        return;
    }

    /* Is the entire patch section within the output buffer? */

    if  (outFileBuffOffs <= offset)
    {
        /* Patch the data in memory */

        memcpy(outFileBuffAddr + offset - outFileBuffOffs, data, size);

        return;
    }

    /* The patch section spans the output buffer - do it one byte at a time */

    char    *   temp = (char *)data;

    do
    {
        outFilePatchByte(offset, *temp);
    }
    while   (++offset, ++temp, --size);
}

/*****************************************************************************/
#endif//OLD_IL
/*****************************************************************************
 *
 *  Append the specified number of 0 bytes to the file.
 */

void                outFile::outFileWritePad (size_t size)
{
    assert((int)size > 0);

    static
    BYTE            zeros[32];

    /* This is a bit lame .... */

    while (size >= sizeof(zeros))
    {
        outFileWriteData(zeros, sizeof(zeros)); size -= sizeof(zeros);
    }

    if  (size)
        outFileWriteData(zeros, size);
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\pewrite.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _PEWRITE_H_
#define _PEWRITE_H_
/*****************************************************************************/

#ifndef _OUTFILE_H_
#include "outfile.h"
#endif

#ifndef _CORWRAP_H
#include "CORwrap.h"
#endif

/*****************************************************************************/

const   unsigned    PEfileAlignment  = 512;
const   unsigned    PEvirtAlignment  = 8192;

/*****************************************************************************/

const   unsigned    PEmaxSections    = 8;

/*****************************************************************************/

const   unsigned    MAX_PE_TEXT_SIZE = 1024*1024*16;
const   unsigned    MAX_PE_DATA_SIZE = 1024*256;
const   unsigned    MAX_PE_RDTA_SIZE = 1024*512;
const   unsigned    MAX_PE_RLOC_SIZE = 1024*4;

/*****************************************************************************/

const   unsigned    CODE_BASE_RVA    = PEvirtAlignment;

/*****************************************************************************/

enum    WPEstdSects
{
    PE_SECT_text,
    PE_SECT_data,
    PE_SECT_rdata,
    PE_SECT_rsrc,
    PE_SECT_reloc,

    PE_SECT_count,
};

const   WPEstdSects PE_SECT_string = PE_SECT_count;

/*****************************************************************************/

struct  PErelocDsc;
typedef PErelocDsc *PEreloc;

struct  PErelocDsc
{
    PEreloc         perNext;

    unsigned        perSect     :4;     // enough to store 'PEmaxSections'
    unsigned        perOffs     :28;
};

/*****************************************************************************/

struct  PEsecData;
typedef PEsecData * PEsection;

struct  PEsecData
{
    BYTE    *       PEsdBase;
    BYTE    *       PEsdNext;
    BYTE    *       PEsdLast;
    BYTE    *       PEsdEndp;

    WPEstdSects     PEsdIndex;

    PEreloc         PEsdRelocs;

#ifdef  DEBUG
    bool            PEsdFinished;
#endif

    unsigned        PEsdAddrFile;
    unsigned        PEsdAddrRVA;
    unsigned        PEsdSizeData;
    unsigned        PEsdFlags;
};

/*****************************************************************************
 *
 *  The following is used to build the import tables. We hash all DLL names
 *  along with the imports into a hash table, and keep track of the number
 *  of imports for each DLL and all that.
 */

class   WPEnameRec;
typedef WPEnameRec *WPEname;
struct  WPEndefRec;
typedef WPEndefRec *WPEndef;
class   WPEhashTab;
typedef WPEhashTab *WPEhash;
struct  WPEiDLLdsc;
typedef WPEiDLLdsc *WPEimpDLL;

class   WPEnameRec
{
public:

    WPEname         PEnmNext;       // next name in this hash bucket
    WPEndef         PEnmDefs;       // list of imports for this name

    unsigned        PEnmHash;       // hash value

    unsigned        PEnmOffs;       // offset within hint/name table

    const   char *  PEnmSpelling() { assert(this); return PEnmName; }

    unsigned short  PEnmFlags;      // see PENMF_xxxx below

    unsigned short  PEnmNlen;       // length of the identifier's name
    char            PEnmName[];     // the spelling follows
};

enum    WPEnameFlags
{
    PENMF_IMP_NAME   = 0x01,        // the identifier is an import name
};

class   WPEhashTab
{
public:

    void            WPEhashInit(Compiler         comp,
                                norls_allocator *alloc,
                                unsigned         count = 512);

    WPEname         WPEhashName(const char * name, bool *isNewPtr);
    WPEndef         WPEhashName(const char * name,
                                WPEimpDLL   owner, bool *isNewPtr);

    norls_allocator*WPEhashAlloc;

    WPEname    *    WPEhashTable;
    unsigned        WPEhashSize;
    unsigned        WPEhashMask;
    Compiler        WPEhashComp;

    size_t          WPEhashStrLen;  // total length of all non-DLL strings
};

struct  WPEiDLLdsc                  // describes each imported DLL
{
    WPEimpDLL       PEidNext;       // mext DLL name
    WPEname         PEidName;       // name record for this DLL

    unsigned        PEidIndex;      // each DLL has an index assigned to it
    unsigned        PEidIATbase;    // offset of first IAT entry
    unsigned        PEidILTbase;    // offset of first import lookup entry

    WPEndef         PEidImpList;    // list of imports - head
    WPEndef         PEidImpLast;    // list of imports - tail
    unsigned        PEidImpCnt;     // number of imports in this DLL
};

struct  WPEndefRec                  // describes each unique (DLL,import) pair
{
    WPEndef         PEndNext;       // next import with this name (other DLL's)
    WPEname         PEndName;       // the name entry itself
    WPEndef         PEndNextInDLL;  // next import of the same DLL
    WPEimpDLL       PEndDLL;        // the DLL this import comes from
    unsigned        PEndIndex;      // the index within the DLL
};

/*****************************************************************************/

DEFMGMT
class   writePE
{
private:

    Compiler        WPEcomp;
    norls_allocator*WPEalloc;
    OutFile         WPEoutFile;

    const   char *  WPEoutFnam;

public:

    /*************************************************************************/
    /* Prepare to output a PE file, flush and write the file to disk         */
    /*************************************************************************/

    bool            WPEinit(Compiler comp, norls_allocator*alloc);
    bool            WPEdone(mdToken entryTok, bool errors);

    /*************************************************************************/
    /* Set the name of the output file, this better be done (and on time)!   */
    /*************************************************************************/

    void            WPEsetOutputFileName(const char *outfile);

    /*************************************************************************/
    /* Add a resource file to the output image                               */
    /*************************************************************************/

public:
    bool            WPEaddRCfile(const char *filename);

private:
    size_t          WPErsrcSize;

    HANDLE          WPErsrcFile;
    HANDLE          WPErsrcFmap;
    const   BYTE  * WPErsrcBase;

    void            WPEinitRCimp();
    void            WPEdoneRCimp();

    void            WPEgenRCcont(OutFile  outf, PEsection sect);

    /*************************************************************************/
    /* The following members create and manage PE file sections              */
    /*************************************************************************/

private:

    PEsecData       WPEsections[PEmaxSections];
    unsigned        WPEsectCnt;

    PEsecData     * WPEgetSection(WPEstdSects sect)
    {
        assert(sect < PE_SECT_count);
        assert(WPEsecTable[sect]);
        return WPEsecTable[sect];
    }

    PEsection       WPEsecList;
    PEsection       WPEsecLast;

//  unsigned        WPEcodeRVA;             // RVA of the .text  section
    unsigned        WPErdatRVA;             // RVA of the .rdata section
    unsigned        WPEdataRVA;             // RVA of the .data  section
    unsigned        WPErsrcRVA;             // RVA of the .rsrc  section

    unsigned        WPEvirtBase;

    PEsection       WPEsecTable[PE_SECT_count];

    static
    const   char    WPEsecNames[PE_SECT_count][IMAGE_SIZEOF_SHORT_NAME];

public:

    const   char *  WPEsecName    (WPEstdSects sect);

    void            WPEaddSection (WPEstdSects sect, unsigned attrs,
                                                     size_t   maxSz);

    unsigned        WPEsecAddrRVA (WPEstdSects sect);
    unsigned        WPEsecAddrVirt(WPEstdSects sect);
    unsigned        WPEsecAddrOffs(WPEstdSects sect, memBuffPtr addr);
    size_t          WPEsecSizeData(WPEstdSects sect);
    size_t          WPEsecNextOffs(WPEstdSects sect);

    unsigned        WPEsecRsvData (WPEstdSects sect, size_t         size,
                                                     size_t         align,
                                                 OUT memBuffPtr REF outRef);
    unsigned        WPEsecAddData (WPEstdSects sect, genericBuff    data,
                                                     size_t         size);
    memBuffPtr      WPEsecAdrData (WPEstdSects sect, unsigned       offs);

    void            WPEsecAddFixup(WPEstdSects ssrc,
                                   WPEstdSects sdst, unsigned       offs);

    unsigned        WPEgetCodeBase()
    {
        return  CODE_BASE_RVA;
    }

    unsigned        WPEallocCode  (size_t size, size_t align, OUT memBuffPtr REF dataRef);
    void            WPEallocString(size_t size, size_t align, OUT memBuffPtr REF dataRef);
private:
    unsigned        WPEstrPoolBase;

    /*************************************************************************/
    /* The following members manage CLR / metadata generation               */
    /*************************************************************************/

private:

    unsigned        WPEcomPlusOffs;
    size_t          WPEcomPlusSize;

    unsigned        WPEmetaDataOffs;
    size_t          WPEmetaDataSize;

    size_t          WPEgetCOMplusSize(unsigned offs);
    void            WPEgenCOMplusData(OutFile outf, PEsection sect, mdToken entryTok);

    WMetaDataDispenser *WPEwmdd;
    WMetaDataEmit      *WPEwmde;

public:

    void            WPEinitMDemit(WMetaDataDispenser *mdd,
                                  WMetaDataEmit      *mde)
    {
        WPEwmdd = mdd;
        WPEwmde = mde;
    }

    void            WPEdoneMDemit()
    {
        WPEwmde = NULL;
        WPEwmdd = NULL;
    }

    /*************************************************************************/
    /* The following members manage Debug Directory generation               */
    /*************************************************************************/

private:

    unsigned        WPEdebugDirOffs;
    size_t          WPEdebugDirSize;

    size_t          WPEgetDebugDirSize(unsigned offs);
    void            WPEgenDebugDirData(OutFile outf,
                                       PEsection sect,
                                       DWORD timestamp);

    IMAGE_DEBUG_DIRECTORY  WPEdebugDirIDD;
    DWORD                  WPEdebugDirDataSize;
    BYTE                  *WPEdebugDirData;

public:

    int             WPEinitDebugDirEmit(WSymWriter *cmpSymWriter)
    {
        int err = 0;

        /* Get the size of the debug data blob */

        if (err = cmpSymWriter->GetDebugInfo(NULL,
                                             0,
                                             &WPEdebugDirDataSize,
                                             NULL))
            return err;

        if (WPEdebugDirDataSize)
        {
            WPEdebugDirData = (BYTE*)WPEalloc->nraAlloc(roundUp(WPEdebugDirDataSize));

            err = cmpSymWriter->GetDebugInfo(&WPEdebugDirIDD,
                                             roundUp(WPEdebugDirDataSize),
                                             NULL,
                                             WPEdebugDirData);
        }
        else
            WPEdebugDirData = NULL;

        return err;
    }

    /*************************************************************************/
    /* The following members manage the import tables                        */
    /*************************************************************************/

    WPEhash         WPEimpHash;

    void    *       WPEcorMain;             // IAT entry for _CorMain

    unsigned        WPEimpDLLcnt;
    WPEimpDLL       WPEimpDLLlist;
    WPEimpDLL       WPEimpDLLlast;

    unsigned        WPEimpSizeAll;          // size of all import tables

    unsigned        WPEimpOffsIAT;          // offset of the IAT
    unsigned        WPEimpSizeIAT;          // size   of the IAT

    unsigned        WPEimpOffsIDT;          // offset of the import directory
    unsigned        WPEimpSizeIDT;          // size   of the import directory

    unsigned        WPEimpOffsLook;         // offset of the lookup    table
    unsigned        WPEimpOffsName;         // offset of the name/hint table
    unsigned        WPEimpOffsDLLn;         // offset of the DLL name  table

    unsigned        WPEimpDLLstrLen;        // length of all DLL  strings

    void            WPEimportInit();
    size_t          WPEimportDone(unsigned offs);
    void            WPEimportGen (OutFile  outf, PEsection sect);

    void          * WPEimportAdd (const char *DLLname, const char *impName);
};

/*****************************************************************************/

inline
unsigned            writePE::WPEsecAddrRVA (WPEstdSects sect)
{
    PEsecData     * sec = WPEgetSection(sect);

    assert(sec->PEsdFinished);
    return sec->PEsdAddrFile;
}

inline
unsigned            writePE::WPEsecAddrVirt(WPEstdSects sect)
{
    PEsecData     * sec = WPEgetSection(sect);

    assert(sec->PEsdFinished);
    return sec->PEsdAddrRVA;
}

inline
size_t              writePE::WPEsecSizeData(WPEstdSects sect)
{
    PEsecData     * sec = WPEgetSection(sect);

    assert(sec->PEsdFinished);
    return sec->PEsdSizeData;
}

inline
size_t              writePE::WPEsecNextOffs(WPEstdSects sect)
{
    PEsecData     * sec = WPEgetSection(sect);

    return sec->PEsdNext - sec->PEsdBase;
}

/*****************************************************************************/
#endif//_PEWRITE_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\scan.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _SCAN_H_
#define _SCAN_H_
/*****************************************************************************/
#ifndef _ALLOC_H_
#include "alloc.h"
#endif
/*****************************************************************************/
#ifndef _TOKENS_H_
#include "tokens.h"
#endif
/*****************************************************************************/
#ifndef _INFILE_H_
#include "infile.h"
#endif
/*****************************************************************************/
#ifndef _HASH_H_
#include "hash.h"
#endif
/*****************************************************************************/

const   size_t      scanSaveBuffSize = 4*OS_page_size;

/*****************************************************************************
 *
 *  The following describes a pre-processor "macro" entry. We only allow two
 *  types of macros - they must either expand to a simple identifier (or the
 *  empty string as a special case) or an integer constant.
 */

DEFMGMT class MacDefRec
{
public:

    MacDef          mdNext;
    Ident           mdName;

    bool            mdIsId;             // identifier vs. constant?
    bool            mdBuiltin;          // non-recursive definition?

    union
    {
        Ident           mdIden;
        int             mdCons;
    }
                    mdDef;
};

/*****************************************************************************
 *
 *  The following is used to keep track of conditional compilation state.
 */

enum    preprocState
{
    PPS_NONE,

    PPS_IF,                             // we're in a true 'if' part
    PPS_ELSE,                           // we're in any  'else' part
};

enum    prepDirs
{
    PP_NONE,

    PP_IF,
    PP_IFDEF,
    PP_IFNDEF,
    PP_ELSE,
    PP_ENDIF,
    PP_ERROR,
    PP_PRAGMA,
    PP_DEFINE,
};

DEFMGMT class PrepListRec
{
public:

    PrepList            pplNext;
    preprocState        pplState;
    unsigned            pplLine;
};

/*****************************************************************************/

DEFMGMT
union Token
{
    tokens      tok;                    // for easy access

    // Each version of the token must start with 'tok'

    struct
    {
        tokens          tok;

        Ident           tokIdent;
    }
                id;

    struct
    {
        tokens          tok;

        QualName        tokQualName;
        SymDef          tokQualSym;
        SymDef          tokQualScp;
    }
                qualid;

    struct
    {
        tokens          tok;

        SymDef          tokHackSym;
    }
                hackid;

    struct
    {
        tokens          tok;

        var_types       tokIntTyp;
        __int32         tokIntVal;
    }
                intCon;

    struct
    {
        tokens          tok;

        var_types       tokLngTyp;
        __int64         tokLngVal;
    }
                lngCon;

    struct
    {
        tokens          tok;

        float           tokFltVal;
    }
                fltCon;

    struct
    {
        tokens          tok;

        double          tokDblVal;
    }
                dblCon;

    struct
    {
        tokens          tok;

        size_t          tokStrLen   :28;
        size_t          tokStrType  :3; // 0=default,1="A",2="L",3="S"
        size_t          tokStrWide  :1;
        stringBuff      tokStrVal;
    }
                strCon;

    struct
    {
        tokens          tok;

        AtComment       tokAtcList;
    }
                atComm;
};

/*****************************************************************************/

DEFMGMT
struct  scannerState;

/*****************************************************************************/

DEFMGMT
class   scanner
{

private:

    HashTab         scanHashKwd;
    HashTab         scanHashSrc;

public:

    /*************************************************************************/
    /* Overall startup and shutdown (once per session)                       */
    /*************************************************************************/

    bool            scanInit(Compiler comp, HashTab hashKwd);
    void            scanDone(){}

    void            scanReset();

    void            scanSetp(Parser parser)
    {
        scanParser = parser;
    }

    /*************************************************************************/
    /* Start/stop/restart scanning the specified input text                  */
    /*************************************************************************/

    void            scanStart  (SymDef            sourceCSym,
                                const char      * sourceFile,
                                QueuedFile        sourceBuff,
                                const char      * sourceText,
                                HashTab           hashSrc,
                                norls_allocator * alloc);

    void            scanClose  ();

    void            scanRestart(SymDef            sourceCSym,
                                const char      * sourceFile,
                                scanPosTP         begAddr,
//                              scanPosTP         endAddr,
                                unsigned          begLine,
//                              unsigned          begCol,
                                norls_allocator * alloc);

    void            scanSetCpos(const char      * sourceFile,
                                unsigned          begLine)
    {
        scanInputFile.inputSetFileName(sourceFile);

//      scanTokColumn = begCol;
        scanTokLineNo = begLine;
    }

    void            scanString (const char      * sourceText,
                                norls_allocator * alloc);

    /*************************************************************************/
    /* Look an arbitrary number of tokens ahead and then backtrack           */
    /*************************************************************************/

private:

    bool            scanTokRecord;          // we're recording tokens for replay
    BYTE    *       scanTokReplay;          // current input stream position

    tokens          scanReplayTok();

public:

    scanPosTP       scanTokMarkPos(OUT Token     REF saveTok,
                                   OUT unsigned  REF saveLno);
    scanPosTP       scanTokMarkPLA(OUT Token     REF saveTok,
                                   OUT unsigned  REF saveLno);

    void            scanTokRewind (    scanPosTP     pos,
                                       unsigned      lineNum,
                                       Token *       pushTok = NULL);

    /*************************************************************************/
    /* The main entry points for scanning the input                          */
    /*************************************************************************/

    Token           scanTok;

    tokens          scan();

    HashTab         scanGetHash() { return scanHashSrc; }

    void            scanSuspend(OUT scannerState REF state);
    void            scanResume (IN  scannerState REF state);

    void            scanSetQualID(QualName qual, SymDef sym, SymDef scp = NULL);

    /*************************************************************************/
    /* Only the hashtable class uses the following tables                    */
    /*************************************************************************/

    static
    unsigned        scanHashValIds[256];
    static
    unsigned        scanHashValAll[256];

    /*************************************************************************/
    /* The following buffer must be large enough for the longest identifier  */
    /*************************************************************************/

    char            scannerBuff[1030];

    /*************************************************************************/
    /* The private state of the scanner - compiler/allocator to use, etc.    */
    /*************************************************************************/

private:

    norls_allocator*scanAlloc;

    Compiler        scanComp;
    Parser          scanParser;

    /*************************************************************************/
    /* Input-related members - source file, read next char, etc.             */
    /*************************************************************************/

    infile          scanInputFile;

    int             readNextChar();
    void            undoNextChar();
    int             peekNextChar();

    int             scanNextChar();

    void            scanSkipComment();
    void            scanSkipLineCmt();

    tokens          scanNumericConstant(int ch);
    tokens          scanIdentifier     (int ch);

    unsigned        scanSkipWsp(unsigned ch, bool stopAtEOL = false);

    /*************************************************************************/
    /* The following is used for parsing those weird @foo comment things     */
    /*************************************************************************/

    ConstStr        scanCollectGUID();
    bool            scanNativeType(CorNativeType *type, size_t *size);
    bool            scanCollectId(bool dotOK = false);
    int             scanCollectNum();

    bool            scanDoAtComment();

    /*************************************************************************/
    /* The following is used to manage conditional compilation               */
    /*************************************************************************/

    PrepList        scanPrepList;
    PrepList        scanPrepFree;

    PrepList        scanGetPPdsc();

    void            scanPPdscPush(preprocState state);
    void            scanPPdscPop();

    prepDirs        scanCheckForPrep();

    void            scanCheckEOL();

    void            scanSkipToDir(preprocState state);

    bool            scanStopAtEOL;
    bool            scanInPPexpr;
    bool            scanNoMacExp;
    bool            scanSkipToPP;

    /*************************************************************************/
    /* The following members are used to manage macros                       */
    /*************************************************************************/

private:

    MacDef          scanMacros;

    MacDef          scanFindMac(Ident name);

    bool            scanIsMacro(const char *name);

#if!MGDDATA
    MacDefRec       scanDefDsc;
#endif

public:

    MacDef          scanDefMac(const char *name,
                               const char *def, bool builtIn = false,
                                                bool chkOnly = false);
    bool            scanUndMac(const char *name);

    bool            scanChkDefined();

    /*************************************************************************/
    /* Members for reporting the source position of tokens                   */
    /*************************************************************************/

    unsigned        scanTokLineNo;
//  unsigned        scanTokColumn;

    BYTE    *       scanTokSrcPos;

    void            scanSaveLinePos();

    void            scanSkipToEOL();
    prepDirs        scanNewLine(unsigned ch, bool noPrep = false);
    prepDirs        scanRecordNL(bool noPrep);
    void            saveSrcPos();

    SymDef          scanCompUnit;

public:

    unsigned        scanGetTokenLno()
    {
        if  (scanSaveLastLn != scanTokLineNo)
            scanSaveLinePos();

        return  scanTokLineNo;
    }

    unsigned        scanGetSourceLno()
    {
        return  scanTokLineNo;
    }

//  unsigned        scanGetTokenCol()
//  {
//      return  scanTokColumn;
//  }

    scanPosTP       scanGetFilePos()
    {
        if  (scanSaveLastLn != scanTokLineNo)
            scanSaveLinePos();

        return  scanTokReplay ? scanTokReplay : scanSaveNext;
    }

    scanPosTP       scanGetTokenPos(unsigned *lineNo = NULL)
    {
        if  (scanSaveLastLn != scanTokLineNo)
            scanSaveLinePos();

        if  (lineNo)
            *lineNo = scanTokLineNo;

        return    scanTokSrcPos;
    }

    scanDifTP       scanGetPosDiff(scanPosTP memBpos, scanPosTP memEpos)
    {
        return  memEpos - memBpos;
    }

    void            scanSetTokenPos(unsigned  lineNo)
    {
        scanTokLineNo = lineNo;
    }

    void            scanSetTokenPos(SymDef    compUnit,
                                    unsigned  lineNo)
    {
        scanCompUnit  = compUnit;
        scanTokLineNo = lineNo;
    }

    SymDef          scanGetCompUnit()
    {
        return scanCompUnit;
    }

private:
    unsigned        scanNestedGTcnt;
public:
    void            scanNestedGT(int delta)
    {
        scanNestedGTcnt += delta; assert((int)scanNestedGTcnt >= 0);
    }

    /*************************************************************************/
    /* Members for token lookahead                                           */
    /*************************************************************************/

private:

    unsigned        scanLookAheadCount;
    Token           scanLookAheadToken;
    unsigned        scanLookAheadLineNo;
//  unsigned        scanLookAheadColumn;
    BYTE    *       scanSaveSN;

public:

    tokens          scanLookAhead();

    /*************************************************************************/
    /* Members that are used to record token streams                         */
    /*************************************************************************/

private:

    BYTE    *       scanSaveBase;
    BYTE    *       scanSaveNext;
    BYTE    *       scanSaveEndp;

    unsigned        scanSaveLastLn;

    void            scanSaveMoreSp(size_t need = 0);

    /*************************************************************************/
    /* Members to deal with string and character literals                    */
    /*************************************************************************/

private:

    unsigned        scanEscapeSeq(bool *newLnFlag);

    tokens          scanCharConstant();
    tokens          scanStrgConstant(int prefixChar = 0);

    char    *       scanStrLitBuff;
    size_t          scanStrLitBsiz;

    /*************************************************************************/
    /* Members to construct error strings                                    */
    /*************************************************************************/

private:

    char       *    scanErrStrNext;

public:

    void            scanErrNameBeg();
    void            scanErrNameEnd(){}

    stringBuff      scanErrNameStrBeg();
    void            scanErrNameStrAdd(stringBuff str);
    void            scanErrNameStrApp(stringBuff str);
#if MGDDATA
    void            scanErrNameStrAdd(String     str);
    void            scanErrNameStrApp(String     str);
#endif
    void            scanErrNameStrEnd();

    /*************************************************************************/
    /* The following is used to 'swallow' definitions of symbols             */
    /*************************************************************************/

#ifdef  SETS
    unsigned        scanBrackLvl;
#endif

private:

    void            scanSkipInit();

public:

    void            scanSkipText(tokens LT, tokens RT, tokens ET = tkNone);

    /*************************************************************************/
    /* Use these methods to skip over sections of the source stream          */
    /*************************************************************************/

    void            scanSkipSect(unsigned tokDist, unsigned linDif = 0)
    {
        scanTokReplay = scanTokSrcPos + tokDist;
        scanTokLineNo = scanSaveLastLn = scanTokLineNo + linDif;

        scanReplayTok();
    }

    /*************************************************************************/
    /* Members that implement miscellaneous query functionality              */
    /*************************************************************************/

public:

    Ident           tokenToIdent(tokens tok)
    {
        return  scanHashKwd->tokenToIdent(tok);
    }

    bool            tokenIsKwd(tokens tok)
    {
        return  (bool)(tok <= tkKwdLast);
    }

    /*************************************************************************/
    /* Debugging functions                                                   */
    /*************************************************************************/

#ifdef  DEBUG
    bool            scanDispCurToken(bool lastId, bool brief = false);
#endif

};

/*****************************************************************************/

inline
int                 scanner::readNextChar()
{
    return  scanInputFile.inputStreamRdU1();
}

inline
void                scanner::undoNextChar()
{
            scanInputFile.inputStreamUnU1();
}

inline
int                 scanner::peekNextChar()
{
    int     ch = scanInputFile.inputStreamRdU1();
                 scanInputFile.inputStreamUnU1();
    return  ch;
}

/*****************************************************************************/

DEFMGMT
struct scannerState
{
    SymDef          scsvCompUnit;

    Token           scsvTok;

    unsigned        scsvTokLineNo;
//  unsigned        scsvTokColumn;

    unsigned        scsvNestedGTcnt;

    scanPosTP       scsvTokSrcPos;
    scanPosTP       scsvTokReplay;

    bool            scsvTokRecord;
};

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\symbol.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

/*****************************************************************************/

#include "comp.h"
#include "alloc.h"
#include "hash.h"
#include "symbol.h"
#include "error.h"

/*****************************************************************************/
#ifdef  DEBUG
#define SYMALLOC_DISP   0
#else
#define SYMALLOC_DISP   0
#endif
/*****************************************************************************/
#ifndef __SMC__
SymDef              symTab::stErrSymbol;
#endif
/*****************************************************************************
 *
 *  Initialize a symbol table.
 */

void                symTab::stInit(Compiler             comp,
                                   norls_allocator    * alloc,
                                   HashTab              hash,
                                   unsigned             ownerx)
{
    assert(comp);
    assert(alloc);

#ifdef  SETS
    stImplicitScp = NULL;
#endif

    /* Create a hash table if the caller didn't supply one */

    if  (!hash)
    {
#if MGDDATA
        hash = new HashTab;
#else
        hash =    (HashTab)alloc->nraAlloc(sizeof(*hash));
#endif
        if  (!hash)
            comp->cmpFatal(ERRnoMemory);
        if  (hash->hashInit(comp, HASH_TABLE_SIZE, ownerx, alloc))
            comp->cmpFatal(ERRnoMemory);
    }

    stAllocPerm = alloc;
#ifdef  DEBUG
    stAllocTemp = NULL;
#endif

    if  (!stErrSymbol)
        stErrSymbol = stDeclareSym(NULL, SYM_ERR, NS_HIDE, NULL);

    stComp      = comp;
    stHash      = hash;
    stOwner     = ownerx;

    stDollarClsMode = false;

    /* Create the intrinsic types and so on */

    stInitTypes();
}

/*****************************************************************************
 *
 *  Collect and display stats about symbol table allocations.
 */

#if SYMALLOC_DISP

unsigned            totSymSize;
unsigned            totDefSize;

void                dispSymTabAllocStats()
{
    printf("A total of %7u bytes allocated for symbol  entries\n", totSymSize);
    printf("A total of %7u bytes allocated for def/dcl entries\n", totDefSize);
}

#endif

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Display the specified qualified name.
 */

void                symTab::stDumpQualName(QualName name)
{
    unsigned        i = 0;
    unsigned        c = name->qnCount;

    assert(c);

    for (;;)
    {
        printf("%s", hashTab::identSpelling(name->qnTable[i]));

        if  (++i == c)
            break;

        printf(".");
    }

    if  (name->qnEndAll)
        printf(".*");
}

/*****************************************************************************
 *
 *  Display the specified "using" list.
 */

void                symTab::stDumpUsings(UseList uses, unsigned indent)
{
    if  (!uses)
        return;

    printf("\n");

    do
    {
        if  (!uses->ulAnchor)
        {
            printf("%*c Using '", 3+4*indent, ' ');

            if  (uses->ulBound)
            {
                printf("%s", uses->ul.ulSym->sdSpelling());
            }
            else
                stDumpQualName(uses->ul.ulName);

            printf("'\n");
        }

        uses = uses->ulNext;
    }
    while (uses);
}

/*****************************************************************************
 *
 *  Display the specified definition point.
 */

void                symTab::stDumpSymDef(DefSrc def, SymDef comp)
{
    printf("[def@%06X]", def->dsdBegPos);

    assert(comp);
    assert(comp->sdSymKind == SYM_COMPUNIT);

    printf(" %s(%u)", hashTab::identSpelling(comp->sdName), def->dsdSrcLno);
}

/*****************************************************************************/

void                symTab::stDumpSymbol(SymDef sym, int     indent,
                                                     bool    recurse,
                                                     bool    members)
{
    SymDef          child;
    bool            scopd;

    if  (sym->sdIsImport && sym->sdSymKind != SYM_NAMESPACE && stComp->cmpConfig.ccVerbose < 2)
        return;

    switch  (sym->sdSymKind)
    {
    case SYM_NAMESPACE:
    case SYM_COMPUNIT:
    case SYM_CLASS:
        printf("\n");
        scopd = true;
        break;
    default:
        scopd = false;
        break;
    }

    printf("%*c [%08X] ", 1+4*indent, ' ', sym);

    switch  (sym->sdSymKind)
    {
        const   char *  nm;

    case SYM_ERR:
        NO_WAY(!"get out of here");

    case SYM_VAR:
        if  (sym->sdParent->sdSymKind == SYM_CLASS)
            printf("Field    ");
        else
            printf("Variable  ");
        if  (sym->sdType)
            printf("'%s'", stTypeName(sym->sdType, sym));
        else
            printf("'%s'", hashTab::identSpelling(sym->sdName));
        break;

    case SYM_PROP:
        printf("Property  '%s' [", stTypeName(sym->sdType, sym));
        if  (sym->sdProp.sdpGetMeth) printf("get");
        if  (sym->sdProp.sdpSetMeth) printf("set");
        printf("]");
        break;

    case SYM_ENUM:
        printf("Enum      '%s'", hashTab::identSpelling(sym->sdName));
        break;

    case SYM_ENUMVAL:
        printf("Enumval   '%s'", hashTab::identSpelling(sym->sdName));
        printf(" = %d", sym->sdEnumVal.sdEV.sdevIval);
        break;

    case SYM_CLASS:
        switch (sym->sdClass.sdcFlavor)
        {
        case STF_NONE    : nm = "Record"   ; break;
        case STF_CLASS   : nm = "Class"    ; break;
        case STF_UNION   : nm = "Union"    ; break;
        case STF_STRUCT  : nm = "Struct"   ; break;
        case STF_INTF    : nm = "Interface"; break;
        case STF_DELEGATE: nm = "Delegate" ; break;
                  default: nm = "<oops>"   ; break;
        }
        printf("%-9s '%s'", nm,  hashTab::identSpelling(sym->sdName));

        if  (sym->sdType->tdClass.tdcBase)
        {
            printf(" inherits %s", sym->sdType->tdClass.tdcBase->tdClass.tdcSymbol->sdSpelling());
        }
        if  (sym->sdType->tdClass.tdcIntf)
        {
            TypList         intf;

            printf(" includes ");

            for (intf = sym->sdType->tdClass.tdcIntf;
                 intf;
                 intf = intf->tlNext)
            {
                printf("%s", intf->tlType->tdClass.tdcSymbol->sdSpelling());
                if  (intf->tlNext)
                    printf(", ");
            }
        }
        break;

    case SYM_LABEL:
        printf("Label     '%s'", hashTab::identSpelling(sym->sdName));
        break;

    case SYM_NAMESPACE:
        printf("Namespace '%s'", hashTab::identSpelling(sym->sdName));
        break;

    case SYM_TYPEDEF:
        printf("Typedef   ");
        if  (sym->sdType)
            printf("%s", stTypeName(NULL, sym));
        else
            printf("'%s'", hashTab::identSpelling(sym->sdName));
        break;

    case SYM_FNC:
        if  (sym->sdParent->sdSymKind == SYM_CLASS)
            printf("Method   ");
        else
            printf("Function ");
        if  (sym->sdType)
            printf("%s", stTypeName(sym->sdType, sym));
        else
            printf("'%s'", hashTab::identSpelling(sym->sdName));
        break;

    case SYM_SCOPE:
        printf("Scope");
        break;

    case SYM_COMPUNIT:
        printf("Comp-unit '%s'", sym->sdName ? hashTab::identSpelling(sym->sdName)
                                             : "<NONAME>");
        break;

    default:
        assert(!"unexpected symbol kind");
    }
    printf("\n");

    /* Does this symbol have any known definitions? */

    if  (sym->sdSrcDefList)
    {
        DefList         defs;

        for (defs = sym->sdSrcDefList; defs; defs = defs->dlNext)
        {
            printf("%*c Defined in ", 3+4*indent, ' ');

            stDumpSymDef(&defs->dlDef, defs->dlComp);
            printf("\n");

            if  (defs->dlUses)
            {
                switch (sym->sdSymKind)
                {
                case SYM_FNC:
                case SYM_ENUM:
                case SYM_CLASS:
                case SYM_NAMESPACE:
                    stDumpUsings(defs->dlUses, indent);
                    printf("\n");
                    break;
                }
            }
        }
    }

    if  (!recurse)
        return;

    if  (!members && sym->sdSymKind == SYM_CLASS)
        return;

    if  (sym->sdSymKind == SYM_NAMESPACE && sym->sdNS.sdnDeclList)
    {
        ExtList         decl;

        printf("\n");

        for (decl = sym->sdNS.sdnDeclList; decl; decl = (ExtList)decl->dlNext)
        {
            printf("%*c File decl.   '", 3+4*indent, ' ');

            if  (decl->dlQualified)
                stDumpQualName(decl->mlQual);
            else
                printf("%s", hashTab::identSpelling(decl->mlName));

            printf("'\n");

            printf("%*c Defined in ", 5+4*indent, ' ');
            stDumpSymDef(&decl->dlDef, decl->dlComp);
            printf("'\n");
        }
    }

    if (sym->sdHasScope() && sym->sdScope.sdScope.sdsChildList)
    {
        if  (sym->sdSymKind == SYM_CLASS)
            printf("\n");

        for (child = sym->sdScope.sdScope.sdsChildList;
             child;
             child = child->sdNextInScope)
        {
            if  (sym->sdSymKind != SYM_CLASS && child != sym->sdScope.sdScope.sdsChildList
                                             && child->sdHasScope() == false)
                printf("\n");

            stDumpSymbol(child, indent + 1, recurse, members);
        }
    }

    if  (sym->sdSymKind == SYM_CLASS && sym->sdIsImport == false
                                     && sym->sdClass.sdcMemDefList)
    {
        ExtList         mems;

        /* Display the members, if any are present */

        printf("\n");

        for (mems = sym->sdClass.sdcMemDefList;
             mems;
             mems = (ExtList)mems->dlNext)
        {
            printf("%*c Member '", 3+4*indent, ' ');

            if  (mems->dlQualified)
                stDumpQualName(mems->mlQual);
            else
                printf("%s", hashTab::identSpelling(mems->mlName));

            printf("'\n");

            printf("%*c Defined in ", 5+4*indent, ' ');
            stDumpSymDef(&mems->dlDef, mems->dlComp);
            printf("\n");
        }
    }
}

/*****************************************************************************/
#endif
/*****************************************************************************/

#if!MGDDATA

inline
size_t              symbolSize(symbolKinds kind)
{
    static
    unsigned char       symSizes[] =
    {
        symDef_size_err,        // SYM_ERR
        symDef_size_var,        // SYM_VAR
        symDef_size_fnc,        // SYM_FNC
        symDef_size_prop,       // SYM_PROP
        symDef_size_label,      // SYM_LABEL
        symDef_size_using,      // SYM_USING
        symDef_size_genarg,     // SYM_GENARG
        symDef_size_enumval,    // SYM_ENUMVAL
        symDef_size_typedef,    // SYM_TYPEDEF
        symDef_size_comp,       // SYM_COMPUNIT
        symDef_size_enum,       // SYM_ENUM
        symDef_size_scope,      // SYM_SCOPE
        symDef_size_class,      // SYM_CLASS
        symDef_size_NS,         // SYM_NAMESPACE
    };

    assert(kind < sizeof(symSizes)/sizeof(symSizes[0]));

    assert(symSizes[SYM_ERR      ] == symDef_size_err    );
    assert(symSizes[SYM_VAR      ] == symDef_size_var    );
    assert(symSizes[SYM_FNC      ] == symDef_size_fnc    );
    assert(symSizes[SYM_PROP     ] == symDef_size_prop   );
    assert(symSizes[SYM_LABEL    ] == symDef_size_label  );
    assert(symSizes[SYM_USING    ] == symDef_size_using  );
    assert(symSizes[SYM_GENARG   ] == symDef_size_genarg );
    assert(symSizes[SYM_ENUMVAL  ] == symDef_size_enumval);
    assert(symSizes[SYM_TYPEDEF  ] == symDef_size_typedef);
    assert(symSizes[SYM_COMPUNIT ] == symDef_size_comp   );
    assert(symSizes[SYM_ENUM     ] == symDef_size_enum   );
    assert(symSizes[SYM_SCOPE    ] == symDef_size_scope  );
    assert(symSizes[SYM_CLASS    ] == symDef_size_class  );
    assert(symSizes[SYM_NAMESPACE] == symDef_size_NS     );

    assert(kind < sizeof(symSizes)/sizeof(symSizes[0]));

    return  symSizes[kind];
}

#endif

/*****************************************************************************
 *
 *  The cmpDeclareSym() function creates a symbol descriptor, inserts it
 *  in the appropriate scope, and makes it visible via the hash table.
 *
 *  IMPORTANT:  This method should only be used to declare symbols outside
 *              of local (block) scopes. Local symbols should be declared
 *              via stDeclareLcl().
 */

SymDef              symTab::stDeclareSym(Ident       name,
                                         symbolKinds kind,
                                         name_space  nspc,
                                         SymDef      parent)
{
    SymDef          sym;
#if!MGDDATA
    size_t          siz;
#endif

    /* set the 'type' bit for classes and enums */

    switch (kind)
    {
    case SYM_ENUM:
    case SYM_CLASS:
        if  (nspc != NS_HIDE)
            nspc = NS_TYPE;
        break;

    case SYM_TYPEDEF:
    case SYM_NAMESPACE:
        nspc = (name_space)(nspc | NS_TYPE);
        break;
    }

    if  (SymDefRec::sdHasScope(kind))
        nspc = (name_space)(nspc | NS_CONT);

    /* Allocate the symbol and fill in some basic information */

#if MGDDATA

    sym = new SymDef;

#else

    siz = symbolSize(kind);
    sym = (SymDef)stAllocPerm->nraAlloc(siz);

#if SYMALLOC_DISP
    totSymSize += siz;
#endif

    memset(sym, 0, siz);        // ISSUE: is this a good idea?

#endif

    sym->sdName         = name;
    sym->sdSymKind      = kind;
    sym->sdNameSpace    = nspc;
    sym->sdParent       = parent;
    sym->sdCompileState = CS_KNOWN;

    /* Insert the symbol into the hash table, unless name == 0 */

    if  (name && !(nspc & NS_HIDE))
    {
        /* Hook the symbol into the symbol definition list */

        sym->sdNextDef = hashTab::getIdentSymDef(name);
                         hashTab::setIdentSymDef(name, sym);
    }

    /* Add the symbol to the parent's list of children (if there is a parent) */

    if  (parent)
    {
        if  (parent->sdScope.sdScope.sdsChildLast)
            parent->sdScope.sdScope.sdsChildLast->sdNextInScope  = sym;
        else
            parent->sdScope.sdScope.sdsChildList                 = sym;

        parent->sdScope.sdScope.sdsChildLast = sym;
    }

//  if  (name && !strcmp(name->idSpelling(), "<whatever>")) forceDebugBreak();
//  if  ((int)sym == 0xADDRESS                            ) forceDebugBreak();

    return sym;
}

/*****************************************************************************
 *
 *  Declare a nested class type.
 */

SymDef              symTab::stDeclareNcs(Ident        name,
                                         SymDef       scope,
                                         str_flavors  flavor)
{
    SymDef          sym;
    TypDef          typ;

    assert(scope && scope->sdSymKind == SYM_CLASS);

    sym                    = stDeclareSym(name, SYM_CLASS, NS_NORM, scope);
    typ = sym->sdType      = stNewClsType(sym);

    sym->sdClass.sdcFlavor = flavor;
    typ->tdClass.tdcFlavor = flavor;

    return  sym;
}

/*****************************************************************************
 *
 *  Declare a new overloaded function and add it to the overload list of the
 *  given function symbol.
 */

SymDef              symTab::stDeclareOvl(SymDef fnc)
{
    SymDef          sym;
#if!MGDDATA
    size_t          siz;
#endif

    assert(fnc);

    if  (fnc->sdSymKind == SYM_FNC)
    {
        /* Allocate the symbol and fill in some basic information */

#if MGDDATA

        sym = new SymDef;

#else

        siz = symbolSize(SYM_FNC);
        sym = (SymDef)stAllocPerm->nraAlloc(siz);

#if SYMALLOC_DISP
        totSymSize += siz;
#endif

        memset(sym, 0, siz);        // ISSUE: is this a good idea?

#endif

        sym->sdSymKind         = SYM_FNC;

        /* Add the symbol to the overload list */

        sym->sdFnc.sdfNextOvl  = fnc->sdFnc.sdfNextOvl;
        fnc->sdFnc.sdfNextOvl  = sym;

        /* Copy a few attributes from the old symbol */

        sym->sdIsManaged       = fnc->sdIsManaged;
        sym->sdFnc.sdfOper     = fnc->sdFnc.sdfOper;
        sym->sdFnc.sdfConvOper = fnc->sdFnc.sdfConvOper;
    }
    else
    {
        assert(fnc->sdSymKind == SYM_PROP);

        /* Allocate the symbol and fill in some basic information */

#if MGDDATA

        sym = new SymDef;

#else

        siz = symbolSize(SYM_PROP);
        sym = (SymDef)stAllocPerm->nraAlloc(siz);

#if SYMALLOC_DISP
        totSymSize += siz;
#endif

        memset(sym, 0, siz);        // ISSUE: is this a good idea?

#endif

        sym->sdSymKind         = SYM_PROP;

        sym->sdProp.sdpNextOvl = fnc->sdProp.sdpNextOvl;
        fnc->sdProp.sdpNextOvl = sym;
    }

    /* Copy over the fields that should be identical */

    sym->sdName            = fnc->sdName;
    sym->sdNameSpace       = fnc->sdNameSpace;
    sym->sdParent          = fnc->sdParent;
    sym->sdCompileState    = CS_KNOWN;

    return sym;
}

/*****************************************************************************
 *
 *  The cmpDeclareLcl() function creates a symbol descriptor and inserts it
 *  in the given *local* function scope.
 */

SymDef              symTab::stDeclareLcl(Ident              name,
                                         symbolKinds        kind,
                                         name_space         nspc,
                                         SymDef             parent,
                                         norls_allocator *  alloc)
{
    SymDef          sym;
#if!MGDDATA
    size_t          siz;
#endif

    /* For now force the caller to choose which allocator to use */

    assert(alloc);

    /* Make sure the scope looks reasonable */

    assert(parent == NULL || parent->sdSymKind == SYM_SCOPE);

    /* Allocate the symbol and fill in some basic information */

#if MGDDATA

    sym = new SymDef;

#else

    siz = symbolSize(kind);
    sym = (SymDef)alloc->nraAlloc(siz);

    memset(sym, 0, siz);        // ISSUE: is this a good idea?

#endif

    sym->sdName         = name;
    sym->sdSymKind      = kind;
    sym->sdNameSpace    = nspc;
    sym->sdParent       = parent;
    sym->sdCompileState = CS_KNOWN;

    /* Add the symbol to the parent's list of children (if there is a parent) */

    if  (parent)
    {
        if  (parent->sdScope.sdScope.sdsChildLast)
            parent->sdScope.sdScope.sdsChildLast->sdNextInScope  = sym;
        else
            parent->sdScope.sdScope.sdsChildList                 = sym;

        parent->sdScope.sdScope.sdsChildLast = sym;
    }

    return sym;
}

/*****************************************************************************
 *
 *  Allocate a label symbol from the specified allocator and stick it in
 *  the given scope.
 */

SymDef              symTab::stDeclareLab(Ident  name,
                                         SymDef scope, norls_allocator*alloc)
{
    SymDef          sym;
#if!MGDDATA
    size_t          siz;
#endif

    /* Make sure the scope looks reasonable */

    assert(scope && scope->sdSymKind == SYM_SCOPE);

    /* Allocate the symbol and fill in some basic information */

#if MGDDATA
    sym = new SymDef;
#else
    siz = symbolSize(SYM_LABEL);
    sym = (SymDef)alloc->nraAlloc(siz);
#endif

    sym->sdName         = name;
#ifdef  DEBUG
    sym->sdType         = NULL;
#endif
    sym->sdSymKind      = SYM_LABEL;
    sym->sdNameSpace    = NS_HIDE;
    sym->sdParent       = scope;
//  sym->sdCompileState = CS_KNOWN;

    /* Insert the symbol into the hash table */

    sym->sdNextDef = hashTab::getIdentSymDef(name);
                     hashTab::setIdentSymDef(name, sym);

    return sym;
}

/*****************************************************************************
 *
 *  Remove the given symbol from the symbol table.
 */

void                symTab::stRemoveSym(SymDef sym)
{
    Ident           symName = sym->sdName;

    SymDef          defList;

    assert(symName);

    /* Remove the symbol from the linked list of definitions */

    defList = hashTab::getIdentSymDef(symName);
    if  (defList == sym)
    {
        /* The symbol is at the very front of the list */

        hashTab::setIdentSymDef(symName, defList->sdNextDef);
    }
    else
    {
        /* Locate the symbol in the linked list and remove it */

        for (;;)
        {
            SymDef      defLast = defList; assert(defLast);

            defList = defList->sdNextDef;

            if  (defList == sym)
            {
                defLast->sdNextDef = defList->sdNextDef;
                return;
            }
        }
    }
}

/*****************************************************************************
 *
 *  Record a definition for the given symbol in the current comp-unit at the
 *  specified source offsets.
 */

DefList             symTab::stRecordSymSrcDef(SymDef  sym,
                                              SymDef  cmp,
                                              UseList uses, scanPosTP dclFpos,
                                                            unsigned  dclLine,
                                              bool    ext)
{
    DefList         defRec;
    ExtList         extRec;

    if  (ext)
    {
#if MGDDATA
        extRec = new ExtList;
#else
        extRec =    (ExtList)stAllocPerm->nraAlloc(sizeof(*extRec));
        memset(extRec, 0, sizeof(*extRec));
#endif

        extRec->dlQualified = false;
        extRec->mlName      = sym->sdName;

        defRec = extRec;
    }
    else
    {
#if MGDDATA
        defRec = new DefList;
#else
        defRec =    (DefList)stAllocPerm->nraAlloc(sizeof(*defRec));
        memset(defRec, 0, sizeof(*defRec));
#endif
    }

#if!MGDDATA
#if SYMALLOC_DISP
    totDefSize += ext ? sizeof(*extRec) : sizeof(*defRec);
#endif
#endif

    defRec->dlNext = sym->sdSrcDefList;
                     sym->sdSrcDefList = defRec;

    defRec->dlDef.dsdBegPos = dclFpos;
    defRec->dlDef.dsdSrcLno = dclLine;

    defRec->dlDeclSkip      = 0;

    defRec->dlComp          = cmp;
    defRec->dlUses          = uses;

#ifdef  DEBUG
    defRec->dlExtended      = ext;
#endif

    return  defRec;
}

/*****************************************************************************
 *
 *  Create a definition record for the given member.
 */

ExtList             symTab::stRecordMemSrcDef(Ident    name,
                                              QualName qual,
                                              SymDef   comp,
                                              UseList  uses, scanPosTP dclFpos,
                                                             unsigned  dclLine)
{
    ExtList         defRec;

#if MGDDATA
    defRec = new ExtList;
#else
    defRec =    (ExtList)stAllocPerm->nraAlloc(sizeof(*defRec));
    memset(defRec, 0, sizeof(*defRec));
#endif

    assert((name != NULL) != (qual != NULL));

    if  (name)
    {
        defRec->dlQualified = false;
        defRec->mlName      = name;
    }
    else
    {
        defRec->dlQualified = true;
        defRec->mlQual      = qual;
    }

#if SYMALLOC_DISP
    totDefSize += sizeof(*defRec);
#endif

    defRec->dlDef.dsdBegPos = dclFpos;
    defRec->dlDef.dsdSrcLno = dclLine;

    defRec->dlComp          = comp;
    defRec->dlUses          = uses;

#ifdef  DEBUG
    defRec->dlExtended      = true;
#endif

    assert(defRec->dlDeclSkip == 0);    // should be cleared above

    return  defRec;
}

/*****************************************************************************
 *
 *  Lookup a name in the given namespace scope.
 */

SymDef              symTab::stLookupNspSym(Ident       name,
                                           name_space  symNS,
                                           SymDef      scope)
{
    SymDef          sym;

    // ISSUE: May have to rehash into the appropriate hash table

    assert(name);
    assert(scope && (scope->sdSymKind == SYM_NAMESPACE ||
                     scope->sdSymKind == SYM_SCOPE));

    /* Walk the symbol definitions, looking for a matching one */

    for (sym = hashTab::getIdentSymDef(name); sym; sym = sym->sdNextDef)
    {
        assert(sym->sdName == name);

        /* Does the symbol belong to the desired scope? */

        if  (sym->sdParent == scope)
            return  sym;
    }

    return sym;
}

/*****************************************************************************
 *
 *  Lookup a member in the given class/enum.
 */

SymDef              symTab::stLookupClsSym(Ident name, SymDef scope)
{
    SymDef          sym;

    // ISSUE: May have to rehash into the appropriate hash table

    assert(name);
    assert(scope && (scope->sdSymKind == SYM_ENUM ||
                     scope->sdSymKind == SYM_CLASS));

    /* Make sure the class/enum is at least in 'declared' state */

    if  (scope->sdCompileState < CS_DECLSOON)
    {
        // ISSUE: This is a little expensive, isn't it?

        if  (stComp->cmpDeclSym(scope))
            return  NULL;
    }

    /* Walk the symbol definitions, looking for a matching one */

    for (sym = hashTab::getIdentSymDef(name); sym; sym = sym->sdNextDef)
    {
        SymDef          parent = sym->sdParent;

        assert(sym->sdName == name);

        /* Does the symbol belong to the desired scope? */

        if  (parent == scope)
            return sym;

        /* Special case: a member of a nested anonymous union */

        while (parent->sdSymKind == SYM_CLASS && parent->sdClass.sdcAnonUnion)
        {
            parent = parent->sdParent; assert(parent);

            if  (parent == scope)
                return  sym;
        }
    }

    return  sym;
}

/*****************************************************************************
 *
 *  Find a property member in the given class type.
 */

SymDef              symTab::stLookupProp(Ident name, SymDef scope)
{
    SymDef          sym;

    // ISSUE: May have to rehash into the appropriate hash table

    assert(name);
    assert(scope && scope->sdSymKind == SYM_CLASS);

    /* Make sure the class is at least in 'declared' state */

    assert(scope->sdCompileState >= CS_DECLSOON);

    /* Walk the symbol definitions, looking for a matching one */

    for (sym = hashTab::getIdentSymDef(name); sym; sym = sym->sdNextDef)
    {
        SymDef          parent = sym->sdParent;

        assert(sym->sdName == name);

        /* Does the symbol belong to the desired scope? */

        if  (parent == scope)
            return sym;
    }

    return  sym;
}

/*****************************************************************************
 *
 *  Lookup a name in the given non-namespace scope.
 */

SymDef              symTab::stLookupScpSym(Ident name, SymDef scope)
{
    SymDef          sym;

    // ISSUE: May have to rehash into the appropriate hash table

    assert(name);
    assert(scope && (scope->sdSymKind == SYM_ENUM  ||
                     scope->sdSymKind == SYM_CLASS ||
                     scope->sdSymKind == SYM_SCOPE));

#ifdef  SETS

    // implicit scopes must be handled elsewhere for now

    assert(scope->sdIsImplicit == false || scope->sdSymKind != SYM_SCOPE);

#endif

    /* Walk the symbol definitions, looking for a matching one */

    for (sym = hashTab::getIdentSymDef(name); sym; sym = sym->sdNextDef)
    {
        assert(sym->sdName == name);

        /* Does the symbol belong to the desired scope? */

        if  (sym->sdParent == scope)
            return  sym;
    }

    return sym;
}

/*****************************************************************************
 *
 *  Perform a full lookup of the given name in the specified class. This looks
 *  in the base classes and all that. An ambiguous reference is reported as an
 *  error (and 'stErrSymbol' is returned in that case).
 */

SymDef              symTab::stFindInClass(Ident name, SymDef scp, name_space nsp)
{
    SymDef          sym;
    SymDef          nts;
    TypDef          typ;

    // ISSUE: May have to rehash into the appropriate hash table

    assert(name);
    assert(scp && (scp->sdSymKind == SYM_ENUM ||
                   scp->sdSymKind == SYM_CLASS));

    assert(scp->sdCompileState >= CS_DECLSOON);

    /* Walk the symbol definitions, looking for a matching one */

    for (sym = hashTab::getIdentSymDef(name), nts = NULL;
         sym;
         sym = sym->sdNextDef)
    {
        SymDef          parent = sym->sdParent;

        assert(sym->sdName == name);

        /* Does the symbol belong to the desired scope? */

        if  (parent == scp)
        {
            /* Does the symbol belong to the desired namespace ? */

            if  (!(sym->sdNameSpace & nsp))
            {
                /* Special case: are we looking for types? */

                if  (nsp == NS_TYPE)
                {
                    /* Remember any non-type symbol we encounter */

                    if  (sym->sdNameSpace & NS_NORM)
                        nts = sym;
                }

                continue;
            }


            return sym;
        }

        /* Special case: a member of a nested anonymous union */

        while (parent && symTab::stIsAnonUnion(parent))
        {
            parent = parent->sdParent; assert(parent);

            if  (parent == scp)
                return  sym;
        }
    }

    /* Did we find a non-type symbol that matched ? */

    if  (nts)
        return  nts;

    /* Does the name match the class name itself? */

    if  (name == scp->sdName)
        return  scp;

    /* No luck, time to check the base class and interfaces */

    if  (scp->sdSymKind != SYM_CLASS)
        return  NULL;

    typ = scp->sdType;

    /* Is there a base class? */

    if  (typ->tdClass.tdcBase)
    {
        /* Look in the base class (recursively) and return if we find something */

        scp = typ->tdClass.tdcBase->tdClass.tdcSymbol;
        sym = stLookupAllCls(name, scp, nsp, CS_DECLSOON);
        if  (sym)
            return  sym;
    }

    /* Does the class include any interfaces? */

    if  (typ->tdClass.tdcIntf)
    {
        TypList         ifl = typ->tdClass.tdcIntf;

        do
        {
            SymDef          tmp;
            SymDef          tsc;

            /* Look in the interface and bail if that triggers an error */

            tsc = ifl->tlType->tdClass.tdcSymbol;
            tmp = stLookupAllCls(name, tsc, nsp, CS_DECLSOON);
            if  (tmp == stErrSymbol)
                return  tmp;

            if  (tmp)
            {
                /* We have a match, do we already have a different match? */

                if  (sym && sym != tmp && !stArgsMatch(sym->sdType, tmp->sdType))
                {
                    stComp->cmpError(ERRambigMem, name, scp, tsc);
                    return  stErrSymbol;
                }

                /* This is the first match, record it and continue */

                sym = tmp;
                scp = tsc;
            }

            ifl = ifl->tlNext;
        }
        while (ifl);
    }

    return  sym;
}

/*****************************************************************************
 *
 *  Look for a matching method/property in the given class. If the 'baseOnly'
 *  argument is non-zero we don't look in the class itself, only in its base
 *  (and any interfaces it includes).
 */

SymDef              symTab::stFindBCImem(SymDef clsSym, Ident       name,
                                                        TypDef      type,
                                                        symbolKinds kind,
                                                  INOUT SymDef  REF matchFN,
                                                        bool        baseOnly)
{
    TypDef          clsType = clsSym->sdType;
    SymDef          sym;

    assert(kind == SYM_FNC || kind == SYM_PROP);

    /* Try the class itself if we're supposed to */

    if  (!baseOnly)
    {
        sym = clsSym;
    }
    else if  (clsType->tdClass.tdcBase)
    {
        sym = clsType->tdClass.tdcBase->tdClass.tdcSymbol;
    }
    else
        goto TRY_INTF;


    // UNDONE: This call may cause ambiguity errors to be issued, which is inappropriate here, right?

    sym = stLookupAllCls(name, sym, NS_NORM, CS_DECLARED);

    if  (sym && (BYTE)sym->sdSymKind == (BYTE)kind)
    {
        SymDef          ovl;

        /* Tell the caller about a possibly hidden base method */

        matchFN = sym;

        /* Look for an exact match on signature */

        if  (kind == SYM_FNC)
            ovl = stFindOvlFnc (sym, type);
        else
            ovl = stFindOvlProp(sym, type);

        if  (ovl)
            return  ovl;
    }

TRY_INTF:

    /* Now try all the interfaces */

    if  (clsType->tdClass.tdcIntf)
    {
        TypList         ifl = clsType->tdClass.tdcIntf;

        do
        {
            SymDef          tmp;

            /* Look in the interface (recursively) */

            tmp = stFindBCImem(ifl->tlType->tdClass.tdcSymbol, name, type, kind, matchFN, false);
            if  (tmp)
                return  tmp;

            ifl = ifl->tlNext;
        }
        while (ifl);
    }

    return  NULL;
}

/*****************************************************************************
 *
 *  See if the given method has a matching definition in the given class or
 *  any of it base classes (note that we ignore interfaces).
 */

SymDef              symTab::stFindInBase(SymDef fnc, SymDef scp)
{
    SymDef          sym;
    Ident           name = fnc->sdName;

    // ISSUE: May have to rehash into the appropriate hash table

    assert(fnc);
    assert(fnc->sdSymKind == SYM_FNC);
    assert(fnc->sdParent->sdSymKind == SYM_CLASS);

    for (;;)
    {
        assert(scp && scp->sdSymKind == SYM_CLASS);

        if  (scp->sdCompileState < CS_DECLSOON)
            stComp->cmpDeclSym(scp);

        /* Look for a definition of the method in the given class */

        if  (fnc->sdFnc.sdfOper != OVOP_NONE)
        {
            UNIMPL("");
        }
        else
        {
            /* Walk the symbol definitions, looking for a matching one */

            for (sym = hashTab::getIdentSymDef(name); sym; sym = sym->sdNextDef)
            {
                SymDef          parent = sym->sdParent;

                assert(sym->sdName == name);

                /* Does the symbol belong to the desired scope? */

                if  (parent == scp)
                    return sym;
            }
        }

        /* Is there a base class? */

        if  (!scp->sdType->tdClass.tdcBase)
            break;

        /* Look in the base class */

        scp = scp->sdType->tdClass.tdcBase->tdClass.tdcSymbol;
    }

    return  sym;
}

/*****************************************************************************
 *
 *  Lookup a name in the given local (block) scope.
 */

SymDef              symTab::stLookupLclSym(Ident name, SymDef scope)
{
    SymDef          sym;

#ifdef  SETS

    // implicit scopes must be handled elsewhere for now

    assert(scope->sdIsImplicit == false || scope->sdSymKind != SYM_SCOPE);

#endif

    for (sym = scope->sdScope.sdScope.sdsChildList;
         sym;
         sym = sym->sdNextInScope)
    {
        if  (sym->sdName == name)
            break;
    }

    return  sym;
}

/*****************************************************************************
 *
 *  Look inside the given "using" section for an unambiguous definition of
 *  the given name. If an error occurs, 'stErrSymbol' is returned. If no
 *  definition is found, NULL is returned. Otherwise the one and only symbol
 *  found is returned.
 */

SymDef              symTab::stSearchUsing(INOUT UseList REF useRef, Ident      name,
                                                                    name_space nsp)
{
    UseList         uses;

    SymDef          oneSym  = NULL;

    SymDef          allSym1 = NULL;
    SymDef          allSym2 = NULL;

    assert(useRef && useRef->ulAnchor);

    /*
        Keep track of any matching symbols we find - if we get a match against
        an import of an individual name, we remember it in "oneSym". Matches
        within imports of entire namespaces are kept in "allSym1"/"allSym2".
     */

    for (uses = useRef->ulNext; uses && !uses->ulAnchor; uses = uses->ulNext)
    {
        SymDef          use;

        assert(uses->ulBound); use = uses->ul.ulSym;

        if  (!use)
            continue;

        if  (uses->ulAll)
        {
            SymDef          sym;

            /* Look for the name in the used namespace */

            sym = stLookupNspSym(name, nsp, use);

            if  (sym)
            {
                /* prefer a class symbol */

                if  (stComp->cmpConfig.ccAmbigHack)
                {
                    if  (sym->sdSymKind == SYM_CLASS)
                        return  sym;

                    allSym1 = allSym2 = NULL;
                }

                if  (sym != allSym1 &&
                     sym != allSym2)
                {
                    if      (allSym1 == NULL)
                        allSym1 = sym;
                    else if (allSym2 == NULL)
                        allSym2 = sym;
                }
            }
        }
        else
        {
            if  (use->sdName == name)
            {
                if  (oneSym && oneSym != use)
                {
                    /* The name is ambiguous */

                    stComp->cmpErrorQSS(ERRambigUse, oneSym, use);

                    return  stErrSymbol;
                }

                oneSym = use;
            }
        }
    }

    useRef = uses;

    /* Did we find one specific import? */

    if  (oneSym)
        return  oneSym;

    /* Did we find zero or one names from namespace-wide imports? */

    if  (allSym2 == NULL)
        return  allSym1;

    /* The name is ambiguous */

    stComp->cmpErrorQSS(ERRambigUse, allSym1, allSym2);

    return  stErrSymbol;
}

/*****************************************************************************
 *
 *  Lookup a name in the current context.
 */

SymDef              symTab::stLookupSym(Ident name, name_space symNS)
{
    Compiler        ourComp = stComp;

    SymDef          curCls;
    SymDef          curNS;
    UseList         uses;
    SymDef          sym;

#ifdef  SETS
    assert(stImplicitScp == NULL);
#endif

AGAIN:

    /* Check the local scope first, if we're in one */

    if  (ourComp->cmpCurScp)
    {
        SymDef          lclScp;

        for (lclScp = ourComp->cmpCurScp;
             lclScp;
             lclScp = lclScp->sdParent)
        {
            /* Check for an implicit class scope */

#ifdef  SETS

            if  (lclScp->sdIsImplicit && lclScp->sdSymKind == SYM_SCOPE)
            {
                SymDef          scpCls;

                assert(lclScp->sdType);
                assert(lclScp->sdType->tdTypeKind == TYP_CLASS);

                scpCls = lclScp->sdType->tdClass.tdcSymbol;

                sym = stLookupAllCls(name, scpCls, symNS, CS_DECLARED);
                if  (sym)
                {
                    // UNDONE: Check for ambiguity --> ERRimplAmbig

                    stImplicitScp = lclScp;

                    return  sym;
                }

                continue;
            }

#endif

            sym = stLookupLclSym(name, lclScp);
            if  (sym)
                return  sym;
        }
    }

    /* Now check the current class, if we're in one */

    for (curCls = ourComp->cmpCurCls; curCls; curCls = curCls->sdParent)
    {
        if  (curCls->sdSymKind == SYM_CLASS)
        {
            if  (curCls->sdName == name && (symNS & NS_TYPE))
                return  curCls;

            sym = stLookupAllCls(name, curCls, symNS, CS_DECLSOON);
            if  (sym)
            {
                if  (sym->sdNameSpace & symNS)
                    return  sym;
            }
        }
        else
        {
            if  (curCls->sdSymKind != SYM_ENUM)
                break;
            if  (symNS & NS_NORM)
            {
                sym = stLookupScpSym(name, curCls);
                if  (sym)
                    return  sym;
            }
        }
    }

    /* Look in the current namespace and its parents (along with "using"'s) */

    for (curNS = ourComp->cmpCurNS, uses = ourComp->cmpCurUses;
         curNS;
         curNS = curNS->sdParent)
    {
        /* Look in the namespace itself */

        sym = stLookupNspSym(name, symNS, curNS);
        if  (sym)
        {
            if  (sym->sdNameSpace & symNS)
            {
                //               If we've found a namespace symbol, look
                //               in the "using" scope also, and if we
                //               find a symbol there choose it instead.

                if  (sym->sdSymKind == SYM_NAMESPACE)
                {
                    SymDef          use;

                    assert(uses && uses->ulAnchor && uses->ul.ulSym == curNS);

                    use = stSearchUsing(uses, name, symNS);
                    if  (use)
                        return  use;
                }

                return  sym;
            }
        }

        /* Each NS level should have its "using" anchor point */

        assert(uses && uses->ulAnchor && uses->ul.ulSym == curNS);

        sym = stSearchUsing(uses, name, symNS);
        if  (sym)
        {
            if  ((sym->sdNameSpace & symNS) || sym == stErrSymbol)
                return  sym;

            while (!uses->ulAnchor)
            {
                uses = uses->ulNext; assert(uses);
            }
        }

        /* Does the namespace itself match the name we're looking for? */

        if  (curNS->sdName == name && (symNS & NS_NORM))
            return  curNS;
    }

    /* There might be "using" clauses in effect at global scope */

    if  (uses)
    {
        sym = stSearchUsing(uses, name, symNS);
        if  (sym)
            return  sym;
    }

#if 0

    /* Are there any implicit outer scopes ? */

    for (curScp = ourComp->cmpOuterScp; curScp; curScp = curScp->sdParent)
    {
        assert(curScp->sdSymKind == SYM_SCOPE);

        sym = stLookupScpSym(name, curScp);
        if  (sym)
        {
            if  (sym->sdNameSpace & symNS)
                return  sym;
        }
    }

#endif

    /*
        Here we have exhausted all the scopes. The last thing we try is to
        check whether we should look in the non-type namespace - if we're
        looking for a type we first try the type namespace and then the
        other one.
     */

    if  (symNS == NS_TYPE)
    {
        symNS = NS_NORM;
        goto AGAIN;
    }

    return  NULL;
}

/*****************************************************************************
 *
 *  Given a symbol, locate the symbol table it belongs to.
 */

SymTab              SymDefRec::sdOwnerST()
{
    SymDef          sym;

    // UNDONE: How the heck do we figure out which symbol table this symbol
    // UNDONE: belongs to? For now, just use the global one ....

    for (sym = this; sym->sdSymKind != SYM_NAMESPACE; sym = sym->sdParent)
    {
        assert(sym);
    }

    return  sym->sdNS.sdnSymtab;
}

/*****************************************************************************
 *
 *  Given a symbol that represents a type name, return its type (these are
 *  created in a "lazy" as-needed fashion).
 */

TypDef              SymDefRec::sdTypeMake()
{
    assert(this);

    if  (!sdType)
    {
        SymTab          stab;
        TypDef          type;

        stab = sdOwnerST();

        switch (sdSymKind)
        {
        case SYM_TYPEDEF:
            type = stab->stNewTdefType(this);
            break;

        case SYM_ENUM:
            type = stab->stNewEnumType(this);
            break;

        case SYM_CLASS:
            type = stab->stNewClsType(this);
            break;

        default:
            NO_WAY(!"unexpected type kind in sdTypeMake()");
        }

        sdType = type;
    }

    return  sdType;
}

/*****************************************************************************
 *
 *  Look for an overloaded function with a matching argument list.
 */

SymDef              symTab::stFindOvlFnc(SymDef fsym, TypDef type)
{
    while (fsym)
    {
        TypDef          ftyp;

        assert(fsym->sdSymKind == SYM_FNC);

        ftyp = fsym->sdType;
        assert(ftyp && ftyp->tdTypeKind == TYP_FNC);

        /* Do the argument lists match? */

        if  (stArgsMatch(ftyp, type))
        {
            /* For conversion operators the return types must match as well */

            if  (fsym->sdFnc.sdfConvOper)
            {
                assert(fsym->sdFnc.sdfOper == OVOP_CONV_IMP ||
                       fsym->sdFnc.sdfOper == OVOP_CONV_EXP);

                if  (stMatchTypes(ftyp->tdFnc.tdfRett, type->tdFnc.tdfRett))
                    break;
            }
            else
            {
                assert(fsym->sdFnc.sdfOper != OVOP_CONV_IMP &&
                       fsym->sdFnc.sdfOper != OVOP_CONV_EXP);

                break;
            }
        }

        fsym = fsym->sdFnc.sdfNextOvl;
    }

    return fsym;
}

/*****************************************************************************
 *
 *  Look for an overloaded property with a matching type.
 */

SymDef              symTab::stFindOvlProp(SymDef psym, TypDef type)
{
    while (psym)
    {
        TypDef          ptyp = psym->sdType;

        assert(psym->sdSymKind == SYM_PROP);

        /* Are both indexed/non-indexed properties? */

        if  (ptyp->tdTypeKind != TYP_FNC &&
             type->tdTypeKind != TYP_FNC)
             break;

        if  (ptyp->tdTypeKind == type->tdTypeKind && stArgsMatch(ptyp, type))
            break;

        psym = psym->sdProp.sdpNextOvl;
    }

    return psym;
}

/*****************************************************************************
 *
 *  Look for an overloaded property with a matching type.
 */

SymDef              symTab::stFindSameProp(SymDef psym, TypDef type)
{
    while (psym)
    {
        if  (psym->sdSymKind == SYM_PROP)
        {
            if  (stMatchTypes(psym->sdType, type))
                break;

            psym = psym->sdProp.sdpNextOvl;
        }
        else
        {
            assert(psym->sdSymKind == SYM_FNC);

            psym = psym->sdFnc .sdfNextOvl;
        }
    }

    return psym;
}

/*****************************************************************************
 *
 *  Convert an overloaded operator / constructor name into an index.
 */

ovlOpFlavors        symTab::stOvlOperIndex(tokens token, unsigned argCnt)
{
    /* For now we do a pretty lame thing here */

    if  (token < tkComma)
    {
        switch (token)
        {
        case OPNM_CTOR_INST: return OVOP_CTOR_INST;
        case OPNM_CTOR_STAT: return OVOP_CTOR_STAT;

        case OPNM_FINALIZER: return OVOP_FINALIZER;

        case OPNM_CONV_IMP:  return OVOP_CONV_IMP;
        case OPNM_CONV_EXP:  return OVOP_CONV_EXP;

        case OPNM_EQUALS:    return OVOP_EQUALS;
        case OPNM_COMPARE:   return OVOP_COMPARE;

        case OPNM_PROP_GET:  return OVOP_PROP_GET;
        case OPNM_PROP_SET:  return OVOP_PROP_SET;
        }
    }
    else
    {
        switch (token)
        {
        case tkAdd:          return (argCnt == 2) ? OVOP_ADD : OVOP_NOP;
        case tkSub:          return (argCnt == 2) ? OVOP_SUB : OVOP_NEG;
        case tkMul:          return OVOP_MUL;
        case tkDiv:          return OVOP_DIV;
        case tkPct:          return OVOP_MOD;

        case tkOr:           return OVOP_OR;
        case tkXor:          return OVOP_XOR;
        case tkAnd:          return OVOP_AND;

        case tkLsh:          return OVOP_LSH;
        case tkRsh:          return OVOP_RSH;
        case tkRsz:          return OVOP_RSZ;

        case tkConcat:       return OVOP_CNC;

        case tkEQ:           return OVOP_EQ;
        case tkNE:           return OVOP_NE;

        case tkLT:           return OVOP_LT;
        case tkLE:           return OVOP_LE;
        case tkGE:           return OVOP_GE;
        case tkGT:           return OVOP_GT;

        case tkLogAnd:       return OVOP_LOG_AND;
        case tkLogOr:        return OVOP_LOG_OR;

        case tkBang:         return OVOP_LOG_NOT;
        case tkTilde:        return OVOP_NOT;

        case tkInc:          return OVOP_INC;
        case tkDec:          return OVOP_DEC;

        case tkAsg:          return OVOP_ASG;

        case tkAsgAdd:       return OVOP_ASG_ADD;
        case tkAsgSub:       return OVOP_ASG_SUB;
        case tkAsgMul:       return OVOP_ASG_MUL;
        case tkAsgDiv:       return OVOP_ASG_DIV;
        case tkAsgMod:       return OVOP_ASG_MOD;

        case tkAsgAnd:       return OVOP_ASG_AND;
        case tkAsgXor:       return OVOP_ASG_XOR;
        case tkAsgOr:        return OVOP_ASG_OR;

        case tkAsgLsh:       return OVOP_ASG_LSH;
        case tkAsgRsh:       return OVOP_ASG_RSH;
        case tkAsgRsz:       return OVOP_ASG_RSZ;

        case tkAsgCnc:       return OVOP_ASG_CNC;
        }
    }

#ifdef  DEBUG
    printf("Unexpected operator name: '%s'\n", stComp->cmpGlobalHT->tokenToIdent(token)->idSpelling());
    NO_WAY(!"bad oper name");
#endif

    return  OVOP_NONE;
}

/*****************************************************************************
 *
 *  Convert an overloaded operator / constructor index to a name.
 */

Ident               symTab::stOvlOperIdent(ovlOpFlavors oper)
{
    static
    tokens          optoks[] =
    {
        tkNone,             // OVOP_NONE

        tkAdd,              // OVOP_ADD
        tkSub,              // OVOP_SUB
        tkMul,              // OVOP_MUL
        tkDiv,              // OVOP_DIV
        tkPct,              // OVOP_MOD

        tkOr,               // OVOP_OR
        tkXor,              // OVOP_XOR
        tkAnd,              // OVOP_AND

        tkLsh,              // OVOP_LSH
        tkRsh,              // OVOP_RSH
        tkRsz,              // OVOP_RSZ

        tkConcat,           // OVOP_ASG_CNC

        tkEQ,               // OVOP_EQ
        tkNE,               // OVOP_NE

        tkLT,               // OVOP_LT
        tkLE,               // OVOP_LE
        tkGE,               // OVOP_GE
        tkGT,               // OVOP_GT

        tkLogAnd,           // OVOP_AND
        tkLogOr,            // OVOP_OR

        tkBang,             // OVOP_NOT
        tkTilde,            // OVOP_LOG_NOT

        tkAdd,              // OVOP_NOP
        tkSub,              // OVOP_NEG

        tkInc,              // OVOP_INC
        tkDec,              // OVOP_DEC

        tkAsg,              // OVOP_ASG

        tkAsgAdd,           // OVOP_ASG_ADD
        tkAsgSub,           // OVOP_ASG_SUB
        tkAsgMul,           // OVOP_ASG_MUL
        tkAsgDiv,           // OVOP_ASG_DIV
        tkAsgMod,           // OVOP_ASG_MOD

        tkAsgAnd,           // OVOP_ASG_AND
        tkAsgXor,           // OVOP_ASG_XOR
        tkAsgOr,            // OVOP_ASG_OR

        tkAsgLsh,           // OVOP_ASG_LSH
        tkAsgRsh,           // OVOP_ASG_RSH
        tkAsgRsz,           // OVOP_ASG_RSZ

        tkAsgCnc,           // OVOP_ASG_CNC

        OPNM_CTOR_INST,     // OVOP_CTOR_INST
        OPNM_CTOR_STAT,     // OVOP_CTOR_STAT

        OPNM_FINALIZER,     // OVOP_FINALIZER

        OPNM_CONV_IMP,      // OVOP_CONV_IMP
        OPNM_CONV_EXP,      // OVOP_CONV_EXP

        OPNM_EQUALS,        // OVOP_EQUALS
        OPNM_COMPARE,       // OVOP_COMPARE

        OPNM_PROP_GET,      // OVOP_PROP_GET
        OPNM_PROP_SET,      // OVOP_PROP_SET
    };

    assert(oper < arraylen(optoks));

    assert(optoks[OVOP_ADD      ] == tkAdd         );
    assert(optoks[OVOP_SUB      ] == tkSub         );
    assert(optoks[OVOP_MUL      ] == tkMul         );
    assert(optoks[OVOP_DIV      ] == tkDiv         );
    assert(optoks[OVOP_MOD      ] == tkPct         );

    assert(optoks[OVOP_OR       ] == tkOr          );
    assert(optoks[OVOP_XOR      ] == tkXor         );
    assert(optoks[OVOP_AND      ] == tkAnd         );

    assert(optoks[OVOP_LSH      ] == tkLsh         );
    assert(optoks[OVOP_RSH      ] == tkRsh         );
    assert(optoks[OVOP_RSZ      ] == tkRsz         );

    assert(optoks[OVOP_CNC      ] == tkConcat      );

    assert(optoks[OVOP_EQ       ] == tkEQ          );
    assert(optoks[OVOP_NE       ] == tkNE          );

    assert(optoks[OVOP_LT       ] == tkLT          );
    assert(optoks[OVOP_LE       ] == tkLE          );
    assert(optoks[OVOP_GE       ] == tkGE          );
    assert(optoks[OVOP_GT       ] == tkGT          );

    assert(optoks[OVOP_LOG_AND  ] == tkLogAnd      );
    assert(optoks[OVOP_LOG_OR   ] == tkLogOr       );

    assert(optoks[OVOP_LOG_NOT  ] == tkBang        );
    assert(optoks[OVOP_NOT      ] == tkTilde       );

    assert(optoks[OVOP_NOP      ] == tkAdd         );
    assert(optoks[OVOP_NEG      ] == tkSub         );

    assert(optoks[OVOP_INC      ] == tkInc         );
    assert(optoks[OVOP_DEC      ] == tkDec         );

    assert(optoks[OVOP_ASG      ] == tkAsg         );

    assert(optoks[OVOP_ASG_ADD  ] == tkAsgAdd      );
    assert(optoks[OVOP_ASG_SUB  ] == tkAsgSub      );
    assert(optoks[OVOP_ASG_MUL  ] == tkAsgMul      );
    assert(optoks[OVOP_ASG_DIV  ] == tkAsgDiv      );
    assert(optoks[OVOP_ASG_MOD  ] == tkAsgMod      );

    assert(optoks[OVOP_ASG_AND  ] == tkAsgAnd      );
    assert(optoks[OVOP_ASG_XOR  ] == tkAsgXor      );
    assert(optoks[OVOP_ASG_OR   ] == tkAsgOr       );

    assert(optoks[OVOP_ASG_LSH  ] == tkAsgLsh      );
    assert(optoks[OVOP_ASG_RSH  ] == tkAsgRsh      );
    assert(optoks[OVOP_ASG_RSZ  ] == tkAsgRsz      );

    assert(optoks[OVOP_ASG_CNC  ] == tkAsgCnc      );

    assert(optoks[OVOP_CTOR_INST] == OPNM_CTOR_INST);
    assert(optoks[OVOP_CTOR_STAT] == OPNM_CTOR_STAT);

    assert(optoks[OVOP_FINALIZER] == OPNM_FINALIZER);

    assert(optoks[OVOP_CONV_IMP ] == OPNM_CONV_IMP );
    assert(optoks[OVOP_CONV_EXP ] == OPNM_CONV_EXP );

    assert(optoks[OVOP_EQUALS   ] == OPNM_EQUALS   );
    assert(optoks[OVOP_COMPARE  ] == OPNM_COMPARE  );

    assert(optoks[OVOP_PROP_GET ] == OPNM_PROP_GET );
    assert(optoks[OVOP_PROP_SET ] == OPNM_PROP_SET );

    return  stComp->cmpGlobalHT->tokenToIdent(optoks[oper]);
}

/*****************************************************************************
 *
 *  Declare an overloaded operator / constructor symbol.
 */

SymDef              symTab::stDeclareOper(ovlOpFlavors oper, SymDef scope)
{
    SymDef          memSym;
#if MGDDATA
    SymDef  []      memTab;
#else
    SymDef  *       memTab;
    size_t          memSiz;
#endif

    /* Make sure the overloaded operator table for the class is allocated */

    assert(scope && scope->sdSymKind == SYM_CLASS);

    memTab = scope->sdClass.sdcOvlOpers;
    if  (!memTab)
    {
        /* Allocate the overloaded operator table */

#if MGDDATA
        memTab = new managed SymDef[OVOP_COUNT];
#else
        size_t          size = (unsigned)OVOP_COUNT * sizeof(*memTab);
        memTab = (SymDef*)stAllocPerm->nraAlloc(size);
        memset(memTab, 0, size);
#endif

        /* Store the table in the class */

        scope->sdClass.sdcOvlOpers = memTab;
    }

    /* This function should never be called to add an overload */

    assert(oper < OVOP_COUNT); assert(memTab[oper] == NULL);

    /* Allocate the symbol and stick it in the table */

#if MGDDATA

    memSym = new SymDef;

#else

    memSiz = symbolSize(SYM_FNC);
    memSym = (SymDef)stAllocPerm->nraAlloc(memSiz);

#if SYMALLOC_DISP
    totSymSize += memSiz;
#endif

    memset(memSym, 0, memSiz);          // ISSUE: is this a good idea?

#endif

    memSym->sdName         = stOvlOperIdent(oper);
    memSym->sdSymKind      = SYM_FNC;
    memSym->sdNameSpace    = NS_NORM;
    memSym->sdParent       = scope;
    memSym->sdCompileState = CS_KNOWN;

    /* Add the member to the parent's list of kids */

    if  (scope->sdScope.sdScope.sdsChildLast)
        scope->sdScope.sdScope.sdsChildLast->sdNextInScope  = memSym;
    else
        scope->sdScope.sdScope.sdsChildList                 = memSym;

    scope->sdScope.sdScope.sdsChildLast = memSym;

    /* Remember that the member is an overloaded operator */

    memSym->sdFnc.sdfOper = oper; assert(memSym->sdFnc.sdfOper == oper);

    if  (oper == OVOP_CONV_EXP || oper == OVOP_CONV_IMP)
        memSym->sdFnc.sdfConvOper = true;

    /* Store the symbol in the operator table and return */

    memTab[oper] = memSym;

    return  memSym;
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\smcpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __PREPROCESS__

#include <windows.h>

#include <cor.h>

#include <assert.h>
#include <stddef.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <excpt.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>

#include "smc.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\scan.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include <sys/types.h>
#include <sys/stat.h>

/*****************************************************************************/

#include "alloc.h"
#include "scan.h"
#include "error.h"

/*****************************************************************************/
#ifdef  DEBUG
#define DISP_TOKEN_STREAMS  0
#else
#define DISP_TOKEN_STREAMS  0
#endif
/*****************************************************************************/

#ifndef __SMC__
unsigned            scanner::scanHashValIds[256];
unsigned            scanner::scanHashValAll[256];
#endif

/*****************************************************************************
 *
 *  Record the current position as the start of the current token.
 */

inline
void                scanner::saveSrcPos()
{
    assert(scanTokReplay == NULL);

//  scanTokColumn = scanInputFile.inputStreamCurCol();
    scanTokSrcPos = scanSaveNext;
}

/*****************************************************************************
 *
 *  The following functions can be used to construct error string(s).
 */

void                scanner::scanErrNameBeg()
{
    scanErrStrNext = scannerBuff;
}

char        *       scanner::scanErrNameStrBeg()
{
    return  scanErrStrNext;
}

void                scanner::scanErrNameStrAdd(stringBuff str)
{
    if  (scanErrStrNext != str)
        strcpy(scanErrStrNext, str);

    scanErrStrNext += strlen(str);
}

void                scanner::scanErrNameStrApp(stringBuff str)
{
    scanErrStrNext--;
    scanErrNameStrAdd(str);
}

#if MGDDATA
void                scanner::scanErrNameStrAdd(String     str)
{
    UNIMPL(!"managed stradd");
}
void                scanner::scanErrNameStrAdd(String     str)
{
    UNIMPL(!"managed stradd");
}
#endif

void                scanner::scanErrNameStrEnd()
{
    *scanErrStrNext++ = 0;
}

/*****************************************************************************/

bool                infile::inputStreamInit(Compiler        comp,
                                            const char     *filename,
                                            bool            textMode)
{
    _Fstat          fileInfo;

    void           *buffAddr;

    DWORD           numRead;

    bool            result = true;

    /* Record the compiler reference for later use */

    inputComp     = comp;

    /* Remember the file name and mode */

    inputFileName = filename;
    inputFileText = textMode;

    cycleCounterPause();

    /* See if the source file exists */

    if  (_stat(filename, &fileInfo))
        goto EXIT;

    /* Open the file (we know it exists, but we check for errors anyway) */

    inputFile = CreateFileA(filename, GENERIC_READ,
                                      FILE_SHARE_READ,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_FLAG_SEQUENTIAL_SCAN,
                                      0);
    if  (!inputFile)
        goto EXIT;

    /* Read the file contents into a memory buffer */

    buffAddr = malloc(fileInfo.st_size + 1);
    if  (!buffAddr)
        comp->cmpGenFatal(ERRnoMemory);

    if  (!ReadFile(inputFile, buffAddr, fileInfo.st_size, &numRead, NULL) ||
         numRead != (DWORD)fileInfo.st_size)
    {
        comp->cmpGenFatal(ERRreadErr, inputFileName);
        free(buffAddr);
        goto EXIT;
    }

    /* Append an EOF character so we don't have to check for end of file */

    ((BYTE*)buffAddr)[fileInfo.st_size] = 0x1A;

    /* Set up the input buffer pointers and such */

    inputBuffNext     =
    inputBuffAddr     = (BYTE *)buffAddr;
    inputBuffSize     = fileInfo.st_size;
    inputBuffLast     = inputBuffAddr + inputBuffSize + 1;

    inputSrcText      = NULL;
    inputSrcBuff      = NULL;

    /* Setup the file and line position logic */

    inputFilePos      = 0;
    inputStreamLineNo = 0;

    inputFileOver     = false;

    /* Everything went fine, return a success code to the caller */

    result = false;

EXIT:

    cycleCounterResume();

    return  result;
}

void                infile::inputStreamInit(Compiler comp, QueuedFile  buff,
                                                           const char *text)
{
    inputFile          = 0;

    inputBuffAddr      = NULL;

    inputSrcText       = text;
    inputSrcBuff       = buff;

#ifdef  ASYNCH_INPUT_READ
    if  (buff)
    {
        assert(text == NULL);

        inputStreamLineBeg =
        inputBuffNext      = (const BYTE *)buff->qfBuff;
        inputBuffLast      = (const BYTE *)buff->qfBuff + buff->qfSize + 1;

        inputFileName      = buff->qfName;
    }
    else
#endif
    {
        assert(buff == NULL);

        inputStreamLineBeg =
        inputBuffNext      = (const BYTE *)text;
        inputBuffLast      = (const BYTE *)text + strlen(text);

        inputFileName      = "<mem>";
    }

    assert(inputBuffLast > inputBuffNext && inputBuffLast[-1] == 0x1A);

    inputFilePos       = 0;

    inputStreamLineNo  = 0;

    inputFileOver      = false;
}

unsigned            infile::inputStreamMore()
{
    /* Input buffer exhausted */

    if  (!inputSrcText)
    {
        if  (!inputFileText)
            inputComp->cmpGenFatal(ERRreadErr, inputFileName);
    }

    /* We've reached the end of the input file */

    inputFileOver = true;

    return  0x1A;
}

void                infile::inputStreamDone()
{
    if  (inputBuffAddr)
    {
        free((void *)inputBuffAddr); inputBuffAddr = NULL;
    }

#ifdef  ASYNCH_INPUT_READ
    if  (inputSrcBuff)
    {
        free(inputSrcBuff->qfBuff);
             inputSrcBuff->qfBuff = NULL;

        inputSrcBuff = NULL;
    }
#endif

    if  (inputFile != 0)
    {
        CloseHandle(inputFile); inputFile = 0;
    }
}

/*****************************************************************************
 *
 *  Read the next source character, checking for an "\EOL" sequence.
 */

inline
int                 scanner::scanNextChar()
{
    int             ch = readNextChar();

    if  (ch == '\\')
    {
        UNIMPL(!"backslash");
    }

    return  ch;
}

/*****************************************************************************
 *
 *  The following table speeds various tests of characters, such as whether
 *  a given character can be part of an identifier, and so on.
 */

enum    CFkinds
{
    _CF_IDENT_OK = 0x01,
    _CF_HEXDIGIT = 0x02,
};

static  unsigned char   charFlags[256] =
{
    0,                          /* 0x00   */
    0,                          /* 0x01   */
    0,                          /* 0x02   */
    0,                          /* 0x03   */
    0,                          /* 0x04   */
    0,                          /* 0x05   */
    0,                          /* 0x06   */
    0,                          /* 0x07   */
    0,                          /* 0x08   */
    0,                          /* 0x09   */
    0,                          /* 0x0A   */
    0,                          /* 0x0B   */
    0,                          /* 0x0C   */
    0,                          /* 0x0D   */
    0,                          /* 0x0E   */
    0,                          /* 0x0F   */
    0,                          /* 0x10   */
    0,                          /* 0x11   */
    0,                          /* 0x12   */
    0,                          /* 0x13   */
    0,                          /* 0x14   */
    0,                          /* 0x15   */
    0,                          /* 0x16   */
    0,                          /* 0x17   */
    0,                          /* 0x18   */
    0,                          /* 0x19   */
    0,                          /* 0x1A   */
    0,                          /* 0x1B   */
    0,                          /* 0x1C   */
    0,                          /* 0x1D   */
    0,                          /* 0x1E   */
    0,                          /* 0x1F   */
    0,                          /* 0x20   */
    0,                          /* 0x21 ! */
    0,                          /* 0x22   */
    0,                          /* 0x23 # */
    0,                          /* 0x24 $ */
    0,                          /* 0x25 % */
    0,                          /* 0x26 & */
    0,                          /* 0x27   */
    0,                          /* 0x28   */
    0,                          /* 0x29   */
    0,                          /* 0x2A   */
    0,                          /* 0x2B   */
    0,                          /* 0x2C   */
    0,                          /* 0x2D   */
    0,                          /* 0x2E   */
    0,                          /* 0x2F   */
    0,                          /* 0x30   */
    0,                          /* 0x31   */
    0,                          /* 0x32   */
    0,                          /* 0x33   */
    0,                          /* 0x34   */
    0,                          /* 0x35   */
    0,                          /* 0x36   */
    0,                          /* 0x37   */
    0,                          /* 0x38   */
    0,                          /* 0x39   */
    0,                          /* 0x3A   */
    0,                          /* 0x3B   */
    0,                          /* 0x3C < */
    0,                          /* 0x3D = */
    0,                          /* 0x3E > */
    0,                          /* 0x3F   */
    0,                          /* 0x40 @ */
    _CF_HEXDIGIT,               /* 0x41 A */
    _CF_HEXDIGIT,               /* 0x42 B */
    _CF_HEXDIGIT,               /* 0x43 C */
    _CF_HEXDIGIT,               /* 0x44 D */
    _CF_HEXDIGIT,               /* 0x45 E */
    _CF_HEXDIGIT,               /* 0x46 F */
    0,                          /* 0x47 G */
    0,                          /* 0x48 H */
    0,                          /* 0x49 I */
    0,                          /* 0x4A J */
    0,                          /* 0x4B K */
    0,                          /* 0x4C L */
    0,                          /* 0x4D M */
    0,                          /* 0x4E N */
    0,                          /* 0x4F O */
    0,                          /* 0x50 P */
    0,                          /* 0x51 Q */
    0,                          /* 0x52 R */
    0,                          /* 0x53 S */
    0,                          /* 0x54 T */
    0,                          /* 0x55 U */
    0,                          /* 0x56 V */
    0,                          /* 0x57 W */
    0,                          /* 0x58 X */
    0,                          /* 0x59 Y */
    0,                          /* 0x5A Z */
    0,                          /* 0x5B   */
    0,                          /* 0x5C   */
    0,                          /* 0x5D   */
    0,                          /* 0x5E   */
    0,                          /* 0x5F   */
    0,                          /* 0x60   */
    _CF_HEXDIGIT,               /* 0x61 a */
    _CF_HEXDIGIT,               /* 0x62 b */
    _CF_HEXDIGIT,               /* 0x63 c */
    _CF_HEXDIGIT,               /* 0x64 d */
    _CF_HEXDIGIT,               /* 0x65 e */
    _CF_HEXDIGIT,               /* 0x66 f */
    0,                          /* 0x67 g */
    0,                          /* 0x68 h */
    0,                          /* 0x69 i */
    0,                          /* 0x6A j */
    0,                          /* 0x6B k */
    0,                          /* 0x6C l */
    0,                          /* 0x6D m */
    0,                          /* 0x6E n */
    0,                          /* 0x6F o */
    0,                          /* 0x70 p */
    0,                          /* 0x71 q */
    0,                          /* 0x72 r */
    0,                          /* 0x73 s */
    0,                          /* 0x74 t */
    0,                          /* 0x75 u */
    0,                          /* 0x76 v */
    0,                          /* 0x77 w */
    0,                          /* 0x78 x */
    0,                          /* 0x79 y */
    0,                          /* 0x7A z */
    0,                          /* 0x7B   */
    0,                          /* 0x7C   */
    0,                          /* 0x7D   */
    0,                          /* 0x7E   */
    0                           /* 0x7F   */

    // all the remaining values are 0
};

/*****************************************************************************
 *
 *  The _C_xxx enum and scanCharType[] table are used to map a character to
 *  simple classification values and flags.
 */

enum charTypes
{
        _C_ERR,             // illegal character
        _C_EOF,             // end of file

#if FV_DBCS
        _C_XLD,             // first char of a multi-byte sequence
        _C_DB1,             // a SB char that needs to be mapped to a DB char
#endif

        _C_LET,             // letter (B-K,M-Z,a-z)
        _C_L_A,             // letter 'A'
        _C_L_L,             // letter 'L'
        _C_L_S,             // letter 'S'
        _C_DIG,             // digit (0-9)
        _C_WSP,             // white space
        _C_NWL,             // new line

        _C_DOL,             // $
        _C_BSL,             // \ (backslash)

        _C_BNG,             // !
        _C_QUO,             // "
        _C_APO,             // '
        _C_PCT,             // %
        _C_AMP,             // &
        _C_LPR,             // (
        _C_RPR,             // )
        _C_PLS,             // +
        _C_MIN,             // -
        _C_MUL,             // *
        _C_SLH,             // /
        _C_XOR,             // ^
        _C_CMA,             // ,
        _C_DOT,             // .
        _C_LT,              // <
        _C_EQ,              // =
        _C_GT,              // >
        _C_QUE,             // ?
        _C_LBR,             // [
        _C_RBR,             // ]
        _C_USC,             // _
        _C_LC,              // {
        _C_RC,              // }
        _C_BAR,             // |
        _C_TIL,             // ~
        _C_COL,             // :
        _C_SMC,             // ;
        _C_AT,              // @
};

const   charTypes   _C_BKQ = _C_ERR;      // `
const   charTypes   _C_SHP = _C_ERR;      // #

static
unsigned char       scanCharType[256] =
{
    _C_ERR, _C_ERR, _C_ERR, _C_ERR, _C_ERR, _C_ERR, _C_ERR, _C_ERR, /* 00-07 */
    _C_ERR, _C_WSP, _C_NWL, _C_ERR, _C_WSP, _C_NWL, _C_ERR, _C_ERR, /* 08-0F */

    _C_ERR, _C_ERR, _C_ERR, _C_ERR, _C_ERR, _C_ERR, _C_ERR, _C_ERR, /* 10-17 */
    _C_ERR, _C_WSP, _C_EOF, _C_ERR, _C_ERR, _C_ERR, _C_ERR, _C_ERR, /* 18-1F */

    _C_WSP, _C_BNG, _C_QUO, _C_SHP, _C_DOL, _C_PCT, _C_AMP, _C_APO, /* 20-27 */
    _C_LPR, _C_RPR, _C_MUL, _C_PLS, _C_CMA, _C_MIN, _C_DOT, _C_SLH, /* 28-2F */

    _C_DIG, _C_DIG, _C_DIG, _C_DIG, _C_DIG, _C_DIG, _C_DIG, _C_DIG, /* 30-37 */
    _C_DIG, _C_DIG, _C_COL, _C_SMC, _C_LT , _C_EQ , _C_GT , _C_QUE, /* 38-3F */

    _C_AT , _C_L_A, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* 40-47 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_L_L, _C_LET, _C_LET, _C_LET, /* 48-4F */

    _C_LET, _C_LET, _C_LET, _C_L_S, _C_LET, _C_LET, _C_LET, _C_LET, /* 50-57 */
    _C_LET, _C_LET, _C_LET, _C_LBR, _C_BSL, _C_RBR, _C_XOR, _C_USC, /* 58-5F */

    _C_BKQ, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* 60-67 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* 68-6F */

    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* 70-77 */
    _C_LET, _C_LET, _C_LET, _C_LC , _C_BAR, _C_RC , _C_TIL, _C_ERR, /* 78-7F */

    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* 80-87 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* 88-8F */

    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* 90-97 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* 98-9F */

    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* A0-A7 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* A8-AF */

    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* B0-B7 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* B8-BF */

    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* C0-C7 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* C8-CF */

    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* D0-D7 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* D8-DF */

    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* E0-E7 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* E8-EF */

    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* F0-F7 */
    _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, _C_LET, /* F8-FF */
};

inline
unsigned                charType(unsigned ch)
{
    assert(ch <= 0xFF);
    return  scanCharType[ch];
}

inline
unsigned            wideCharType(unsigned ch)
{
    return  (ch <= 0xFF) ? scanCharType[ch]
                         : _C_LET;
}

/*****************************************************************************
 *
 *  Fill the hash tables with values. Note that the scanCharType[] table must
 *  be initialized properly before calling this routine.
 */

void                hashTab::hashFuncInit(unsigned randSeed)
{
    unsigned        i;

    /* Start the random number generator */

    srand(randSeed);

    /* Fill the 'all' table with random numbers */

    for (i = 0; i < 256; i++)
    {
        int     val = rand();
        if  (!val)
            val = 1;

        scanner::scanHashValAll[i] = val;
    }

    /* Set the appropriate entries in the 'ident-only' array */

    memset(&scanner::scanHashValIds, 0, sizeof(scanner::scanHashValIds));

    for (i = 0; i < 256; i++)
    {
        switch (scanCharType[i])
        {
        case _C_LET:
        case _C_L_A:
        case _C_L_L:
        case _C_L_S:
        case _C_DIG:
        case _C_USC:
        case _C_DOL:

            scanner::scanHashValIds[i] = scanner::scanHashValAll[i];

            /* Remember whether this character is OK in an identifier */

            charFlags[i] |=  _CF_IDENT_OK;
            break;

        default:

            charFlags[i] &= ~_CF_IDENT_OK;
            break;
        }
    }
}

inline  void        hashFNstart(INOUT unsigned REF hv        ) { hv = 0; }
inline  void        hashFNaddCh(INOUT unsigned REF hv, int ah) { hv = hv * 3 ^ ah; }
inline  unsigned    hashFNvalue(INOUT unsigned REF hv        ) { return hv; }

unsigned            hashTab::hashComputeHashVal(const char *name)
{
    unsigned    hash;
    unsigned    hadd;

    hashFNstart(hash);

    for (;;)
    {
        unsigned    ch = *(BYTE *)name; name++;

        if  (!ch)
            return  hashFNvalue(hash);

        hadd = scanner::scanHashValAll[ch]; assert(hadd);

        hashFNaddCh(hash, hadd);
    }
}

unsigned            hashTab::hashComputeHashVal(const char *name, size_t nlen)
{
    unsigned    hash;
    unsigned    hadd;

    assert(nlen);

    hashFNstart(hash);

    do
    {
        unsigned    ch = *(BYTE *)name; name++;

        hadd = scanner::scanHashValAll[ch]; assert(hadd);

        hashFNaddCh(hash, hadd);
    }
    while (--nlen);

    return  hashFNvalue(hash);
}

/*****************************************************************************/

bool            hashTab::hashStringCompare(const char *s1, const char *s2)
{
    return  (strcmp(s1, s2) == 0);
}

/*****************************************************************************/

#ifdef DEBUG

bool                scanner::scanDispCurToken(bool lastId, bool brief)
{
    bool            prevId = lastId;
                             lastId = false;

    if  (brief)
    {
        const char *    name;

        switch  (scanTok.tok)
        {
        case tkID:

            name = hashTab::identSpelling(scanTok.id.tokIdent);

        SHOW_ID:

            if  (strlen(name) > 0)
            {
                printf("[I]");
            }
            else
            {
                if  (prevId) printf(" ");
                printf("%s", name);
                lastId = true;
            }
            break;

        case tkIntCon:
            if  (prevId) printf(" ");
            printf("%ld", scanTok.intCon.tokIntVal);
            lastId = true;
            break;

        case tkLngCon:
            if  (prevId) printf(" ");
            printf("%Ld", scanTok.lngCon.tokLngVal);
            lastId = true;
            break;

        case tkFltCon:
            if  (prevId) printf(" ");
            printf("%f", scanTok.fltCon.tokFltVal);
            lastId = true;
            break;

        case tkStrCon:
            if  (prevId) printf(" ");
            printf("\"%s\"", scanTok.strCon.tokStrVal);
            lastId = true;
            break;

        case tkEOF:
            printf("\n");
            break;

        default:

            name = scanHashKwd->tokenName(scanTok.tok);

            if (scanTok.tok <= tkKwdLast)
                goto SHOW_ID;

            printf("%s", name);
            break;
        }
    }
    else
    {
//      printf("[line=%4u,col=%03u] ", scanTokLineNo, scanTokColumn);
        printf("[line=%4u] "         , scanTokLineNo);

        switch  (scanTok.tok)
        {
        case tkID:
            printf("Ident   '%s' \n", hashTab::identSpelling(scanTok.id.tokIdent));
            break;

        case tkIntCon:
            printf("Integer  %ld \n", scanTok.intCon.tokIntVal);
            break;

        case tkLngCon:
            printf("Long     %Ld \n", scanTok.lngCon.tokLngVal);
            break;

        case tkFltCon:
            printf("Float    %f  \n", scanTok.fltCon.tokFltVal);
            break;

        case tkDblCon:
            printf("Double   %f  \n", scanTok.dblCon.tokDblVal);
            break;

        case tkStrCon:
            printf("String   '%s'\n", scanTok.strCon.tokStrVal);
            break;

        case tkEOF:
            printf("EOF\n");
            break;

        default:

            /* Must be a keyword token */

            assert(tokenToIdent(scanTok.tok));

//          printf("Keyword '%s' (#%u)\n", hashTab::identSpelling(tokenToIdent(scanTok.tok)), scanTok.tok);
            printf("Keyword '%s'\n",       hashTab::identSpelling(tokenToIdent(scanTok.tok)));
            break;
        }
    }

    return  lastId;
}

#endif

/*****************************************************************************
 *
 *  Reuse or allocate a preprocessing state entry.
 */

inline
PrepList            scanner::scanGetPPdsc()
{
    PrepList        prep;

    if  (scanPrepFree)
    {
        prep = scanPrepFree;
               scanPrepFree = prep->pplNext;
    }
    else
    {
        prep = (PrepList)scanAlloc->nraAlloc(sizeof(*prep));
    }

    return  prep;
}

/*****************************************************************************
 *
 *  Push an entry onto the preprocessing state stack.
 */

void                scanner::scanPPdscPush(preprocState state)
{
    PrepList        prep;

    prep = scanGetPPdsc();

    prep->pplState = state;
    prep->pplLine  = scanTokLineNo;

    prep->pplNext  = scanPrepList;
                     scanPrepList = prep;
}

/*****************************************************************************
 *
 *  Pop the top entry from the preprocessing state stack.
 */

void                scanner::scanPPdscPop()
{
    PrepList        prep;

    prep = scanPrepList;
           scanPrepList = prep->pplNext;

    prep->pplNext = scanPrepFree;
                    scanPrepFree = prep;
}

/*****************************************************************************
 *
 *  We're at the beginning of a new source line, check for a directive. If a
 *  directive is found, its PP_xxx value is returned and 'scanStopAtEOL' will
 *  be set to true;
 */

prepDirs            scanner::scanCheckForPrep()
{
    bool            svp;
    tokens          tok;
    unsigned        ch;

    do
    {
        ch = readNextChar();
    }
    while (charType(ch) == _C_WSP);

    if  (ch != '#')
    {
        undoNextChar();
        return  PP_NONE;
    }

    /* We have what looks like a pre-processing directive */

    scanStopAtEOL = true;

    /* The directive name should come next */

    svp = scanSkipToPP; scanSkipToPP = true;
    tok = scan();
    scanSkipToPP = svp;

    switch (tok)
    {
        Ident           iden;
        const   char *  name;
        unsigned        nlen;

    case tkID:

        /* See what directive we have */

        iden = scanTok.id.tokIdent;
        if  (iden)
        {
            name = hashTab::identSpelling(iden);
            nlen = hashTab::identSpellLen(iden);
        }
        else
        {
            name = scannerBuff;
            nlen = strlen(name);
        }

        /* The following is a bit lame, is there a better way? */

        switch (nlen)
        {
        case 5:

            if  (!memcmp(name, "endif" , 5)) return PP_ENDIF;
            if  (!memcmp(name, "ifdef" , 5)) return PP_IFDEF;
            if  (!memcmp(name, "error" , 5)) return PP_ERROR;

            break;

        case 6:

            if  (!memcmp(name, "ifndef", 6)) return PP_IFNDEF;
            if  (!memcmp(name, "pragma", 6)) return PP_PRAGMA;
            if  (!memcmp(name, "define", 6)) return PP_DEFINE;

            break;
        }

        if  (!scanSkipToPP)
            scanComp->cmpGenWarn(WRNbadPrep, name);

        goto SKIP;

    case tkIF:
        return PP_IF;

    case tkELSE:
        return PP_ELSE;
    }

    if  (!scanSkipToPP)
       scanComp->cmpGenError(ERRbadPPdir);

SKIP:

    scanSkipToEOL();
    scanStopAtEOL = false;

    return  PP_NONE;
}

/*****************************************************************************
 *
 *  Check and make sure we're at the end of the current source line.
 */

inline
void                scanner::scanCheckEOL()
{
    scanStopAtEOL = true;

    if  (scan() != tkEOL)
    {
        scanComp->cmpError(ERRnoEOL);
        scanSkipToEOL();
    }

    scanStopAtEOL = false;
}

/*****************************************************************************
 *
 *  Skip to a matching else and/or endif directive.
 */

void                scanner::scanSkipToDir(preprocState state)
{
    PrepList        basePrep = scanPrepList;

    scanSkipToPP = true;

    for (;;)
    {
        /* Skip the current line and check the next one for a directive */

        for (;;)
        {
            unsigned        ch = readNextChar();

            switch (charType(ch))
            {
            case _C_NWL:

                switch (scanNewLine(ch))
                {
                case PP_ELSE:

                    /* The top entry better be an "if" */

                    if  (scanPrepList == basePrep)
                    {
                        if  (state != PPS_IF)
                            scanComp->cmpError(ERRbadElse);

                        scanSkipToPP = false;

                        scanPPdscPush(PPS_ELSE);
                        return;
                    }
                    else
                    {
                        if  (scanPrepList->pplState != PPS_IF)
                            scanComp->cmpError(ERRbadElse);

                        /* Flip the entry to an "else" */

                        scanPrepList->pplState = PPS_ELSE;
                    }
                    break;

                case PP_ENDIF:

                    /* If there are no nested entries, we're done */

                    if  (scanPrepList == basePrep)
                    {
                        scanSkipToPP = false;
                        return;
                    }

                    /* Pop the most recent entry and keep skipping */

                    scanPPdscPop();
                    break;

                case PP_IF:
                case PP_IFDEF:
                case PP_IFNDEF:

                    /* Push a nested entry */

                    scanPPdscPush(PPS_IF);
                    break;
                }
                break;

            case _C_SLH:

                switch (readNextChar())
                {
                case '/':
                    scanSkipLineCmt();
                    break;

                case '*':
                    scanSkipComment();
                    break;
                }
                continue;

            case _C_EOF:

                undoNextChar();

                /* Report any open sections as errors */

                while (scanPrepList != basePrep)
                {
                    scanComp->cmpGenError(ERRnoEndif, scanPrepList->pplLine);

                    scanPPdscPop();
                }

                scanSkipToPP = false;
                return;

            default:
                continue;
            }
        }
    }
}

/*****************************************************************************
 *
 *  Record the beginning of a new source line and check for a pre-processing
 *  directive.
 */

prepDirs            scanner::scanRecordNL(bool noPrep)
{
    prepDirs        prep;
    bool            cond;

    scanTokLineNo = scanInputFile.inputStreamNxtLine();
//  scanTokColumn = 0;
    scanTokSrcPos = scanSaveNext;

    if  (noPrep)
        return  PP_NONE;

    /* Check for a directive in the new source line */

    prep = scanCheckForPrep();
    if  (prep == PP_NONE || scanSkipToPP)
        return  prep;

    assert(scanTokRecord != false); scanTokRecord = false;

    /* We have a directive and we're supposed to process it */

    switch (prep)
    {
        Ident           iden;
        char    *       dest;

    case PP_IF:

        assert(scanInPPexpr == false);

        scanInPPexpr = true;
        cond = scanComp->cmpEvalPreprocCond();
        scanInPPexpr = false;

        goto PREP_COND;

    case PP_IFDEF:
    case PP_IFNDEF:

        scanNoMacExp  = true;
        scan();
        scanNoMacExp  = false;

        if  (scanTok.tok != tkID)
        {
            scanComp->cmpGenError(ERRnoIdent);

            /* To minimize further errors, assume the condition was false */

            cond = false;
        }
        else
        {
            if  (hashTab::getIdentFlags(scanTok.id.tokIdent) & IDF_MACRO)
            {
                /* True if the directive was an "#ifdef" */

                cond = (prep == PP_IFDEF);
            }
            else
            {
                /* True if the directive was an "#ifndef" */

                cond = (prep == PP_IFNDEF);
            }
        }

    PREP_COND:

        /* Come here for "#ifxxx" with 'cond' set to the condition */

        scanCheckEOL();

        /* Is the condition satisfied? */

        if  (cond)
        {
            /* Push an "if" record on the PP state stack */

            scanPPdscPush(PPS_IF);
        }
        else
        {
            /* Skip to a matching "else" or "endif" */

            scanSkipToDir(PPS_IF);
            goto DIR_DONE;
        }

        break;

    case PP_ELSE:

        /* We better be in an "if" part */

        if  (scanPrepList == NULL || scanPrepList->pplState != PPS_IF)
        {
            scanComp->cmpError(ERRbadElse);
            goto DIR_SKIP;
        }

        /* Skip to the matching "endif" */

        scanSkipToDir(PPS_ELSE);
        goto DIR_DONE;

    case PP_ENDIF:

        /* We better be in a pre-processing section */

        if  (scanPrepList == NULL)
        {
            scanComp->cmpError(ERRbadEndif);
            goto DIR_SKIP;
        }

        scanPPdscPop();
        break;

    case PP_ERROR:
        scanComp->cmpFatal(ERRerrDir);
        NO_WAY(!"should never return here");

    case PP_PRAGMA:

        if  (scan() != tkID)
            goto BAD_PRAGMA;

        /* Check for the pragmas we support */

        if  (!strcmp(scannerBuff, "pack"))
            goto PRAGMA_PACK;
        if  (!strcmp(scannerBuff, "message"))
            goto PRAGMA_MESSAGE;
        if  (!strcmp(scannerBuff, "warning"))
            goto PRAGMA_WARNING;
        if  (!strcmp(scannerBuff, "option"))
            goto PRAGMA_OPTION;

    BAD_PRAGMA:

        scanComp->cmpGenWarn(WRNbadPragma, scannerBuff);
        goto DIR_SKIP;

    PRAGMA_PACK:

        if  (scan() != tkLParen)
        {
            scanComp->cmpError(ERRnoLparen);
            goto DIR_SKIP;
        }

        switch (scan())
        {
        case tkIntCon:
            switch (scanTok.intCon.tokIntVal)
            {
            case 1:
            case 2:
            case 4:
            case 8:
            case 16:
                scanParser->parseAlignSet(scanTok.intCon.tokIntVal);
                break;

            default:
                goto BAD_PACK;
            }
            break;

        case tkID:

            if      (!strcmp(scanTok.id.tokIdent->idSpelling(), "push"))
            {
                scanParser->parseAlignPush();
                break;
            }
            else if (!strcmp(scanTok.id.tokIdent->idSpelling(), "pop" ))
            {
                scanParser->parseAlignPop ();
                break;
            }

            // Fall through ....

        default:

        BAD_PACK:

            scanComp->cmpError(ERRbadAlign);
            goto DIR_SKIP;
        }

        if  (scan() != tkRParen)
        {
            scanComp->cmpError(ERRnoRparen);
            goto DIR_SKIP;
        }

        break;

    PRAGMA_MESSAGE:

        if  (scan() != tkLParen)
        {
            scanComp->cmpError(ERRnoLparen);
            goto DIR_SKIP;
        }

        if  (scan() != tkStrCon)
        {
            scanComp->cmpError(ERRnoString);
            goto DIR_SKIP;
        }

        for (;;)
        {
            unsigned        ch = readNextChar();

            if  (charType(ch) == _C_WSP)
                continue;

            if  (ch != ')')
            {
                scanComp->cmpError(ERRnoLparen);
                goto DIR_SKIP;
            }

            break;
        }

        /* Print the string and make sure no garbage follows */

        if  ( !scanSkipToPP)
        {
            _write(1, scanTok.strCon.tokStrVal,
                      scanTok.strCon.tokStrLen);
            _write(1, "\n", 1);
        }

        break;

    PRAGMA_WARNING:

        if  (scan() != tkLParen)
        {
            scanComp->cmpError(ERRnoLparen);
            goto DIR_SKIP;
        }

        do
        {
            int             val;

            if  (scan() != tkID)
            {
                if  (scanTok.tok != tkDEFAULT)
                {
                    scanComp->cmpError(ERRnoIdent);
                    goto DIR_SKIP;
                }

                val = -1;
            }
            else if (!strcmp(scanTok.id.tokIdent->idSpelling(), "enable"))
            {
                val = 1;
            }
            else if (!strcmp(scanTok.id.tokIdent->idSpelling(), "disable"))
            {
                val = 0;
            }
            else
            {
                scanComp->cmpGenWarn(WRNbadPragma, "warning");
                goto DIR_SKIP;
            }

            if  (scan() != tkColon)
            {
                scanComp->cmpError(ERRnoColon);
                goto DIR_SKIP;
            }

            if  (scan() != tkIntCon)
            {
                scanComp->cmpError(ERRnoIntExpr);
                goto DIR_SKIP;
            }

//          printf("Warning %u\n", scanTok.intCon.tokIntVal);

            if  (scanTok.intCon.tokIntVal <  4000 ||
                 scanTok.intCon.tokIntVal >= 4000 + WRNcountWarn)
            {
                scanComp->cmpGenWarn(WRNbadPragma, "warning");
                goto DIR_SKIP;
            }

            scanTok.intCon.tokIntVal -= 4000;

            if  (val == -1)
                val = scanComp->cmpInitialWarn[scanTok.intCon.tokIntVal];

            scanComp->cmpConfig.ccWarning[scanTok.intCon.tokIntVal] = val;

            /* Make sure we have room to record the pragma */

            if  (scanSaveNext >= scanSaveEndp)
                scanSaveMoreSp();

            /* Record the pragma */

#if DISP_TOKEN_STREAMS
            printf("Save [%08X]: #pragma\n", scanSaveNext);
#endif

            *scanSaveNext++ = tkPragma;
            *scanSaveNext++ = (BYTE)val;
            *scanSaveNext++ = (BYTE)scanTok.intCon.tokIntVal;
        }
        while (scan() == tkComma);

        if  (scanTok.tok != tkRParen)
        {
            scanComp->cmpError(ERRnoRparen);
            goto DIR_SKIP;
        }

        break;

    case PP_DEFINE:

        /* Make sure we have an identifier */

        if  (!scanCollectId())
        {
            scanComp->cmpGenError(ERRnoIdent);
            break;
        }

        /* Are there macro arguments ? */

        if  (peekNextChar() == '(')
        {
            scanComp->cmpGenWarn(WRNmacroArgs);
            goto DIR_SKIP;
        }

        /* Stick the identifier in the keyword hash table */

        iden = scanHashKwd->hashString(scannerBuff); assert(iden);

        /* The definition should follow, collect it */

        dest = scannerBuff;

        while (charType(readNextChar()) == _C_WSP);
        undoNextChar();

        for (;;)
        {
            unsigned        ch = readNextChar();

            switch  (charType(ch))
            {
            case _C_SLH:

                /* Check for start of comment */

                switch (charType(readNextChar()))
                {
                case _C_SLH:
                    undoNextChar();
                    goto DONE_DEF;

                case _C_MUL:
                    scanSkipComment();
                    continue;
                }
                break;

            case _C_WSP:
            case _C_NWL:
            case _C_EOF:
                undoNextChar();
                goto DONE_DEF;
            }

            *dest++ = ch;
        }

    DONE_DEF:

        /* If there is no value, stick in "1" */

        if  (dest == scannerBuff)
            *dest++ = '1';

        *dest = 0;

        if  (!scanComp->cmpConfig.ccNoDefines)
            scanDefMac(iden->idSpelling(), scannerBuff, false, true);

        break;

    PRAGMA_OPTION:

        switch (scanSkipWsp(readNextChar(), true))
        {
        case '-':
        case '/':
            break;

        default:
            scanComp->cmpError(ERRbadPrgOpt);
            goto DIR_SKIP;
        }

        /* Collect the option string */

        undoNextChar();

        for (dest = scannerBuff;;)
        {
            unsigned        ch = readNextChar();

            switch  (charType(ch))
            {
            case _C_SLH:

                /* Check for start of comment */

                switch (charType(readNextChar()))
                {
                case _C_SLH:
                    undoNextChar();
                    goto DONE_DEF;

                case _C_MUL:
                    scanSkipComment();
                    continue;
                }
                break;

            case _C_WSP:
            case _C_NWL:
            case _C_EOF:
                undoNextChar();
                goto DONE_OPT;
            }

            *dest++ = ch;
        }

    DONE_OPT:

        *dest = 0;

//      printf("Option string = '%s'\n", scannerBuff);

        if  (processOption(scannerBuff, scanComp))
            scanComp->cmpError(ERRbadPrgOpt);

        break;
    }

    /* Here we make sure there is no extra garbage after the directive */

    scanCheckEOL();

DIR_DONE:

    scanStopAtEOL = false;
    scanTokRecord = true;

    return  PP_NONE;

DIR_SKIP:

    scanSkipToEOL();

    scanStopAtEOL = false;
    scanTokRecord = true;

    return  PP_NONE;
}

/*****************************************************************************
 *
 *  Initialize the scanner - needs to be called once per lifetime.
 */

bool            scanner::scanInit(Compiler comp, HashTab hashKwd)
{
    /* Remember the compiler and hash table */

    scanComp       = comp;
    scanHashKwd    = hashKwd;

    /* Initialize any other global state */

    scanMacros     = NULL;
    scanPrepFree   = NULL;

    scanStrLitBuff = NULL;

    scanSkipInit();

    /* Prepare to record tokens */

    scanSaveBase   =
    scanSaveNext   =
    scanSaveEndp   = NULL;

    scanSaveMoreSp();

    return  false;
}

/*****************************************************************************
 *
 *  Initializes the scanner to prepare to scan the given source file.
 */

void            scanner::scanStart(SymDef               sourceCSym,
                                   const    char     *  sourceFile,
                                   QueuedFile           sourceBuff,
                                   const    char     *  sourceText,
                                   HashTab              hash,
                                   norls_allocator   *  alloc)
{
    assert(sizeof(scannerBuff) > MAX_IDENT_LEN);

    /* Remember which compilation unit we're in */

    scanCompUnit    = sourceCSym;

    /* Remember which allocator we're supposed to use */

    scanAlloc       = alloc;

    /* We're not in skipping mode */

    scanSkipToPP    = false;

    /* The initial state is "recording tokens" */

    scanTokRecord   = true;
    scanTokReplay   = NULL;

    /* Prepare to record tokens */

    scanSaveLastLn  = 1;

    /* Make the hash table conveniently available */

    scanHashSrc     = hash;

    /* We're not in a conditional compilation block */

    scanPrepList    = NULL;

    /* Normally we pay no attention to newlines */

    scanStopAtEOL   = false;

    /* We're not evaluating a constant expression right now */

    scanInPPexpr    = false;

    /* Go ahead and expand macros for now */

    scanNoMacExp    = false;

    /* We're not processing a generic instance specification */

    scanNestedGTcnt = 0;

    /* We haven't seen any brackets yet */

#ifdef  SETS
    scanBrackLvl    = 0;
#endif

    /* Open the input file */

    if  (sourceBuff || sourceText)
    {
        scanInputFile.inputStreamInit(scanComp, sourceBuff, sourceText);
    }
    else
    {
        char    *   fname;

        /* Allocate a more permanent copy of the file name */

        fname = (char *)alloc->nraAlloc(roundUp(strlen(sourceFile)+1));
        strcpy(fname, sourceFile);

        if  (scanInputFile.inputStreamInit(scanComp, fname, true))
            scanComp->cmpGenFatal(ERRopenRdErr, sourceFile);
    }

    /* Clear any other state */

    scanLookAheadCount = 0;

    /* Initialize the source position tracking logic */

    scanRecordNL(false);
}

/*****************************************************************************
 *
 *  We're done parsing the current source -- free up any resources and close
 *  the file.
 */

void                scanner::scanClose()
{
    scanInputFile.inputStreamDone();
}

/*****************************************************************************
 *
 *  Get the scanner initialized and started.
 */

void                scanner::scanReset()
{
    scanLookAheadCount = 0;

    scanSkipToPP       = false;

    scanTokRecord      = false;

    scanPrepList       = NULL;

    scanStopAtEOL      = false;
    scanInPPexpr       = false;
    scanNoMacExp       = false;

    /* Get things started */

    scanTok.tok = tkNone; scan();
}

/*****************************************************************************
 *
 *  Restart scanning from the specified section of source text (which has
 *  been previously been scanned and kept open). The line# / columnm info
 *  is needed for accurate error reporting.
 */

void                scanner::scanRestart(SymDef            sourceCSym,
                                         const char      * sourceFile,
                                         scanPosTP         begAddr,
//                                       scanPosTP         endAddr,
                                         unsigned          begLine,
//                                       unsigned          begCol,
                                         norls_allocator * alloc)
{
    scanCompUnit       = sourceCSym;

    scanSaveLastLn     =
    scanTokLineNo      = begLine;
//  scanTokColumn      = begCol;

    scanTokReplay      =
    scanTokSrcPos      = begAddr;

    scanAlloc          = alloc;

    scanReset();
}

/*****************************************************************************
 *
 *  Scan from the specified string.
 */

void                scanner::scanString(const char        * sourceText,
                                        norls_allocator   * alloc)
{
    scanInputFile.inputStreamInit(scanComp, NULL, sourceText);

    scanTokLineNo      = 1;
//  scanTokColumn      = 1;
    scanAlloc          = alloc;

    scanTokRecord      = false;
    scanTokReplay      = NULL;

    scanReset();
}

/*****************************************************************************
 *
 *  Given the first character (which is known to be a character that can
 *  start an identifier), parse an identifier.
 */

tokens              scanner::scanIdentifier(int ch)
{
    unsigned        hashVal;
    unsigned        hashChv;

    bool            hadWide = false;

#if FV_DBCS
    BOOL            hasDBCS = FALSE;
#endif

    Ident           iden;

    char    *       savePtr = scannerBuff;

    /* Get the hash function started */

    hashFNstart(hashVal);

    /* Accumuluate the identifier string */

    for (;;)
    {
        assert(((charFlags[ch] & _CF_IDENT_OK) != 0) ==
               ((scanHashValIds[ch]          ) != 0));

        hashChv = scanHashValIds[ch];
        if  (!hashChv)
            break;

        hashFNaddCh(hashVal, hashChv);

        *savePtr++ = ch;

        if  (savePtr >= scannerBuff + sizeof(scannerBuff))
            goto ID_TOO_LONG;

        ch = readNextChar();
    }

    /* Put back the last character */

    undoNextChar();

    /* Make sure the identifier is not too long */

    if  (savePtr > scannerBuff + MAX_IDENT_LEN)
        goto ID_TOO_LONG;

    /* Make sure the name is null-terminated */

    *savePtr = 0;

    /* Finish computing the hash value */

    hashVal = hashFNvalue(hashVal);

CHK_MAC:

    /* Hash the identifier into the global/keyword table */

    iden = scanHashKwd->lookupName(scannerBuff,
                                   savePtr - scannerBuff,
                                   hashVal);

    if  (!iden)
        goto NOT_KWD2;

    /* Mark the identifier entry as referenced */

    hashTab::setIdentFlags(iden, IDF_USED);

    /* Check for a macro */

    if  ((hashTab::getIdentFlags(iden) & IDF_MACRO) && (!scanNoMacExp)
                                                    && (!scanStopAtEOL || scanInPPexpr))
    {
        const   char *  str;
        size_t          len;

        MacDef          mdef = scanFindMac(iden);

        if  (!mdef->mdIsId)
        {
            // UNDONE: Check type and all that

            scanTok.tok              = tkIntCon;
            scanTok.intCon.tokIntTyp = TYP_INT;
            scanTok.intCon.tokIntVal = mdef->mdDef.mdCons;

            return  tkIntCon;
        }

        /* Get the definition identifier */

        iden = mdef->mdDef.mdIden;

        if  (!iden)
        {
            if  (scanInPPexpr)
            {
                scanTok.tok              = tkIntCon;
                scanTok.intCon.tokIntTyp = TYP_INT;
                scanTok.intCon.tokIntVal = 0;

                return  tkIntCon;
            }
            else
            {
                return  tkNone;
            }
        }

        /* Copy the macro definition string */

        str = hashTab::identSpelling(iden);
        len = hashTab::identSpellLen(iden);

        strcpy(scannerBuff, str); savePtr = scannerBuff + len;

        /* Compute the hash value */

        hashVal = hashTab::hashComputeHashVal(str, len);

        /* Try hashing the name again */

        iden = scanHashKwd->lookupName(str, len, hashVal);
        if  (!mdef->mdBuiltin)
            goto CHK_MAC;

        /* This should definitely be a keyword (or other token) */

        assert(hashTab::tokenOfIdent(iden) != tkNone);
    }

    /* Is the identifier a keyword? */

    if  (hashTab::tokenOfIdent(iden) != tkNone)
    {
        scanTok.tok = hashTab::tokenOfIdent(iden);

        if  (scanTok.tok == tkLINE)
        {
            scanTok.tok              = tkIntCon;
            scanTok.intCon.tokIntTyp = TYP_UINT;
            scanTok.intCon.tokIntVal = scanGetTokenLno();

            return  (scanTok.tok = tkIntCon);
        }

        if  (scanTok.tok == tkFILE)
        {
            strcpy(scannerBuff, scanInputFile.inputSrcFileName());

            scanTok.strCon.tokStrVal  = scannerBuff;
            scanTok.strCon.tokStrLen  = strlen(scannerBuff);
            scanTok.strCon.tokStrType = 0;
            scanTok.strCon.tokStrWide = false;

            return  (scanTok.tok = tkStrCon);
        }
    }
    else
    {
        /* Not a keyword, hash into the source hash */

    NOT_KWD2:

        if  (scanInPPexpr)
        {
            scanTok.tok              = tkIntCon;
            scanTok.intCon.tokIntTyp = TYP_INT;
            scanTok.intCon.tokIntVal = 0;
        }
        else
        {
            scanTok.id.tokIdent = iden = scanHashSrc->hashName(scannerBuff,
                                                               hashVal,
                                                               savePtr - scannerBuff,
                                                               hadWide);

            /* Mark the identifier entry as referenced */

            hashTab::setIdentFlags(iden, IDF_USED);

            /* The token is an ordinary identifier */

            scanTok.tok = tkID;
        }
    }

    return scanTok.tok;

    /* We come here if the identifier turned out to be too long */

ID_TOO_LONG:

    scanComp->cmpError(ERRidTooLong);
    UNIMPL(!"swallow the rest of the long identifier");
    return tkNone;
}

/*****************************************************************************
 *
 *  Parses a numeric constant. The current character (passed in as 'ch')
 *  is either a decimal digit or '.' (which could start a floating point
 *  number).
 */

tokens              scanner::scanNumericConstant(int ch)
{
    bool            hadDot  = false;
    bool            hadExp  = false;
    bool            hadDigs = false;
    unsigned        numBase = 0;

    char *          numPtr  = scannerBuff;

    /* Assume that this will be an integer */

    scanTok.tok              = tkIntCon;
    scanTok.intCon.tokIntTyp = TYP_INT;

    /* First collect the number string, and then figure out its type */

    if  (ch == '0')
    {
        /* This is most likely an octal or hex integer */

        switch (peekNextChar())
        {
        case 'x':
        case 'X':
            numBase = 16;
            readNextChar();
            break;
        }
    }

    /* At this point, 'ch' is the next character */

    for (;;)
    {
        /* Save the character we just read, and make sure it's OK */

        *numPtr++ = ch;

        /* We're certainly done if the character is non-ASCII */

        if  (ch > 0xFF)
            goto ENDNUM;

        if  (charType(ch) == _C_DIG)
        {
            /* It's an ordinary digit */

            hadDigs = true;
            goto MORE;
        }

        if ((charFlags[ch] & _CF_HEXDIGIT) && numBase == 16)
        {
            /* A hex digit */

            hadDigs = true;
            goto MORE;
        }

        switch (ch)
        {
        case '.':
            if  (!hadDot && !hadExp && !numBase && peekNextChar() != '.')
            {
                hadDot = true;

                /* This will be a floating point number */

                scanTok.tok = tkDblCon;
                goto MORE;
            }
            break;

        case 'e':
        case 'E':
            if  (!hadExp && !numBase)
            {
                /* We have an exponent */

                hadExp = true;

                /* Check for '+' or '-' following the exponent */

                ch = readNextChar();
                if  (ch == '+' || ch == '-')
                    *numPtr++ = ch;
                else
                    undoNextChar();

                /* This will definitely be a floating point number */

                scanTok.tok = tkDblCon;
                goto MORE;
            }
            break;

        case 'f':
        case 'F':
            if  (!numBase)
            {
                /* This will be a 'float' constant */

                scanTok.tok = tkFltCon;

                /* Skip the character and stop */

                goto ENDN;
            }
            break;

        case 'd':
        case 'D':
            if  (!numBase)
            {
                /* This will be a 'double' constant */

                scanTok.tok = tkDblCon;

                /* Skip the character and stop */

                goto ENDN;
            }
            break;

        case 'l':
        case 'L':

            if  (scanTok.tok == tkIntCon)
            {
                /* This will be a 'long' integer */

                scanTok.intCon.tokIntTyp = TYP_LONG;

                /* Skip the character and stop */

                goto ENDN;  // UNDONE: check for "LU" suffix on numbers
            }
            break;

        case 'u':
        case 'U':

            /* This will be an unsigned integer */

            if  (scanTok.tok == tkIntCon)
            {
                scanTok.intCon.tokIntTyp = TYP_UINT;
            }
            else
            {
                scanTok.intCon.tokIntTyp = TYP_ULONG;
            }

            /* Check for 'l' and we're done with the constant */

            switch (peekNextChar())
            {
            case 'l':
            case 'L':
                scanTok.intCon.tokIntTyp = TYP_ULONG;
                readNextChar();
                break;
            }

            goto ENDN;
        }

    ENDNUM:

        /* This character can't be part of the number */

        undoNextChar();
        break;

    MORE:

        ch = readNextChar();
    }

ENDN:

    /* Null-terminate the number string */

    numPtr[-1] = 0;

    /* If there were no digits at all, it's hopeless */

    if  (!hadDigs)
        goto NUM_ERR;

    /* Does the number look like an integer? */

    if  (scanTok.tok == tkIntCon)
    {
        char    *       numPtr = scannerBuff;
        int             maxDig = '9';

        var_types       origTp = scanTok.intCon.tokIntTyp;

        __int64         value  = 0;
        __int64         maxMask;

        unsigned        numBasx;

        /* If the number starts with '0', it will be octal */

        if (*numPtr == '0' && !numBase)
            numBase = 8;

        /*
            The following table is indexed by the type and the number
            base (hex = 0, octal = 1), it's not used for decimal nums.
        */

        static
        __int64         maxMasks[][2] =
        {
            //-------------------------------------------------------------
            //                       HEX                  OCT
            //-------------------------------------------------------------
            /* TYP_INT     */  { 0xF8000000         , 0xD8000000          },
            /* TYP_UINT    */  { 0x70000000         , 0x50000000          },
            /* TYP_NATINT  */  { 0                  , 0                   },
            /* TYP_NATUINT */  { 0                  , 0                   },
            /* TYP_LONG    */  { 0xF800000000000000L, 0xD800000000000000L },
            /* TYP_ULONG   */  { 0x7000000000000000L, 0x5000000000000000L },
        };

        /* Convert the number and make sure it fits in an integer */

        numBasx = 0;

        if  (numBase == 0)
        {
            maxMask = 0;
        }
        else
        {
            if  (numBase == 8)
            {
                maxDig  = '7';
                numBasx = 1;
            }

            maxMask = maxMasks[origTp - TYP_INT][numBasx];
        }

        do
        {
            int     ch = *numPtr++;

            /* Check the number for overflow */

            if  (!numBase)
            {
                __int64             newVal;

                /* We have a decimal constant */

                assert(ch >= '0' && ch <= '9');

                newVal = 10 * value + (ch - '0');

                if  (newVal < 0)
                {
                    /* This is an implicitly unsigned long constant, right? */

                    scanTok.intCon.tokIntTyp = TYP_ULONG;
                }
                else
                {
                    if  ((newVal & 0xFFFFFFFF00000000L) && !numBase
                                                        && scanTok.intCon.tokIntTyp < TYP_LONG)
                    {
                        /* A signed 32-bit decimal constant turning 64-bit */

                        if  (scanTok.intCon.tokIntTyp == TYP_INT)
                             scanTok.intCon.tokIntTyp = TYP_LONG;
                        else
                             scanTok.intCon.tokIntTyp = TYP_ULONG;
                    }
                }

                if  (newVal & maxMask)
                    goto NUM_ERR;

                value = newVal;
            }
            else
            {
                /* We have an unsigned octal or hex number */

                while (value & maxMask)
                {
                    /* Can we implicitly switch to a larger type? */

                    switch (scanTok.intCon.tokIntTyp)
                    {
                    case TYP_INT:
                        scanTok.intCon.tokIntTyp = TYP_UINT;
                        break;

                    case TYP_UINT:
                        if  (origTp == TYP_INT)
                            scanTok.intCon.tokIntTyp = TYP_LONG;
                        else
                            scanTok.intCon.tokIntTyp = TYP_ULONG;
                        break;

                    case TYP_LONG:
                        scanTok.intCon.tokIntTyp = TYP_ULONG;
                        break;

                    case TYP_ULONG:
                        goto NUM_ERR;

                    default:
                        NO_WAY(!"what?");
                    }

                    maxMask = maxMasks[scanTok.intCon.tokIntTyp - TYP_INT][numBasx];
                }

                value *= numBase;

                if  (ch <= '9')
                {
                    if  (ch > maxDig)
                        goto NUM_ERR;

                    value |= ch - '0';
                }
                else
                {
                    value |= toupper(ch) - 'A' + 10;
                }
            }
        }
        while   (*numPtr);

        if  (scanTok.intCon.tokIntTyp >= TYP_LONG)
        {
            scanTok.tok              = tkLngCon;
            scanTok.lngCon.tokLngVal = value;
        }
        else
        {
            scanTok.intCon.tokIntVal = (__int32)value;
        }

        return scanTok.tok;
    }

    /* Convert the number (at this point we must have a floating point value) */

    if  (scanTok.tok == tkFltCon)
    {
        // UNDONE: check for illegal float number!

        scanTok.fltCon.tokFltVal = (float)atof(scannerBuff);

//      if  (negate)
//          scanTok.fltCon.tokFltVal = -scanTok.fltCon.tokFltVal;
    }
    else
    {
        assert(scanTok.tok == tkDblCon);

        // UNDONE: check for illegal float number!

        scanTok.dblCon.tokDblVal = atof(scannerBuff);

//      if  (negate)
//          scanTok.dblCon.tokDblVal = -scanTok.dblCon.tokDblVal;
    }

    return  scanTok.tok;

NUM_ERR:

    scanComp->cmpError(ERRbadNumber);

    scanTok.intCon.tokIntVal = 0;
    scanTok.intCon.tokIntTyp = TYP_UNDEF;

    return  scanTok.tok;
}

/*****************************************************************************
 *
 *  Process a '\' sequence (found within a string/character literal).
 */

unsigned            scanner::scanEscapeSeq(bool *newLnFlag)
{
    unsigned        ch = readNextChar();

    if  (newLnFlag) *newLnFlag = false;

    switch (ch)
    {
        unsigned        uc;
        unsigned        digCnt;
        bool            isHex;

    case 'b': ch = '\b'; break;
    case 'n': ch = '\n'; break;
    case 't': ch = '\t'; break;
    case 'r': ch = '\r'; break;
    case 'a': ch = '\a'; break;
    case 'f': ch = '\f'; break;

    case 'u':
        isHex = false;
        goto HEXCH;

    case 'x':

        isHex = true;

    HEXCH:

        for (ch = 0, digCnt = 4; digCnt; digCnt--)
        {
            unsigned    uc = readNextChar();

            if  (charType(uc) == _C_DIG)
            {
                /* It's an ordinary digit */

                uc -= '0';
            }
            else if (uc >= 'A' && uc <= 'F')
            {
                /* It's an uppercase hex digit */

                uc -= 'A' - 10;
            }
            else if (uc >= 'a' && uc <= 'f')
            {
                /* It's a  lowercase hex digit */

                uc -= 'a' - 10;
            }
            else
            {
                undoNextChar();
                break;
            }

            ch = (ch << 4) | uc;
        }

        /* For some reason hex/oct constant may not specify a character > 0xFF */

        if  (isHex && (ch & 0xFFFFFF00))
            scanComp->cmpError(ERRbadEscCh);

        break;

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':

        for (uc = ch, ch = 0;;)
        {
            if  (ch & 0xFF000000)
                scanComp->cmpError(ERRbadEscCh);

            ch = (ch << 3) | (uc - '0');

            uc = readNextChar();

            if  (uc < '0' || uc > '7')
            {
                undoNextChar();
                break;
            }
        }

        /* For some reason hex/oct constant may not specify a character > 0xFF */

        if  (ch & 0xFFFFFF00)
            scanComp->cmpError(ERRbadEscCh);

        break;

    case '\n':
    case '\r':
        if  (newLnFlag)
        {
            scanNewLine(ch);
            *newLnFlag = true;
            return 0;
        }
        break;

    case '"':
    case '\'':
    case '\\':
        break;

    default:
        scanComp->cmpGenWarn(WRNbadEsc, ch);
        break;
    }

    return ch;
}

/*****************************************************************************
 *
 *  Parses a character constant.
 */

tokens              scanner::scanCharConstant()
{
    unsigned        ch = readNextChar();

    switch  (charType(ch))
    {
    case _C_BSL:
        ch = scanEscapeSeq(NULL);
        break;

    case _C_NWL:
        undoNextChar();
        scanComp->cmpError(ERRbadCharCns);
        goto DONE;

#if FV_DBCS
    case _C_XLD:
        ch = readPrevDBch();
        break;
#endif

    }

    if  (wideCharType(readNextChar()) != _C_APO)
        scanComp->cmpError(ERRbadCharCns);

DONE:

    scanTok.tok              = tkIntCon;
    scanTok.intCon.tokIntTyp = scanComp->cmpConfig.ccOldStyle ? TYP_CHAR : TYP_WCHAR;
    scanTok.intCon.tokIntVal = ch;

    return  tkIntCon;
}

/*****************************************************************************
 *
 *  Parses a string constant.
 */

tokens              scanner::scanStrgConstant(int prefixChar)
{
    char    *       saveAdr = scannerBuff;
    char    *       savePtr = scannerBuff;
    char    *       saveMax = scannerBuff + sizeof(scannerBuff) - 7;
    bool            hasWide = false;

    /* Use the "big" buffer if we have one */

    if  (scanStrLitBuff)
    {
        saveAdr =
        savePtr = scanStrLitBuff;
        saveMax = scanStrLitBuff + scanStrLitBsiz - 7;
    }

    for (;;)
    {
        unsigned    ch = readNextChar();

        /* Check for an escape sequence, new-line, and end of string */

        switch  (charType(ch))
        {
        case _C_BSL:

            {
                bool        newLN;

                ch = scanEscapeSeq(&newLN);
                if  (newLN & 1)
                    continue;
            }

//          printf("Large char = %04X\n", ch);

            /* If the character value doesn't fit in a byte, prefix it */

            if  (ch >= 0xFF)
            {
                /* Write 0xFF followed by the character value */

                *(BYTE *)savePtr =            0xFF; savePtr++;
                *(BYTE *)savePtr = (BYTE)(ch     ); savePtr++;
                *(BYTE *)savePtr = (BYTE)(ch >> 8); savePtr++;

                /* Remember that we have some wide characters */

                hasWide = true;

                /* Make sure there wasn't a bad prefix */

                if  (prefixChar == 'A' && ch > 0xFF)
                    scanComp->cmpError(ERRbadEscCh);

                goto SAVED;
            }

            break;

        case _C_NWL:
            undoNextChar();
            scanComp->cmpError(ERRnoStrEnd);
            goto DONE;

        case _C_QUO:
            goto DONE;

#if FV_DBCS
        case _C_XLD:
            *savePtr++ = ch;
            *savePtr++ = readNextChar();
            goto SAVED;
#endif

        }

        *savePtr++ = ch;

    SAVED:

        /* Do we have enough room for the string in our buffer? */

        if  (savePtr >= saveMax)
        {
            size_t          curStrLen;
            size_t          newStrLen;

            char    *       newBuffer;

            /* The constant is *really* long - we'll have to grow the buffer */

            curStrLen = savePtr - saveAdr;

            /* Allocate a whole bunch more space */

            newStrLen = curStrLen * 2;
            if  (newStrLen < OS_page_size)
                 newStrLen = OS_page_size;

            newBuffer = (char *)LowLevelAlloc(newStrLen);
            if  (!newBuffer)
                scanComp->cmpFatal(ERRnoMemory);

            /* Copy the current string to the new place */

            memcpy(newBuffer, saveAdr, curStrLen);

            /* If the old buffer was heap-based, free it now */

            if  (scanStrLitBuff)
                LowLevelFree(scanStrLitBuff);

            /* Switch over to the new buffer */

            scanStrLitBuff = newBuffer;
            scanStrLitBsiz = newStrLen;

            saveAdr = scanStrLitBuff;
            savePtr = scanStrLitBuff + curStrLen;
            saveMax = scanStrLitBuff + scanStrLitBsiz - 7;
        }
    }

DONE:

    *savePtr = 0;

    scanTok.strCon.tokStrVal  = saveAdr;
    scanTok.strCon.tokStrLen  = savePtr - saveAdr;
    scanTok.strCon.tokStrType = 0;
    scanTok.strCon.tokStrWide = hasWide;

//  if  (scanTok.strCon.tokStrLen > 1000) printf("String = '%s'\n", scanTok.strCon.tokStrVal);

    if  (prefixChar)
    {
        switch (prefixChar)
        {
        case 'A': scanTok.strCon.tokStrType = 1; break;
        case 'L': scanTok.strCon.tokStrType = 2; break;
        case 'S': scanTok.strCon.tokStrType = 3; break;
        default: NO_WAY(!"funny string");
        }
    }

    return  (scanTok.tok = tkStrCon);
}

/*****************************************************************************
 *
 *  Skip until the next end-of-line sequence.
 */

void                scanner::scanSkipToEOL()
{
    for (;;)
    {
        switch (charType(readNextChar()))
        {
        case _C_NWL:
        case _C_EOF:
            undoNextChar();
            return;

        case _C_BSL:

            /* Check for a newline */

            switch  (readNextChar())
            {
            case '\r':
                if  (readNextChar() != '\n')
                    undoNextChar();
                break;

            case '\n':
                if  (readNextChar() != '\r')
                    undoNextChar();
                break;

            case '\\':
                continue;

            default:
                scanComp->cmpError(ERRillegalChar);
                continue;
            }

            /* Swallow the endline and continue */

            scanRecordNL(true);
            continue;
        }
    }
}

/*****************************************************************************
 *
 *  Consume an end-of-line sequence.
 */

prepDirs            scanner::scanNewLine(unsigned ch, bool noPrep)
{
    unsigned        nc;

    /* Accept both CR/LF and LF/CR as new-lines */

    nc = readNextChar();

    switch (nc)
    {
    case '\r':
        if  (ch == '\n')
            nc = readNextChar();
        break;

    case '\n':
        if  (ch == '\r')
            nc = readNextChar();
        break;

    case 0x1A:
        undoNextChar();
        return  PP_NONE;
    }

    /* Push back the first character after the newline */

    undoNextChar();

    /* Remember that we have a new source line */

    return  scanRecordNL(noPrep);
}

/*****************************************************************************
 *
 *  Consume a C++-style comment.
 */

void                scanner::scanSkipLineCmt()
{
    for (;;)
    {
        unsigned        ch = readNextChar();

        switch  (charType(ch))
        {
        case _C_EOF:
        case _C_NWL:
            undoNextChar();
            return;

        case _C_BSL:
            if  (peekNextChar() == 'u')
            {
                ch = scanEscapeSeq(NULL);
                if  (wideCharType(ch) == _C_NWL)
                    return;
            }
            break;
        }
    }
}

/*****************************************************************************
 *
 *  Consume a C-style comment.
 */

void                scanner::scanSkipComment()
{
    unsigned        ch;

    for (;;)
    {
        ch = readNextChar();

    AGAIN:

        switch (charType(ch))
        {
        case _C_MUL:
            if  (wideCharType(readNextChar()) == _C_SLH)
                return;
            undoNextChar();
            break;

        case _C_NWL:
            scanNewLine(ch, true);
            break;

        case _C_EOF:
            scanComp->cmpError(ERRnoCmtEnd);
            return;

        case _C_BSL:
            if  (peekNextChar() != 'u')
                break;
            ch = scanEscapeSeq(NULL);
            if  (ch <= 0xFF)
                goto AGAIN;
            break;

        case _C_AT:

            if  (!scanSkipToPP)
            {
                switch (readNextChar())
                {
                case 'c':

                    if  (readNextChar() == 'o' &&
                         readNextChar() == 'm' &&
                         readNextChar() == '.')
                    {
                        break;
                    }

                    continue;

                case 'd':

                    if  (readNextChar() == 'l' &&
                         readNextChar() == 'l' &&
                         readNextChar() == '.')
                    {
                        break;
                    }

                    continue;

                default:
                    undoNextChar();
                    continue;
                }

                scanComp->cmpGenWarn(WRNskipAtCm);
            }
            break;
        }
    }
}

/*****************************************************************************
 *
 *  Peek ahead at the next token (we can look ahead only one token).
 */

tokens              scanner::scanLookAhead()
{
    /* Only look ahead if we haven't already */

    if  (!scanLookAheadCount)
    {
        bool        simpleSave;
        Token       savedToken;
        unsigned    saveLineNo;
//      unsigned    saveColumn;

        /* First we save off the current token along with its position */

        savedToken = scanTok;
        simpleSave = false;
        saveLineNo = scanTokLineNo;
//      saveColumn = scanTokColumn;

        /* Record the save position in case the callers tries to back up */

        scanSaveSN = scanSaveNext;

        /* Get the next token, and save it */

        scan();

        scanLookAheadToken  = scanTok;
        scanLookAheadLineNo = scanTokLineNo;
//      scanLookAheadColumn = scanTokColumn;

        /* Remember that we have now looked ahead */

        scanLookAheadCount++;

        /* Now put the old token back */

        scanTok       = savedToken;
        scanTokLineNo = saveLineNo;
//      scanTokColumn = saveColumn;
    }

    return  scanLookAheadToken.tok;
}

/*****************************************************************************
 *
 *  The following is used for token lookahead.
 */

DEFMGMT class RecTokDsc
{
public:

    RecTok          rtNext;
    Token           rtTok;
};

/*****************************************************************************
 *
 *  Delivers a token stream.
 *
 *  Implementation note: for token lookahead and stream recording to work,
 *  there must be only one return point from this method, down at the "EXIT"
 *  label. That is, no return statements must be present (other than the one
 *  at the very end of the function) - to exit, jump to "EXIT" instead.
 */

#ifdef  DEBUG
static  unsigned    scanCount[tkLastValue];
static  unsigned    tokSaveSize;
#endif

tokens              scanner::scan()
{
    if  (scanLookAheadCount)
    {
        /* Return the looked ahead token */

        scanLookAheadCount--; assert(scanLookAheadCount == 0);

        scanTok       = scanLookAheadToken;
        scanTokLineNo = scanLookAheadLineNo;
//      scanTokColumn = scanLookAheadColumn;

        return  scanTok.tok;
    }

    if  (scanTokReplay)
    {
#if     DISP_TOKEN_STREAMS
        BYTE    *       start = scanTokReplay;
#endif

        scanTokSrcPos = scanTokReplay;

        scanTok.tok = (tokens)*scanTokReplay++;

        if  (scanTok.tok >= tkID)
        {
            scanTokReplay--;

            /* Read a complex/fake token */

            if  (scanReplayTok() == tkNone)
            {
                /* We just peeked ahead a bit, resume scanning */

                goto NO_SV;
            }
        }

#if     DISP_TOKEN_STREAMS
        printf("Read [%08X]:", start);
        scanDispCurToken(false, false);
#endif

        return  scanTok.tok;
    }

NO_SV:

    for (;;)
    {
        unsigned    ch;
#if FV_DBCS
        unsigned    nc;
#endif

        /* Save the starting position of the token for error reporting */

        saveSrcPos();

        /* Get the next character and switch on its type value */

        ch = readNextChar();

        switch  (charType(ch))
        {
        case _C_WSP:
            break;

        case _C_LET:
#if FV_DBCS
        case _C_DB1:
#endif
        case _C_USC:
        case _C_DOL:

        IDENT:

            if  (scanIdentifier(ch) == tkNone)
                continue;
            goto EXIT;

        case _C_L_A:

            /* Check for A"string" */

            if  (peekNextChar() != '"')
                goto IDENT;

            readNextChar();
            scanStrgConstant('A');
            goto EXIT;

        case _C_L_L:

            /* Check for L"string" */

            if  (peekNextChar() != '"')
                goto IDENT;

            readNextChar();
            scanStrgConstant('L');
            goto EXIT;

        case _C_L_S:

            /* Check for S"string" */

            if  (peekNextChar() != '"')
                goto IDENT;

            readNextChar();
            scanStrgConstant('S');
            goto EXIT;

        case _C_QUO:
            scanStrgConstant();
            goto EXIT;

        case _C_APO:
            scanCharConstant();
            goto EXIT;

        case _C_DOT:

            /* Is the next character a digit or another dot? */

            switch (wideCharType(peekNextChar()))
            {
            case _C_DIG:
                break;

            case _C_DOT:
                ch = readNextChar();
                if  (wideCharType(peekNextChar()) == _C_DOT)
                {
                    readNextChar();
                    scanTok.tok = tkEllipsis;
                    goto EXIT;
                }

                scanTok.tok = tkDot2;
                goto EXIT;

            default:
                scanTok.tok = tkDot;
                goto EXIT;
            }

            // Fall through ...

        case _C_DIG:
            scanNumericConstant(ch);
            goto EXIT;

        case _C_LPR: scanTok.tok = tkLParen; goto EXIT;
        case _C_RPR: scanTok.tok = tkRParen; goto EXIT;
        case _C_LC : scanTok.tok = tkLCurly; goto EXIT;
        case _C_RC : scanTok.tok = tkRCurly; goto EXIT;

#ifdef  SETS

        case _C_LBR:

            switch  (readNextChar())
            {
            case '[':
                scanTok.tok = tkLBrack2;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkLBrack;
                scanBrackLvl++;
                break;
            }
            goto EXIT;

        case _C_RBR:

            switch  (readNextChar())
            {
            case ']':
                if  (!scanBrackLvl)
                {
                    scanTok.tok = tkRBrack2;
                    break;
                }

                // Fall through ...

            default:

                undoNextChar();
                scanTok.tok = tkRBrack;

                if  (scanBrackLvl)
                    scanBrackLvl--;

                break;
            }
            goto EXIT;

#else

        case _C_LBR: scanTok.tok = tkLBrack; goto EXIT;
        case _C_RBR: scanTok.tok = tkRBrack; goto EXIT;

#endif

        case _C_CMA: scanTok.tok = tkComma ; goto EXIT;
        case _C_SMC: scanTok.tok = tkSColon; goto EXIT;
        case _C_TIL: scanTok.tok = tkTilde ; goto EXIT;
        case _C_QUE: scanTok.tok = tkQMark ; goto EXIT;

        case _C_COL:
            switch  (readNextChar())
            {
            case ':':
                scanTok.tok = tkColon2;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkColon;
                break;
            }
            goto EXIT;

        case _C_EQ:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkEQ;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkAsg;
                break;
            }
            goto EXIT;

        case _C_BNG:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkNE;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkBang;
                break;
            }
            goto EXIT;

        case _C_PLS:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkAsgAdd;
                break;
            case '+':
                scanTok.tok = tkInc;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkAdd;
                break;
            }
            goto EXIT;

        case _C_MIN:
            switch (readNextChar())
            {
            case '=':
                scanTok.tok = tkAsgSub;
                break;
            case '-':
                scanTok.tok = tkDec;
                break;
            case '>':
                scanTok.tok = tkArrow;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkSub;
                break;
            }
            goto EXIT;

        case _C_MUL:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkAsgMul;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkMul;
                break;
            }
            goto EXIT;

        case _C_SLH:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkAsgDiv;
                break;

            case '/':
                scanSkipLineCmt();
                continue;

            case '*':

                if  (!scanComp->cmpConfig.ccSkipATC)
                {
                    if  (peekNextChar() == '*')
                    {
                        readNextChar();

                        switch (readNextChar())
                        {
                        case '/':

                            /* This is just an empty comment */

                            continue;

                        case ' ':

                            if  (readNextChar() == '@')
                            {
                                if  (scanDoAtComment())
                                    goto EXIT;
                                else
                                    continue;
                            }

                            // UNDONE: Put those characters back!

                            break;

                        default:
                            break;
                        }
                    }
                }

                scanSkipComment();
                continue;

            default:
                undoNextChar();
                scanTok.tok = tkDiv;
                break;
            }
            goto EXIT;

        case _C_PCT:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkAsgMod;
                break;
            case '%':
                switch  (readNextChar())
                {
                case '=':
                    scanTok.tok = tkAsgCnc;
                    break;

                default:
                    undoNextChar();
                    scanTok.tok = tkConcat;
                    break;
                }
                break;
            default:
                undoNextChar();
                scanTok.tok = tkPct;
                break;
            }
            goto EXIT;

        case _C_LT:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkLE;
                break;

            case '<':
                switch  (readNextChar())
                {
                case '=':
                    scanTok.tok = tkAsgLsh;
                    break;
                default:
                    undoNextChar();
                    scanTok.tok = tkLsh;
                    break;
                }
                break;
            default:
                undoNextChar();
                scanTok.tok = tkLT;
                break;
            }
            goto EXIT;

        case _C_GT:

            if  (scanNestedGTcnt)
            {
                scanTok.tok = tkGT;
                break;
            }

            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkGE;
                break;

            case '>':
                switch  (readNextChar())
                {
                case '=':
                    scanTok.tok = tkAsgRsh;
                    break;


                default:
                    undoNextChar();
                    scanTok.tok = tkRsh;
                    break;
                }
                break;

            default:
                undoNextChar();
                scanTok.tok = tkGT;
                break;
            }
            goto EXIT;

        case _C_XOR:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkAsgXor;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkXor;
                break;
            }
            goto EXIT;

        case _C_BAR:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkAsgOr;
                break;
            case '|':
                scanTok.tok = tkLogOr;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkOr;
                break;
            }
            goto EXIT;

        case _C_AMP:
            switch  (readNextChar())
            {
            case '=':
                scanTok.tok = tkAsgAnd;
                break;
            case '&':
                scanTok.tok = tkLogAnd;
                break;
            default:
                undoNextChar();
                scanTok.tok = tkAnd;
                break;
            }
            goto EXIT;

        case _C_EOF:
            scanTok.tok = tkEOF;
            goto EXIT;

        case _C_NWL:
            if  (scanStopAtEOL)
            {
                scanStopAtEOL = false;
                undoNextChar();
                scanTok.tok = tkEOL;
                goto EXIT;
            }
            scanNewLine(ch);
            break;

        case _C_BSL:

            /* Check for a newline */

            switch  (readNextChar())
            {
            case '\r':
            case '\n':

                /* Swallow the endline and continue */

                scanRecordNL(true);
                continue;

            default:
                goto ERRCH;
            }

#if FV_DBCS

        case _C_XLD:

            /* Note: we allow wide chars only in idents, comments and strings */

            nc = peekPrevDBch(); assert(xislead(ch));

            if  (DBisIdentBeg(nc))
            {
                scanIdentifier(ch);
                goto EXIT;
            }

            // Fall through to report an error ...

#endif

        case _C_AT:
        case _C_ERR:

        ERRCH:

            scanComp->cmpError(ERRillegalChar);
            break;

        default:
            assert(!"missing case for a character kind");
        }
    }

EXIT:

    if  (!scanTokRecord || scanSkipToPP)
        return  scanTok.tok;

    /* Record any line# changes */

    if  (scanSaveLastLn != scanTokLineNo)
        scanSaveLinePos();

    /* Make sure we have room to record the token */

    if  (scanSaveNext >= scanSaveEndp)
        scanSaveMoreSp();

    /* Record the token */

#if DISP_TOKEN_STREAMS
    printf("Save [%08X]:", scanSaveNext);
    scanDispCurToken(false, false);
#endif

    *scanSaveNext++ = scanTok.tok;

#ifdef  DEBUG
    tokSaveSize++;
#endif

    switch (scanTok.tok)
    {
    case tkID:
        *(*(Ident     **)&scanSaveNext)++ = scanTok.id.tokIdent;
#ifdef  DEBUG
        tokSaveSize += 4;
#endif
        break;

    case tkAtComment:
        *(*(AtComment **)&scanSaveNext)++ = scanTok.atComm.tokAtcList;
#ifdef  DEBUG
        tokSaveSize += 4;
#endif
        break;

    case tkIntCon:

        if  (scanTok.intCon.tokIntTyp == TYP_INT &&
             (signed char)scanTok.intCon.tokIntVal == scanTok.intCon.tokIntVal)
        {
            if  (scanTok.intCon.tokIntVal >= -1 &&
                 scanTok.intCon.tokIntVal <=  2)
            {
                scanSaveNext[-1] = (BYTE)(tkIntConM + 1 + scanTok.intCon.tokIntVal);
#ifdef  DEBUG
                assert(tkIntConM + 1 + scanTok.intCon.tokIntVal < arraylen(scanCount)); scanCount[tkIntConM + 1 + scanTok.intCon.tokIntVal]++;
#endif
            }
           else
            {
                 scanSaveNext[-1] = tkIntConB;
                *scanSaveNext++   = (signed char)scanTok.intCon.tokIntVal;

#ifdef  DEBUG
                assert(tkIntConB < arraylen(scanCount)); scanCount[tkIntConB]++;
                tokSaveSize += 1;
#endif
            }

            return  scanTok.tok;
        }

        *(*(BYTE      **)&scanSaveNext)++ = scanTok.intCon.tokIntTyp;
        *(*(__int32   **)&scanSaveNext)++ = scanTok.intCon.tokIntVal;
#ifdef  DEBUG
        tokSaveSize += 5;
#endif
        break;

    case tkLngCon:
        *(*(BYTE      **)&scanSaveNext)++ = scanTok.lngCon.tokLngTyp;
        *(*(__int64   **)&scanSaveNext)++ = scanTok.lngCon.tokLngVal;
#ifdef  DEBUG
        tokSaveSize += 9;
#endif
        break;

    case tkFltCon:
        *(*(float     **)&scanSaveNext)++ = scanTok.fltCon.tokFltVal;
#ifdef  DEBUG
        tokSaveSize += 4;
#endif
        break;

    case tkDblCon:
        *(*(double    **)&scanSaveNext)++ = scanTok.dblCon.tokDblVal;
#ifdef  DEBUG
        tokSaveSize += 8;
#endif
        break;

    case tkStrCon:

        /* Make sure we have enough space for the token and its value */

        if  (scanSaveNext + scanTok.strCon.tokStrLen + 6 >= scanSaveEndp)
        {
            /* Unsave the token, grab more space, resave the token */

            scanSaveNext--;
            scanSaveMoreSp(scanTok.strCon.tokStrLen + 32);
           *scanSaveNext++ = scanTok.tok;
        }

        /* Save the string type and wideness */

        *scanSaveNext++ = scanTok.strCon.tokStrType + 8 * scanTok.strCon.tokStrWide;

        /* Append the string value itself */

        *(*(unsigned **)&scanSaveNext)++ = scanTok.strCon.tokStrLen;

        memcpy(scanSaveNext, scanTok.strCon.tokStrVal, scanTok.strCon.tokStrLen+1);
               scanSaveNext             +=             scanTok.strCon.tokStrLen+1;

#ifdef  DEBUG
        tokSaveSize += scanTok.strCon.tokStrLen+1+4;
#endif
        break;

    case tkEOL:

        /* No point in recording EOL tokens */

        assert(scanSaveNext[-1] == tkEOL); scanSaveNext--;
        break;
    }

#ifdef  DEBUG
    assert(scanTok.tok < arraylen(scanCount)); scanCount[scanTok.tok]++;
#endif

    return scanTok.tok;
}

#ifdef  DEBUG

#ifndef __SMC__
extern  const char *tokenNames[];
#endif

void                dispScannerStats()
{
    unsigned        i;

    for (i = 0; i < arraylen(scanCount) - 1; i++)
    {
        if  (scanCount[i])
        {
            unsigned        s = 1;
            char            b[16];
            const char  *   n;

            if  (i < tkCount)
            {
                n = tokenNames[i];
            }
            else
            {
                if      (i >= tkLnoAdd1 && i < tkLnoAddB)
                {
                    sprintf(b, "line add %u", i - tkLnoAdd1 + 1); n = b;
                }
                else if (i >= tkIntConM && i < tkIntConB)
                {
                    sprintf(b, "int const %d", i - tkIntConM - 1); n = b;
                }
                else
                {
                    switch (i)
                    {
                    case tkIntConB:
                        n = "small int";
                        break;

                    case tkBrkSeq:
                        n = "break seq";
                        break;

                    case tkEndSeq:
                        n = "end seq";
                        break;

                    case tkLnoAddB:
                        n = "line add char";
                        break;

                    case tkLnoAddI:
                        n = "line add int";
                        break;

                    default:
                        UNIMPL(!"unexpected token");
                    }
                }
            }

            printf("%6u count of '%s'\n", scanCount[i], n);
        }
    }

    printf("\nTotal saved token size = %u bytes \n", tokSaveSize); _flushall();
}

#endif

/*****************************************************************************
 *
 *  The line# has changed, make sure we record this.
 */

void                scanner::scanSaveLinePos()
{
    unsigned        dif;

    assert(scanSkipToPP == false);

    if  (scanTokRecord == false)
        return;
    if  (scanTokReplay != NULL)
        return;

    assert(scanTokSrcPos == scanSaveNext);

    /* Compute the difference from the last recorded line# */

    dif = scanTokLineNo - scanSaveLastLn; assert((int)dif > 0);

    /* Update the last recorded line# */

    scanSaveLastLn = scanTokLineNo;

    /* Make sure we have room to record the line# change */

    if  (scanSaveNext >= scanSaveEndp)
        scanSaveMoreSp();

#if DISP_TOKEN_STREAMS
    printf("Save [%08X]:line dif %u\n", scanSaveNext, dif);
#endif

    if  (dif < 10)
    {
        *scanSaveNext++ = tkLnoAdd1 - 1 + dif;
#ifdef  DEBUG
        scanCount[tkLnoAdd1 - 1 + dif]++;
        tokSaveSize += 1;
#endif
    }
    else if (dif < 256)
    {
        *(*(BYTE     **)&scanSaveNext)++ = tkLnoAddB;
        *(*(BYTE     **)&scanSaveNext)++ = dif;
#ifdef  DEBUG
        scanCount[tkLnoAddB]++;
        tokSaveSize += 2;
#endif
    }
    else
    {
        *(*(BYTE     **)&scanSaveNext)++ = tkLnoAddI;
        *(*(unsigned **)&scanSaveNext)++ = dif;
#ifdef  DEBUG
        scanCount[tkLnoAddI]++;
        tokSaveSize += 5;
#endif
    }

    scanTokSrcPos = scanSaveNext;
}

/*****************************************************************************
 *
 *  Define a macro; return NULL in case of an error, otherwise returns a macro
 *  descriptor.
 */

MacDef              scanner::scanDefMac(const char *name,
                                        const char *def, bool builtIn,
                                                         bool chkOnly)
{
#if MGDDATA
    MacDef          mdef = new MacDef;
#else
    MacDef          mdef = &scanDefDsc;
#endif

    Ident           mid;

    assert(name);
    assert(def);

    /* Hash the macro name into the main hash table */

    mdef->mdName = mid = scanHashKwd->hashString(name); assert(mid);

    /* Remember whether this is a "built-in" macro */

    mdef->mdBuiltin = builtIn;

    /* See if the value is an identifier or number */

    if  (*def && isdigit(*def))
    {
        unsigned        val = 0;

        do
        {
            if  (!isdigit(*def))
                return  NULL;

            val = val * 10 + *def - '0';
        }
        while (*++def);

        mdef->mdIsId       = false;
        mdef->mdDef.mdCons = val;
    }
    else
    {
        Ident           name = NULL;

        /* Is there an identifier? */

        if  (*def)
        {
            const   char *  ptr;

            /* Make sure the identifier is well-formed */

            if  (!isalpha(*def) && *def != '_' && !builtIn)
            {
                /* Last chance - non-identifier token */

                name = scanHashKwd->lookupString(def);
                if  (!name)
                    return  NULL;
            }
            else
            {

                ptr = def + 1;

                while (*ptr)
                {
                    if  (!isalnum(*ptr) && *ptr != '_' && !builtIn)
                        return  NULL;

                    ptr++;
                }

                /* Hash the identifier into the main hash table */

                name = scanHashKwd->hashString(def);

                /* Ignore endless recursion */

                if  (name == mid)
                    return  NULL;

                // UNDONE: Need to detect indirect recursion as well!!!!!!!
            }
        }

        /* Store the identifier in the macro descriptor */

        mdef->mdIsId       = true;
        mdef->mdDef.mdIden = name;
    }

    /* Is the name already defined as a macro? */

    if  (hashTab::getIdentFlags(mid) & IDF_MACRO)
    {
        MacDef          odef;

        /* See if the old definition is identical to the current one */

        odef = scanFindMac(mid); assert(odef);

        if  (odef->mdIsId)
        {
            if  (mdef->mdDef.mdIden == odef->mdDef.mdIden)
                return  odef;
        }
        else
        {
            if  (mdef->mdDef.mdCons == odef->mdDef.mdCons)
                return  odef;
        }

        /* Report a redefinition of the macro and bail */

        scanComp->cmpError(ERRmacRedef, mid);
        return  mdef;
    }
    else
    {
        /* Make sure the macro name hasn't been referenced */

        if  (hashTab::getIdentFlags(mid) & IDF_USED)
            scanComp->cmpError(ERRmacPlace, mid);

        /* Make sure we have a permanent copy of the descriptor */

#if!MGDDATA
        mdef = (MacDef)scanComp->cmpAllocPerm.nraAlloc(sizeof(*mdef)); *mdef = scanDefDsc;
#endif

        /* Add the macro to the list of defined macros */

        mdef->mdNext = scanMacros;
                       scanMacros = mdef;
    }

    /* Mark the identifier as having a macro definition */

    hashTab::setIdentFlags(mid, IDF_MACRO);

    return  mdef;
}

/*****************************************************************************
 *
 *  Undefine a macro; return non-zero in case of an error.
 */

bool                scanner::scanUndMac(const char *name)
{
    printf("UNDONE: Undef  macro '%s'\n", name);
    return  false;
}

/*****************************************************************************
 *
 *  Given a global hash table entry that is known to be a macro, return
 *  its macro definition record.
 */

MacDef              scanner::scanFindMac(Ident name)
{
    MacDef          mdef;

    for (mdef = scanMacros; mdef; mdef = mdef->mdNext)
    {
        if  (mdef->mdName == name)
            return  mdef;
    }

    return  mdef;
}

/*****************************************************************************
 *
 *  Return true if what follows is a defined macro name.
 */

bool                scanner::scanChkDefined()
{
    switch  (charType(peekNextChar()))
    {
        bool            save;
        Ident           iden;

    case _C_LET:
    case _C_L_A:
    case _C_L_L:
    case _C_L_S:
#if FV_DBCS
    case _C_DB1:
#endif
    case _C_USC:
    case _C_DOL:

        save = scanInPPexpr;
        assert(scanNoMacExp == false);

        scanNoMacExp = true;
        scanInPPexpr = false;
        scanIdentifier(readNextChar());
        scanNoMacExp = false;
        scanInPPexpr = save;

        iden = (scanTok.tok == tkID) ? scanTok.id.tokIdent
                                     : scanHashKwd->tokenToIdent(scanTok.tok);

        return  (hashTab::getIdentFlags(iden) & IDF_MACRO) != 0;

    default:
        scanComp->cmpError(ERRnoIdent);
        return  false;
    }
}

/*****************************************************************************
 *
 *  Return true if the given string denotes a defined macro name.
 */

bool                scanner::scanIsMacro(const char *name)
{
    Ident           iden = scanHashKwd->lookupString(name);

    if  (iden)
    {
        /* Mark the identifier entry as referenced */

        hashTab::setIdentFlags(iden, IDF_USED);

        /* Return true if the identifier is a macro */

        if  (hashTab::getIdentFlags(iden) & IDF_MACRO)
            return  true;
    }

    return  false;
}

/*****************************************************************************
 *
 *  Record the current state of the scanner so that we can restart where we
 *  are later (after doing some "nested" scanning).
 */

void                scanner::scanSuspend(OUT scannerState REF state)
{
    assert(scanLookAheadCount == 0);

    assert(scanStopAtEOL      == false);
    assert(scanInPPexpr       == false);
    assert(scanNoMacExp       == false);
    assert(scanSkipToPP       == false);

    state.scsvCompUnit    = scanCompUnit;
    state.scsvTok         = scanTok;
    state.scsvTokLineNo   = scanTokLineNo;
//  state.scsvTokColumn   = scanTokColumn;
    state.scsvTokSrcPos   = scanTokSrcPos;
    state.scsvTokReplay   = scanTokReplay;
    state.scsvTokRecord   = scanTokRecord;   scanTokRecord   = false;
    state.scsvNestedGTcnt = scanNestedGTcnt; scanNestedGTcnt = 0;
}

/*****************************************************************************
 *
 *  Restore the state of the scanner from an earlier suspend call.
 */

void                scanner::scanResume(IN scannerState REF state)
{
    scanCompUnit    = state.scsvCompUnit;
    scanTok         = state.scsvTok;
    scanTokLineNo   = state.scsvTokLineNo;
//  scanTokColumn   = state.scsvTokColumn;
    scanTokSrcPos   = state.scsvTokSrcPos;
    scanTokReplay   = state.scsvTokReplay;
    scanTokRecord   = state.scsvTokRecord;
    scanNestedGTcnt = state.scsvNestedGTcnt;
}

/*****************************************************************************
 *
 *  Mark the current spot in the token stream, we'll return to it later.
 */

scanPosTP           scanner::scanTokMarkPos(OUT Token    REF saveTok,
                                            OUT unsigned REF saveLno)
{
    saveTok = scanTok;
    saveLno = scanTokLineNo;

    return  scanTokReplay ? scanTokReplay
                          : scanSaveNext;
}

scanPosTP           scanner::scanTokMarkPLA(OUT Token    REF saveTok,
                                            OUT unsigned REF saveLno)
{
    saveTok = scanTok;
    saveLno = scanTokLineNo;

    assert(scanTokReplay == NULL);

    return  scanSaveSN;
}

/*****************************************************************************
 *
 *  Rewind back to a previously marked position in the token stream.
 */

void                scanner::scanTokRewind(scanPosTP pos, unsigned lineNum,
                                                          Token  * pushTok)
{
    /* Are we currently recording? */

    if  (scanSaveNext)
        *scanSaveNext  = tkEndSeq;

    /* Start reading at the desired input position */

    scanTokReplay      = (BYTE *)pos;

    /* Reset the current line # */

    scanTokLineNo      = lineNum;

    /* Clear any lookaheads, just in case */

    scanLookAheadCount = 0;

    /* Make sure we get started out right */

    if  (pushTok)
        scanTok = *pushTok;
    else
        scan();
}

/*****************************************************************************
 *
 *  Make room for more recorded tokens.
 */

void                scanner::scanSaveMoreSp(size_t need)
{
    BYTE    *       nextBuff;

    /* Figure out how much more space we should grab */

    if  (need < scanSaveBuffSize)
         need = scanSaveBuffSize;

    /* Need to get some more space */

    nextBuff = (BYTE *)LowLevelAlloc(need);

    /* Are we finishing a section? */

    if  (scanSaveNext)
    {
        /* Link from end of old section to the new one */

        *(*(BYTE  **)&scanSaveNext)++ = tkBrkSeq;
        *(*(BYTE ***)&scanSaveNext)++ = nextBuff;
    }

//  static unsigned totSiz; totSiz += scanSaveBuffSize; printf("Alloc token buffer: total size = %u\n", totSiz);

    /* Switch to the new buffer */

    scanSaveBase =
    scanSaveNext = nextBuff;
    scanSaveEndp = nextBuff + need - 16;
}

/*****************************************************************************
 *
 *  Replay the next recorded token.
 */

tokens              scanner::scanReplayTok()
{
    tokens          tok;

    for (;;)
    {
        /* Get hold of the next saved token */

        scanTok.tok = tok = (tokens)*scanTokReplay++;

        /* We're done if it's a "simple" token */

        if  (tok < tkID)
            return  tok;

        /* See if any special handling is required for this token */

        switch (tok)
        {
            unsigned        strTmp;
            size_t          strLen;
            char    *       strAdr;

        case tkID:
            scanTok.id.tokIdent = *(*(Ident **)&scanTokReplay)++;
            return  tok;

        case tkLnoAdd1:
        case tkLnoAdd2:
        case tkLnoAdd3:
        case tkLnoAdd4:
        case tkLnoAdd5:
        case tkLnoAdd6:
        case tkLnoAdd7:
        case tkLnoAdd8:
        case tkLnoAdd9:
#if DISP_TOKEN_STREAMS
//          printf("Read [%08X]:line dif %u\n", scanTokReplay-1, tok - tkLnoAdd1 + 1);
#endif
            scanTokLineNo += (tok - tkLnoAdd1 + 1);
            scanSaveLastLn = scanTokLineNo;
            break;

        case tkLnoAddB:
#if DISP_TOKEN_STREAMS
//          printf("Read [%08X]:line dif %u\n", scanTokReplay-1, *(BYTE    *)scanTokReplay);
#endif
            scanTokLineNo += *(*(BYTE     **)&scanTokReplay)++;
            scanSaveLastLn = scanTokLineNo;
            break;

        case tkLnoAddI:
#if DISP_TOKEN_STREAMS
//          printf("Read [%08X]:line dif %u\n", scanTokReplay-1, *(unsigned*)scanTokReplay);
#endif
            scanTokLineNo += *(*(unsigned **)&scanTokReplay)++;
            scanSaveLastLn = scanTokLineNo;
            break;

        case tkIntConM:
        case tkIntCon0:
        case tkIntCon1:
        case tkIntCon2:
            scanTok.tok               = tkIntCon;
            scanTok.intCon.tokIntTyp  = TYP_INT;
            scanTok.intCon.tokIntVal  = tok - tkIntConM - 1;
            return  tkIntCon;

        case tkIntConB:
            scanTok.tok               = tkIntCon;
            scanTok.intCon.tokIntTyp  = TYP_INT;
            scanTok.intCon.tokIntVal  = *(*(signed char **)&scanTokReplay)++;
            return  tkIntCon;

        case tkIntCon:
            scanTok.intCon.tokIntTyp  = (var_types)*(*(BYTE **)&scanTokReplay)++;
            scanTok.intCon.tokIntVal  = *(*(__int32   **)&scanTokReplay)++;
            return  tok;

        case tkLngCon:
            scanTok.lngCon.tokLngTyp  = (var_types)*(*(BYTE **)&scanTokReplay)++;;
            scanTok.lngCon.tokLngVal  = *(*(__int64   **)&scanTokReplay)++;;
            return  tok;

        case tkFltCon:
            scanTok.fltCon.tokFltVal  = *(*(float     **)&scanTokReplay)++;;
            return  tok;

        case tkDblCon:
            scanTok.dblCon.tokDblVal  = *(*(double    **)&scanTokReplay)++;;
            return  tok;

        case tkStrCon:

            strTmp = *scanTokReplay++;

            scanTok.strCon.tokStrType = strTmp & 7;
            scanTok.strCon.tokStrWide = strTmp / 8;

            strLen = scanTok.strCon.tokStrLen = *(*(size_t **)&scanTokReplay)++;

            /* Does the string fit in our convenient buffer? */

            if  (strLen < sizeof(scannerBuff) - 1)
            {
                strAdr = scannerBuff;
            }
            else
            {
                assert(scanStrLitBuff);
                assert(scanStrLitBsiz > strLen);

                strAdr = scanStrLitBuff;
            }

            memcpy(strAdr, scanTokReplay,   strLen+1);
                           scanTokReplay += strLen+1;

            scanTok.strCon.tokStrVal  = strAdr;

//          if  (scanTok.strCon.tokStrLen > 1000) printf("String = '%s'\n", scanTok.strCon.tokStrVal);

            return  tok;

        case tkBrkSeq:
            scanTokReplay = *(BYTE**)scanTokReplay;
            break;

        case tkEndSeq:
            scanTokReplay = NULL;
            return  tkNone;

        case tkEOF:
            return  tok;

        case tkAtComment:
            scanTok.atComm.tokAtcList = *(*(AtComment **)&scanTokReplay)++;;
            return  tok;

        case tkPragma:
            switch (*scanTokReplay++)
            {
            case 0:
                scanComp->cmpConfig.ccWarning[*scanTokReplay++] = 0;
                break;

            case 1:
                scanComp->cmpConfig.ccWarning[*scanTokReplay++] = 1;
                break;

            default:
                NO_WAY(!"unexpected pragma");
            }
            continue;

        default:
            UNIMPL(!"unexpected token");
        }
    }
}

/*****************************************************************************
 *
 *  Change the current token into a qualified name token.
 */

void                scanner::scanSetQualID(QualName qual, SymDef sym,
                                                          SymDef scp)
{
    scanTok.tok                = tkQUALID;
    scanTok.qualid.tokQualName = qual;
    scanTok.qualid.tokQualSym  = sym;
    scanTok.qualid.tokQualScp  = scp;
}

/*****************************************************************************
 *
 *  Set the entries for all interesting characters to 1 in this table.
 */

static  BYTE        scanSkipFlags[256];

void                scanner::scanSkipInit()
{
    scanSkipFlags['(' ] = 1;
    scanSkipFlags[')' ] = 1;
    scanSkipFlags['[' ] = 1;
    scanSkipFlags[']' ] = 1;
    scanSkipFlags['{' ] = 1;
    scanSkipFlags['}' ] = 1;
    scanSkipFlags[';' ] = 1;
    scanSkipFlags[',' ] = 1;

    scanSkipFlags['\r'] = 1;
    scanSkipFlags['\n'] = 1;
    scanSkipFlags[0x1A] = 1;

    scanSkipFlags['/' ] = 1;
    scanSkipFlags['\''] = 1;
    scanSkipFlags['"' ] = 1;
}

/*****************************************************************************
 *
 *  Skip over a block of text bracketed by the given delimiters.
 */

void                scanner::scanSkipText(tokens LT, tokens RT, tokens ET)
{
    unsigned        delimLevel = 0;
    unsigned        braceLevel = 0;

    assert(scanTok.tok == LT || LT == tkNone || LT == tkLParen);

    assert(LT == tkNone || LT == tkLCurly || LT == tkLBrack || LT == tkLParen || LT == tkLT);
    assert(RT == tkNone || RT == tkRCurly || RT == tkRBrack || RT == tkRParen || RT == tkGT);
    assert(ET == tkNone || ET == tkRCurly || ET == tkLCurly || ET == tkComma);

    for (;;)
    {
        if      (scanTok.tok == LT)
        {
            delimLevel++;
            if  (scanTok.tok == tkLCurly)
                braceLevel++;
            goto NEXT;
        }
        else if (scanTok.tok == RT)
        {
            delimLevel--;
            if  (scanTok.tok == tkRCurly)
                braceLevel--;

            if  (delimLevel == 0)
            {
                if  (RT != tkRParen || ET != tkComma)
                    goto EXIT;
            }

            goto NEXT;
        }
        else if (scanTok.tok == ET)
        {
            if  (delimLevel == 0 && braceLevel == 0)
                goto EXIT;
        }

        switch (scanTok.tok)
        {
        case tkLCurly:
            braceLevel++;
            break;

        case tkRCurly:
            if  (braceLevel == 0)
                goto EXIT;

            braceLevel--;
            break;

        case tkSColon:
            if  (!delimLevel || LT != tkLCurly)
                goto EXIT;
            break;

#ifdef  SETS

        case tkALL:
        case tkSORT:
        case tkSORTBY:
        case tkEXISTS:
        case tkFILTER:
        case tkUNIQUE:
        case tkPROJECT:
        case tkLBrack2:

            /*
                Wwe need to know how many filter/sort
                state classes we need to pre-allocate so that we don't run
                afoul of metadata emission ordering requirements).
             */

            scanComp->cmpSetOpCnt++;
            break;

#endif

        case tkEOF:
            goto EXIT;
        }

    NEXT:

        scan();
    }

EXIT:

    return;
}

/*****************************************************************************
 *
 *  A little helper to collect an identifier (used when processing directives
 *  and other things that aren't "truly" part of the source text). On success
 *  returns true.
 */

bool                scanner::scanCollectId(bool dotOK)
{
    unsigned        ch;
    char    *       temp;

SKIP:

    switch  (charType(peekNextChar()))
    {
    case _C_LET:
    case _C_L_A:
    case _C_L_L:
    case _C_L_S:
    case _C_USC:
    case _C_DOL:
        break;

    case _C_WSP:
        readNextChar();
        goto SKIP;

    default:
        return  false;
    }

    temp = scannerBuff;
    for (;;)
    {
        ch = readNextChar();

        switch  (charType(ch))
        {
        case _C_DOT:
            if  (!dotOK)
                break;

            // Fall through ....

        case _C_LET:
        case _C_L_A:
        case _C_L_L:
        case _C_L_S:
        case _C_DIG:
        case _C_USC:
        case _C_DOL:
            if  (temp < scannerBuff + sizeof(scannerBuff) - 1)
                *temp++ = ch;
            continue;
        }
        break;
    }

    *temp = 0;

    undoNextChar();

    return  true;
}

/*****************************************************************************
 *
 *  A little helper to consume and convert a decimal number (this is used for
 *  processing directives and other things that aren't "truly" part of the
 *  source text). On success returns the value, otherwise returns -1.
 */

int                 scanner::scanCollectNum()
{
    unsigned        ch;

    int             sign = 1;
    bool            hex  = false;
    unsigned        val  = 0;

    scanSkipWsp(readNextChar()); undoNextChar();

    switch (charType(peekNextChar()))
    {
    case _C_DIG:
        break;

    case _C_MIN:
        sign = -1;
        readNextChar();
        if  (charType(peekNextChar()) == _C_DIG)
            break;

    default:
        return  -1;
    }

    if  (peekNextChar() == '0')
    {
        readNextChar();

        switch (peekNextChar())
        {
        case 'x':
        case 'X':
            readNextChar();
            hex = true;
            break;
        }
    }

    for (;;)
    {
        ch = readNextChar();

        switch (charType(ch))
        {
        case _C_DIG:
            val = val * (hex ? 16 : 10) + (ch - '0');
            continue;

        default:

            if (hex)
            {
                unsigned        add;

                if      (ch >= 'a' && ch <= 'f')
                    add = 10 + (ch - 'a');
                else if (ch >= 'A' && ch <= 'F')
                    add = 10 + (ch - 'A');
                else
                    break;

                val = val * 16 + add;
                continue;
            }

            break;
        }

        break;
    }

    undoNextChar();
    return  val * sign;
}

/*****************************************************************************
 *
 *  Skip any whitespace, including newlines.
 */

unsigned            scanner::scanSkipWsp(unsigned ch, bool stopAtEOL)
{
    for (;;)
    {
        switch (charType(ch))
        {
        case _C_NWL:
            if  (stopAtEOL)
                return  ch;
            scanNewLine(ch);
            break;

        case _C_WSP:
            break;

        default:
            return  ch;
        }

        ch = readNextChar();
    }
}

/*****************************************************************************
 *
 *  The following is used to map types in @structmap directives.
 */

struct  COMtypeMapDsc
{
    const   char *  ctmName;
    CorNativeType   ctmType;
};

static
COMtypeMapDsc       COMtypeMap[] =
{
    { "BOOLEAN"     , NATIVE_TYPE_BOOLEAN    },
    { "TCHAR"       , NATIVE_TYPE_SYSCHAR    },
    { "I1"          , NATIVE_TYPE_I1         },
    { "U1"          , NATIVE_TYPE_U1         },
    { "I2"          , NATIVE_TYPE_I2         },
    { "U2"          , NATIVE_TYPE_U2         },
    { "I4"          , NATIVE_TYPE_I4         },
    { "U4"          , NATIVE_TYPE_U4         },
    { "I8"          , NATIVE_TYPE_I8         },
    { "U8"          , NATIVE_TYPE_U8         },
    { "R4"          , NATIVE_TYPE_R4         },
    { "R8"          , NATIVE_TYPE_R8         },

    { "PTR"         , NATIVE_TYPE_PTR        },
    { "DATE"        , NATIVE_TYPE_DATE       },
    { "STRING"      , NATIVE_TYPE_BSTR       },
    { "STRUCT"      , NATIVE_TYPE_STRUCT     },     // ????
    { "OBJECT"      , NATIVE_TYPE_OBJECTREF  },
    { "VARIANT"     , NATIVE_TYPE_VARIANT    },
    { "DISPATCH"    , NATIVE_TYPE_IDISPATCH  },
    { "CURRENCY"    , NATIVE_TYPE_CURRENCY   },
    { "SAFEARRAY"   , NATIVE_TYPE_SAFEARRAY  },
    { "ARRAY"       , NATIVE_TYPE_FIXEDARRAY },

    { "CUSTOM"      , NATIVE_TYPE_MAX        },     // ????
    { "CUSTOMBYREF" , NATIVE_TYPE_VOID       },     // ????
    { "BSTR"        , NATIVE_TYPE_BSTR       },
    { "LPSTR"       , NATIVE_TYPE_LPSTR      },
    { "LPWSTR"      , NATIVE_TYPE_LPWSTR     },
    { "LPTSTR"      , NATIVE_TYPE_LPTSTR     },
    { "STRUCT"      , NATIVE_TYPE_STRUCT     },
    { "INTF"        , NATIVE_TYPE_INTF       },
    { "VARIANTBOOL" , NATIVE_TYPE_VARIANTBOOL},
    { "FUNC"        , NATIVE_TYPE_FUNC       },
    { "ASANY"       , NATIVE_TYPE_ASANY      },
    { "LPARRAY"     , NATIVE_TYPE_ARRAY      },   //ugh - "ARRAY" already used
    { "LPSTRUCT"    , NATIVE_TYPE_LPSTRUCT   },
};

bool                scanner::scanNativeType(CorNativeType *typePtr,
                                            size_t        *sizePtr)
{
    CorNativeType   type;
    unsigned        size;

    if  (!scanCollectId())
        return  true;

    if      (!strcmp(scannerBuff, "FIXEDARRAY"))
    {
        if  (readNextChar() != ',')
            return  true;
        scanSkipWsp(readNextChar()); undoNextChar();
        if  (!scanCollectId() || strcmp(scannerBuff, "size"))
            return  true;
        if  (scanSkipWsp(readNextChar()) != '=')
            return  true;
        type = NATIVE_TYPE_FIXEDARRAY;
        size = scanCollectNum();
        if  ((int)size == -1)
            return  true;
    }
    else
    {
        COMtypeMapDsc * typePtr;
        unsigned        typeNum;

        for (typeNum = 0, typePtr = COMtypeMap;
             typeNum < arraylen(COMtypeMap);
             typeNum++  , typePtr++)
        {
            if  (!strcmp(scannerBuff, typePtr->ctmName))
            {
                type = typePtr->ctmType;
                goto GOT_STP;
            }
        }

        printf("ERROR: unrecognized @dll.structmap type '%s'\n", scannerBuff);
        forceDebugBreak();
        return  true;

GOT_STP:

        if  (peekNextChar() == '[')
        {
            readNextChar();
            size = scanCollectNum();
            if  ((int)size == -1)
                return  true;
            if  (readNextChar() != ']')
                return  true;

            switch (type)
            {
            case NATIVE_TYPE_SYSCHAR:
                type = NATIVE_TYPE_FIXEDSYSSTRING;
                break;

            default:
//              assert(!"unexpected fixed array type in @dll/@com directive");
                break;
            }
        }
        else
            size = 0;
    }

    if  (type != NATIVE_TYPE_MAX || *typePtr == NATIVE_TYPE_END)
        *typePtr = type;

    *sizePtr = size;

    return  false;
}

ConstStr            scanner::scanCollectGUID()
{
    char    *       dest = scannerBuff;

    /* Save everything up to the next "," or ")" in a buffer */

    for (;;)
    {
        unsigned        ch = readNextChar();

        switch (ch)
        {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':

        case 'a':
        case 'A':
        case 'b':
        case 'B':
        case 'c':
        case 'C':
        case 'd':
        case 'D':
        case 'e':
        case 'E':
        case 'f':
        case 'F':

        case '-':

            if  (dest >= scannerBuff + sizeof(scannerBuff))
                return  NULL;

            *dest++ = ch;
            continue;

        case ',':
        case ')':
            undoNextChar();
            break;

        default:
            return  NULL;
        }
        break;
    }

    *dest = 0;

    /* Save the GUID string */

    return  scanComp->cmpSaveStringCns(scannerBuff, dest - scannerBuff);
}

/*****************************************************************************
 *
 *  We've encountered "/** @", process whatever follows. If we find a correct
 *  recognized comment directive we set the current token to tkAtComment, in
 *  case of an error (such as an unrecognized directive) we set it to tkNone.
 */

#ifdef  __SMC__
void                ATCerror(){}
#else
#define             ATCerror() forceDebugBreak()
#endif

bool                scanner::scanDoAtComment()
{
    unsigned        ch;

    bool            isCom;
    char            name[16];
    char *          temp;

    AtComment       atcList = NULL;
    AtComment       atcLast = NULL;

    unsigned        saveTokLineNo = scanTokLineNo;
//  unsigned        saveTokColumn = scanTokColumn;
    scanPosTP       saveTokSrcPos = scanTokSrcPos;

#ifdef  DEBUG
    char *          begAddr;
    bool            ignored;
#endif

    for (;;)
    {
        atCommDsc       atcDesc;
        AtComment       atcThis;

        bool            skipRest;

        const   char *  atcName;

    AGAIN:

#ifdef  DEBUG
        begAddr = (char *)scanInputFile.inputBuffNext - 1;
        ignored = false;
#endif

        /* The first thing we expect is a simple identifier */

        if  (!scanCollectId())
        {

        ERR_RET:

            // UNDONE: Free up any allocated memory

            scanSkipComment();
            scanTok.tok = tkNone;
            return  false;
        }

        /* Get the directive name (and save it in case we issue diagnostics later) */

        if  (strlen(scannerBuff) >= arraylen(name))
        {
        WRN1:

            saveSrcPos();
            scanComp->cmpGenWarn(WRNbadAtCm, scannerBuff);

            goto ERR_RET;
        }

        strcpy(name, scannerBuff);

        /* Look for a recognizable directive */

        skipRest = false;

        if      (!strcmp(name, "deprecated"))
        {
            atcDesc.atcFlavor = AC_DEPRECATED;

//          scanComp->cmpGenWarn(WRNobsolete, "@deprecated");

            /* There is often garbage after this directive */

            skipRest = true;
            goto NEXT;
        }
        else if (!strcmp(name, "conditional"))
        {
            goto CONDITIONAL;
        }
        else if (!strcmp(name, "dll"))
        {
            isCom = false;
        }
        else if (!strcmp(name, "com"))
        {
            isCom = true;
        }
        else if (!strcmp(name, "param")  ||
                 !strcmp(name, "return") ||
                 !strcmp(name, "exception"))
        {
            skipRest = true;
            goto SKIP;
        }
        else
            goto WRN1;

        /* Here we expect too see a subdirective, i.e. ".subdir" */

        if  (readNextChar() != '.')
        {
        ERR1:

            saveSrcPos();
//          scanComp->cmpGenWarn(WRNbadAtCm, name);
            scanComp->cmpGenError(ERRbadAtCmForm, name);

            goto ERR_RET;
        }

        if  (!scanCollectId())
            { ATCerror(); goto ERR1; }

        /* Now check the directive/subdirective combination */

        temp = scannerBuff;

        if  (isCom)
        {
            if  (!strcmp(temp, "class"     )) goto AT_COM_CLASS;
            if  (!strcmp(temp, "interface" )) goto AT_COM_INTERF;
            if  (!strcmp(temp, "method"    )) goto AT_COM_METHOD;
            if  (!strcmp(temp, "parameters")) goto AT_COM_PARAMS;
            if  (!strcmp(temp, "register"  )) goto AT_COM_REGSTR;
            if  (!strcmp(temp, "struct"    )) goto AT_DLL_STRUCT;
            if  (!strcmp(temp, "structmap" )) goto AT_DLL_STRMAP;
        }
        else
        {
            if  (!strcmp(temp, "import"    )) goto AT_DLL_IMPORT;
            if  (!strcmp(temp, "struct"    )) goto AT_DLL_STRUCT;
            if  (!strcmp(temp, "structmap" )) goto AT_DLL_STRMAP;
        }

        scanComp->cmpGenError(ERRbadAtCmSubd, name, temp);
        goto ERR_RET;

    AT_DLL_IMPORT:
    {
        Linkage         linkInfo;

        char    *       DLLname = NULL;
        char    *       SYMname = NULL;

        unsigned        strings = 0;

        bool            lasterr = false;

        /* We should have a set of things within "()" here */

        if  (readNextChar() != '(')
            { ATCerror(); goto ERR1; }

        for (;;)
        {
            switch  (charType(scanSkipWsp(readNextChar())))
            {
            case _C_QUO:

                /* Presumably we have a DLL name */

                scanStrgConstant();

                /* Save a permanent copy of the string */

                DLLname = (char*)scanComp->cmpAllocPerm.nraAlloc(roundUp(scanTok.strCon.tokStrLen+1));
                memcpy(DLLname, scanTok.strCon.tokStrVal,
                                scanTok.strCon.tokStrLen+1);

                break;

            default:

                /* This better be one of the identifier things */

                undoNextChar();

                if  (!scanCollectId())
                    { ATCerror(); goto ERR1; }

                if      (!strcmp(scannerBuff, "auto"))
                {
                    if  (strings)
                        { ATCerror(); goto ERR1; }
                    strings = 1;
                }
                else if (!strcmp(scannerBuff, "ansi"))
                {
                    if  (strings)
                        { ATCerror(); goto ERR1; }
                    strings = 2;
                }
                else if (!strcmp(scannerBuff, "unicode"))
                {
                    if  (strings)
                        { ATCerror(); goto ERR1; }
                    strings = 3;
                }
                else if (!strcmp(scannerBuff, "ole"))
                {
                    if  (strings)
                        { ATCerror(); goto ERR1; }
                    strings = 4;
                }
                else if (!strcmp(scannerBuff, "setLastError"))
                {
                    if  (lasterr)
                        { ATCerror(); goto ERR1; }
                    lasterr = true;
                }
                else if (!strcmp(scannerBuff, "entrypoint"))
                {
                    if  (SYMname)
                        { ATCerror(); goto ERR1; }

                    ch = scanSkipWsp(readNextChar());
                    if  (ch != '=')
                        { ATCerror(); goto ERR1; }

                    ch = scanSkipWsp(readNextChar());
                    if  (ch != '"')
                        { ATCerror(); goto ERR1; }

                    scanStrgConstant();

                    /* Save a permanent copy of the string */

                    SYMname = (char*)scanComp->cmpAllocPerm.nraAlloc(roundUp(scanTok.strCon.tokStrLen+1));
                    memcpy(SYMname, scanTok.strCon.tokStrVal,
                                    scanTok.strCon.tokStrLen+1);

                    break;
                }
                else
                    { ATCerror(); goto ERR1; }

                break;
            }

            switch  (scanSkipWsp(readNextChar()))
            {
            case ')':
                goto DONE_IMP;

            case ',':
                break;

            default:
                { ATCerror(); goto ERR1; }
            }
        }

    DONE_IMP:

        /* Allocate a linkage descriptor and fill it in */

        linkInfo  = (Linkage)scanComp->cmpAllocPerm.nraAlloc(sizeof(*linkInfo));

        linkInfo->ldDLLname = DLLname;
        linkInfo->ldSYMname = SYMname;

        linkInfo->ldStrings = strings;
        linkInfo->ldLastErr = lasterr;

        /* Store the info in the current descriptor */

        atcDesc.atcFlavor          = AC_DLL_IMPORT;
        atcDesc.atcInfo.atcImpLink = linkInfo;
        }
        goto NEXT;

    AT_COM_METHOD:

        /* Format: @com.method(vtoffset=13, addFlagsVtable=4) */

        {
            int             temp;
            int             offs = -1;
            int             disp = -1;

            if  (readNextChar() != '(')
                { ATCerror(); goto ERR1; }

            if  (peekNextChar() == ')')
            {
                readNextChar();
                offs = disp = 0;
                goto DONE_METH;
            }

            for (;;)
            {
                if  (!scanCollectId())
                    { ATCerror(); goto ERR1; }
                if  (readNextChar() != '=')
                    { ATCerror(); goto ERR1; }

                if  (!_stricmp(scannerBuff, "type"))
                {
                    if  (!scanCollectId())
                        { ATCerror(); goto ERR1; }

                    if      (!_stricmp(scannerBuff, "method"))
                    {
                    }
                    else if (!_stricmp(scannerBuff, "PROPPUT"))
                    {
                    }
                    else if (!_stricmp(scannerBuff, "PROPPUTREF"))
                    {
                    }
                    else if (!_stricmp(scannerBuff, "PROPGET"))
                    {
                    }
                    else
                        { ATCerror(); goto ERR1; }

                    goto NXT_METH;
                }

                if  (!_stricmp(scannerBuff, "name"))
                {
                    if  (readNextChar() != '"')
                        { ATCerror(); goto ERR1; }
                    if  (!scanCollectId())
                        { ATCerror(); goto ERR1; }
                    if  (readNextChar() != '"')
                        { ATCerror(); goto ERR1; }

//                  scanComp->cmpGenWarn(WRNignAtCm, "method/name");
                    goto NXT_METH;
                }

                if  (!_stricmp(scannerBuff, "name2"))
                {
                    if  (readNextChar() != '"')
                        { ATCerror(); goto ERR1; }
                    if  (!scanCollectId())
                        { ATCerror(); goto ERR1; }
                    if  (readNextChar() != '"')
                        { ATCerror(); goto ERR1; }

//                  scanComp->cmpGenWarn(WRNignAtCm, "method/name2");
                    goto NXT_METH;
                }

                if  (!strcmp(scannerBuff, "returntype"))
                {
                    if  (!scanCollectId(true))
                        { ATCerror(); goto ERR1; }

                    goto NXT_METH;
                }

                temp = scanCollectNum();
                if  (temp == -1)
                    { ATCerror(); goto ERR1; }

                if      (!_stricmp(scannerBuff, "vtoffset"))
                {
                    offs = temp;
                }
                else if (!_stricmp(scannerBuff, "addflagsvtable"))
                {
                    if  (temp != 4)
                        { ATCerror(); goto ERR1; }
                }
                else if (!_stricmp(scannerBuff, "dispid"))
                {
                    disp = temp;
                }
                else
                    { ATCerror(); goto ERR1; }

            NXT_METH:

                ch = readNextChar();
                if  (ch != ',')
                    break;
            }

            if  (ch != ')')
                { ATCerror(); goto ERR1; }

        DONE_METH:

            atcDesc.atcFlavor                   = AC_COM_METHOD;
            atcDesc.atcInfo.atcMethod.atcVToffs = offs;
            atcDesc.atcInfo.atcMethod.atcDispid = disp;
        }
        goto NEXT;

    AT_COM_PARAMS:

        /* Format: @com.parameters([out] arg, [vt=9,type=SAFEARRAY] return) */

        if  (readNextChar() != '(')
            { ATCerror(); goto ERR1; }

        atcDesc.atcFlavor         = AC_COM_PARAMS;
        atcDesc.atcInfo.atcParams = NULL;

        if  (peekNextChar() != ')')
        {
            MethArgInfo         list = NULL;
            MethArgInfo         last = NULL;
            MethArgInfo         desc;

            do
            {
                Ident           name;

                unsigned        vt      = 0;
                CorNativeType   type    = NATIVE_TYPE_END;
                bool            marsh   = false;
                unsigned        size    = 0;

                bool            modeIn  = false;
                bool            modeOut = false;

                if  (scanSkipWsp(readNextChar()) != '[')
                    { ATCerror(); goto ERR1; }

                do
                {
                    if  (!scanCollectId())
                        { ATCerror(); goto ERR1; }

                    if      (!_stricmp(scannerBuff, "in"))
                    {
                        modeIn  = true;
                    }
                    else if (!_stricmp(scannerBuff, "out"))
                    {
                        modeOut = true;
                    }
                    else if (!_stricmp(scannerBuff, "byref"))
                    {
                        modeIn  = true;
                        modeOut = true;
                    }
                    else if (!_stricmp(scannerBuff, "vt"))
                    {
                        if  (readNextChar() != '=')
                            { ATCerror(); goto ERR1; }
                        vt = scanCollectNum();
                        if  ((int)vt == -1)
                            { ATCerror(); goto ERR1; }
                    }
                    else if (!_stricmp(scannerBuff, "type"))
                    {
                        size_t          temp;

                        if  (readNextChar() != '=')
                            { ATCerror(); goto ERR1; }

                        if  (marsh)
                        {
                            if  (!scanCollectId())
                                { ATCerror(); goto ERR1; }

                            if      (!_stricmp(scannerBuff, "custom"))
                            {
                            }
                            else if (!_stricmp(scannerBuff, "custombyref"))
                            {
                            }
                            else
                                { ATCerror(); goto ERR1; }
                        }
                        else
                        {
                            if  (scanNativeType(&type, &temp))
                                { ATCerror(); goto ERR1; }
                            if  (temp)
                                size = temp;
                        }
                    }
                    else if (!_stricmp(scannerBuff, "size"))
                    {
                        if  (readNextChar() != '=')
                            { ATCerror(); goto ERR1; }
                        size = scanCollectNum();
                        if  ((int)size == -1)
                            { ATCerror(); goto ERR1; }
                    }
                    else if (!_stricmp(scannerBuff, "iid"))
                    {
                        if  (readNextChar() != '=')
                            { ATCerror(); goto ERR1; }
                        if  (!scanCollectGUID())
                            { ATCerror(); goto ERR1; }

//                      scanComp->cmpGenWarn(WRNignAtCm, "params/iid");
                    }
                    else if (!strcmp(scannerBuff, "thread"))
                    {
                        if  (readNextChar() != '=')
                            { ATCerror(); goto ERR1; }
                        if  (!scanCollectId())
                            { ATCerror(); goto ERR1; }
                        if  (_stricmp(scannerBuff, "auto"))
                            { ATCerror(); goto ERR1; }
                    }
                    else if (!strcmp(scannerBuff, "customMarshal"))
                    {
                        if  (readNextChar() != '=')
                            { ATCerror(); goto ERR1; }
                        if  (readNextChar() != '"')
                            { ATCerror(); goto ERR1; }
                        if  (!scanCollectId(true))
                            { ATCerror(); goto ERR1; }

                        if      (!_stricmp(scannerBuff, "com.ms.com.AnsiStringMarshaller"))
                        {
                            type = NATIVE_TYPE_LPSTR;
                        }
                        else if (!_stricmp(scannerBuff, "com.ms.com.UniStringMarshaller"))
                        {
                            type = NATIVE_TYPE_LPWSTR;
                        }
                        else if (!_stricmp(scannerBuff, "com.ms.dll.StringMarshaler"))
                        {
                            type = NATIVE_TYPE_LPTSTR;
                        }
                        else if (!_stricmp(scannerBuff, "UniStringMarshaller"))
                        {
                            type = NATIVE_TYPE_LPTSTR;
                        }
                        else
                        {
                            { ATCerror(); goto ERR1; }
                        }

                        if  (readNextChar() != '"')
                            { ATCerror(); goto ERR1; }

//                      marsh = true;
                    }
                    else if (!strcmp(scannerBuff, "elementType"))
                    {
                        if  (readNextChar() != '=')
                            { ATCerror(); goto ERR1; }
                        if  (!scanCollectId(true))
                            { ATCerror(); goto ERR1; }
                    }
                    else
                        { ATCerror(); goto ERR1; }

                    ch = readNextChar();
                }
                while (ch == ',');

                if  (ch != ']')
                    { ATCerror(); goto ERR1; }
                if  (!scanCollectId())
                {
                    switch (scanSkipWsp(readNextChar()))
                    {
                    case ',':
                    case ')':
                        break;

                    default:
                        { ATCerror(); goto ERR1; }
                    }
                    undoNextChar();
                    name = NULL;
                }
                else
                {
                    name = scanHashKwd->lookupString(scannerBuff);
                    if  (!name)
                        name = scanHashSrc->hashString(scannerBuff);
                }

                desc = (MethArgInfo)scanComp->cmpAllocPerm.nraAlloc(sizeof(*desc));

                desc->methArgDesc.marshType    = type;
                desc->methArgDesc.marshSubTp   = 0;
                desc->methArgDesc.marshSize    = size;

                desc->methArgDesc.marshModeIn  = modeIn;
                desc->methArgDesc.marshModeOut = modeOut;

                desc->methArgName              = name;
                desc->methArgNext              = NULL;

                if  (last)
                    last->methArgNext = desc;
                else
                    list              = desc;

                last = desc;
            }
            while (readNextChar() == ',');

            undoNextChar();

            atcDesc.atcInfo.atcParams = list;
        }

        if  (readNextChar() != ')')
            { ATCerror(); goto ERR1; }

        goto NEXT;

    AT_COM_INTERF:

        /* Format: @com.interface(iid=AFBF15E5-C37C-11d2-B88E-00A0C9B471B8, thread=AUTO, type=DUAL) */

        atcDesc.atcFlavor = AC_COM_INTF;
        atcName = "iid";
        goto GET_GUID;

    AT_COM_REGSTR:

        /* Format: @com.register(clsid=8a664d00-7450-11d2-b99c-0080c7e8daa5) */

        atcDesc.atcFlavor = AC_COM_REGISTER;
        atcName = "clsid";

    GET_GUID:

        if  (readNextChar() != '(')
            { ATCerror(); goto ERR1; }

        atcDesc.atcInfo.atcReg.atcGUID = NULL;
        atcDesc.atcInfo.atcReg.atcDual = false;

        for (;;)
        {
            /* Look for the next "name=value" pair */

            if  (!scanCollectId())
                { ATCerror(); goto ERR1; }
            if  (readNextChar() != '=')
                { ATCerror(); goto ERR1; }

            if  (!_stricmp(scannerBuff, atcName))
            {
                if  (atcDesc.atcInfo.atcReg.atcGUID)
                    { ATCerror(); goto ERR1; }
                atcDesc.atcInfo.atcReg.atcGUID = scanCollectGUID();
                if  (!atcDesc.atcInfo.atcReg.atcGUID)
                    { ATCerror(); goto ERR1; }
            }
            else
            {
                /* Only @com.interface is allowed to have other args */

                if  (atcDesc.atcFlavor != AC_COM_INTF)
                    { ATCerror(); goto ERR1; }

                if      (!_stricmp(scannerBuff, "thread"))
                {
                    if  (!scanCollectId())
                        { ATCerror(); goto ERR1; }
                    if  (_stricmp(scannerBuff, "auto") && _stricmp(scannerBuff, "no"))
                        { ATCerror(); goto ERR1; }
                }
                else if (!_stricmp(scannerBuff, "type"))
                {
                    if  (!scanCollectId())
                        { ATCerror(); goto ERR1; }
                    if  (!_stricmp(scannerBuff, "dual"))
                        atcDesc.atcInfo.atcReg.atcDual = true;
                }
                else
                    { ATCerror(); goto ERR1; }
            }

            ch = readNextChar();
            if  (ch != ',')
                break;
        }

        if  (ch != ')')
            { ATCerror(); goto ERR1; }

        goto NEXT;

    AT_DLL_STRUCT:
        {
            unsigned        strings = 0;
            unsigned        pack    = 0;

            if  (readNextChar() != '(')
                { ATCerror(); goto ERR1; }

            if  (readNextChar() != ')')
            {
                undoNextChar();

                for (;;)
                {
                    if  (!scanCollectId())
                        { ATCerror(); goto ERR1; }

                    if      (!strcmp(scannerBuff, "pack"))
                    {
                        if  (readNextChar() != '=')
                            { ATCerror(); goto ERR1; }
                        pack = scanCollectNum();
                        if  ((int)pack == -1)
                            { ATCerror(); goto ERR1; }
                    }
                    else if (!_stricmp(scannerBuff, "ansi"))
                    {
                        strings = 2;
                    }
                    else if (!_stricmp(scannerBuff, "unicode"))
                    {
                        strings = 3;
                    }
                    else if (!_stricmp(scannerBuff, "auto"))
                    {
                        strings = 4;
                    }
                    else if (!_stricmp(scannerBuff, "ole"))
                    {
                        strings = 5;
                    }
                    else if (!_stricmp(scannerBuff, "noAutoOffset"))
                    {
                    }
                    else
                        { ATCerror(); goto ERR1; }

                    switch (scanSkipWsp(readNextChar()))
                    {
                    case ')':
                        break;
                    case ',':
                        continue;
                    default:
                        { ATCerror(); goto ERR1; }
                    }

                    break;
                }
            }

            atcDesc.atcFlavor                    = AC_DLL_STRUCT;
            atcDesc.atcInfo.atcStruct.atcStrings = strings;
            atcDesc.atcInfo.atcStruct.atcPack    = pack;
        }
        goto NEXT;

    AT_DLL_STRMAP:
        {
            CorNativeType   type;
            size_t          size;
            MarshalInfo     desc;
            unsigned        offs;

            if  (readNextChar() != '(')
                { ATCerror(); goto ERR1; }
            if  (readNextChar() != '[')
                { ATCerror(); goto ERR1; }

            for (;;)
            {
                if  (!scanCollectId())
                    { ATCerror(); goto ERR1; }

                if  (!strcmp(scannerBuff, "offset"))
                {
                    if  (readNextChar() != '=')
                        { ATCerror(); goto ERR1; }
                    offs = scanCollectNum();
                    if  ((int)offs == -1)
                        { ATCerror(); goto ERR1; }

//                  scanComp->cmpGenWarn(WRNignAtCm, "structmap/offset");
                    goto NXT_MAP;
                }

                if  (!strcmp(scannerBuff, "thread"))
                {
                    if  (readNextChar() != '=')
                        { ATCerror(); goto ERR1; }
                    if  (!scanCollectId())
                        { ATCerror(); goto ERR1; }
                    if  (_stricmp(scannerBuff, "auto"))
                        { ATCerror(); goto ERR1; }

//                  scanComp->cmpGenWarn(WRNignAtCm, "structmap/thread");
                    goto NXT_MAP;
                }

                if  (!strcmp(scannerBuff, "iid"))
                {
                    if  (readNextChar() != '=')
                        { ATCerror(); goto ERR1; }

//                  scanComp->cmpGenWarn(WRNignAtCm, "structmap/iid");

                    for (;;)
                    {
                        switch (readNextChar())
                        {
                        case ']':
                        case ',':
                            undoNextChar();
                            goto NXT_MAP;
                        }
                    }
                }

                if  (!strcmp(scannerBuff, "customMarshal"))
                {
                    if  (readNextChar() != '=')
                        { ATCerror(); goto ERR1; }
                    if  (readNextChar() != '"')
                        { ATCerror(); goto ERR1; }
                    if  (!scanCollectId(true))
                        { ATCerror(); goto ERR1; }
                    if  (readNextChar() != '"')
                        { ATCerror(); goto ERR1; }

//                  scanComp->cmpGenWarn(WRNignAtCm, "structmap/customMarshall");
                    goto NXT_MAP;
                }

                if  (!strcmp(scannerBuff, "type"))
                {
                    if  (scanSkipWsp(readNextChar()) != '=')
                        { ATCerror(); goto ERR1; }
                    if  (scanNativeType(&type, &size))
                        { ATCerror(); goto ERR1; }
                }

            NXT_MAP:

                if  (readNextChar() != ',')
                    break;
            }

            undoNextChar();

            if  (readNextChar() != ']')
                { ATCerror(); goto ERR1; }

            ch = scanSkipWsp(readNextChar());
            if  (ch != ')')
            {
                undoNextChar();
                if  (!scanCollectId())
                    { ATCerror(); goto ERR1; }
                if  (scanSkipWsp(readNextChar()) != ')')
                    { ATCerror(); goto ERR1; }
            }

            desc = (MarshalInfo)scanComp->cmpAllocPerm.nraAlloc(sizeof(*desc));
            desc->marshType  = type;
            desc->marshSubTp = 0;
            desc->marshSize  = size;

            atcDesc.atcFlavor          = AC_DLL_STRUCTMAP;
            atcDesc.atcInfo.atcMarshal = desc;
        }
        goto NEXT;

    CONDITIONAL:
        {
            if  (scanSkipWsp(readNextChar()) != '(')
                { ATCerror(); goto ERR1; }
            if  (!scanCollectId())
                { ATCerror(); goto ERR1; }
            if  (scanSkipWsp(readNextChar()) != ')')
                { ATCerror(); goto ERR1; }

            atcDesc.atcFlavor          = AC_CONDITIONAL;
            atcDesc.atcInfo.atcCondYes = scanIsMacro(scannerBuff);
        }
        goto NEXT;

    AT_COM_CLASS:

        atcDesc.atcFlavor = AC_COM_CLASS;

//  SKIPIT:

        skipRest = true;
#ifdef  DEBUG
        ignored  = true;
#endif

    NEXT:

        atcDesc.atcNext = NULL;

        /* Allocate and append a record to the list */

        atcThis = (AtComment)scanComp->cmpAllocPerm.nraAlloc(sizeof(*atcThis));
       *atcThis = atcDesc;

        if  (atcList)
            atcLast->atcNext = atcThis;
        else
            atcList          = atcThis;

        atcLast = atcThis;

    SKIP:

        /* Find the end of the comment or the next directive */

        for (;;)
        {
            switch  (charType(scanSkipWsp(readNextChar())))
            {
            case _C_AT:

                goto AGAIN;

            case _C_MUL:

                /* Check for end of comment */

                if  (charType(readNextChar()) != _C_SLH)
                    break;

#ifdef  DEBUG
                if  (ignored)
                {
                    size_t          strLen = (char*)scanInputFile.inputBuffNext - begAddr;
                    char            strBuff[128];

                    if  (strLen >= arraylen(strBuff) - 1)
                         strLen  = arraylen(strBuff) - 1;

                    memcpy(strBuff, begAddr, strLen); strBuff[strLen]  = 0;

                    for (;;)
                    {
                        char    *       crPos = strchr(strBuff, '\r');
                        char    *       lfPos = strchr(strBuff, '\n');

                        if      (crPos)
                        {
                            *crPos = 0;
                            if  (lfPos)
                                *lfPos = 0;
                        }
                        else if (lfPos)
                        {
                            *lfPos = 0;
                        }
                        else
                            break;
                    }

                    scanComp->cmpGenWarn(WRNignAtCm, strBuff);
                }
#endif

                goto DONE;

            default:

                if  (!skipRest)
                    { ATCerror(); goto ERR1; }

                break;
            }
        }
    }

DONE:

    scanTok.tok               = tkAtComment;
    scanTok.atComm.tokAtcList = atcList;

    /* Restore the initial position for the whole deal */

    scanTokLineNo = saveTokLineNo;
//  scanTokColumn = saveTokColumn;
    scanTokSrcPos = saveTokSrcPos;

    return  true;
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\smc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include <sys/types.h>
#include <sys/stat.h>

#include "comp.h"

/*****************************************************************************/
#ifdef  ASYNCH_INPUT_READ

#define MAX_SIMULTANEOUS_ASYNC_IOS  3       // NT limit (is this really true?)

#define DISP_ASYNC_PROGRESS         0       // set to "1" to see the following:

//  RDIRRRDDDDPEPEPREPERRDDDPEPEPERRDDPEPERRDDPEPERRDDPEPRERRDDDPEPE
//  PERRDDPEPERRDDPEPERRDDPEPERRDDPRDRDEPREPEPERRDDDPEPREPRERDDDPEPE
//  PRERRDDDPEPREPRERDDDPEPREPERRDDDPEPREPERRDDDPEPEPEC

#endif
/*****************************************************************************/

#ifndef __SMC__
extern  "C"
const   char *      COMPILER_VERSION;
#endif

/*****************************************************************************/

#ifdef  __IL__
#ifdef  _MSC_VER

#undef  isspace
#define isspace IsSpace

inline
int     isspace(int c)
{
    return  (c == ' ') || (c == '\t');
}

#endif
#endif

/*****************************************************************************/

const   char *      SMCregKey = "Software\\Microsoft\\SMC";

/*****************************************************************************/

static
char                  firstFileName[_MAX_PATH];

static
char                outfileNameBuff[_MAX_PATH];

/*****************************************************************************/

static
bool                startedCompiling;

/*****************************************************************************/

static
StrList             addToStrList(const char *str, StrList  list,
                                                  StrList *lastPtr);

static
bool                processDLLbaseFile(const char *fname, Compiler comp);

/*****************************************************************************
 *
 *  Display the help screen with short descriptions of command-line options.
 */

void                dispHelpScreen(Compiler comp, const char *optStr = NULL)
{
    if  (optStr)
        printf("ERROR: Invalid compiler option '%s'\n\n", optStr);

    printf("Usage: SMC [options] source-filename-list\n");
    printf("\n");


    printf("  -q                quiet mode\n");
    printf("\n");
    printf("  -d                create a DLL (default is EXE)\n");
    printf("  -b<base>          set the image base (value in decimal for now)\n");
    printf("  -b@filename,key   set the image base/size from the given file\n");
    printf("  -CG{IID}          set the GUID attribute of the PE file\n");
    printf("  -CM<name>         name of entry point class\n");
    printf("  -CN<name>         set the name attribute of the PE file\n");
    printf("  -CR<name>         add .RES file to the image\n");
    printf("  -CS               ignore '@' COM interop comments\n");
    printf("  -O<filename>      set the name of the output file name\n");
    printf("  -R                recurse into subdirs for source files\n");
    printf("  -Wc             * set subsystem to character mode\n");
    printf("  -Wg               set subsystem to GUI\n");
    printf("  -s[filename]    * specify MSCORLIB.DLL location (default: MSCORLIB.DLL in path)\n");
    printf("  -m[filename]      import additional metadata from the given EXE/DLL\n");
    printf("  -p[pathlist]      search additional path(s) for metadata\n");
    printf("  -z              * import and emit assembly goo\n");
    printf("  -zm<name>         add module   to assembly manifest\n");
    printf("  -zr<file>         add resource to assembly manifest\n");
    printf("  -zt               exclude types from manifest (use for mscorlib.dll)\n");
    printf("  -zn               mark assembly as non-CLS compliant\n");
#ifdef  ASYNCH_INPUT_READ
    printf("  -i                overlapped (asynch) file input\n");
#endif
    printf("\n");
    printf("  -w                 enable all warnings\n");
    printf("  -w-               disable all warnings\n");
    printf("  -w####             enable one warning\n");
    printf("  -w-####           disable one warning\n");
    printf("  -wx               treat warnings as errors\n");
    printf("  -e<count>         set max. number of errors\n");
    printf("\n");
    printf("  -N                use new-style metadata names\n");
    printf("\n");
    printf("  -Zi               generate full debug info (implies -Zn)\n");
    printf("  -Zl               generate only line# info\n");
    printf("  -Zn               include parameter names in metadata\n");
    printf("\n");
    printf("  -A                enable asserts\n");
    printf("  -AS               enable asserts with source info\n");
    printf("\n");
    printf("  -Dname[=value]    define a macro\n");
    printf("\n");
    printf("  -a<size>          set default struct alignment (1,2,4,8 or 16)\n");
    printf("  -c                default to C-style declarations\n");
    printf("  -SA               string constants default to 'char *'\n");
    printf("  -SM               string constants default to 'managed'\n");
    printf("  -SU               string constants default to 'wchar *'\n");
    printf("  -S                typesafe mode\n");
    printf("  -P                pedantic mode\n");
    printf("  -U              * flag uninitialized local variable use\n");
    printf("  -X                pick class for ambiguous lookups in multiple usings\n");
    printf("  -r                relation operators compare string values\n");
    printf("  -6                64-bit target\n");
    printf("  -E                map enums to ints\n");
#ifdef  DEBUG
    printf("\n");
    printf(" Debug build switches (for debugging of the compiler):\n");
    printf("  -v[level]         verbose mode\n");
    printf("  -g                display generated IL code\n");
    printf("  -gd               display generated IL code (detailed)\n");
    printf("  -R                display RVA's of methods\n");
#endif
    printf("\n");
    printf("NOTE: Following a toggle flag with '-' turns it\n");
    printf("off, options marked '*' are enabled by default.\n");
    printf("\n");
    printf("The list of source file names may contain wildcards\n");
    printf("as well as response files (of the form '@file.lst');\n");
    printf("note that only new-style command-line options will be\n");
    printf("recognized within response files.\n");
    printf("\n");
}

const
char    *           saveOptionString(const char *str)
{
    char    *       save = (char *)malloc(strlen(str)+1);
    strcpy(save, str);
    return  save;
}

/*****************************************************************************
 *
 *  Process a command-line option. Returns true if there is a problem.
 */

bool                processOption(const char *optStr, Compiler comp)
{
    bool       *    flagPtr;
    const char *    cmdPtr;

    cmdPtr = optStr + 2;


    switch  (cmdPtr[-1])
    {
        int             temp;
        unsigned        val;

    case '6':
        flagPtr = &comp->cmpConfig.ccTgt64bit;
        goto TOGGLE_FLAG;

    case 'A':
        switch (*cmdPtr)
        {
        case '-':
            comp->cmpConfig.ccAsserts = 0;
            break;

        case 0:
            comp->cmpConfig.ccAsserts = 1;
            break;

        case 'S':
            comp->cmpConfig.ccAsserts = 2;
            break;

        default:
            return  true;
        }
        break;

    case 'a':
        temp = atoi(cmdPtr);
        switch (temp)
        {
        case 1:
        case 2:
        case 4:
        case 8:
        case 16:
            comp->cmpConfig.ccAlignVal = temp;
            break;

        default:
            return  true;
        }

    case 'b':

        if  (*cmdPtr == '@')
            return  processDLLbaseFile(cmdPtr+1, comp);

        comp->cmpConfig.ccOutBase = atoi(cmdPtr);
        break;

    case 'c':
        flagPtr = &comp->cmpConfig.ccOldStyle;
        goto TOGGLE_FLAG;

    case 'E':
        flagPtr = &comp->cmpConfig.ccIntEnums;
        goto TOGGLE_FLAG;

    case 'C':
        switch (*cmdPtr++)
        {
        case 'G':
            if  (parseGUID(cmdPtr, &comp->cmpConfig.ccOutGUID, true))
                return  true;
            break;

        case 'M':
            comp->cmpConfig.ccMainCls = saveOptionString(cmdPtr);
            break;

        case 'N':
            comp->cmpConfig.ccOutName = saveOptionString(cmdPtr);
            break;

        case 'R':
            comp->cmpConfig.ccRCfile  = saveOptionString(cmdPtr);
            break;

        case 'S':
            flagPtr = &comp->cmpConfig.ccSkipATC;
            goto TOGGLE_FLAG;

        default:
            return  true;
        }
        break;

    case 'd':
        flagPtr = &comp->cmpConfig.ccOutDLL;
        goto TOGGLE_FLAG;

    case 'W':
        switch (*cmdPtr++)
        {
        case 'c':
            comp->cmpConfig.ccSubsystem = IMAGE_SUBSYSTEM_WINDOWS_CUI;
            break;

        case 'g':
            comp->cmpConfig.ccSubsystem = IMAGE_SUBSYSTEM_WINDOWS_GUI;
            break;

        default:
            return  true;
        }
        break;

    case 'D':
        comp->cmpConfig.ccMacList = addToStrList(cmdPtr, comp->cmpConfig.ccMacList, &comp->cmpConfig.ccMacLast);
        break;

    case 'e':
        comp->cmpConfig.ccMaxErrs = atoi(cmdPtr);
        break;

    case 'i':
#ifdef  ASYNCH_INPUT_READ
        flagPtr = &comp->cmpConfig.ccAsynchIO;
        goto TOGGLE_FLAG;
#else
        break;
#endif


    case 'm':
        comp->cmpConfig.ccSuckList = addToStrList(cmdPtr, comp->cmpConfig.ccSuckList, &comp->cmpConfig.ccSuckLast);
        break;

    case 'N':
        flagPtr = &comp->cmpConfig.ccNewMDnames;
        goto TOGGLE_FLAG;

#ifdef  OLD_IL

    case 'G':
        switch (*cmdPtr++)
        {
        case 0:
            comp->cmpConfig.ccOILgen = true;
            break;

        case '-':
            comp->cmpConfig.ccOILgen = false;
            break;

        case 'g':
            comp->cmpConfig.ccOILcgen = saveOptionString(cmdPtr);
            break;

        case 'l':
            flagPtr = &comp->cmpConfig.ccOILlink;
            goto TOGGLE_FLAG;

        case 'k':
            flagPtr = &comp->cmpConfig.ccOILkeep;
            goto TOGGLE_FLAG;

        case 'x':
            flagPtr = &comp->cmpConfig.ccOILopt;
            goto TOGGLE_FLAG;

        case 's':
            flagPtr = &comp->cmpConfig.ccOILopts;
            goto TOGGLE_FLAG;

        case 'a':
            flagPtr = &comp->cmpConfig.ccOILasm;
            goto TOGGLE_FLAG;

        case 'c':
            flagPtr = &comp->cmpConfig.ccOILcod;
            goto TOGGLE_FLAG;

        default:
            return  true;
        }
        break;

#endif

    case 'O':
        strcpy(outfileNameBuff, cmdPtr); comp->cmpConfig.ccOutFileName = outfileNameBuff;
        break;

    case 'p':
        comp->cmpConfig.ccPathList = addToStrList(cmdPtr, comp->cmpConfig.ccPathList, &comp->cmpConfig.ccPathLast);
        break;

    case 'P':
        flagPtr = &comp->cmpConfig.ccPedantic;
        goto TOGGLE_FLAG;

    case 'q':
        flagPtr = &comp->cmpConfig.ccQuiet;
        goto TOGGLE_FLAG;

    case 'r':
        flagPtr = &comp->cmpConfig.ccStrValCmp;
        goto TOGGLE_FLAG;

    case 'R':
        flagPtr = &comp->cmpConfig.ccRecDir;
        goto TOGGLE_FLAG;

    case 's':
        switch (*cmdPtr)
        {
        case 0:
            comp->cmpConfig.ccBaseLibs = "";
            break;

        case '-':
            comp->cmpConfig.ccBaseLibs = NULL;
            break;

        default:
            comp->cmpConfig.ccBaseLibs = saveOptionString(cmdPtr);
        }
        break;

    case 'S':
        switch (*cmdPtr)
        {
        case 0:
            comp->cmpConfig.ccSafeMode   = true;
            return  false;

        case '-':
            comp->cmpConfig.ccSafeMode   = false;
            return  false;

        case 'M':
            comp->cmpConfig.ccStrCnsDef = 0;
            break;

        case 'A':
            comp->cmpConfig.ccStrCnsDef = 1;
            break;

        case 'U':
            comp->cmpConfig.ccStrCnsDef = 2;
            break;

        default:
            return  true;
        }

        if  (cmdPtr[1])
            return  true;

        break;

    case 'T':
        comp->cmpConfig.ccTestMask = atoi(cmdPtr);
        printf("NOTE: Using test mask of 0x%X\n", comp->cmpConfig.ccTestMask);
        break;

    case 'U':
        flagPtr = &comp->cmpConfig.ccChkUseDef;
        goto TOGGLE_FLAG;

    case 'u':
        flagPtr = &comp->cmpConfig.ccNoDefines;
        goto TOGGLE_FLAG;

#ifdef  DEBUG

    case 'g':
        switch (*cmdPtr)
        {
        case 0:
            comp->cmpConfig.ccDispCode = true;
            break;

        case '-':
            comp->cmpConfig.ccDispCode = false;
            break;

        case 'd':
            cmdPtr++;
            comp->cmpConfig.ccDispCode = true;
            flagPtr = &comp->cmpConfig.ccDispILcd;
            goto TOGGLE_FLAG;

        default:
            return  true;
        }
        break;

    case 'v':
        switch (*cmdPtr)
        {
        case 0:
            comp->cmpConfig.ccVerbose = 1;
            break;

        case '-':
            comp->cmpConfig.ccVerbose = 0;
            break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            comp->cmpConfig.ccVerbose = atoi(cmdPtr);
            break;

        default:
            return  true;
        }
        break;

#endif

    case 'V':
        // just ignore the darn thing
        printf("Please stop using the -V flag, it's no longer meaningful!!!!!!!!!\n");
        break;

    case 'w':
        switch (*cmdPtr++)
        {
        case 0:
            memset(comp->cmpConfig.ccWarning, 1, sizeof(comp->cmpConfig.ccWarning));
            return  false;

        case '-':
            if  (*cmdPtr == 0)
            {
                unsigned        w;

                for (w = 0; w < sizeof(comp->cmpConfig.ccWarning); w++)
                {
                    if  (comp->cmpConfig.ccWarning[w] != 9)
                         comp->cmpConfig.ccWarning[w]  = 0;
                }
                return  false;
            }
            val = 0;
            break;

        case 'x':
            flagPtr = &comp->cmpConfig.ccWarnErr;
            goto TOGGLE_FLAG;

        default:
            val = 1; cmdPtr--;
            break;
        }

        /* We better have a warning number here */

        temp = atoi(cmdPtr);
        if  (temp < 4000 || temp >= 4000 + WRNcountWarn)
            return  true;

        comp->cmpConfig.ccWarning[temp - 4000] = val;
        break;

    case 'X':
        flagPtr = &comp->cmpConfig.ccAmbigHack;
        goto TOGGLE_FLAG;

    case 'z':
        switch (*cmdPtr++)
        {
        case 0:
            comp->cmpConfig.ccAssembly = true;
            break;

        case '-':
            comp->cmpConfig.ccAssembly = false;
            break;

        case 't':
            flagPtr = &comp->cmpConfig.ccAsmNoPubTp;
            comp->cmpConfig.ccAssembly = true;
            goto TOGGLE_FLAG;

        case 'n':
            flagPtr = &comp->cmpConfig.ccAsmNonCLS;
            comp->cmpConfig.ccAssembly = true;
            goto TOGGLE_FLAG;

        case 'm':
            comp->cmpConfig.ccModList = addToStrList(cmdPtr, comp->cmpConfig.ccModList, &comp->cmpConfig.ccModLast);
            comp->cmpConfig.ccAssembly = true;
            break;

        case 'r':
            comp->cmpConfig.ccMRIlist = addToStrList(cmdPtr, comp->cmpConfig.ccMRIlist, &comp->cmpConfig.ccMRIlast);
            comp->cmpConfig.ccAssembly = true;
            break;

        default:
            return  true;
        }
        break;

    case 'Z':
        switch (*cmdPtr++)
        {
        case 'i':
            flagPtr = &comp->cmpConfig.ccGenDebug;
            goto TOGGLE_FLAG;

        case 'l':
            flagPtr = &comp->cmpConfig.ccLineNums;
            goto TOGGLE_FLAG;

        case 'n':
            flagPtr = &comp->cmpConfig.ccParamNames;
            goto TOGGLE_FLAG;

        default:
            return  true;
        }

    TOGGLE_FLAG:

        switch  (*cmdPtr)
        {
        case 0:
            *flagPtr = true;
            break;
        case '-':
            *flagPtr = false;
            break;
        default:
            return  true;
        }
        break;

    default:
        return  true;
    }

    return  false;
}


/*****************************************************************************
 *
 *  The following is used to map a managed String instance to a raw C-style
 *  unmanaged string when running on top of the CLR.
 */

#ifdef  __COMRT__

char    *           makeRawString(String s)
{
    size_t          strLen = s.Length;
    char    *       strPtr = (char *)malloc(strLen + 1);

    unsigned        i;

    for (i = 0; i < strLen; i++)
        strPtr[i] = (char)s.Chars[i];

    strPtr[strLen] = 0;

    return  strPtr;
}

String              makeMgdString(char * s)
{
#ifdef  __64BIT__
#pragma message("all managed code disabled for 64 bits")
    return  NULL;
#else
    size_t              strLen = strlen(s);
    Text::StringBuilder strBuf = new Text::StringBuilder(strLen);

    unsigned        i;

    for (i = 0; i < strLen; i++)
        strBuf.Append((wchar)s[i]);

    return  strBuf.ToString();
#endif
}

#endif

/*****************************************************************************
 *
 *  Convert a GUID string to a - surprise - GUID!
 */

static
int                 convertHC(int ch)
{
    if  (ch >= '0' && ch <= '9')
        return  ch - '0';
    if  (ch >= 'A' && ch <= 'Z')
        return  ch - 'A' + 10;
    if  (ch >= 'a' && ch <= 'z')
        return  ch - 'a' + 10;

    return  -1;
}

static
const   char *      parseHexD(const char *str, void *dest, unsigned cnt, bool fwd, bool end)
{
    size_t          size;
    unsigned char   buff[6];
    unsigned char * next;

    assert(cnt && (cnt & 2) == 0);

    size = cnt = cnt / 2; assert(size <= arraylen(buff));

    if  (fwd)
        next = buff;
    else
        next = buff + size;

    do
    {
        int             nb1;
        int             nb2;

        nb1 = convertHC(*str++); if (nb1 == -1) return NULL;
        nb2 = convertHC(*str++); if (nb2 == -1) return NULL;

        next -= (int)(fwd == false);

        assert(next >= buff);
        assert(next <  buff + sizeof(buff));

        *next = nb1 << 4 | nb2;

        next += (int)(fwd != false);
    }
    while (--cnt);

    assert((fwd == false && next == buff) || (fwd != false && next == buff + size));

    if  (!end)
    {
        if  (*str++ != '-') return NULL;
    }

    memcpy(dest, buff, size);

    return  str;
}

bool                parseGUID(const char *str, GUID *guidPtr, bool curlied)
{
    if  (curlied && *str++ != '{')
    {
    ERR:
//      printf("ERROR: GUID's use the format 'HHHHHHHH-HHHH-HHHH-HHHH-HHHHHHHHHHHH'\n");
        return  true;
    }

    str = parseHexD(str, &guidPtr->Data1   , 8, false, false);
    if  (str == NULL)
        goto ERR;
    str = parseHexD(str, &guidPtr->Data2   , 4, false, false);
    if  (str == NULL)
        goto ERR;
    str = parseHexD(str, &guidPtr->Data3   , 4, false, false);
    if  (str == NULL)
        goto ERR;
    str = parseHexD(str,  guidPtr->Data4   , 4,  true, false);
    if  (str == NULL)
        goto ERR;
    str = parseHexD(str,  guidPtr->Data4+2 ,12,  true,  true);
    if  (str == NULL)
        goto ERR;

    if  (curlied && *str++ != '}')
        goto ERR;
    if  (*str)
        goto ERR;

    return  false;
}

/*****************************************************************************
 *
 *  Process a DLL base file option.
 */

static
bool                parseHexNum(const char **nextPtr, unsigned *valPtr)
{
    const   char *  next = *nextPtr;
    unsigned        val  = 0;

    /* Skip over any whitespace */

    while (isspace(*next)) next++;

    /* We should have "0x" next */

    if  (*next++ != '0')
        return  true;
    if  (*next++ != 'x')
        return  true;

    /* Now collect a hex number */

    while (*next)
    {
        int             add;

        add = convertHC(*next);

        if  (add == -1)
            break;

        val <<= 4;
        val  += add;

        next++;
    }

    /* Everything went fine, return everything to the caller */

    *nextPtr = next;
    * valPtr = val;

    return  false;
}

static
bool                processDLLbaseFile(const char *fname, Compiler comp)
{
    const   char *  comma;
    char            nbuff[_MAX_PATH];
    FILE    *       filep;
    bool            found;

    const   char *  nmstr;
    unsigned        nmlen;

//  printf("DLL file = '%s'\n", fname);

    /* There better be a filename followed by name seperated by comma */

    comma = strchr(fname, ',');
    if  (!comma || comma == fname || comma[1] == 0)
        return  true;

    memcpy(nbuff, fname, comma-fname); nbuff[comma-fname] = 0;
    nmstr = comma + 1;
    nmlen = strlen(nmstr);

//  printf("File = '%s'\n", nbuff);
//  printf("Name = '%s'\n", nmstr);

    filep = fopen(nbuff, "rt");
    if  (!filep)
    {
        printf("WARNING: Could not open DLL base file '%s'\n", nbuff);
        return  false;
    }

    for (found = false;;)
    {
        char            line[256];
        const   char *  next;

        if  (!fgets(line, sizeof(line), filep))
            break;

        for (next = line; *next; next++)
        {
            if  (isalpha(*next))
            {
                const   char *  nsbeg = next;

                do
                {
                    next++;
                }
                while (isalpha(*next));

                if  ((int)nmlen == next - nsbeg && !memcmp(nsbeg, nmstr, nmlen))
                {
                    unsigned            base;
                    unsigned            size;

                    found = true;

                    /* We better have two hex numbers here */

                    if  (parseHexNum(&next, &base))
                    {
                        printf("WARNING: Didn't find size for DLL entry '%s' in '%s'\n", nmstr, nbuff);
                        goto DONE;
                    }

                    if  (parseHexNum(&next, &size))
                    {
                        printf("WARNING: Didn't find size for DLL entry '%s' in '%s'\n", nmstr, nbuff);
                        goto DONE;
                    }

                    comp->cmpConfig.ccOutBase = base;
                    comp->cmpConfig.ccOutSize = size;

//                  printf("Found DLL entry [base=%08X,size=%08X]\n", base, size);

                    goto DONE;
                }
            }
        }
    }

    fclose(filep);

DONE:

    if  (!found)
    {
        printf("WARNING: Didn't find entry for '%s' in DLL base file '%s'\n", nmstr, nbuff);
        return  false;
    }

    return  false;
}

static
StrList             addToStrList(const char *str, StrList  list,
                                                  StrList *lastPtr)
{
    StrList         next;
    char    *       save;

#if MGDDATA

    UNIMPL(!"save str");

#else

    next = (StrList)malloc(sizeof(*next));
    save = (char  *)malloc(strlen(str)+1);

    strcpy(save, str);

#endif

    next->slString = save;
    next->slNext   = NULL;

    if  (*lastPtr)
        (*lastPtr)->slNext = next;
    else
        list               = next;

    *lastPtr = next;

    return  list;
}

/*****************************************************************************/
#if COUNT_CYCLES
/*****************************************************************************/

#pragma warning(disable:4035)

#define CCNT_OVERHEAD64 13

__int64         GetCycleCount64()
{
__asm   _emit   0x0F
__asm   _emit   0x31
};

#define CCNT_OVERHEAD32 13

unsigned        GetCycleCount32()        // enough for about 40 seconds
{
__asm   push    EDX
__asm   _emit   0x0F
__asm   _emit   0x31
__asm   pop     EDX
};

#pragma warning(default:4035)

/*****************************************************************************/

static
__int64         cycleBegin;

static
__int64         cycleTotal;

static
__int64         cycleStart;

static
unsigned        cyclePause;

unsigned        cycleExtra;

static
void            cycleCounterInit()
{
    cycleBegin = GetCycleCount64();
    cycleTotal = 0;
    cycleStart = 0;
    cyclePause = 0;
}

static
__int64         cycleCounterDone(__int64 *realPtr)
{
    assert(cyclePause == 0);

    *realPtr = GetCycleCount64() - cycleBegin;

    return cycleTotal;
}

void            cycleCounterBeg()
{
    assert(cyclePause == 0);

    cycleStart = GetCycleCount64();
}

void            cycleCounterEnd()
{
    assert(cycleStart != 0);
    assert(cyclePause == 0);

    cycleTotal += GetCycleCount64() - cycleStart;

    cycleStart  = 0;
}

void            cycleCounterPause()
{
    assert(cycleStart != 0);

    if  (!cyclePause)
        cycleTotal += GetCycleCount64() - cycleStart;

    cyclePause++;
}

void            cycleCounterResume()
{
    assert(cycleStart != 0);
    assert(cyclePause != 0);

    if  (--cyclePause)
        return;

    cycleStart = GetCycleCount64();
}

/*****************************************************************************/
#endif//COUNT_CYCLES
/*****************************************************************************
 *
 *  Recursively process the given file list, calling the given function pointer
 *  for each file found.
 */

static
bool                processFiles(Compiler    comp,
                                 unsigned    argb,
                                 unsigned    argc,
                                 stringArr_t argv,
                                 const char *subdir,
                                 bool      (*processOneFileFN)(genericRef, stringBuff, QueuedFile, stringBuff),
                                 genericRef  cookie,
                                 bool        asynch,
                                 const char *defaultFileExt)
{
    const   char *  file;

    int             more;

    __int32         ffHandle;
    _finddata_t     ffData;

    char            path[_MAX_PATH ];
    char            fnam[_MAX_FNAME];
    char            fdrv[_MAX_DRIVE];
    char            fdir[_MAX_DIR  ];
    char            fext[_MAX_EXT  ];

    bool            status = false;

    while (argb < argc)
    {
        /* Pull the next file name from the list */

        file = makeRawString(argv[argb++]);

        /* Is this a response file? */

        if  (*file == '@')
        {
            FILE    *       fp;
            bool            err;

            cycleCounterPause();
            fp = fopen(file+1, "rt");
            cycleCounterResume();

            if  (!fp)
            {
                printf("ERROR: response file '%s' could not be opened.\n", file+1);
                forceDebugBreak();
                return 1;
            }

            for (err = false;;)
            {
                char            line[256];
                size_t          llen;

                if  (!fgets(line, sizeof(line), fp))
                    break;

                llen = strlen(line);

                if  (llen && line[llen-1] == '\n')
                {
                    llen--;
                    line[llen] = 0;
                }

                if  (line[0] && line[0] != ';')
                {
                    if  (line[0] == '-' ||
                         line[0] == '/')
                    {
                        if  (startedCompiling)
                        {
                            printf("ERROR: All command-line options must precede source files\n");
                            return  true;
                        }

                        if  (processOption(line, comp))
                        {
                            dispHelpScreen(comp, line);
                            return  true;
                        }
                    }
                    else
                    {
                        char    *   name = line;

#ifdef  __COMRT__
                        stringArr_t nameArr   = new managed String[1]; nameArr[0] = makeMgdString(name);
#else
                        const char *nameArr[] = { name };
#endif

                        /* Recursive call */

                        err = processFiles(comp, 0, 1, nameArr,
                                                       NULL,
                                                       processOneFileFN,
                                                       cookie,
                                                       asynch,
                                                       defaultFileExt);

                        if  (err)
                            break;
                    }
                }
            }

            fclose(fp);

            if  (err)
                return err;

            continue;
        }

        /* Split the filename */

        _splitpath(file, fdrv, fdir, fnam, fext);

        /* Make sure we set the extension appropriately */

        if  (!fext[0])
            strcpy(fext, defaultFileExt);

        /* Append the subdirectory path if non-null */

        if  (subdir && *subdir)
            strcat(fdir, subdir);
        else
            subdir = "";

        /* Form a filename with the appropriate extension */

        _makepath(path, fdrv, fdir, fnam, fext);

        /* Look for the first match for the file pattern */

        cycleCounterPause();
        ffHandle = _findfirst(path, &ffData);
        cycleCounterResume();

        if  (ffHandle == -1)
        {
            if  (comp->cmpConfig.ccRecDir)
                goto SUBDIRS;

            printf("ERROR: source file '%s' not found.\n", file);
            return 1;
        }

        do
        {
            // WARNING: Don't call cmpInit() in this thread if doing asynch I/O !!!!

            if  (!startedCompiling && !asynch)
            {
                /* Initialize the compiler */

                if  (comp->cmpInit())
                    return  true;

                startedCompiling = true;
            }

            /* Make the matching file name into a complete path */

            _splitpath(ffData.name, NULL, NULL, fnam, fext);
            _makepath(path,         fdrv, fdir, fnam, fext);

            /* Remember the first name we encounter for the output file */

            if  (!firstFileName[0] && !comp->cmpConfig.ccRecDir)
                _makepath(firstFileName, fdrv, fdir, fnam, NULL);

            /* Process the file by calling via the provided function pointer */

            status |= processOneFileFN(cookie, path, NULL, NULL);
            if  (status)
                break;

            cycleCounterPause();
            more = _findnext(ffHandle, &ffData);
            cycleCounterResume();
        }
        while (more != -1);

        _findclose(ffHandle);

        if  (status)
            return  status;

    SUBDIRS:

        if  (comp->cmpConfig.ccRecDir)
        {
            /* Form a "*.*" filename */

            _makepath(path, fdrv, fdir, "*", "*");

            /* Walk the directory again */

            cycleCounterPause();
            ffHandle = _findfirst(path, &ffData);
            cycleCounterResume();

            if  (ffHandle == -1)
                goto NEXT;

            do
            {
                char            temp[_MAX_DIR  ];

                if  (!(ffData.attrib & _A_SUBDIR))
                    continue;

                /* Special case: skip "." and ".." */

                if  (ffData.name[0] == '.')
                {
                    switch (ffData.name[1])
                    {
                    case '.':
                        if  (ffData.name[2] == 0)
                            continue;
                        break;

                    case 0:
                        continue;
                    }
                }

                /* Append this subdirectory to the subdir path */

                strcpy(temp, subdir);
                if  (*temp) strcat(temp, "\\");
                strcat(temp, ffData.name);

                /* Recursively process the sub-directory */

                status = processFiles(comp,
                                      argb-1,
                                      argb,
                                      argv, temp,
                                            processOneFileFN,
                                            cookie,
                                            asynch,
                                            defaultFileExt);
            }
            while (!status && _findnext(ffHandle, &ffData) != -1);

            _findclose(ffHandle);
        }

    NEXT:;
    }

    return  status;
}

/*****************************************************************************/
#ifdef  ASYNCH_INPUT_READ
/*****************************************************************************
 *
 *  The overlapped (asynch) file input logic follows.
 */

static
QueuedFile          fileQueueHead;
static
QueuedFile          fileQueueTail;

static
LONG    volatile    fileQueueSize;
static
LONG    volatile    fileQueueOpen;
static
LONG    volatile    fileQueueReading;
static
LONG    volatile    fileQueueRead;
static
LONG    volatile    fileQueueParsed;

static
CRITICAL_SECTION    fileQueueCritSect;

static
HANDLE              fileQueueListCnt;       // semaphore
static
HANDLE              fileQueueReadCnt;       // semaphore

static
HANDLE              fileQueueEndEvt0;     // event
static
HANDLE              fileQueueEndEvt1;     // event
static
HANDLE              fileQueueEndEvt2;     // event
static
HANDLE              fileQueueEndEvt3;     // event

struct  fileListDsc
{
    Compiler        comp;
    unsigned        argb;
    unsigned        argc;
    stringArr_t     argv;
    bool          (*func)(genericRef, stringBuff, QueuedFile, stringBuff);
    const char *    defx;
    void    *       cptr;
};

static
void    __stdcall   fileReadCallBack(DWORD error,
                                     DWORD count, OVERLAPPED *optr)
{
    QueuedFile      file = (QueuedFile)optr->hEvent;

    assert(file->qfSelf == file);

    if  (error || count != file->qfSize)
        file->qfComp->cmpGenFatal(ERRreadErr, file->qfName);

//  printf("Asynch I/O done: %6u bytes from '%s'\n", count, file->qfName);

#if DISP_ASYNC_PROGRESS
    printf("D");
#endif

    /* Append the EOF character */

    ((BYTE*)file->qfBuff)[file->qfSize] = 0x1A;

    /* Close the file */

    CloseHandle(file->qfHandle); file->qfHandle = 0;

    /* Mark the entry as "done" */

    file->qfDone = true; fileQueueRead++;

    /* Decrement the number of pending files */

    InterlockedDecrement((LONG*)&fileQueueReading);

    /* Signal the reader thread that another file has finished reading */

    if  (!ReleaseSemaphore(fileQueueReadCnt, 1, NULL))
    {
        printf("FATAL ERROR: Couldn't signal semaphore (error=%08X)\n", GetLastError());
        _flushall();
        exit(-1);
    }

    /* Signal the file event itself */

    SetEvent(file->qfEvent);
}

static
DWORD   __stdcall   fileReadWorker(LPVOID cookie)
{
    fileListDsc *   desc = (fileListDsc *)cookie;

    QueuedFile      list = fileQueueHead;
    bool            more = true;

    HANDLE          etab[3];

//  printf("Beg reader thread.\n");

    etab[0] = fileQueueListCnt;
    etab[1] = fileQueueEndEvt0;
    etab[2] = fileQueueEndEvt1;

    while (more || fileQueueSize != fileQueueOpen)
    {
        _Fstat          fileInfo;

        size_t          size;
        void    *       buff;
        size_t          read;

        unsigned        wait;

        /* Do we have a file ready to read? */

        if  (list && !list->qfOpen)
        {
            /* Make sure that we don't have too many files in play already */

            if  (fileQueueReading < MAX_SIMULTANEOUS_ASYNC_IOS)
                goto NEXT;
        }

    WAIT:

        /* Wait for a file to be added to the queue or the end of the file list */

//      printf("Start wait [%u]\n", __LINE__);

        wait = WaitForMultipleObjectsEx(arraylen(etab),
                                        etab,
                                        FALSE,
                                        0, // INFINITE,
                                        true);

//      printf("End   wait [%u]\n", __LINE__);

#if 0
        if  (wait != WAIT_OBJECT_0 &&
             wait != WAIT_TIMEOUT  &&
             wait != WAIT_IO_COMPLETION)
        {
            printf("Wait -> 0x%04X\n", wait);
//          static int x; if (++x == 50) exit(-1);
        }
#endif

        switch (wait)
        {
        case WAIT_FAILED:
            printf("[1] Wait failed, huh?\n");
            return  1;

        case WAIT_TIMEOUT:
            continue;

        case WAIT_IO_COMPLETION:
            break;

        case WAIT_OBJECT_0:

            /* A new file has been added to the queue, let's go process it */

            break;

        case WAIT_OBJECT_0+1:

            /* Queue has been drained, let's go look for some more work */

            ResetEvent(fileQueueEndEvt0);
            break;

        case WAIT_OBJECT_0+2:

            /* No more files will be added to the input queue */

            more = false;
            ResetEvent(fileQueueEndEvt1);
            continue;

        default:
            printf("[1] Wait returned %08X, what the heck does that mean?\n", wait);
            return  1;
        }

        /* At least one file has been added to our queue, start reading it */

        if  (list == NULL)
             list = fileQueueHead;

        for (;;)
        {
            assert(list);

            if  (!list->qfReady)
                goto WAIT;

            if  (!list->qfOpen)
                break;

            if  (!list->qfNext)
                goto WAIT;

            list = list->qfNext;
        }

        /* Make sure we don't start reading too many files at once */

        if  (fileQueueReading >= MAX_SIMULTANEOUS_ASYNC_IOS)
            continue;

    NEXT:

//      printf("Start asynch read from source file '%s'\n", list->qfName);

        /* See if the source file exists */

        if  (_stat(list->qfName, &fileInfo))
        {
        ERR_OPEN:
            printf("ERROR: source file '%s' not found.\n", list->qfName);
            UNIMPL(!"need to pretend the file has finished reading");
            continue;
        }

        /* Get hold of the file size */

        list->qfSize   = size = fileInfo.st_size;

        /* Open a read handle onto the file */

        list->qfHandle = CreateFileA(list->qfName,
                                     GENERIC_READ,
                                     FILE_SHARE_READ|FILE_SHARE_WRITE,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_FLAG_SEQUENTIAL_SCAN,
//                                   FILE_FLAG_OVERLAPPED|FILE_FLAG_NO_BUFFERING|FILE_FLAG_OVERLAPPED,
                                     NULL);

        if  (list->qfHandle == INVALID_HANDLE_VALUE)
            goto ERR_OPEN;

        /* Create the "read finished" event */

        list->qfEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        /* Mark the file as open and increment the open file count */

        list->qfOpen = true;

        /* Increment the number of open and pending files */

        InterlockedIncrement((LONG*)&fileQueueOpen);
        InterlockedIncrement((LONG*)&fileQueueReading);

        /* Allocate a buffer for the file contents */

        list->qfBuff = buff = malloc(size+1);
        if  (!buff)
            desc->comp->cmpGenFatal(ERRnoMemory);

        /* Clear the overlapped struct and stash the file pointer in it */

        memset(&list->qfOdsc, 0, sizeof(list->qfOdsc));

        list->qfOdsc.hEvent = (HANDLE)list;

        /* We're ready to issue the read request */

        read = ReadFileEx(list->qfHandle,
                          list->qfBuff,
                          list->qfSize,
                         &list->qfOdsc,
                          fileReadCallBack);

#if     DISP_ASYNC_PROGRESS
        printf("R");
#endif

        if  (!read)
        {
            /* Error - call the callback manually (the OS won't call it) */

            fileReadCallBack(GetLastError(), 0, &list->qfOdsc);
        }
    }

    SetEvent(fileQueueEndEvt2);

    while (fileQueueRead != fileQueueSize)
        SleepEx(1000, TRUE);

//  printf("End reader thread.\n");

    return  0;
}

static
bool                fileReadAppend(genericRef cookie, stringBuff filename, QueuedFile, stringBuff)
{
    fileListDsc *   desc = (fileListDsc *)cookie;
    Compiler        comp = desc->comp;
    char    *       name;

    QueuedFile      qfile;

//  printf("Adding file to input queue: '%s'\n", filename);

    /* Make a durable copy of the input file name */

    name  = new char[strlen(filename)+1]; strcpy(name, filename);

    /* Create a new file queue entry */

    qfile = new queuedFile;

    qfile->qfComp    = comp;
    qfile->qfName    = name;
    qfile->qfSize    = 0;
    qfile->qfBuff    = NULL;
    qfile->qfHandle  = 0;
    qfile->qfOpen    = false;
    qfile->qfDone    = false;
    qfile->qfParsing = false;
    qfile->qfEvent   = NULL;
    qfile->qfNext    = NULL;

#ifdef  DEBUG
    qfile->qfSelf    = qfile;
#endif

    /* Append the new file entry to the queue */

    EnterCriticalSection(&fileQueueCritSect);

    if  (fileQueueHead)
         fileQueueTail->qfNext = qfile;
    else
         fileQueueHead         = qfile;

    fileQueueTail = qfile;

    fileQueueSize++;

    LeaveCriticalSection(&fileQueueCritSect);

    /* The file is ready to be processed now */

    qfile->qfReady = true;

    /* Signal the reader thread that there is more work to be done */

    if  (!ReleaseSemaphore(fileQueueListCnt, 1, NULL))
    {
        printf("FATAL ERROR: Couldn't signal semaphore (error=%08X)\n", GetLastError());
        _flushall();
        exit(-1);
    }

    SleepEx(0, TRUE);

    return  false;
}

static
DWORD   __stdcall   fileListWorker(LPVOID cookie)
{
    bool            result;

    fileListDsc *   desc = (fileListDsc *)cookie;

    result = processFiles(desc->comp,
                          desc->argb,
                          desc->argc,
                          desc->argv,
                          NULL,
                          &fileReadAppend,
                          desc,
                          true,
                          desc->defx);

    SetEvent(fileQueueEndEvt1);

    return  result;
}

static
bool                processFileList(Compiler    comp,
                                    unsigned    argb,
                                    unsigned    argc,
                                    stringArr_t argv,
                                    bool      (*processOneFileFN)(genericRef, stringBuff, QueuedFile, stringBuff),
                                    genericRef  cookie,
                                    bool        asynch,
                                    const char *defaultFileExt)
{
    bool            err = false;

    fileListDsc     desc;

    bool            more;
    bool            done;

    HANDLE          etab[3];

    QueuedFile      nextFile;
    unsigned        waitCnt;

    DWORD           listerThrdID;
    HANDLE          listerThrdHN;

    DWORD           readerThrdID;
    HANDLE          readerThrdHN;

    if  (!asynch)
    {
        return  processFiles(comp,
                             argb,
                             argc,
                             argv,
                             NULL,
                             processOneFileFN,
                             cookie,
                             asynch,
                             defaultFileExt);
    }

    /* Clear the queue of input files */

    fileQueueHead =
    fileQueueTail = NULL;

    InitializeCriticalSection(&fileQueueCritSect);

    /* Create the necessary event objects */

    fileQueueListCnt = CreateSemaphore(NULL, 0, INT_MAX, NULL);
    fileQueueReadCnt = CreateSemaphore(NULL, 0, INT_MAX, NULL);

    fileQueueEndEvt0 = CreateEvent    (NULL, TRUE, FALSE, NULL);
    fileQueueEndEvt1 = CreateEvent    (NULL, TRUE, FALSE, NULL);
    fileQueueEndEvt2 = CreateEvent    (NULL, TRUE, FALSE, NULL);
    fileQueueEndEvt3 = CreateEvent    (NULL, TRUE, FALSE, NULL);

    /* Create a thread that will look for files to compile */

    desc.comp = comp;
    desc.argb = argb;
    desc.argc = argc;
    desc.argv = argv;
    desc.func = processOneFileFN;
    desc.defx = defaultFileExt;
    desc.cptr = cookie;

    listerThrdHN = CreateThread(NULL, 0, fileListWorker, &desc, 0, &listerThrdID);
    if  (listerThrdHN == NULL)
    {
        printf("FATAL ERROR: Couldn't create file list worker thread (error=%08X)\n", GetLastError());
        return  true;
    }

    readerThrdHN = CreateThread(NULL, 0, fileReadWorker, &desc, 0, &readerThrdID);
    if  (readerThrdHN == NULL)
    {
        printf("FATAL ERROR: Couldn't create file read worker thread (error=%08X)\n", GetLastError());
        return  true;
    }

    /* Wait until files start arriving */

    etab[0]  = fileQueueReadCnt;
    etab[1]  = fileQueueEndEvt2;
    etab[2]  = fileQueueEndEvt3;

    for (more = true, done = false, nextFile = NULL, waitCnt = 0;;)
    {
        unsigned        wait;

//      printf("[2] Pending = %u\n", fileQueueReading);

        /* Are any files waiting to be processed? */

        while (waitCnt)
        {
            if  (nextFile == NULL)
            {
                /* This is the very first time here */

                nextFile = fileQueueHead;

                /* Initialize the compiler */

                assert(startedCompiling == false);

#ifdef  ASYNCH_INPUT_READ
#if     DISP_ASYNC_PROGRESS
                printf("I");
#endif
                cycleCounterResume();
#endif

                if  (comp->cmpInit())
                    return  true;

#ifdef  ASYNCH_INPUT_READ
                cycleCounterPause();
#endif

                startedCompiling = true;

                SetEvent(fileQueueEndEvt3);
            }

            assert(nextFile);

            /* Skip over any files we may have processed last time */

            for (;;)
            {
                if  (!nextFile->qfParsing)
                    break;

                if  (!nextFile->qfNext)
                    goto WAIT;

                nextFile = nextFile->qfNext;
            }

            if  (!nextFile->qfDone)
            {
                /* Wait for this file to finish loading */

                UNIMPL(!"wait");
            }

            if  (nextFile->qfEvent)
            {
                CloseHandle(nextFile->qfEvent);
                            nextFile->qfEvent = 0;
            }

            nextFile->qfParsing = true;
            waitCnt--;

            InterlockedIncrement((LONG*)&fileQueueParsed);

            assert(nextFile->qfDone);

#ifdef  ASYNCH_INPUT_READ
#if     DISP_ASYNC_PROGRESS
            printf("P");
#endif
            cycleCounterResume();
#endif

            err |= processOneFileFN(comp, (char *)nextFile->qfName, nextFile, NULL);

#ifdef  ASYNCH_INPUT_READ
            cycleCounterPause();
#if     DISP_ASYNC_PROGRESS
            printf("E");
#endif
#endif

            /* Throw away the file contents */

            assert(nextFile->qfBuff == NULL);

            if  (nextFile->qfBuff)
            {
                free(nextFile->qfBuff);
                     nextFile->qfBuff = NULL;
            }

            /* If any files might be backed up, push the queue */

            if  (fileQueueReading)
                SetEvent(fileQueueEndEvt0);

//          printf("[3] Pending = %u\n", fileQueueReading);

            SleepEx(0, TRUE);
        }

    WAIT:

//      printf("Waitcnt = %u, more = %u, counts = %u/%u\n", waitCnt, more, fileQueueSize, fileQueueRead);

        if  (!more && done && fileQueueSize == fileQueueRead)
            break;

        /* Wait for a file to be added to the queue or the end of the file list */

//      printf("Start wait [%u]\n", __LINE__);

        wait = WaitForMultipleObjectsEx(arraylen(etab),
                                        etab,
                                        FALSE,
                                        0, // INFINITE,
                                        true);

//      printf("End   wait [%u]\n", __LINE__);

        switch (wait)
        {
        case WAIT_OBJECT_0:

            /* Another file has finished reading */

            waitCnt++;
            break;

        case WAIT_OBJECT_0+1:

            /* All files have been added to the file list */

            more = false; ResetEvent(fileQueueEndEvt2);
            break;

        case WAIT_OBJECT_0+2:

            /* At least one file has been read and started parsing */

            done = true;
            break;

        case WAIT_TIMEOUT:
            SleepEx(0, TRUE);
            break;

        default:
            printf("[2] Wait returned %08X, what the heck does that mean?\n", wait);
            err = true;
            goto DONE;
        }
    }

DONE:

    DeleteCriticalSection(&fileQueueCritSect);

    CloseHandle(fileQueueListCnt);
    CloseHandle(fileQueueReadCnt);

    CloseHandle(fileQueueEndEvt0);
    CloseHandle(fileQueueEndEvt1);
    CloseHandle(fileQueueEndEvt2);
    CloseHandle(fileQueueEndEvt3);

    assert(fileQueueReading == 0);

    assert(fileQueueSize    == fileQueueOpen);
    assert(fileQueueSize    == fileQueueRead);

    return  err;
}

/*****************************************************************************/
#else //ASYNCH_INPUT_READ
/*****************************************************************************/

static
bool                processFileList(Compiler    comp,
                                    unsigned    argb,
                                    unsigned    argc,
                                    stringArr_t argv,
                                    bool      (*processOneFileFN)(genericRef, stringBuff, QueuedFile, stringBuff),
                                    genericRef  cookie,
                                    bool        asynch,
                                    const char *defaultFileExt)
{
    return  processFiles(comp,
                         argb,
                         argc,
                         argv,
                         NULL,
                         processOneFileFN,
                         cookie,
                         asynch,
                         defaultFileExt);
}

/*****************************************************************************/
#endif//ASYNCH_INPUT_READ
/*****************************************************************************/

int                 getRegIntVal(const char *name, int defVal)
{
    assert(name);

#ifndef __IL__      // the following crashes as managed code, don't know why ....

    HKEY            subKey;

    if  (!RegOpenKeyExA(HKEY_CURRENT_USER, SMCregKey, 0, KEY_QUERY_VALUE, &subKey))
    {
        DWORD           value;
        DWORD           valType;
        DWORD           valSize = sizeof(value);

        if  (!RegQueryValueExA(subKey, name, NULL, &valType, (PBYTE)&value, &valSize))
        {
            if  (valType == REG_DWORD && valSize == sizeof(DWORD))
                defVal = value;
        }

        RegCloseKey(subKey);
    }

#endif

    return defVal;
}

/*****************************************************************************
 *
 *  Filter expression - return 1 to handle an exception.
 */

int                 EHfilter(unsigned code)
{
//  printf("Error code = %08X\n", code); _flushall();
    return  (code != 0x80000003);
}

/*****************************************************************************
 *
 *  The main generic entry point of the compiler.
 */

#ifdef  DLL
int                 compileAll(int argc, stringArr_t argv, Compiler comp)
#else
int                 compileAll(int argc, stringArr_t argv)
#endif
{
    unsigned        EHcode;

#ifdef  DLL


#else

    Compiler        comp = (Compiler)malloc(sizeof(*comp));

#endif

    int             err  = 0;

    unsigned        argx = 0;

    /* Clear the compile state */

#if!MGDDATA
    memset(comp, 0, sizeof(*comp));
#endif

    /* Catch any exceptions and report them as "internal errors" */

    __try
    {
        unsigned        optNum;
        optionDesc  *   optTab;

        /* Create the default config value */

        for (optNum = 0, optTab = optionInfo;
             optNum < CC_COUNT;
             optNum++  , optTab++)
        {
            if  (optTab->odValueSize <= sizeof(int))
            {
                memcpy( optTab->odValueOffs + (char*)(&comp->cmpConfig),
                       &optTab->odDefault,
                        optTab->odValueSize);
            }
        }

        /* Copy over the default warning settings */

        comp->cmpErrorInit();


        /* Process any command-line switches */

        while (argx < (unsigned)argc)
        {
            const   char *  argn;

            /* Grab the next command-line argument and stop if not an option */

            argn = makeRawString(argv[argx]);
            if  (argn[0] != '-' && argn[0] != '/')
                break;


            if  (processOption(argn, comp))
            {
                dispHelpScreen(comp, argn);
                goto EXIT;
            }


            argx++;
        }

        if  (argc == (int)argx)
        {
#ifndef DLL
            printf("ERROR: No source files to be compiled have been specified\n\n");
            dispHelpScreen(comp);
#endif
            goto EXIT;
        }

#if COUNT_CYCLES

        /* Reset the cycle counter */

        cycleCounterInit();
        assert(cycleTotal == 0);
        cycleCounterBeg();

#ifdef  ASYNCH_INPUT_READ
        if  (comp->cmpConfig.ccAsynchIO)
            cycleCounterPause();
#endif

#endif

        /* Display the signon banner */

        if  (!comp->cmpConfig.ccQuiet)
        {
            printf("Microsoft (R) Visual SMC Compiler Version %s\n", COMPILER_VERSION);
            printf("Copyright (c) Microsoft Corporation.  All rights reserved.\n");
            printf("\n");
        }

        /* Prepare all the source files given to us */

        err = processFileList(comp, argx, argc, argv, compiler::cmpPrepSrc, comp, comp->cmpConfig.ccAsynchIO, ".smc");
        if  (err)
            goto EXIT;

        /* Bail if there was a fatal error */

        if  (comp->cmpFatalCount)
            goto DONE;

#ifdef  DEBUG
//      if  (comp->cmpConfig.ccVerbose) comp->cmpDumpSymbolTable();
#endif

#ifdef  ASYNCH_INPUT_READ
#if     DISP_ASYNC_PROGRESS
        printf("C\n");
#endif
        if  (comp->cmpConfig.ccAsynchIO)
            cycleCounterResume();
#endif

        /* Prepare for the real thing */

        err = comp->cmpStart(firstFileName);
        if  (err)
            goto EXIT;

        /* Compile everything [CONSIDER: only compile one class if desired] */

        err = comp->cmpClass();
        if  (err)
            goto EXIT;

#if COUNT_CYCLES

        __int64         cycleTotal;
        __int64         cycleSpent;

        cycleSpent = cycleCounterDone(&cycleTotal);

        if  (cycleTotal)
            printf("Gross time (est): P2-450 / %4.2f sec, P2-500 / %4.2f, P2-650 / %4.2f\n", (float)cycleTotal/450000000, (float)cycleTotal/500000000, (float)cycleTotal/650000000);
        if  (cycleSpent)
            printf("Net   time (est): P2-450 / %4.2f sec, P2-500 / %4.2f, P2-650 / %4.2f\n", (float)cycleSpent/450000000, (float)cycleSpent/500000000, (float)cycleSpent/650000000);

        if  (cycleExtra)
            printf("Extra time (est): P2-450 / %4.2f sec, P2-500 / %4.2f, P2-650 / %4.2f\n", (float)cycleExtra/450000000, (float)cycleExtra/500000000, (float)cycleExtra/650000000);

        printf("\n");

#endif

#ifdef  SMC_MD_PERF

        __int64         cycCnt;
        __int64         totCyc;

        MetaDataImp     cimp;
        unsigned        i;

        printf("\nMetadata Import:\n");

        for (cimp = comp->cmpMDlist, i = 1, totCyc = 0;
             cimp;
             cimp = cimp->MDnext   , i++)
        {
            cycCnt  = cimp->MDwmdi->getTotalCycles();
            totCyc += cycCnt;

            printf("\tFile [%02u] cycles = %8.0f, time = %6.5f sec (est. on P2-450)\n", i, (float)cycCnt, (float)cycCnt/450000000);
        }

        cycCnt  = comp->cmpPEwriter->WPEwmde->getTotalCycles();
        totCyc += cycCnt;

        printf("Metadata Emit:\n");
        printf("\t          cycles = %8.0f, time = %6.5f sec (est. on P2-450)\n", (float)cycCnt, (float)cycCnt/450000000);

        printf("Metadata Total:\n");
        printf("\t          cycles = %8.0f, time = %6.5f sec (est. on P2-450)\n", (float)totCyc, (float)totCyc/450000000);

#endif

#ifdef  DEBUG
        if  (comp->cmpConfig.ccVerbose >= 4) comp->cmpDumpSymbolTable();
#endif

    DONE:

        /* Wrap up the compilation process */

        err = comp->cmpDone(err != 0);
    }
//  __except(EHcode = 0)
    __except(EHfilter(EHcode = _exception_code()))
    {
        printf("fatal error: Compiler writer error [EC=0x%08X]", EHcode);

        switch (EHcode)
        {
        case STATUS_STACK_OVERFLOW:
            printf(" -- stack overflow");
            break;

#ifdef  __IL__
        case 0x80131522:
            printf(" -- load failed (bad CORwrap.DLL?)");
            break;
#endif

        }

#ifdef  DEBUG_____DISABLED_FOR_NOW
        printf(" [compiler command line='");
        for (int i = 0; i < argc; i++)
        {
            printf("%s", makeRawString(argv[i]));
            if  (i < argc-1)
                printf(" ");
        }
        printf("]'");
        forceDebugBreak();
#endif

        printf("\n");
        err = -1;
    }

EXIT:

#if 0
    printf("Total array types created: %u\n", arrTypeCnt);
    printf("Total array types  reused: %u\n", arrTypeHit);
#endif

#if 0
    void    dispMemAllocStats();
            dispMemAllocStats();
#endif

#if 0
    void    dispSymTabAllocStats();
            dispSymTabAllocStats();
#endif

#if 0
    void    dispHashTabStats();
            dispHashTabStats();
#endif

#if 0
    void    dispScannerStats();
            dispScannerStats();
#endif

    return  err;
}

/*****************************************************************************
 *
 *  Main platform-specific entry point of compiler.
 */

#ifdef  DLL

__declspec(dllexport)
int __stdcall       DllMain(HINSTANCE instance, DWORD reason, LPVOID foobar)
{
    if  (reason == DLL_PROCESS_ATTACH)
        printf("SMC compiler DLL   loaded.\n");
    if  (reason == DLL_PROCESS_DETACH)
        printf("SMC compiler DLL unloaded.\n");



    return  TRUE;
}

extern  "C"
__declspec(dllexport)
int __cdecl         compileInit(unsigned optCnt, const char *optTab[], void **cookiePtr)
{
    Compiler        comp = (Compiler)malloc(sizeof(*comp));
    int             err;

    /* Process the command-line options */

    err = compileAll(optCnt, optTab, comp);
    if  (err)
        return  err;

    /* Make sure we set the output file name properly */

    cfg.ccOutFileName = ":memory:";

    /* Save the option settings */

    comp->cmpConfig = cfg;

    /* Return the compiler instance to the caller */

    *cookiePtr = comp;

    return  0;
}

extern  "C"
__declspec(dllexport)
int __cdecl         compileText(void *cookie, const char *srcText)
{
    int             err;
    Compiler        comp = (Compiler)cookie;

    __try
    {
        /* Start up the compiler */

        comp->cmpInit();

        /* Prepare the source text given to us */

        err = comp->cmpPrepSrc(comp, NULL, "<memory>", (stringBuff)srcText);
        if  (err)
            goto EXIT;

        /* Bail if there was a fatal error */

        if  (comp->cmpFatalCount)
            goto DONE;

        /* Prepare for the real thing */

        err = comp->cmpStart(NULL);
        if  (err)
            goto EXIT;

        /* Compile the source text */

        err = comp->cmpClass();
        if  (err)
            goto EXIT;

    DONE:

        /* Wrap up the compilation process */

        err = comp->cmpDone(err != 0);
    }
    __except(EHfilter(_exception_code()))
    {
        printf("fatal error: Compiler writer error\n");
        err = -1;
    }

EXIT:

    return  err;
}

#else

#ifdef  __SMC__

int                 main(String managed [] args)
{
//  printf("Made it to %s(%u)\n", __FILE__, __LINE__); _flushall();

    return  compileAll(args.Length, args);
}

#else

int     _cdecl      main(int argc, stringArr_t argv)
{


    return  compileAll(argc - 1, argv + 1);


}

#endif

#endif

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\smc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _SMC_H_
#define _SMC_H_
/*****************************************************************************/
/*****************************************************************************/
#include "macros.h"
/*****************************************************************************/

#if     FAST
#ifndef __SMC__
#define COUNT_CYCLES    1
#endif
#endif

#if     COUNT_CYCLES
extern  unsigned        cycleExtra;
extern  void            cycleCounterInit  ();
extern  void            cycleCounterBeg   ();
extern  void            cycleCounterPause ();
extern  void            cycleCounterResume();
extern  void            cycleCounterEnd   ();
extern  __int64         GetCycleCount64   ();
extern  unsigned        GetCycleCount32   ();
#else
inline  void            cycleCounterInit  (){}
inline  void            cycleCounterBeg   (){}
inline  void            cycleCounterPause (){}
inline  void            cycleCounterResume(){}
inline  void            cycleCounterEnd   (){}
#endif

/*****************************************************************************/
#ifndef __SMC__
#define UNION(tag)  union
#define CASE(tval)
#define DEFCASE
#endif
/*****************************************************************************/
#ifdef  __SMC__
unmanaged   class   IMetaDataDispenser      {}
unmanaged   class   IMetaDataImport         {}
unmanaged   class   IMetaDataEmit           {}
unmanaged   class   IMetaDataAssemblyImport {}
unmanaged   class   IMetaDataAssemblyEmit   {}
unmanaged   class   IMetaDataDebugEmit      {}
#endif
/*****************************************************************************/

#ifndef _HOST_H_
#include "host.h"
#endif

/*****************************************************************************/

inline
size_t              roundUp(size_t size, size_t mult = sizeof(int))
{
    // UNDONE: Check that 'mult' is a power of 2

    return  (size + (mult - 1)) & ~(mult - 1);
}

/*****************************************************************************/

#ifndef _TYPEDEFS_H_
#include "typedefs.h"
#endif

#ifndef _VARTYPE_H_
#include "vartype.h"
#endif

/*****************************************************************************/

#ifndef _HASH_H_
#include "hash.h"
#endif

#ifndef _ERRROR_H_
#include "error.h"
#endif

#ifndef _CONFIG_H_
#include "config.h"
#endif

#ifndef _PARSER_H_
#include "parser.h"
#endif

#ifndef _SYMBOL_H_
#include "symbol.h"
#endif

/*****************************************************************************
 *
 *  Data structures and helpers used to manipulate memory buffers and such.
 */

/*****************************************************************************/
#if MGDDATA
/*****************************************************************************/

inline
genericBuff         makeGenBuff(const void *addr, size_t size)
{
    UNIMPL(!"");
    return  null;
}

inline
stringBuff          makeStrBuff(const char *str)
{
    UNIMPL(!"");
    return  null;
}

/*****************************************************************************/

inline
memBuffPtr          memBuffMkNull()
{
    memBuffPtr n; n.buffBase = NULL; return n;
}

inline
bool                memBuffIsNull(memBuffPtr buff)
{
    return (buff.buffBase == NULL);
}

inline
void                memBuffCopy(INOUT memBuffPtr REF buff, genericBuff  dptr,
                                                           size_t       dlen)
{
    UNIMPL(!"copy array data");
}

inline
void                memBuffMove(INOUT memBuffPtr REF buff, size_t       dlen)
{
    buff.buffOffs += dlen;
}

/*****************************************************************************/
#else //MGDDATA
/*****************************************************************************/

inline
genericBuff         makeGenBuff(const void *addr, size_t size)
{
    return (BYTE*)addr;
}

inline
stringBuff          makeStrBuff(const char *str)
{
    return  (stringBuff)str;
}

inline
memBuffPtr          memBuffMkNull()
{
    return NULL;
}

inline
bool                memBuffIsNull(memBuffPtr buff)
{
    return !buff;
}

inline
void                memBuffCopy(INOUT memBuffPtr REF buff, genericBuff  dptr,
                                                           size_t       dlen)
{
    memcpy(buff, dptr, dlen);
           buff   +=   dlen;
}

inline
void                memBuffMove(INOUT memBuffPtr REF buff, size_t       dlen)
{
    buff += dlen;
}

/*****************************************************************************/
#endif//MGDDATA
/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\symbol.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _SYMBOL_H_
#define _SYMBOL_H_
/*****************************************************************************/
#ifndef _ALLOC_H_
#include "alloc.h"
#endif
/*****************************************************************************/
#ifndef _TYPE_H_
#include "type.h"
#endif
/*****************************************************************************/

struct DefSrcDsc
{
    scanPosTP       dsdBegPos;              // source filepos
    unsigned        dsdSrcLno;              // source line
//  unsigned        dsdSrcCol   :8;         // source column
};

const
unsigned            dlSkipBits = 16;
const
unsigned            dlSkipBig = (1 << (dlSkipBits - 1));

DEFMGMT
class DefListRec
{
public:

    DefList         dlNext;
    SymDef          dlComp;                 // containing comp-unit
    DefSrcDsc       dlDef;                  // where the symbol is defined
    UseList         dlUses;                 // list of "using" clauses

    unsigned        dlDeclSkip  :dlSkipBits;// typespec -> declarator "distance"
#ifdef  DEBUG
    unsigned        dlExtended  :1;         // is there a name/sym extension?
#endif
    unsigned        dlDefAcc    :3;         // default access level
    unsigned        dlHasBase   :1;         // class/interface: is there a base?
    unsigned        dlHasDef    :1;         // class/var/func : is there a body/init?
    unsigned        dlQualified :1;         // is the name a qualified one?
    unsigned        dlEarlyDecl :1;         // needs to be declared "early" ?
    unsigned        dlOldStyle  :1;         // old-style declaration?
    unsigned        dlIsCtor    :1;         // constructor member?
    unsigned        dlIsOvlop   :1;         // constructor member?
#ifdef  SETS
    unsigned        dlXMLelem   :1;         // XML element  member?
    unsigned        dlXMLelems  :1;         // XML elements member ("kids") ?
#endif
    unsigned        dlPrefixMods:1;         // prefix modifiers present?
    unsigned        dlAnonUnion :1;         // anonymous union member?
    unsigned        dlInstance  :1;         // instance of a generic type?
};

DEFMGMT
class MemListRec : public DefListRec
{
public:

    SymDef          mlSym;                  // symbol (if known)

    union
    {
        Ident           mlName;             // name of symbol (simple)
        QualName        mlQual;             // name of symbol (qualified)
    };
};

/*****************************************************************************/

DEFMGMT
class   IniListRec
{
public:
    IniList         ilNext;
    ExtList         ilInit;
    SymDef          ilCls;
};

/*****************************************************************************/

DEFMGMT class UseListRec
{
public:

    UseList         ulNext;

    bool            ulAll       :1;         // are we using all symbols?
    bool            ulBound     :1;         // chooses between the following 2
    bool            ulAnchor    :1;         // placeholder for a list?

    union
    {
        QualName        ulName;             // qualified name being used
        SymDef          ulSym;              // what symbol is being used
    }
        ul;
};

/*****************************************************************************/

DEFMGMT class SymListRec
{
public:

    SymList         slNext;
    SymDef          slSym;
};

DEFMGMT class TypListRec
{
public:

    TypList         tlNext;
    TypDef          tlType;
};

/*****************************************************************************/

struct bitFieldDsc
{
    unsigned char   bfWidth;
    unsigned char   bfOffset;
};

/*****************************************************************************/

enum ovlOpFlavors
{
    OVOP_NONE,

    OVOP_ADD,                               // operator +
    OVOP_SUB,                               // operator -
    OVOP_MUL,                               // operator *
    OVOP_DIV,                               // operator /
    OVOP_MOD,                               // operator %

    OVOP_OR,                                // operator |
    OVOP_XOR,                               // operator ^
    OVOP_AND,                               // operator &

    OVOP_LSH,                               // operator <<
    OVOP_RSH,                               // operator >>
    OVOP_RSZ,                               // operator >>>

    OVOP_CNC,                               // operator %%

    OVOP_EQ,                                // operator ==
    OVOP_NE,                                // operator !=

    OVOP_LT,                                // operator <
    OVOP_LE,                                // operator <=
    OVOP_GE,                                // operator >=
    OVOP_GT,                                // operator >

    OVOP_LOG_AND,                           // operator &&
    OVOP_LOG_OR,                            // operator ||

    OVOP_LOG_NOT,                           // operator !
    OVOP_NOT,                               // operator ~

    OVOP_NOP,                               // operator + (unary)
    OVOP_NEG,                               // operator - (unary)

    OVOP_INC,                               // operator ++
    OVOP_DEC,                               // operator --

    OVOP_ASG,                               // operator =

    OVOP_ASG_ADD,                           // operator +=
    OVOP_ASG_SUB,                           // operator -=
    OVOP_ASG_MUL,                           // operator *=
    OVOP_ASG_DIV,                           // operator /=
    OVOP_ASG_MOD,                           // operator %=

    OVOP_ASG_AND,                           // operator &=
    OVOP_ASG_XOR,                           // operator ^=
    OVOP_ASG_OR,                            // operator |=

    OVOP_ASG_LSH,                           // operator <<=
    OVOP_ASG_RSH,                           // operator >>=
    OVOP_ASG_RSZ,                           // operator >>>=

    OVOP_ASG_CNC,                           // operator %%=

    OVOP_CTOR_INST,                         // instance constructor
    OVOP_CTOR_STAT,                         // class    constructor

    OVOP_FINALIZER,                         // class    finalizer

    OVOP_CONV_IMP,                          // implicit conversion
    OVOP_CONV_EXP,                          // explicit conversion

    OVOP_EQUALS,                            // quality comparison
    OVOP_COMPARE,                           // full relational compare

    OVOP_PROP_GET,                          // property get
    OVOP_PROP_SET,                          // property set

    OVOP_COUNT,
};

/*****************************************************************************
 *
 *  Special methods such as constructors and overloaded operators are entered
 *  in the symbol table under the following special names.
 */

const   tokens      OPNM_CTOR_INST = tkLCurly;
const   tokens      OPNM_CTOR_STAT = tkSTATIC;

const   tokens      OPNM_FINALIZER = tkRCurly;

const   tokens      OPNM_CONV_IMP  = tkIMPLICIT;
const   tokens      OPNM_CONV_EXP  = tkEXPLICIT;

const   tokens      OPNM_EQUALS    = tkEQUALS;
const   tokens      OPNM_COMPARE   = tkCOMPARE;

const   tokens      OPNM_PROP_GET  = tkOUT;
const   tokens      OPNM_PROP_SET  = tkIN;

/*****************************************************************************
 *
 *  A descriptor for any symbol that is allowed to own other symbols (i.e. it
 *  can be a scope) must have a first field of the following type. This way,
 *  one can access these common scope-related members without having to always
 *  switch on the particular symbol kind (i.e. the location of these members
 *  is common for all symbols that contain them).
 */

struct scopeFields
{
    SymDef          sdsChildList;           // head of list of owned symbols
    SymDef          sdsChildLast;           // tail of list of owned symbols
};

/*****************************************************************************
 *
 *  Information about one formal/actual generic class argument is stored in
 *  the following descriptors.
 */

DEFMGMT
class   GenArgRec
{
public:
    GenArgDsc       gaNext;
#ifdef  DEBUG
    unsigned char   gaBound     :1;         // is this an actual (bound) arg?
#endif
};

DEFMGMT
class   GenArgRecF : public GenArgRec
{
public:
    Ident           gaName;                 // name
    SymDef          gaMsym;                 // member symbol created for the argument

    TypDef          gaBase;                 // bound: base class
    TypList         gaIntf;                 // bound: nterface(s)
};

DEFMGMT
class   GenArgRecA : public GenArgRec
{
public:
    TypDef          gaType;                 // actual type
};

/*****************************************************************************/

DEFMGMT class SymDefRec
{
public:

#ifndef  FAST
    Ident           sdName;                 // name of the symbol
    TypDef          sdType;                 // type of the symbol
#endif

    SymDef          sdParent;               // owning symbol

#ifndef FAST
    symbolKinds     sdSymKind;
    accessLevels    sdAccessLevel;
    name_space      sdNameSpace;
    compileStates   sdCompileState;
#else
    unsigned        sdSymKind           :8; // SYM_xxxx
    unsigned        sdAccessLevel       :3; // ACL_xxxx
    unsigned        sdNameSpace         :5; //  NS_xxxx (this is a mask)
    unsigned        sdCompileState      :4; //  CS_xxxx
#endif

    unsigned        sdIsDefined         :1; // has definition (e.g. fn body)
    unsigned        sdIsImport          :1; // comes from another program?

    unsigned        sdIsMember          :1; // member of a class?
    unsigned        sdIsImplicit        :1; // declared by compiler

    unsigned        sdIsVirtProp        :1; // properties: virtual ?
    unsigned        sdIsDfltProp        :1; // properties: default ?

    unsigned        sdReferenced        :1; // methods  , variables
    unsigned        sdRefDirect         :1; // methods  , variables
    unsigned        sdIsDeprecated      :1; // methods  , variables, classes

    unsigned        sdIsAbstract        :1; // methods  , classes
    unsigned        sdIsSealed          :1; // methods  , classes, fields, locals

    unsigned        sdIsStatic          :1; // variables, functions

    unsigned        sdIsManaged         :1; // classes  , namespaces
    unsigned        sdMemListOrder      :1; // classes  , namespaces

    unsigned        sdIsTransient       :1; // properties, fields

#ifdef  FAST
    Ident           sdName;                 // name of this symbol
    TypDef          sdType;                 // the type of this symbol
#endif

    symbolKinds     sdSymKindGet()
    {
        return  (symbolKinds)sdSymKind;
    }

    stringBuff      sdSpelling()
    {
        return  hashTab::identSpelling(sdName);
    }

    size_t          sdSpellLen()
    {
        return  hashTab::identSpellLen(sdName);
    }

    bool            sdHasScope()
    {
        return  (bool)(sdSymKind >= SYM_FIRST_SCOPED);
    }

    static
    bool            sdHasScope(symbolKinds symkind)
    {
        return  (bool)(  symkind >= SYM_FIRST_SCOPED);
    }

private:
    TypDef          sdTypeMake();
public:
    TypDef          sdTypeGet();
    SymTab          sdOwnerST();

    SymDef          sdNextDef;              // next definition in hash table
    SymDef          sdNextInScope;          // next symbol in the same scope

    DefList         sdSrcDefList;           // list of source definitions

    UNION(sdSymKind)
    {

    CASE(SYM_CLASS)     // class/interface symbol

        struct
        {
            /* This symbol owns scopes, the first field must be 'scopeFields' */

            scopeFields     sdScope;

            // maintain metadata token ordering

            SymDef          sdNextTypeDef;

            /* Here are the fields specific to this symbol kind */

            vectorSym       sdcOvlOpers;    // overloaded operator table (or NULL)

            ExtList         sdcMemDefList;  // list of member defs - head
            ExtList         sdcMemDefLast;  // list of member defs - tail

            mdTypeDef       sdcMDtypedef;   // definition metadata token (if known)
            mdTypeRef       sdcMDtypeImp;   // import     metadata token (if known)
            mdToken         sdcComTypeX;    // ComType    metadata token (if known)

            MetaDataImp     sdcMDimporter;  // imported from here

            SymDef          sdcDefProp;     // default property if present

            SymXinfo        sdcExtraInfo;   // linkage/security/etc. info

            SymDef          sdcVtableSym;   // vtable (unmanaged classes only)

#ifdef  SETS
            SymDef          sdcElemsSym;    // member holding "XML children/elements"
#endif

            unsigned        sdcVirtCnt  :16;// number of vtable slots used
            unsigned        sdcFlavor   :3; // union/struct/class/intf
            unsigned        sdcDefAlign :3; // #pragma pack value in effect
            unsigned        sdcOldStyle :1; // old-style syntax used for declaration
            unsigned        sdcNestTypes:1; // class has nested types (classes,enums,...)
            unsigned        sdcInstInit :1; // instance member initializers present?
            unsigned        sdcStatInit :1; // static   member initializers present?
            unsigned        sdcDeferInit:1; // deferred member initializers present?
            unsigned        sdcMarshInfo:1; // any member marshalling info present?
            unsigned        sdcAnonUnion:1; // is this an anonymous union?
            unsigned        sdcTagdUnion:1; // is this a  tagged    union?
            unsigned        sdc1stVptr  :1; // vtable ptr introduced?
            unsigned        sdcHasVptr  :1; // vtable ptr present?

            // DWORD boundary (watch out for packing!)

            unsigned        sdcAssemIndx:16;// assembly index (0 = none)
            unsigned        sdcAssemRefd:1; // assembly ref emitted yet?

#ifdef  SETS
            unsigned        sdcPODTclass:1; // is this a plain-old-data class?
            unsigned        sdcCollState:1; // collection state class
            unsigned        sdcXMLelems :1; // class contains XML elements
            unsigned        sdcXMLextend:1; // class contains XML extension (...)
#endif

            unsigned        sdcHasMeths :1; // methods present?
            unsigned        sdcHasBodies:1; // bodies for methods defined?
            unsigned        sdcHasLinks :1; // any methods have linkage specs?
            unsigned        sdcAttribute:1; // this is an attribute class
            unsigned        sdcAttrDupOK:1; // can be specified multiple times

            unsigned        sdcSrlzable :1; // class marked as "serializable" ?
            unsigned        sdcUnsafe   :1; // class marked as "unsafe"       ?

            unsigned        sdcBuiltin  :1; // "Delegate"
            unsigned        sdcMultiCast:1; // multicast delegate?

            unsigned        sdcAsyncDlg :1; // asynchronous delegate?

            unsigned        sdcGeneric  :1; // generic class?
            unsigned        sdcSpecific :1; // instance of a generic class?

            unsigned        sdcGenArg   :8; // generic class arg index or 0

            GenArgDsc       sdcArgLst;      // generic arguments (formal or actual)

            UNION(sdcGeneric)
            {
            CASE(true)
                SymList         sdcInstances;   // instances created so far

            CASE(false)
                SymDef          sdcGenClass;    // the "parent" generic type
            };
        }
                sdClass;

    CASE(SYM_NAMESPACE) // namespace

        struct
        {
            /* This symbol owns scopes, the first field must be 'scopeFields' */

            scopeFields     sdScope;

            /* Here are the fields specific to this symbol kind */

            SymTab          sdnSymtab;

            /* The list of global declarations */

            ExtList         sdnDeclList;
        }
                sdNS;

    CASE(SYM_ENUM)      // enum type

        struct
        {
            /* This symbol owns scopes, the first field must be 'scopeFields' */

            scopeFields     sdScope;

            // maintain metadata token ordering

            SymDef          sdNextTypeDef;

            /* Here are the fields specific to this symbol kind */

            MetaDataImp     sdeMDimporter;  // imported from here

            mdTypeDef       sdeMDtypedef;   // definition metadata token (if known)
            mdToken         sdeComTypeX;    // ComType    metadata token (if known)

            SymXinfo        sdeExtraInfo;   // custom attributes etc.

            mdTypeRef       sdeMDtypeImp;   // import     metadata token (if known)

            unsigned        sdeAssemIndx:16;// assembly index (0 = none)
            unsigned        sdeAssemRefd:1; // assembly ref emitted yet?

            // ......
        }
                sdEnum;

    CASE(SYM_GENARG)    // generic argument

        struct
        {
            bool            sdgaValue;      // value (as opposed to type) argument?
        }
                sdGenArg;

    CASE(SYM_SCOPE)     // scope

        struct
        {
            /* This symbol owns scopes, the first field must be 'scopeFields' */

            scopeFields     sdScope;

            /* Here are the fields specific to this symbol kind */

            int             sdSWscopeId;    // scope id for the scope

            ILblock         sdBegBlkAddr;
            size_t          sdBegBlkOffs;
            ILblock         sdEndBlkAddr;
            size_t          sdEndBlkOffs;
        }
                sdScope;

    CASE(SYM_COMPUNIT)  // compilation unit

        struct
        {
            /* Here are the fields specific to this symbol kind */

            stringBuff      sdcSrcFile;     // name of source file

            /* The source file token if debug info emitted */

            void    *       sdcDbgDocument;
        }
                sdComp;

    CASE(SYM_FNC)       // function member

        struct
        {
            /* This symbol owns scopes, the first field must be 'scopeFields' */

            scopeFields     sdScope;

            /* Here are the fields specific to this symbol kind */

            SymDef          sdfNextOvl;     // next overloaded fn

            SymDef          sdfGenSym;      // generic method this is an instance of

            SymXinfo        sdfExtraInfo;   // linkage/security/etc. info

            unsigned        sdfVtblx    :16;// vtable index (0 = not virtual)
            ovlOpFlavors    sdfOper     :8; // overloaded operator / ctor index
            unsigned        sdfConvOper :1; // conversion operator?
            unsigned        sdfCtor     :1; // constructor?
            unsigned        sdfProperty :1; // is this a property?
            unsigned        sdfNative   :1; // native import?
            unsigned        sdfIsIntfImp:1; // implements an interface method?
            unsigned        sdfDisabled :1; // conditionally disabled
            unsigned        sdfRThasDef :1; // the runtime provides the body
            unsigned        sdfInstance :1; // instance of a generic type

            unsigned        sdfImpIndex :6; // index of importer

            unsigned        sdfEntryPt  :1; // could be an entry point?
            unsigned        sdfExclusive:1;
            unsigned        sdfVirtual  :1;
            unsigned        sdfOverride :1;
            unsigned        sdfOverload :1;
            unsigned        sdfUnsafe   :1;
            unsigned        sdfBaseOvl  :1;
            unsigned        sdfBaseHide :1; // potentially hides base methods
            unsigned        sdfIntfImpl :1; // implements specific intf method

#ifdef  SETS
            unsigned        sdfFunclet  :1;
#endif

            SymDef          sdfIntfImpSym;  // interface method being implemented

            mdToken         sdfMDtoken;     // metadata token
            mdMemberRef     sdfMDfnref;     // metadata token (methodref)
        }
                sdFnc;

    CASE(SYM_VAR)       // variable (local or global) or data member

        struct
        {
            SymDef          sdvGenSym;      // generic member this is an instance of

            mdToken         sdvMDtoken;     // metadata token
            mdMemberRef     sdvMDsdref;     // import token (statics/globals only)

#ifdef  SETS
            Tree            sdvInitExpr;    // UNDONE: move someplace else !!!!
#endif

            unsigned        sdvLocal    :1; // local (auto) (including arguments)
            unsigned        sdvArgument :1; // local : is this an argument ?
            unsigned        sdvBitfield :1; // member: is this a  bitfield ?
            unsigned        sdvMgdByRef :1; // local :   managed  byref arg?
            unsigned        sdvUmgByRef :1; // local : unmanaged  byref arg?
            unsigned        sdvAllocated:1; // static: space been allocated?
            unsigned        sdvCanInit  :1; // static member that s/b initialized
            unsigned        sdvHadInit  :1; // have we found an initializer?
            unsigned        sdvConst    :1; // compile time constant?
            unsigned        sdvDeferCns :1; // const : hasn't been evaluated yet
            unsigned        sdvInEval   :1; // const : it's being evaluated right now
            unsigned        sdvMarshInfo:1; // marshalling info specified?
            unsigned        sdvAnonUnion:1; // member of an anonymous union?
            unsigned        sdvTagged   :1; // member of a  tagged    union?
            unsigned        sdvCatchArg :1; // catch() argument?
            unsigned        sdvChkInit  :1; // unitialized use possible?
            unsigned        sdvIsVtable :1; // fake symbol for unmanaged vtable?
            unsigned        sdvAddrTaken:1; // address has been taken?
            unsigned        sdvInstance :1; // instance of a generic type

#ifdef  SETS
            unsigned        sdvCollIter :1; // implicit collection iteration var
            unsigned        sdvXMLelem  :1; // XML element member
#endif

            /*
                For local variables 'sdvILindex' holds the MSIL slot number,
                which also serves as the index for initialization tracking.
                For managed static members the same field is used whenever
                initialization needs to be tracked.

                For unmanaged members 'sdvOffset' holds the offset (either
                within the instance (for non-static members) or within the
                .data section (for static members).

                For imported global variables 'sdvImpIndex' holds the index
                of the metadata importer where the variable came from.
             */

            union
            {
                unsigned        sdvILindex;
                unsigned        sdvOffset;
                unsigned        sdvImpIndex;
            };

            UNION(sdvConst)
            {
            CASE(true)

                ConstVal        sdvCnsVal;  // used for constants

            CASE(false)

                UNION(sdvBitfield)
                {
                CASE(true)
                    bitFieldDsc     sdvBfldInfo;// used for bitfields

                CASE(false)
                    SymXinfo        sdvFldInfo; // used for fields (marshalling, union tag, ...)
                };
            };
        }
                sdVar;

    CASE(SYM_PROP)      // property data member

        struct
        {
            SymDef          sdpGetMeth;     // the getter method (if present)
            SymDef          sdpSetMeth;     // the setter method (if present)
            SymDef          sdpNextOvl;     // next property with the same name
            mdToken         sdpMDtoken;     // metadata token

            SymXinfo        sdpExtraInfo;   // custom attributes / etc.
        }
                sdProp;

    CASE(SYM_LABEL)     // label

        struct
        {
            ILblock         sdlILlab;
#ifdef  OLD_IL
            mdToken         sdlMDtoken;
#endif
        }
                sdLabel;

    CASE(SYM_TYPEDEF)   // typedef

        struct
        {
            unsigned        sdtNothing;     // for now, no fields
        }
                sdTypeDef;

    CASE(SYM_USING)     // symbol import

        struct
        {
            SymDef          sduSym;
        }
                sdUsing;

    CASE(SYM_ENUMVAL)   // enumerator name

        struct
        {
            SymDef          sdeNext;        // next eval value in the type

            union
            {
                __int32         sdevIval;   // for type <= uint
                __int64 *       sdevLval;   // for type >= long
            }
                    sdEV;

            SymXinfo        sdeExtraInfo;   // custom attributes / etc.
        }
                sdEnumVal;

        /* The following is used only for sizing purposes */

    DEFCASE

        struct  {}     sdBase;
    };
};

/*****************************************************************************
 *
 *  IMPORTANT:  Please keep the contents of "symsizes.h" in synch with
 *              the declarations above!
 */

#include "symsizes.h"

/*****************************************************************************
 *
 *  Given a symbol that represents a type name, return its type (these are
 *  created in a "lazy" as-needed fashion).
 */

inline
TypDef              SymDefRec::sdTypeGet()
{
    if  (!sdType)
        sdTypeMake();

    return  sdType;
}

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\smcself.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

// Place any random declaratations that are only used for the self-compiled
// version here. Obviously, not much happening is here right now ....

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\tokens.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _TOKENS_H_
#define _TOKENS_H_
/*****************************************************************************
 *
 *  Define the token kind enum. Note that all entries from the keyword
 *  table are defined first, such that the first entry has the value 0.
 */

enum tokens
{
    /*
        tkKwdCount  yields the number of keyword table entries
        tkKwdLast   yields the last entry in the keyword table
     */

    #define KEYWORD(str, nam, info, prec2, op2, prec1, op1, mod) nam,
    #define KWD_MAX(str, nam, info, prec2, op2, prec1, op1, mod) nam, tkKwdCount, tkKwdLast = tkKwdCount-1,
    #define KWD_OP1(str, nam, info, prec2, op2, prec1, op1, mod) nam, tkFirstOper =nam,
    #include "keywords.h"

    tkCount,

    /* The following values only used for token recording */

    tkPragma,

    tkIntConM,
    tkIntCon0,
    tkIntCon1,
    tkIntCon2,
    tkIntConB,

    tkLnoAdd1,
    tkLnoAdd2,
    tkLnoAdd3,
    tkLnoAdd4,
    tkLnoAdd5,
    tkLnoAdd6,
    tkLnoAdd7,
    tkLnoAdd8,
    tkLnoAdd9,
    tkLnoAddB,
    tkLnoAddI,

    tkBrkSeq,
    tkEndSeq,

    tkLastValue,

    tkNoToken = 0x12345678          // force allocation of a full int
};

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\symsizes.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _SYMSIZES_H_
#define _SYMSIZES_H_
/*****************************************************************************/

const   size_t  symDef_size_base    = (offsetof(SymDefRec, sdBase       ));

const   size_t  symDef_size_err     = (offsetof(SymDefRec, sdBase       ));
const   size_t  symDef_size_var     = (size2mem(SymDefRec, sdVar        ));
const   size_t  symDef_size_fnc     = (size2mem(SymDefRec, sdFnc        ));
const   size_t  symDef_size_prop    = (size2mem(SymDefRec, sdProp       ));
const   size_t  symDef_size_label   = (size2mem(SymDefRec, sdLabel      ));
const   size_t  symDef_size_using   = (size2mem(SymDefRec, sdUsing      ));
const   size_t  symDef_size_genarg  = (size2mem(SymDefRec, sdGenArg     ));
const   size_t  symDef_size_enumval = (size2mem(SymDefRec, sdEnumVal    ));
const   size_t  symDef_size_typedef = (size2mem(SymDefRec, sdTypeDef    ));
const   size_t  symDef_size_comp    = (size2mem(SymDefRec, sdComp       ));

const   size_t  symDef_size_enum    = (size2mem(SymDefRec, sdEnum       ));
const   size_t  symDef_size_class   = (size2mem(SymDefRec, sdClass      ));
const   size_t  symDef_size_NS      = (size2mem(SymDefRec, sdNS         ));
const   size_t  symDef_size_scope   = (size2mem(SymDefRec, sdScope      ));

/*****************************************************************************/
#endif//_SYMSIZES_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\tree.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _TREE_H_
#define _TREE_H_
/*****************************************************************************/
#ifndef _TREEOPS_H_
#include "treeops.h"
#endif
/*****************************************************************************/

struct  TreeRec
{
};

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\tree.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include "parser.h"
#include "treeops.h"

/*****************************************************************************
 *
 *  The low-level tree node allocation routines.
 */

#ifndef FAST

Tree                parser::parseAllocNode()
{
    Tree            node;

    node = (Tree)parseAllocPriv.nraAlloc(sizeof(*node));

#ifdef  DEBUG
    node->tnLineNo = -1;
//  node->tnColumn = -1;
#endif

    return  node;
}

#endif

/*****************************************************************************
 *
 *  Allocate a parse tree node with the given operator.
 */

Tree                parser::parseCreateNode(treeOps op)
{
    Tree            tree = parseAllocNode();

#ifndef NDEBUG
    memset(tree, 0xDD, sizeof(*tree));
#endif

    tree->tnOper   = op;
    tree->tnFlags  = 0;

    tree->tnLineNo = parseScan->scanGetTokenLno();
//  tree->tnColumn = parseScan->scanGetTokenCol();

    return  tree;
}

/*****************************************************************************/

Tree                parser::parseCreateBconNode(int     val)
{
    Tree            node = parseCreateNode(TN_CNS_INT);

    node->tnVtyp             = TYP_BOOL;
    node->tnIntCon.tnIconVal = val;

    return  node;
}

Tree                parser::parseCreateIconNode(__int32 ival, var_types typ)
{
    Tree            node = parseCreateNode(TN_CNS_INT);

    node->tnVtyp             = typ;
    node->tnIntCon.tnIconVal = ival;

    if  (typ != TYP_UNDEF)
        return  node;

    node->tnOper = TN_ERROR;
    node->tnType = parseStab->stIntrinsicType(typ);

    return  node;
}

Tree                parser::parseCreateLconNode(__int64 lval, var_types typ)
{
    Tree            node = parseCreateNode(TN_CNS_LNG);

    assert(typ == TYP_LONG || typ == TYP_ULONG);

    node->tnVtyp             = typ;
    node->tnLngCon.tnLconVal = lval;

    return  node;
}

Tree                parser::parseCreateFconNode(float fval)
{
    Tree            node = parseCreateNode(TN_CNS_FLT);

    node->tnVtyp             = TYP_FLOAT;
    node->tnFltCon.tnFconVal = fval;

    return  node;
}

Tree                parser::parseCreateDconNode(double dval)
{
    Tree            node = parseCreateNode(TN_CNS_DBL);

    node->tnVtyp             = TYP_DOUBLE;
    node->tnDblCon.tnDconVal = dval;

    return  node;
}

Tree                parser::parseCreateSconNode(stringBuff  sval,
                                                size_t      slen,
                                                unsigned    type,
                                                int         wide,
                                                Tree        addx)
{
    Tree            node;
    size_t          olen;
    size_t          tlen;
    stringBuff      buff;
    unsigned        flag;

    static
    unsigned        tpfl[] =
    {
        0,
        TNF_STR_ASCII,
        TNF_STR_WIDE,
        TNF_STR_STR,
    };

    assert(type < arraylen(tpfl));

    flag = tpfl[type];

    if  (addx)
    {
        unsigned        oldf = addx->tnFlags & (TNF_STR_ASCII|TNF_STR_WIDE|TNF_STR_STR);

        assert(addx->tnOper == TN_CNS_STR);

        if  (flag != oldf)
        {
            if  (tpfl)
                parseComp->cmpError(ERRsyntax);
            else
                flag = oldf;
        }

        node = addx;
        olen = addx->tnStrCon.tnSconLen;
        tlen = slen + olen;
    }
    else
    {
        node = parseCreateNode(TN_CNS_STR);
        tlen = slen;
    }

#if MGDDATA

    UNIMPL(!"save str");

#else

    stringBuff      dest;

    buff = dest = (char *)parseAllocPriv.nraAlloc(roundUp(tlen + 1));

    if  (addx)
    {
        memcpy(dest, node->tnStrCon.tnSconVal, olen);
               dest               +=           olen;
    }

    memcpy(dest, sval, slen + 1);

#endif

    node->tnVtyp             = TYP_REF;
    node->tnStrCon.tnSconVal = buff;
    node->tnStrCon.tnSconLen = tlen;
    node->tnStrCon.tnSconLCH = wide;

    node->tnFlags |= flag;

    return  node;
}

Tree                 parser::parseCreateErrNode(unsigned errNum)
{
    Tree            node = parseCreateNode(TN_ERROR);

    if  (errNum != ERRnone) parseComp->cmpError(errNum);

    node->tnVtyp = TYP_UNDEF;
    node->tnType = parseStab->stIntrinsicType(TYP_UNDEF);

    return  node;
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************/

#ifndef __SMC__
const   char    *   treeNodeName(treeOps op);   // moved into macros.cpp
#endif

inline
void                treeNodeIndent(unsigned level)
{
    printf("%*c", 1+level*3, ' ');
}

void                parser::parseDispTreeNode(Tree tree, unsigned indent, const char *name)
{
    treeNodeIndent(indent);
    printf("[%08X] ", tree);

    if  (tree && tree->tnType
              && (NatUns)tree->tnType != 0xCCCCCCCC
              && (NatUns)tree->tnType != 0xDDDDDDDD
              && tree->tnOper != TN_LIST)
    {
        printf("(type=%s)", parseStab->stTypeName(tree->tnType, NULL));
    }

    assert(tree || name);

    if  (!name)
    {
        name = (tree->tnOper < TN_COUNT) ? treeNodeName(tree->tnOperGet())
                                         : "<ERROR>";
    }

    printf("%12s ", name);

    assert(tree == 0 || tree->tnOper < TN_COUNT);
}

void                parser::parseDispTree(Tree tree, unsigned indent)
{
    unsigned        kind;

    if  (tree == NULL)
    {
        treeNodeIndent(indent);
        printf("[%08X] <NULL>\n", tree);
        return;
    }

    assert((int)tree != 0xDDDDDDDD);    /* Value used to initalize nodes */

    /* Make sure we're not stuck in a recursive tree */

    assert(indent < 32);

    if  (tree->tnOper >= TN_COUNT)
    {
        parseDispTreeNode(tree, indent); NO_WAY(!"bogus operator");
    }

    kind = tree->tnOperKind();

    /* Is this a constant node? */

    if  (kind & TNK_CONST)
    {
        parseDispTreeNode(tree, indent);

        switch  (tree->tnOper)
        {
        case TN_CNS_INT: printf(" %ld" , tree->tnIntCon.tnIconVal); break;
        case TN_CNS_LNG: printf(" %Ld" , tree->tnLngCon.tnLconVal); break;
        case TN_CNS_FLT: printf(" %f"  , tree->tnFltCon.tnFconVal); break;
        case TN_CNS_DBL: printf(" %lf" , tree->tnDblCon.tnDconVal); break;
        case TN_CNS_STR: printf(" '%s'", tree->tnStrCon.tnSconVal); break;
        }

        printf("\n");
        return;
    }

    /* Is this a leaf node? */

    if  (kind & TNK_LEAF)
    {
        parseDispTreeNode(tree, indent);

        switch  (tree->tnOper)
        {
        case TN_NAME:
            printf("'%s'", tree->tnName.tnNameId->idSpelling());
            break;

        case TN_THIS:
        case TN_NULL:
        case TN_BASE:
        case TN_DBGBRK:
            break;

        default:
            NO_WAY(!"don't know how to display this leaf node");
        }

        printf("\n");
        return;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & TNK_SMPOP)
    {
        if  (tree->tnOp.tnOp2)
            parseDispTree(tree->tnOp.tnOp2, indent + 1);

        parseDispTreeNode(tree, indent);

        /* Check for a few special cases */

        switch (tree->tnOper)
        {
        case TN_NEW:
        case TN_CAST:
            if  (!(tree->tnFlags & TNF_BOUND))
                printf(" type='%s'", parseStab->stTypeName(tree->tnType, NULL));
            break;

#ifdef  SETS

        case TN_PROJECT:

            TypDef          clsTyp;
            TypDef          memTyp;
            SymDef          memSym;

            printf("\n");

            if  (tree->tnOp.tnOp1->tnVtyp == TYP_REF)
                clsTyp = tree->tnOp.tnOp1->tnType;
            else
                clsTyp = tree->            tnType;

            assert(clsTyp);

            if  (clsTyp->tdTypeKind == TYP_REF)
                clsTyp = clsTyp->tdRef.tdrBase;

            assert(clsTyp->tdTypeKind == TYP_CLASS);

            memTyp = parseComp->cmpIsCollection(clsTyp);
            if  (memTyp)
                clsTyp = memTyp;

            assert(clsTyp->tdTypeKind == TYP_CLASS);

            for (memSym = clsTyp->tdClass.tdcSymbol->sdScope.sdScope.sdsChildList;
                 memSym;
                 memSym = memSym->sdNextInScope)
            {
                if  (memSym->sdSymKind != SYM_VAR)
                    continue;
                if  (memSym->sdIsStatic)
                    continue;

                treeNodeIndent(indent+1);

                printf("%s", parseStab->stTypeName(memSym->sdType, memSym, NULL, NULL, false));

                if  (memSym->sdVar.sdvInitExpr)
                {
                    printf(" = \n");
                    parseDispTree(memSym->sdVar.sdvInitExpr, indent+2);
                }

                printf("\n");
            }

            assert(tree->tnOp.tnOp1);
            parseDispTree(tree->tnOp.tnOp1, indent + 1);
            return;

#endif

        default:
            break;
        }

        printf("\n");

        if  (tree->tnOp.tnOp1)
            parseDispTree(tree->tnOp.tnOp1, indent + 1);

        return;
    }

    /* See what kind of a special operator we have here */

    switch  (tree->tnOper)
    {
        Tree            name;
        Tree            init;

    case TN_BLOCK:

        if  (tree->tnBlock.tnBlkDecl)
            parseDispTree(tree->tnBlock.tnBlkDecl, indent + 1);

        parseDispTreeNode(tree, indent);
        printf(" parent=[%08X]", tree->tnBlock.tnBlkParent);
        printf( " decls=[%08X]", tree->tnBlock.tnBlkDecl  );
        printf("\n");

        if  (tree->tnBlock.tnBlkStmt)
            parseDispTree(tree->tnBlock.tnBlkStmt, indent + 1);

        break;

    case TN_VAR_DECL:

        init = NULL;
        name = tree->tnDcl.tnDclInfo;

        parseDispTreeNode(tree, indent);
        printf(" next=[%08X] ", tree->tnDcl.tnDclNext);

        if  (name)
        {
            if  (name->tnOper == TN_LIST)
            {
                init = name->tnOp.tnOp2;
                name = name->tnOp.tnOp1;
            }

            assert(name && name->tnOper == TN_NAME);

            printf("'%s'\n", name->tnName.tnNameId->idSpelling());

            if  (init)
                parseDispTree(init, indent + 1);
        }
        else
        {
            SymDef          vsym = tree->tnDcl.tnDclSym;

            assert(vsym && vsym->sdSymKind == SYM_VAR);

            printf("[sym=%08X] '%s'\n", vsym, vsym->sdSpelling());
        }

        break;

    case TN_FNC_SYM:
    case TN_FNC_PTR:

        if  (tree->tnFncSym.tnFncObj)
            parseDispTree(tree->tnFncSym.tnFncObj, indent + 1);

        parseDispTreeNode(tree, indent);
        printf("'%s'\n", tree->tnFncSym.tnFncSym->sdSpelling());

        if  (tree->tnFncSym.tnFncArgs)
            parseDispTree(tree->tnFncSym.tnFncArgs, indent + 1);
        return;

    case TN_LCL_SYM:

        parseDispTreeNode(tree, indent);
        if  (tree->tnLclSym.tnLclSym->sdIsImplicit)
            printf(" TEMP(%d)\n", tree->tnLclSym.tnLclSym->sdVar.sdvILindex);
        else
            printf(" sym='%s'\n", parseStab->stTypeName(NULL, tree->tnLclSym.tnLclSym, NULL, NULL, true));
        break;

    case TN_VAR_SYM:
    case TN_PROPERTY:

        if  (tree->tnVarSym.tnVarObj)
            parseDispTree(tree->tnVarSym.tnVarObj, indent + 1);

        parseDispTreeNode(tree, indent);
        printf(" sym='%s'\n", parseStab->stTypeName(NULL, tree->tnVarSym.tnVarSym, NULL, NULL, true));
        break;

    case TN_BFM_SYM:

        if  (tree->tnBitFld.tnBFinst)
            parseDispTree(tree->tnBitFld.tnBFinst, indent + 1);

        parseDispTreeNode(tree, indent);
        printf(" offs=%04X BF=[%u/%u] sym='%s'\n", tree->tnBitFld.tnBFoffs,
                                                   tree->tnBitFld.tnBFlen,
                                                   tree->tnBitFld.tnBFpos,
                                                   parseStab->stTypeName(NULL, tree->tnBitFld.tnBFmsym, NULL, NULL, true));
        break;

    case TN_ANY_SYM:

        parseDispTreeNode(tree, indent);
        printf(" sym='%s'\n", parseStab->stTypeName(NULL, tree->tnSym.tnSym, NULL, NULL, true));
        break;

    case TN_ERROR:

        parseDispTreeNode(tree, indent);
        printf("\n");
        break;

    case TN_SLV_INIT:
        parseDispTreeNode(tree, indent);
        printf(" at line #%u [offs=%04X]\n", tree->tnInit.tniSrcPos.dsdSrcLno,
                                             tree->tnInit.tniSrcPos.dsdBegPos);
        break;

    case TN_NONE:
        parseDispTreeNode(tree, indent);
        if  (tree->tnType)
            printf(" type='%s'", parseStab->stTypeName(tree->tnType, NULL));
        printf("\n");
        break;

    default:
        parseDispTreeNode(tree, indent);

        printf("<DON'T KNOW HOW TO DISPLAY THIS NODE>\n");
        return;
    }
}

/*****************************************************************************/
#endif//DEBUG
/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************/

SaveTree            compiler::cmpSaveTree_I1 (SaveTree    dest,
                                        INOUT size_t REF  size, __int32  val)
{
    assert((int)val >= -128 && (int)val < 128);

    if  (dest) *(*(BYTE    **)&dest)++ = (BYTE)val;

    size += 1;

    return  dest;
}

SaveTree            compiler::cmpSaveTree_U1 (SaveTree    dest,
                                        INOUT size_t REF  size, __uint32 val)
{
    assert((int)val >= 0 && (int)val < 0x100);

    if  (dest) *(*(BYTE    **)&dest)++ = val;

    size += 1;

    return  dest;
}

SaveTree            compiler::cmpSaveTree_U4 (SaveTree    dest,
                                        INOUT size_t REF  size, __uint32 val)
{
    if  (dest) *(*(__uint32**)&dest)++ = val;

    size += sizeof(__uint32);

    return  dest;
}

SaveTree            compiler::cmpSaveTree_ptr(SaveTree    dest,
                                        INOUT size_t REF  size, void *val)
{
    if  (dest) *(*(void*   **)&dest)++ = val;

    size += sizeof(void *);

    return  dest;
}

SaveTree            compiler::cmpSaveTree_buf(SaveTree    dest,
                                        INOUT size_t REF  size, void * dataAddr,
                                                                size_t dataSize)
{
    if  (dest)
    {
        memcpy(dest, dataAddr, dataSize);
               dest     +=     dataSize;
    }

    size += dataSize;

    return  dest;
}

size_t              compiler::cmpSaveTreeRec (Tree      expr,
                                              SaveTree  dest,
                                              unsigned *stszPtr,
                                              Tree     *stTable)
{
    unsigned        kind;
    treeOps         oper;

    size_t          size = 0;
    size_t          tsiz;

    // UNDONE: We need to check for side effects and do something !

AGAIN:

    /* Special case: record NULL expression as TN_ERROR */

    if  (expr == NULL)
    {
        dest = cmpSaveTree_U1(dest, size, TN_ERROR);
        return  size;
    }

    assert((int)expr         != 0xDDDDDDDD && (int)expr         != 0xCCCCCCCC);
    assert((int)expr->tnType != 0xDDDDDDDD && (int)expr->tnType != 0xCCCCCCCC);

    /* Get hold of the operator and its kind, flags, etc. */

    oper = expr->tnOperGet();
    kind = expr->tnOperKind();

    /* Save the node operator */

//  if  (dest) { printf("Save tree @ %08X: ", dest); cmpParser->parseDispTreeNode(expr, 0, NULL); printf("\n"); }

    dest = cmpSaveTree_U1(dest, size, oper);

    /* Save the type of the node */

    dest = cmpSaveTree_U1(dest, size, expr->tnVtyp);

    if  (expr->tnVtyp > TYP_lastIntrins)
        dest  = cmpSaveTree_ptr(dest, size, expr->tnType);

    /* Save the flags value */

    dest = cmpSaveTree_U4(dest, size, expr->tnFlags);

    /* Is this a constant node? */

    if  (kind & TNK_CONST)
    {
        switch  (oper)
        {
        case TN_NULL:
            break;

        case TN_CNS_INT:
            dest = cmpSaveTree_U4 (dest, size,        expr->tnIntCon.tnIconVal);
            break;

        case TN_CNS_LNG:
            dest = cmpSaveTree_buf(dest, size,       &expr->tnLngCon.tnLconVal,
                                               sizeof(expr->tnLngCon.tnLconVal));
            break;

        case TN_CNS_FLT:
            dest = cmpSaveTree_buf(dest, size,       &expr->tnFltCon.tnFconVal,
                                               sizeof(expr->tnFltCon.tnFconVal));
            break;

        case TN_CNS_DBL:
            dest = cmpSaveTree_buf(dest, size,       &expr->tnDblCon.tnDconVal,
                                               sizeof(expr->tnDblCon.tnDconVal));
            break;

        case TN_CNS_STR:
            dest = cmpSaveTree_U1 (dest, size,        expr->tnStrCon.tnSconLCH);
            dest = cmpSaveTree_U4 (dest, size,        expr->tnStrCon.tnSconLen);
            dest = cmpSaveTree_buf(dest, size,        expr->tnStrCon.tnSconVal,
                                                      expr->tnStrCon.tnSconLen);
            break;

        default:
            NO_WAY(!"unexpected constant node");
        }

        return  size;
    }

    /* Is this a leaf node? */

    if  (kind & TNK_LEAF)
    {
        switch  (oper)
        {
        case TN_NULL:
//          size += cmpSaveTree_U1(dest, TN_NULL);
            break;

        case TN_THIS:
        case TN_BASE:
        case TN_DBGBRK:

        default:
#ifdef  DEBUG
            cmpParser->parseDispTree(expr);
#endif
            UNIMPL(!"unexpected leaf operator in savetree");
        }

        return  size;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & TNK_SMPOP)
    {
        Tree            op1 = expr->tnOp.tnOp1;
        Tree            op2 = expr->tnOp.tnOp2;

        /* Check for a nested filter/sort expression */

        switch (oper)
        {
            collOpNest      nest;

            Tree            dcl;
            SymDef          var;

        case TN_ALL:
        case TN_SORT:
        case TN_FILTER:
        case TN_EXISTS:
        case TN_UNIQUE:

            assert(op1->tnOper == TN_LIST);
            dcl = op1->tnOp.tnOp1;
            assert(dcl->tnOper == TN_BLOCK);
            dcl = dcl->tnBlock.tnBlkDecl;
            assert(dcl && dcl->tnOper == TN_VAR_DECL);
            var = dcl->tnDcl.tnDclSym;

            /* Save the name and type of the iteration variable */

            dest = cmpSaveTree_ptr(dest, size, var->sdName);
            dest = cmpSaveTree_ptr(dest, size, var->sdType);

            /* Record the collection expression */

            tsiz = cmpSaveTreeRec(op1->tnOp.tnOp2,
                                  dest,
                                  stszPtr,
                                  stTable);

            size += tsiz;
            if  (dest)
                dest += tsiz;

            /* Add an entry to the collection operator list */

            nest.conIndex   = ++cmpCollOperCount;
            nest.conIterVar = var;
            nest.conOuter   = cmpCollOperList;
                              cmpCollOperList = &nest;

            /* Record the filter expression */

            tsiz = cmpSaveTreeRec(op2,
                                  dest,
                                  stszPtr,
                                  stTable);

            size += tsiz;
            if  (dest)
                dest += tsiz;

            /* Remove our entry from the collection list */

            cmpCollOperList = nest.conOuter;

            return  size;
        }

        tsiz  = cmpSaveTreeRec(op1, dest, stszPtr, stTable);

        size += tsiz;
        if  (dest)
            dest += tsiz;

        expr  = op2;

        goto AGAIN;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        SymDef          sym;

    case TN_FNC_SYM:

        dest  = cmpSaveTree_ptr(dest, size, expr->tnFncSym.tnFncSym);

        tsiz  = cmpSaveTreeRec(expr->tnFncSym.tnFncObj,
                               dest,
                               stszPtr,
                               stTable);

        size += tsiz;
        if  (dest)
            dest += tsiz;

        expr = expr->tnFncSym.tnFncArgs;
        goto AGAIN;

    case TN_LCL_SYM:

        /*
            This is either a reference to the iteration variable,
            or something we need to capture as iteration "state".
         */

        sym = expr->tnLclSym.tnLclSym;

        assert(sym && sym->sdSymKind == SYM_VAR && sym->sdVar.sdvLocal);

        if  (sym->sdVar.sdvCollIter)
        {
            unsigned        itr;
            unsigned        cnt = abs(cmpSaveIterSymCnt);

            collOpList      nest;

            /* Look for a match against the table of iteration variables */

            for (itr = 0; itr < cnt; itr++)
            {
                if  (sym == cmpSaveIterSymTab[itr])
                {
                    if  (cmpSaveIterSymCnt < 0)
                    {
                        UNIMPL("ref to source array entry");
                    }
                    else
                    {
                        assert(itr < MAX_ITER_VAR_CNT);

                        // need to distinguish one vs. two-state case

                        if  (cmpSaveIterSymCnt == 2)
                            itr++;

//                      if (dest) printf("Save %2u '%s'\n", itr, sym->sdName ? sym->sdSpelling() : "<NONE>");

                        dest = cmpSaveTree_I1(dest, size, itr);
                    }

                    return  size;
                }
            }

            /* Look for any outer iteration variables */

            for (nest = cmpCollOperList; nest; nest = nest->conOuter)
            {
                if  (nest->conIterVar == sym)
                {
//                  if (dest) printf("Save %2d '%s'\n", -nest->conIndex, sym->sdName ? sym->sdSpelling() : "<NONE>");
                    dest = cmpSaveTree_I1(dest, size, -nest->conIndex);
                    break;
                }
            }

            assert(nest && "nested iter var entry not found");
        }
        else
        {
            unsigned        index = *stszPtr;

            /* We need to capture this expression in the iteration state */

            if  (expr->tnVtyp == TYP_REF)
            {
//              printf("We have a GC-ref: index = %u\n", index);

                if  ((index & 1) == 0)
                    index++;
            }
            else
            {
//              printf("We have a non-GC: index = %u\n", index);

                if  ((index & 1) != 0)
                    index++;
            }

            *stszPtr = index + 1;

            if  (dest)
            {
                stTable[index] = expr;

#ifdef  DEBUG
//              printf("Store expr as state #%u -> %u\n", index, index+5);
//              cmpParser->parseDispTree(expr);
//              printf("\n");
#endif
            }

//          if (dest) printf("Save %2u\n", index + MAX_ITER_VAR_CNT);

            dest = cmpSaveTree_I1(dest, size, index + MAX_ITER_VAR_CNT);
        }

        return  size;

    case TN_VAR_SYM:
    case TN_PROPERTY:

        dest = cmpSaveTree_ptr(dest, size, expr->tnVarSym.tnVarSym);
        expr = expr->tnVarSym.tnVarObj;
        goto AGAIN;

    case TN_NONE:
        break;

    case TN_ANY_SYM:
    case TN_BFM_SYM:

    case TN_ERROR:
    case TN_SLV_INIT:
    case TN_FNC_PTR:

    case TN_VAR_DECL:
    case TN_BLOCK:

    default:
#ifdef  DEBUG
        cmpParser->parseDispTree(expr);
#endif
        UNIMPL(!"unexpected operator in savetree");
    }

    return  size;
}

SaveTree            compiler::cmpSaveExprTree(Tree        expr,
                                              unsigned    iterSymCnt,
                                              SymDef    * iterSymTab,
                                              unsigned  * stSizPtr,
                                              Tree    * * stTabPtr)
{
    size_t          saveSize;
    size_t          saveTemp;
    SaveTree        saveAddr;

    unsigned        stateCnt = 0;
    unsigned        stateTmp = 0;

    /* This routine is not intended to be re-entrant! */

    assert(cmpCollOperList == NULL); cmpCollOperCount = 0;

    /* Note the iteration variable symbols */

    cmpSaveIterSymCnt = iterSymCnt;
    cmpSaveIterSymTab = iterSymTab;

    /* First compute the size needed to save the expr */

    saveSize = cmpSaveTreeRec(expr, NULL, &stateCnt, NULL);

    /* Allocate space for the saved tree */

#if MGDDATA
    saveAddr = new BYTE[saveSize];
#else
    saveAddr = (SaveTree)cmpAllocPerm.nraAlloc(roundUp(saveSize));
#endif

    /* Allocate the state vector, if non-empty */

#if MGDDATA
    Tree    []      stateTab = NULL;
#else
    Tree    *       stateTab = NULL;
#endif

    if  (stateCnt)
    {
        unsigned        totalCnt = stateCnt + (stateCnt & 1);
        size_t          stateSiz = totalCnt*sizeof(*stateTab);

#if MGDDATA
        stateTab = new Tree[totalCnt];
#else
        stateTab =    (Tree*)cmpAllocPerm.nraAlloc(stateSiz);
#endif

        memset(stateTab, 0, stateSiz);
    }

    /* Now save the tree in the block we've allocated */

    assert(cmpCollOperList == NULL); cmpCollOperCount = 0;
    saveTemp = cmpSaveTreeRec(expr, saveAddr, &stateTmp, stateTab);
    assert(cmpCollOperList == NULL);

    /* Make sure the predicted size matched the actual size stored */

    assert(saveSize == saveTemp);

    /* Return all the values to the caller */

    *stSizPtr = stateCnt;
    *stTabPtr = stateTab;

    return  saveAddr;
}

int                 compiler::cmpReadTree_I1 (INOUT SaveTree REF save)
{
    return  *(*(signed char **)&save)++;
}

unsigned            compiler::cmpReadTree_U1 (INOUT SaveTree REF save)
{
    return  *(*(BYTE        **)&save)++;
}

unsigned            compiler::cmpReadTree_U4 (INOUT SaveTree REF save)
{
    return  *(*(__uint32    **)&save)++;
}

void    *           compiler::cmpReadTree_ptr(INOUT SaveTree REF save)
{
    return  *(*(void *      **)&save)++;
}

void                compiler::cmpReadTree_buf(INOUT SaveTree REF save,
                                                    size_t       dataSize,
                                                    void *       dataAddr)
{
    memcpy(dataAddr, save ,  dataSize);
                     save += dataSize;
}

Tree                compiler::cmpReadTreeRec (INOUT SaveTree REF save)
{
    Tree            expr;

    unsigned        kind;
    treeOps         oper;

    var_types       vtyp;
    TypDef          type;

//  printf("Read %02X at %08X\n", *save, save);

    /* Read the operator and check for TN_ERROR (which stands for NULL) */

    oper = (treeOps)cmpReadTree_U1(save);

    if  (oper == TN_ERROR)
        return  NULL;

    /* Read the type of the node */

    vtyp = (var_types)cmpReadTree_U1(save);

    if  (vtyp <= TYP_lastIntrins)
        type = cmpGlobalST->stIntrinsicType(vtyp);
    else
        type = (TypDef)cmpReadTree_ptr(save);

    /* Create the expression node */

    expr = cmpCreateExprNode(NULL, oper, type);

    /* Read the flags value */

    expr->tnFlags = cmpReadTree_U4(save);

    /* See what kind of a node we've got */

    kind = expr->tnOperKind();

    /* Is this a constant node? */

    if  (kind & TNK_CONST)
    {
        switch  (oper)
        {
            char    *       sval;
            size_t          slen;

        case TN_NULL:
            break;

        case TN_CNS_INT:
            expr->tnIntCon.tnIconVal = cmpReadTree_U4(save);
            break;

        case TN_CNS_LNG:
            cmpReadTree_buf(save, sizeof(expr->tnLngCon.tnLconVal),
                                        &expr->tnLngCon.tnLconVal);
            break;

        case TN_CNS_FLT:
            cmpReadTree_buf(save, sizeof(expr->tnFltCon.tnFconVal),
                                        &expr->tnFltCon.tnFconVal);
            break;

        case TN_CNS_DBL:
            cmpReadTree_buf(save, sizeof(expr->tnDblCon.tnDconVal),
                                        &expr->tnDblCon.tnDconVal);
            break;

        case TN_CNS_STR:

            expr->tnStrCon.tnSconLCH =        cmpReadTree_U1(save);
            expr->tnStrCon.tnSconLen = slen = cmpReadTree_U4(save);
            expr->tnStrCon.tnSconVal = sval = (char*)cmpAllocCGen.nraAlloc(roundUp(slen+1));

            cmpReadTree_buf(save, slen, sval);
            break;

        default:
            NO_WAY(!"unexpected constant node");
        }

        return  expr;
    }

    /* Is this a leaf node? */

    if  (kind & TNK_LEAF)
    {
        switch  (oper)
        {
        case TN_NULL:
            break;

        case TN_THIS:
        case TN_BASE:
        case TN_DBGBRK:

        default:
#ifdef  DEBUG
            cmpParser->parseDispTree(expr);
#endif
            UNIMPL(!"unexpected leaf operator in readtree");
        }

        return  expr;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & TNK_SMPOP)
    {
        /* Check for a nested filter/sort expression */

        switch (oper)
        {
            collOpNest      nest;

            Ident           name;
            TypDef          vtyp;

            Tree            coll;
            Tree            decl;
            Tree            vdcl;
            SymDef          vsym;

        case TN_ALL:
        case TN_SORT:
        case TN_FILTER:
        case TN_EXISTS:
        case TN_UNIQUE:

            /* Read the name and type of the iteration variable */

            name = (Ident )cmpReadTree_ptr(save);
            vtyp = (TypDef)cmpReadTree_ptr(save);

            /* Read the collection expression */

            coll = cmpReadTreeRec(save);

            /* Create a new scope symbol for the filter */

            cmpCurScp = cmpGlobalST->stDeclareLcl(NULL,
                                                  SYM_SCOPE,
                                                  NS_HIDE,
                                                  cmpCurScp,
                                                  &cmpAllocCGen);

            /* Declare a symbol for the iteration variable */

            vsym      = cmpGlobalST->stDeclareLcl(name,
                                                  SYM_VAR,
                                                  NS_NORM,
                                                  cmpCurScp,
                                                  &cmpAllocCGen);

            vsym->sdType            = vtyp;
            vsym->sdIsImplicit      = true;
            vsym->sdIsDefined       = true;
            vsym->sdVar.sdvLocal    = true;
            vsym->sdVar.sdvCollIter = true;
            vsym->sdCompileState    = CS_DECLARED;

            /* Create a declaration node for the iteration variable */

            vdcl = cmpCreateExprNode(NULL, TN_VAR_DECL, vtyp);

            vdcl->tnDcl.tnDclSym    = vsym;
            vdcl->tnDcl.tnDclInfo   = NULL;
            vdcl->tnDcl.tnDclNext   = NULL;

            /* Create a new block scope tree node */

            decl = cmpCreateExprNode(NULL, TN_BLOCK, cmpTypeVoid);

            decl->tnBlock.tnBlkStmt   = NULL;
            decl->tnBlock.tnBlkDecl   = vdcl;
            decl->tnBlock.tnBlkParent = NULL;

            /* Add an entry to the collection operator list */

            nest.conIndex    = ++cmpCollOperCount;
            nest.conIterVar  = vsym;
            nest.conOuter    = cmpCollOperList;
                               cmpCollOperList = &nest;

            /* Store the declaration/collection expr in the filter node */

            expr->tnOp.tnOp1 = cmpCreateExprNode(NULL,
                                                 TN_LIST,
                                                 cmpTypeVoid, decl,
                                                              coll);

            /* Read the filter expression */

            expr->tnOp.tnOp2 = cmpReadTreeRec(save);

            /* Remove our entries from the collection and scope lists */

            cmpCollOperList = nest.conOuter;
            cmpCurScp       = cmpCurScp->sdParent;

            return  expr;
        }

        expr->tnOp.tnOp1 = cmpReadTreeRec(save);
        expr->tnOp.tnOp2 = cmpReadTreeRec(save);

        return  expr;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        int             index;
        Ident           name;
        SymDef          sym;

    case TN_LCL_SYM:

        index = cmpReadTree_I1(save);

        if  (index < 0)
        {
            collOpList      nest;

            /* This is a nested filter iteration variable reference */

            for (nest = cmpCollOperList; nest; nest = nest->conOuter)
            {
                if  (nest->conIndex == -index)
                {
                    expr->tnLclSym.tnLclSym = nest->conIterVar;
                    break;
                }
            }

            assert(nest && "nested iter var entry not found");

            break;
        }

        if  (index >= MAX_ITER_VAR_CNT)
        {
            /* This is a state variable reference */

            name = cmpIdentCSstate;

            if  (!name)
                 name = cmpIdentCSstate = cmpGlobalHT->hashString(CFC_ARGNAME_STATE);
        }
        else
        {
            /* This is a reference to the iteration variable itself */

            switch (index)
            {
            case 0:
                name = cmpIdentCSitem;
                if  (!name)
                     name = cmpIdentCSitem  = cmpGlobalHT->hashString(CFC_ARGNAME_ITEM);
                break;

            case 1:
                name = cmpIdentCSitem1;
                if  (!name)
                     name = cmpIdentCSitem1 = cmpGlobalHT->hashString(CFC_ARGNAME_ITEM1);
                break;

            case 2:
                name = cmpIdentCSitem2;
                if  (!name)
                     name = cmpIdentCSitem2 = cmpGlobalHT->hashString(CFC_ARGNAME_ITEM2);
                break;

            default:
                NO_WAY(!"unexpected local variable index");
            }
        }

        /* Find the argument symbol */

        sym = cmpGlobalST->stLookupSym(name, NS_NORM);

//      printf("Read %2u '%s'\n", index, sym ? (sym->sdName ? sym->sdSpelling() : "<NONE>") : "!NULL!");

        assert(sym && sym->sdSymKind == SYM_VAR && sym->sdVar.sdvLocal);

        /* Store the argument symbol in the expression */

        expr->tnLclSym.tnLclSym = sym;

        /* We have to do more work if this is a state variable */

        if  (index >= MAX_ITER_VAR_CNT)
        {
            TypDef          typ;
            SymDef          fsym;
            Tree            fldx;
            char            name[16];

            /* Make sure the state variable expression has the proper type */

            expr->tnVtyp = TYP_REF;
            expr->tnType = sym->sdType;

            /* Find the appropriate entry in the state descriptor */

            typ = sym->sdType;        assert(typ->tdTypeKind == TYP_REF);
            typ = typ->tdRef.tdrBase; assert(typ->tdTypeKind == TYP_CLASS);

            /* Look for the appropriate state variable */

            sprintf(name, "$V%u", index - MAX_ITER_VAR_CNT);

            fsym = cmpGlobalST->stLookupClsSym(cmpGlobalHT->hashString(name),
                                               typ->tdClass.tdcSymbol);

            assert(fsym && fsym->sdSymKind == SYM_VAR);

            /* Create the expression that will fetch the member value */

            fldx = cmpCreateExprNode(NULL, TN_VAR_SYM, type);
            fldx->tnVarSym.tnVarSym  = fsym;
            fldx->tnVarSym.tnVarObj  = expr;

//          printf("Revive #%u\n", index); cmpParser->parseDispTree(fldx); printf("\n");

            return  fldx;
        }
        break;

    case TN_VAR_SYM:
    case TN_PROPERTY:

        expr->tnVarSym.tnVarSym  = (SymDef)cmpReadTree_ptr(save);
        expr->tnVarSym.tnVarObj  = cmpReadTreeRec(save);
        break;

    case TN_FNC_SYM:

        expr->tnFncSym.tnFncSym  = (SymDef)cmpReadTree_ptr(save);
        expr->tnFncSym.tnFncObj  = cmpReadTreeRec(save);
        expr->tnFncSym.tnFncArgs = cmpReadTreeRec(save);
        break;

    case TN_NONE:
        break;

    default:
#ifdef  DEBUG
        cmpParser->parseDispTree(expr);
#endif
        UNIMPL(!"unexpected operator in readtree");
    }

    return  expr;
}

Tree                compiler::cmpReadExprTree(SaveTree save, unsigned *lclCntPtr)
{
    Tree            expr;

    cmpCollOperCount = 0;

    assert(cmpCollOperList == NULL);
    expr = cmpReadTreeRec(save);
    assert(cmpCollOperList == NULL);

    *lclCntPtr = cmpCollOperCount;

//  cmpParser->parseDispTree(expr);
//  printf("\n\n");

    return  expr;
}

Tree                compiler::cmpCloneExpr(Tree expr, SymDef oldSym,
                                                      SymDef newSym)
{
    unsigned        kind;
    treeOps         oper;
    Tree            copy;

    if  (!expr)
        return  expr;

    assert((int)expr != 0xDDDDDDDD && (int)expr != 0xCCCCCCCC);

    /* Get hold of the operator and its kind, flags, etc. */

    oper = expr->tnOperGet();
    kind = expr->tnOperKind();

    /* Create a copy of the node */

    copy = cmpCreateExprNode(NULL, oper, expr->tnType);
    copy->tnFlags = expr->tnFlags;

    /* Is this a constant node? */

    if  (kind & TNK_CONST)
    {
        switch  (oper)
        {
        case TN_NULL:
            break;

        case TN_CNS_INT: copy->tnIntCon.tnIconVal = expr->tnIntCon.tnIconVal; break;
        case TN_CNS_LNG: copy->tnLngCon.tnLconVal = expr->tnLngCon.tnLconVal; break;
        case TN_CNS_FLT: copy->tnFltCon.tnFconVal = expr->tnFltCon.tnFconVal; break;
        case TN_CNS_DBL: copy->tnDblCon.tnDconVal = expr->tnDblCon.tnDconVal; break;
        case TN_CNS_STR: UNIMPL(!"copy CNS_STR expr node"); break;

        default:
            NO_WAY(!"unexpected constant node");
        }

        return  copy;
    }

    /* Is this a leaf node? */

    if  (kind & TNK_LEAF)
        return  copy;

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & TNK_SMPOP)
    {
        copy->tnOp.tnOp1 = cmpCloneExpr(expr->tnOp.tnOp1, oldSym, newSym);
        copy->tnOp.tnOp2 = cmpCloneExpr(expr->tnOp.tnOp2, oldSym, newSym);

        return  copy;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        SymDef          sym;

    case TN_NONE:
        break;

    case TN_LCL_SYM:

        /* Check for a reference to the substitution variable */

        sym = expr->tnLclSym.tnLclSym;

        assert(sym && sym->sdSymKind == SYM_VAR && sym->sdVar.sdvLocal);

        if  (sym == oldSym)
            sym = newSym;

        copy->tnLclSym.tnLclSym = sym;
        break;

    case TN_VAR_SYM:
    case TN_PROPERTY:

        copy->tnVarSym.tnVarSym = expr->tnVarSym.tnVarSym;
        copy->tnVarSym.tnVarObj = cmpCloneExpr(expr->tnVarSym.tnVarObj, oldSym, newSym);
        break;

    case TN_FNC_SYM:

        copy->tnFncSym.tnFncSym = expr->tnFncSym.tnFncSym;
        copy->tnFncSym.tnFncObj = cmpCloneExpr(expr->tnFncSym.tnFncObj , oldSym, newSym);
        copy->tnFncSym.tnFncArgs= cmpCloneExpr(expr->tnFncSym.tnFncArgs, oldSym, newSym);

        break;

    case TN_ANY_SYM:
    case TN_BFM_SYM:

    case TN_ERROR:
    case TN_SLV_INIT:
    case TN_FNC_PTR:

    case TN_VAR_DECL:
    case TN_BLOCK:

    default:
#ifdef  DEBUG
        cmpParser->parseDispTree(expr);
#endif
        UNIMPL(!"unexpected operator in clonetree");
    }

    return  copy;
}

/*****************************************************************************/
#endif//SETS
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\toplist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef TREEOP
#error  Define TREEOP before including this file.
#endif
/*****************************************************************************/
//
//    Node enum
//                   , token
//                            ,  "Node name"
//
//
//                                            ,ILcode
//                                                       ,operator precedence
//                                                          ,operKind

TREEOP(TN_ERROR      , tkNone,   "error"      ,CEE_NOP   , 0,TNK_NONE)
TREEOP(TN_NONE       , tkNone,   "<none>"     ,CEE_NOP   , 0,TNK_NONE)

//-----------------------------------------------------------------------------
//  Leaf nodes (i.e. these nodes have no sub-operands):
//-----------------------------------------------------------------------------

TREEOP(TN_NAME       , tkNone,   "name"       ,CEE_NOP   , 0,TNK_LEAF)
TREEOP(TN_THIS       , tkNone,   "this"       ,CEE_NOP   , 0,TNK_LEAF)
TREEOP(TN_BASE       , tkNone,   "base"       ,CEE_NOP   , 0,TNK_LEAF)
TREEOP(TN_DBGBRK     , tkNone,   "debugbreak" ,CEE_NOP   , 0,TNK_LEAF)

//-----------------------------------------------------------------------------
//  Constant nodes:
//-----------------------------------------------------------------------------

TREEOP(TN_CNS_INT    , tkNone,   "int const"  ,CEE_NOP   , 0,TNK_LEAF|TNK_CONST)
TREEOP(TN_CNS_LNG    , tkNone,   "lng const"  ,CEE_NOP   , 0,TNK_LEAF|TNK_CONST)
TREEOP(TN_CNS_FLT    , tkNone,   "flt const"  ,CEE_NOP   , 0,TNK_LEAF|TNK_CONST)
TREEOP(TN_CNS_DBL    , tkNone,   "dbl const"  ,CEE_NOP   , 0,TNK_LEAF|TNK_CONST)
TREEOP(TN_CNS_STR    , tkNone,   "str const"  ,CEE_NOP   , 0,TNK_LEAF|TNK_CONST)
TREEOP(TN_NULL       , tkNone,   "null"       ,CEE_NOP   , 0,TNK_LEAF|TNK_CONST)

//-----------------------------------------------------------------------------
//  Unary  operators (0 or 1 operands):
//-----------------------------------------------------------------------------

TREEOP(TN_ADDROF     , tkAnd,    "&"          ,CEE_NOP   ,14,TNK_UNOP)

TREEOP(TN_NOT        , tkTilde,  "~"          ,CEE_NOP   ,14,TNK_UNOP)
TREEOP(TN_LOG_NOT    , tkBang,   "!"          ,CEE_NOP   ,14,TNK_UNOP)
TREEOP(TN_NOP        , tkAdd,    "unary +"    ,CEE_NOP   ,14,TNK_UNOP)
TREEOP(TN_NEG        , tkSub,    "unary -"    ,CEE_NOP   ,14,TNK_UNOP)
TREEOP(TN_THROW      , tkNone,   "throw"      ,CEE_NOP   ,14,TNK_UNOP)

TREEOP(TN_INC_POST   , tkInc,    "++ post"    ,CEE_NOP   ,14,TNK_UNOP)
TREEOP(TN_DEC_POST   , tkDec,    "-- post"    ,CEE_NOP   ,14,TNK_UNOP)
TREEOP(TN_INC_PRE    , tkInc,    "++ pre"     ,CEE_NOP   ,14,TNK_UNOP)
TREEOP(TN_DEC_PRE    , tkDec,    "-- pre"     ,CEE_NOP   ,14,TNK_UNOP)

TREEOP(TN_TYPE       , tkNone,   "<type>"     ,CEE_NOP   , 0,TNK_UNOP)
TREEOP(TN_TOKEN      , tkNone,   "<token>"    ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_INST_STUB  , tkNone,   "inst-stub"  ,CEE_NOP   , 0,TNK_UNOP)

//-----------------------------------------------------------------------------
//  Binary operators (2 operands):
//-----------------------------------------------------------------------------

TREEOP(TN_ADD        , tkAdd,    "+"          ,CEE_ADD   ,12,TNK_BINOP)
TREEOP(TN_SUB        , tkSub,    "-"          ,CEE_SUB   ,12,TNK_BINOP)
TREEOP(TN_MUL        , tkMul,    "*"          ,CEE_MUL   ,13,TNK_BINOP)
TREEOP(TN_DIV        , tkDiv,    "/"          ,CEE_DIV   ,13,TNK_BINOP)
TREEOP(TN_MOD        , tkPct,    "%"          ,CEE_REM   ,13,TNK_BINOP)

TREEOP(TN_AND        , tkAnd,    "&"          ,CEE_AND   , 7,TNK_BINOP|TNK_LOGOP)
TREEOP(TN_XOR        , tkXor,    "^"          ,CEE_XOR   , 7,TNK_BINOP|TNK_LOGOP)
TREEOP(TN_OR         , tkOr ,    "|"          ,CEE_OR    , 6,TNK_BINOP|TNK_LOGOP)

TREEOP(TN_LSH        , tkLsh,    "<<"         ,CEE_NOP   ,11,TNK_BINOP)
TREEOP(TN_RSH        , tkRsh,    ">>"         ,CEE_NOP   ,11,TNK_BINOP)
TREEOP(TN_RSZ        , tkRsz,    ">>>"        ,CEE_NOP   ,11,TNK_BINOP)

TREEOP(TN_EQ         , tkEQ,     "=="         ,CEE_BEQ   , 9,TNK_BINOP|TNK_RELOP)
TREEOP(TN_NE         , tkNE,     "!="         ,CEE_BNE_UN, 9,TNK_BINOP|TNK_RELOP)
TREEOP(TN_LT         , tkLT,     "<"          ,CEE_BLT   ,10,TNK_BINOP|TNK_RELOP)
TREEOP(TN_LE         , tkLE,     "<="         ,CEE_BLE   ,10,TNK_BINOP|TNK_RELOP)
TREEOP(TN_GE         , tkGE,     ">="         ,CEE_BGE   ,10,TNK_BINOP|TNK_RELOP)
TREEOP(TN_GT         , tkGT,     ">"          ,CEE_BGT   ,10,TNK_BINOP|TNK_RELOP)

// NOTE: The "op=" varieties must appear in the same order as "op" above

TREEOP(TN_ASG        , tkAsg,    "="          ,CEE_NOP   , 2,TNK_BINOP|TNK_ASGOP)
TREEOP(TN_ASG_ADD    , tkAsgAdd, "+="         ,CEE_ADD   , 2,TNK_BINOP|TNK_ASGOP)
TREEOP(TN_ASG_SUB    , tkAsgSub, "-="         ,CEE_SUB   , 2,TNK_BINOP|TNK_ASGOP)
TREEOP(TN_ASG_MUL    , tkAsgMul, "*="         ,CEE_MUL   , 2,TNK_BINOP|TNK_ASGOP)
TREEOP(TN_ASG_DIV    , tkAsgDiv, "/="         ,CEE_DIV   , 2,TNK_BINOP|TNK_ASGOP)
TREEOP(TN_ASG_MOD    , tkAsgMod, "%="         ,CEE_REM   , 2,TNK_BINOP|TNK_ASGOP)

TREEOP(TN_ASG_AND    , tkAsgAnd, "&="         ,CEE_AND   , 2,TNK_BINOP|TNK_ASGOP)
TREEOP(TN_ASG_XOR    , tkAsgXor, "^="         ,CEE_XOR   , 2,TNK_BINOP|TNK_ASGOP)
TREEOP(TN_ASG_OR     , tkAsgOr , "|="         ,CEE_OR    , 2,TNK_BINOP|TNK_ASGOP)

TREEOP(TN_ASG_LSH    , tkAsgLsh, "<<="        ,CEE_SHL   , 2,TNK_BINOP|TNK_ASGOP)
TREEOP(TN_ASG_RSH    , tkAsgRsh, ">>="        ,CEE_SHR   , 2,TNK_BINOP|TNK_ASGOP)
TREEOP(TN_ASG_RSZ    , tkAsgRsz, ">>>="       ,CEE_SHR_UN, 2,TNK_BINOP|TNK_ASGOP)

TREEOP(TN_ASG_CNC    , tkAsgCnc, "%%="        ,CEE_NOP   , 2,TNK_BINOP|TNK_ASGOP)

TREEOP(TN_COMMA      , tkNone,   ","          ,CEE_NOP   , 1,TNK_BINOP)

TREEOP(TN_QMARK      , tkQMark,  "?"          ,CEE_NOP   , 3,TNK_BINOP)
TREEOP(TN_COLON      , tkColon,  ":"          ,CEE_NOP   , 3,TNK_BINOP)

TREEOP(TN_LOG_OR     , tkLogOr , "||"         ,CEE_NOP   , 4,TNK_BINOP)
TREEOP(TN_LOG_AND    , tkLogAnd, "&&"         ,CEE_NOP   , 5,TNK_BINOP)

TREEOP(TN_ISTYPE     , tkISTYPE, "istype"     ,CEE_NOP   ,14,TNK_BINOP)

TREEOP(TN_INDEX      , tkNone,   "[]"         ,CEE_NOP   ,15,TNK_BINOP)
TREEOP(TN_CALL       , tkNone,   "()"         ,CEE_NOP   ,15,TNK_BINOP)
TREEOP(TN_ARROW      , tkNone,   "->"         ,CEE_NOP   ,12,TNK_BINOP)

#ifdef  SETS
TREEOP(TN_DOT2       , tkNone,   ".."         ,CEE_NOP   ,12,TNK_BINOP)
#endif

TREEOP(TN_REFADDR    , tkREFADDR,"ref&"       ,CEE_NOP   , 0,TNK_BINOP)

//-----------------------------------------------------------------------------
//  Other nodes that look like unary/binary operators:
//-----------------------------------------------------------------------------

TREEOP(TN_IND        , tkMul,    "indir"      ,CEE_NOP   ,12,TNK_UNOP)   // is prec correct?

TREEOP(TN_NEW        , tkNone,   "new"        ,CEE_NOP   ,14,TNK_BINOP)
TREEOP(TN_DELETE     , tkNone,   "delete"     ,CEE_NOP   ,14,TNK_UNOP)

TREEOP(TN_CONCAT     , tkNone,   "%%"         ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_CONCAT_ASG , tkNone,   "%%="        ,CEE_NOP   , 0,TNK_BINOP|TNK_ASGOP)

TREEOP(TN_AND_NOSTR  , tkNone,   "math &"     ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_ANA_NOSTR  , tkNone,   "math &="    ,CEE_NOP   , 0,TNK_BINOP|TNK_ASGOP)

TREEOP(TN_LIST       , tkNone,   "<list>"     ,CEE_NOP   , 0,TNK_BINOP)

TREEOP(TN_CAST       , tkNone,   "cast"       ,CEE_NOP   , 0,TNK_BINOP)

TREEOP(TN_CLASS      , tkNone,   "className"  ,CEE_NOP   , 0,TNK_BINOP)

TREEOP(TN_TRY        , tkNone,   "try"        ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_CATCH      , tkNone,   "catch"      ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_EXCEPT     , tkNone,   "except"     ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_FINALLY    , tkNone,   "finally"    ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_DOT        , tkNone,   "."          ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_DOT_NAME   , tkNone,   "name.name"  ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_GOTO       , tkNone,   "goto"       ,CEE_NOP   , 0,TNK_UNOP)
TREEOP(TN_LABEL      , tkNone,   "label"      ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_ARR_INIT   , tkNone,   "arr init"   ,CEE_NOP   , 0,TNK_UNOP)
TREEOP(TN_ARR_LEN    , tkNone,   "arr length" ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_SIZEOF     , tkSIZEOF, "sizeof"     ,CEE_NOP   , 0,TNK_UNOP)
TREEOP(TN_TYPEOF     , tkTYPEOF, "typeof"     ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_BOX        , tkNone,   "box"        ,CEE_NOP   , 0,TNK_UNOP)
TREEOP(TN_UNBOX      , tkNone,   "unbox"      ,CEE_NOP   , 0,TNK_UNOP)

#ifdef  SETS
TREEOP(TN_ALL        , tkNone,   "all"        ,CEE_NOP   , 0,TNK_BINOP)
//////(TN_COUNT      , tkNone,   "count"      ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_EXISTS     , tkNone,   "exists"     ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_CROSS      , tkNone,   "cross"      ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_FILTER     , tkNone,   "filter"     ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_FOREACH    , tkNone,   "foreach"    ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_GROUPBY    , tkNone,   "groupby"    ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_PROJECT    , tkNone,   "project"    ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_SORT       , tkNone,   "sort"       ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_UNIQUE     , tkNone,   "unique"     ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_INDEX2     , tkNone,   "[[]]"       ,CEE_NOP   , 0,TNK_BINOP)
#endif

//-----------------------------------------------------------------------------
//  Statement operator nodes that have ordinary tree structure:
//-----------------------------------------------------------------------------

TREEOP(TN_EXPR_STMT  , tkNone,   "stmtExpr"   ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_IF         , tkNone,   "if"         ,CEE_NOP   , 0,TNK_BINOP)

TREEOP(TN_DO         , tkNone,   "do"         ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_FOR        , tkNone,   "for"        ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_WHILE      , tkNone,   "while"      ,CEE_NOP   , 0,TNK_BINOP)

TREEOP(TN_EXCLUDE    , tkNone,   "excludeStmt",CEE_NOP   , 0,TNK_BINOP)

TREEOP(TN_BREAK      , tkNone,   "break"      ,CEE_NOP   , 0,TNK_UNOP)
TREEOP(TN_CONTINUE   , tkNone,   "continue"   ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_SWITCH     , tkNone,   "switch"     ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_CASE       , tkNone,   "case"       ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_RETURN     , tkNone,   "return"     ,CEE_NOP   , 0,TNK_BINOP)

TREEOP(TN_ASSERT     , tkNone,   "assert"     ,CEE_NOP   , 0,TNK_UNOP)

TREEOP(TN_VARARG_BEG , tkNone,   "vararg-beg" ,CEE_NOP   , 0,TNK_BINOP)
TREEOP(TN_VARARG_GET , tkNone,   "vararg-get" ,CEE_NOP   , 0,TNK_BINOP)

#ifdef  SETS
TREEOP(TN_CONNECT    , tkNone,   "connect"    ,CEE_NOP   , 0,TNK_BINOP)
#endif

//-----------------------------------------------------------------------------
//  Statement operator nodes that have special fields:
//-----------------------------------------------------------------------------

TREEOP(TN_NAMESPACE  , tkNone,   "namespace"  ,CEE_NOP   , 0,TNK_NONE)
TREEOP(TN_ANY_SYM    , tkNone,   "qualname"   ,CEE_NOP   , 0,TNK_NONE)
TREEOP(TN_LCL_SYM    , tkNone,   "lcl var"    ,CEE_NOP   , 0,TNK_NONE)
TREEOP(TN_MEM_SYM    , tkNone,   "member"     ,CEE_NOP   , 0,TNK_NONE)
TREEOP(TN_VAR_SYM    , tkNone,   "variable"   ,CEE_NOP   , 0,TNK_NONE)
TREEOP(TN_BFM_SYM    , tkNone,   "bitfield"   ,CEE_NOP   , 0,TNK_NONE)
TREEOP(TN_FNC_SYM    , tkNone,   "function"   ,CEE_NOP   , 0,TNK_NONE)
TREEOP(TN_FNC_PTR    , tkNone,   "meth-ptr"   ,CEE_NOP   , 0,TNK_NONE)
TREEOP(TN_PROPERTY   , tkNone,   "property"   ,CEE_NOP   , 0,TNK_NONE)

TREEOP(TN_BLOCK      , tkNone,   "{}"         ,CEE_NOP   , 0,TNK_NONE)

//-----------------------------------------------------------------------------
//  Declaration nodes that have special fields:
//-----------------------------------------------------------------------------

TREEOP(TN_VAR_DECL   , tkNone,   "var-decl"   ,CEE_NOP   , 0,TNK_NONE) // may form a loop
TREEOP(TN_SLV_INIT   , tkNone,   "slv-init"   ,CEE_NOP   , 0,TNK_NONE)

//-----------------------------------------------------------------------------
//  Declaration nodes:
//-----------------------------------------------------------------------------

TREEOP(TN_DCL_VAR    , tkNone,   "varDecl"    ,CEE_NOP   , 0,TNK_NONE)

//-----------------------------------------------------------------------------
//  Nodes that never actually appear in trees
//-----------------------------------------------------------------------------

TREEOP(TN_DEFINED    , tkNone,   "defined"    ,CEE_NOP   , 0,TNK_NONE)

/*****************************************************************************/
#undef  TREEOP
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\treeops.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _TREEOPS_H_
#define _TREEOPS_H_
/*****************************************************************************/

enum treeOps
{
    #define TREEOP(en,tk,sn,IL,pr,ok) en,
    #include "toplist.h"

    TN_COUNT
};

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\treenode.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _TREENODE_H_
#define _TREENODE_H_
/*****************************************************************************
 *
 *  The following enum defines a set of bit flags that can be used
 *  to classify expression tree nodes. Note that some operators will
 *  have more than one bit set, as follows:
 *
 *          TNK_CONST    implies    TNK_LEAF
 *          TNK_RELOP    implies    TNK_BINOP
 *          TNK_LOGOP    implies    TNK_BINOP
 */

enum genTreeKinds
{
    TNK_NONE        = 0x0000,   // unclassified operator

    TNK_CONST       = 0x0001,   // constant     operator
    TNK_LEAF        = 0x0002,   // leaf         operator
    TNK_UNOP        = 0x0004,   // unary        operator
    TNK_BINOP       = 0x0008,   // binary       operator
    TNK_RELOP       = 0x0010,   // comparison   operator
    TNK_LOGOP       = 0x0020,   // logical      operator
    TNK_ASGOP       = 0x0040,   // assignment   oeprator

    /* Define composite value(s) */

    TNK_SMPOP       = TNK_UNOP|TNK_BINOP|TNK_RELOP|TNK_LOGOP
};

/*****************************************************************************
 *
 *  The following are the values used for the 'tnFlags' field of TreeNode.
 *
 *  The first set of flags can be used with a large set of nodes, and thus
 *  their values need to be unique. That is, one can take any expression
 *  node and safely test for one of these flags.
 */

enum treeNodeFlags
{
    TNF_BOUND       = 0x0001,   // bound ('compiled') node
    TNF_LVALUE      = 0x0002,   // tree is an lvalue
    TNF_NOT_USER    = 0x0004,   // compiler-added code
    TNF_ASG_DEST    = 0x0008,   // expression is an assignment target
    TNF_BEEN_CAST   = 0x0010,   // this value has been cast
    TNF_COND_TRUE   = 0x0020,   // condition is known to be true
    TNF_PAREN       = 0x0040,   // expression was explicitly parenthesized

    //---------------------------------------------------------------------
    //  The remaining flags can be used only with one or a few nodes, and
    //  so their values need not be distinct (other than within the set
    //  that goes with a particular node, of course). That is, testing
    //  one of these flags only makes sense if the node kind is tested
    //  as well to make sure it's the right one for the particular flag.
    //---------------------------------------------------------------------

    TNF_IF_HASELSE  = 0x8000,   // TN_IF        is an "else" part present?

    TNF_LCL_BASE    = 0x8000,   // TN_LCL_SYM   this is a "baseclass" ref

    TNF_VAR_ARG     = 0x8000,   // TN_VAR_DECL  this is an argument decl
    TNF_VAR_INIT    = 0x4000,   // TN_VAR_DECL  there is an initializer
    TNF_VAR_STATIC  = 0x2000,   // TN_VAR_DECL  variable is static
    TNF_VAR_CONST   = 0x1000,   // TN_VAR_DECL  variable is constant
    TNF_VAR_SEALED  = 0x0800,   // TN_VAR_DECL  variable is read-only
    TNF_VAR_UNREAL  = 0x0400,   // TN_VAR_DECL  variable is compiler-invented

    TNF_ADR_IMPLICIT= 0x8000,   // TN_ADDROF    automatic "&" for arrays/funcs
    TNF_ADR_OUTARG  = 0x4000,   // TN_ADDROF    this is an "out" argument

    TNF_EXP_CAST    = 0x8000,   // TN_CAST      explicit cast?
    TNF_CHK_CAST    = 0x4000,   // TN_CAST      cast that needs to be checked?
    TNF_CTX_CAST    = 0x2000,   // TN_CAST      context wrap/unwrap cast?

    TNF_STR_ASCII   = 0x8000,   // TN_CNS_STR   A"string"
    TNF_STR_WIDE    = 0x4000,   // TN_CNS_STR   L"string"
    TNF_STR_STR     = 0x2000,   // TN_CNS_STR   S"string"

    TNF_BLK_CATCH   = 0x8000,   // TN_BLOCK     this is a "catch" block
    TNF_BLK_FOR     = 0x4000,   // TN_BLOCK     this is an implicit for loop scope
    TNF_BLK_NUSER   = 0x2000,   // TN_BLOCK     scope added by compiler

    TNF_BLK_HASFIN  = 0x8000,   // TN_TRY       is a "finally" present?

    TNF_ADD_NOCAT   = 0x8000,   // TN_ADD       operands bound, not string concat

    TNF_ASG_INIT    = 0x8000,   // TN_ASG       initialization assignment

    TNF_REL_NANREV  = 0x8000,   // TN_GT/LT/..  reversed NaN sense

#ifdef  SETS

    TNF_LIST_DES    = 0x8000,   // TN_LIST      sort list entry direction = descending

    TNF_LIST_SORT   = 0x8000,   // TN_LIST      sort     funclet body
    TNF_LIST_PROJ   = 0x4000,   // TN_LIST      projectt funclet body

#endif

    TNF_CALL_NVIRT  = 0x8000,   // TN_CALL      the call is non-virtual
    TNF_CALL_VARARG = 0x4000,   // TN_CALL      the call has "extra" args
    TNF_CALL_MODOBJ = 0x2000,   // TN_CALL      args may modify instance ptr
    TNF_CALL_STRCAT = 0x1000,   // TN_CALL      string concat assignment
    TNF_CALL_ASGOP  = 0x0800,   // TN_CALL      assignment  operator
    TNF_CALL_ASGPRE = 0x0400,   // TN_CALL      pre-inc/dec operator
    TNF_CALL_GOTADR = 0x0200,   // TN_CALL      addr of result already computed
    TNF_CALL_CHKOVL = 0x0100,   // TN_CALL      checking overloaded operator

    TNF_NAME_TYPENS = 0x8000,   // TN_NAME      the name should be a type
};

/*****************************************************************************/

DEFMGMT
class TreeNode
{
public:

#ifdef FAST
    BYTE            tnOper;                 // operator
    BYTE            tnVtyp;                 // var_type of the node
#else
    treeOps         tnOper;                 // operator
    var_types       tnVtyp;                 // var_type of the node
#endif

    treeOps         tnOperGet() { return (treeOps  )tnOper; }
    var_types       tnVtypGet() { return (var_types)tnVtyp; }

    unsigned short  tnFlags;                // see TNF_xxxx above

    unsigned        tnLineNo;               // for error reporting
//  unsigned short  tnColumn;               // for error reporting

    TypDef          tnType;                 // type of the node (if bound)

    //----------------------------------------------------------------

    union
    {
        /* tnOp     -- unary/binary operator */

        struct
        {
            Tree            tnOp1;
            Tree            tnOp2;
        }
            tnOp;

        /* tnIntCon -- integer constant (TN_CNS_INT) */

        struct
        {
            __int32         tnIconVal;
        }
            tnIntCon;

        /* tnLngCon -- long    constant (TN_CNS_LNG) */

        struct
        {
            __int64         tnLconVal;
        }
            tnLngCon;

        /* tnFltCon -- float   constant (TN_CNS_FLT) */

        struct
        {
            float           tnFconVal;
        }
            tnFltCon;

        /* tnDblCon -- double  constant (TN_CNS_DBL) */

        struct
        {
            double          tnDconVal;
        }
            tnDblCon;

        /* tnStrCon -- string  constant (TN_CNS_STR) */

        struct
        {
            stringBuff      tnSconVal;
            size_t          tnSconLen   :31;
            size_t          tnSconLCH   :1; // encoded "large" characters present?
        }
            tnStrCon;

        /* tnName   -- unbound name reference */

        struct
        {
            Ident           tnNameId;
        }
            tnName;

        /* tnSym    -- unbound symbol reference */

        struct
        {
            SymDef          tnSym;
            SymDef          tnScp;
        }
            tnSym;

        /* tnBlock  -- block/scope */

        struct
        {
            Tree            tnBlkParent;    // parent scope or NULL
            Tree            tnBlkStmt;      // statement list of body
            Tree            tnBlkDecl;      // declaration list or NULL
            unsigned        tnBlkSrcEnd;    // last source line in block
        }
            tnBlock;

        /* tnDcl    -- local declaration */

        struct
        {
            Tree            tnDclNext;      // next declaration in scope
            Tree            tnDclInfo;      // name w/optional initializer
            SymDef          tnDclSym;       // local symbol (if defined)
        }
            tnDcl;

        /* tnSwitch -- switch statement */

        struct
        {
            Tree            tnsValue;       // switch value
            Tree            tnsStmt;        // body of the switch
            Tree            tnsCaseList;    // list of case/default labels - head
            Tree            tnsCaseLast;    // list of case/default labels - tail
        }
            tnSwitch;

        /* tnCase   -- case/default label */

        struct
        {
            Tree            tncNext;        // next label
            Tree            tncValue;       // label value (NULL = default)
            ILblock         tncLabel;       // assigned IL label
        }
            tnCase;

        /* tnInit   -- {}-style initializer */

        struct
        {
            DefSrcDsc       tniSrcPos;      // initializer's source section
            SymDef          tniCompUnit;    // initializer's compilation unit
        }
            tnInit;

        //-----------------------------------------------------------------
        // The flavors that follow only appear within bound expressions:
        //-----------------------------------------------------------------

        /* tnLclSym -- local variable */

        struct
        {
            SymDef          tnLclSym;       // variable symbol
        }
            tnLclSym;

        /* tnVarSym -- global variable or data member */

        struct
        {
            SymDef          tnVarSym;       // variable/data member
            Tree            tnVarObj;       // instance pointer or NULL
        }
            tnVarSym;

        /* tnFncSym -- function or method */

        struct
        {
            SymDef          tnFncSym;       // function symbol
            SymDef          tnFncScp;       // scope for lookup
            Tree            tnFncObj;       // instance pointer or NULL
            Tree            tnFncArgs;      // argument list
        }
            tnFncSym;

        /* tnBitFld -- bitfield data member */

        struct
        {
            Tree            tnBFinst;       // instance pointer
            SymDef          tnBFmsym;       // data member symbol
            unsigned        tnBFoffs;       // member base offset
            unsigned char   tnBFlen;        // number of bits
            unsigned char   tnBFpos;        // offset of first bit
        }
            tnBitFld;
    };

    //---------------------------------------------------------------------

    bool            tnOperMayThrow();

    //---------------------------------------------------------------------

    static
    const   BYTE    tnOperKindTable[TN_COUNT];

    static
    unsigned        tnOperKind(treeOps      tnOper)
    {
        assert(tnOper < TN_COUNT);

        return  tnOperKindTable[tnOper];
    }

    unsigned        tnOperKind()
    {
        assert(tnOper < TN_COUNT);

        return  tnOperKindTable[tnOper];
    }

    static
    int             tnOperIsConst(treeOps   tnOper)
    {
        return  (tnOperKindTable[tnOper] & TNK_CONST) != 0;
    }

    int             tnOperIsConst()
    {
        return  (tnOperKindTable[tnOper] & TNK_CONST) != 0;
    }

    static
    int             tnOperIsLeaf(treeOps    tnOper)
    {
        return  (tnOperKindTable[tnOper] & TNK_LEAF ) != 0;
    }

    int             tnOperIsLeaf()
    {
        return  (tnOperKindTable[tnOper] & TNK_LEAF ) != 0;
    }

    static
    int             tnOperIsCompare(treeOps tnOper)
    {
        return  (tnOperKindTable[tnOper] & TNK_RELOP) != 0;
    }

    int             tnOperIsCompare()
    {
        return  (tnOperKindTable[tnOper] & TNK_RELOP) != 0;
    }

    static
    int             tnOperIsLogical(treeOps tnOper)
    {
        return  (tnOperKindTable[tnOper] & TNK_LOGOP) != 0;
    }

    int             tnOperIsLogical()
    {
        return  (tnOperKindTable[tnOper] & TNK_LOGOP) != 0;
    }

    static
    int             tnOperIsUnary(treeOps   tnOper)
    {
        return  (tnOperKindTable[tnOper] & TNK_UNOP ) != 0;
    }

    int             tnOperIsUnary()
    {
        return  (tnOperKindTable[tnOper] & TNK_UNOP ) != 0;
    }

    static
    int             tnOperIsBinary(treeOps  tnOper)
    {
        return  (tnOperKindTable[tnOper] & TNK_BINOP) != 0;
    }

    int             tnOperIsBinary()
    {
        return  (tnOperKindTable[tnOper] & TNK_BINOP) != 0;
    }

    static
    int             tnOperIsSimple(treeOps  tnOper)
    {
        return  (tnOperKindTable[tnOper] & TNK_SMPOP) != 0;
    }

    int             tnOperIsSimple()
    {
        return  (tnOperKindTable[tnOper] & TNK_SMPOP) != 0;
    }
};

/*****************************************************************************/
#endif//_TREENODE_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\type.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

/*****************************************************************************/

#include "hash.h"
#include "comp.h"
#include "error.h"
#include "symbol.h"

/*****************************************************************************/

void                symTab::pushTypeChar(int ch)
{
    if  (ch)
        *typeNameNext++ = ch;
}

void                symTab::pushTypeStr(const char *str)
{
    if  (str)
    {
        size_t      len = strlen(str);

        size_t      spc = stComp->cmpScanner->scannerBuff + sizeof(stComp->cmpScanner->scannerBuff) - typeNameNext;

        if  (spc > len)
        {
            strcpy(typeNameNext, str); typeNameNext += strlen(str);
        }
        else if (spc)
        {
            strncpy(typeNameNext, str, spc);
            strcpy(stComp->cmpScanner->scannerBuff + sizeof(stComp->cmpScanner->scannerBuff) - 5, " ...");
            typeNameNext = stComp->cmpScanner->scannerBuff + sizeof(stComp->cmpScanner->scannerBuff);
        }
    }
}

void                symTab::pushTypeSep(bool refOK, bool arrOK)
{
    if  (typeNameAddr == typeNameNext)
        return;

    switch (typeNameNext[-1])
    {
    case ' ':
    case '(':
    case '<':
        return;

    case ']':
        if  (!arrOK)
            pushTypeStr(" ");
        return;

    case '*':
    case '&':
        if  (refOK)
            return;

    default:
        pushTypeStr(" ");
        return;
    }
}

/*****************************************************************************
 *
 *  Display the argument list of a generic type instance.
 */

void                symTab::pushTypeInst(SymDef clsSym)
{
    GenArgDscA      arg;

    assert(clsSym->sdSymKind == SYM_CLASS);
    assert(clsSym->sdClass.sdcSpecific);

    pushTypeStr("<");

    /* Compare the argument types */

    for (arg = (GenArgDscA)clsSym->sdClass.sdcArgLst;;)
    {
        assert(arg->gaBound);

        pushTypeName(arg->gaType, false, false);

        arg = (GenArgDscA)arg->gaNext;
        if  (!arg)
            break;

        pushTypeStr(",");
    }

    pushTypeStr(">");
}

/*****************************************************************************
 *
 *  Display the name of the given symbol.
 */

void                symTab::pushTypeNstr(SymDef sym, bool fullName)
{
    Ident           name;

    assert(sym);

    if  (fullName)
    {
        SymDef          ctx = sym->sdParent; assert(ctx);

        /* If the owmner is a class or a real namespace, display "scope_name." */

        if  (ctx->sdSymKind == SYM_CLASS || (ctx->sdSymKind == SYM_NAMESPACE &&
                                             ctx != stComp->cmpGlobalNS))
        {
            pushTypeNstr(ctx, fullName);

            if  (stDollarClsMode && ctx->sdSymKind == SYM_CLASS)
                pushTypeStr("$");
            else
                pushTypeStr(".");
        }
    }

    name = sym->sdName; assert(name);

    if  (hashTab::hashIsIdHidden(name) && sym->sdSymKind != SYM_FNC)
    {
        switch (sym->sdSymKind)
        {
        case SYM_ENUM:
            pushTypeStr("enum");
//          pushTypeStr(" <anonymous>");
            return;

        case SYM_CLASS:
            pushTypeStr(stClsFlavorStr(sym->sdClass.sdcFlavor));
//          pushTypeStr(" <anonymous>");
            return;
        }

        pushTypeStr("<unknown>");
        return;
    }

    if  (sym->sdSymKind == SYM_FNC && sym->sdFnc.sdfOper != OVOP_NONE)
    {
        tokens          ntok;

        switch (sym->sdFnc.sdfOper)
        {
        case OVOP_CTOR_INST:
        case OVOP_CTOR_STAT: name = sym->sdParent->sdName; goto NAME;

        case OVOP_FINALIZER: ntok = OPNM_FINALIZER; goto NO_OPP;

        case OVOP_CONV_IMP : ntok = OPNM_CONV_IMP ; break;
        case OVOP_CONV_EXP : ntok = OPNM_CONV_EXP ; break;

        case OVOP_EQUALS   : ntok = OPNM_EQUALS   ; break;
        case OVOP_COMPARE  : ntok = OPNM_COMPARE  ; break;

        default:
            goto NAME;
        }

        pushTypeStr("operator ");

    NO_OPP:

        name = stHash->tokenToIdent(ntok);
    }

NAME:

    pushTypeStr(name->idSpelling());

    if  (sym->sdSymKind == SYM_CLASS && sym->sdClass.sdcSpecific)
        pushTypeInst(sym);
}

/*****************************************************************************
 *
 *  Append the specified qualified name.
 */

void                symTab::pushQualNstr(QualName name)
{
    assert(name);

    unsigned        i = 0;
    unsigned        c = name->qnCount;

    assert(c);

    for (;;)
    {
        pushTypeStr(hashTab::identSpelling(name->qnTable[i]));

        if  (++i == c)
            break;

        pushTypeStr(".");
    }

    if  (name->qnEndAll)
        pushTypeStr(".*");
}

/*****************************************************************************
 *
 *  Append a string for the given argument list.
 */

void                symTab::pushTypeArgs(TypDef type)
{
    ArgDscRec       argDsc;
    ArgDef          argRec;
    unsigned        argCnt;

    assert(type && type->tdTypeKind == TYP_FNC);

    argDsc = type->tdFnc.tdfArgs;
    argCnt = argDsc.adCount;

    pushTypeStr("(");

    for (argRec = argDsc.adArgs; argRec; )
    {
        TypDef          argType = argRec->adType;
#if MGDDATA
        TypDef          refType = new TypDef;
#else
        TypDefRec       refType;
#endif

        if  (argDsc.adExtRec)
        {
            ArgExt          xrec = (ArgExt)argRec;

            if  (xrec->adFlags & ARGF_MODE_INOUT) pushTypeStr("inout ");
            if  (xrec->adFlags & ARGF_MODE_OUT  ) pushTypeStr(  "out ");

            if  (xrec->adFlags & ARGF_MODE_REF)
            {
                /* We need to stick in a "&" to display the argument */

                refType.tdTypeKind    = TYP_REF;
                refType.tdRef.tdrBase = argType;

#if MGDDATA
                argType =  refType;
#else
                argType = &refType;
#endif
            }
        }

        pushFullName(argType, NULL, argRec->adName, NULL, false);

        argRec = argRec->adNext;
        if  (argRec)
        {
            pushTypeStr(", ");
            continue;
        }
        else
        {
            if  (argDsc.adVarArgs)
                pushTypeStr(", ...");

            break;
        }
    }

    pushTypeStr(")");
}

/*****************************************************************************
 *
 *  Append a string for the given array type.
 */

void                symTab::pushTypeDims(TypDef type)
{
    DimDef          dims;

    assert(type && type->tdTypeKind == TYP_ARRAY);

    pushTypeStr("[");

    dims = type->tdArr.tdaDims; assert(dims);

    if  (!dims->ddNoDim || dims->ddNext)
    {
        for (;;)
        {
            if  (dims->ddNoDim)
            {
                pushTypeStr("*");
            }
            else
            {
                if  (dims->ddIsConst)
                {
                    char            buff[32];

                    sprintf(buff, "%d", dims->ddSize);

                    pushTypeStr(buff);
                }
//              else
//                  pushTypeStr("<expr>");
            }

            dims = dims->ddNext;
            if  (!dims)
                break;

            pushTypeStr(",");
        }
    }

    pushTypeStr("]");
}

/*****************************************************************************
 *
 *  Recursive routine to display a type.
 */

void                symTab::pushTypeName(TypDef type, bool isptr, bool qual)
{
    assert(type);

    switch  (type->tdTypeKind)
    {
    case TYP_CLASS:
        pushTypeSep();
        pushTypeNstr(type->tdClass.tdcSymbol, qual);

//      if  (type->tdClass.tdcSymbol->sdClass.sdcSpecific)
//          pushTypeInst(type->tdClass.tdcSymbol);

        return;

    case TYP_ENUM:
        pushTypeSep();
        pushTypeNstr(type->tdEnum .tdeSymbol, qual);
        return;

    case TYP_TYPEDEF:
        pushTypeSep(true);
        pushTypeNstr(type->tdTypedef.tdtSym , qual);
        return;

    case TYP_REF:
        pushTypeName(type->tdRef.tdrBase    , true, qual);
        if  (!type->tdIsImplicit)
        {
            pushTypeSep();
            pushTypeStr("&");
        }
        return;

    case TYP_PTR:
        pushTypeName(type->tdRef.tdrBase    , true, qual);
        pushTypeSep();
        pushTypeStr("*");
        return;

    case TYP_ARRAY:
        if  (type->tdIsManaged)
        {
            pushTypeName(type->tdArr.tdaElem, false, qual);
            pushTypeSep(false, true);
            pushTypeDims(type);
            break;
        }
        pushTypeName(type->tdArr.tdaElem    , false, qual);
        goto DEFER;

    case TYP_FNC:

        pushTypeName(type->tdFnc.tdfRett    , false, qual);

    DEFER:

        /* Push the type on the "deferred" list */

        *typeNameDeft++ = type;
        *typeNameDeff++ = isptr;

        /* Output "(" if we're deferring a pointer type */

        if  (isptr)
            pushTypeStr("(");

        return;

    case TYP_VOID:
        pushTypeStr("void");
        return;

    case TYP_UNDEF:
        pushTypeSep(true);
        if  (type->tdUndef.tduName)
            pushTypeStr(hashTab::identSpelling(type->tdUndef.tduName));
        else
            pushTypeStr("<undefined>");
        return;

    default:
        pushTypeStr(symTab::stIntrinsicTypeName(type->tdTypeKindGet()));
        return;
    }
}

/*****************************************************************************
 *
 *  Construct a string representing the given type/symbol.
 */

void                symTab::pushFullName(TypDef      typ,
                                         SymDef      sym,
                                         Ident       name,
                                         QualName    qual,
                                         bool        fullName)
{
    TypDef          deferTypes[16];  // arbitrary limit (this is debug only anyway)
    TypDef      *   deferTypesSave;

    bool            deferFlags[16];
    bool        *   deferFlagsSave;

    deferTypesSave = typeNameDeft; typeNameDeft = deferTypes;
    deferFlagsSave = typeNameDeff; typeNameDeff = deferFlags;

    /* Don't display both type and name for type symbols */

    if  (sym && sym->sdType == typ)
    {
        switch (sym->sdSymKind)
        {
        case SYM_ENUM:
        case SYM_CLASS:
            typ = NULL;
            break;
        }
    }

    /* Output the first part of the type string */

    if  (typ)
        pushTypeName(typ, false, fullName && (sym == NULL && qual == NULL));

    /* Append the name, if any was supplied */

    if      (sym)
    {
        pushTypeSep(true);
        pushTypeNstr(sym, fullName);
    }
    else if (name)
    {
        pushTypeSep(true);
        pushTypeStr(hashTab::identSpelling(name));
    }
    else if (qual)
    {
        pushTypeSep(true);
        pushQualNstr(qual);
    }
    else if (typ && typ->tdTypeKind == TYP_FNC)
    {
        pushTypeSep(true);
    }

    /* Append any "deferred" array/function types */

    while (typeNameDeft > deferTypes)
    {
        TypDef          deftp = *--typeNameDeft;

        if  (*--typeNameDeff)
            pushTypeStr(")");

        switch (deftp->tdTypeKind)
        {
        case TYP_ARRAY:
            pushTypeDims(deftp);
            break;

        case TYP_FNC:
            pushTypeArgs(deftp);
            break;

        default:
            NO_WAY(!"unexpected type");
        }
    }

    assert(typeNameDeft == deferTypes); typeNameDeft = deferTypesSave;
    assert(typeNameDeff == deferFlags); typeNameDeff = deferFlagsSave;
}

/*****************************************************************************
 *
 *  Return a printable human-readable represntation of the iven type. If a
 *  symbol or name is supplied, it will be included within the type in the
 *  proper place so that the output looks like a declaration.
 */

stringBuff          symTab::stTypeName(TypDef      typ,
                                       SymDef      sym,
                                       Ident       name,
                                       QualName    qual,
                                       bool        fullName,
                                       stringBuff  destBuffPos)
{
    Scanner         ourScanner = stComp->cmpScanner;

    /* Did the caller supply a specific buffer beginning address? */

    if  (destBuffPos)
    {
        /* Make sure the supplied buffer pointer is within range */

        assert(destBuffPos >= ourScanner->scannerBuff);
        assert(destBuffPos <  ourScanner->scannerBuff + sizeof(ourScanner->scannerBuff));
    }
    else
    {
        /* Use the entire buffer, then */

        destBuffPos = ourScanner->scannerBuff;
    }

    typeNameAddr =
    typeNameNext = destBuffPos;
    pushFullName(typ, sym, name, qual, fullName);
    typeNameNext[0] = 0;

    return  destBuffPos;
}

/*****************************************************************************
 *
 *  Create an error string with the given type.
 */

const   char *      symTab::stErrorTypeName(TypDef type)
{
    Scanner         ourScanner = stComp->cmpScanner;

    char    *       nstr = ourScanner->scanErrNameStrBeg();

    assert(type);

    symTab::stTypeName(type, NULL, NULL, NULL, false, nstr);

    ourScanner->scanErrNameStrAdd(nstr);
    ourScanner->scanErrNameStrEnd();

    return nstr;
}

/*****************************************************************************
 *
 *  Create an error string with the fully decorated name of the given symbol.
 */

const   char *      symTab::stErrorSymbName(SymDef sym, bool qual, bool notype)
{
    Scanner         ourScanner = stComp->cmpScanner;

    char *          nstr = ourScanner->scanErrNameStrBeg();

    assert(sym);

    if  (notype || sym->sdSymKind != SYM_FNC)
    {
        symTab::stTypeName(NULL       , sym, NULL, NULL, qual, nstr);
    }
    else
    {
        symTab::stTypeName(sym->sdType, sym, NULL, NULL, qual, nstr);
    }

    ourScanner->scanErrNameStrAdd(nstr);
    ourScanner->scanErrNameStrEnd();

    return nstr;
}

/*****************************************************************************
 *
 *  Create an error string with the given function name and type.
 */

const   char *      symTab::stErrorTypeName(Ident name, TypDef type)
{
    Scanner         ourScanner = stComp->cmpScanner;

    char    *       nstr = ourScanner->scanErrNameStrBeg();

    assert(type);

    symTab::stTypeName(type, NULL, name, NULL, false, nstr);

    ourScanner->scanErrNameStrAdd(nstr);
    ourScanner->scanErrNameStrEnd();

    return nstr;
}

/*****************************************************************************
 *
 *  Create an error string with the qualified name.
 */

const   char *      symTab::stErrorQualName(QualName qual, TypDef type)
{
    Scanner         ourScanner = stComp->cmpScanner;

    stringBuff      astr;
    stringBuff      nstr = ourScanner->scanErrNameStrBeg();

    assert(qual);

    astr = symTab::stTypeName(type, NULL, NULL, qual, false, nstr);

    ourScanner->scanErrNameStrAdd(astr);
    ourScanner->scanErrNameStrEnd();

    return nstr;
}

/*****************************************************************************
 *
 *  Create an error string with the identifier name.
 */

const   char *      symTab::stErrorIdenName(Ident name, TypDef type)
{
    Scanner         ourScanner = stComp->cmpScanner;

    stringBuff      astr;
    stringBuff      nstr = ourScanner->scanErrNameStrBeg();

    assert(name);

    astr = symTab::stTypeName(type, NULL, name, NULL, false, nstr);

    ourScanner->scanErrNameStrAdd(astr);
    ourScanner->scanErrNameStrEnd();

    return nstr;
}

/*****************************************************************************
 *
 *  Return the string corresponing to the given class type flavor.
 */

normString          symTab::stClsFlavorStr(unsigned flavor)
{
    static
    const   char *  flavs[] =
    {
        "",         // STF_NONE
        "class",    // CLASS
        "union",    // UNION
        "struct",   // STRUCT
        "interface",// INTF
        "delegate", // DELEGATE
    };

    assert(flavor < STF_COUNT);
    assert(flavor < arraylen(flavs));

    return  flavs[flavor];
}

/*****************************************************************************
 *
 *  Compute a hash for an anonymous struct/class type.
 */

#ifdef  SETS

unsigned            symTab::stAnonClassHash(TypDef clsTyp)
{
    assert(clsTyp);
    assert(clsTyp->tdTypeKind == TYP_CLASS);
    assert(clsTyp->tdClass.tdcSymbol->sdCompileState >= CS_DECLARED);

    if  (!clsTyp->tdClass.tdcHashVal)
    {
        SymDef          memSym;

        unsigned        hashVal = 0;

        /* Simply hash together the types of all non-static data members */

        for (memSym = clsTyp->tdClass.tdcSymbol->sdScope.sdScope.sdsChildList;
             memSym;
             memSym = memSym->sdNextInScope)
        {
            if  (memSym->sdSymKind != SYM_VAR)
                continue;
            if  (memSym->sdIsStatic)
                continue;

            hashVal = (hashVal * 3) ^ stComputeTypeCRC(memSym->sdType);
        }

        clsTyp->tdClass.tdcHashVal = hashVal;

        /* Make sure the hash value is non-zero */

        if  (clsTyp->tdClass.tdcHashVal == 0)
             clsTyp->tdClass.tdcHashVal++;
    }

    return  clsTyp->tdClass.tdcHashVal;
}

#endif

/*****************************************************************************
 *
 *  Compute a 'CRC' for the given type. Note that it isn't essential that
 *  two different types have different CRC's, but the opposite must always
 *  be true: that is, two identical types (even from two different symbol
 *  tables) must always compute the same CRC.
 *
 */

unsigned            symTab::stTypeHash(TypDef type, int ival, bool bval1,
                                                              bool bval2)
{
    unsigned        hash = stComputeTypeCRC(type) ^ ival;

    if  (bval1) hash = hash * 3;
    if  (bval2) hash = hash * 3;

    return  hash;
}

unsigned            symTab::stComputeTypeCRC(TypDef typ)
{
    // ISSUE: The following is pretty lame ....

    for (;;)
    {
        switch (typ->tdTypeKind)
        {
        case TYP_REF:
        case TYP_PTR:
            return  stTypeHash(typ->tdRef.tdrBase,
                               typ->tdTypeKind,
                         (bool)typ->tdIsImplicit);

        case TYP_ENUM:
            return  hashTab::identHashVal(typ->tdEnum .tdeSymbol->sdName);

        case TYP_CLASS:
            return  hashTab::identHashVal(typ->tdClass.tdcSymbol->sdName);

        case TYP_ARRAY:
            return  stTypeHash(typ->tdArr.tdaElem,
                               typ->tdArr.tdaDcnt,
                         (bool)typ->tdIsUndimmed,
                         (bool)typ->tdIsManaged);

        case TYP_TYPEDEF:
            typ = typ->tdTypedef.tdtType;
            continue;

        default:
            return  typ->tdTypeKind;
        }
    }
}

/*****************************************************************************
 *
 *  Initialize the type system - create the intrinsic types, etc.
 */

void                symTab::stInitTypes(unsigned refHashSz,
                                        unsigned arrHashSz)
{
    size_t          sz;
    TypDef          tp;
    var_types       vt;

    /* Are we supposed to hash ref/ptr/array types? */

    stRefTpHashSize = refHashSz;
    stRefTpHash     = NULL;

    if  (refHashSz)
    {
        /* Allocate and clear the ref/ptr type hash table */

        sz = refHashSz * sizeof(*stRefTpHash);

        stRefTpHash = (TypDef*)stAllocPerm->nraAlloc(sz);
        memset(stRefTpHash, 0, sz);
    }

    stArrTpHashSize = arrHashSz;
    stArrTpHash     = NULL;

    if  (arrHashSz)
    {
        /* Allocate and clear the  array  type hash table */

        sz = arrHashSz * sizeof(*stArrTpHash);

        stArrTpHash = (TypDef*)stAllocPerm->nraAlloc(sz);
        memset(stArrTpHash, 0, sz);
    }

    /* In any case we haven't created any ref/ptr/array types yet */

    stRefTypeList = NULL;
    stArrTypeList = NULL;

    /* Create all the 'easy' intrinsic types */

    for (vt = TYP_UNDEF; vt <= TYP_lastIntrins; vt = (var_types)(vt + 1))
    {
        tp             = stAllocTypDef(vt);
        tp->tdTypeKind = vt;

        stIntrinsicTypes[vt] = tp;
    }

    if  (stComp->cmpConfig.ccTgt64bit)
    {
        assert(stIntrTypeSizes [TYP_ARRAY] == 4); stIntrTypeSizes [TYP_ARRAY] = 8;
        assert(stIntrTypeSizes [TYP_REF  ] == 4); stIntrTypeSizes [TYP_REF  ] = 8;
        assert(stIntrTypeSizes [TYP_PTR  ] == 4); stIntrTypeSizes [TYP_PTR  ] = 8;

        assert(stIntrTypeAligns[TYP_ARRAY] == 4); stIntrTypeAligns[TYP_ARRAY] = 8;
        assert(stIntrTypeAligns[TYP_REF  ] == 4); stIntrTypeAligns[TYP_REF  ] = 8;
        assert(stIntrTypeAligns[TYP_PTR  ] == 4); stIntrTypeAligns[TYP_PTR  ] = 8;
    }
}

/*****************************************************************************/

TypDef              symTab::stAllocTypDef(var_types kind)
{
    TypDef          typ;

#if MGDDATA

    typ = new TypDef();

#else

    size_t          siz;

    static
    size_t          typeDscSizes[] =
    {
        typDef_size_undef,      // TYP_UNDEF
        typDef_size_base,       // TYP_VOID

        typDef_size_base,       // TYP_BOOL
        typDef_size_base,       // TYP_WCHAR

        typDef_size_base,       // TYP_CHAR
        typDef_size_base,       // TYP_UCHAR
        typDef_size_base,       // TYP_SHORT
        typDef_size_base,       // TYP_USHORT
        typDef_size_base,       // TYP_INT
        typDef_size_base,       // TYP_UINT
        typDef_size_base,       // TYP_NATINT
        typDef_size_base,       // TYP_NATUINT
        typDef_size_base,       // TYP_LONG
        typDef_size_base,       // TYP_ULONG

        typDef_size_base,       // TYP_FLOAT
        typDef_size_base,       // TYP_DOUBLE
        typDef_size_base,       // TYP_LONGDBL
        typDef_size_base,       // TYP_REFANY

        typDef_size_array,      // TYP_ARRAY
        typDef_size_class,      // TYP_CLASS
        typDef_size_fnc,        // TYP_FNC
        typDef_size_ref,        // TYP_REF
        typDef_size_ptr,        // TYP_PTR

        typDef_size_enum,       // TYP_ENUM
        typDef_size_typedef,    // TYP_TYPEDEF
    };

    /* Make sure the size table is up to date */

    assert(typeDscSizes[TYP_UNDEF  ] == typDef_size_undef  );
    assert(typeDscSizes[TYP_VOID   ] == typDef_size_base   );

    assert(typeDscSizes[TYP_BOOL   ] == typDef_size_base   );
    assert(typeDscSizes[TYP_WCHAR  ] == typDef_size_base   );

    assert(typeDscSizes[TYP_CHAR   ] == typDef_size_base   );
    assert(typeDscSizes[TYP_UCHAR  ] == typDef_size_base   );
    assert(typeDscSizes[TYP_SHORT  ] == typDef_size_base   );
    assert(typeDscSizes[TYP_USHORT ] == typDef_size_base   );
    assert(typeDscSizes[TYP_INT    ] == typDef_size_base   );
    assert(typeDscSizes[TYP_UINT   ] == typDef_size_base   );
    assert(typeDscSizes[TYP_NATINT ] == typDef_size_base   );
    assert(typeDscSizes[TYP_NATUINT] == typDef_size_base   );
    assert(typeDscSizes[TYP_LONG   ] == typDef_size_base   );
    assert(typeDscSizes[TYP_ULONG  ] == typDef_size_base   );

    assert(typeDscSizes[TYP_FLOAT  ] == typDef_size_base   );
    assert(typeDscSizes[TYP_DOUBLE ] == typDef_size_base   );
    assert(typeDscSizes[TYP_LONGDBL] == typDef_size_base   );

    assert(typeDscSizes[TYP_ARRAY  ] == typDef_size_array  );
    assert(typeDscSizes[TYP_CLASS  ] == typDef_size_class  );
    assert(typeDscSizes[TYP_FNC    ] == typDef_size_fnc    );
    assert(typeDscSizes[TYP_REF    ] == typDef_size_ref    );
    assert(typeDscSizes[TYP_PTR    ] == typDef_size_ptr    );

    assert(typeDscSizes[TYP_ENUM   ] == typDef_size_enum   );
    assert(typeDscSizes[TYP_TYPEDEF] == typDef_size_typedef);

    assert(kind < arraylen(typeDscSizes));

    /* Figure out how big the type descriptor will be */

    siz = typeDscSizes[kind];

    /* Now allocate and clear the type descriptor */

    typ = (TypDef)stAllocPerm->nraAlloc(siz); memset(typ, 0, siz);

#endif

    typ->tdTypeKind = kind;

    return  typ;
}

/*****************************************************************************
 *
 *  Add an entry to an interface list.
 */

TypList             symTab::stAddIntfList(TypDef type, TypList  list,
                                                       TypList *lastPtr)
{
    TypList         intf;

    /* Check for a duplicate first */

    for (intf = list; intf; intf = intf->tlNext)
    {
        if  (stMatchTypes(type, intf->tlType))
        {
            stComp->cmpError(ERRintfDup, type);
            return  list;
        }
    }

#if MGDDATA
    intf = new TypList;
#else
    intf =    (TypList)stAllocPerm->nraAlloc(sizeof(*intf));
#endif

    intf->tlNext = NULL;
    intf->tlType = type;

    if  (list)
        (*lastPtr)->tlNext = intf;
    else
        list = intf;

    *lastPtr = intf;

    return  list;
}

/*****************************************************************************
 *
 *  Create a new ref/ptr type.
 */

TypDef              symTab::stNewRefType(var_types kind, TypDef elem, bool impl)
{
    TypDef          type;
    unsigned        hash;

    assert(kind == TYP_REF || kind == TYP_PTR);

    /* If the base type isn't known we can't match */

    if  (!elem)
        goto NO_MATCH;

    /* Are we using a hash table? */

    if  (stRefTpHash)
    {
        hash = stTypeHash(elem, kind, impl) % stRefTpHashSize;
        type = stRefTpHash[hash];
    }
    else
    {
        type = stRefTypeList;
    }

    /* Look for a matching pointer type that we could reuse */

    while   (type)
    {
        if  (type->tdRef.tdrBase == elem &&
             type->tdTypeKind    == kind &&
             type->tdIsImplicit  == impl)
        {
            return  type;
        }

        type = type->tdRef.tdrNext;
    }

NO_MATCH:

    /* Not found, create a new type */

    type = stAllocTypDef(kind);
    type->tdRef.tdrBase = elem;
    type->tdIsImplicit  = impl;

    if  (elem && elem->tdTypeKind == TYP_CLASS)
        type->tdIsManaged = elem->tdIsManaged;

    /* Insert into the hash table or the linked list */

    if  (stRefTpHash && elem)
    {
        type->tdRef.tdrNext = stRefTpHash[hash];
                              stRefTpHash[hash] = type;
    }
    else
    {
        type->tdRef.tdrNext = stRefTypeList;
                              stRefTypeList     = type;
    }

    return  type;
}

/*****************************************************************************
 *
 *  Allocate an array dimension descriptor.
 */

DimDef              symTab::stNewDimDesc(unsigned size)
{
    DimDef          dim;

#if MGDDATA
    dim = new DimDef;
#else
    dim =    (DimDef)stAllocPerm->nraAlloc(sizeof(*dim));
#endif

    dim->ddNext = NULL;

    if  (size)
    {
        dim->ddIsConst = true;
        dim->ddNoDim   = false;
        dim->ddSize    = size; assert(dim->ddSize == size);
    }
    else
    {
        dim->ddIsConst = false;
        dim->ddNoDim   = true;
    }

    return  dim;
}

/*****************************************************************************
 *
 *  Create a new array type.
 */

//  unsigned    arrTypeCnt;
//  unsigned    arrTypeHit;

TypDef              symTab::stNewArrType(DimDef dims, bool mgd, TypDef elem)
{
    DimDef          temp;
    unsigned        dcnt;
    bool            udim;
    bool            nzlb;
    TypDef          type;

    unsigned        hash;
    bool            uhsh = false;

    /*
        Count the dimensions; while we're at it, see if one or more dimension
        has been specified, and whether there are any non-zero lower bounds.
     */

    for (temp = dims, dcnt = 0, nzlb = false, udim = true;
         temp;
         temp = temp->ddNext)
    {
        dcnt++;

        if  (!temp->ddNoDim)
        {
            udim = false;

            if  (temp->ddHiTree)
                nzlb = true;
        }
    }

    /* If we don't know the element type, we can't reuse an existing type */

    if  (!elem)
    {
        assert(mgd == false);
        goto NO_MATCH;
    }

    /* If we have any dimensions, don't bother reusing an existing type */

    if  (!udim)
        goto NO_MATCH;

    /* Are we using a hash table? */

    if  (stArrTpHash)
    {
        uhsh = true;
        hash = stTypeHash(elem, dcnt, udim, mgd) % stArrTpHashSize;
        type = stArrTpHash[hash];
    }
    else
    {
        type = stArrTypeList;
    }

    /* Look for a matching array type that we can reuse */

    while   (type)
    {
        /* Note that the desired array type has no dimensions */

        if  (type->tdArr.tdaDcnt == dcnt  &&
             type->tdIsManaged   == mgd   &&
             type->tdIsUndimmed  != false &&
             type->tdIsGenArray  == false && stMatchTypes(type->tdArr.tdaElem, elem))
        {
            /* Make sure we would have created the same exact type */

#ifndef __IL__

            TypDefRec       arrt;

            arrt.tdTypeKind     = TYP_ARRAY;
            arrt.tdArr.tdaElem  = elem;
            arrt.tdArr.tdaDims  = dims;
            arrt.tdArr.tdaDcnt  = dcnt;
            arrt.tdIsManaged    =  mgd;
            arrt.tdIsUndimmed   = udim;

            assert(symTab::stMatchTypes(type, &arrt));

#endif

//          arrTypeHit++;

            return  type;
        }

        type = type->tdArr.tdaNext;
    }

NO_MATCH:

    /* Is this a generic (non-zero lower bound) array? */

    if  (!dims)
    {
        /* Make sure we have a dimension */

        dims = stNewDimDesc(0);
        nzlb = true;
    }

    /* An existing reusable array type not found, create a new one */

    type = stAllocTypDef(TYP_ARRAY);

//  arrTypeCnt++;

    type->tdArr.tdaElem  = elem;
    type->tdArr.tdaDims  = dims;
    type->tdArr.tdaDcnt  = dcnt;
    type->tdIsManaged    =  mgd;
    type->tdIsUndimmed   = udim;
    type->tdIsGenArray   = nzlb;

    if  (elem)
        type->tdIsGenArg = elem->tdIsGenArg;

    /* Insert into the hash table or the linked list */

    if  (uhsh)
    {
        type->tdArr.tdaNext = stArrTpHash[hash];
                              stArrTpHash[hash] = type;
    }
    else
    {
        type->tdArr.tdaNext = stArrTypeList;
                              stArrTypeList     = type;
    }

    return  type;
}

/*****************************************************************************
 *
 *  Returns a generic array type with the given element type and number of
 *  dimensions (if such a type already exists, it is reused).
 */

TypDef              symTab::stNewGenArrTp(unsigned dcnt, TypDef elem, bool generic)
{
    TypDef          type;
    unsigned        hash;
    DimDef          dims;

    if  (generic)
        dcnt = 0;

    /* Are we using a hash table? */

    if  (stArrTpHash)
    {
        hash = stTypeHash(elem, dcnt, true, true) % stArrTpHashSize;
        type = stArrTpHash[hash];
    }
    else
    {
        type = stArrTypeList;
    }

    /* Look for a matching array type */

    while   (type)
    {
        if  (type->tdArr.tdaDcnt == dcnt &&
             type->tdIsManaged           &&
             type->tdIsUndimmed          && stMatchTypes(type->tdArr.tdaElem, elem))
        {
            return  type;
        }

        type = type->tdArr.tdaNext;
    }

    dims = NULL;

    while (dcnt--)
    {
        DimDef          next = stNewDimDesc(0);

        next->ddNext = dims;
                       dims = next;
    }

    type = stNewArrType(dims, true, elem);

    if  (elem->tdTypeKind == TYP_CLASS && isMgdValueType(elem))
        type->tdIsValArray = true;

    return  type;
}

/*****************************************************************************
 *
 *  Create a new function type.
 */

TypDef              symTab::stNewFncType(ArgDscRec args, TypDef rett)
{
    TypDef          type;

    type = stAllocTypDef(TYP_FNC);

    type->tdFnc.tdfRett   = rett;
    type->tdFnc.tdfArgs   = args;
    type->tdFnc.tdfPtrSig = 0;

    return  type;
}

/*****************************************************************************
 *
 *  Create a new class type.
 */

TypDef              symTab::stNewClsType(SymDef tsym)
{
    TypDef          type;
    TypDef          tref;

    assert(tsym && tsym->sdSymKind == SYM_CLASS);

    type = stAllocTypDef(TYP_CLASS);

    type->tdClass.tdcSymbol     = tsym;
    type->tdClass.tdcRefTyp     = NULL;     // created on demand
    type->tdClass.tdcBase       = NULL;     // filled in when we go to CS_DECL
    type->tdClass.tdcIntf       = NULL;     // filled in when we go to CS_DECL

    type->tdClass.tdcFlavor     = tsym->sdClass.sdcFlavor;

    type->tdIsManaged           = tsym->sdIsManaged;
    type->tdClass.tdcValueType  = false;

    type->tdClass.tdcAnonUnion  = tsym->sdClass.sdcAnonUnion;
    type->tdClass.tdcTagdUnion  = tsym->sdClass.sdcTagdUnion;

    if  (!tsym->sdIsManaged && tsym->sdClass.sdcFlavor != STF_CLASS)
        type->tdClass.tdcValueType = true;

    if  (tsym->sdClass.sdcFlavor == STF_DELEGATE)
    {
        assert(tsym->sdIsManaged);
        type->tdIsDelegate      = true;
    }

    /* Pre-allocate the pointer/reference type */

    tref = stNewRefType(tsym->sdIsManaged ? TYP_REF
                                          : TYP_PTR, type, true);

    type->tdClass.tdcRefTyp = tref;

    /* Store the type in the class symbol */

    tsym->sdType = type;

    return  type;
}

/*****************************************************************************
 *
 *  Create a new enum type.
 */

TypDef              symTab::stNewEnumType(SymDef tsym)
{
    TypDef          type;

    assert(tsym && tsym->sdSymKind == SYM_ENUM);

    type = stAllocTypDef(TYP_ENUM);

    type->tdEnum.tdeSymbol  = tsym;
    type->tdIsManaged       = tsym->sdIsManaged;
    type->tdEnum.tdeIntType = NULL;         // filled in later

    return  type;
}

/*****************************************************************************
 *
 *  Create a new "typedef" type.
 */

TypDef              symTab::stNewTdefType(SymDef tsym)
{
    TypDef          type;

    assert(tsym && tsym->sdSymKind == SYM_TYPEDEF);

    type = stAllocTypDef(TYP_TYPEDEF);

    type->tdTypedef.tdtSym = tsym;

    return  type;
}

/*****************************************************************************
 *
 *  Create a new "error" type.
 */

TypDef              symTab::stNewErrType(Ident name)
{
    TypDef          type;

    type = stAllocTypDef(TYP_UNDEF);

    type->tdUndef.tduName = name;

    return  type;
}

/*****************************************************************************
 *
 *  Return the function type for the given delegate type.
 */

TypDef              symTab::stDlgSignature(TypDef dlgTyp)
{
    SymDef          invm;

    assert(dlgTyp->tdTypeKind == TYP_CLASS);
    assert(dlgTyp->tdClass.tdcFlavor == STF_DELEGATE);

    /* Find the "Invoke" method in the delegate type */

    invm = stLookupScpSym(stComp->cmpIdentInvoke, dlgTyp->tdClass.tdcSymbol);

    /* The "Invoke" method should always be present and not overloaded */

    assert(invm && invm->sdSymKind == SYM_FNC && !invm->sdFnc.sdfNextOvl);

    return invm->sdType;
}

/*****************************************************************************
 *
 *  Given two types (which may potentially come from two different
 *  symbol tables), return true if they represent the same type.
 */

bool                symTab::stMatchType2(TypDef typ1, TypDef typ2)
{
    for (;;)
    {
        var_types       kind;

        assert(typ1);
        assert(typ2);

        if  (typ1 == typ2)
            return  true;

        kind = typ1->tdTypeKindGet();

        if  (kind != typ2->tdTypeKindGet())
        {
            if  (kind == TYP_TYPEDEF)
            {
                if  (typ1->tdTypedef.tdtType)
                {
                    typ1 = typ1->tdTypedef.tdtType;
                    continue;
                }

                UNIMPL(!"match undefined typedefs");
            }

            if  (typ2->tdTypeKind == TYP_TYPEDEF)
            {
                typ2 = typ2->tdTypedef.tdtType; assert(typ2);
                continue;
            }

            return  false;
        }

        if  (kind <= TYP_lastIntrins)
            return  true;

        switch  (kind)
        {
        case TYP_FNC:

            /* First match the argument lists */

            if  (!stArgsMatch(typ1, typ2))
                return  false;

            // UNDONE: Match calling conventions and all that ....

            /* Now match the return types */

            typ1 = typ1->tdFnc.tdfRett;
            typ2 = typ2->tdFnc.tdfRett;
            break;

        case TYP_CLASS:

            /* Are both types actually delegates? */

            if  (typ1->tdClass.tdcFlavor == STF_DELEGATE &&
                 typ2->tdClass.tdcFlavor == STF_DELEGATE)
            {
                SymDef          csym1;
                SymDef          csym2;

                SymTab          stab1;
                SymTab          stab2;

                /* Compare the referenced types, i.e. the "Invoke" signatures */

                csym1 = typ1->tdClass.tdcSymbol;
                csym2 = typ2->tdClass.tdcSymbol;

                /* Special case: the built-in base class */

                if  (csym1->sdClass.sdcBuiltin ||
                     csym2->sdClass.sdcBuiltin)
                {
                    return  false;
                }

                stab1 = csym1->sdOwnerST();
                stab2 = csym2->sdOwnerST();

                typ1  = stab1->stDlgSignature(typ1);
                typ2  = stab1->stDlgSignature(typ2);

                break;
            }

#ifdef  SETS

            /* Are both classes PODT's ? */

            if  (typ1->tdClass.tdcSymbol->sdClass.sdcPODTclass &&
                 typ2->tdClass.tdcSymbol->sdClass.sdcPODTclass)
            {
                SymDef          memSym1;
                SymDef          memSym2;

                SymDef          clsSym1 = typ1->tdClass.tdcSymbol;
                SymDef          clsSym2 = typ2->tdClass.tdcSymbol;

                /* No more than one of the classes may have a an explicit name */

                if  (!hashTab::hashIsIdHidden(clsSym1->sdName) &&
                     !hashTab::hashIsIdHidden(clsSym2->sdName))
                {
                    return  false;
                }

                /* The hash values better agree */

                if  (stAnonClassHash(typ1) != stAnonClassHash(typ2))
                    return  false;

                /* Check to make sure the member lists agree */

                memSym1 = clsSym1->sdScope.sdScope.sdsChildList;
                memSym2 = clsSym2->sdScope.sdScope.sdsChildList;

                while (memSym1 || memSym2)
                {
                    if  (memSym1)
                    {
                        if  (memSym1->sdSymKind != SYM_VAR ||
                             memSym1->sdIsStatic)
                        {
                            memSym1 = memSym1->sdNextInScope;
                            continue;
                        }
                    }

                    if  (memSym2)
                    {
                        if  (memSym2->sdSymKind != SYM_VAR ||
                             memSym2->sdIsStatic)
                        {
                            memSym2 = memSym2->sdNextInScope;
                            continue;
                        }

                        if  (!memSym1)
                            break;
                    }
                    else
                        break;

                    if  (!stMatchTypes(memSym1->sdType, memSym2->sdType))
                        return  false;

                    memSym1 = memSym1->sdNextInScope;
                    memSym2 = memSym2->sdNextInScope;
                }

                return  (memSym1 == memSym2);
            }

#endif

            return  false;

        case TYP_ENUM:
            return  false;

        case TYP_ARRAY:
            return  stMatchArrays(typ1, typ2, false);

        case TYP_REF:
        case TYP_PTR:
            typ1 = typ1->tdRef.tdrBase;
            typ2 = typ2->tdRef.tdrBase;
            break;

        case TYP_TYPEDEF:
            typ1 = typ1->tdTypedef.tdtType;
            typ2 = typ2->tdTypedef.tdtType;
            break;

        default:
            assert(!"unexpected type kind in typ_mgr::tmMatchTypes()");
        }
    }
}

/*****************************************************************************
 *
 *  Compare two array types and return true if they are identical/compatible,
 *  depending on the value of 'subtype'.
 */

bool                symTab::stMatchArrays(TypDef typ1, TypDef typ2, bool subtype)
{
    DimDef          dim1;
    DimDef          dim2;

AGAIN:

    /* Match the dimensions and element type */

    if  (typ1->tdArr.tdaDcnt != typ2->tdArr.tdaDcnt)
        return  false;

    dim1 = typ1->tdArr.tdaDims;
    dim2 = typ2->tdArr.tdaDims;

    while (dim1)
    {
        assert(dim2);

        if  (dim1->ddNoDim != dim2->ddNoDim)
        {
            if  (!subtype || dim1->ddNoDim)
                return  false;
        }
        else if (!dim1->ddNoDim)
        {
            /* ISSUE: Is the following correct? */

            if  (!dim1->ddIsConst)
                return false;
            if  (!dim2->ddIsConst)
                return false;

            if  (dim1->ddSize != dim2->ddSize)
                return  false;
        }

        dim1 = dim1->ddNext;
        dim2 = dim2->ddNext;
    }

    assert(dim2 == NULL);

    typ1 = typ1->tdArr.tdaElem;
    typ2 = typ2->tdArr.tdaElem;

    if  (typ1->tdTypeKind == TYP_ARRAY &&
         typ2->tdTypeKind == TYP_ARRAY)
    {
        goto AGAIN;
    }

    /* Special case: "Object[]" is compatible with any array */

    if  (subtype && stIsObjectRef(typ2) && typ1->tdTypeKind == TYP_ARRAY)
        return  true;

    return  stMatchTypes(typ1, typ2);
}

/*****************************************************************************
 *
 *  Compute argument list 'checksum' for the given function type - this is
 *  used to speed up comparisons of argument lists (e.g. when looking for
 *  matching overloaded functions).
 */

unsigned            symTab::stComputeArgsCRC(TypDef typ)
{
    ArgDef          arg;
    unsigned        CRC = 0;

    assert(typ->tdTypeKind == TYP_FNC);

    /* Walk the argument list, computing the CRC based on the argument types */

    for (arg = typ->tdFnc.tdfArgs.adArgs; arg; arg = arg->adNext)
    {
        CRC = (CRC * 3) + stComputeTypeCRC(arg->adType);
    }

    /* Include the presence of "..." in the CRC */

    if  (typ->tdFnc.tdfArgs.adVarArgs)
        CRC ^= 33;

    /* Note: we have to return the value as it is stored in the function type */

    typ->tdFnc.tdfArgs.adCRC = CRC;

    /* Make sure the value is non-zero and store it in the function type */

    if  (typ->tdFnc.tdfArgs.adCRC == 0)
         typ->tdFnc.tdfArgs.adCRC++;

    return typ->tdFnc.tdfArgs.adCRC;
}

/*****************************************************************************
 *
 *  Returns non-zero if the two function argument lists are equivalent.
 */

bool                symTab::stArgsMatch(TypDef typ1, TypDef typ2)
{
    ArgDef          arg1;
    ArgDef          arg2;

    assert(typ1->tdTypeKind == TYP_FNC);
    assert(typ2->tdTypeKind == TYP_FNC);

    /* Compare argument CRC's first */

    unsigned        CRC1 = typ1->tdFnc.tdfArgs.adCRC;
    unsigned        CRC2 = typ2->tdFnc.tdfArgs.adCRC;

    assert(CRC1 == 0 || CRC1 == symTab::stComputeArgsCRC(typ1));
    assert(CRC2 == 0 || CRC2 == symTab::stComputeArgsCRC(typ2));

    if (!CRC1)      CRC1 = symTab::stComputeArgsCRC(typ1);
    if (!CRC2)      CRC2 = symTab::stComputeArgsCRC(typ2);

    if  (CRC1 != CRC2)
        return false;

    /* Either both or neither must be varargs functions */

    if  (typ1->tdFnc.tdfArgs.adVarArgs != typ2->tdFnc.tdfArgs.adVarArgs)
        return false;

    /* Compare the two argument lists */

    for (arg1 = typ1->tdFnc.tdfArgs.adArgs,
         arg2 = typ2->tdFnc.tdfArgs.adArgs;
         arg1 &&
         arg2;
         arg1 = arg1->adNext,
         arg2 = arg2->adNext)
    {
        if  (!symTab::stMatchTypes(arg1->adType, arg2->adType))
            return false;
    }

    if  (arg1 || arg2)
        return false;

    return  true;
}

/*****************************************************************************
 *
 *  Given two classes, return a non-zero value if the first is the base class
 *  of the second. The number returned is the number of intervening classes
 *  between the derived class and the base (1 if they are identical).
 */

unsigned            symTab::stIsBaseClass(TypDef baseTyp, TypDef dervTyp)
{
    unsigned        cost = 1;

    assert(baseTyp && baseTyp->tdTypeKind == TYP_CLASS);
    assert(dervTyp && dervTyp->tdTypeKind == TYP_CLASS);

    do
    {
        TypList         ifl;

        if  (baseTyp == dervTyp)
            return cost;

        assert(dervTyp && dervTyp->tdTypeKind == TYP_CLASS);

        cost++;

        /* Make sure the base classes of the derived type are known */

        if  (dervTyp->tdClass.tdcSymbol->sdCompileState < CS_DECLSOON)
            stComp->cmpDeclSym(dervTyp->tdClass.tdcSymbol);

        /* Check any interfaces the class implements */

        for (ifl = dervTyp->tdClass.tdcIntf; ifl; ifl = ifl->tlNext)
        {
            unsigned    more;

            more = stIsBaseClass(baseTyp, ifl->tlType);
            if  (more)
                return cost + more;
        }

        /* Continue with the base class, if any */

        dervTyp = dervTyp->tdClass.tdcBase;
    }
    while (dervTyp);

    return 0;
}

/*****************************************************************************
 *
 *  Append the specified type as an argument to the given argument list. Note
 *  that we make a copy of the argument list so that the argument descriptor
 *  that is passed in remains unmolested.
 */

void                symTab::stAddArgList(INOUT ArgDscRec REF args,
                                               TypDef        type,
                                               Ident         name)
{
    ArgDef          list;
    ArgDef          last;
    ArgDef          arec;
    size_t          asiz;

    ArgDscRec       adsc;

    assert(args.adArgs);
    assert(args.adCount);

    /* Clear the new descriptor */

#if MGDDATA
    adsc = new ArgDscRec;
#else
    memset(&adsc, 0, sizeof(adsc));
#endif

    /* Copy over some stuff from the original descriptor */

    adsc.adCount = args.adCount+1;

    /* Figure out how big the descriptors ought to be */

    asiz = args.adExtRec ? sizeof(ArgExtRec)
                         : sizeof(ArgDefRec);

    /* Make a copy of the incoming argument list */

    list = args.adArgs;
    last = NULL;

    do
    {
        /* Allocate and copy over the next entry */

#if MGDDATA
        arec = new ArgDef; UNIMPL(!"need to copy argdef record");
#else
        arec =    (ArgDef)stAllocPerm->nraAlloc(asiz); memcpy(arec, list, asiz);
#endif

        /* Add the entry to the list */

        if  (last)
            last->adNext = arec;
        else
            adsc.adArgs  = arec;

        last = arec;

        /* Continue with the next entry */

        list = list->adNext;
    }
    while (list);

    /* Allocate the entry we're supposed to add and fill it in */

#if MGDDATA
    arec = new ArgDef;
#else
    arec =    (ArgDef)stAllocPerm->nraAlloc(asiz); memset(arec, 0, sizeof(*arec));
#endif

    arec->adType  = type;
    arec->adName  = name;

#ifdef  DEBUG
    arec->adIsExt = args.adExtRec;
#endif

    /* Append the new entry to the copied list */

    last->adNext  = arec;

    /* Give the new descriptor back to the caller */

    args = adsc;
}

void                symTab::stExtArgsBeg(  OUT ArgDscRec REF newArgs,
                                           OUT ArgDef    REF lastArg,
                                               ArgDscRec     oldArgs,
                                               bool          prefix,
                                               bool          outOnly)
{
    ArgDef          list;
    ArgDef          last;
    ArgDef          arec;
    size_t          asiz;

    /* Clear the new descriptor */

#if MGDDATA
    newArgs = new ArgDscRec;
#else
    memset(&newArgs, 0, sizeof(newArgs));
#endif

    /* Copy over information from the original descriptor */

    newArgs.adExtRec  = oldArgs.adExtRec;
    newArgs.adVarArgs = oldArgs.adVarArgs;
    newArgs.adDefs    = oldArgs.adDefs;
    newArgs.adCount   = 0;
    newArgs.adArgs    = NULL;

    /* Done if the caller wants to prefix any arguments */

    if  (prefix)
        return;

    /* Figure out how big the descriptors ought to be */

    asiz = oldArgs.adExtRec ? sizeof(ArgExtRec)
                            : sizeof(ArgDefRec);

    /* Copy over the old argument list */

    list = oldArgs.adArgs;
    last = NULL;

    while (list)
    {
        if  (outOnly)
        {
            if  (!newArgs.adExtRec)
                goto NEXT;

            assert(list->adIsExt);

            if  (!(((ArgExt)list)->adFlags & (ARGF_MODE_OUT  |
                                              ARGF_MODE_INOUT|
                                              ARGF_MODE_REF)))
            {
                goto NEXT;
            }
        }

        /* Allocate and copy over the next entry */

#if MGDDATA
        arec = new ArgDef; UNIMPL(!"need to copy argdef record");
#else
        arec =    (ArgDef)stAllocPerm->nraAlloc(asiz); memcpy(arec, list, asiz);
#endif

        /* Add the entry to the list */

        if  (last)
            last->adNext   = arec;
        else
            newArgs.adArgs = arec;

        last = arec;

        /* Keep track of the argument count */

        newArgs.adCount++;

    NEXT:

        /* Continue with the next entry */

        list = list->adNext;
    }

    /* Terminate the list of non-empty */

    if  (last)
        last->adNext = NULL;

    /* The caller promises to hang on to the 'last' value for us */

    lastArg = last;
}

void                symTab::stExtArgsAdd(INOUT ArgDscRec REF newArgs,
                                         INOUT ArgDef    REF lastArg,
                                               TypDef        argType,
                                               const char *  argName)
{
    ArgDef          arec;
    size_t          asiz;

    /* Figure out how big the descriptors ought to be */

    asiz = newArgs.adExtRec ? sizeof(ArgExtRec)
                            : sizeof(ArgDefRec);

    /* Allocate and clear the next entry */

#if MGDDATA
    arec = new ArgDef; UNIMPL(!"need to copy argdef record");
#else
    arec =    (ArgDef)stAllocPerm->nraAlloc(asiz); memset(arec, 0, asiz);
#endif

    arec->adType  = argType;
    arec->adName  = argName ? stHash->hashString(argName) : NULL;

#ifdef  DEBUG
    arec->adIsExt = newArgs.adExtRec;
#endif

    /* Append the entry to the end of the list */

    if  (lastArg)
        lastArg->adNext = arec;
    else
        newArgs.adArgs  = arec;

    lastArg = arec;

    /* Bump the argument count */

    newArgs.adCount++;
}

void                symTab::stExtArgsEnd(INOUT ArgDscRec REF newArgs)
{

#ifndef NDEBUG

    ArgDef          arg;
    unsigned        cnt;

    for (arg = newArgs.adArgs, cnt = 0;
         arg;
         arg = arg->adNext   , cnt++);

    assert(cnt == newArgs.adCount);

#endif

}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\vartype.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _VARTYPE_H_
#define _VARTYPE_H_
/*****************************************************************************/

enum    var_types_classification
{
    VTF_ANY = 0x0000,
    VTF_INT = 0x0001,
    VTF_UNS = 0x0002,
    VTF_FLT = 0x0004,
    VTF_SCL = 0x0008,
    VTF_ARI = 0x0010,
    VTF_IND = 0x0080,
};

#ifndef __SMC__

enum    var_types
{
    #define DEF_TP(tn,sz,al,nm,tf) TYP_##tn,
    #include "typelist.h"
    #undef  DEF_TP

    TYP_COUNT,

    TYP_lastIntrins = TYP_REFANY
};

#endif

#ifdef  FAST
typedef unsigned    varType_t;
#else
typedef var_types   varType_t;
#endif

/*****************************************************************************/

#ifndef __SMC__
extern  BYTE        varTypeClassification[TYP_COUNT];
#endif

inline  bool        varTypeIsIntegral  (var_types vt)
{
    assert((unsigned)vt < TYP_COUNT);
    return  (bool)((varTypeClassification[vt] & (VTF_INT)) != 0);
}

inline  bool        varTypeIsIntArith  (var_types vt)
{
    assert((unsigned)vt < TYP_COUNT);
    return  (bool)((varTypeClassification[vt] & (VTF_INT|VTF_ARI)) == (VTF_INT|VTF_ARI));
}

inline  bool        varTypeIsUnsigned  (var_types vt)
{
    assert((unsigned)vt < TYP_COUNT && vt != TYP_ENUM);
    return  (bool)((varTypeClassification[vt] & (VTF_UNS)) != 0);
}

inline  bool        varTypeIsFloating  (var_types vt)
{
    assert((unsigned)vt < TYP_COUNT);
    return  (bool)((varTypeClassification[vt] & (VTF_FLT)) != 0);
}

inline  bool        varTypeIsArithmetic(var_types vt)
{
    assert((unsigned)vt < TYP_COUNT);
    return  (bool)((varTypeClassification[vt] & (VTF_ARI)) != 0);
}

inline  bool        varTypeIsScalar    (var_types vt)
{
    assert((unsigned)vt < TYP_COUNT);
    return  (bool)((varTypeClassification[vt] & (VTF_SCL)) != 0);
}

inline  bool        varTypeIsSclOrFP   (var_types vt)
{
    assert((unsigned)vt < TYP_COUNT);
    return  (bool)((varTypeClassification[vt] & (VTF_SCL|VTF_FLT)) != 0);
}

inline  bool        varTypeIsIndirect  (var_types vt)
{
    assert((unsigned)vt < TYP_COUNT);
    return  (bool)((varTypeClassification[vt] & (VTF_IND)) != 0);
}

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\type.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _TYPE_H_
#define _TYPE_H_
/*****************************************************************************/
#ifndef _VARTYPE_H_
#include "vartype.h"
#endif
/*****************************************************************************/
#ifndef _ALLOC_H_
#include "alloc.h"
#endif
/*****************************************************************************/
#ifndef _SCAN_H_
#include "scan.h"
#endif
/*****************************************************************************/

DEFMGMT
class ArgDefRec
{
public:

    ArgDef          adNext;
    TypDef          adType;                     // 0 for "..."

#ifdef  DEBUG
    bool            adIsExt;                    // an "ArgDefExt" instance?
#endif

    Ident           adName;                     // NULL if not available
};

DEFMGMT
class ArgExtRec : public ArgDefRec
{
public:

    unsigned        adFlags;                    // see ARGF_xxxx
#if MGDDATA
    ConstVal        adDefVal;                   // optional default value
#else
    constVal        adDefVal;                   // optional default value
#endif
    SymXinfo        adAttrs;                    // custom attributes
};

enum   ArgDefFlags
{
    ARGF_MODE_OUT   = 0x01,
    ARGF_MODE_INOUT = 0x02,                     // note: default is "in"
    ARGF_MODE_REF   = 0x04,                     // "raw" (unmanaged) reference

    ARGF_DEFVAL     = 0x08,                     // default value present?

    ARGF_MARSH_ATTR = 0x10                      // marshalling attribute present?
};

DEFMGMT
struct  ArgDscRec
{
    unsigned short  adCRC;                      // for faster arglist comparisons
    unsigned short  adCount     :12;            // number of arguments
    unsigned short  adExtRec    :1;             // entries are extended?
    unsigned short  adVarArgs   :1;             // variable argument list?
    unsigned short  adAttrs     :1;             // custom attribute(s) present?
    unsigned short  adDefs      :1;             // default value(s)    present?

    BYTE    *       adSig;                      // signature string or NULL
    ArgDef          adArgs;                     // head of argument list
};

/*****************************************************************************/

DEFMGMT class DimDefRec
{
public:

    DimDef          ddNext;

    Tree            ddLoTree;                   // low  bound expression
    Tree            ddHiTree;                   // high bound expression

    unsigned        ddIsConst   :1;             // constant fixed dimension
    unsigned        ddNoDim     :1;             // "*" in this position
#ifdef  DEBUG
    unsigned        ddDimBound  :1;             // the lo/hi trees have been bound
#endif

    unsigned        ddSize;                     // constant dimension value
};

/*****************************************************************************/

DEFMGMT
class TypDefRec
{
public:

    /* We store the 'kind' as a simple byte for speed (enum for debugging) */

#ifdef  FAST
    unsigned char   tdTypeKind;
#else
    var_types       tdTypeKind;
#endif

    var_types       tdTypeKindGet()
    {
        return  (var_types)tdTypeKind;          // with 'FAST' tdTypeKind is BYTE
    }

    /*
        Since we'd waste 24 bits if we didn't put anything here,
        we'll put some flags that apply only to one of the type
        variants here to use at least some of the bits (which
        would otherwise be wasted on padding anyway).
     */

    unsigned char   tdIsManaged     :1;         // all  : managed type?
    unsigned char   tdIsGenArg      :1;         // all  : uses a generic type arg?

    unsigned char   tdIsValArray    :1;         // array: managed value elems?
    unsigned char   tdIsUndimmed    :1;         // array: no dimension(s) given?
    unsigned char   tdIsGenArray    :1;         // array: non-zero low bound?

    unsigned char   tdIsDelegate    :1;         // class: delegate?
    unsigned char   tdIsIntrinsic   :1;         // class: intrinsic value type?

    unsigned char   tdIsImplicit    :1;         // ref  : implicit managed ref?
    unsigned char   tdIsObjRef      :1;         // ref  : Object ref?

#ifdef  OLD_IL
    unsigned short  tdDbgIndex;
#endif

    // .... 16 bits available for various flags and things ....

    UNION(tdTypeKind)
    {

    CASE(TYP_CLASS)

        struct
        {
            SymDef          tdcSymbol;          // the class symbol
            TypDef          tdcRefTyp;          // type "ref/ptr to this class"
            TypDef          tdcBase;            // base class type or 0
            TypList         tdcIntf;            // interface list  or 0

            size_t          tdcSize;            // instance size in bytes (if known)

#ifdef  SETS

            TypDef          tdcNextHash;        // next entry in the hash     bucket
            TypDef          tdcNextSame;        // next entry in the identity bucket

            unsigned        tdcHashVal      :16;

#endif

            unsigned        tdcIntrType     :4; // for intrinsic value types
            unsigned        tdcFlavor       :3; // union/struct/class/intf
            unsigned        tdcAlignment    :3; // 0=byte,1=word,2=dword,3=qword
            unsigned        tdcHasCtor      :1; // non-empty ctor(s) present
            unsigned        tdcLayoutDone   :1; // class layout done?
            unsigned        tdcLayoutDoing  :1; // class layout is being done?
            unsigned        tdcFnPtrWrap    :1; // method pointer wrapper (aka delegate)?
            unsigned        tdcValueType    :1; // default is value not ref
            unsigned        tdcHasIntf      :1; // class or its base has interfaces
            unsigned        tdcAnonUnion    :1; // anonymous union?
            unsigned        tdcTagdUnion    :1; // tagged    union?

            unsigned        tdcContext      :2; // unbound=0,appdomain=1,contextful=2
        }
            tdClass;

    CASE(TYP_REF)
    CASE(TYP_PTR)

        struct  // Note: the following used for both refs and ptrs
        {
            TypDef          tdrBase;            // type the ref/ptr points to
            TypDef          tdrNext;            // next entry in the hash chain
        }
            tdRef;

    CASE(TYP_FNC)

        struct
        {
            TypDef          tdfRett;            // return type of the function
            ArgDscRec       tdfArgs;            // argument list
            mdToken         tdfPtrSig;          // token for methodref or 0
        }
            tdFnc;

    CASE(TYP_ARRAY)

        struct
        {
            TypDef          tdaElem;            // element type
            DimDef          tdaDims;            // dimension list (or NULL)
            TypDef          tdaBase;            // next more generic array type
            unsigned        tdaDcnt;            // number of dimensions
            TypDef          tdaNext;            // next entry in the hash chain

            mdToken         tdaTypeSig;         // token if metadata gen'd
        }
            tdArr;

    CASE(TYP_ENUM)

        struct
        {
            SymDef          tdeSymbol;          // the enum type symbol
            SymDef          tdeValues;          // the enum value symbols
            TypDef          tdeIntType;         // the underlying integer type
        }
            tdEnum;

    CASE(TYP_TYPEDEF)

        struct
        {
            SymDef          tdtSym;             // the typedef symbol
            TypDef          tdtType;            // the type referred to
        }
            tdTypedef;

    CASE(TYP_UNDEF)

        struct
        {
            Ident           tduName;            // for better error messages
        }
            tdUndef;

    DEFCASE

        struct
        {
            // no additional fields needed for intrinsic types
        }
            tdIntrinsic;
    };
};

/*****************************************************************************
 *
 *  IMPORTANT:  Please keep the contents of "typsizes.h" in synch with
 *              the declarations above!
 */

#include "typsizes.h"

/*****************************************************************************/

const   unsigned    tmPtrTypeHashSize = 256;

/*****************************************************************************/

inline
bool                isMgdValueType(TypDef type)
{
    return  (type->tdTypeKind == TYP_CLASS &&
             type->tdIsManaged             &&
             type->tdClass.tdcValueType);
}

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\typsizes.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _TYPSIZES_H_
#define _TYPSIZES_H_

/*****************************************************************************/

const   size_t  typDef_size_base    = (offsetof(TypDefRec, tdIntrinsic));

const   size_t  typDef_size_array   = (size2mem(TypDefRec, tdArr      ));
const   size_t  typDef_size_fnc     = (size2mem(TypDefRec, tdFnc      ));
const   size_t  typDef_size_ptr     = (size2mem(TypDefRec, tdRef      ));
const   size_t  typDef_size_ref     = (size2mem(TypDefRec, tdRef      ));
const   size_t  typDef_size_enum    = (size2mem(TypDefRec, tdEnum     ));
const   size_t  typDef_size_undef   = (size2mem(TypDefRec, tdUndef    ));
const   size_t  typDef_size_class   = (size2mem(TypDefRec, tdClass    ));
const   size_t  typDef_size_typedef = (size2mem(TypDefRec, tdTypedef  ));

/*****************************************************************************/
#endif//_TYPSIZES_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\typelist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
DEF_TP(UNDEF    , 1, 1, "<UNDEF>"    , 0                              )
DEF_TP(VOID     , 0, 0, "void"       , 0                              )

DEF_TP(BOOL     , 1, 1, "boolean"    ,         VTF_SCL|VTF_INT|VTF_UNS)
DEF_TP(WCHAR    , 2, 2, "wchar"      ,         VTF_SCL|VTF_INT|VTF_UNS)

DEF_TP(CHAR     , 1, 1, "char"       , VTF_ARI|VTF_SCL|VTF_INT        )
DEF_TP(UCHAR    , 1, 1, "uchar"      , VTF_ARI|VTF_SCL|VTF_INT|VTF_UNS)
DEF_TP(SHORT    , 2, 2, "short"      , VTF_ARI|VTF_SCL|VTF_INT        )
DEF_TP(USHORT   , 2, 2, "ushort"     , VTF_ARI|VTF_SCL|VTF_INT|VTF_UNS)
DEF_TP(INT      , 4, 4, "int"        , VTF_ARI|VTF_SCL|VTF_INT        )
DEF_TP(UINT     , 4, 4, "uint"       , VTF_ARI|VTF_SCL|VTF_INT|VTF_UNS)
DEF_TP(NATINT   , 0, 8, "naturalint" , VTF_ARI|VTF_SCL|VTF_INT        )
DEF_TP(NATUINT  , 0, 8, "naturaluint", VTF_ARI|VTF_SCL|VTF_INT|VTF_UNS)
DEF_TP(LONG     , 8, 8, "longint"    , VTF_ARI|VTF_SCL|VTF_INT        )
DEF_TP(ULONG    , 8, 8, "ulongint"   , VTF_ARI|VTF_SCL|VTF_INT|VTF_UNS)

DEF_TP(FLOAT    , 4, 4, "float"      , VTF_ARI        |VTF_FLT        )
DEF_TP(DOUBLE   , 8, 8, "double"     , VTF_ARI        |VTF_FLT        )
DEF_TP(LONGDBL  , 0, 0, "longdbl"    , VTF_ARI        |VTF_FLT        )
DEF_TP(REFANY   , 0, 0, "void &"     , 0                              )

DEF_TP(ARRAY    , 4, 4, "array"      ,         VTF_SCL        |VTF_UNS)
DEF_TP(CLASS    , 0, 0, "class"      , 0                              )
DEF_TP(FNC      , 0, 0, "function"   , 0                              )
DEF_TP(REF      , 4, 4, "ref"        ,         VTF_SCL        |VTF_UNS)
DEF_TP(PTR      , 4, 4, "pointer"    ,         VTF_SCL        |VTF_UNS)

DEF_TP(ENUM     , 0, 0, "enum"       ,         VTF_SCL|VTF_IND|VTF_INT)
DEF_TP(TYPEDEF  , 0, 0, "typedef"    ,                 VTF_IND        )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\version.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
const   char *      COMPILER_VERSION = "0.90.2321";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\typedefs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _TYPEDEFS_H_
#define _TYPEDEFS_H_
/*****************************************************************************/

#ifndef MR
#error  Define "MR" to an empty string if using managed data, "*" otherwise.
#endif

/*****************************************************************************/

DEFMGMT
class   compiler;
typedef compiler     MR Compiler;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   parser;
typedef parser       MR Parser;

DEFMGMT
struct  usingState;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   genIL;
typedef genIL        MR GenILref;

#ifdef  OLD_IL
DEFMGMT
class   genOIL;
typedef genOIL       MR GenOILref;
#endif

DEFMGMT
struct  stmtNestRec;
typedef stmtNestRec   * StmtNest;

DEFMGMT
class   ILfixupDsc;
typedef ILfixupDsc   MR ILfixup;

DEFMGMT
class   ILtempDsc;
typedef ILtempDsc    MR ILtemp;

DEFMGMT
class   ILswitchDsc;
typedef ILswitchDsc  MR ILswitch;

DEFMGMT
class   handlerDsc;
typedef handlerDsc   MR Handler;

DEFMGMT
class   lineInfoRec;
typedef lineInfoRec  MR LineInfo;

DEFMGMT
class   strEntryDsc;
typedef strEntryDsc  MR StrEntry;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   writePE;
typedef writePE      MR WritePE;

/*---------------------------------------------------------------------------*/

class   MDsigImport;
struct  MDargImport;

DEFMGMT
class   metadataImp;
typedef metadataImp  MR MetaDataImp;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   hashTab;
typedef hashTab      MR HashTab;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   XinfoDsc;
typedef XinfoDsc     MR  SymXinfo;

DEFMGMT
class   XinfoLnk;
typedef XinfoLnk     MR  SymXinfoLnk;

DEFMGMT
class   XinfoSec;
typedef XinfoSec     MR  SymXinfoSec;

DEFMGMT
class   XinfoAtc;
typedef XinfoAtc     MR  SymXinfoAtc;

DEFMGMT
class   XinfoCOM;
typedef XinfoCOM     MR  SymXinfoCOM;

DEFMGMT
class   XinfoSym;
typedef XinfoSym     MR  SymXinfoSym;

DEFMGMT
class   XinfoAttr;
typedef XinfoAttr    MR  SymXinfoAttr;

DEFMGMT
class   GenArgRec;
typedef GenArgRec    MR  GenArgDsc;

DEFMGMT
class   GenArgRecF;
typedef GenArgRecF   MR  GenArgDscF;

DEFMGMT
class   GenArgRecA;
typedef GenArgRecA   MR  GenArgDscA;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   scanner;
typedef scanner      MR Scanner;

DEFMGMT
class   RecTokDsc;
typedef RecTokDsc    MR RecTok;

DEFMGMT
class   queuedFile;
typedef queuedFile   MR QueuedFile;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   symTab;
typedef symTab       MR SymTab;

DEFMGMT
class   IdentRec;
typedef IdentRec     MR Ident;

DEFMGMT
class   SymDefRec;
typedef SymDefRec    MR SymDef;

DEFMGMT
class   TypDefRec;
typedef TypDefRec    MR TypDef;

DEFMGMT
class   DimDefRec;
typedef DimDefRec    MR DimDef;

DEFMGMT
struct  ArgDscRec;
typedef ArgDscRec    MR ArgDsc;

DEFMGMT
class   ArgDefRec;
typedef ArgDefRec    MR ArgDef;

DEFMGMT
class   ArgExtRec;
typedef ArgExtRec    MR ArgExt;

DEFMGMT
class   constStr;
typedef constStr     MR ConstStr;

/*---------------------------------------------------------------------------*/

struct  declMods;
typedef declMods      * DeclMod;

DEFMGMT
class   constVal;
typedef constVal     MR ConstVal;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   MacDefRec;
typedef MacDefRec    MR MacDef;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   TreeNode;
typedef TreeNode     MR Tree;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   QualNameRec;
typedef QualNameRec  MR QualName;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   LinkDesc;
typedef LinkDesc     MR Linkage;

/*---------------------------------------------------------------------------*/

struct  DefSrcDsc;
typedef DefSrcDsc     * DefSrc;

DEFMGMT
class   DefListRec;
typedef DefListRec   MR DefList;

DEFMGMT
class   UseListRec;
typedef UseListRec   MR UseList;

DEFMGMT
class   SymListRec;
typedef SymListRec   MR SymList;

DEFMGMT
class   MemListRec;
typedef MemListRec   MR ExtList;

DEFMGMT
class   IniListRec;
typedef IniListRec   MR IniList;

DEFMGMT
class   TypListRec;
typedef TypListRec   MR TypList;

DEFMGMT
class   StrListRec;
typedef StrListRec   MR StrList;

DEFMGMT
class   BlkListRec;
typedef BlkListRec   MR BlkList;

DEFMGMT
class   PrepListRec;
typedef PrepListRec  MR PrepList;

DEFMGMT
class   IdentListRec;
typedef IdentListRec MR IdentList;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   VecEntryDsc;
typedef VecEntryDsc  MR VecEntry;

enum    vecEntryKinds
{
    VEC_NONE,
    VEC_TOKEN_DIST,
};

/*---------------------------------------------------------------------------*/

DEFMGMT
class   NumPairDsc;
typedef NumPairDsc   MR NumPair;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   SecurityDesc;
typedef SecurityDesc MR SecurityInfo;

DEFMGMT
class   PairListRec;
typedef PairListRec  MR PairList;

/*---------------------------------------------------------------------------*/

DEFMGMT
class   ILblockDsc;
typedef ILblockDsc   MR ILblock;

/*****************************************************************************/
#if MGDDATA

typedef Tree   managed[]vectorTree;
typedef SymDef managed[]vectorSym;

typedef Object          genericRef;
typedef BYTE   managed[]genericBuff;
typedef char   managed[] stringBuff;

DEFMGMT struct          memBuffPtr
{
    BYTE managed []         buffBase;
    unsigned                buffOffs;

    memBuffPtr(size_t size)
    {
        buffBase = new managed BYTE [size];
        buffOffs = 0;
    }
};

typedef String          wideString;
typedef String          normString;

#else

typedef Tree          * vectorTree;
typedef SymDef        * vectorSym;

typedef void          * genericRef;
typedef BYTE          * genericBuff;
typedef char          *  stringBuff;

typedef BYTE          * memBuffPtr;

typedef wchar         * wideString;
typedef const char    * normString;

typedef BYTE    *       scanPosTP;

#endif

typedef unsigned        scanDifTP;

/*****************************************************************************/

#ifdef  SETS

DEFMGMT
class   funcletDesc;
typedef funcletDesc  MR funcletList;

DEFMGMT
struct  collOpNest;
typedef collOpNest   MR collOpList;

typedef genericBuff     SaveTree;

#endif

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "smctest.exe"
#define VER_FILEDESCRIPTION_STR "Common Language Runtime sample compiler\0"
#define VER_ORIGFILENAME_STR    "smctest.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\obj\i386\versionnum.cpp ===
#include <smcPCH.h>

extern "C"
const   char *      COMPILER_VERSION = "0.90.0220";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\objd\i386\versionnum.cpp ===
#include <smcPCH.h>

extern "C"
const   char *      COMPILER_VERSION = "0.90.0902";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\corwrap\corwrap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <stdio.h>
#include <assert.h>
#include <windows.h>

/*****************************************************************************/

#define COR_IMPORT(d,s) __declspec(dllexport)

#include <COR.h>
#include <CorSym.h>

#include "CORwrap.h"

/*****************************************************************************/

#if 0

const   unsigned    META_S_DUPLICATE  = 0x131197;

void                logCall(int err, const char *name)
{
    static
    bool            doit;
    static
    bool            init;
    static
    unsigned        ord;

    if  (!init)
    {
        init = true;
        doit = getenv("LOGMD") ? true : false;
    }

    if  (err && err != 1 && err != META_S_DUPLICATE)
        printf("WARNING: Error %08X returned from metadata API '%s'\n", err, name);

#ifndef __IL__
    if (++ord == 0x0) __asm int 3
#endif

    if  (!doit)
        return;

#ifndef __IL__
    printf("[%04X] ", ord);
#endif

    if      (err == -1)
        printf("Return(-1)");
    else if (err == 0)
        printf("Return(OK)");
    else if (err == 1)
        printf("Return(N/A)");
    else if (err == META_S_DUPLICATE)
        printf("Return(dup)");
    else
        printf("Return(0x%X)", err);

    printf(" from '%s'\n", name);
}

#else

inline
void                logCall(int err, const char *name){}

#endif

/*****************************************************************************/

bool                CORinitialized;

/*****************************************************************************/

void                WMetaData::AddRef (){}
void                WMetaData::Release(){}

/*****************************************************************************/

const GUID*__stdcall getIID_CorMetaDataRuntime()      { return &CLSID_CorMetaDataRuntime;    }

const GUID*__stdcall getIID_IMetaDataImport()         { return &IID_IMetaDataImport;         }
const GUID*__stdcall getIID_IMetaDataEmit()           { return &IID_IMetaDataEmit;           }

const GUID*__stdcall getIID_IMetaDataAssemblyImport() { return &IID_IMetaDataAssemblyImport; }
const GUID*__stdcall getIID_IMetaDataAssemblyEmit()   { return &IID_IMetaDataAssemblyEmit;   }

/*****************************************************************************/

struct  intfListRec;
typedef intfListRec*IntfList;
struct  intfListRec
{
    IntfList        ilNext;
    void        *   ilIntf;
    WMetaData   *   ilWrap;
};

IntfList            IMDDlist;
IntfList            IMDIlist;
IntfList            IMDElist;
IntfList            IASIlist;
IntfList            IASElist;

IntfList            SYMWlist;

WMetaData   *       findIntfListEntry(IntfList list, void *intf)
{
    IntfList        temp;

    for (temp = list; temp; temp = temp->ilNext)
    {
        if  (temp->ilIntf == intf)
            return  temp->ilWrap;
    }

    return  NULL;
}

void                 addIntfListEntry(IntfList &list, void *intf, WMetaData *wrap)
{
    IntfList        temp;

    temp = new intfListRec;
    temp->ilIntf = intf;
    temp->ilWrap = wrap;
    temp->ilNext = list;
                   list = temp;
}

/*****************************************************************************/

WMetaDataDispenser *  __stdcall makeIMDDwrapper(IMetaDataDispenser *intf)
{
    WMetaDataDispenser *wrap;
    WMetaData          *oldw;

    oldw = findIntfListEntry(IMDDlist, intf);
    if  (oldw)
        return  dynamic_cast<WMetaDataDispenser *>(oldw);

    wrap = new WMetaDataDispenser;

    wrap->useCount = 1;
    wrap->imdd     = intf;

    addIntfListEntry(IMDDlist, intf, wrap);

    return  wrap;
}

WMetaDataImport    *  __stdcall makeIMDIwrapper(IMetaDataImport    *intf)
{
    WMetaDataImport    *wrap;
    WMetaData          *oldw;

    oldw = findIntfListEntry(IMDIlist, intf);
    if  (oldw)
        return  dynamic_cast<WMetaDataImport    *>(oldw);

    wrap = new WMetaDataImport;

    wrap->useCount = 1;
    wrap->imdi     = intf;

#ifdef SMC_MD_PERF
    wrap->cycleCounterInit();
    wrap->cycleCounterBeg();
    wrap->cycleCounterPause();
#endif

    addIntfListEntry(IMDIlist, intf, wrap);

    return  wrap;
}

WMetaDataEmit      *  __stdcall makeIMDEwrapper(IMetaDataEmit      *intf)
{
    WMetaDataEmit      *wrap;
    WMetaData          *oldw;

    oldw = findIntfListEntry(IMDElist, intf);
    if  (oldw)
        return  dynamic_cast<WMetaDataEmit      *>(oldw);

    wrap = new WMetaDataEmit;

    wrap->useCount = 1;
    wrap->imde     = intf;

#ifdef SMC_MD_PERF
    wrap->cycleCounterInit();
    wrap->cycleCounterBeg();
    wrap->cycleCounterPause();
#endif

    addIntfListEntry(IMDElist, intf, wrap);

    return  wrap;
}

WAssemblyImport    *  __stdcall makeIASIwrapper(IMetaDataAssemblyImport*intf)
{
    WAssemblyImport    *wrap;
    WMetaData          *oldw;

    oldw = findIntfListEntry(IASIlist, intf);
    if  (oldw)
        return  dynamic_cast<WAssemblyImport    *>(oldw);

    wrap = new WAssemblyImport;

    wrap->useCount = 1;
    wrap->iasi     = intf;

#ifdef SMC_MD_PERF
    wrap->cycleCounterInit();
    wrap->cycleCounterBeg();
    wrap->cycleCounterPause();
#endif

    addIntfListEntry(IASIlist, intf, wrap);

    return  wrap;
}

WAssemblyEmit      *  __stdcall makeIASEwrapper(IMetaDataAssemblyEmit  *intf)
{
    WAssemblyEmit      *wrap;
    WMetaData          *oldw;

    oldw = findIntfListEntry(IASElist, intf);
    if  (oldw)
        return  dynamic_cast<WAssemblyEmit      *>(oldw);

    wrap = new WAssemblyEmit;

    wrap->useCount = 1;
    wrap->iase     = intf;

#ifdef SMC_MD_PERF
    wrap->cycleCounterInit();
    wrap->cycleCounterBeg();
    wrap->cycleCounterPause();
#endif

    addIntfListEntry(IASElist, intf, wrap);

    return  wrap;
}

WSymWriter         *  __stdcall makeSYMWwrapper(void *intf)
{
    WSymWriter         *wrap;
    WMetaData          *oldw;

    oldw = findIntfListEntry(SYMWlist, intf);
    if  (oldw)
        return  dynamic_cast<WSymWriter *>(oldw);

    wrap = new WSymWriter;

    wrap->useCount = 1;
    wrap->isw      = intf;

    addIntfListEntry(SYMWlist, intf, wrap);

    return  wrap;
}

/*****************************************************************************/

IMetaDataDispenser     *__stdcall  uwrpIMDDwrapper(WMetaDataDispenser *inst)
{
    return  inst->imdd;
}

IMetaDataImport        *__stdcall  uwrpIMDIwrapper(WMetaDataImport    *inst)
{
    return  inst->imdi;
}

IMetaDataEmit          *__stdcall  uwrpIMDEwrapper(WMetaDataEmit      *inst)
{
    return  inst->imde;
}

IMetaDataAssemblyEmit  *__stdcall   uwrpIASEwrapper(WAssemblyEmit      *inst)
{
    return  inst->iase;
}

IMetaDataAssemblyImport*__stdcall   uwrpIASIwrapper(WAssemblyImport    *inst)
{
    return  inst->iasi;
}

/*****************************************************************************/

int WMetaDataDispenser::DefineScope(    const CLSID *       rclsid,
                                        DWORD               dwCreateFlags,
                                        const IID *         riid,
                                        WMetaDataEmit   * * intfPtr)
{
    int             err;
    IMetaDataEmit  *imde;

    err = imdd->DefineScope(*rclsid, dwCreateFlags, *riid, (IUnknown **)&imde);

    if  (err)
    {
        *intfPtr = NULL;
    }
    else
    {
        *intfPtr = makeIMDEwrapper(imde);
    }

    return  err;
}

int WMetaDataDispenser::DefineAssem(WMetaDataEmit     * emitPtr,
                                    WAssemblyEmit   * * intfPtr)
{
    int                     err;
    IMetaDataAssemblyEmit  *iase;

    err = emitPtr->imde->QueryInterface(IID_IMetaDataAssemblyEmit, (void **)&iase);

    if  (err)
    {
        *intfPtr = NULL;
    }
    else
    {
        *intfPtr = makeIASEwrapper(iase);
    }

    return  err;
}

int WMetaDataDispenser::OpenScope(      LPCWSTR             szScope,
                                        DWORD               dwOpenFlags,
                                        const IID *         riid,
                                        WMetaDataImport * * intfPtr)
{
    int             err;
    IMetaDataImport*imdi;

//  printf("this = %08X, scp = %08X, flags = %08X, ridd = %08X, intf = %08X\n", this, szScope, dwOpenFlags, riid, intfPtr);

    err = imdd->OpenScope(szScope, dwOpenFlags, *riid, (IUnknown **)&imdi);

    if  (err)
    {
        *intfPtr = NULL;
    }
    else
    {
        *intfPtr = makeIMDIwrapper(imdi);
    }

    return  err;
}

/*****************************************************************************/
#if __BEGIN_ATROCIOUS_HACK__ || 1
/*****************************************************************************/

static
PIMAGE_SECTION_HEADER Cor_RtlImageRvaToSection(IN PIMAGE_NT_HEADERS NtHeaders,
                                               IN PVOID Base,
                                               IN ULONG Rva)
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData)
            return NtSection;

        ++NtSection;
    }

    return NULL;
}


static
PVOID Cor_RtlImageRvaToVa(IN PIMAGE_NT_HEADERS NtHeaders,
                          IN PVOID Base,
                          IN ULONG Rva)
{
    PIMAGE_SECTION_HEADER NtSection = Cor_RtlImageRvaToSection(NtHeaders,
                                                               Base,
                                                               Rva);

    if (NtSection != NULL) {
        return (PVOID)((PCHAR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData);
    }
    else
        return NULL;
}

/* static */
IMAGE_COR20_HEADER * getCOMHeader(HMODULE hMod, IMAGE_NT_HEADERS *pNT)
{
    PIMAGE_SECTION_HEADER pSectionHeader;

    // Get the image header from the image, then get the directory location
    // of the CLR header which may or may not be filled out.
    pSectionHeader = (PIMAGE_SECTION_HEADER) Cor_RtlImageRvaToVa(pNT, hMod,
                                                                 pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress);

    return (IMAGE_COR20_HEADER *) pSectionHeader;
}


/* static */
IMAGE_NT_HEADERS * FindNTHeader(PBYTE pbMapAddress)
{
    IMAGE_DOS_HEADER   *pDosHeader;
    IMAGE_NT_HEADERS   *pNT;

    pDosHeader = (IMAGE_DOS_HEADER *) pbMapAddress;

    if ((pDosHeader->e_magic == IMAGE_DOS_SIGNATURE) &&
        (pDosHeader->e_lfanew != 0))
    {
        pNT = (IMAGE_NT_HEADERS*) (pDosHeader->e_lfanew + (DWORD) pDosHeader);

        if ((pNT->Signature != IMAGE_NT_SIGNATURE) ||
            (pNT->FileHeader.SizeOfOptionalHeader !=
             IMAGE_SIZEOF_NT_OPTIONAL_HEADER) ||
            (pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC))
            return NULL;
    }
    else
        return NULL;

    return pNT;
}

// @TODO: This opens a manifest created by LM -a.  Should be removed
// once the -a option is removed from LM.
// NOTE: The file mapping needs to be kept around as long as the returned
// metadata scope is in use.  When finished, call UnmapViewOfFile(*pbMapAddress);
int OpenLM_AAssem(IMetaDataDispenser *imdd,
                  LPCSTR              szFileName,
                  const IID *         riid,
                  mdAssembly        * assTok,
                  BYTE *            * fmapPtr,
                  WAssemblyImport * * intfPtr)
{
    IMetaDataAssemblyImport *iasi;
    IMAGE_COR20_HEADER      *pICH;
    IMAGE_NT_HEADERS        *pNT;
    DWORD                   *dwSize;

    BYTE    *               mapAddr = NULL;

    *fmapPtr = NULL;
    *intfPtr = NULL;

    HANDLE hFile = CreateFileA(szFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    HANDLE hMapFile = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    DWORD dwFileLen = GetFileSize(hFile, 0);
    CloseHandle(hFile);
    if (!hMapFile)
        return HRESULT_FROM_WIN32(GetLastError());

    mapAddr = (PBYTE) MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hMapFile);
    if (!(mapAddr))
        return HRESULT_FROM_WIN32(GetLastError());

    if ((!(pNT = FindNTHeader(mapAddr))) ||
        (!(pICH = getCOMHeader((HMODULE) (mapAddr), pNT)))) {
        UnmapViewOfFile(mapAddr);
        return E_FAIL;
    }

    int hr = E_FAIL;
    if ((!pICH->Resources.Size) ||
        (dwFileLen < pICH->Resources.VirtualAddress + pICH->Resources.Size) ||
        (!(dwSize = (DWORD *) (mapAddr + pICH->Resources.VirtualAddress))) ||
        (FAILED(hr = imdd->OpenScopeOnMemory(pICH->Resources.VirtualAddress + (mapAddr) + sizeof(DWORD),
                                        *dwSize,
                                        0,
                                        *riid,
                                        (IUnknown **)&iasi)))) {
        UnmapViewOfFile(mapAddr);
        return hr;
    }

    if ((hr = iasi->GetAssemblyFromScope(assTok)) >= 0) {
        *intfPtr = makeIASIwrapper(iasi);
        *fmapPtr = mapAddr;
        return S_OK;
    }

    iasi->Release();
    UnmapViewOfFile(mapAddr);
    mapAddr = NULL;
    return hr;
}

void    WMetaDataDispenser::TossAssem(BYTE *cookie)
{
    if (cookie) UnmapViewOfFile(cookie);
}

/*****************************************************************************/
#endif
/*****************************************************************************/

int WMetaDataDispenser::OpenAssem(      LPCWSTR             szScope,
                                        DWORD               dwOpenFlags,
                                        const IID *         riid,
                                        LPCSTR              szFileName,
                                        mdAssembly        * assTok,
                                        BYTE *            * cookiePtr,
                                        WAssemblyImport * * intfPtr)
{
    int                     err;
    IMetaDataAssemblyImport*iasi;

    *cookiePtr = NULL;

    cycleCounterResume();
    err = imdd->OpenScope(szScope, dwOpenFlags, *riid, (IUnknown **)&iasi);
    cycleCounterPause();
    logCall(err, "OpenScope");

    if  (err)
    {
        *intfPtr = NULL;
    }
    else
    {
        if  (iasi->GetAssemblyFromScope(assTok) >= 0)
        {
            *intfPtr = makeIASIwrapper(iasi);
        }
        else
        {
            iasi->Release();

            cycleCounterResume();
            err = OpenLM_AAssem(imdd, szFileName, riid, assTok, cookiePtr, intfPtr);
            cycleCounterPause();
            logCall(err, "OpenLMassemHack");

            if  (err < 0)
                return  err;
        }
    }

    return  err;
}

/*****************************************************************************/

void    WMetaDataImport::CloseEnum(HCORENUM hEnum)
{
    imdi->CloseEnum(hEnum);
}

int     WMetaDataImport::CountEnum(HCORENUM hEnum, ULONG *pulCount)
{
    cycleCounterResume();
    int     err = imdi->CountEnum(hEnum, pulCount);
    cycleCounterPause();
    logCall(err, "CountEnum");
    return  err;
}

int     WMetaDataImport::ResetEnum(HCORENUM hEnum, ULONG ulPos)
{
    cycleCounterResume();
    int     err = imdi->ResetEnum(hEnum, ulPos);
    cycleCounterPause();
    logCall(err, "ResetEnum");
    return  err;
}

int     WMetaDataImport::EnumTypeDefs(HCORENUM *phEnum, mdTypeDef rTypeDefs[], ULONG cMax, ULONG *pcTypeDefs)
{
    cycleCounterResume();
    int     err = imdi->EnumTypeDefs(phEnum, rTypeDefs, cMax, pcTypeDefs);
    cycleCounterPause();
    logCall(err, "EnumTypeDefs");
    return  err;
}

int     WMetaDataImport::EnumInterfaceImpls(HCORENUM *phEnum, mdTypeDef td, mdInterfaceImpl rImpls[], ULONG cMax, ULONG* pcImpls)
{
    cycleCounterResume();
    int     err = imdi->EnumInterfaceImpls(phEnum, td, rImpls, cMax, pcImpls);
    cycleCounterPause();
    logCall(err, "EnumInterfaceImpls");
    return  err;
}

int     WMetaDataImport::EnumTypeRefs(HCORENUM *phEnum, mdTypeRef rTypeRefs[], ULONG cMax, ULONG* pcTypeRefs)
{
    cycleCounterResume();
    int     err = imdi->EnumTypeRefs(phEnum, rTypeRefs, cMax, pcTypeRefs);
    cycleCounterPause();
    logCall(err, "EnumTypeRefs");
    return  err;
}

int     WMetaDataImport::GetTypeDefProps(
            mdTypeDef       td,
            LPWSTR          szTypeDef,
            ULONG           cchTypeDef,
            ULONG          *pchTypeDef,
            DWORD          *pdwTypeDefFlags,
            mdToken        *ptkExtends)
{
    cycleCounterResume();
    int     err = imdi->GetTypeDefProps(td,
                                  szTypeDef,
                                  cchTypeDef,
                                  pchTypeDef,
                                  pdwTypeDefFlags,
                                  ptkExtends);
    cycleCounterPause();
    logCall(err, "GetTypeDefProps");
    return  err;
}

int     WMetaDataImport::GetClassLayout(
                mdTypeDef   td,
                DWORD       *pdwPackSize,
                COR_FIELD_OFFSET rFieldOffset[],
                ULONG       cMax,
                ULONG       *pcFieldOffset,
                ULONG       *pulClassSize)
{
    cycleCounterResume();
    int     err = imdi->GetClassLayout(td,
                                       pdwPackSize,
                                       rFieldOffset,
                                       cMax,
                                       pcFieldOffset,
                                       pulClassSize);
    cycleCounterPause();
    logCall(err, "GetClassLayout");
    return  err;
}

int     WMetaDataImport::GetNestedClassProps(
                mdTypeDef       tdNestedClass,
                mdTypeDef      *ptdEnclosingClass)
{
    cycleCounterResume();
    int     err = imdi->GetNestedClassProps(tdNestedClass, ptdEnclosingClass);
    cycleCounterPause();
    logCall(err, "GetNestedClassProps");
    return  err;
}

int     WMetaDataImport::GetFieldMarshal(
            mdToken         tk,
            PCCOR_SIGNATURE*ppvNativeType,
            ULONG          *pcbNativeType)
{
    cycleCounterResume();
    int     err = imdi->GetFieldMarshal(tk, ppvNativeType, pcbNativeType);
    cycleCounterPause();
    logCall(err, "GetFieldMarshal");
    return  err;
}

int     WMetaDataImport::GetPermissionSetProps(
            mdPermission    pm,
            DWORD          *pdwAction,
            void const    **ppvPermission,
            ULONG          *pcbPermission)
{
    cycleCounterResume();
    int     err = imdi->GetPermissionSetProps(pm, pdwAction, ppvPermission, pcbPermission);
    cycleCounterPause();
    logCall(err, "GetPermissionSetProps");
    return  err;
}

int     WMetaDataImport::EnumMembers(
            HCORENUM       *phEnum,
            mdTypeDef       cl,
            mdToken         rMembers[],
            ULONG           cMax,
            ULONG          *pcTokens)
{
    cycleCounterResume();
    int     err = imdi->EnumMembers(phEnum,
                              cl,
                              rMembers,
                              cMax,
                              pcTokens);
    cycleCounterPause();
    logCall(err, "EnumMembers");
    return  err;
}

int     WMetaDataImport::GetMemberProps(
            mdToken         mb,
            mdTypeDef      *pClass,
            LPWSTR          szMember,
            ULONG           cchMember,
            ULONG          *pchMember,
            DWORD          *pdwAttr,
            PCCOR_SIGNATURE*ppvSigBlob,
            ULONG          *pcbSigBlob,
            ULONG          *pulCodeRVA,
            DWORD          *pdwImplFlags,
            DWORD          *pdwCPlusTypeFlag,
            void const    **ppValue,
            ULONG          *pcbValue)
{
    cycleCounterResume();
    int     err = imdi->GetMemberProps(mb,
                                 pClass,
                                 szMember,
                                 cchMember,
                                 pchMember,
                                 pdwAttr,
                                 ppvSigBlob,
                                 pcbSigBlob,
                                 pulCodeRVA,
                                 pdwImplFlags,
                                 pdwCPlusTypeFlag,
                                 ppValue,
                                 pcbValue);
    cycleCounterPause();
    logCall(err, "GetMemberProps");
    return  err;
}

int     WMetaDataImport::EnumProperties(
            HCORENUM       *phEnum,
            mdTypeDef       td,
            mdProperty      rProperties[],
            ULONG           cMax,
            ULONG          *pcProperties)
{
    cycleCounterResume();
    int     err = imdi->EnumProperties(phEnum, td, rProperties, cMax, pcProperties);
    cycleCounterPause();
    logCall(err, "EnumProperties");
    return  err;
}

int     WMetaDataImport::GetPropertyProps(
            mdProperty      prop,
            mdTypeDef      *pClass,
            LPCWSTR         szProperty,
            ULONG           cchProperty,
            ULONG          *pchProperty,
            DWORD          *pdwPropFlags,
            PCCOR_SIGNATURE*ppvSig,
            ULONG          *pbSig,
            DWORD          *pdwCPlusTypeFlag,
            void const    **ppDefaultValue,
            ULONG          *pcbDefaultValue,
            mdMethodDef    *pmdSetter,
            mdMethodDef    *pmdGetter,
            mdMethodDef     rmdOtherMethod[],
            ULONG           cMax,
            ULONG          *pcOtherMethod)
{
    cycleCounterResume();
    int     err = imdi->GetPropertyProps(
                            prop,
                            pClass,
                            szProperty,
                            cchProperty,
                            pchProperty,
                            pdwPropFlags,
                            ppvSig,
                            pbSig,
                            pdwCPlusTypeFlag,
                            ppDefaultValue,
                            pcbDefaultValue,
                            pmdSetter,
                            pmdGetter,
                            rmdOtherMethod,
                            cMax,
                            pcOtherMethod);
    cycleCounterPause();
    logCall(err, "GetPropertyProps");
    return  err;
}

int     WMetaDataImport::EnumParams(
            HCORENUM       *phEnum,
            mdMethodDef     mb,
            mdParamDef      rParams[],
            ULONG           cMax,
            ULONG          *pcTokens)
{
    cycleCounterResume();
    int     err = imdi->EnumParams(phEnum,
                             mb,
                             rParams,
                             cMax,
                             pcTokens);
    cycleCounterPause();
    logCall(err, "EnumParams");
    return  err;
}

int     WMetaDataImport::GetParamProps(
            mdToken         tk,
            mdMethodDef    *pmd,
            ULONG          *pulSequence,
            LPWSTR          szName,
            ULONG           cchName,
            ULONG          *pchName,
            DWORD          *pdwAttr,
            DWORD          *pdwCPlusTypeFlag,
            void const    **ppValue,
            ULONG          *pcbValue)
{
    cycleCounterResume();
    int     err = imdi->GetParamProps(tk,
                                pmd,
                                pulSequence,
                                szName,
                                cchName,
                                pchName,
                                pdwAttr,
                                pdwCPlusTypeFlag,
                                ppValue,
                                pcbValue);
    cycleCounterPause();
    logCall(err, "GetParamProps");
    return  err;
}

int     WMetaDataImport::GetScopeProps(
            LPWSTR          szName,
            ULONG           cchName,
            ULONG          *pchName,
            GUID           *pmvid)
{
    cycleCounterResume();
    int     err = imdi->GetScopeProps(szName, cchName, pchName, pmvid);
    cycleCounterPause();
    logCall(err, "GetScopeProps");
    return  err;
}

int     WMetaDataImport::GetNameFromToken(mdToken tk, const char **pszUtf8NamePtr)
{
    cycleCounterResume();
    int     err = imdi->GetNameFromToken(tk, pszUtf8NamePtr);
    cycleCounterPause();
    logCall(err, "GetNameFromToken");
    return  err;
}

int     WMetaDataImport::GetInterfaceImplProps(
            mdInterfaceImpl iiImpl,
            mdTypeDef      *pClass,
            mdToken        *ptkIface)
{
    cycleCounterResume();
    int     err = imdi->GetInterfaceImplProps(iiImpl, pClass, ptkIface);
    cycleCounterPause();
    logCall(err, "GetInterfaceImplProps");
    return  err;
}

int     WMetaDataImport::GetTypeRefProps(
            mdTypeRef   tr,
            mdToken     tkResolutionScope,
            LPWSTR      szTypeRef,
            ULONG       cchTypeRef,
            ULONG      *pchTypeRef)
{
    cycleCounterResume();
    int     err = imdi->GetTypeRefProps(tr,
                                &tkResolutionScope,
                                szTypeRef,
                                cchTypeRef,
                                pchTypeRef);
    cycleCounterPause();
    logCall(err, "GetTypeRefProps");
    return  err;
}

int     WMetaDataImport::GetMemberRefProps(
            mdMemberRef     mr,
            mdToken        *ptk,
            LPWSTR          szMember,
            ULONG           cchMember,
            ULONG          *pchMember,
            PCCOR_SIGNATURE*ppvSigBlob,
            ULONG          *pbSig)
{
    cycleCounterResume();
    int     err = imdi->GetMemberRefProps(mr, ptk, szMember, cchMember, pchMember, ppvSigBlob, pbSig);
    cycleCounterPause();
    logCall(err, "GetMemberRefProps");
    return  err;
}

int     WMetaDataImport::GetMethodProps(
            mdMethodDef     mb,
            mdTypeDef      *pClass,
            LPWSTR          szMethod,
            ULONG           cchMethod,
            ULONG          *pchMethod,
            DWORD          *pdwAttr,
            PCCOR_SIGNATURE*ppvSigBlob,
            ULONG          *pcbSigBlob,
            ULONG          *pulCodeRVA,
            DWORD          *pdwImplFlags)
{
    cycleCounterResume();
    int     err = imdi->GetMethodProps(mb, pClass, szMethod, cchMethod, pchMethod, pdwAttr, ppvSigBlob, pcbSigBlob, pulCodeRVA, pdwImplFlags);
    cycleCounterPause();
    logCall(err, "GetMethodProps");
    return  err;
}

int     WMetaDataImport::ResolveTypeRef(mdTypeRef tr, const IID * riid, WMetaDataImport **scope, mdTypeDef *ptd)
{
    int             err;
    IMetaDataImport*imdiNew;

    cycleCounterResume();
    err = imdi->ResolveTypeRef(tr, *riid, (IUnknown **)&imdiNew, ptd);
    cycleCounterPause();
    if  (err)
    {
        *scope = NULL;
    }
    else
    {
        *scope = makeIMDIwrapper(imdiNew);
    }

    logCall(err, "ResolveTypeRef");
    return  err;
}

int     WMetaDataImport::FindTypeRef(
            mdToken         tkResolutionScope,
            LPCWSTR         szTypeName,
            mdTypeRef      *ptr)
{
    cycleCounterResume();
    int     err = imdi->FindTypeRef(tkResolutionScope,
                                szTypeName,
                                ptr);
    cycleCounterPause();
    logCall(err, "FindTypeRef");
    return  err;
}

int     WMetaDataImport::GetCustomAttributeByName(mdToken tkObj, LPCWSTR szName, void const **ppBlob, ULONG *pcbSize)
{
    cycleCounterResume();
    int     err = imdi->GetCustomAttributeByName(tkObj, szName, ppBlob,pcbSize);
    cycleCounterPause();
    logCall(err, "GetCustomAttributeByName");
    return  err;
}

int     WMetaDataImport::EnumCustomAttributes(
                HCORENUM       *phEnum,
                mdToken         tk,
                mdToken         tkType,
                mdCustomAttribute   rCustomValues[],
                ULONG           cMax,
                ULONG          *pcCustomValues)
{
    cycleCounterResume();
    int     err = imdi->EnumCustomAttributes(phEnum, tk, tkType, rCustomValues, cMax, pcCustomValues);
    cycleCounterPause();
    logCall(err, "EnumCustomAttributes");
    return  err;
}

int     WMetaDataImport::GetCustomAttributeProps(
                mdCustomAttribute   cv,
                mdToken        *ptkObj,
                mdToken        *ptkType,
                void const    **ppBlob,
                ULONG          *pcbSize)
{
    cycleCounterResume();
    int     err = imdi->GetCustomAttributeProps(cv, ptkObj, ptkType, ppBlob, pcbSize);
    cycleCounterPause();
    logCall(err, "GetCustomAttributeProps");
    return  err;
}

/*****************************************************************************/

int     WMetaDataEmit::GetSaveSize(CorSaveSize fSave, DWORD *pdwSaveSize)
{
    cycleCounterResume();
    int     err = imde->GetSaveSize(fSave, pdwSaveSize);
    cycleCounterPause();
    logCall(err, "GetSaveSize");
    return  err;
}

int     WMetaDataEmit::DefineTypeDef(
            LPCWSTR         szTypeDef,
            DWORD           dwTypeDefFlags,
            mdToken         tkExtends,
            mdToken         rtkImplements[],
            mdTypeDef      *ptd)
{
    cycleCounterResume();
    int     err = imde->DefineTypeDef(szTypeDef,
                                dwTypeDefFlags,
                                tkExtends,
                                rtkImplements,
                                ptd);
    cycleCounterPause();
    logCall(err, "DefineTypeDef");
    return  err;
}

int     WMetaDataEmit::DefineNestedType(
            LPCWSTR         szTypeDef,
            DWORD           dwTypeDefFlags,
            mdToken         tkExtends,
            mdToken         rtkImplements[],
            mdTypeDef       tkEncloser,
            mdTypeDef      *ptd)
{
    cycleCounterResume();
    int     err = imde->DefineNestedType(szTypeDef,
                                dwTypeDefFlags,
                                tkExtends,
                                rtkImplements,
                                tkEncloser,
                                ptd);
    cycleCounterPause();
    logCall(err, "DefineNestedType");
    return  err;
}

int     WMetaDataEmit::SetTypeDefProps(
            mdTypeDef       td,
            DWORD           dwTypeDefFlags,
            mdToken         tkExtends,
            mdToken         rtkImplements[])
{
    cycleCounterResume();
    int     err = imde->SetTypeDefProps(td,
                                  dwTypeDefFlags,
                                  tkExtends,
                                  rtkImplements);
    cycleCounterPause();
    logCall(err, "SetTypeDefProps");
    return  err;
}

int     WMetaDataEmit::DefineMethod(
            mdTypeDef       td,
            LPCWSTR         szName,
            DWORD           dwMethodFlags,
            PCCOR_SIGNATURE pvSigBlob,
            ULONG           cbSigBlob,
            ULONG           ulCodeRVA,
            DWORD           dwImplFlags,
            mdMethodDef    *pmd)
{
    cycleCounterResume();
    int     err = imde->DefineMethod(td,
                               szName,
                               dwMethodFlags,
                               pvSigBlob,
                               cbSigBlob,
                               ulCodeRVA,
                               dwImplFlags,
                               pmd);
    cycleCounterPause();
    logCall(err, "DefineMethod");
    return  err;
}

int     WMetaDataEmit::DefineField(
            mdTypeDef       td,
            LPCWSTR         szName,
            DWORD           dwFieldFlags,
            PCCOR_SIGNATURE pvSigBlob,
            ULONG           cbSigBlob,
            DWORD           dwCPlusTypeFlag,
            void const     *pValue,
            ULONG           cbValue,
            mdFieldDef     *pmd)
{
    cycleCounterResume();
    int     err = imde->DefineField(td,
                              szName,
                              dwFieldFlags,
                              pvSigBlob,
                              cbSigBlob,
                              dwCPlusTypeFlag,
                              pValue,
                              cbValue,
                              pmd);
    cycleCounterPause();
    logCall(err, "DefineField");
    return  err;
}

int     WMetaDataEmit::DefineProperty(
            mdTypeDef       td,
            LPCWSTR         szProperty,
            DWORD           dwPropFlags,
            PCCOR_SIGNATURE pvSig,
            ULONG           cbSig,
            DWORD           dwCPlusTypeFlag,
            void const     *pValue,
            ULONG           cbValue,
            mdMethodDef     mdSetter,
            mdMethodDef     mdGetter,
            mdMethodDef     rmdOtherMethods[],
            mdProperty     *pmdProp)
{
    cycleCounterResume();
    int     err = imde->DefineProperty(td,
                                       szProperty,
                                       dwPropFlags,
                                       pvSig,
                                       cbSig,
                                       dwCPlusTypeFlag,
                                       pValue,
                                       cbValue,
                                       mdSetter,
                                       mdGetter,
                                       rmdOtherMethods,
                                       pmdProp);
    cycleCounterPause();
    logCall(err, "DefineProperty");
    return  err;
}

int     WMetaDataEmit::DefineParam(
            mdMethodDef     md,
            ULONG           ulParamSeq,
            LPCWSTR         szName,
            DWORD           dwParamFlags,
            DWORD           dwCPlusTypeFlag,
            void const     *pValue,
            ULONG           cbValue,
            mdParamDef     *ppd)
{
    cycleCounterResume();
    int     err = imde->DefineParam(md,
                                    ulParamSeq,
                                    szName,
                                    dwParamFlags,
                                    dwCPlusTypeFlag,
                                    pValue,
                                    cbValue,
                                    ppd);
    cycleCounterPause();
    logCall(err, "DefineParam");
    return  err;
}

int     WMetaDataEmit::DefineMethodImpl(
            mdTypeDef       td,
            mdToken         tkBody,
            mdToken         tkDecl)
{
    cycleCounterResume();
    int     err = imde->DefineMethodImpl(td,
                                   tkBody,
                                   tkDecl);
    cycleCounterPause();
    logCall(err, "DefineMethodImpl");
    return  err;
}

int     WMetaDataEmit::SetRVA(
            mdToken         md,
            ULONG           ulCodeRVA)
{
    cycleCounterResume();
    int     err = imde->SetRVA(md,
                         ulCodeRVA);
    cycleCounterPause();
    logCall(err, "SetRVA");
    return  err;
}

int     WMetaDataEmit::SetMethodImplFlags(
            mdToken         md,
            DWORD           dwImplFlags)
{
    cycleCounterResume();
    int     err = imde->SetMethodImplFlags(md,
                         dwImplFlags);
    cycleCounterPause();
    logCall(err, "SetMethodImplFlags");
    return  err;
}

int     WMetaDataEmit::DefineTypeRefByName(
            mdToken         tkResolutionScope,
            LPCWSTR         szName,
            mdTypeRef      *ptr)
{
    cycleCounterResume();
    int     err = imde->DefineTypeRefByName(tkResolutionScope, szName, ptr);
    cycleCounterPause();
    logCall(err, "DefineTypeRefByName");
    return  err;
}

int     WMetaDataEmit::DefineImportType(
            IMetaDataAssemblyImport *pAssemImport,
            const void      *pbHashValue,
            ULONG           cbHashValue,
            IMetaDataImport *pImport,
            mdTypeDef       tdImport,
            IMetaDataAssemblyEmit *pAssemEmit,
            mdTypeRef      *ptr)
{
    cycleCounterResume();
    int     err = imde->DefineImportType(pAssemImport,
                                   pbHashValue,
                                   cbHashValue,
                                   pImport,
                                   tdImport,
                                   pAssemEmit,
                                   ptr);
    cycleCounterPause();
    logCall(err, "DefineImportType");
    return  err;
}

int     WMetaDataEmit::DefineMemberRef(
            mdToken         tkImport,
            LPCWSTR         szName,
            PCCOR_SIGNATURE pvSigBlob,
            ULONG           cbSigBlob,
            mdMemberRef    *pmr)
{
    cycleCounterResume();
    int     err = imde->DefineMemberRef(tkImport,
                                  szName,
                                  pvSigBlob,
                                  cbSigBlob,
                                  pmr);
    cycleCounterPause();
    logCall(err, "DefineMemberRef");
    return  err;
}

int     WMetaDataEmit::DefineImportMember(
            IMetaDataAssemblyImport *pAssemImport,
            const void      *pbHashValue,
            ULONG           cbHashValue,
            IMetaDataImport *pImport,
            mdToken         mbMember,
            IMetaDataAssemblyEmit *pAssemEmit,
            mdToken         tkParent,
            mdMemberRef    *pmr)
{
    cycleCounterResume();
    int     err = imde->DefineImportMember(pAssemImport,
                                     pbHashValue,
                                     cbHashValue,
                                     pImport,
                                     mbMember,
                                     pAssemEmit,
                                     tkParent,
                                     pmr);
    cycleCounterPause();
    logCall(err, "DefineImportMember");
    return  err;
}

int     WMetaDataEmit::DefineModuleRef(LPCWSTR szName, mdModuleRef *pmur)
{
    cycleCounterResume();
    int     err = imde->DefineModuleRef(szName, pmur);
    cycleCounterPause();
    logCall(err, "DefineModuleRef");
    return  err;
}

int     WMetaDataEmit::DefineUserString(
                LPCWSTR         szString,
                ULONG           cchString,
                mdString       *pstk)
{
    int     err = imde->DefineUserString(szString, cchString, pstk);
    logCall(err, "DefineUserString");
    return  err;
}

int     WMetaDataEmit::DefinePinvokeMap(
                mdToken         tk,
                DWORD           dwMappingFlags,
                LPCWSTR         szImportName,
                mdModuleRef     mrImportDLL)
{
    cycleCounterResume();
    int     err = imde->DefinePinvokeMap(tk,
                                         dwMappingFlags,
                                         szImportName,
                                         mrImportDLL);
    cycleCounterPause();
    logCall(err, "DefinePinvokeMap");
    return  err;
}

int     WMetaDataEmit::SetClassLayout(
            mdTypeDef        td,
            DWORD            dwPackSize,
            COR_FIELD_OFFSET rFieldOffsets[],
            ULONG            ulClassSize)
{
    cycleCounterResume();
    int     err = imde->SetClassLayout(td,
                                 dwPackSize,
                                 rFieldOffsets,
                                 ulClassSize);
    cycleCounterPause();
    logCall(err, "SetClassLayout");
    return  err;
}

int     WMetaDataEmit::SetFieldMarshal(
            mdToken         tk,
            PCCOR_SIGNATURE pvNativeType,
            ULONG           cbNativeType)
{
    cycleCounterResume();
    int     err = imde->SetFieldMarshal(tk, pvNativeType, cbNativeType);
    cycleCounterPause();
    logCall(err, "SetFieldMarshal");
    return  err;
}

int     WMetaDataEmit::SetFieldRVA(mdFieldDef fd, ULONG ulRVA)
{
    cycleCounterResume();
    int     err = imde->SetFieldRVA(fd, ulRVA);
    cycleCounterPause();
    logCall(err, "SetFieldRVA");
    return  err;
}

int     WMetaDataEmit::DefinePermissionSet(
            mdToken         tk,
            DWORD           dwAction,
            void const     *pvPermission,
            ULONG           cbPermission,
            mdPermission   *ppm)
{
    cycleCounterResume();
    int     err = imde->DefinePermissionSet(tk, dwAction, pvPermission, cbPermission, ppm);
    cycleCounterPause();
    logCall(err, "DefinePermissionSet");
    return  err;
}

int     WMetaDataEmit::GetTokenFromSig(
            PCCOR_SIGNATURE pvSig,
            ULONG           cbSig,
            mdSignature    *pmsig)
{
    cycleCounterResume();
    int     err = imde->GetTokenFromSig(pvSig, cbSig, pmsig);
    cycleCounterPause();
    logCall(err, "GetTokenFromSig");
    return  err;
}

int     WMetaDataEmit::SetParent(
            mdMemberRef     mr,
            mdToken         tk)
{
    cycleCounterResume();
    int     err = imde->SetParent(mr, tk);
    cycleCounterPause();
    logCall(err, "SetParent");
    return  err;
}

int     WMetaDataEmit::SaveToMemory(
            void           *pbData,
            ULONG           cbData)
{
    cycleCounterResume();
    int     err = imde->SaveToMemory(pbData, cbData);
    cycleCounterPause();
    logCall(err, "SaveToMemory");
    return  err;
}

int     WMetaDataEmit::DefineCustomAttribute(
                mdToken         tkObj,
                mdToken         tkType,
                void const     *pCustomValue,
                ULONG           cbCustomValue,
                mdCustomAttribute  *pcv)
{
    cycleCounterResume();
    int     err = imde->DefineCustomAttribute(tkObj,
                                              tkType,
                                              pCustomValue,
                                              cbCustomValue,
                                              pcv);
    cycleCounterPause();
    logCall(err, "DefineCustomAttribute");
    return  err;
}

int     WMetaDataEmit::DefineSecurityAttributeSet(
                mdToken         tkObj,
                COR_SECATTR     rSecAttrs[],
                ULONG           cSecAttrs,
                ULONG          *pulErrorAttr)
{
    cycleCounterResume();
    int     err = imde->DefineSecurityAttributeSet(tkObj,
                                                   rSecAttrs,
                                                   cSecAttrs,
                                                   pulErrorAttr);
    cycleCounterPause();
    logCall(err, "DefineSecurityAttributeSet");
    return  err;
}

int     WMetaDataEmit::GetTokenFromTypeSpec(
                PCCOR_SIGNATURE pvSig,
                ULONG           cbSig,
                mdTypeSpec     *ptypespec)
{
    cycleCounterResume();
    int     err = imde->GetTokenFromTypeSpec(pvSig, cbSig, ptypespec);
    cycleCounterPause();
    logCall(err, "GetTokenFromTypeSpec");
    return  err;
}

int     WMetaDataEmit::SetModuleProps(
                LPCWSTR         szName)
{
    cycleCounterResume();
    int     err = imde->SetModuleProps(szName);
    cycleCounterPause();
    logCall(err, "SetModuleProps");
    return  err;
}

/*****************************************************************************/

int     WAssemblyImport::GetAssemblyFromScope(mdAssembly *ptkAssembly)
{
    cycleCounterResume();
    int     err = iasi->GetAssemblyFromScope(ptkAssembly);
    cycleCounterPause();
    logCall(err, "GetAssemblyFromScope");
    return  err;
};

int     WAssemblyImport::GetAssemblyProps(
                mdAssembly      mda,
                const void    **ppbPublicKey,
                ULONG          *pcbPublicKey,
                ULONG          *pulHashAlgId,
                LPWSTR          szName,
                ULONG           cchName,
                ULONG          *pchName,
                ASSEMBLYMETADATA *pMetaData,
                DWORD          *pdwAssemblyFlags)
{
    cycleCounterResume();
    int     err = iasi->GetAssemblyProps(
                mda,
                ppbPublicKey,
                pcbPublicKey,
                pulHashAlgId,
                szName,
                cchName,
                pchName,
                pMetaData,
                pdwAssemblyFlags);
    cycleCounterPause();
    logCall(err, "GetAssemblyProps");
    return  err;
}

int     WAssemblyImport::EnumExportedTypes(
                HCORENUM       *phEnum,
                mdExportedType       rComTypes[],
                ULONG           cMax,
                ULONG          *pcTokens)
{
    cycleCounterResume();
    int     err = iasi->EnumExportedTypes(phEnum, rComTypes, cMax, pcTokens);
    cycleCounterPause();
    logCall(err, "EnumExportedTypes");
    return  err;
}

int     WAssemblyImport::GetExportedTypeProps(
                mdExportedType  mdct,
                LPWSTR          szName,
                ULONG           cchName,
                ULONG          *pchName,
                mdToken        *ptkImplementation,
                mdTypeDef      *ptkTypeDef,
                DWORD          *pdwComTypeFlags)
{
    cycleCounterResume();
    int     err = iasi->GetExportedTypeProps(
                mdct,
                szName,
                cchName,
                pchName,
                ptkImplementation,
                ptkTypeDef,
                pdwComTypeFlags);
    cycleCounterPause();
    logCall(err, "GetExportedTypeProps");
    return  err;
}

int     WAssemblyImport::EnumFiles(
                HCORENUM       *phEnum,
                mdFile          rFiles[],
                ULONG           cMax,
                ULONG          *pcTokens)
{
    cycleCounterResume();
    int     err = iasi->EnumFiles(phEnum, rFiles, cMax, pcTokens);
    cycleCounterPause();
    logCall(err, "EnumFiles");
    return  err;
}

int     WAssemblyImport::GetFileProps(
                mdFile          mdf,
                LPWSTR          szName,
                ULONG           cchName,
                ULONG          *pchName,
                const void    **ppbHashValue,
                ULONG          *pcbHashValue,
                DWORD          *pdwFileFlags)
{
    cycleCounterResume();
    int     err = iasi->GetFileProps(
                mdf,
                szName,
                cchName,
                pchName,
                ppbHashValue,
                pcbHashValue,
                pdwFileFlags);
    cycleCounterPause();
    logCall(err, "GetFileProps");
    return  err;
}

void    WAssemblyImport::CloseEnum(HCORENUM hEnum)
{
    cycleCounterResume();
    iasi->CloseEnum(hEnum);
    cycleCounterPause();
    logCall(0, "CloseEnum");
}

/*****************************************************************************/

int     WAssemblyEmit::DefineAssembly(
                const void  *pbPublicKey,
                ULONG       cbPublicKey,
                ULONG       ulHashAlgId,
                LPCWSTR     szName,
                const ASSEMBLYMETADATA *pMetaData,
                LPCWSTR     szTitle,
                LPCWSTR     szDescription,
                LPCWSTR     szDefaultAlias,
                DWORD       dwAssemblyFlags,
                mdAssembly  *pma)
{
    cycleCounterResume();
    int     err = iase->DefineAssembly(
                pbPublicKey,
                cbPublicKey,
                ulHashAlgId,
                szName,
                pMetaData,
                dwAssemblyFlags,
                pma);
    cycleCounterPause();
    logCall(err, "DefineAssembly");
    return  err;
}

int     WAssemblyEmit::DefineFile(
                LPCWSTR     szName,
                const void  *pbHashValue,
                ULONG       cbHashValue,
                DWORD       dwFileFlags,
                mdFile      *pmdf)
{
    cycleCounterResume();
    int     err = iase->DefineFile(
                szName,
                pbHashValue,
                cbHashValue,
                dwFileFlags,
                pmdf);
    cycleCounterPause();
    logCall(err, "DefineFile");
    return  err;
}

int     WAssemblyEmit::DefineExportedType(
                LPCWSTR     szName,
                mdToken     tkImplementation,
                mdTypeDef   tkTypeDef,
                DWORD       dwComTypeFlags,
                mdExportedType   *pmdct)
{
    cycleCounterResume();
    int     err = iase->DefineExportedType(
                szName,
                tkImplementation,
                tkTypeDef,
                dwComTypeFlags,
                pmdct);
    cycleCounterPause();
    logCall(err, "DefineExportedType");
    return  err;
}

int     WAssemblyEmit::DefineAssemblyRef(
                const void  *pbPublicKeyOrToken,
                ULONG       cbPublicKeyOrToken,
                LPCWSTR     szName,
                const ASSEMBLYMETADATA *pMetaData,
                const void  *pbHashValue,
                ULONG       cbHashValue,
                DWORD       dwAssemblyRefFlags,
                mdAssemblyRef *pmdar)
{
    cycleCounterResume();
    int     err = iase->DefineAssemblyRef(
                pbPublicKeyOrToken,
                cbPublicKeyOrToken,
                szName,
                pMetaData,
                pbHashValue,
                cbHashValue,
                dwAssemblyRefFlags,
                pmdar);
    cycleCounterPause();
    logCall(err, "DefineAssemblyRef");
    return  err;
}

int     WAssemblyEmit::DefineManifestResource(
                LPCWSTR     szName,
                mdToken     tkImplementation,
                DWORD       dwOffset,
                DWORD       dwResourceFlags,
                mdManifestResource  *pmdmr)
{
    cycleCounterResume();
    int     err = iase->DefineManifestResource(szName, tkImplementation, dwOffset, dwResourceFlags, pmdmr);
    cycleCounterPause();
    logCall(err, "DefineManifestResource");
    return  err;
}

#if 0

int     WAssemblyEmit::SetAssemblyRefProps(
                mdAssemblyRef ar,
                const void  *pbPublicKeyOrToken,
                ULONG       cbPublicKeyOrToken,
                LPCWSTR     szName,
                const ASSEMBLYMETADATA *pMetaData,
                const void  *pbHashValue,
                ULONG       cbHashValue,
                DWORD       dwAssemblyRefFlags)
{
    cycleCounterResume();
    int     err = iase->;
    cycleCounterPause();
    logCall(err, "");
    return  err;
}

int     WAssemblyEmit::SetFileProps(
                mdFile      file,
                const void  *pbHashValue,
                ULONG       cbHashValue,
                DWORD       dwFileFlags)
{
    cycleCounterResume();
    int     err = iase->;
    cycleCounterPause();
    logCall(err, "");
    return  err;
}

int     WAssemblyEmit::SetExportedTypeProps(
                mdExportedType   ct,
                LPCWSTR     szDescription,
                mdToken     tkImplementation,
                mdTypeDef   tkTypeDef,
                DWORD       dwComTypeFlags)
{
    cycleCounterResume();
    int     err = iase->;
    cycleCounterPause();
    logCall(err, "");
    return  err;
}

#endif

/*****************************************************************************/

int     WMetaDataEmit::CreateSymbolWriter(LPCWSTR filename,
                                          WSymWriter **dbgWriter)
{
    ISymUnmanagedWriter *writer;

    int                  err;


    err = CoCreateInstance(CLSID_CorSymWriter_SxS,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_ISymUnmanagedWriter,
                           (void **)&writer);

    logCall(err, "CreateSymbolWriter");

    if  (err)
    {
        *dbgWriter = NULL;
    }
    else
    {
        *dbgWriter = makeSYMWwrapper(writer);

        // Tell the symbol writer what metadata emitter it needs to be
        // working with.
        err = writer->Initialize((IUnknown*)imde,
                                 filename, NULL, TRUE);
        logCall(err, "SetEmitter");
    }

    return  err;
}

int     WSymWriter::DefineDocument(
                LPCWSTR         wzFileName,
                void          **pISymUnmanagedDocument)
{
    int     err = ((ISymUnmanagedWriter*)isw)->DefineDocument(
                        (LPWSTR)wzFileName,
                        &CorSym_LanguageType_SMC,
                        &CorSym_LanguageVendor_Microsoft,
                        &CorSym_DocumentType_Text,
                        (ISymUnmanagedDocumentWriter**)pISymUnmanagedDocument);
    logCall(err, "DefineDocument");
    return  err;
}

int     WSymWriter::OpenMethod(
                mdMethodDef     methodToken)
{
    int     err = ((ISymUnmanagedWriter*)isw)->OpenMethod(methodToken);
    logCall(err, "OpenMethod");
    return  err;
}

int     WSymWriter::CloseMethod()
{
    int     err = ((ISymUnmanagedWriter*)isw)->CloseMethod();
    logCall(err, "CloseMethod");
    return  err;
}

int     WSymWriter::SetUserEntryPoint(mdMethodDef methodToken)
{
    int     err = ((ISymUnmanagedWriter*)isw)->SetUserEntryPoint(methodToken);
    logCall(err, "SetUserEntryPoint");
    return  err;
}

int     WSymWriter::OpenScope(unsigned startOffset, unsigned *scopeID)
{
    ULONG32 retScopeID = 0;
    int     err = ((ISymUnmanagedWriter*)isw)->OpenScope((ULONG32)startOffset,
                                                         &retScopeID);
    *scopeID = retScopeID;
    logCall(err, "OpenScope");
    return  err;
}

int     WSymWriter::CloseScope(unsigned endOffset)
{
    int     err = ((ISymUnmanagedWriter*)isw)->CloseScope(endOffset);
    logCall(err, "OpenScope");
    return  err;
}

int     WSymWriter::SetScopeRange(unsigned scopeID,
                                  unsigned startOffset,
                                  unsigned endOffset)
{
    int     err = ((ISymUnmanagedWriter*)isw)->SetScopeRange(scopeID,
                                                             startOffset,
                                                             endOffset);
    logCall(err, "SetScopeRange");
    return  err;
}

int     WSymWriter::DefineLocalVariable(
                LPCWSTR         wzVariableName,
                PCCOR_SIGNATURE sigPtr,
                ULONG32         sigLen,
                unsigned        slot)
{
    int     err = ((ISymUnmanagedWriter*)isw)->DefineLocalVariable(
                                                  (LPWSTR)wzVariableName,
                                                          0,
                                                          sigLen,
                                                   (BYTE*)sigPtr,
                                                          ADDR_IL_OFFSET,
                                                          slot,
                                                          0,
                                                          0,
                                                          0,
                                                          0);
    logCall(err, "DefineLocalVariable");
    return  err;
}

int     WSymWriter::DefineParameter(
                LPCWSTR         wzVariableName,
                unsigned        sequence)
{
    int     err = ((ISymUnmanagedWriter*)isw)->DefineParameter(
                                              (LPWSTR)wzVariableName,
                                                      0,
                                                      sequence,
                                                      ADDR_IL_OFFSET,
                                                      sequence,
                                                      0,
                                                      0);
    logCall(err, "DefineParameter");
    return  err;
}

int     WSymWriter::DefineSequencePoints(
                void           *document,
                ULONG32        spCount,
                unsigned       *offsets,
                unsigned       *lines)
{
    assert(sizeof(ULONG32) == sizeof(unsigned));

    int     err = ((ISymUnmanagedWriter*)isw)->DefineSequencePoints(
                                      (ISymUnmanagedDocumentWriter*)document,
                                      spCount,
                            (ULONG32*)offsets,
                            (ULONG32*)lines,
                                      NULL,
                                      NULL,
                                      NULL);
    logCall(err, "DefineSequencePoints");
    return  err;
}

int     WSymWriter::GetDebugInfo(IMAGE_DEBUG_DIRECTORY *pIDD,
                                 DWORD cData,
                                 DWORD *pcData,
                                 BYTE data[])
{
    int     err = ((ISymUnmanagedWriter*)isw)->GetDebugInfo(pIDD,
                                                            cData,
                                                            pcData,
                                                            data);
    logCall(err, "GetDebugInfo");
    return  err;
}

int     WSymWriter::Close(void)
{
    int     err = ((ISymUnmanagedWriter*)isw)->Close();
    logCall(err, "Close");
    return  err;
}

/*****************************************************************************/

WMetaDataDispenser * __stdcall  initializeIMD()
{
    /* Initialize COM and COR */

    if  (!CORinitialized)
    {
        CoInitialize(0);
        CoInitializeCor(COINITCOR_DEFAULT);

        CORinitialized = true;
    }

    /* Ask for the metadata metainterface */

    IMetaDataDispenser *imdd = NULL;

    if  (CoCreateInstance(CLSID_CorMetaDataDispenser,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IMetaDataDispenser, (void**)&imdd))
    {
        return  NULL;
    }

#if!MD_TOKEN_REMAP

    IMetaDataDispenserEx  * iex;

    if  (!imdd->QueryInterface(IID_IMetaDataDispenserEx, (void **)&iex))
    {
        VARIANT                 optv; optv.vt = VT_UI4;

        /* Check for duplicates of some tokens */

        optv.ulVal = MDDupSignature|MDDupMemberRef|MDDupModuleRef|MDDupTypeRef;
        iex->SetOption(MetaDataCheckDuplicatesFor   , &optv);

        /* Give error if emitting out of order */

#if     0
#ifdef  DEBUG
        optv.ulVal = MDErrorOutOfOrderAll;
        iex->SetOption(MetaDataErrorIfEmitOutOfOrder, &optv);
#endif
#endif

        iex->Release();
    }

#endif

    /* Return a wrapper */

    return  makeIMDDwrapper(imdd);
}

/*****************************************************************************/

ULONG       __stdcall WRAPPED_CorSigCompressData         (ULONG           iLen,  void           *pDataOut)
{
    return  CorSigCompressData(iLen, pDataOut);
}

ULONG       __stdcall WRAPPED_CorSigCompressToken        (mdToken         tk,    void           *pDataOut)
{
    return  CorSigCompressToken(tk, pDataOut);
}

ULONG       __stdcall WRAPPED_CorSigUncompressSignedInt  (PCCOR_SIGNATURE pData, int            *pInt)
{
    return CorSigUncompressSignedInt(pData, pInt);
}

ULONG       __stdcall WRAPPED_CorSigUncompressData       (PCCOR_SIGNATURE pData, ULONG          *pDataOut)
{
    return  CorSigUncompressData(pData, pDataOut);
}

ULONG       __stdcall WRAPPED_CorSigUncompressToken      (PCCOR_SIGNATURE pData, mdToken        *pToken)
{
    return  CorSigUncompressToken(pData, pToken);
}

ULONG       __stdcall WRAPPED_CorSigUncompressElementType(PCCOR_SIGNATURE pData, CorElementType *pElementType)
{
    return  CorSigUncompressElementType(pData, pElementType);
}

/*****************************************************************************/

CLS_EH_FAT* __stdcall WRAPPED_SectEH_EHClause (void       *   pSectEH,
                                               unsigned       idx,
                                               CLS_EH_FAT *   buff)
{
    return  SectEH_EHClause(pSectEH, idx, buff);
}

unsigned    __stdcall WRAPPED_SectEH_Emit     (unsigned       size,
                                     unsigned       ehCount,
                                     CLS_EH_FAT *   clauses,
                                     BOOL           moreSections,
                                     BYTE       *   outBuff)
{
    return  SectEH_Emit(size, ehCount, clauses, moreSections, outBuff);
}

unsigned    __stdcall WRAPPED_SectEH_SizeExact(unsigned       ehCount,
                                     CLS_EH_FAT *   clauses)
{
    return  SectEH_SizeExact(ehCount, clauses);
}

unsigned    __stdcall WRAPPED_IlmethodSize    (COR_IM_FAT *   header,
                                     BOOL           MoreSections)
{
    return  IlmethodSize(header, MoreSections);
}

unsigned    __stdcall WRAPPED_IlmethodEmit    (unsigned       size,
                                     COR_IM_FAT *   header,
                                     BOOL           moreSections,
                                     BYTE *         outBuff)
{
    return  IlmethodEmit(size, header, moreSections, outBuff);
}

/*****************************************************************************/

#include "strongname.h"

__declspec(dllexport)
HRESULT __stdcall WRAPPED_GetHashFromFileW(LPCWSTR   wszFilePath,
                                           unsigned *iHashAlg,
                                           BYTE     *pbHash,
                                           DWORD     cchHash,
                                           DWORD    *pchHash)
{
    return  GetHashFromFileW(wszFilePath, iHashAlg, pbHash, cchHash, pchHash);
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\corwrap\delayload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include "ShimLoad.h"

ExternC PfnDliHook __pfnDliNotifyHook = ShimDelayLoadHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\win32.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************/
#ifdef _MSC_VER
#error  Don't include this header when building with VC!
#endif
/****************************************************************************/
/*                   The basic typedefs from various headers                */
/****************************************************************************/

typedef wchar           wchar_t;

typedef unsigned        size_t;
typedef __int32         time_t;

typedef unsigned        DWORD;
typedef int             BOOL;
typedef void            VOID;
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef float           FLOAT;
typedef FLOAT          *PFLOAT;
typedef BOOL           *PBOOL;
typedef BOOL           *LPBOOL;
typedef BYTE           *PBYTE;
typedef BYTE           *LPBYTE;
typedef int            *PINT;
typedef int            *LPINT;
typedef WORD           *PWORD;
typedef WORD           *LPWORD;
typedef __int32        *LPLONG;
typedef DWORD          *PDWORD;
typedef DWORD          *LPDWORD;
typedef void           *LPVOID;
typedef const void     *LPCVOID;

typedef unsigned __int32 ULONG32;

typedef          __int64  LONGLONG;
typedef unsigned __int64 ULONGLONG;

typedef int             INT;
typedef unsigned int    UINT;
typedef unsigned int   *PUINT;
typedef unsigned int    UINT_PTR;

typedef SHORT          *PSHORT;
typedef LONG           *PLONG;

typedef int             HINSTANCE;
typedef int             HRESULT;
typedef int             HANDLE;

typedef BYTE            BOOLEAN;
typedef BOOLEAN        *PBOOLEAN;

typedef unsigned char   UCHAR;
typedef short           SHORT;
typedef unsigned short  USHORT;
typedef DWORD           ULONG;
typedef double          DOUBLE;

typedef void           *PVOID;
typedef void           *PVOID64;
typedef char            CHAR;
typedef __int32         LONG;
typedef wchar_t         WCHAR;
typedef WCHAR          *PWCHAR;
typedef WCHAR          *LPWCH;
typedef WCHAR          *PWCH;
typedef const WCHAR    *LPCWCH;
typedef const WCHAR    *PCWCH;
typedef WCHAR          *NWPSTR;
typedef WCHAR          *LPWSTR;
typedef WCHAR          *PWSTR;
typedef const WCHAR    *LPCWSTR;
typedef const WCHAR    *PCWSTR;
typedef CHAR           *PCHAR;
typedef CHAR           *LPCH;
typedef CHAR           *PCH;
typedef const CHAR     *LPCCH;
typedef const CHAR     *PCCH;
typedef CHAR           *NPSTR;
typedef CHAR           *LPSTR;
typedef CHAR           *PSTR;
typedef const CHAR     *LPCSTR;
typedef const CHAR     *PCSTR;

typedef void *          LPSTGMEDIUM;

typedef int             LCID;

const   int             S_OK = 0;
const   int             E_NOTIMPL = 0x80004001;
const   int             E_NOINTERFACE = 0x80004002;

struct GUID
{
    DWORD  Data1;
    WORD   Data2;
    WORD   Data3;
    BYTE   Data4[8];
};

typedef GUID            IID;
typedef GUID            CLSID;
typedef  IID    *       REFIID;
typedef const CLSID *   REFCLSID;
struct                  STATSTG        {};

static  REFIID          IID_IUnknown;

struct                   LARGE_INTEGER {};
struct                  ULARGE_INTEGER {};

struct                  VARIANT        {};

typedef DWORD           ACCESS_MASK;
typedef ACCESS_MASK   *PACCESS_MASK;

typedef ACCESS_MASK     REGSAM;

/****************************************************************************/
/*                        PE file format definitions                        */
/****************************************************************************/

//
//  The following are masks for the predefined standard access types
//

const uint DELETE                           = (0x00010000);
const uint READ_CONTROL                     = (0x00020000);
const uint WRITE_DAC                        = (0x00040000);
const uint WRITE_OWNER                      = (0x00080000);
const uint SYNCHRONIZE                      = (0x00100000);

const uint STANDARD_RIGHTS_REQUIRED         = (0x000F0000);

const uint STANDARD_RIGHTS_READ             = (READ_CONTROL);
const uint STANDARD_RIGHTS_WRITE            = (READ_CONTROL);
const uint STANDARD_RIGHTS_EXECUTE          = (READ_CONTROL);

const uint STANDARD_RIGHTS_ALL              = (0x001F0000);

const uint SPECIFIC_RIGHTS_ALL              = (0x0000FFFF);

//
// AccessSystemAcl access type
//

const uint ACCESS_SYSTEM_SECURITY           = (0x01000000);

//
// MaximumAllowed access type
//

const uint MAXIMUM_ALLOWED                  = (0x02000000);

//
//  These are the generic rights.
//

const uint GENERIC_READ                     = (0x80000000);
const uint GENERIC_WRITE                    = (0x40000000);
const uint GENERIC_EXECUTE                  = (0x20000000);
const uint GENERIC_ALL                      = (0x10000000);

const uint IMAGE_DOS_SIGNATURE                  = 0x4D5A;      // MZ
const uint IMAGE_OS2_SIGNATURE                  = 0x4E45;      // NE
const uint IMAGE_OS2_SIGNATURE_LE               = 0x4C45;      // LE
const uint IMAGE_NT_SIGNATURE                   = 0x50450000; // PE00

const uint IMAGE_SIZEOF_FILE_HEADER             = 20;

const uint IMAGE_SIZEOF_ROM_OPTIONAL_HEADER     =  56;
const uint IMAGE_SIZEOF_STD_OPTIONAL_HEADER     =  28;
const uint IMAGE_SIZEOF_NT_OPTIONAL32_HEADER    = 224;
const uint IMAGE_SIZEOF_NT_OPTIONAL64_HEADER    = 240;

const uint IMAGE_NT_OPTIONAL_HDR32_MAGIC        = 0x10b;
const uint IMAGE_NT_OPTIONAL_HDR64_MAGIC        = 0x20b;
const uint IMAGE_ROM_OPTIONAL_HDR_MAGIC         = 0x107;

const uint IMAGE_SIZEOF_NT_OPTIONAL_HEADER      = IMAGE_SIZEOF_NT_OPTIONAL32_HEADER;
const uint IMAGE_NT_OPTIONAL_HDR_MAGIC          = IMAGE_NT_OPTIONAL_HDR32_MAGIC;

const uint IMAGE_NUMBEROF_DIRECTORY_ENTRIES     = 16;

// Subsystem Values

const uint IMAGE_SUBSYSTEM_UNKNOWN              = 0;   // Unknown subsystem.
const uint IMAGE_SUBSYSTEM_NATIVE               = 1;   // Image doesn't require a subsystem.
const uint IMAGE_SUBSYSTEM_WINDOWS_GUI          = 2;   // Image runs in the Windows GUI subsystem.
const uint IMAGE_SUBSYSTEM_WINDOWS_CUI          = 3;   // Image runs in the Windows character subsystem.
const uint IMAGE_SUBSYSTEM_OS2_CUI              = 5;   // image runs in the OS/2 character subsystem.
const uint IMAGE_SUBSYSTEM_POSIX_CUI            = 7;   // image runs in the Posix character subsystem.
const uint IMAGE_SUBSYSTEM_NATIVE_WINDOWS       = 8;   // image is a native Win9x driver.
const uint IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       = 9;   // Image runs in the Windows CE subsystem.

// DllCharacteristics Entries

//      IMAGE_LIBRARY_PROCESS_INIT              = 0x0001;     // Reserved.
//      IMAGE_LIBRARY_PROCESS_TERM              = 0x0002;     // Reserved.
//      IMAGE_LIBRARY_THREAD_INIT               = 0x0004;     // Reserved.
//      IMAGE_LIBRARY_THREAD_TERM               = 0x0008;     // Reserved.
const uint IMAGE_DLLCHARACTERISTICS_WDM_DRIVER  = 0x2000;     // Driver uses WDM model

// Directory Entries

const uint IMAGE_DIRECTORY_ENTRY_EXPORT         =  0;   // Export Directory
const uint IMAGE_DIRECTORY_ENTRY_IMPORT         =  1;   // Import Directory
const uint IMAGE_DIRECTORY_ENTRY_RESOURCE       =  2;   // Resource Directory
const uint IMAGE_DIRECTORY_ENTRY_EXCEPTION      =  3;   // Exception Directory
const uint IMAGE_DIRECTORY_ENTRY_SECURITY       =  4;   // Security Directory
const uint IMAGE_DIRECTORY_ENTRY_BASERELOC      =  5;   // Base Relocation Table
const uint IMAGE_DIRECTORY_ENTRY_DEBUG          =  6;   // Debug Directory
const uint IMAGE_DIRECTORY_ENTRY_ARCHITECTURE   =  7;   // Architecture Specific Data
const uint IMAGE_DIRECTORY_ENTRY_GLOBALPTR      =  8;   // RVA of GP
const uint IMAGE_DIRECTORY_ENTRY_TLS            =  9;   // TLS Directory
const uint IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    = 10;   // Load Configuration Directory
const uint IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   = 11;   // Bound Import Directory in headers
const uint IMAGE_DIRECTORY_ENTRY_IAT            = 12;   // Import Address Table
const uint IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   = 13;   // Delay Load Import Descriptors
const uint IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14;   // COM Runtime descriptor

const uint IMAGE_SIZEOF_SHORT_NAME              = 8;

const uint IMAGE_SIZEOF_SECTION_HEADER          = 40;

const uint IMAGE_FILE_RELOCS_STRIPPED           = 0x0001;  // Relocation info stripped from file.
const uint IMAGE_FILE_EXECUTABLE_IMAGE          = 0x0002;  // File is executable  (i.e. no unresolved externel references).
const uint IMAGE_FILE_LINE_NUMS_STRIPPED        = 0x0004;  // Line nunbers stripped from file.
const uint IMAGE_FILE_LOCAL_SYMS_STRIPPED       = 0x0008;  // Local symbols stripped from file.
const uint IMAGE_FILE_AGGRESIVE_WS_TRIM         = 0x0010;  // Agressively trim working set
const uint IMAGE_FILE_LARGE_ADDRESS_AWARE       = 0x0020;  // App can handle >2gb addresses
const uint IMAGE_FILE_BYTES_REVERSED_LO         = 0x0080;  // Bytes of machine word are reversed.
const uint IMAGE_FILE_32BIT_MACHINE             = 0x0100;  // 32 bit word machine.
const uint IMAGE_FILE_DEBUG_STRIPPED            = 0x0200;  // Debugging info stripped from file in .DBG file
const uint IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   = 0x0400;  // If Image is on removable media, copy and run from the swap file.
const uint IMAGE_FILE_NET_RUN_FROM_SWAP         = 0x0800;  // If Image is on Net, copy and run from the swap file.
const uint IMAGE_FILE_SYSTEM                    = 0x1000;  // System File.
const uint IMAGE_FILE_DLL                       = 0x2000;  // File is a DLL.
const uint IMAGE_FILE_UP_SYSTEM_ONLY            = 0x4000;  // File should only be run on a UP machine
const uint IMAGE_FILE_BYTES_REVERSED_HI         = 0x8000;  // Bytes of machine word are reversed.

const uint IMAGE_FILE_MACHINE_UNKNOWN           = 0;
const uint IMAGE_FILE_MACHINE_I386              = 0x014c;  // Intel 386.
const uint IMAGE_FILE_MACHINE_R3000             = 0x0162;  // MIPS little-endian, 0x160 big-endian
const uint IMAGE_FILE_MACHINE_R4000             = 0x0166;  // MIPS little-endian
const uint IMAGE_FILE_MACHINE_R10000            = 0x0168;  // MIPS little-endian
const uint IMAGE_FILE_MACHINE_WCEMIPSV2         = 0x0169;  // MIPS little-endian WCE v2
const uint IMAGE_FILE_MACHINE_ALPHA             = 0x0184;  // Alpha_AXP
const uint IMAGE_FILE_MACHINE_POWERPC           = 0x01F0;  // IBM PowerPC Little-Endian
const uint IMAGE_FILE_MACHINE_SH3               = 0x01a2;  // SH3 little-endian
const uint IMAGE_FILE_MACHINE_SH3E              = 0x01a4;  // SH3E little-endian
const uint IMAGE_FILE_MACHINE_SH4               = 0x01a6;  // SH4 little-endian
const uint IMAGE_FILE_MACHINE_ARM               = 0x01c0;  // ARM Little-Endian
const uint IMAGE_FILE_MACHINE_THUMB             = 0x01c2;
const uint IMAGE_FILE_MACHINE_IA64              = 0x0200;  // Intel 64
const uint IMAGE_FILE_MACHINE_MIPS16            = 0x0266;  // MIPS
const uint IMAGE_FILE_MACHINE_MIPSFPU           = 0x0366;  // MIPS
const uint IMAGE_FILE_MACHINE_MIPSFPU16         = 0x0466;  // MIPS
const uint IMAGE_FILE_MACHINE_ALPHA64           = 0x0284;  // ALPHA64
const uint IMAGE_FILE_MACHINE_AXP64             = IMAGE_FILE_MACHINE_ALPHA64;

//
// Section characteristics.
//
//      IMAGE_SCN_TYPE_REG                      = 0x00000000;  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                    = 0x00000001;  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                   = 0x00000002;  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                    = 0x00000004;  // Reserved.
const uint IMAGE_SCN_TYPE_NO_PAD                = 0x00000008;  // Reserved.
//      IMAGE_SCN_TYPE_COPY                     = 0x00000010;  // Reserved.

const uint IMAGE_SCN_CNT_CODE                   = 0x00000020;  // Section contains code.
const uint IMAGE_SCN_CNT_INITIALIZED_DATA       = 0x00000040;  // Section contains initialized data.
const uint IMAGE_SCN_CNT_UNINITIALIZED_DATA     = 0x00000080;  // Section contains uninitialized data.

const uint IMAGE_SCN_LNK_OTHER                  = 0x00000100;  // Reserved.
const uint IMAGE_SCN_LNK_INFO                   = 0x00000200;  // Section contains comments or some other type of information.
//      IMAGE_SCN_TYPE_OVER                     = 0x00000400;  // Reserved.
const uint IMAGE_SCN_LNK_REMOVE                 = 0x00000800;  // Section contents will not become part of image.
const uint IMAGE_SCN_LNK_COMDAT                 = 0x00001000;  // Section contents comdat.
//                                              = 0x00002000;  // Reserved.
//      IMAGE_SCN_MEM_PROTECTED - Obsolete      = 0x00004000;
const uint IMAGE_SCN_NO_DEFER_SPEC_EXC          = 0x00004000;  // Reset speculative exceptions handling bits in the TLB entries for this section.
const uint IMAGE_SCN_GPREL                      = 0x00008000;  // Section content can be accessed relative to GP
const uint IMAGE_SCN_MEM_FARDATA                = 0x00008000;
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete       = 0x00010000;
const uint IMAGE_SCN_MEM_PURGEABLE              = 0x00020000;
const uint IMAGE_SCN_MEM_16BIT                  = 0x00020000;
const uint IMAGE_SCN_MEM_LOCKED                 = 0x00040000;
const uint IMAGE_SCN_MEM_PRELOAD                = 0x00080000;

const uint IMAGE_SCN_ALIGN_1BYTES               = 0x00100000;  //
const uint IMAGE_SCN_ALIGN_2BYTES               = 0x00200000;  //
const uint IMAGE_SCN_ALIGN_4BYTES               = 0x00300000;  //
const uint IMAGE_SCN_ALIGN_8BYTES               = 0x00400000;  //
const uint IMAGE_SCN_ALIGN_16BYTES              = 0x00500000;  // Default alignment if no others are specified.
const uint IMAGE_SCN_ALIGN_32BYTES              = 0x00600000;  //
const uint IMAGE_SCN_ALIGN_64BYTES              = 0x00700000;  //
const uint IMAGE_SCN_ALIGN_128BYTES             = 0x00800000;  //
const uint IMAGE_SCN_ALIGN_256BYTES             = 0x00900000;  //
const uint IMAGE_SCN_ALIGN_512BYTES             = 0x00A00000;  //
const uint IMAGE_SCN_ALIGN_1024BYTES            = 0x00B00000;  //
const uint IMAGE_SCN_ALIGN_2048BYTES            = 0x00C00000;  //
const uint IMAGE_SCN_ALIGN_4096BYTES            = 0x00D00000;  //
const uint IMAGE_SCN_ALIGN_8192BYTES            = 0x00E00000;  //
// Unused                                       = 0x00F00000;

const uint IMAGE_SCN_LNK_NRELOC_OVFL            = 0x01000000;  // Section contains extended relocations.
const uint IMAGE_SCN_MEM_DISCARDABLE            = 0x02000000;  // Section can be discarded.
const uint IMAGE_SCN_MEM_NOT_CACHED             = 0x04000000;  // Section is not cachable.
const uint IMAGE_SCN_MEM_NOT_PAGED              = 0x08000000;  // Section is not pageable.
const uint IMAGE_SCN_MEM_SHARED                 = 0x10000000;  // Section is shareable.
const uint IMAGE_SCN_MEM_EXECUTE                = 0x20000000;  // Section is executable.
const uint IMAGE_SCN_MEM_READ                   = 0x40000000;  // Section is readable.
const uint IMAGE_SCN_MEM_WRITE                  = 0x80000000;  // Section is writeable.

const uint SECTION_QUERY       = 0x0001;
const uint SECTION_MAP_WRITE   = 0x0002;
const uint SECTION_MAP_READ    = 0x0004;
const uint SECTION_MAP_EXECUTE = 0x0008;
const uint SECTION_EXTEND_SIZE = 0x0010;

const uint SECTION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|
                                 SECTION_MAP_WRITE |
                                 SECTION_MAP_READ |
                                 SECTION_MAP_EXECUTE |
                                 SECTION_EXTEND_SIZE);

const uint FILE_MAP_COPY       = SECTION_QUERY;
const uint FILE_MAP_WRITE      = SECTION_MAP_WRITE;
const uint FILE_MAP_READ       = SECTION_MAP_READ;
const uint FILE_MAP_ALL_ACCESS = SECTION_ALL_ACCESS;

const uint FILE_SHARE_READ                     = 0x00000001;
const uint FILE_SHARE_WRITE                    = 0x00000002;
const uint FILE_SHARE_DELETE                   = 0x00000004;
const uint FILE_ATTRIBUTE_READONLY             = 0x00000001;
const uint FILE_ATTRIBUTE_HIDDEN               = 0x00000002;
const uint FILE_ATTRIBUTE_SYSTEM               = 0x00000004;
const uint FILE_ATTRIBUTE_DIRECTORY            = 0x00000010;
const uint FILE_ATTRIBUTE_ARCHIVE              = 0x00000020;
const uint FILE_ATTRIBUTE_ENCRYPTED            = 0x00000040;
const uint FILE_ATTRIBUTE_NORMAL               = 0x00000080;
const uint FILE_ATTRIBUTE_TEMPORARY            = 0x00000100;
const uint FILE_ATTRIBUTE_SPARSE_FILE          = 0x00000200;
const uint FILE_ATTRIBUTE_REPARSE_POINT        = 0x00000400;
const uint FILE_ATTRIBUTE_COMPRESSED           = 0x00000800;
const uint FILE_ATTRIBUTE_OFFLINE              = 0x00001000;
const uint FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  = 0x00002000;

//
// TLS Chaacteristic Flags
//
const uint IMAGE_SCN_SCALE_INDEX                = 0x00000001;  // Tls index is scaled

struct IMAGE_DOS_HEADER {
    WORD   e_magic;
    WORD   e_cblp;
    WORD   e_cp;
    WORD   e_crlc;
    WORD   e_cparhdr;
    WORD   e_minalloc;
    WORD   e_maxalloc;
    WORD   e_ss;
    WORD   e_sp;
    WORD   e_csum;
    WORD   e_ip;
    WORD   e_cs;
    WORD   e_lfarlc;
    WORD   e_ovno;
    WORD   e_res[4];
    WORD   e_oemid;
    WORD   e_oeminfo;
    WORD   e_res2[10];
    LONG   e_lfanew;
  };

struct IMAGE_OS2_HEADER {
    WORD   ne_magic;
    CHAR   ne_ver;
    CHAR   ne_rev;
    WORD   ne_enttab;
    WORD   ne_cbenttab;
    LONG   ne_crc;
    WORD   ne_flags;
    WORD   ne_autodata;
    WORD   ne_heap;
    WORD   ne_stack;
    LONG   ne_csip;
    LONG   ne_sssp;
    WORD   ne_cseg;
    WORD   ne_cmod;
    WORD   ne_cbnrestab;
    WORD   ne_segtab;
    WORD   ne_rsrctab;
    WORD   ne_restab;
    WORD   ne_modtab;
    WORD   ne_imptab;
    LONG   ne_nrestab;
    WORD   ne_cmovent;
    WORD   ne_align;
    WORD   ne_cres;
    BYTE   ne_exetyp;
    BYTE   ne_flagsothers;
    WORD   ne_pretthunks;
    WORD   ne_psegrefbytes;
    WORD   ne_swaparea;
    WORD   ne_expver;
  };

struct IMAGE_VXD_HEADER {
    WORD   e32_magic;
    BYTE   e32_border;
    BYTE   e32_worder;
    DWORD  e32_level;
    WORD   e32_cpu;
    WORD   e32_os;
    DWORD  e32_ver;
    DWORD  e32_mflags;
    DWORD  e32_mpages;
    DWORD  e32_startobj;
    DWORD  e32_eip;
    DWORD  e32_stackobj;
    DWORD  e32_esp;
    DWORD  e32_pagesize;
    DWORD  e32_lastpagesize;
    DWORD  e32_fixupsize;
    DWORD  e32_fixupsum;
    DWORD  e32_ldrsize;
    DWORD  e32_ldrsum;
    DWORD  e32_objtab;
    DWORD  e32_objcnt;
    DWORD  e32_objmap;
    DWORD  e32_itermap;
    DWORD  e32_rsrctab;
    DWORD  e32_rsrccnt;
    DWORD  e32_restab;
    DWORD  e32_enttab;
    DWORD  e32_dirtab;
    DWORD  e32_dircnt;
    DWORD  e32_fpagetab;
    DWORD  e32_frectab;
    DWORD  e32_impmod;
    DWORD  e32_impmodcnt;
    DWORD  e32_impproc;
    DWORD  e32_pagesum;
    DWORD  e32_datapage;
    DWORD  e32_preload;
    DWORD  e32_nrestab;
    DWORD  e32_cbnrestab;
    DWORD  e32_nressum;
    DWORD  e32_autodata;
    DWORD  e32_debuginfo;
    DWORD  e32_debuglen;
    DWORD  e32_instpreload;
    DWORD  e32_instdemand;
    DWORD  e32_heapsize;
    BYTE   e32_res3[12];
    DWORD  e32_winresoff;
    DWORD  e32_winreslen;
    WORD   e32_devid;
    WORD   e32_ddkver;
  };

#pragma pack(pop)

struct IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
};


struct IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
};

struct IMAGE_OPTIONAL_HEADER {

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;





    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef IMAGE_OPTIONAL_HEADER IMAGE_OPTIONAL_HEADER32;


struct IMAGE_ROM_OPTIONAL_HEADER {
    WORD   Magic;
    BYTE   MajorLinkerVersion;
    BYTE   MinorLinkerVersion;
    DWORD  SizeOfCode;
    DWORD  SizeOfInitializedData;
    DWORD  SizeOfUninitializedData;
    DWORD  AddressOfEntryPoint;
    DWORD  BaseOfCode;
    DWORD  BaseOfData;
    DWORD  BaseOfBss;
    DWORD  GprMask;
    DWORD  CprMask[4];
    DWORD  GpValue;
};

struct IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
};



struct IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
};

struct IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

struct IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
};



struct IMAGE_SECTION_HEADER {
    BYTE    Name[8];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
};


struct IMAGE_SYMBOL {
    union {
        BYTE    ShortName[8];
        struct {
            DWORD   Short;
            DWORD   Long;
        } Name;
        PBYTE   LongName[2];
    } N;
    DWORD   Value;
    SHORT   SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
};
typedef IMAGE_SYMBOL  *PIMAGE_SYMBOL;



union IMAGE_AUX_SYMBOL {
    struct {
        DWORD    TagIndex;
        union {
            struct {
                WORD    Linenumber;
                WORD    Size;
            } LnSz;
           DWORD    TotalSize;
        } Misc;
        union {
            struct {
                DWORD    PointerToLinenumber;
                DWORD    PointerToNextFunction;
            } Function;
            struct {
                WORD     Dimension[4];
            } Array;
        } FcnAry;
        WORD    TvIndex;
    } Sym;
    struct {
        BYTE    Name[18];
    } File;
    struct {
        DWORD   Length;
        WORD    NumberOfRelocations;
        WORD    NumberOfLinenumbers;
        DWORD   CheckSum;
        SHORT   Number;
        BYTE    Selection;
    } Section;
};
typedef IMAGE_AUX_SYMBOL  *PIMAGE_AUX_SYMBOL;

//
// I386 relocation types.
//
const   uint    IMAGE_REL_I386_ABSOLUTE             = 0x0000;
const   uint    IMAGE_REL_I386_DIR16                = 0x0001;
const   uint    IMAGE_REL_I386_REL16                = 0x0002;
const   uint    IMAGE_REL_I386_DIR32                = 0x0006;
const   uint    IMAGE_REL_I386_DIR32NB              = 0x0007;
const   uint    IMAGE_REL_I386_SEG12                = 0x0009;
const   uint    IMAGE_REL_I386_SECTION              = 0x000A;
const   uint    IMAGE_REL_I386_SECREL               = 0x000B;
const   uint    IMAGE_REL_I386_REL32                = 0x0014;

//
// Storage classes.
//
const   uint    IMAGE_SYM_CLASS_END_OF_FUNCTION     = (BYTE )-1;
const   uint    IMAGE_SYM_CLASS_NULL                = 0x0000;
const   uint    IMAGE_SYM_CLASS_AUTOMATIC           = 0x0001;
const   uint    IMAGE_SYM_CLASS_EXTERNAL            = 0x0002;
const   uint    IMAGE_SYM_CLASS_STATIC              = 0x0003;
const   uint    IMAGE_SYM_CLASS_REGISTER            = 0x0004;
const   uint    IMAGE_SYM_CLASS_EXTERNAL_DEF        = 0x0005;
const   uint    IMAGE_SYM_CLASS_LABEL               = 0x0006;
const   uint    IMAGE_SYM_CLASS_UNDEFINED_LABEL     = 0x0007;
const   uint    IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    = 0x0008;
const   uint    IMAGE_SYM_CLASS_ARGUMENT            = 0x0009;
const   uint    IMAGE_SYM_CLASS_STRUCT_TAG          = 0x000A;
const   uint    IMAGE_SYM_CLASS_MEMBER_OF_UNION     = 0x000B;
const   uint    IMAGE_SYM_CLASS_UNION_TAG           = 0x000C;
const   uint    IMAGE_SYM_CLASS_TYPE_DEFINITION     = 0x000D;
const   uint    IMAGE_SYM_CLASS_UNDEFINED_STATIC    = 0x000E;
const   uint    IMAGE_SYM_CLASS_ENUM_TAG            = 0x000F;
const   uint    IMAGE_SYM_CLASS_MEMBER_OF_ENUM      = 0x0010;
const   uint    IMAGE_SYM_CLASS_REGISTER_PARAM      = 0x0011;
const   uint    IMAGE_SYM_CLASS_BIT_FIELD           = 0x0012;

struct IMAGE_RELOCATION {
    union {
        DWORD   VirtualAddress;
        DWORD   RelocCount;
    };
    DWORD   SymbolTableIndex;
    WORD    Type;
};
typedef IMAGE_RELOCATION  *PIMAGE_RELOCATION;

//
// Based relocation types.
//

const   uint    IMAGE_REL_BASED_ABSOLUTE            =  0;
const   uint    IMAGE_REL_BASED_HIGH                =  1;
const   uint    IMAGE_REL_BASED_LOW                 =  2;
const   uint    IMAGE_REL_BASED_HIGHLOW             =  3;
const   uint    IMAGE_REL_BASED_HIGHADJ             =  4;
const   uint    IMAGE_REL_BASED_MIPS_JMPADDR        =  5;
const   uint    IMAGE_REL_BASED_SECTION             =  6;
const   uint    IMAGE_REL_BASED_REL32               =  7;

const   uint    IMAGE_REL_BASED_MIPS_JMPADDR16      =  9;
const   uint    IMAGE_REL_BASED_IA64_IMM64          =  9;
const   uint    IMAGE_REL_BASED_DIR64               = 10;
const   uint    IMAGE_REL_BASED_HIGH3ADJ            = 11;


struct IMAGE_LINENUMBER {
    union {
        DWORD   SymbolTableIndex;
        DWORD   VirtualAddress;
    } Type;
    WORD    Linenumber;
};
typedef IMAGE_LINENUMBER  *PIMAGE_LINENUMBER;


#pragma pack(pop)


struct IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;

};
typedef IMAGE_BASE_RELOCATION  * PIMAGE_BASE_RELOCATION;



struct IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE     Name[16];
    BYTE     Date[12];
    BYTE     UserID[6];
    BYTE     GroupID[6];
    BYTE     Mode[8];
    BYTE     Size[10];
    BYTE     EndHeader[2];
};


struct IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;
    DWORD   AddressOfNames;
    DWORD   AddressOfNameOrdinals;
};



struct IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    BYTE    Name[1];
};

typedef IMAGE_IMPORT_BY_NAME * PIMAGE_IMPORT_BY_NAME;


#pragma pack(push)
#line 28 "N:\\VStudio\\VC98\\Include\\pshpack8.h"
#pragma pack(8)

struct IMAGE_THUNK_DATA64 {
    union {
        PBYTE  ForwarderString;
        PDWORD Function;
        ULONGLONG Ordinal;
        PIMAGE_IMPORT_BY_NAME  AddressOfData;
    } u1;
};
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

#pragma pack(pop)


struct IMAGE_THUNK_DATA32 {
    union {
        PBYTE  ForwarderString;
        PDWORD Function;
        DWORD Ordinal;
        PIMAGE_IMPORT_BY_NAME  AddressOfData;
    } u1;
};
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;



typedef void
(__stdcall *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

struct IMAGE_TLS_DIRECTORY64 {
    ULONGLONG   StartAddressOfRawData;
    ULONGLONG   EndAddressOfRawData;
    PDWORD  AddressOfIndex;
    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
    DWORD   SizeOfZeroFill;
    DWORD   Characteristics;
};
typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

struct IMAGE_TLS_DIRECTORY32 {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    PDWORD  AddressOfIndex;
    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
    DWORD   SizeOfZeroFill;
    DWORD   Characteristics;
};
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;



typedef IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;

typedef IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;
#line 6031 "N:\\VStudio\\VC98\\Include\\winnt.h"

struct IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;
        DWORD   OriginalFirstThunk;
    };
    DWORD   TimeDateStamp;




    DWORD   ForwarderChain;
    DWORD   Name;
    DWORD   FirstThunk;
};
typedef IMAGE_IMPORT_DESCRIPTOR  *PIMAGE_IMPORT_DESCRIPTOR;





struct IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;

};

struct IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
};






struct IMAGE_STUB_DIRECTORY {
    DWORD   SecondaryImportAddressTable;
    WORD    ExpectedISA[2];
    DWORD   StubAddressTable[2];
};


struct IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;

};




struct IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        }x;
        DWORD   Name;
        WORD    Id;
    };
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        }y;
    };
};


struct IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
};


struct IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
};




struct IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
};





struct IMAGE_LOAD_CONFIG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   GlobalFlagsClear;
    DWORD   GlobalFlagsSet;
    DWORD   CriticalSectionDefaultTimeout;
    DWORD   DeCommitFreeBlockThreshold;
    DWORD   DeCommitTotalFreeThreshold;
    PVOID   LockPrefixTable;
    DWORD   MaximumAllocationSize;
    DWORD   VirtualMemoryThreshold;
    DWORD   ProcessHeapFlags;
    DWORD   ProcessAffinityMask;
    WORD    CSDVersion;
    WORD    Reserved1;
    PVOID   EditList;
    DWORD   Reserved[ 1 ];
};



struct IMAGE_IA64_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD UnwindInfoAddress;
};








struct IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
};

typedef IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY * PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

struct IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
};

typedef  IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY*PIMAGE_AXP64_RUNTIME_FUNCTION_ENTRY;





struct IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
};






#line 6263 "N:\\VStudio\\VC98\\Include\\winnt.h"

typedef  IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#line 6268 "N:\\VStudio\\VC98\\Include\\winnt.h"





struct IMAGE_DEBUG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData;
    DWORD   PointerToRawData;
};


struct IMAGE_COFF_SYMBOLS_HEADER {
    DWORD   NumberOfSymbols;
    DWORD   LvaToFirstSymbol;
    DWORD   NumberOfLinenumbers;
    DWORD   LvaToFirstLinenumber;
    DWORD   RvaToFirstByteOfCode;
    DWORD   RvaToLastByteOfCode;
    DWORD   RvaToFirstByteOfData;
    DWORD   RvaToLastByteOfData;
};


struct FPO_DATA {
    DWORD       ulOffStart;
    DWORD       cbProcSize;
    DWORD       cdwLocals;
    WORD        cdwParams;
    WORD        cbProlog : 8;
    WORD        cbRegs   : 3;
    WORD        fHasSEH  : 1;
    WORD        fUseBP   : 1;
    WORD        reserved : 1;
    WORD        cbFrame  : 2;
};


struct IMAGE_DEBUG_MISC {
    DWORD       DataType;
    DWORD       Length;

    BOOLEAN     Unicode;
    BYTE        Reserved[ 3 ];
    BYTE        Data[ 1 ];
};



struct IMAGE_FUNCTION_ENTRY {
    DWORD   StartingAddress;
    DWORD   EndingAddress;
    DWORD   EndOfPrologue;
};

#line 6363 "N:\\VStudio\\VC98\\Include\\winnt.h"
struct IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG   StartingAddress;
    ULONGLONG   EndingAddress;
    ULONGLONG   EndOfPrologue;
};



struct IMAGE_SEPARATE_DEBUG_HEADER {
    WORD        Signature;
    WORD        Flags;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       ImageBase;
    DWORD       SizeOfImage;
    DWORD       NumberOfSections;
    DWORD       ExportedNamesSize;
    DWORD       DebugDirectorySize;
    DWORD       SectionAlignment;
    DWORD       Reserved[2];
};






struct ImageArchitectureHeader {
    unsigned int AmaskValue: 1;

    int :7;
    unsigned int AmaskShift: 8;
    int :16;
    DWORD FirstEntryRVA;
};

struct ImageArchitectureEntry {
    DWORD FixupInstRVA;
    DWORD NewInst;
};



#pragma pack(pop)

struct IMPORT_OBJECT_HEADER {
    WORD    Sig1;
    WORD    Sig2;
    WORD    Version;
    WORD    Machine;
    DWORD   TimeDateStamp;
    DWORD   SizeOfData;

    union {
        WORD    Ordinal;
        WORD    Hint;
    };

    WORD    Type : 2;
    WORD    NameType : 3;
    WORD    Reserved : 11;
};

enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
};

enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,
    IMPORT_OBJECT_NAME = 1,
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,
    IMPORT_OBJECT_NAME_UNDECORATE = 3,

};




struct SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
};
typedef SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;


struct HKEY__
{
    int unused;
};
typedef HKEY__ * HKEY;
typedef HKEY   *PHKEY;

/****************************************************************************/
/*                           file I/O, memory alloc, etc.                   */
/****************************************************************************/

const uint PAGE_NOACCESS         = 0x01;
const uint PAGE_READONLY         = 0x02;
const uint PAGE_READWRITE        = 0x04;
const uint PAGE_WRITECOPY        = 0x08;
const uint PAGE_EXECUTE          = 0x10;
const uint PAGE_EXECUTE_READ     = 0x20;
const uint PAGE_EXECUTE_READWRITE= 0x40;
const uint PAGE_EXECUTE_WRITECOPY= 0x80;
const uint PAGE_GUARD           = 0x100;
const uint PAGE_NOCACHE         = 0x200;
const uint PAGE_WRITECOMBINE    = 0x400;
const uint MEM_COMMIT          = 0x1000;
const uint MEM_RESERVE         = 0x2000;
const uint MEM_DECOMMIT        = 0x4000;
const uint MEM_RELEASE         = 0x8000;
const uint MEM_FREE           = 0x10000;
const uint MEM_PRIVATE        = 0x20000;
const uint MEM_MAPPED         = 0x40000;
const uint MEM_RESET          = 0x80000;
const uint MEM_TOP_DOWN      = 0x100000;

const uint CREATE_NEW        =  1;
const uint CREATE_ALWAYS     =  2;
const uint OPEN_EXISTING     =  3;
const uint OPEN_ALWAYS       =  4;
const uint TRUNCATE_EXISTING =  5;

const uint FILE_FLAG_WRITE_THROUGH      = 0x80000000;
const uint FILE_FLAG_OVERLAPPED         = 0x40000000;
const uint FILE_FLAG_NO_BUFFERING       = 0x20000000;
const uint FILE_FLAG_RANDOM_ACCESS      = 0x10000000;
const uint FILE_FLAG_SEQUENTIAL_SCAN    = 0x08000000;
const uint FILE_FLAG_DELETE_ON_CLOSE    = 0x04000000;
const uint FILE_FLAG_BACKUP_SEMANTICS   = 0x02000000;
const uint FILE_FLAG_POSIX_SEMANTICS    = 0x01000000;
const uint FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000;
const uint FILE_FLAG_OPEN_NO_RECALL     = 0x00100000;

[sysimport(dll="kernel32.dll", name="CreateFileA")]
HANDLE  CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

[sysimport(dll="kernel32.dll", name="ReadFile")]
BOOL    ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPVOID  lpOverlapped
    );

[sysimport(dll="kernel32.dll", name="CreateFileMappingA")]
HANDLE  CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );

[sysimport(dll="kernel32.dll", name="MapViewOfFileEx")]
LPVOID  MapViewOfFileEx(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap,
    LPVOID lpBaseAddress
    );

[sysimport(dll="kernel32.dll", name="VirtualAlloc")]
LPVOID  VirtualAlloc(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );

[sysimport(dll="kernel32.dll", name="VirtualFree")]
BOOL    VirtualFree(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD dwFreeType
    );

/****************************************************************************/
/*                            synchronization                               */
/****************************************************************************/

const  unsigned WAIT_TIMEOUT        = 0x102;
const  unsigned WAIT_IO_COMPLETION  = 0x0C0;

struct OVERLAPPED
{
    DWORD   Internal;
    DWORD   InternalHigh;
    DWORD   Offset;
    DWORD   OffsetHigh;
    HANDLE  hEvent;
};

struct CRITICAL_SECTION
{
    void *  DebugInfo;
    LONG    LockCount;
    LONG    RecursionCount;
    HANDLE  OwningThread;
    HANDLE  LockSemaphore;
    DWORD   SpinCount;
};

/****************************************************************************/
/*                                misc                                      */
/****************************************************************************/

[sysimport(dll="kernel32.dll", name="RaiseException")]
VOID    RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    DWORD *lpArguments
    );

[sysimport(dll="kernel32.dll", name="GetSystemDirectoryA")]
UINT    GetSystemDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );

[sysimport(dll="kernel32.dll", name="SearchPathA")]
DWORD   SearchPathA(
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

[sysimport(dll="kernel32.dll", name="GetLastError")]
DWORD   GetLastError();

[sysimport(dll="kernel32.dll", name="CloseHandle")]
BOOL    CloseHandle(HANDLE hObject);

[sysimport(dll="kernel32.dll", name="GetCurrentProcessId")]
DWORD   GetCurrentProcessId();

const   uint    STATUS_STACK_OVERFLOW          = 0xC00000FD;

/****************************************************************************/
/*                               Registry                                   */
/****************************************************************************/

const   uint    REG_NONE                       = 0;
const   uint    REG_SZ                         = 1;
const   uint    REG_EXPAND_SZ                  = 2;

const   uint    REG_BINARY                     = 3;
const   uint    REG_DWORD                      = 4;
const   uint    REG_DWORD_LITTLE_ENDIAN        = 4;
const   uint    REG_DWORD_BIG_ENDIAN           = 5;
const   uint    REG_LINK                       = 6;
const   uint    REG_MULTI_SZ                   = 7;
const   uint    REG_RESOURCE_LIST              = 8;
const   uint    REG_FULL_RESOURCE_DESCRIPTOR   = 9;
const   uint    REG_RESOURCE_REQUIREMENTS_LIST = 10;

const   uint    KEY_QUERY_VALUE                = 0x0001;
const   uint    KEY_SET_VALUE                  = 0x0002;
const   uint    KEY_CREATE_SUB_KEY             = 0x0004;
const   uint    KEY_ENUMERATE_SUB_KEYS         = 0x0008;
const   uint    KEY_NOTIFY                     = 0x0010;
const   uint    KEY_CREATE_LINK                = 0x0020;

const   HKEY    HKEY_CLASSES_ROOT              = (HKEY)0x80000000;
const   HKEY    HKEY_CURRENT_USER              = (HKEY)0x80000001;
const   HKEY    HKEY_LOCAL_MACHINE             = (HKEY)0x80000002;
const   HKEY    HKEY_USERS                     = (HKEY)0x80000003;
const   HKEY    HKEY_PERFORMANCE_DATA          = (HKEY)0x80000004;
const   HKEY    HKEY_CURRENT_CONFIG            = (HKEY)0x80000005;
const   HKEY    HKEY_DYN_DATA                  = (HKEY)0x80000006;

[sysimport(dll="kernel32.dll", name="RegOpenKeyA")]
LONG    RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);

[sysimport(dll="kernel32.dll", name="RegQueryValueA")]
LONG    RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);

[sysimport(dll="kernel32.dll", name="RegCloseKey")]
LONG    RegCloseKey(HKEY hKey);

/****************************************************************************/
/*                                 COM                                      */
/****************************************************************************/

struct   IUnknown
{
public:

    virtual abstract HRESULT __stdcall QueryInterface(INOUT const IID REF riid, void  * *ppvObject);
    virtual abstract ULONG   __stdcall AddRef();
    virtual abstract ULONG   __stdcall Release();
};



enum CLSCTX
{
    CLSCTX_INPROC_SERVER    = 0x1,
    CLSCTX_INPROC_HANDLER   = 0x2,
    CLSCTX_LOCAL_SERVER     = 0x4,
    CLSCTX_INPROC_SERVER16  = 0x8,
    CLSCTX_REMOTE_SERVER    = 0x10,
    CLSCTX_INPROC_HANDLER16 = 0x20,
    CLSCTX_INPROC_SERVERX86 = 0x40,
    CLSCTX_INPROC_HANDLERX86        = 0x80,
    CLSCTX_ESERVER_HANDLER  = 0x100
};


typedef IUnknown  * LPUNKNOWN;

struct  IStream     {};

[sysimport(dll="ole32.dll", name="CoInitialize")]
HRESULT    CoInitialize(LPVOID pvReserved);

[sysimport(dll="ole32.dll", name="CoUninitialize")]
void     CoUninitialize();

[sysimport(dll="ole32.dll", name="CoCreateInstance")]
HRESULT     CoCreateInstance(
                void * rclsid,
                LPUNKNOWN pUnkOuter,
                DWORD dwClsContext,
                void * riid,
                LPVOID * ppv);

/****************************************************************************/

inline
bool                FAILED(HRESULT Status)
{
    return  (Status < 0);
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\corwrap\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "corwrap.dll"
#define VER_FILEDESCRIPTION_STR "Common Language Runtime SMC helper dll\0"
#define VER_ORIGFILENAME_STR    "corwrap.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\corwrap\corwrap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _CORWRAP_H
#define _CORWRAP_H
/*****************************************************************************/

#ifndef COR_IMPORT
#ifndef __SMC__

#ifdef  __IL__
#define COR_IMPORT(d,e) [sysimport(dll=d, name=e)]
#else
#define COR_IMPORT(d,e) __declspec(dllimport)
#endif

#endif
#endif

/*****************************************************************************/

#ifdef  __IL__

#ifdef  _MSC_VER

#define SectEH_Emit                 fake_SectEH_Emit
#define SectEH_EHClause             fake_SectEH_EHClause
#define SectEH_SizeExact            fake_SectEH_SizeExact

#define IlmethodSize                fake_IlmethodSize
#define IlmethodEmit                fake_IlmethodEmit

#include "corhlpr.h"

#undef  SectEH_Emit
#undef  SectEH_EHClause
#undef  SectEH_SizeExact

#undef  IlmethodSize
#undef  IlmethodEmit

#endif

#else

#include "corhlpr.h"

#endif

/*****************************************************************************/
#ifdef SMC_MD_PERF
/*****************************************************************************/
#pragma warning(disable:4035)

#define CCNT_OVERHEAD64 13

static __int64         CycleCount64()
{
__asm   _emit   0x0F
__asm   _emit   0x31
};

#define CCNT_OVERHEAD32 13

static unsigned        CycleCount32()        // enough for about 40 seconds
{
__asm   push    EDX
__asm   _emit   0x0F
__asm   _emit   0x31
__asm   pop     EDX
};

#pragma warning(default:4035)

/*****************************************************************************/
#endif
/*****************************************************************************/

struct  WMetaData
{
    unsigned            useCount;

#ifdef  __SMC__
    COR_IMPORT("CORwrap.dll", "?AddRef@WMetaData@@UAEXXZ")
#endif
    virtual void        AddRef();

#ifdef  __SMC__
    COR_IMPORT("CORwrap.dll", "?Release@WMetaData@@UAEXXZ")
#endif
    virtual void        Release();

#ifdef  SMC_MD_PERF

    __int64             cycleBegin;
    __int64             cycleTotal;
    __int64             cycleStart;
    unsigned            cyclePause;

    void                cycleCounterInit()
    {
        cycleBegin = CycleCount64();
        cycleTotal = 0;
        cycleStart = 0;
        cyclePause = 0;
    }

    __int64             cycleCounterDone(__int64 *realPtr)
    {
        assert(cyclePause == 0);

        *realPtr = CycleCount64() - cycleBegin;

        return cycleTotal;
    }

    void                cycleCounterBeg()
    {
        assert(cyclePause == 0);

        cycleStart = CycleCount64();
    }

    void                cycleCounterEnd()
    {
        assert(cycleStart != 0);
        assert(cyclePause == 0);

        cycleTotal += CycleCount64() - cycleStart;// - CCNT_OVERHEAD64;

        cycleStart  = 0;
    }

    void                cycleCounterPause()
    {
        assert(cycleStart != 0);

        if  (!cyclePause)
            cycleTotal += CycleCount64() - cycleStart;// - CCNT_OVERHEAD64;

        cyclePause++;
    }

    void                cycleCounterResume()
    {
        assert(cycleStart != 0);
        assert(cyclePause != 0);

        if  (--cyclePause)
            return;

        cycleStart = CycleCount64();
    }

    __int64 __stdcall   getTotalCycles()
    {
        return cycleTotal;
    }

#else //SMC_MD_PERF

    void                cycleCounterPause () {}
    void                cycleCounterResume() {}

#endif//SMC_MD_PERF

};

struct  WSymWriter;

struct  WMetaDataImport : WMetaData
{
    IMetaDataImport    *imdi;

    COR_IMPORT("CORwrap.dll", "?CloseEnum@WMetaDataImport@@QAGXPAX@Z")
    void    __stdcall   CloseEnum(HCORENUM hEnum);

    COR_IMPORT("CORwrap.dll", "?CountEnum@WMetaDataImport@@QAGHPAXPAK@Z")
    int     __stdcall   CountEnum(HCORENUM hEnum, ULONG *pulCount);

    COR_IMPORT("CORwrap.dll", "?ResetEnum@WMetaDataImport@@QAGHPAXK@Z")
    int     __stdcall   ResetEnum(HCORENUM hEnum, ULONG ulPos);

    COR_IMPORT("CORwrap.dll", "?EnumTypeDefs@WMetaDataImport@@QAGHPAPAXQAIKPAK@Z")
    int     __stdcall   EnumTypeDefs(HCORENUM *phEnum, mdTypeDef rTypeDefs[], ULONG cMax, ULONG *pcTypeDefs);

    COR_IMPORT("CORwrap.dll", "?EnumInterfaceImpls@WMetaDataImport@@QAGHPAPAXIQAIKPAK@Z")
    int     __stdcall   EnumInterfaceImpls(HCORENUM *phEnum, mdTypeDef td, mdInterfaceImpl rImpls[], ULONG cMax, ULONG* pcImpls);

    COR_IMPORT("CORwrap.dll", "?EnumTypeRefs@WMetaDataImport@@QAGHPAPAXQAIKPAK@Z")
    int     __stdcall   EnumTypeRefs(HCORENUM *phEnum, mdTypeRef rTypeRefs[], ULONG cMax, ULONG* pcTypeRefs);

    COR_IMPORT("CORwrap.dll", "?GetScopeProps@WMetaDataImport@@QAGHPAGKPAKPAU_GUID@@@Z")
    int     __stdcall   GetScopeProps(
                LPWSTR          szName,
                ULONG           cchName,
                ULONG          *pchName,
                GUID           *pmvid);

    COR_IMPORT("CORwrap.dll", "?GetNameFromToken@WMetaDataImport@@QAGHIPAPBD@Z")
    int     __stdcall   GetNameFromToken(
                mdToken         tk,
                const char *   *pszUtf8NamePtr);

    COR_IMPORT("CORwrap.dll", "?GetTypeDefProps@WMetaDataImport@@QAGHIPAGKPAK1PAI@Z")
    int     __stdcall   GetTypeDefProps(
                mdTypeDef       td,
                LPWSTR          szTypeDef,
                ULONG           cchTypeDef,
                ULONG          *pchTypeDef,
                DWORD          *pdwTypeDefFlags,
                mdToken        *ptkExtends);

    COR_IMPORT("CORwrap.dll", "?EnumMembers@WMetaDataImport@@QAGHPAPAXIQAIKPAK@Z")
    int     __stdcall   EnumMembers(
                HCORENUM        *phEnum,
                mdTypeDef       cl,
                mdToken         rMembers[],
                ULONG           cMax,
                ULONG           *pcTokens); /* abstract */

    COR_IMPORT("CORwrap.dll", "?GetMemberProps@WMetaDataImport@@QAGHIPAIPAGKPAK2PAPBE2222PAPBX2@Z")
    int     __stdcall   GetMemberProps(
                mdToken         mb,
                mdTypeDef       *pClass,
                LPWSTR          szMember,
                ULONG           cchMember,
                ULONG           *pchMember,
                DWORD           *pdwAttr,
                PCCOR_SIGNATURE *ppvSigBlob,
                ULONG           *pcbSigBlob,
                ULONG           *pulCodeRVA,
                DWORD           *pdwImplFlags,
                DWORD           *pdwCPlusTypeFlag,
                void const      **ppValue,
                ULONG           *pcbValue); /* abstract */

    COR_IMPORT("CORwrap.dll", "?EnumProperties@WMetaDataImport@@QAGHPAPAXIQAIKPAK@Z")
    int     __stdcall   EnumProperties(
                HCORENUM       *phEnum,
                mdTypeDef       td,
                mdProperty      rProperties[],
                ULONG           cMax,
                ULONG          *pcProperties);

    COR_IMPORT("CORwrap.dll", "?GetPropertyProps@WMetaDataImport@@QAGHIPAIPBGKPAK2PAPBE22PAPBX200QAIK2@Z")
    int     __stdcall   GetPropertyProps(
                mdProperty      prop,
                mdTypeDef      *pClass,
                LPCWSTR         szProperty,
                ULONG           cchProperty,
                ULONG          *pchProperty,
                DWORD          *pdwPropFlags,
                PCCOR_SIGNATURE*ppvSig,
                ULONG          *pbSig,
                DWORD          *pdwCPlusTypeFlag,
                void const    **ppDefaultValue,
                ULONG          *pcbDefaultValue,
                mdMethodDef    *pmdSetter,
                mdMethodDef    *pmdGetter,
                mdMethodDef     rmdOtherMethod[],
                ULONG           cMax,
                ULONG          *pcOtherMethod);

    COR_IMPORT("CORwrap.dll", "?EnumParams@WMetaDataImport@@QAGHPAPAXIQAIKPAK@Z")
    int     __stdcall   EnumParams(
                HCORENUM        *phEnum,
                mdMethodDef mb,
                mdParamDef      rParams[],
                ULONG           cMax,
                ULONG           *pcTokens); /* abstract */

    COR_IMPORT("CORwrap.dll", "?GetParamProps@WMetaDataImport@@QAGHIPAIPAKPAGK111PAPBX1@Z")
    int     __stdcall   GetParamProps(
                mdToken         tk,
                mdMethodDef     *pmd,
                ULONG           *pulSequence,
                LPWSTR          szName,
                ULONG           cchName,
                ULONG           *pchName,
                DWORD           *pdwAttr,
                DWORD           *pdwCPlusTypeFlag,
                void const      **ppValue,
                ULONG           *pcbValue); /* abstract */

    COR_IMPORT("CORwrap.dll", "?GetInterfaceImplProps@WMetaDataImport@@QAGHIPAI0@Z")
    int     __stdcall   GetInterfaceImplProps(
                mdInterfaceImpl iiImpl,
                mdTypeDef       *pClass,
                mdToken         *ptkIface);

    COR_IMPORT("CORwrap.dll", "?GetClassLayout@WMetaDataImport@@QAGHIPAKQAUCOR_FIELD_OFFSET@@K00@Z")
    int     __stdcall   GetClassLayout(
                mdTypeDef   td,
                DWORD       *pdwPackSize,
                COR_FIELD_OFFSET rFieldOffset[],
                ULONG       cMax,
                ULONG       *pcFieldOffset,
                ULONG       *pulClassSize);

    COR_IMPORT("CORwrap.dll", "?GetFieldMarshal@WMetaDataImport@@QAGHIPAPBEPAK@Z")
    int     __stdcall   GetFieldMarshal(
                mdToken         tk,
                PCCOR_SIGNATURE*ppvNativeType,
                ULONG          *pcbNativeType);

    COR_IMPORT("CORwrap.dll", "?GetPermissionSetProps@WMetaDataImport@@QAGHIPAKPAPBX0@Z")
    int     __stdcall   GetPermissionSetProps(
                mdPermission    pm,
                DWORD          *pdwAction,
                void const    **ppvPermission,
                ULONG          *pcbPermission);

    COR_IMPORT("CORwrap.dll", "?GetNestedClassProps@WMetaDataImport@@QAGHIPAI@Z")
    int     __stdcall   GetNestedClassProps(
                mdTypeDef       tdNestedClass,
                mdTypeDef      *ptdEnclosingClass);

    COR_IMPORT("CORwrap.dll", "?GetTypeRefProps@WMetaDataImport@@QAGHIIPAGKPAK@Z")
    int     __stdcall   GetTypeRefProps(
                mdTypeRef       tr,
                mdToken         tkResolutionScope,

                LPWSTR          szTypeRef,
                ULONG           cchTypeRef,
                ULONG          *pchTypeRef);

    COR_IMPORT("CORwrap.dll", "?GetMemberRefProps@WMetaDataImport@@QAGHIPAIPAGKPAKPAPBE2@Z")
    int     __stdcall   GetMemberRefProps(
                mdMemberRef     mr,
                mdToken        *ptk,
                LPWSTR          szMember,
                ULONG           cchMember,
                ULONG          *pchMember,
                PCCOR_SIGNATURE*ppvSigBlob,
                ULONG          *pbSig);

    COR_IMPORT("CORwrap.dll", "?GetMethodProps@WMetaDataImport@@QAGHIPAIPAGKPAK2PAPBE222@Z")
    int     __stdcall   GetMethodProps(
                mdMethodDef     mb,
                mdTypeDef      *pClass,
                LPWSTR          szMethod,
                ULONG           cchMethod,
                ULONG          *pchMethod,
                DWORD          *pdwAttr,
                PCCOR_SIGNATURE*ppvSigBlob,
                ULONG          *pcbSigBlob,
                ULONG          *pulCodeRVA,
                DWORD          *pdwImplFlags);

    COR_IMPORT("CORwrap.dll", "?ResolveTypeRef@WMetaDataImport@@QAGHIPBU_GUID@@PAPAU1@PAI@Z")
    int     __stdcall   ResolveTypeRef(mdTypeRef tr, const IID * riid, WMetaDataImport **scope, mdTypeDef *ptd);

    COR_IMPORT("CORwrap.dll", "?FindTypeRef@WMetaDataImport@@QAGHIPBGPAI@Z")
    int     __stdcall   FindTypeRef(
                mdToken         tkResolutionScope,
                LPCWSTR         szTypeName,
                mdTypeRef      *ptr);

    COR_IMPORT("CORwrap.dll", "?GetCustomAttributeByName@WMetaDataImport@@QAGHIPBGPAPBXPAK@Z")
    int     __stdcall   GetCustomAttributeByName(mdToken tkObj, LPCWSTR szName, void const **ppBlob, ULONG *pcbSize);

    COR_IMPORT("CORwrap.dll", "?EnumCustomAttributes@WMetaDataImport@@QAGHPAPAXIIQAIKPAK@Z")
    int     __stdcall   EnumCustomAttributes(
                HCORENUM       *phEnum,
                mdToken         tk,
                mdToken         tkType,
                mdCustomAttribute   rCustomValues[],
                ULONG           cMax,
                ULONG          *pcCustomValues);

    COR_IMPORT("CORwrap.dll", "?GetCustomAttributeProps@WMetaDataImport@@QAGHIPAI0PAPBXPAK@Z")
    int     __stdcall   GetCustomAttributeProps(
                mdCustomAttribute   cv,
                mdToken        *ptkObj,
                mdToken        *ptkType,
                void const    **ppBlob,
                ULONG          *pcbSize);
};

struct  WMetaDataEmit : WMetaData
{
    IMetaDataEmit      *imde;

    COR_IMPORT("CORwrap.dll", "?SetModuleProps@WMetaDataEmit@@QAGHPBG@Z")
    int     __stdcall SetModuleProps(
                LPCWSTR         szName);

    COR_IMPORT("CORwrap.dll", "?DefineTypeDef@WMetaDataEmit@@QAGHPBGKIQAIPAI@Z")
    int     __stdcall   DefineTypeDef(
                LPCWSTR         szTypeDef,
                DWORD           dwTypeDefFlags,
                mdToken         tkExtends,
                mdToken         rtkImplements[],
                mdTypeDef       *ptd);

    COR_IMPORT("CORwrap.dll", "?DefineNestedType@WMetaDataEmit@@QAGHPBGKIQAIIPAI@Z")
    int     __stdcall   DefineNestedType(
                LPCWSTR         szTypeDef,
                DWORD           dwTypeDefFlags,
                mdToken         tkExtends,
                mdToken         rtkImplements[],
                mdTypeDef       tkEncloser,
                mdTypeDef       *ptd);

    COR_IMPORT("CORwrap.dll", "?SetTypeDefProps@WMetaDataEmit@@QAGHIKIQAI@Z")
    int     __stdcall   SetTypeDefProps(
                mdTypeDef       td,
                DWORD           dwTypeDefFlags,
                mdToken         tkExtends,
                mdToken         rtkImplements[]);

    COR_IMPORT("CORwrap.dll", "?DefineMethod@WMetaDataEmit@@QAGHIPBGKPBEKKKPAI@Z")
    int     __stdcall   DefineMethod(
                mdTypeDef       td,
                LPCWSTR         szName,
                DWORD           dwMethodFlags,
                PCCOR_SIGNATURE pvSigBlob,
                ULONG           cbSigBlob,
                ULONG           ulCodeRVA,
                DWORD           dwImplFlags,
                mdMethodDef *pmd);

    COR_IMPORT("CORwrap.dll", "?DefineField@WMetaDataEmit@@QAGHIPBGKPBEKKPBXKPAI@Z")
    int     __stdcall   DefineField(
                mdTypeDef       td,
                LPCWSTR         szName,
                DWORD           dwFieldFlags,
                PCCOR_SIGNATURE pvSigBlob,
                ULONG           cbSigBlob,
                DWORD           dwCPlusTypeFlag,
                void const      *pValue,
                ULONG           cbValue,
                mdFieldDef      *pmd);

    COR_IMPORT("CORwrap.dll", "?DefineProperty@WMetaDataEmit@@QAGHIPBGKPBEKKPBXKIIQAIPAI@Z")
    int     __stdcall   DefineProperty(
                mdTypeDef       td,
                LPCWSTR         szProperty,
                DWORD           dwPropFlags,
                PCCOR_SIGNATURE pvSig,
                ULONG           cbSig,
                DWORD           dwCPlusTypeFlag,
                void const     *pValue,
                ULONG           cbValue,
                mdMethodDef     mdSetter,
                mdMethodDef     mdGetter,
                mdMethodDef     rmdOtherMethods[],
                mdProperty     *pmdProp);

    COR_IMPORT("CORwrap.dll", "?DefineParam@WMetaDataEmit@@QAGHIKPBGKKPBXKPAI@Z")
    int     __stdcall   DefineParam(
                mdMethodDef md,
                ULONG           ulParamSeq,
                LPCWSTR         szName,
                DWORD           dwParamFlags,
                DWORD           dwCPlusTypeFlag,
                void const      *pValue,
                ULONG           cbValue,
                mdParamDef      *ppd);

    COR_IMPORT("CORwrap.dll", "?DefineMethodImpl@WMetaDataEmit@@QAGHIII@Z")
    int     __stdcall   DefineMethodImpl(
                mdTypeDef       td,
                mdToken         tkBody,
                mdToken         tkDecl);

    COR_IMPORT("CORwrap.dll", "?SetRVA@WMetaDataEmit@@QAGHIK@Z")
    int     __stdcall   SetRVA(
                mdToken         md,
                ULONG           ulCodeRVA);

    COR_IMPORT("CORwrap.dll", "?SetMethodImplFlags@WMetaDataEmit@@QAGHIK@Z")
    int     __stdcall   SetMethodImplFlags(
                mdToken         md,
                DWORD           dwImplFlags);

    COR_IMPORT("CORwrap.dll", "?DefineTypeRefByName@WMetaDataEmit@@QAGHIPBGPAI@Z")
    int     __stdcall   DefineTypeRefByName(
                mdToken         tkResolutionScope,
                LPCWSTR         szName,
                mdTypeRef       *ptr);

    COR_IMPORT("CORwrap.dll", "?DefineImportType@WMetaDataEmit@@QAGHPAUIMetaDataAssemblyImport@@PBXKPAUIMetaDataImport@@IPAUIMetaDataAssemblyEmit@@PAI@Z")
    int     __stdcall   DefineImportType(
                IMetaDataAssemblyImport *pAssemImport,
                const void      *pbHashValue,
                ULONG           ulHashValue,
                IMetaDataImport *pImport,
                mdTypeDef       tdImport,
                IMetaDataAssemblyEmit *pAssemEmit,
                mdTypeRef       *ptr);

    COR_IMPORT("CORwrap.dll", "?DefineMemberRef@WMetaDataEmit@@QAGHIPBGPBEKPAI@Z")
    int     __stdcall   DefineMemberRef(
                mdToken         tkImport,
                LPCWSTR         szName,
                PCCOR_SIGNATURE pvSigBlob,
                ULONG           cbSigBlob,
                mdMemberRef *pmr);

    COR_IMPORT("CORwrap.dll", "?DefineImportMember@WMetaDataEmit@@QAGHPAUIMetaDataAssemblyImport@@PBXKPAUIMetaDataImport@@IPAUIMetaDataAssemblyEmit@@IPAI@Z")
    int     __stdcall   DefineImportMember(
                IMetaDataAssemblyImport *pAssemImport,
                const void      *pbHashValue,
                ULONG           cbHashValue,
                IMetaDataImport *pImport,
                mdToken         mbMember,
                IMetaDataAssemblyEmit *pAssemEmit,
                mdToken         tkParent,
                mdMemberRef *pmr);

    COR_IMPORT("CORwrap.dll", "?SetClassLayout@WMetaDataEmit@@QAGHIKQAUCOR_FIELD_OFFSET@@K@Z")
    int     __stdcall   SetClassLayout(
                mdTypeDef       td,
                DWORD           dwPackSize,
                COR_FIELD_OFFSET rFieldOffsets[],
                ULONG           ulClassSize);

    COR_IMPORT("CORwrap.dll", "?SetFieldMarshal@WMetaDataEmit@@QAGHIPBEK@Z")
    int     __stdcall   SetFieldMarshal(
                mdToken         tk,
                PCCOR_SIGNATURE pvNativeType,
                ULONG           cbNativeType);

    COR_IMPORT("CORwrap.dll", "?SetFieldRVA@WMetaDataEmit@@QAGHIK@Z")
    int     __stdcall   SetFieldRVA(
                mdFieldDef      fd,
                ULONG           ulRVA);

    COR_IMPORT("CORwrap.dll", "?DefinePermissionSet@WMetaDataEmit@@QAGHIKPBXKPAI@Z")
    int     __stdcall   DefinePermissionSet(
                mdToken         tk,
                DWORD           dwAction,
                void const     *pvPermission,
                ULONG           cbPermission,
                mdPermission   *ppm);

    COR_IMPORT("CORwrap.dll", "?GetTokenFromSig@WMetaDataEmit@@QAGHPBEKPAI@Z")
    int     __stdcall   GetTokenFromSig(
                PCCOR_SIGNATURE pvSig,
                ULONG           cbSig,
                mdSignature *pmsig);

    COR_IMPORT("CORwrap.dll", "?DefineModuleRef@WMetaDataEmit@@QAGHPBGPAI@Z")
    int     __stdcall   DefineModuleRef(
                LPCWSTR         szName,
                mdModuleRef     *pmur);

    COR_IMPORT("CORwrap.dll", "?SetParent@WMetaDataEmit@@QAGHII@Z")
    int     __stdcall   SetParent(
                mdMemberRef     mr,
                mdToken         tk);

    COR_IMPORT("CORwrap.dll", "?GetSaveSize@WMetaDataEmit@@QAGHW4CorSaveSize@@PAK@Z")
    int     __stdcall   GetSaveSize(CorSaveSize fSave, DWORD *pdwSaveSize);

    COR_IMPORT("CORwrap.dll", "?SaveToMemory@WMetaDataEmit@@QAGHPAXK@Z")
    int     __stdcall   SaveToMemory(
                void           *pbData,
                ULONG           cbData);

    COR_IMPORT("CORwrap.dll", "?DefineUserString@WMetaDataEmit@@QAGHPBGKPAI@Z")
    int     __stdcall   DefineUserString(
                LPCWSTR         szString,
                ULONG           cchString,
                mdString       *pstk);

    COR_IMPORT("CORwrap.dll", "?DefinePinvokeMap@WMetaDataEmit@@QAGHIKPBGI@Z")
    int     __stdcall   DefinePinvokeMap(
                mdToken         tk,
                DWORD           dwMappingFlags,
                LPCWSTR         szImportName,
                mdModuleRef     mrImportDLL);

    COR_IMPORT("CORwrap.dll", "?DefineCustomAttribute@WMetaDataEmit@@QAGHIIPBXKPAI@Z")
    int     __stdcall   DefineCustomAttribute(
                mdToken         tkObj,
                mdToken         tkType,
                void const     *pCustomValue,
                ULONG           cbCustomValue,
                mdCustomAttribute  *pcv);

    COR_IMPORT("CORwrap.dll", "?DefineSecurityAttributeSet@WMetaDataEmit@@QAGHIQAUCOR_SECATTR@@KPAK@Z")
    int     __stdcall DefineSecurityAttributeSet(
                mdToken         tkObj,
                COR_SECATTR     rSecAttrs[],
                ULONG           cSecAttrs,
                ULONG          *pulErrorAttr);

    COR_IMPORT("CORwrap.dll", "?GetTokenFromTypeSpec@WMetaDataEmit@@QAGHPBEKPAI@Z")
    int     __stdcall GetTokenFromTypeSpec(
                PCCOR_SIGNATURE pvSig,
                ULONG           cbSig,
                mdTypeSpec *parrspec);

    COR_IMPORT("CORwrap.dll", "?CreateSymbolWriter@WMetaDataEmit@@QAGHPBGPAPAUWSymWriter@@@Z")
    int     __stdcall   CreateSymbolWriter(
                LPCWSTR         filename,
                WSymWriter    **dbgWriter);
};

struct  WSymWriter : WMetaData
{
    void    *           isw;

    COR_IMPORT("CORwrap.dll", "?DefineDocument@WSymWriter@@QAGHPBGPAPAX@Z")
    int     __stdcall DefineDocument(
                LPCWSTR         wzFileName,
                void          **pISymUnmanagedDocument);

    COR_IMPORT("CORwrap.dll", "?OpenMethod@WSymWriter@@QAGHI@Z")
    int     __stdcall OpenMethod(
                mdMethodDef     methodToken);

    COR_IMPORT("CORwrap.dll", "?CloseMethod@WSymWriter@@QAGHXZ")
    int     __stdcall CloseMethod();

    COR_IMPORT("CORwrap.dll", "?SetUserEntryPoint@WSymWriter@@QAGHI@Z")
    int     __stdcall SetUserEntryPoint(
                mdMethodDef     methodToken);

    COR_IMPORT("CORwrap.dll", "?DefineSequencePoints@WSymWriter@@QAGHPAXIPAI1@Z")
    int     __stdcall DefineSequencePoints(
                void           *document,
                ULONG32        spCount,
                unsigned       *offsets,
                unsigned       *lines);

    COR_IMPORT("CORwrap.dll", "?OpenScope@WSymWriter@@QAGHIPAI@Z")
    int     __stdcall OpenScope(
                unsigned        startOffset,
                unsigned       *scopeID);

    COR_IMPORT("CORwrap.dll", "?CloseScope@WSymWriter@@QAGHI@Z")
    int     __stdcall CloseScope(
                unsigned        endOffset);

    COR_IMPORT("CORwrap.dll", "?SetScopeRange@WSymWriter@@QAGHIII@Z")
    int     __stdcall SetScopeRange(
                unsigned        scopeID,
                unsigned        startOffset,
                unsigned        endOffset);

    COR_IMPORT("CORwrap.dll", "?DefineLocalVariable@WSymWriter@@QAGHPBGPBEII@Z")
    int     __stdcall DefineLocalVariable(
                LPCWSTR         wzVariableName,
                PCCOR_SIGNATURE sigPtr,
                ULONG32         sigLen,
                unsigned        slot);

    COR_IMPORT("CORwrap.dll", "?DefineParameter@WSymWriter@@QAGHPBGI@Z")
    int     __stdcall DefineParameter(
                LPCWSTR         wzVariableName,
                unsigned        sequence);

    COR_IMPORT("CORwrap.dll", "?GetDebugInfo@WSymWriter@@QAGHPAU_IMAGE_DEBUG_DIRECTORY@@KPAKQAE@Z")
    int     __stdcall GetDebugInfo(IMAGE_DEBUG_DIRECTORY *pIDD,
                                   DWORD cData,
                                   DWORD *pcData,
                                   BYTE data[]);

    COR_IMPORT("CORwrap.dll", "?Close@WSymWriter@@QAGHXZ")
    int     __stdcall Close();
};

struct  WAssemblyImport : WMetaData
{
    IMetaDataAssemblyImport *iasi;

    COR_IMPORT("CORwrap.dll", "?GetAssemblyFromScope@WAssemblyImport@@QAGHPAI@Z")
    int     __stdcall GetAssemblyFromScope(mdAssembly *ptkAssembly);

    COR_IMPORT("CORwrap.dll", "?GetAssemblyProps@WAssemblyImport@@QAGHIPAPBXPAK1PAGK1PAUASSEMBLYMETADATA@@1@Z")
    int     __stdcall GetAssemblyProps(
                mdAssembly      mda,
                const void    **ppbPublicKey,
                ULONG          *pcbPublicKey,
                ULONG          *pulHashAlgId,
                LPWSTR          szName,
                ULONG           cchName,
                ULONG          *pchName,
                ASSEMBLYMETADATA *pMetaData,
                DWORD          *pdwAssemblyFlags);

    COR_IMPORT("CORwrap.dll", "?EnumExportedTypes@WAssemblyImport@@QAGHPAPAXQAIKPAK@Z")
    int     __stdcall EnumExportedTypes(
                HCORENUM       *phEnum,
                mdExportedType       rComTypes[],
                ULONG           cMax,
                ULONG          *pcTokens);

    COR_IMPORT("CORwrap.dll", "?GetExportedTypeProps@WAssemblyImport@@QAGHIPAGKPAKPAI21@Z")
    int     __stdcall GetExportedTypeProps(
                mdExportedType       mdct,
                LPWSTR          szName,
                ULONG           cchName,
                ULONG          *pchName,
                mdToken        *ptkImplementation,
                mdTypeDef      *ptkTypeDef,
                DWORD          *pdwComTypeFlags);

    COR_IMPORT("CORwrap.dll", "?EnumFiles@WAssemblyImport@@QAGHPAPAXQAIKPAK@Z")
    int     __stdcall EnumFiles(
                HCORENUM       *phEnum,
                mdFile          rFiles[],
                ULONG           cMax,
                ULONG          *pcTokens);

    COR_IMPORT("CORwrap.dll", "?GetFileProps@WAssemblyImport@@QAGHIPAGKPAKPAPBX11@Z")
    int     __stdcall GetFileProps(
                mdFile          mdf,
                LPWSTR          szName,
                ULONG           cchName,
                ULONG          *pchName,
                const void    **ppbHashValue,
                ULONG          *pcbHashValue,
                DWORD          *pdwFileFlags);

    COR_IMPORT("CORwrap.dll", "?CloseEnum@WAssemblyImport@@QAGXPAX@Z")
    void    __stdcall CloseEnum(HCORENUM hEnum);
};

struct  WAssemblyEmit   : WMetaData
{
    IMetaDataAssemblyEmit  *iase;

    COR_IMPORT("CORwrap.dll", "?DefineAssembly@WAssemblyEmit@@QAGHPBXKKPBGPBUASSEMBLYMETADATA@@111KPAI@Z")
    int     __stdcall DefineAssembly(
                const void  *pbPublicKey,
                ULONG       cbPublicKey,
                ULONG       ulHashAlgId,
                LPCWSTR     szName,
                const ASSEMBLYMETADATA *pMetaData,
                LPCWSTR     szTitle,
                LPCWSTR     szDescription,
                LPCWSTR     szDefaultAlias,
                DWORD       dwAssemblyFlags,
                mdAssembly  *pma);

    COR_IMPORT("CORwrap.dll", "?DefineAssemblyRef@WAssemblyEmit@@QAGHPBXKPBGPBUASSEMBLYMETADATA@@0KKPAI@Z")
    int     __stdcall DefineAssemblyRef(
                const void  *pbPublicKeyOrToken,
                ULONG       cbPublicKeyOrToken,
                LPCWSTR     szName,
                const ASSEMBLYMETADATA *pMetaData,
                const void  *pbHashValue,
                ULONG       cbHashValue,
                DWORD       dwAssemblyRefFlags,
                mdAssemblyRef *pmdar);

    COR_IMPORT("CORwrap.dll", "?DefineFile@WAssemblyEmit@@QAGHPBGPBXKKPAI@Z")
    int     __stdcall DefineFile(
                LPCWSTR     szName,
                const void  *pbHashValue,
                ULONG       cbHashValue,
                DWORD       dwFileFlags,
                mdFile      *pmdf);

    COR_IMPORT("CORwrap.dll", "?DefineExportedType@WAssemblyEmit@@QAGHPBGIIKPAI@Z")
    int     __stdcall DefineExportedType(
                LPCWSTR     szName,
                mdToken     tkImplementation,
                mdTypeDef   tkTypeDef,
                DWORD       dwComTypeFlags,
                mdExportedType   *pmdct);

    COR_IMPORT("CORwrap.dll", "?DefineManifestResource@WAssemblyEmit@@QAGHPBGIKKPAI@Z")
    int     __stdcall DefineManifestResource(
                LPCWSTR     szName,
                mdToken     tkImplementation,
                DWORD       dwOffset,
                DWORD       dwResourceFlags,
                mdManifestResource  *pmdmr);

#if 0

    COR_IMPORT("CORwrap.dll", "???????????????????????")
    int     __stdcall SetAssemblyRefProps(
                mdAssemblyRef ar,
                const void  *pbPublicKeyOrToken,
                ULONG       cbPublicKeyOrToken,
                LPCWSTR     szName,
                const ASSEMBLYMETADATA *pMetaData,
                const void  *pbHashValue,
                ULONG       cbHashValue,
                DWORD       dwAssemblyRefFlags);

    COR_IMPORT("CORwrap.dll", "???????????????????????")
    int     __stdcall SetFileProps(
                mdFile      file,
                const void  *pbHashValue,
                ULONG       cbHashValue,
                DWORD       dwFileFlags);

    COR_IMPORT("CORwrap.dll", "?????????????????????????????????")
    int     __stdcall SetExportedTypeProps(
                mdExportedType   ct,
                LPCWSTR     szDescription,
                mdToken     tkImplementation,
                mdTypeDef   tkTypeDef,
                DWORD       dwComTypeFlags);

#endif

};

struct  WMetaDataDispenser : WMetaData
{
    IMetaDataDispenser *imdd;

    COR_IMPORT("CORwrap.dll", "?DefineScope@WMetaDataDispenser@@QAGHPBU_GUID@@K0PAPAUWMetaDataEmit@@@Z")
    int     __stdcall   DefineScope(
                        const CLSID *       rclsid,
                        DWORD               dwCreateFlags,
                        const IID *         riid,
                        WMetaDataEmit   * * intfPtr);

    COR_IMPORT("CORwrap.dll", "?DefineAssem@WMetaDataDispenser@@QAGHPAUWMetaDataEmit@@PAPAUWAssemblyEmit@@@Z")
    int     __stdcall   DefineAssem(
                        WMetaDataEmit     * emitPtr,
                        WAssemblyEmit   * * intfPtr);

    COR_IMPORT("CORwrap.dll", "?OpenScope@WMetaDataDispenser@@QAGHPBGKPBU_GUID@@PAPAUWMetaDataImport@@@Z")
    int     __stdcall   OpenScope(
                        LPCWSTR             szScope,
                        DWORD               dwOpenFlags,
                        const IID *         riid,
                        WMetaDataImport * * intfPtr);

    COR_IMPORT("CORwrap.dll", "?OpenAssem@WMetaDataDispenser@@QAGHPBGKPBU_GUID@@PBDPAIPAPAEPAPAUWAssemblyImport@@@Z")
    int     __stdcall   OpenAssem(
                        LPCWSTR             szScope,
                        DWORD               dwOpenFlags,
                        const IID *         riid,
                        LPCSTR              szFileName,
                        mdAssembly        * assTok,
                        BYTE *            * cookiePtr,
                        WAssemblyImport * * intfPtr);

    COR_IMPORT("CORwrap.dll", "?TossAssem@WMetaDataDispenser@@QAGXPAE@Z")
    void    __stdcall   TossAssem(BYTE *cookie);
};

COR_IMPORT("CORwrap.dll", "?makeIMDDwrapper@@YGPAUWMetaDataDispenser@@PAUIMetaDataDispenser@@@Z")
WMetaDataDispenser     *__stdcall makeIMDDwrapper(IMetaDataDispenser *intf);
COR_IMPORT("CORwrap.dll", "?makeIMDIwrapper@@YGPAUWMetaDataImport@@PAUIMetaDataImport@@@Z")
WMetaDataImport        *__stdcall makeIMDIwrapper(IMetaDataImport    *intf);
COR_IMPORT("CORwrap.dll", "?makeIMDEwrapper@@YGPAUWMetaDataEmit@@PAUIMetaDataEmit@@@Z")
WMetaDataEmit          *__stdcall makeIMDEwrapper(IMetaDataEmit      *intf);

COR_IMPORT("CORwrap.dll", "?makeIASIwrapper@@YGPAUWAssemblyImport@@PAUIMetaDataAssemblyImport@@@Z")
WAssemblyImport        *__stdcall makeIASIwrapper(IMetaDataAssemblyImport *intf);
COR_IMPORT("CORwrap.dll", "?makeIASEwrapper@@YGPAUWAssemblyEmit@@PAUIMetaDataAssemblyEmit@@@Z")
WAssemblyEmit          *__stdcall makeIASEwrapper(IMetaDataAssemblyEmit   *intf);

COR_IMPORT("CORwrap.dll", "?makeSYMWwrapper@@YGPAUWSymWriter@@PAX@Z")
WSymWriter             *__stdcall makeSYMWwrapper(void               *intf);

COR_IMPORT("CORwrap.dll", "?uwrpIMDDwrapper@@YGPAUIMetaDataDispenser@@PAUWMetaDataDispenser@@@Z")
IMetaDataDispenser     *__stdcall uwrpIMDDwrapper(WMetaDataDispenser *inst);
COR_IMPORT("CORwrap.dll", "?uwrpIMDIwrapper@@YGPAUIMetaDataImport@@PAUWMetaDataImport@@@Z")
IMetaDataImport        *__stdcall uwrpIMDIwrapper(WMetaDataImport    *inst);
COR_IMPORT("CORwrap.dll", "?uwrpIMDEwrapper@@YGPAUIMetaDataEmit@@PAUWMetaDataEmit@@@Z")
IMetaDataEmit          *__stdcall uwrpIMDEwrapper(WMetaDataEmit      *inst);
COR_IMPORT("CORwrap.dll", "?uwrpIASEwrapper@@YGPAUIMetaDataAssemblyEmit@@PAUWAssemblyEmit@@@Z")
IMetaDataAssemblyEmit  *__stdcall uwrpIASEwrapper(WAssemblyEmit      *inst);
COR_IMPORT("CORwrap.dll", "?uwrpIASIwrapper@@YGPAUIMetaDataAssemblyImport@@PAUWAssemblyImport@@@Z")
IMetaDataAssemblyImport*__stdcall uwrpIASIwrapper(WAssemblyImport    *inst);

COR_IMPORT("CORwrap.dll", "?initializeIMD@@YGPAUWMetaDataDispenser@@XZ")
WMetaDataDispenser     *__stdcall initializeIMD();

/*****************************************************************************/

COR_IMPORT("CORwrap.dll", "?getIID_CorMetaDataRuntime@@YGPBU_GUID@@XZ")
const GUID *  __stdcall getIID_CorMetaDataRuntime();

COR_IMPORT("CORwrap.dll", "?getIID_IMetaDataImport@@YGPBU_GUID@@XZ")
const GUID *  __stdcall getIID_IMetaDataImport();
COR_IMPORT("CORwrap.dll", "?getIID_IMetaDataEmit@@YGPBU_GUID@@XZ")
const GUID *  __stdcall getIID_IMetaDataEmit();

COR_IMPORT("CORwrap.dll", "?getIID_IMetaDataAssemblyImport@@YGPBU_GUID@@XZ")
const GUID *  __stdcall getIID_IMetaDataAssemblyImport();
COR_IMPORT("CORwrap.dll", "?getIID_IMetaDataAssemblyEmit@@YGPBU_GUID@@XZ")
const GUID *  __stdcall getIID_IMetaDataAssemblyEmit();

/*****************************************************************************/

COR_IMPORT("CORwrap.dll","?WRAPPED_GetHashFromFileW@@YGJPBGPAIPAEKPAK@Z")
HRESULT       __stdcall WRAPPED_GetHashFromFileW(LPCWSTR   wszFilePath,
                                                 unsigned *iHashAlg,
                                                 BYTE     *pbHash,
                                                 DWORD     cchHash,
                                                 DWORD    *pchHash);

/*****************************************************************************/

COR_IMPORT("CORwrap.dll", "?WRAPPED_CorSigCompressData@@YGKKPAX@Z")
ULONG       __stdcall WRAPPED_CorSigCompressData         (ULONG           iLen,  void           *pDataOut);
COR_IMPORT("CORwrap.dll", "?WRAPPED_CorSigCompressToken@@YGKIPAX@Z")
ULONG       __stdcall WRAPPED_CorSigCompressToken        (mdToken         tk,    void           *pDataOut);
COR_IMPORT("CORwrap.dll", "?WRAPPED_CorSigUncompressSignedInt@@YGKPBEPAH@Z")
ULONG       __stdcall WRAPPED_CorSigUncompressSignedInt  (PCCOR_SIGNATURE pData, int            *pInt);
COR_IMPORT("CORwrap.dll", "?WRAPPED_CorSigUncompressData@@YGKPBEPAK@Z")
ULONG       __stdcall WRAPPED_CorSigUncompressData       (PCCOR_SIGNATURE pData, ULONG          *pDataOut);
COR_IMPORT("CORwrap.dll", "?WRAPPED_CorSigUncompressToken@@YGKPBEPAI@Z")
ULONG       __stdcall WRAPPED_CorSigUncompressToken      (PCCOR_SIGNATURE pData, mdToken        *pToken);
COR_IMPORT("CORwrap.dll", "?WRAPPED_CorSigUncompressElementType@@YGKPBEPAW4CorElementType@@@Z")
ULONG       __stdcall WRAPPED_CorSigUncompressElementType(PCCOR_SIGNATURE pData, CorElementType *pElementType);

/*****************************************************************************/

typedef IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT   CLS_EH_FAT;
typedef       COR_ILMETHOD_FAT                  COR_IM_FAT;

COR_IMPORT("CORwrap.dll", "?WRAPPED_SectEH_EHClause@@YGPAUIMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT@@PAXIPAU1@@Z")
CLS_EH_FAT* __stdcall WRAPPED_SectEH_EHClause(void *pSectEH, unsigned idx, CLS_EH_FAT* buff);

COR_IMPORT("CORwrap.dll", "?WRAPPED_SectEH_Emit@@YGIIIPAUIMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT@@HPAE@Z")
unsigned    __stdcall WRAPPED_SectEH_Emit(unsigned size, unsigned ehCount, CLS_EH_FAT* clauses, BOOL moreSections, BYTE* outBuff);

COR_IMPORT("CORwrap.dll", "?WRAPPED_SectEH_SizeExact@@YGIIPAUIMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT@@@Z")
unsigned    __stdcall WRAPPED_SectEH_SizeExact(unsigned ehCount, CLS_EH_FAT* clauses);

COR_IMPORT("CORwrap.dll", "?WRAPPED_IlmethodSize@@YGIPAUtagCOR_ILMETHOD_FAT@@H@Z")
unsigned    __stdcall WRAPPED_IlmethodSize(COR_IM_FAT* header, BOOL MoreSections);

COR_IMPORT("CORwrap.dll", "?WRAPPED_IlmethodEmit@@YGIIPAUtagCOR_ILMETHOD_FAT@@HPAE@Z")
unsigned    __stdcall WRAPPED_IlmethodEmit(unsigned size, COR_IM_FAT* header, BOOL moreSections, BYTE* outBuff);

/*****************************************************************************/
#undef  COR_IMPORT
/*****************************************************************************/
#endif//_CORWRAP_H
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\disasm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __disasm_h__
#define __disasm_h__

struct DumpStackFlag
{
    BOOL fEEonly;
    DWORD_PTR top;
    DWORD_PTR end;
};

void Unassembly (DWORD_PTR IPBegin, DWORD_PTR IPEnd);

void DumpStackDummy (DumpStackFlag &DSFlag);
void DumpStackSmart (DumpStackFlag &DSFlag);

void DumpStackObjectsHelper (size_t StackTop, size_t StackBottom);

void UnassemblyUnmanaged (DWORD_PTR IP);

BOOL GetCalleeSite (DWORD_PTR IP, DWORD_PTR &IPCallee);

BOOL CheckEEDll ();

void DisasmAndClean (DWORD_PTR &IP, char *line, ULONG length);

INT_PTR GetValueFromExpr(char *ptr, INT_PTR &value);

void NextTerm (char *& ptr);

BOOL IsByRef (char *& ptr);

BOOL IsTermSep (char ch);

const char * HelperFuncName (size_t IP);

#endif // __disasm_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\disasmia64.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include "disasm.h"
#ifndef UNDER_CE
#include <dbghelp.h>
#endif



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Unassembly a managed code.  Translating managed object,           *  
*    call.                                                             *
*                                                                      *
\**********************************************************************/
void Unassembly (DWORD_PTR IPBegin, DWORD_PTR IPEnd)
{
    dprintf("Unassembly not yet implemented\n");

    ULONG_PTR IP = IPBegin;
    char line[256];

    while (IP < IPEnd)
    {
        if (IsInterrupt())
            return;

        DisasmAndClean(IP, line, 256);

        dprintf(line);

        //
        // @TODO: need to implement this
        //

        dprintf("\n");
    }
}


void DumpStackDummy (DumpStackFlag &DSFlag)
{
    dprintf("DumpStackDummy not yet implemented\n");
}

void DumpStackSmart (DumpStackFlag &DSFlag)
{
    dprintf("DumpStackSmart not yet implemented\n");
}


void DumpStackObjectsHelper (size_t StackTop, size_t StackBottom)
{
    dprintf("DumpStackObjectsHelper not yet implemented\n");
}

// Find the real callee site.  Handle JMP instruction.
// Return TRUE if we get the address, FALSE if not.
BOOL GetCalleeSite (DWORD_PTR IP, DWORD_PTR &IPCallee)
{
    dprintf("GetCalleeSite not yet implemented\n");
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\disasmx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include "disasm.h"
#ifndef UNDER_CE
#include <dbghelp.h>
#endif




enum RegIndex {EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, EIP, NONE};
const int NumReg = NONE;
struct Register
{
    DWORD_PTR value;
    BOOL bValid;
    DWORD_PTR stack;
    BOOL bOnStack;
};

// Find the index for a register name
inline RegIndex FindReg (char *ptr)
{
    if (!strncmp (ptr, "eax", 3))
        return EAX;
    else if (!strncmp (ptr, "ebx", 3))
        return EBX;
    else if (!strncmp (ptr, "ecx", 3))
        return ECX;
    else if (!strncmp (ptr, "edx", 3))
        return EDX;
    else if (!strncmp (ptr, "esi", 3))
        return ESI;
    else if (!strncmp (ptr, "edi", 3))
        return EDI;
    else if (!strncmp (ptr, "ebp", 3))
        return EBP;
    else if (!strncmp (ptr, "esp", 3))
        return ESP;
    else
        return NONE;
}

// Find the value of an expression.
inline BOOL FindSrc (char *ptr, Register *reg, INT_PTR &value, BOOL &bDigit)
{
    if (GetValueFromExpr (ptr, value))
    {
        bDigit = TRUE;
        return TRUE;
    }
    
    BOOL bValid = FALSE;
    BOOL bByRef = IsByRef (ptr);
    bDigit = FALSE;

    RegIndex index = FindReg (ptr);
    if (index != NONE)
    {
        if (reg[index].bValid)
        {
            value = reg[index].value;
            ptr += 3;
            // TODO:  consider ecx+edi*4+0x4
            if ((IsTermSep (ptr[0]) && !bByRef)
                || (ptr[0] == ']' && bByRef))
            {
                bValid = TRUE;
                if (bByRef)
                    SafeReadMemory (value, &value, 4, NULL);
            }
        }
    }
    return bValid;
}


enum ADDRESSMODE {REG, DATA, INDIRECT, NODATA, BAD};

struct RegState
{
    RegIndex reg;
    BOOL bFullReg;
    char scale;
};

struct InstData
{
    ADDRESSMODE mode;
    RegState reg[2];
    INT_PTR value;
};

void FindMainReg (char *ptr, RegState &reg)
{
    reg.bFullReg = FALSE;
    if (ptr[0] == 'e' || ptr[0] == 'E')
    {
        reg.bFullReg = TRUE;
        ptr ++;
    }
    
    if (ptr[0] == 'a' || ptr[0] == 'A')
    {
        reg.reg = EAX;
        return;
    }
    else if (ptr[0] == 'c' || ptr[0] == 'C')
    {
        reg.reg = ECX;
        return;
    }
    else if (ptr[0] == 's' || ptr[0] == 'S')
    {
        reg.reg = (ptr[1] == 'p' || ptr[1] == 'P')? ESP: ESI;
        return;
    }
    else if (ptr[0] == 'd' || ptr[0] == 'D')
    {
        reg.reg = (ptr[1] == 'i' || ptr[1] == 'I')? EDI: EDX;
        return;
    }
    else if (ptr[0] == 'b' || ptr[0] == 'B')
    {
        reg.reg = (ptr[1] == 'p' || ptr[1] == 'P')? EBP: EBX;
        return;
    }
    else
    {
        reg.reg = NONE;
        return;
    }
}

static void DecodeAddressIndirect (char *term, InstData& arg)
{
    arg.mode = BAD;
    arg.value = 0;
    arg.reg[0].scale = 0;
    arg.reg[1].scale = 0;
    
    if (!IsByRef (term))
    {
        return;
    }
    
    // first part must be a reg
    arg.reg[0].scale = 1;
    if (term[0] == '+')
        term ++;
    else if (term[0] == '-')
    {
        term ++;
        arg.reg[0].scale = -1;
    }
    if (isdigit(term[0]))
    {
        arg.reg[0].scale *= term[0]-'0';
        term ++;
    }
    FindMainReg (term, arg.reg[0]);
    if (arg.reg[0].reg == NONE)
        return;
    if (arg.reg[0].bFullReg)
        term += 3;
    else
        term += 2;
    if (term[0] == ']')
    {
        // It is [reg]
        arg.mode = INDIRECT;
        arg.value = 0;
        return;
    }

    char sign = (char)((term[0] == '+')?1:-1);
    term ++;
    FindMainReg (term, arg.reg[1]);
    if (arg.reg[1].reg != NONE)
    {
        // It is either [reg+reg*c] or [reg+reg*c+c]
        if (arg.reg[1].bFullReg)
            term += 3;
        else
            term += 2;
        if (term[0] == '*')
        {
            term ++;
            arg.reg[1].scale = sign*(term[0]-'0');
            term ++;
        }
        else
            arg.reg[1].scale = sign;
    
        if (term[0] == ']')
        {
            // It is [reg+reg*c]
            arg.mode = INDIRECT;
            arg.value = 0;
            return;
        }
        sign = (char)((term[0] == '+')?1:-1);
        term ++;
    }
    
    char *endptr;
    arg.value = strtol(term, &endptr, 16);
    if (endptr[0] == ']')
    {
        // It is [reg+reg*c+c]
        arg.value *= sign;
        arg.mode = INDIRECT;
    }
}

void DecodeAddressTerm (char *term, InstData& arg)
{
    arg.mode = BAD;
    arg.reg[0].scale = 0;
    arg.reg[1].scale = 0;
    arg.value = 0;
    INT_PTR value;
    
    if (GetValueFromExpr (term, value))
    {
        arg.value = value;
        arg.mode = DATA;
    }
    else
    {
        FindMainReg (term, arg.reg[0]);
        if (arg.reg[0].reg != NONE)
        {
            arg.mode = REG;
        }
        else
        {
            DecodeAddressIndirect (term, arg);
        }
    }
}

static BOOL DecodeLine (char *line, char *inst, InstData& arg1, InstData& arg2)
{
    char *ptr = line;
    if (inst[0] == '*' || !strncmp (ptr, inst, strlen (inst)))
    {
        arg1.mode = BAD;
        arg2.mode = BAD;
        NextTerm (ptr);
        if (*ptr == '\0')
        {
            arg1.mode = NODATA;
            return TRUE;
        }

        DecodeAddressTerm (ptr, arg1);
        NextTerm (ptr);
        if (*ptr == '\0')
        {
            return TRUE;
        }
        DecodeAddressTerm (ptr, arg2);
        return TRUE;
    }
    else
        return FALSE;
}

// Return 0 for non-managed call.  Otherwise return MD address.
DWORD_PTR MDForCall (DWORD_PTR callee)
{
    // call managed code?
    JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR IP = callee;
    DWORD_PTR gcinfoAddr;

    if (!GetCalleeSite (callee, IP))
        return 0;

    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc)
    {
        return methodDesc;
    }

    // call stub
    char line[256];
    DisasmAndClean (IP, line, 256);
    char *ptr = line;
    NextTerm (ptr);
    NextTerm (ptr);
    if (!strncmp (ptr, "call ", 5)
        && IsMethodDesc (IP))
    {
        return IP;
    }
    else if (!strncmp (ptr, "jmp ", 4))
    {
        // For EJIT/debugger/profiler
        NextTerm (ptr);
        INT_PTR value;
        methodDesc = 0;
        if (GetValueFromExpr (ptr, value))
        {
            IP2MethodDesc (value, methodDesc, jitType, gcinfoAddr);
        }
        return methodDesc;
    }
    return 0;
}

// Handle a call instruction.
void HandleCall (DWORD_PTR callee)
{
    // call managed code?
    DWORD_PTR methodDesc = MDForCall (callee);
    if (methodDesc)
    {
        MethodDesc vMD;
        vMD.Fill (methodDesc);
        NameForMD (&vMD, g_mdName);
        ExtOut (" (%S)", g_mdName);
        return;
    }

    // call unmanaged code?
    char Symbol[1024];
    if (SUCCEEDED(g_ExtSymbols->GetNameByOffset(callee, Symbol, 1024,
                                                NULL, NULL)
        ))
    {
        if (Symbol[0] != '\0')
        {
            ExtOut (" (%s)", Symbol);
            return;
        }
    }

    // A JitHelper?
    const char* name = HelperFuncName(callee);
    if (name) {
        ExtOut (" (JitHelp: %s)", name);
    }
}

// Determine if a value is MT/MD/Obj
void HandleValue(DWORD_PTR value)
{
    // A MethodTable?
    if (IsMethodTable(value))
    {
        NameForMT (value, g_mdName);
        ExtOut (" (MT: %S)", g_mdName);
        return;
    }
    
    // A Managed Object?
    DWORD_PTR dwMTAddr;
    move (dwMTAddr, value);
    if (dwMTAddr == MTForString())
    {
        ExtOut (" (\"");
        StringObjectContent (value, TRUE);
        ExtOut ("\")");
        return;
    }
    else if (IsMethodTable(dwMTAddr))
    {
        NameForMT (dwMTAddr, g_mdName);
        ExtOut (" (Object: %S)", g_mdName);
        return;
    }
    
    // A MethodDesc?
    if (IsMethodDesc(value))
    {
        MethodDesc vMD;
        vMD.Fill(value);
        NameForMD (&vMD, g_mdName);
        ExtOut (" (MD: %S)", g_mdName);
        return;
    }

    // A JitHelper?
    const char* name = HelperFuncName(value);
    if (name) {
        ExtOut (" (JitHelp: %s)", name);
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Unassembly a managed code.  Translating managed object,           *  
*    call.                                                             *
*                                                                      *
\**********************************************************************/
void Unassembly (DWORD_PTR IPBegin, DWORD_PTR IPEnd)
{
    ULONG_PTR IP = IPBegin;
    char line[256];
    Register reg [NumReg];
    ZeroMemory (reg, sizeof(reg));
    RegIndex dest;
    INT_PTR value;
    BOOL bDigit;
    char *ptr;
    
    while (IP < IPEnd)
    {
        if (IsInterrupt())
            return;
        DisasmAndClean (IP, line, 256);
        ExtOut (line);
        // look at key word
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (!strncmp (ptr, "mov ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest != NONE)
            {
                NextTerm (ptr);
                if (FindSrc (ptr, reg, value, bDigit))
                {
                    reg[dest].bValid = TRUE;
                    reg[dest].value = value;
                    // Is it a managed obj
                    if (bDigit)
                        HandleValue (reg[dest].value);
                }
            }
        }
        else if (!strncmp (ptr, "call ", 5))
        {
            NextTerm (ptr);
            if (FindSrc (ptr, reg, value, bDigit))
            {
                HandleCall (value);
                // trash EAX, ECX, EDX
                reg[EAX].bValid = FALSE;
                reg[ECX].bValid = FALSE;
                reg[EDX].bValid = FALSE;
            }
        }
        else if (!strncmp (ptr, "lea ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest != NONE)
            {
                NextTerm (ptr);
                if (FindSrc (ptr, reg, value, bDigit))
                {
                    reg[dest].bValid = TRUE;
                    reg[dest].value = value;
                }
            }
        }
        else if (!strncmp (ptr, "push ", 5))
        {
            // do not do anything
            NextTerm (ptr);
            if (FindSrc (ptr, reg, value, bDigit))
            {
                if (bDigit)
                {
                    HandleValue (value);
                }
            }
        }
        else
        {
            // assume this instruction will trash dest reg
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest != NONE)
                reg[dest].bValid = FALSE;
        }
        ExtOut ("\n");
    }
}

// Return TRUE if we have printed something.
BOOL PrintCallInfo (DWORD_PTR vEBP, DWORD_PTR IP,
                    DumpStackFlag& DSFlag,
                    BOOL bSymbolOnly)
{
    char Symbol[1024];
    char filename[MAX_PATH+1];
    ULONG64 Displacement;
    BOOL bOutput = FALSE;

    DWORD_PTR methodDesc = FunctionType (IP);

    /*
    JitType jitType;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    */
    if (methodDesc > 1)
    {
        bOutput = TRUE;
        if (!bSymbolOnly)
            ExtOut ("%08x %08x ", vEBP, IP);
        ExtOut ("(MethodDesc %#x ", methodDesc);
        MethodDesc vMD;
        DWORD_PTR dwAddr = methodDesc;
        vMD.Fill (dwAddr);
        GetMDIPOffset (IP, &vMD, Displacement);
        if (Displacement != 0 && Displacement != -1)
            ExtOut ("+%#x ", Displacement);
        NameForMD (&vMD, g_mdName);
        ExtOut ("%S)", g_mdName);
    }
    else
    {
        if (!DSFlag.fEEonly)
        {
            bOutput = TRUE;
            const char *name;
            if (!bSymbolOnly)
                ExtOut ("%08x %08x ", vEBP, IP);
            if (methodDesc == 0) {
                HRESULT hr;
                hr = g_ExtSymbols->GetNameByOffset(IP, Symbol, 1024, NULL, &Displacement);
                if (SUCCEEDED(hr) && Symbol[0] != '\0')
                {
                    ExtOut ("%s", Symbol);
                    if (Displacement)
                        ExtOut ("+%#x", Displacement);
                    ULONG line;
                    hr = g_ExtSymbols->GetLineByOffset (IP, &line, filename,
                                                        MAX_PATH+1, NULL, NULL);
                    if (SUCCEEDED (hr))
                        ExtOut (" [%s:%d]", filename, line);
                }
            }
            else if (IsMethodDesc (IP))
            {
                DWORD_PTR dwAddr = IP;
                MethodDesc vMD;
                vMD.Fill (dwAddr);
                NameForMD (&vMD, g_mdName);
                dprintf (" (stub for %S)", g_mdName);
            }
            else if (IsMethodDesc (IP+5)) {
                DWORD_PTR dwAddr = IP+5;
                MethodDesc vMD;
                vMD.Fill (dwAddr);
                NameForMD (&vMD, g_mdName);
                dprintf ("%08x (MethodDesc %#x %S)", IP, IP+5, g_mdName);
            }
            else if ((name = HelperFuncName(IP)) != NULL) {
                ExtOut (" (JitHelp: %s)", name);
            }
            else
                ExtOut ("%08x", IP);
        }
    }
    return bOutput;
}

void ExpFuncStateInit (DWORD_PTR *IPRetAddr)
{
    ULONG64 offset;
    if (FAILED(g_ExtSymbols->GetOffsetByName("ntdll!KiUserExceptionDispatcher", &offset))) {
        return;
    }
    char            line[256];
    int i = 0;
    while (i < 3) {
        g_ExtControl->Disassemble (offset, 0, line, 256, NULL, &offset);
        if (strstr (line, "call")) {
            IPRetAddr[i++] = (DWORD_PTR)offset;
        }
    }
}

BOOL GetExceptionContext (DWORD_PTR stack, DWORD_PTR IP, DWORD_PTR *cxrAddr, PCONTEXT cxr,
                          DWORD_PTR *exrAddr, PEXCEPTION_RECORD exr)
{
    static DWORD_PTR IPRetAddr[3] = {0,0,0};

    if (IPRetAddr[0] == 0) {
        ExpFuncStateInit (IPRetAddr);
    }
    *cxrAddr = 0;
    *exrAddr = 0;
    if (IP == IPRetAddr[0]) {
        *exrAddr = stack + sizeof(DWORD_PTR);
        *cxrAddr = stack + 2*sizeof(DWORD_PTR);
    }
    else if (IP == IPRetAddr[1]) {
        *cxrAddr = stack + sizeof(DWORD_PTR);
    }
    else if (IP == IPRetAddr[2]) {
        *exrAddr = stack + sizeof(DWORD_PTR);
        *cxrAddr = stack + 2*sizeof(DWORD_PTR);
    }
    else
        return FALSE;

    if (FAILED (g_ExtData->ReadVirtual(*cxrAddr, &stack, sizeof(stack), NULL)))
        return FALSE;
    *cxrAddr = stack;

    size_t contextSize = offsetof(CONTEXT, ExtendedRegisters);
    //if ((pContext->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)
    //    contextSize += sizeof(pContext->ExtendedRegisters);
    if (FAILED (g_ExtData->ReadVirtual(stack, cxr, contextSize, NULL))) {
        return FALSE;
    }

    if (*exrAddr) {
        if (FAILED (g_ExtData->ReadVirtual(*exrAddr, &stack, sizeof(stack), NULL)))
        {
            *exrAddr = 0;
            return TRUE;
        }
        *exrAddr = stack;
        size_t erSize = offsetof (EXCEPTION_RECORD, ExceptionInformation);
        if (FAILED (g_ExtData->ReadVirtual(stack, exr, erSize, NULL))) {
            *exrAddr = 0;
            return TRUE;
        }
    }
    return TRUE;
}

void DumpStackDummy (DumpStackFlag &DSFlag)
{
    DWORD_PTR eip;
    ULONG64 Offset;
    g_ExtRegisters->GetInstructionOffset (&Offset);
    eip = (DWORD_PTR)Offset;
    
    ExtOut("Current frame: ");
    PrintCallInfo (0, eip, DSFlag, TRUE);
    ExtOut ("\n");

    DWORD_PTR ptr = DSFlag.top & ~3;  // make certain dword aligned
    ExtOut ("ChildEBP RetAddr  Caller,Callee\n");
    while (ptr < DSFlag.end)
    {
        if (IsInterrupt())
            return;
        DWORD_PTR retAddr;
        DWORD_PTR whereCalled;
        move (retAddr, ptr);
        isRetAddr(retAddr, &whereCalled);
        if (whereCalled)
        {
            BOOL bOutput = PrintCallInfo (ptr-4, retAddr, DSFlag, FALSE);
            if (!DSFlag.fEEonly)
            {
                if (whereCalled != 0xFFFFFFFF)
                {
                    ExtOut (", calling ");
                    PrintCallInfo (0, whereCalled, DSFlag, TRUE);
                }
            }
            if (bOutput)
                ExtOut ("\n");
            
            DWORD_PTR cxrAddr;
            CONTEXT cxr;
            DWORD_PTR exrAddr;
            EXCEPTION_RECORD exr;

            if (GetExceptionContext(ptr,retAddr,&cxrAddr,&cxr,&exrAddr,&exr)) {
                bOutput = PrintCallInfo (cxr.Esp,cxr.Eip,DSFlag, FALSE);
                if (bOutput) {
                    ExtOut (" ====> Exception ");
                    if (exrAddr)
                        ExtOut ("Code %x ", exr.ExceptionCode);
                    ExtOut ("cxr@%x", cxrAddr);
                    if (exrAddr)
                        ExtOut (" exr@%x", exrAddr);
                    ExtOut ("\n");
                }
            }
        }
        ptr += sizeof (DWORD_PTR);
    }
}

void DumpRegObjectHelper (const char *regName)
{
    ULONG IREG;
    DEBUG_VALUE value;
    DWORD_PTR reg;
    
    g_ExtRegisters->GetIndexByName(regName, &IREG);
    g_ExtRegisters->GetValue(IREG, &value);
    reg = value.I32;
    if (IsObject(reg)) {
        ExtOut ("%-8s %p ", regName, reg);
        DWORD_PTR mtAddr;
        move (mtAddr, reg);
        NameForMT (mtAddr,g_mdName);
        ExtOut ("%S", g_mdName);
        if (mtAddr == MTForString()) {
            ExtOut ("    ");
            StringObjectContent(reg, FALSE, 40);
        }
        ExtOut ("\n");
    }
}

void DumpStackObjectsHelper (size_t StackTop, size_t StackBottom)
{
    // Registers:ECX, EDX, ESI, EBX, EBP
    ExtOut ("ESP/REG  Object   Name\n");

    DumpRegObjectHelper ("eax");
    DumpRegObjectHelper ("ebx");
    DumpRegObjectHelper ("ecx");
    DumpRegObjectHelper ("edx");
    DumpRegObjectHelper ("esi");
    DumpRegObjectHelper ("edi");
    DumpRegObjectHelper ("ebp");

    DWORD_PTR ptr = StackTop & ~3;  // make certain dword aligned
    for (;ptr < StackBottom; ptr += sizeof(DWORD_PTR))
    {
        if (IsInterrupt())
            return;
        DWORD_PTR objAddr;
        move (objAddr, ptr);
        DWORD_PTR mtAddr;
        if (SUCCEEDED(g_ExtData->ReadVirtual((ULONG64)objAddr, &mtAddr, sizeof(mtAddr), NULL))) {
            if (IsMethodTable(mtAddr)) {
                ExtOut ("%p %p ", (ULONG64)ptr, (ULONG64)objAddr);
                NameForMT (mtAddr,g_mdName);
                ExtOut ("%S", g_mdName);
                if (mtAddr == MTForString()) {
                    ExtOut ("    ");
                    StringObjectContent(objAddr, FALSE, 40);
                }
                ExtOut ("\n");
            }
        }
    }
}


void PrintReg (Register *reg)
{
    ExtOut ("[EBX=%08x ESI=%08x EDI=%08x EBP=%08x ESP=%08x]\n",
             reg[EBX].value, reg[ESI].value, reg[EDI].value, reg[EBP].value,
             reg[ESP].value);
}


// Find the real callee site.  Handle JMP instruction.
// Return TRUE if we get the address, FALSE if not.
BOOL GetCalleeSite (DWORD_PTR IP, DWORD_PTR &IPCallee)
{
    char line[256];
    char *ptr;
    ULONG64 IPOrig = IP;
    ULONG64 vIP = IP;
    g_ExtControl->Disassemble (vIP, 0, line, 256, NULL, &vIP);
    IP = (DWORD_PTR)vIP;
    
    // remove the ending '\n'
    ptr = line;
    NextTerm (ptr);
    NextTerm (ptr);
    if (strncmp (ptr, "jmp", 3))
    {
        IPCallee = (DWORD_PTR)IPOrig;
        return TRUE;
    }
    // We have a jmp.
    NextTerm (ptr);
    INT_PTR target;
    if (GetValueFromExpr(ptr, target) == 0)
        return FALSE;
    else
        return GetCalleeSite (target, IPCallee);
}


// Find the number of bytes that ret will pop off stack
static BOOL FuncRetSizeDirect (DWORD_PTR IP, DWORD_PTR &retSize)
{
    retSize = 0;
    DWORD_PTR IPCallee;
    if (GetCalleeSite(IP, IPCallee))
    {
        if (IP != IPCallee)
            IP = IPCallee;
    }
    else
        return FALSE;
    
    // UnManaged Code?
    ULONG64 handle;
    g_ExtSystem->GetCurrentProcessHandle(&handle);
    PFPO_DATA data =
        (PFPO_DATA)SymFunctionTableAccess((HANDLE)handle, IP);
    if (data != NULL)
    {
        retSize = data->cdwParams * 4;
        return TRUE;
    }

    // Managed code?
    JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc)
    {
        MethodDesc MD;
        MD.Fill (methodDesc);
        CodeInfo infoHdr;
        CodeInfoForMethodDesc (MD, infoHdr, FALSE);
        if (infoHdr.IPBegin)
        {
            retSize = infoHdr.argCount;
            return TRUE;
        }
    }

    return FALSE;
}

static BOOL FuncRetSize (DWORD_PTR IP, DWORD_PTR &retSize)
{
    retSize = 0;
    
    DWORD_PTR IPCallee;
    if (GetCalleeSite(IP, IPCallee))
    {
        if (IP != IPCallee)
            IP = IPCallee;
    }
    else
    {
        // It is a jmp, but we can not determine the target
        return FALSE;
    }

    if (FuncRetSizeDirect (IP, retSize))
        return TRUE;
    
    if (IsMethodDesc (IP+5))
    {
        // We are calling a stub
        return FALSE;
    }
    
    // What left are our stub, or unmanaged code without debug info.
    DWORD_PTR IPNow = IP;
    char line[256];
    char *ptr;
    InstData arg1;
    InstData arg2;
        
    while (1)
    {
        DisasmAndClean (IPNow, line, 256);
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (DecodeLine (ptr, "ret", arg1, arg2))
        {
            if (arg1.mode == NODATA)
            {
                retSize = 0;
                return TRUE;
            }
            else if (arg1.mode == DATA)
            {
                retSize = arg1.value;
                return TRUE;
            }
            else
                return FALSE;
        }
    }

    return FALSE;
}

struct FrameRegInfo
{
    int Saved[NumReg];
    int Restored[NumReg];
};

// The only things that a call can change is ESP and EBP value,
// such as in _EH_prolog:
// push 0xff
// push eax
// mov eax,fs:[0]
// push eax
// mov eax,[esp+0xc]
// mov fs:[0],esp
// mov [esp+c],ebp
// lea ebp,[esp+0xc]
// push eax
// ret

// We will try to be conservative.
// If a line is using EBX/ESI/EDI except push, we are outside of Prolog.
// If a line is using EBP, we are also outside of Prolog.
BOOL TraceCall (DWORD_PTR IPBegin, INT_PTR& ESPChange)
{
    char line[256];
    char *ptr;
    DWORD_PTR IP;
    DWORD_PTR retSize;

    if (FuncRetSizeDirect (IPBegin, retSize))
    {
        ESPChange = retSize+4;  // Plus the ret address.
        return TRUE;
    }

    ESPChange = 0;
    if (!GetCalleeSite (IPBegin, IP))
        return FALSE;
    
    InstData arg1;
    InstData arg2;
    BOOL bCorrectStack = TRUE;
    
    while (1)
    {
        DisasmAndClean (IP, line, 256);
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (DecodeLine (ptr, "ret", arg1, arg2))
        {
            ESPChange += 4;
            if (arg1.mode == DATA)
                ESPChange += arg1.value;
            return bCorrectStack;
        }
        else if (DecodeLine (ptr, "sub ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
            {
                if (arg2.mode == DATA)
                    ESPChange -= arg1.value;
                else
                    bCorrectStack = FALSE;
            }
        }
        else if (DecodeLine (ptr, "add ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
            {
                if (arg2.mode == DATA)
                    ESPChange += arg1.value;
                else
                    bCorrectStack = FALSE;
            }
        }
        else if (DecodeLine (ptr, "and ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP
                && arg2.mode == DATA)
            {
                bCorrectStack = FALSE;

                // Be conservative.
                INT_PTR offset = 0;
                INT_PTR remain;
                remain = arg2.value;
                while (remain)
                {
                    offset = (offset << 8) + (0x100 - (remain & 0xff));
                    remain = remain >> 8;
                }
                ESPChange -= offset;
            }
        }
        else if (DecodeLine (ptr, "push ", arg1, arg2))
        {
            ESPChange -= 4;
        }
        else if (DecodeLine (ptr, "pop ", arg1, arg2))
        {
            ESPChange += 4;
        }
        else if (DecodeLine (ptr, "lea ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == EBP
                && arg2.mode == INDIRECT && arg2.reg[0].reg == ESP
                && arg2.reg[0].bFullReg && arg2.reg[0].scale == 1
                && arg2.reg[1].scale == 0)
            {
                ;//ESPChange += 4;
            }
        }
        else if (DecodeLine (ptr, "call ", arg1, arg2))
        {
            if (arg1.mode == DATA)
            {
                DWORD_PTR retSize;
                if (FuncRetSize (arg1.value, retSize))
                    ESPChange += retSize;
                else
                {
                    bCorrectStack = FALSE;
                }
            }
            else
            {
                // We lose track of stack.
                // consider ret only.
                bCorrectStack = FALSE;
            }
        }
        else if (DecodeLine (ptr, "*", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
                bCorrectStack = FALSE;
        }
    }
}

#if 0
DWORD_PTR UnmanagedFrameBase (HANDLE PFPO_DATA data,
                              Register *reg,
                              DWORD_PTR CurIP, DWORD_PTR IPBegin)
{
    char line[256];
    char *ptr;
    DWORD_PTR IP;
    if (data->cbFrame == FRAME_NONFPO)
    {
        // EBP Frame

        // Have we done "mov ebp, esp"?
        IP = IPBegin;
        BOOL fMOVEBPESP = FALSE;
        DWORD dwPush = 0;
        while (IP < CurIP && IP - IPBegin <= data->cbProlog)
        {
            DisasmAndClean (IP, line, 256);
            ptr = line;
            NextTerm (ptr);
            NextTerm (ptr);
            if (!strncmp (ptr, "mov ", 4))
            {
                NextTerm (ptr);
                if (!strncmp (ptr, "ebp", 3))
                {
                    NextTerm (ptr);
                    if (!strncmp (ptr, "esp", 3))
                    {
                        fMOVEBPESP = TRUE;
                        break;
                    }
                }
            }
            else if (!strncmp (ptr, "push ", 5))
                dwPush += 4;
            else if (!strncmp (ptr, "call ", 5))
            {
                NextTerm (ptr);
                DWORD_PTR value;
                if (GetValueFromExpr(ptr, value))
                    dwPush -= FuncRetSize (value);
                else
                    ExtOut ("Can not call the callee site\n");
            }
            else if (!strncmp (ptr, "sub ", 4))
            {
                NextTerm (ptr);
                if (!strncmp (ptr, "esp", 3))
                {
                    char *endptr;
                    DWORD_PTR value;
                    value = strtoul(ptr, &endptr, 16);
                    dwPush += value;
                }
            }
            else if (!strncmp (ptr, "add ", 4))
            {
                NextTerm (ptr);
                if (!strncmp (ptr, "esp", 3))
                {
                    char *endptr;
                    DWORD_PTR value;
                    value = strtoul(ptr, &endptr, 16);
                    dwPush -= value;
                }
            }
        }

        if (fMOVEBPESP)
        {
            return reg[EBP].value + dwPush;
        }
        else
        {
            return reg[ESP].value + dwPush;
        }
    }
    return -1;
}
#endif

struct CallInfo
{
    DWORD_PTR stackPos;
    DWORD_PTR retAddr;
    DWORD_PTR whereCalled;
};

// Search for a Return address on stack.
BOOL GetNextRetAddr (DWORD_PTR stackBegin, DWORD_PTR stackEnd,
                     CallInfo &callInfo)
{
    for (callInfo.stackPos = stackBegin;
         callInfo.stackPos <= stackEnd;
         callInfo.stackPos += 4)
    {
        if (!SafeReadMemory (callInfo.stackPos, &callInfo.retAddr, 4, NULL))
            continue;
        
        isRetAddr(callInfo.retAddr, &callInfo.whereCalled);
        if (callInfo.whereCalled)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

struct FrameInfo
{
    DWORD_PTR IPStart;
    DWORD_PTR Prolog;
    DWORD_PTR FrameBase;   // The value of ESP at the entry.
    DWORD_PTR StackEnd;
    DWORD_PTR argCount;
    BOOL bEBPFrame;
};

// if a EBP frame, return TRUE if EBP has been setup
void GetFrameBaseHelper (DWORD_PTR IPBegin, DWORD_PTR IPEnd,
                         INT_PTR &StackChange)
{
    char line[256];
    char *ptr;
    InstData arg1;
    InstData arg2;
    DWORD_PTR IP = IPBegin;
    StackChange = 0;
    while (IP < IPEnd)
    {
        DisasmAndClean (IP, line, 256);
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (DecodeLine (ptr, "push ", arg1, arg2))
        {
            StackChange += 4;
        }
        else if (DecodeLine (ptr, "pop ", arg1, arg2))
        {
            StackChange -= 4;
        }
        else if (DecodeLine (ptr, "sub ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
            {
                if (arg2.mode == DATA)
                    StackChange -= arg2.value;
            }
        }
        else if (DecodeLine (ptr, "add ", arg1, arg2))
        {
            if (arg1.mode == REG && arg1.reg[0].reg == ESP)
            {
                if (arg2.mode == DATA)
                    StackChange += arg2.value;
            }
        }
        else if (!strncmp (ptr, "ret", 3)) {
            return;
        }
    }
}

enum IPSTATE {IPPROLOG1 /*Before EBP set*/, IPPROLOG2 /*After EBP set*/, IPCODE, IPEPILOG, IPEND};

IPSTATE GetIpState (DWORD_PTR IP, FrameInfo* pFrame)
{
    char line[256];
    char *ptr;
    
    if (IP >= pFrame->IPStart && IP < pFrame->IPStart + pFrame->Prolog)
    {
        if (pFrame->bEBPFrame) {
            DWORD_PTR pIP = pFrame->IPStart;
            while (pIP < IP) {
                DisasmAndClean (IP,line, 256);
                ptr = line;
                NextTerm (ptr);
                NextTerm (ptr);
                if (!strncmp (ptr, "mov ", 4)) {
                    NextTerm (ptr);
                    if (!strncmp (ptr, "ebp", 3)) {
                        NextTerm (ptr);
                        if (!strncmp (ptr, "esp", 3)) {
                            return IPPROLOG2;
                        }
                    }
                }
                else if (!strncmp (ptr, "call ", 5)) {
                    NextTerm (ptr);
                    if (strstr (ptr, "__EH_prolog")) {
                        return IPPROLOG2;
                    }
                }
            }
            pIP = IP;
            while (pIP < pFrame->IPStart + pFrame->Prolog) {
                DisasmAndClean (IP,line, 256);
                ptr = line;
                NextTerm (ptr);
                NextTerm (ptr);
                if (!strncmp (ptr, "mov ", 4)) {
                    NextTerm (ptr);
                    if (!strncmp (ptr, "ebp", 3)) {
                        NextTerm (ptr);
                        if (!strncmp (ptr, "esp", 3)) {
                            return IPPROLOG1;
                        }
                    }
                }
                else if (!strncmp (ptr, "call ", 5)) {
                    NextTerm (ptr);
                    if (strstr (ptr, "__EH_prolog")) {
                        return IPPROLOG1;
                    }
                }
            }

            ExtOut ("Fail to find where EBP is saved\n");
            return IPPROLOG2;
        }
        else
        {
            return IPPROLOG1;
        }
    }
    
    int nline = 0;
    while (1) {
        DisasmAndClean (IP,line, 256);
        nline ++;
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (!strncmp (ptr, "ret", 3)) {
            return (nline==1)?IPEND:IPEPILOG;
        }
        else if (!strncmp (ptr, "leave", 5)) {
            return IPEPILOG;
        }
        else if (!strncmp (ptr, "call", 4)) {
            return IPCODE;
        }
        else if (ptr[0] == 'j') {
            return IPCODE;
        }
    }
}

// FrameBase is the ESP value at the entry of a function.
BOOL GetFrameBase (Register callee[], FrameInfo* pFrame)
{
    //char line[256];
    //char *ptr;
    INT_PTR dwpushed = 0;
    //DWORD_PTR IP;
    
    IPSTATE IpState = GetIpState (callee[EIP].value, pFrame);

    if (pFrame->bEBPFrame)
    {
        if (IpState == IPEND || IpState == IPPROLOG1) {
            pFrame->FrameBase = callee[ESP].value;
        }
        else
        {
            pFrame->FrameBase = callee[EBP].value+4;
        }
        return TRUE;
    }
    else
    {
        if (IpState == IPEND) {
            pFrame->FrameBase = callee[ESP].value;
            return TRUE;
        }

        DWORD_PTR IPBegin, IPEnd;
        if (IpState == IPEPILOG) {
            IPBegin = callee[EIP].value;
            IPEnd = -1;
        }
        else if (IpState == IPPROLOG1) {
            IPBegin = pFrame->IPStart;
            IPEnd = callee[EIP].value;
        }
        else
        {
            IPBegin = pFrame->IPStart;
            IPEnd = IPBegin + pFrame->Prolog;
        }
        GetFrameBaseHelper (IPBegin, IPEnd, dwpushed);

        if (IpState == IPEPILOG) {
            ExtOut ("stack %d\n", dwpushed);
            pFrame->FrameBase = callee[ESP].value - dwpushed;
            return TRUE;
        }

        CallInfo callInfo;
        if (GetNextRetAddr (callee[ESP].value + dwpushed,
                            pFrame->StackEnd, callInfo))
        {
            pFrame->FrameBase = callInfo.stackPos;
            return TRUE;
        }

        return FALSE;
    }
}

// caller[ESP]: the ESP value when we return to caller.
void RestoreCallerRegister (Register callee[], Register caller[],
                            FrameInfo *pFrame)
{
    if (pFrame->bEBPFrame)
    {
        if (callee[ESP].value < pFrame->FrameBase)
        {
            SafeReadMemory (pFrame->FrameBase-4, &caller[EBP].value, 4, NULL);
        }
        else
            caller[EBP].value = callee[EBP].value;
    }
    else
        caller[EBP].value = callee[EBP].value;
    
    caller[EBP].bValid = TRUE;
    caller[ESP].value = pFrame->FrameBase + 4 + pFrame->argCount;
    callee[EBP].value = pFrame->FrameBase - sizeof(void*);
    SafeReadMemory (pFrame->FrameBase, &caller[EIP].value, 4, NULL);
}

BOOL GetFrameInfoHelper (Register callee[], Register caller[],
                         FrameInfo *pFrame)
{
    if (GetFrameBase (callee, pFrame))
    {
        RestoreCallerRegister (callee, caller, pFrame);
        return TRUE;
    }
    else
        return FALSE;
}

// Return TRUE if Frame Info is OK, otherwise FALSE.
BOOL GetUnmanagedFrameInfo (Register callee[], Register caller[],
                            DumpStackFlag &DSFlag, PFPO_DATA data)
{
    FrameInfo Frame;
    ULONG64 base;
    g_ExtSymbols->GetModuleByOffset (callee[EIP].value, 0, NULL, &base);
    Frame.IPStart = data->ulOffStart + (ULONG_PTR)base;
    Frame.Prolog = data->cbProlog;
    // Why do we have to do this to make it work?
    if (Frame.Prolog == 1) {
        Frame.Prolog = 0;
    }
    Frame.bEBPFrame = (data->cbFrame == FRAME_NONFPO);
    Frame.StackEnd = DSFlag.end;
    Frame.argCount = data->cdwParams*4;

    return GetFrameInfoHelper (callee, caller, &Frame);
}

BOOL GetManagedFrameInfo (Register callee[], Register caller[],
                          DumpStackFlag &DSFlag, CodeInfo *pinfoHdr)
{
    FrameInfo Frame;
    Frame.IPStart = pinfoHdr->IPBegin;
    Frame.Prolog = pinfoHdr->prologSize;
    Frame.bEBPFrame = pinfoHdr->ebpFrame;
    Frame.StackEnd = DSFlag.end;
    Frame.argCount = pinfoHdr->argCount;
    
    return GetFrameInfoHelper (callee, caller, &Frame);
}

#if 0
class IPInfo
{
public:
private:
    struct Range {
        size_t begin;
        size_t end;
    };
    IPRange m_Range[8];
    IPRange *nextRange;
};
#endif

// offsetEBP: offset of stack position where EBP is saved.
// If EBP is not saved, *offsetEBP = -1;
BOOL IPReachable (DWORD_PTR IPBegin, DWORD_PTR IP, DWORD *offsetEBP)
{
    *offsetEBP = -1;
    return FALSE;
}
    
BOOL HandleEEStub (Register callee[], Register caller[], 
                   DumpStackFlag &DSFlag)
{
    // EEStub can only be called by IP directory.  Let's look for possible caller.
    CallInfo callInfo;
    DWORD_PTR stackPos = callee[ESP].value;
    while (stackPos < DSFlag.end) {
        if (GetNextRetAddr (stackPos,
                            DSFlag.end, callInfo))
        {
            if (callInfo.whereCalled != -1) {
                DWORD offsetEBP;
                if (IPReachable (callInfo.whereCalled, callee[EIP].value, &offsetEBP)) {
                    caller[EIP].value = callInfo.retAddr;
                    // TODO: We may have saved EBP.
                    if (offsetEBP == -1) {
                        caller[EBP].value = callee[EBP].value;
                    }
                    else
                        SafeReadMemory (callInfo.stackPos-sizeof(PVOID)-offsetEBP,&caller[EBP].value, sizeof(PVOID), NULL);
                    caller[ESP].value = callInfo.stackPos+sizeof(PVOID);
                    return TRUE;
                }
            }
            stackPos = callInfo.stackPos+sizeof(PVOID);
        }
        else
            return FALSE;
    }

    return FALSE;
}


BOOL HandleByEpilog (Register callee[], Register caller[], 
                    DumpStackFlag &DSFlag)
{
    return FALSE;
}



BOOL GetFrameInfo (Register callee[], Register caller[],
                   DumpStackFlag &DSFlag)
{
    size_t function = FunctionType (callee[EIP].value);

    if (function == 0) {
        ULONG64 handle;
        g_ExtSystem->GetCurrentProcessHandle(&handle);
        PFPO_DATA data =
            (PFPO_DATA)SymFunctionTableAccess((HANDLE)handle,
                                              callee[EIP].value);
        if (data)
            return GetUnmanagedFrameInfo (callee, caller, DSFlag, data);
        else
        {
            return HandleByEpilog (callee, caller, DSFlag);
        }
    }
    else if (function == 1) {
        // Stub
        if (IsMethodDesc (callee[EIP].value+5))
        {
            // We are about to call a Stub.
            memcpy (caller, callee, sizeof(Register)*NumReg);
            caller[ESP].value += 4;
            SafeReadMemory (callee[ESP].value, &caller[EIP].value, 4, NULL);
            return TRUE;
        }
        else if (IsMethodDesc (callee[EIP].value))
        {
            // We are calling a Stub.
            memcpy (caller, callee, sizeof(Register)*NumReg);
            caller[ESP].value += 8;
            SafeReadMemory (callee[ESP].value, &caller[EIP].value, 4, NULL);
            return TRUE;
        }
        else
        {
            // Stub
            return HandleEEStub (callee, caller, DSFlag);
        }
    }
    else
    {
        // Managed code
        DWORD_PTR methodDesc = function;
        MethodDesc MD;
        MD.Fill (methodDesc);
        CodeInfo infoHdr;
        CodeInfoForMethodDesc (MD, infoHdr, FALSE);
        if (infoHdr.IPBegin)
        {
            return GetManagedFrameInfo (callee, caller, DSFlag, &infoHdr);
        }
    }

    return FALSE;
}

void RestoreFrameUnmanaged (Register *reg, DWORD_PTR CurIP)
{
    char line[256];
    char *ptr;
    DWORD_PTR IP = CurIP;
    INT_PTR value;
    BOOL bDigit;
    BOOL bGoodESP = true;
    RegIndex dest;

    ULONG64 base;
    g_ExtSymbols->GetModuleByOffset (CurIP, 0, NULL, &base);
    ULONG64 handle;
    g_ExtSystem->GetCurrentProcessHandle(&handle);
    PFPO_DATA data =
        (PFPO_DATA)SymFunctionTableAccess((HANDLE)handle, CurIP);
    DWORD_PTR IPBegin = data->ulOffStart + (ULONG_PTR)base;

    if (CurIP - IPBegin <= data->cbProlog)
    {
        // We are inside a prolog.
        // See where we save the callee saved register.
        // Also how many DWORD's we pushd
        IP = IPBegin;
        reg[ESP].stack = 0;
        reg[ESP].bOnStack = FALSE;
        reg[EBP].stack = 0;
        reg[EBP].bOnStack = FALSE;
        reg[ESI].stack = 0;
        reg[ESI].bOnStack = FALSE;
        reg[EDI].stack = 0;
        reg[EDI].bOnStack = FALSE;
        reg[EBX].stack = 0;
        reg[EBX].bOnStack = FALSE;

        while (IP < CurIP)
        {
            DisasmAndClean (IP, line, 256);
            ptr = line;
            NextTerm (ptr);
            NextTerm (ptr);
            if (!strncmp (ptr, "push ", 5))
            {
                reg[ESP].stack += 4;
                NextTerm (ptr);
                dest = FindReg(ptr);
                if (dest == EBP || dest == EBX || dest == ESI || dest == EDI)
                {
                    reg[dest].bOnStack = TRUE;
                    reg[dest].stack = reg[ESP].stack;
                }
            }
            else if (!strncmp (ptr, "sub ", 4))
            {
                NextTerm (ptr);
                dest = FindReg(ptr);
                if (dest == ESP)
                {
                    NextTerm (ptr);
                    char *endptr;
                    DWORD_PTR value;
                    value = strtoul(ptr, &endptr, 16);
                    reg[ESP].stack += value;
                }
            }
        }
        
        DWORD_PTR baseESP = reg[ESP].value + reg[ESP].stack;
        if (reg[EBP].bOnStack)
        {
            move (reg[EBP].value, baseESP-reg[EBP].stack);
        }
        if (reg[EBX].bOnStack)
        {
            move (reg[EBX].value, baseESP-reg[EBX].stack);
        }
        if (reg[ESI].bOnStack)
        {
            move (reg[ESI].value, baseESP-reg[ESI].stack);
        }
        if (reg[EDI].bOnStack)
        {
            move (reg[EDI].value, baseESP-reg[EDI].stack);
        }
        move (reg[EIP].value, baseESP);
        reg[ESP].value = baseESP + 4;
        return;
    }

    if (data->cbFrame == FRAME_NONFPO)
    {
        // EBP Frame
    }
    
    // Look for epilog
    while (1)
    {
        DisasmAndClean (IP, line, 256);
        ptr = line;
        NextTerm (ptr);
        NextTerm (ptr);
        if (!strncmp (ptr, "mov ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest == ESP)
            {
                NextTerm (ptr);
                if (FindReg(ptr) == EBP)
                {
                    // We have a EBP frame
                    bGoodESP = true;
                    reg[ESP].value = reg[EBP].value;
                }
            }
        }
        else if (!strncmp (ptr, "ret", 3))
        {
            NextTerm (ptr);
            // check the value on stack is a return address.
            DWORD_PTR retAddr;
            DWORD_PTR whereCalled;
            move (retAddr, reg[ESP].value);
            int ESPAdjustCount = 0;
            while (1)
            {
                isRetAddr(retAddr, &whereCalled);
                if (whereCalled)
                    break;
                ESPAdjustCount ++;
                reg[ESP].value += 4;
                move (retAddr, reg[ESP].value);
            }
            reg[EIP].value = retAddr;
            if (ESPAdjustCount)
            {
                ESPAdjustCount *= 4;
            }
            if (reg[EBX].bOnStack)
            {
                reg[EBX].stack += ESPAdjustCount;
                move (reg[EBX].value, reg[EBX].stack);
            }
            if (reg[ESI].bOnStack)
            {
                reg[ESI].stack += ESPAdjustCount;
                move (reg[ESI].value, reg[EBX].stack);
            }
            if (reg[EDI].bOnStack)
            {
                reg[EDI].stack += ESPAdjustCount;
                move (reg[EDI].value, reg[EBX].stack);
            }
            
            reg[ESP].value += 4;
            if (ptr[0] != '\0')
            {
                FindSrc (ptr, reg, value, bDigit);
                reg[ESP].value += value;
            }
            break;
        }
        else if (!strncmp (ptr, "pop ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest == EBP || dest == EBX || dest == ESI || dest == EDI)
            {
                reg[dest].stack = reg[ESP].value;
                reg[dest].bOnStack = TRUE;
            }
            reg[ESP].value += 4;
        }
        else if (!strncmp (ptr, "add ", 4))
        {
            NextTerm (ptr);
            dest = FindReg(ptr);
            if (dest == ESP)
            {
                NextTerm (ptr);
                FindSrc (ptr, reg, value, bDigit);
                reg[ESP].value += value;
            }
        }
        else if (!strncmp (ptr, "call ", 5))
        {
            // assume we do not have a good value on ESP.
            // We could go into the call and find out number of pushed args.
            bGoodESP = FALSE;
        }
    }
    
    // Look for prolog
}

void DumpStackSmart (DumpStackFlag &DSFlag)
{
    DWORD_PTR ptr = DSFlag.top & ~3;  // make certain dword aligned

    Register callee[NumReg];
    Register caller[NumReg];
    ZeroMemory (callee, sizeof(callee));
    ZeroMemory (caller, sizeof(caller));

    ULONG IEBX;
    g_ExtRegisters->GetIndexByName("ebx", &IEBX);
    ULONG IESI;
    g_ExtRegisters->GetIndexByName("esi", &IESI);
    ULONG IEDI;
    g_ExtRegisters->GetIndexByName("edi", &IEDI);

    DEBUG_VALUE value;
    g_ExtRegisters->GetValue(IEBX, &value);
    callee[EBX].value = value.I32;

    g_ExtRegisters->GetValue(IEDI, &value);
    callee[EDI].value = value.I32;
    
    g_ExtRegisters->GetValue(IESI, &value);
    callee[ESI].value = value.I32;

    ULONG64 Offset;
    g_ExtRegisters->GetStackOffset (&Offset);
    callee[ESP].value = (DWORD_PTR)Offset;
    
    g_ExtRegisters->GetFrameOffset (&Offset);
    callee[EBP].value = (DWORD_PTR)Offset;

    g_ExtRegisters->GetInstructionOffset (&Offset);
    callee[EIP].value = (DWORD_PTR)Offset;

    ExtOut("Current frame: ");
    PrintCallInfo (0, callee[EIP].value, DSFlag, TRUE);
    ExtOut ("\n");
    ptr = caller[ESP].value;
    ExtOut ("ChildEBP RetAddr  Caller,Callee\n");
    BOOL fUseDumb = FALSE;
    while (ptr < DSFlag.end)
    {
        if (IsInterrupt())
            return;
        ExtOut ("EIP:%x EBP:%x ESP:%x -- ", callee[EIP].value, callee[EBP].value, callee[ESP].value);
        ExtOut ("EIP:%x EBP:%x ESP:%x\n", caller[EIP].value, caller[EBP].value, caller[ESP].value);
        if (!GetFrameInfo (callee, caller, DSFlag)) {
            fUseDumb = TRUE;
            DSFlag.top = callee[ESP].value;
            break;
        }
        ExtOut ("EIP:%x EBP:%x ESP:%x -- ", callee[EIP].value, callee[EBP].value, callee[ESP].value);
        ExtOut ("EIP:%x EBP:%x ESP:%x\n", caller[EIP].value, caller[EBP].value, caller[ESP].value);
        DWORD_PTR whereCalled;
        isRetAddr(caller[EIP].value, &whereCalled);
        if (whereCalled) {
            PrintCallInfo (callee[EBP].value, caller[EIP].value, DSFlag, FALSE);
            if (whereCalled != 0xFFFFFFFF) {
                ExtOut (", calling ");
                PrintCallInfo (0,whereCalled,DSFlag,TRUE);
            }
            ExtOut ("\n");
        }
        else
            break;
        memcpy (callee, caller, sizeof (caller));
        if (ptr >= caller[ESP].value) {
            break;
        }
        ptr = caller[ESP].value;
    }

    if (fUseDumb) {
        // TODO: Add back;
        // DumpStackDummy (DSFlag);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\dllsext.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "data.h"
#include "util.h"

#ifndef UNDER_CE

void DllsNameFromPeb(
    ULONG_PTR addrContaining,
    WCHAR *dllName
	)
{
    ULONG64 ProcessPeb;
    g_ExtSystem->GetCurrentProcessPeb (&ProcessPeb);

    ULONG64 pLdrEntry;
    ULONG64 PebLdrAddress;
    ULONG64 Next;
    ULONG64 OrderModuleListStart;
    
    //
    // Capture PebLdrData
    //

    static ULONG Offset_Ldr = -1;
    if (Offset_Ldr == -1)
    {
        ULONG TypeId;
        ULONG64 NtDllBase;
        if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName ("ntdll",0,NULL,
                                                           &NtDllBase))
            && SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "PEB", &TypeId)))
        {
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "Ldr", &Offset_Ldr)))
                Offset_Ldr = -1;
        }
    }
    // We can not get it from PDB.  Use the fixed one.
    if (Offset_Ldr == -1)
        Offset_Ldr = offsetof (PEB, Ldr);

    PEB peb;
    if (FAILED(g_ExtData->ReadVirtual(ProcessPeb+Offset_Ldr, &peb.Ldr,
                                      sizeof(peb.Ldr), NULL)))
    {
        ExtOut ( "    Unable to read PEB_LDR_DATA address at %p\n", (ULONG64)(ProcessPeb+Offset_Ldr));
        return;
    }

    PebLdrAddress = (ULONG64)peb.Ldr;
    
    //
    // Walk through the loaded module table and display all ldr data
    //

    static ULONG Offset_ModuleList = -1;
    if (Offset_ModuleList == -1)
    {
        ULONG TypeId;
        ULONG64 NtDllBase;
        if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName ("ntdll",0,NULL,
                                                           &NtDllBase))
            && SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "PEB_LDR_DATA",
                                                  &TypeId)))
        {
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "InMemoryOrderModuleList",
                                                     &Offset_ModuleList)))
                Offset_ModuleList = -1;
        }
    }
    // We can not get it from PDB.  Use the fixed one.
    if (Offset_ModuleList == -1)
        Offset_ModuleList = offsetof (PEB_LDR_DATA, InMemoryOrderModuleList);
    
    OrderModuleListStart = PebLdrAddress + Offset_ModuleList;
    PEB_LDR_DATA Ldr;
    if (FAILED(g_ExtData->ReadVirtual(OrderModuleListStart,
                                      &Ldr.InMemoryOrderModuleList,
                                      sizeof(Ldr.InMemoryOrderModuleList),
                                      NULL)))
    {
        ExtOut ( "    Unable to read InMemoryOrderModuleList address at %p\n", OrderModuleListStart);
        return;
    }
    Next = (ULONG64)Ldr.InMemoryOrderModuleList.Flink;

    static ULONG Offset_OrderLinks = -1;
    static ULONG Offset_FullDllName = -1;
    static ULONG Offset_DllBase = -1;
    static ULONG Offset_SizeOfImage = -1;
    if (Offset_OrderLinks == -1)
    {
        ULONG TypeId;
        ULONG64 NtDllBase;
        if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName ("ntdll",0,NULL,
                                                           &NtDllBase))
            && SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "LDR_DATA_TABLE_ENTRY",
                                                  &TypeId)))
        {
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "InMemoryOrderLinks",
                                                     &Offset_OrderLinks)))
                Offset_OrderLinks = -1;
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "FullDllName",
                                                     &Offset_FullDllName)))
                Offset_FullDllName = -1;
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "DllBase",
                                                     &Offset_DllBase)))
                Offset_DllBase = -1;
            if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                     "SizeOfImage",
                                                     &Offset_SizeOfImage)))
                Offset_SizeOfImage = -1;
        }
    }

    // We can not get it from PDB.  Use the fixed one.
    if (Offset_OrderLinks == -1 || Offset_OrderLinks == 0)
    {
        Offset_OrderLinks = offsetof (LDR_DATA_TABLE_ENTRY,
                                      InMemoryOrderLinks);
        Offset_FullDllName = offsetof (LDR_DATA_TABLE_ENTRY,
                                       FullDllName);
        Offset_DllBase = offsetof (LDR_DATA_TABLE_ENTRY,
                                   DllBase);
        Offset_SizeOfImage = offsetof (LDR_DATA_TABLE_ENTRY,
                                       SizeOfImage);
    }

    _UNICODE_STRING FullDllName;
    __try {
        while (Next != OrderModuleListStart) {
            if (IsInterrupt())
                return;
            
            pLdrEntry = Next - Offset_OrderLinks;
    
            //
            // Capture LdrEntry
            //
            if (FAILED(g_ExtData->ReadVirtual(pLdrEntry + Offset_FullDllName,
                                              &FullDllName,
                                              sizeof(FullDllName),
                                              NULL)))
            {
                ExtOut ( "    Unable to read FullDllName address at %p\n",
                         pLdrEntry + Offset_FullDllName);
                return;
            }
            ZeroMemory( dllName, MAX_PATH * sizeof (WCHAR) );
            if (FAILED(g_ExtData->ReadVirtual((ULONG64)FullDllName.Buffer,
                                              dllName,
                                              FullDllName.Length,
                                              NULL)))
            {
#if 0
                ExtOut ( "    Unable to read FullDllName.Buffer address at %p\n",
                         (ULONG64)FullDllName.Buffer);
#endif
                ZeroMemory( dllName, MAX_PATH * sizeof (WCHAR) );
            }
    
            //
            // Dump the ldr entry data
            // (dump all the entries if no containing address specified)
            //
            LDR_DATA_TABLE_ENTRY LdrEntry;
            if (SUCCEEDED(g_ExtData->ReadVirtual(pLdrEntry + Offset_DllBase,
                                                 &LdrEntry.DllBase,
                                                 sizeof(LdrEntry.DllBase),
                                                 NULL))
                &&
                SUCCEEDED(g_ExtData->ReadVirtual(pLdrEntry + Offset_SizeOfImage,
                                                 &LdrEntry.SizeOfImage,
                                                 sizeof(LdrEntry.SizeOfImage),
                                                 NULL))
                )
            {
                if (((ULONG_PTR)LdrEntry.DllBase <= addrContaining) &&
                    (addrContaining <= (ULONG_PTR)LdrEntry.DllBase + (ULONG_PTR)LdrEntry.SizeOfImage))
                    break;
            }
    
            ZeroMemory( dllName, MAX_PATH * sizeof (WCHAR) );
            if (FAILED(g_ExtData->ReadVirtual(pLdrEntry + Offset_OrderLinks,
                                              &LdrEntry.InMemoryOrderLinks,
                                              sizeof(LdrEntry.InMemoryOrderLinks),
                                              NULL)))
                break;
            
            Next = (ULONG64)LdrEntry.InMemoryOrderLinks.Flink;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        ExtOut ("exception during reading PEB\n");
        return;
    }
}

VOID
DllsName(
    ULONG_PTR addrContaining,
    WCHAR *dllName
    )
{
    dllName[0] = L'\0';
    
    ULONG Index;
    ULONG64 base;
    if (g_ExtSymbols->GetModuleByOffset(addrContaining, 0, &Index, &base) != S_OK)
        return;
    CHAR name[MAX_PATH+1];
    ULONG length;
    WCHAR wname[MAX_PATH+1] = L"\0";
    if (g_ExtSymbols->GetModuleNames(Index,base,name,MAX_PATH,&length,NULL,0,NULL,NULL,0,NULL) == S_OK)
    {
        MultiByteToWideChar (CP_ACP,0,name,-1,wname,MAX_PATH);
    }
    if (wcsrchr (wname, '\\') == NULL) {
        DllsNameFromPeb (addrContaining,wname);
    }

    MatchDllsName (wname, dllName, base);
}

VOID
MatchDllsName (WCHAR *wname, WCHAR *dllName, ULONG64 base)
{
    if (!IsDumpFile() && !IsKernelDebugger()) {
        if (FileExist(wname)) {
            wcscpy (dllName,wname);
            return;
        }
    }
    else
    {
        if (IsKernelDebugger() && DllPath == NULL) {
            ExtOut ("Path for managed Dll not set yet\n");
            goto NotFound;
        }
        
        WCHAR *wptr = wcsrchr (wname, '\\');
        
        if (wptr == NULL) {
            wptr = wname;
        }
        else
            wptr ++;
        
        if (wptr && DllPath == NULL) {
            if (FileExist(wname)) {
                wcscpy (dllName, wname);
                return;
            }
        }
        if (DllPath == NULL) {
            ExtOut ("Path for managed Dll not set yet\n");
            goto NotFound;
        }
        
        const WCHAR *path = DllPath->PathToDll(wptr);
    
        if (path) {
            wcscpy (dllName,path);
            wcscat (dllName,L"\\");
            wcscat (dllName,wptr);
            return;
        }
    }
    
NotFound:
    // We do not find the module
    wcscpy (dllName,L"Not Available: ");
    int len = wcslen (wname);
    WCHAR *wptr = wname;
    if (len > 200) {
        wptr += len-200;
    }
    wcscat (dllName, wptr);
    wptr = dllName + wcslen (dllName);

    wsprintfW (wptr, L" [Base %p]", base);
    return;
}
#else // UNDER_CE

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
DECLARE_API(Help);

VOID help(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    Help(NULL, NULL, NULL, NULL, NULL);
}

VOID
CheckVersion(
    VOID
    )
{
}

VOID WINAPI
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

BOOL WINAPI DllInit(HANDLE hModule, DWORD dwReason, DWORD dwReserved)
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            break;
        case DLL_PROCESS_ATTACH:
            break;
    }
    return TRUE;
}

#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\disasm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include "disasm.h"
#ifndef UNDER_CE
#include <dbghelp.h>
#endif

PVOID
GenOpenMapping(
    PCSTR FilePath,
    PULONG Size
    )
{
    HANDLE hFile;
    HANDLE hMappedFile;
    PVOID MappedFile;


    hFile = CreateFileA(
                FilePath,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
#if 0
    if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE ) {

        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED) {

            // We're on an OS that doesn't support Unicode
            // file operations.  Convert to ANSI and see if
            // that helps.
            
            CHAR FilePathA [ MAX_PATH + 10 ];

            if (WideCharToMultiByte (CP_ACP,
                                     0,
                                     FilePath,
                                     -1,
                                     FilePathA,
                                     sizeof (FilePathA),
                                     0,
                                     0
                                     ) > 0) {

                hFile = CreateFileA(FilePathA,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL
                                    );
            }
        }

        if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE ) {
            return NULL;
        }
    }
#endif

    *Size = GetFileSize(hFile, NULL);
    if (*Size == -1) {
        CloseHandle( hFile );
        return FALSE;
    }
    
    hMappedFile = CreateFileMapping (
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if ( !hMappedFile ) {
        CloseHandle ( hFile );
        return FALSE;
    }

    MappedFile = MapViewOfFile (
                        hMappedFile,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );

    CloseHandle (hMappedFile);
    CloseHandle (hFile);

    return MappedFile;
}

char* PrintOneLine (char *begin, char *limit)
{
    if (begin == NULL || begin >= limit) {
        return NULL;
    }
    char line[128];
    size_t length;
    char *end;
    while (1) {
        length = strlen (begin);
        end = strstr (begin, "\r\xa");
        if (end == NULL) {
            ExtOut ("%s", begin);
            end = begin+length+1;
            if (end >= limit) {
                return NULL;
            }
        }
        else {
            end += 2;
            length = end-begin;
            while (length) {
                size_t n = length;
                if (n > 127) {
                    n = 127;
                }
                strncpy (line, begin, n);
                line[n] = '\0';
                ExtOut ("%s", line);
                begin += n;
                length -= n;
            }
            return end;
        }
    }
}

void UnassemblyUnmanaged(DWORD_PTR IP)
{
    char            filename[MAX_PATH+1];
    char            line[256];
    int             lcount          = 10;

    ReloadSymbolWithLineInfo();

    ULONG linenum;
    ULONG64 Displacement;
    BOOL fLineAvailable;
    ULONG64 vIP;
    
    fLineAvailable = SUCCEEDED (g_ExtSymbols->GetLineByOffset (IP, &linenum,
                                                               filename,
                                                               MAX_PATH+1,
                                                               NULL,
                                                               &Displacement));
    ULONG FileLines = 0;
    ULONG64* Buffer = NULL;
    ToDestroyCxxArray<ULONG64> des0(&Buffer);

    if (fLineAvailable)
    {
        g_ExtSymbols->GetSourceFileLineOffsets (filename, NULL, 0, &FileLines);
        if (FileLines == 0xFFFFFFFF || FileLines == 0)
            fLineAvailable = FALSE;
    }

    if (fLineAvailable)
    {
        Buffer = new ULONG64[FileLines];
        if (Buffer == NULL)
            fLineAvailable = FALSE;
    }
    
    if (!fLineAvailable)
    {
        vIP = IP;
        // There is no line info.  Just disasm the code.
        while (lcount-- > 0)
        {
            if (IsInterrupt())
                return;
            g_ExtControl->Disassemble (vIP, 0, line, 256, NULL, &vIP);
            ExtOut (line);
        }
        return;
    }

    g_ExtSymbols->GetSourceFileLineOffsets (filename, Buffer, FileLines, NULL);
    
    int beginLine = 0;
    int endLine = 0;
    int lastLine;
    linenum --;
    for (lastLine = linenum; lastLine >= 0; lastLine --) {
        if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
            g_ExtSymbols->GetNameByOffset(Buffer[lastLine],NULL,0,NULL,&Displacement);
            if (Displacement == 0) {
                beginLine = lastLine;
                break;
            }
        }
    }
    if (lastLine < 0) {
        int n = lcount / 2;
        lastLine = linenum-1;
        beginLine = lastLine;
        while (lastLine >= 0) {
            if (IsInterrupt())
                return;
            if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
                beginLine = lastLine;
                n --;
                if (n == 0) {
                    break;
                }
            }
            lastLine --;
        }
    }
    while (beginLine > 0 && Buffer[beginLine-1] == DEBUG_INVALID_OFFSET) {
        beginLine --;
    }
    int endOfFunc = 0;
    for (lastLine = linenum+1; (ULONG)lastLine < FileLines; lastLine ++) {
        if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
            g_ExtSymbols->GetNameByOffset(Buffer[lastLine],NULL,0,NULL,&Displacement);
            if (Displacement == 0) {
                endLine = lastLine;
                break;
            }
            endOfFunc = lastLine;
        }
    }
    if ((ULONG)lastLine == FileLines) {
        int n = lcount / 2;
        lastLine = linenum+1;
        endLine = lastLine;
        while ((ULONG)lastLine < FileLines) {
            if (IsInterrupt())
                return;
            if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
                endLine = lastLine;
                n --;
                if (n == 0) {
                    break;
                }
            }
            lastLine ++;
        }
    }

    PVOID MappedBase = NULL;
    ULONG MappedSize = 0;

    class ToUnmap
    {
        PVOID *m_Base;
    public:
        ToUnmap (PVOID *base)
        :m_Base(base)
        {}
        ~ToUnmap ()
        {
            if (*m_Base) {
                UnmapViewOfFile (*m_Base);
                *m_Base = NULL;
            }
        }
    };
    ToUnmap toUnmap(&MappedBase);

#define MAX_SOURCE_PATH 1024
    char Found[MAX_SOURCE_PATH];
    char *pFile;
    if (g_ExtSymbols->FindSourceFile(0, filename,
                       DEBUG_FIND_SOURCE_BEST_MATCH |
                       DEBUG_FIND_SOURCE_FULL_PATH,
                       NULL, Found, sizeof(Found), NULL) != S_OK)
    {
        pFile = filename;
    }
    else
    {
        MappedBase = GenOpenMapping ( Found, &MappedSize );
        pFile = Found;
    }
    
    lastLine = beginLine;
    char *pFileCh = (char*)MappedBase;
    if (MappedBase) {
        ExtOut ("%s\n", pFile);
        int n = beginLine;
        while (n > 0) {
            while (!(pFileCh[0] == '\r' && pFileCh[1] == 0xa)) {
                pFileCh ++;
            }
            pFileCh += 2;
            n --;
        }
    }
    
    char filename1[MAX_PATH+1];
    for (lastLine = beginLine; lastLine < endLine; lastLine ++) {
        if (IsInterrupt())
            return;
        if (MappedBase) {
            ExtOut ("%4d ", lastLine+1);
            pFileCh = PrintOneLine (pFileCh, (char*)MappedBase+MappedSize);
        }
        if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
            if (MappedBase == 0) {
                ExtOut (">>> %s:%d\n", pFile, lastLine+1);
            }
            vIP = Buffer[lastLine];
            ULONG64 vNextLineIP;
            int i;
            for (i = lastLine + 1; (ULONG)i < FileLines && Buffer[i] == DEBUG_INVALID_OFFSET; i ++) {
                ;
            }
            if ((ULONG)i == FileLines) {
                vNextLineIP = 0;
            }
            else
                vNextLineIP = Buffer[i];
            while (1) {
                if (IsInterrupt())
                    return;
                g_ExtControl->Disassemble (vIP, 0, line, 256, NULL, &vIP);
                ExtOut (line);
                if (vIP > vNextLineIP || vNextLineIP - vIP > 40) {
                    if (FAILED (g_ExtSymbols->GetLineByOffset (vIP, &linenum,
                                                               filename1,
                                                               MAX_PATH+1,
                                                               NULL,
                                                               &Displacement))) {
                        if (lastLine != endOfFunc) {
                            break;
                        }
                        if (strstr (line, "ret") || strstr (line, "jmp")) {
                            break;
                        }
                    }

                    if (linenum != (ULONG)lastLine+1 || strcmp (filename, filename1)) {
                        break;
                    }
                }
                else if (vIP == vNextLineIP) {
                    break;
                }
            }
        }
    }
        
}


void DisasmAndClean (DWORD_PTR &IP, char *line, ULONG length)
{
    ULONG64 vIP = IP;
    g_ExtControl->Disassemble (vIP, 0, line, length, NULL, &vIP);
    IP = (DWORD_PTR)vIP;
    // remove the ending '\n'
    char *ptr = strrchr (line, '\n');
    if (ptr != NULL)
        ptr[0] = '\0';
}

// If byref, move to pass the byref prefix
BOOL IsByRef (char *& ptr)
{
    BOOL bByRef = FALSE;
    if (ptr[0] == '[')
    {
        bByRef = TRUE;
        ptr ++;
    }
    else if (!strncmp (ptr, "dword ptr [", 11))
    {
        bByRef = TRUE;
        ptr += 11;
    }
    return bByRef;
}

BOOL IsTermSep (char ch)
{
    return (ch == '\0' || isspace (ch) || ch == ',' || ch == '\n');
}

// Find next term. A term is seperated by space or ,
void NextTerm (char *& ptr)
{
    // If we have a byref, skip to ']'
    if (IsByRef (ptr))
    {
        while (ptr[0] != ']' && ptr[0] != '\0')
            ptr ++;
        if (ptr[0] == ']')
            ptr ++;
    }
    
    while (!IsTermSep (ptr[0]))
        ptr ++;
    while (IsTermSep(ptr[0]) && (*ptr != '\0'))
        ptr ++;
}

// only handle pure value, or memory address
INT_PTR GetValueFromExpr(char *ptr, INT_PTR &value)
{
    BOOL bNegative = FALSE;
    value = 0;
    char *myPtr = ptr;
    BOOL bByRef = IsByRef (myPtr);

    if (myPtr[0] == '-')
    {
        myPtr ++;
        bNegative = TRUE;
    }
    if (!strncmp (myPtr, "0x", 2) || isxdigit (myPtr[0]))
    {
        char *endptr;
        value = strtoul(myPtr, &endptr, 16);
        if ((IsTermSep (endptr[0]) && !bByRef)
            || (endptr[0] == ']' && bByRef))
        {
            if (bNegative)
                value = -value;
            ptr = endptr;
            if (bByRef)
            {
                ptr += 1;
                SafeReadMemory (value, &value, 4, NULL);
            }
            return ptr - myPtr;
        }
    }

    // handle mscorlib+0xed310 (6e24d310)
    if (!bByRef)
    {
        ptr = myPtr;
        while (ptr[0] != ' ' && ptr[0] != '+' && ptr[0] != '\0')
            ptr ++;
        if (ptr[0] == '+')
        {
            NextTerm (ptr);
            if (ptr[0] == '(')
            {
                ptr ++;
                char *endptr;
                value = strtoul(ptr, &endptr, 16);
                if (endptr[0] == ')')
                {
                    ptr ++;
                    return ptr - myPtr;
                }
            }
        }
    }
    if (bByRef)
    {
        // handle dword [mscorlib+0x2bd788 (02ead788)]
        ptr = myPtr;
        while (ptr[0] != '(' && ptr[0] != '\0')
            ptr ++;
        if (ptr[0] == '(')
        {
            ptr ++;
            char *endptr;
            value = strtoul(ptr, &endptr, 16);
            if (endptr[0] == ')' && endptr[1] == ']')
            {
                ptr = endptr + 2;
                SafeReadMemory (value, &value, 4, NULL);
                return ptr - myPtr;
            }
        }
    }
    return 0;
}

struct HelperFuncEntry
{
    char *name;
    size_t addr;
    size_t begin;
    size_t end;
    HelperFuncEntry ()
    : name(NULL), addr(0), begin(0), end(0)
    {}
};

class HelperFuncTable
{
public:
    HelperFuncTable ()
    : table (NULL), nEntry(0)
    {}
    ~HelperFuncTable ()
    {
        for (size_t i = 0; i < nEntry; i ++) {
            if (table[i].name) {
                free ((LPVOID)table[i].name);
            }
        }
        if (table) {
            delete [] table;
        }
    }
    const char *HelperFuncName (size_t IP);
private:
    HelperFuncEntry *table;
    size_t nEntry;

    void Init();
    void SetupAddr();
};

void HelperFuncTable::Init()
{
    if (nEntry == 0) {
        ULONG length = Get1DArrayLength ("hlpFuncTable");
        if (length == 0) {
            return;
        }
        DWORD_PTR hlpAddr = GetAddressOf(offset_class_Global_Variables,
            offset_member_Global_Variables::hlpFuncTable);
        if (hlpAddr == 0) {
            return;
        }
        size_t entrySize = VMHELPDEF::size();
        size_t bufferSize = length*entrySize;
        size_t *buffer = new size_t[bufferSize/sizeof(size_t)];
        if (buffer == NULL) {
            return;
        }
        ToDestroyCxxArray<size_t> des(&buffer);
        if (g_ExtData->ReadVirtual(hlpAddr,buffer,bufferSize,NULL) != S_OK) {
            return;
        }

        EEFLAVOR flavor = GetEEFlavor ();
        ULONG modIndex;
        g_ExtSymbols->GetModuleByOffset(moduleInfo[flavor].baseAddr,0,&modIndex,NULL);
        DEBUG_MODULE_PARAMETERS Params;
        g_ExtSymbols->GetModuleParameters(1,NULL,modIndex,&Params);
        
        size_t index = VMHELPDEF::GetFieldOffset
            (offset_member_VMHELPDEF::pfnHelper)/sizeof(size_t);
        size_t *pt = buffer + entrySize/sizeof(size_t);   // skip the first one
        size_t count = 0;
        size_t i;
        for (i = 1; i < length; i ++) {
            if (pt[index] < Params.Base || pt[index] > Params.Base + Params.Size) {
                count ++;
            }
            pt += entrySize/sizeof(size_t);
        }
        nEntry = count;
        table = new HelperFuncEntry[count];
        count = 0;
        pt = buffer + entrySize/sizeof(size_t);
        for (i = 1; i < length; i ++) {
            if (pt[index] < Params.Base || pt[index] > Params.Base + Params.Size) {
                table[count].addr = hlpAddr + i*entrySize + index*sizeof(size_t);
                table[count].begin = pt[index];
                // XXX: can we easily replace this for external builds?
                NameForEnumValue ("CorInfoHelpFunc", i, &table[count].name);
                count ++;
            }
            pt += entrySize/sizeof(size_t);
        }
    }

    SetupAddr();
}

void HelperFuncTable::SetupAddr()
{
    //if (!IsDebuggeeInNewState()) {
    //    return;
    //}
    for (size_t i = 0; i < nEntry; i ++) {
        if (table[i].addr == 0) {
            g_ExtData->ReadVirtual(table[i].addr, &table[i].begin,sizeof(table[i].begin),NULL);
        }
    }
}

const char *HelperFuncTable::HelperFuncName (size_t IP)
{
    Init();
    for (size_t i = 0; i < nEntry; i ++) {
        if (table[i].begin == IP) {
            const char *pt = table[i].name;
            if (pt) {
                pt += sizeof("CORINFO_HELP_")-1;
            }
            return pt;
        }
    }
    return NULL;
}

static HelperFuncTable s_HelperFuncTable;

const char * HelperFuncName (size_t IP)
{
    return s_HelperFuncTable.HelperFuncName(IP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\data.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __data_h__
#define __data_h__

#include "..\..\inc\cor.h"

BOOL FileExist (const char *filename);
BOOL FileExist (const WCHAR *filename);

enum JitType;

// We use global variables
// because move returns void if it fails
//typedef DWORD DWORD_PTR;
//typedef ULONG ULONG_PTR;

// Max length in WCHAR for a buffer to store metadata name
const int mdNameLen = 2048;
extern WCHAR g_mdName[mdNameLen];

const int nMDIMPORT = 128;
struct MDIMPORT
{
    WCHAR *name;
    IMetaDataImport *pImport;
    MDIMPORT *left;
    MDIMPORT *right;
};

class MDImportSet
{
    MDIMPORT *root;
public:
    MDImportSet()
        :root(NULL)
    {
    }
    ~MDImportSet()
    {
    }
    void Destroy();
    IMetaDataImport *GetImport(WCHAR *moduleName);
private:
    void DestroyInternal(MDIMPORT *node);
};

#ifdef _X86_

struct CodeInfo
{
    JitType jitType;
    DWORD_PTR IPBegin;
    unsigned methodSize;
    DWORD_PTR gcinfoAddr;
    unsigned char prologSize;
    unsigned char epilogStart;
    unsigned char epilogCount:3;
    unsigned char epilogAtEnd:1;
    unsigned char ediSaved   :1;
    unsigned char esiSaved   :1;
    unsigned char ebxSaved   :1;
    unsigned char ebpSaved   :1;
    unsigned char ebpFrame;
    unsigned short argCount;
};

#endif // _X86_

#ifdef _IA64_

struct CodeInfo
{
    JitType jitType;
    DWORD_PTR IPBegin;
    unsigned methodSize;
    DWORD_PTR gcinfoAddr;
    unsigned char prologSize;
    unsigned char epilogStart;
    unsigned char epilogCount:3;
    unsigned char epilogAtEnd:1;
//    unsigned char ediSaved   :1;
//    unsigned char esiSaved   :1;
//    unsigned char ebxSaved   :1;
//    unsigned char ebpSaved   :1;
//    unsigned char ebpFrame;
    unsigned short argCount;
};


#endif // _IA64_

extern MDImportSet mdImportSet;

extern DWORD_PTR EEManager;
extern BOOL ControlC;
extern IMetaDataDispenserEx *pDisp;

const int NumEEDllPath=8;
class EEDllPath
{
    WCHAR path[NumEEDllPath][MAX_PATH];
    EEDllPath *next;
public:
    EEDllPath ()
    {
        next = NULL;
        for (int i = 0; i < NumEEDllPath; i ++) {
            path[i][0] = L'\0';
        }
    }
    ~EEDllPath ()
    {
        if (next) {
            delete next;
        }
    }
    void AddPath (const WCHAR* str)
    {
        EEDllPath *ptr = this;
        while (ptr->next != NULL) {
            ptr = ptr->next;
        }
        for (int i = 0; i < NumEEDllPath; i ++) {
            if (ptr->path[i][0] == L'\0') {
                wcscpy (ptr->path[i], str);
                return;
            }
            else if (_wcsicmp (ptr->path[i],str) == 0) {
                return;
            }
        }
        if (ptr->next == NULL) {
            ptr->next = new EEDllPath;
        }
        ptr = ptr->next;
        wcscpy (ptr->path[0], str);
    }

    void AddPath (const char* str)
    {
		WCHAR path[MAX_PATH+1];
		MultiByteToWideChar (CP_ACP,0,str,-1,path,MAX_PATH);
		AddPath (path);
    }

    const WCHAR* PathToDll (const WCHAR* str)
    {
        EEDllPath *ptr = this;
        WCHAR filename[MAX_PATH+1];
        while (ptr) {
            for (int i = 0; i < NumEEDllPath; i ++) {
                if (ptr->path[i][0] == L'\0') {
                    return NULL;
                }
                wcscpy (filename, ptr->path[i]);
                wcscat (filename, L"\\");
                size_t n = wcslen (filename);
                wcsncat (filename, str, MAX_PATH-n);
                filename[MAX_PATH] = L'\0';
                if (FileExist (filename)) {
                    return ptr->path[i];
                }
            }
            ptr = ptr->next;
        }
        return NULL;
    }

    void DisplayPath ();

    void Reset ()
    {
        EEDllPath *ptr = this;
        while (ptr) {
            for (int i = 0; i < NumEEDllPath; i ++) {
                ptr->path[i][0] = L'\0';
            }
            ptr = ptr->next;
        }
    }
};

extern EEDllPath *DllPath;
#endif // __data_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\eeheap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "util.h"

void* operator new(size_t, void* p) 
{
    return p;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to update GC heap statistics.             *  
*                                                                      *
\**********************************************************************/
void HeapStat::Add(DWORD_PTR aMT, DWORD aSize)
{
    if (head == 0)
    {
        head = (Node*)malloc(sizeof(Node));
        if (head == NULL)
        {
            dprintf ("Not enough memory\n");
            ControlC = TRUE;
            return;
        }
        head = new (head) Node;
        head->MT = aMT;
    }
    Node *walk = head;
    while (walk->MT != aMT)
    {
        if (IsInterrupt())
            return;
        if (aMT < walk->MT)
        {
            if (walk->left == NULL)
                break;
            walk = walk->left;
        }
        else
        {
            if (walk->right == NULL)
                break;
            walk = walk->right;
        }
    }
    
    if (aMT == walk->MT)
    {
        walk->count ++;
        walk->totalSize += aSize;
    }
    else
    {
        Node *node = (Node*)malloc(sizeof(Node));
        if (node == NULL)
        {
            dprintf ("Not enough memory\n");
            ControlC = TRUE;
            return;
        }
        node = new (node) Node;
        node->MT = aMT;
        node->totalSize = aSize;
        node->count ++;
        
        if (aMT < walk->MT)
        {
            walk->left = node;
        }
        else
        {
            walk->right = node;
        }
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to sort all entries in the heap stat.     *  
*                                                                      *
\**********************************************************************/
void HeapStat::Sort ()
{
    Node *root = head;
    head = NULL;
    ReverseLeftMost (root);

    Node *sortRoot = NULL;
    while (head)
    {
        Node *tmp = head;
        head = head->left;
        if (tmp->right)
            ReverseLeftMost (tmp->right);
        // add tmp
        tmp->right = NULL;
        tmp->left = NULL;
        SortAdd (sortRoot, tmp);
    }
    head = sortRoot;

    // Change binary tree to a linear tree
    root = head;
    head = NULL;
    ReverseLeftMost (root);
    sortRoot = NULL;
    while (head)
    {
        Node *tmp = head;
        head = head->left;
        if (tmp->right)
            ReverseLeftMost (tmp->right);
        // add tmp
        tmp->right = NULL;
        tmp->left = NULL;
        LinearAdd (sortRoot, tmp);
    }
    head = sortRoot;

    //reverse the order
    root = head;
    head = NULL;
    sortRoot = NULL;
    while (root)
    {
        Node *tmp = root->right;
        root->left = NULL;
        root->right = NULL;
        LinearAdd (sortRoot, root);
        root = tmp;
    }
    head = sortRoot;
}

void HeapStat::ReverseLeftMost (Node *root)
{
    while (root)
    {
        Node *tmp = root->left;
        root->left = head;
        head = root;
        root = tmp;
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to help to sort heap stat.                *  
*                                                                      *
\**********************************************************************/
void HeapStat::SortAdd (Node *&root, Node *entry)
{
    if (root == NULL)
    {
        root = entry;
    }
    else
    {
        Node *parent = root;
        Node *ptr = root;
        while (ptr)
        {
            parent = ptr;
            if (ptr->totalSize < entry->totalSize)
                ptr = ptr->right;
            else
                ptr = ptr->left;
        }
        if (parent->totalSize < entry->totalSize)
            parent->right = entry;
        else
            parent->left = entry;
    }
}

void HeapStat::LinearAdd(Node *&root, Node *entry)
{
    if (root == NULL)
    {
        root = entry;
    }
    else
    {
        entry->right = root;
        root = entry;
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to print GC heap statistics.              *  
*                                                                      *
\**********************************************************************/
void HeapStat::Print()
{
    Node *root = head;
    int ncount = 0;
    while (root)
    {
        if (IsInterrupt())
            return;
        dprintf ("%8x %8d %9d ", root->MT, root->count, root->totalSize);
        ncount += root->count;
        if (root->MT == MTForFreeObj())
        {
            dprintf ("%9s\n","Free");
        }
        else
        {
            NameForMT (root->MT, g_mdName);
            dprintf ("%S\n", g_mdName);
        }
        root = root->right;
    }
    dprintf ("Total %d objects\n", ncount);
}

void HeapStat::Delete()
{
    Node *root = head;
    head = NULL;
    ReverseLeftMost (root);

    while (head)
    {
        Node *tmp = head;
        head = head->left;
        if (tmp->right)
            ReverseLeftMost (tmp->right);
        // free tmp
        free (tmp);
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Print the gc heap info.                                           *  
*                                                                      *
\**********************************************************************/
void GCHeapInfo(gc_heap &heap, DWORD_PTR &total_size)
{
    DWORD_PTR dwAddrSeg;
    heap_segment segment;
    int n;
    for (n = 0; n <= heap.g_max_generation; n ++)
    {
        if (IsInterrupt())
            return;
        dprintf ("generation %d starts at 0x%p\n",
                 n, (ULONG64)heap.generation_table[n].allocation_start);
    }
    dwAddrSeg = (DWORD_PTR)heap.generation_table[heap.g_max_generation].start_segment;

    dprintf (" segment    begin allocated     size\n");

    total_size = 0;
    n = 0;
    DWORD_PTR dwAddr;
    while (dwAddrSeg != (DWORD_PTR)heap.generation_table[0].start_segment)
    {
        if (IsInterrupt())
            return;
        dwAddr = dwAddrSeg;
        segment.Fill (dwAddr);
        dprintf ("%p %p  %p 0x%p(%d)\n", (ULONG64)dwAddrSeg,
                 (ULONG64)segment.mem, (ULONG64)segment.allocated,
                 (ULONG64)(segment.allocated - segment.mem),
                 segment.allocated - segment.mem);
        total_size += segment.allocated - segment.mem;
        dwAddrSeg = (DWORD_PTR)segment.next;
        n ++;
        if (n > 20)
            break;
    }

    dwAddr = (DWORD_PTR)heap.generation_table[0].start_segment;
    segment.Fill (dwAddr);
    //DWORD_PTR end = (DWORD_PTR)heap.generation_table[0].allocation_context.alloc_ptr;
    DWORD_PTR end = (DWORD_PTR)heap.alloc_allocated;
    dprintf ("%p %p  %p %p(%d)\n", (ULONG64)dwAddrSeg,
             (ULONG64)segment.mem, (ULONG64)end,
             (ULONG64)(end - (DWORD_PTR)segment.mem),
             end - (DWORD_PTR)segment.mem);
    
    total_size += end - (DWORD_PTR)segment.mem;
    dprintf ("Total Size  %#8x(%d)\n", total_size, total_size);
}


//Alignment constant for allocation
#ifdef _X86_
#define ALIGNCONST 3
#else
#define ALIGNCONST 7
#endif

static BOOL MemOverlap (DWORD_PTR beg1, DWORD_PTR end1,
                        DWORD_PTR beg2, DWORD_PTR end2)
{
    if (beg2 >= beg1 && beg2 <= end1)
        return TRUE;
    else if (end2 >= beg1 && end2 <= end1)
        return TRUE;
    else if (beg1 >= beg2 && beg1 <= end2)
        return TRUE;
    else if (end1 >= beg2 && end1 <= end2)
        return TRUE;
    else
        return FALSE;
}

#define plug_skew           sizeof(DWORD)
#define min_obj_size        (sizeof(BYTE*)+plug_skew+sizeof(size_t))
size_t Align (size_t nbytes)
{
    return (nbytes + ALIGNCONST) & ~ALIGNCONST;
}
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Dump objects on the gc heap.                                      *  
*                                                                      *
\**********************************************************************/
void GCHeapDump(gc_heap &heap, DWORD_PTR &nObj, DumpHeapFlags &flags,
                AllocInfo* pallocInfo)
{
    DWORD_PTR begin_youngest;
    DWORD_PTR end_youngest;    
    begin_youngest = (DWORD_PTR)heap.generation_table[0].allocation_start;
    DWORD_PTR dwAddr = (DWORD_PTR)heap.ephemeral_heap_segment;
    heap_segment segment;
    segment.Fill (dwAddr);
    end_youngest = (DWORD_PTR)heap.alloc_allocated;
    
    DWORD_PTR dwAddrSeg = (DWORD_PTR)heap.generation_table[2].start_segment;
    dwAddr = dwAddrSeg;
    segment.Fill (dwAddr);
    
    DWORD_PTR dwAddrCurrObj = (DWORD_PTR)heap.generation_table[2].allocation_start;
    if (flags.bFixRange) {
        dwAddrCurrObj = flags.startObject;
        DWORD_PTR end_of_segment = (DWORD_PTR)segment.allocated;
        if (dwAddrSeg == (DWORD_PTR)heap.ephemeral_heap_segment)
        {
            end_of_segment = end_youngest;
        }
        // Find the correct segment for this address.
        while (dwAddrCurrObj > end_of_segment || dwAddrCurrObj < dwAddrSeg) {
            dwAddrSeg = (DWORD_PTR)segment.next;
            if (dwAddrSeg)
            {
                dwAddr = dwAddrSeg;
                segment.Fill (dwAddr);
                
                if (dwAddrSeg == (DWORD_PTR)heap.ephemeral_heap_segment)
                {
                    end_of_segment = end_youngest;
                }
            }
            else
                return;
        }
    }

    size_t s;
    MethodTable vMethTable;
    DWORD_PTR dwAddrMethTable;
    nObj = 0;
    DWORD_PTR dwAddrPrevObj=0;

    while(1)
    {
        if (IsInterrupt())
            break;
        if (dwAddrCurrObj > flags.endObject)
            break;
        DWORD_PTR end_of_segment = (DWORD_PTR)segment.allocated;
        if (dwAddrSeg == (DWORD_PTR)heap.ephemeral_heap_segment)
        {
            end_of_segment = end_youngest;
            if (dwAddrCurrObj == end_youngest - Align(min_obj_size))
                break;
        }
        if (dwAddrCurrObj >= (DWORD_PTR)end_of_segment
            || !MemOverlap (flags.startObject, flags.endObject,
                            (DWORD_PTR)segment.mem,
                            (DWORD_PTR)end_of_segment))
        {
            if (dwAddrCurrObj > (DWORD_PTR)end_of_segment)
            {
                dprintf ("curr_object: %p > heap_segment_allocated (seg: %p)\n",
                         (ULONG64)dwAddrCurrObj, (ULONG64)dwAddrSeg);
                if (dwAddrPrevObj) {
                    dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
                }
                break;
            }
            dwAddrSeg = (DWORD_PTR)segment.next;
            if (dwAddrSeg)
            {
                dwAddr = dwAddrSeg;
                segment.Fill (dwAddrSeg);
                dwAddrCurrObj = (DWORD_PTR)segment.mem;
                continue;
            }
            else
                break;  // Done Verifying Heap
        }

        if (dwAddrSeg == (DWORD_PTR)heap.ephemeral_heap_segment
            && dwAddrCurrObj >= end_youngest)
        {
            if (dwAddrCurrObj > end_youngest)
            {
                // prev_object length is too long
                dprintf ("curr_object: %p > end_youngest: %p\n",
                         (ULONG64)dwAddrCurrObj, (ULONG64)end_youngest);
                if (dwAddrPrevObj) {
                    dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
                }
                break;
            }
            break;
        }

        move (dwAddrMethTable, dwAddrCurrObj);
        dwAddrMethTable = dwAddrMethTable & ~3;
        if (dwAddrMethTable == 0)
        {
            // Is this the beginning of an allocation context?
            int i;
            for (i = 0; i < pallocInfo->num; i ++)
            {
                if (dwAddrCurrObj == (DWORD_PTR)pallocInfo->array[i].alloc_ptr)
                {
                    dwAddrCurrObj =
                        (DWORD_PTR)pallocInfo->array[i].alloc_limit + Align(min_obj_size);
                    break;
                }
            }
            if (i < pallocInfo->num)
                continue;
        }
        if (dwAddrMethTable != MTForFreeObj() && !IsMethodTable (dwAddrMethTable))
        {
            dprintf ("Bad MethodTable for Obj at %p\n", (ULONG64)dwAddrCurrObj);
            if (dwAddrPrevObj) {
                dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
            }
            break;
        }
        DWORD_PTR dwAddrTmp = dwAddrMethTable;
        DWORD_PTR mtAddr = dwAddrTmp;
        vMethTable.Fill (dwAddrTmp);
        if (!CallStatus)
        {
            dprintf ("Fail to read MethodTable for Obj at %p\n", (ULONG64)dwAddrCurrObj);
            if (dwAddrPrevObj) {
                dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
            }
            break;
        }
        
        s = ObjectSize (dwAddrCurrObj);
        if (s == 0)
        {
            dprintf ("curr_object : %p size=0\n", (ULONG64)dwAddrCurrObj);
            if (dwAddrPrevObj) {
                dprintf ("Last good object: %p\n", (ULONG64)dwAddrPrevObj);
            }
            break;
        }
        if (dwAddrCurrObj >= flags.startObject &&
            dwAddrCurrObj <= flags.endObject
            && s > flags.min_size && s < flags.max_size
            && (flags.MT == 0 || flags.MT == mtAddr))
        {
            nObj ++;
            if (!flags.bStatOnly)
                dprintf ("%p %p %8d%s\n", (ULONG64)dwAddrCurrObj, (ULONG64)dwAddrMethTable, s,
                         (dwAddrMethTable==MTForFreeObj())?" Free":"");
            stat->Add (dwAddrMethTable, (DWORD)s);
        }
        s = (s + ALIGNCONST) & ~ALIGNCONST;
        dwAddrPrevObj = dwAddrCurrObj;
        dwAddrCurrObj += s;
    }
}

DWORD_PTR LoaderHeapInfo (LoaderHeap *pLoaderHeap)
{
    LoaderHeapBlock heapBlock;
    DWORD_PTR totalSize = 0;
    DWORD_PTR wastedSize = 0;
    DWORD_PTR heapAddr = (DWORD_PTR)pLoaderHeap->m_pFirstBlock;
    DWORD_PTR dwCurBlock = (DWORD_PTR)pLoaderHeap->m_pCurBlock;

    while (1)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR dwAddr = heapAddr;
        heapBlock.Fill (dwAddr);
        if (!CallStatus)
        {
            break;
        }
        DWORD_PTR curSize = 0;
        if (heapAddr != dwCurBlock)
        {
            DWORD_PTR dwAddr;
            char ch;
            for (dwAddr = (DWORD_PTR)heapBlock.pVirtualAddress;
                 dwAddr < (DWORD_PTR)heapBlock.pVirtualAddress
                     + heapBlock.dwVirtualSize;
                 dwAddr += OSPageSize())
            {
                if (IsInterrupt())
                    break;
                if (SafeReadMemory(dwAddr, &ch, sizeof(ch), NULL))
                {
                    curSize += OSPageSize();
                }
                else
                    break;
            }
            wastedSize += heapBlock.dwVirtualSize - curSize;
        }
        else
        {
            curSize =
                (DWORD_PTR)pLoaderHeap->m_pPtrToEndOfCommittedRegion
                - (DWORD_PTR)heapAddr;
        }
        
        totalSize += curSize;
        dprintf ("%p(%x", (ULONG64)heapBlock.pVirtualAddress,
                 heapBlock.dwVirtualSize);
        if (curSize != heapBlock.dwVirtualSize)
            dprintf (":%p", (ULONG64)curSize);
        dprintf (") ");

        heapAddr = (DWORD_PTR)heapBlock.pNext;
        if (heapAddr == 0)
        {
            dprintf ("\n");
            break;
        }
    }
    dprintf ("Size: 0x%p(%d) bytes.\n", (ULONG64)totalSize, totalSize);
    if (wastedSize)
        dprintf ("Wasted: 0x%p(%d) bytes.\n", (ULONG64)wastedSize, wastedSize);
    
    return totalSize;
}

DWORD_PTR JitHeapInfo ()
{
    // walk ExecutionManager__m_pJitList
    static DWORD_PTR dwJitListAddr = 0;
    if (dwJitListAddr == 0)
    {
        dwJitListAddr = GetAddressOf(offset_class_ExecutionManager, 
          offset_member_ExecutionManager::m_pJitList);
    }

    DWORD_PTR dwJitList;
    
    if (!SafeReadMemory(dwJitListAddr, &dwJitList, sizeof(DWORD_PTR), NULL))
    {
        return 0;
    }
    if (dwJitList == 0)
        return 0;

    EEJitManager vEEJitManager;
    IJitManager vIJitManager;
    DWORD_PTR totalSize = 0;
    while (dwJitList)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR vtbl;
        if (!SafeReadMemory(dwJitList, &vtbl, sizeof(DWORD_PTR), NULL))
        {
            break;
        }
        JitType jitType = GetJitType (vtbl);
        DWORD_PTR dwAddr = dwJitList;
        if (jitType == JIT)
        {
            vEEJitManager.Fill (dwAddr);
            dwJitList = (DWORD_PTR)vEEJitManager.m_next;
            dprintf ("Normal Jit:");
            HeapList vHeapList;
            LoaderHeap v_LoaderHeap;
            dwAddr = (DWORD_PTR)vEEJitManager.m_pCodeHeap;
            while (dwAddr)
            {
                if (IsInterrupt())
                    break;
                vHeapList.Fill (dwAddr);
                v_LoaderHeap.Fill (vHeapList.pHeap);
                totalSize += LoaderHeapInfo (&v_LoaderHeap);
                dwAddr = vHeapList.hpNext;
            }
        }
        else if (jitType == EJIT)
        {
            vIJitManager.Fill (dwAddr);
            dwJitList = (DWORD_PTR)vIJitManager.m_next;
            dprintf ("FJIT: ");
            dwAddr = GetAddressOf (offset_class_EconoJitManager,
              offset_member_EconoJitManager::m_CodeHeap);
            unsigned value;
            SafeReadMemory(dwAddr, &value, sizeof(unsigned), NULL);
            dprintf ("%x", value);
            dwAddr = GetAddressOf (offset_class_EconoJitManager,
              offset_member_EconoJitManager::m_CodeHeapCommittedSize);
            SafeReadMemory(dwAddr, &value, sizeof(unsigned), NULL);
            dprintf ("(%x)", value);
            dprintf ("\n");
            dprintf ("Size 0x%x(%d)bytes\n", value);
            totalSize += value;
        }
        else if (jitType == PJIT)
        {
            vIJitManager.Fill (dwAddr);
            dwJitList = (DWORD_PTR)vIJitManager.m_next;
        }
        else
        {
            dprintf ("Unknown Jit\n");
            break;
        }
    }
    dprintf ("Total size 0x%p(%d)bytes.\n", (ULONG64)totalSize, totalSize);
    return totalSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\exts.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "exts.h"

#define VER_PRODUCTVERSION_W        (0x0100)

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;

ULONG PageSize;

//
// Valid for the lifetime of the debug session.
//

ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass;


PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYMBOLS2       g_ExtSymbols2;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if (Client->QueryInterface(__uuidof(IDebugSymbols2), 
                                 (void **)&g_ExtSymbols2) != S_OK)
    {
        g_ExtSymbols2 = NULL;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 /*Argument*/)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                    DEBUG_DATA_MmPageSize, &Page,
                    sizeof(Page), NULL)) == S_OK)
                {
                    PageSize = (ULONG)(ULONG_PTR)Page;
                }

                DebugDataSpaces->Release();
            }
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &Qualifier)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        PageSize = 0;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE /*hModule*/,
    DWORD  dwReason,
    DWORD  /*dwReserved*/
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\eestructs.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include "get-table-info.h"

#ifdef _DEBUG
#include <assert.h>
#define _ASSERTE(a) assert(a)
#else
#define _ASSERTE(a)
#endif

#pragma warning(disable:4189)

/*
 * Bleh.
 *
 * We want to use Table Lookup for all things Strike, to eliminate PDB
 * requirements.
 *
 * To do so, we've replaced all uses of GetValueFromExpression to use
 * GetMemberInformation, which does a table lookup.
 *
 * However, to use the table lookup, we need to add classes to the table that
 * Strike previously didn't have stubbed-out classes for.  An example is the
 * Global_Variables class, which doesn't actually exist.  It's only there as a
 * holder for global variables.
 *
 * This is all well and good for generating indexes & the table, but we're
 * also using the same macros to generate the stubbed-out classes'
 * Fill functions.
 *
 * However, if we provide an implementation of the macros used in
 * ``inc/dump-types.h'', the compiler will require that a class declaration be
 * present for each class that we're generating a Fill function for, which
 * would include the aforementioned Global_Variables class (among others).
 *
 * Thus, we need to provide a class declaration for each class that's in
 * ``inc/dump-types.h'', but not present in "strikeEE.h" or "MiniEE.h".
 *
 * Additionally, an empty class prototype can't work because of
 * CDI_CLASS_MEMBER_OFFSET (and others), which references a member
 * variable.
 *
 * Thus, we need to provide dummy class declarations AND dummy class data 
 * for all classes that aren't present in "strikeEE.h", just to allow for an
 * automated implementation of Fill.
 */
#define BEGIN_DUMMY_CLASS(klass)                                    \
class klass {                                                       \
private:                                                            \
  DWORD_PTR m_vLoadAddr;                                            \
  ULONG_PTR GetFieldOffset (offset_member_ ## klass :: members f);  \
  SIZE_T size ();                                                   \
  void Fill (DWORD_PTR& dwStartAddr);

#define DUMMY_MEMBER(member) \
  void* member;

#define END_DUMMY_CLASS(klass) \
}; 

BEGIN_DUMMY_CLASS(EconoJitManager)
  DUMMY_MEMBER(m_CodeHeap)
  DUMMY_MEMBER(m_CodeHeapCommittedSize)
  DUMMY_MEMBER(m_JittedMethodInfoHdr)
  DUMMY_MEMBER(m_PcToMdMap)
  DUMMY_MEMBER(m_PcToMdMap_len)
END_DUMMY_CLASS(EconoJitManager)

BEGIN_DUMMY_CLASS(ExecutionManager)
  DUMMY_MEMBER(m_pJitList)
  DUMMY_MEMBER(m_RangeTree)
END_DUMMY_CLASS(ExecutionManager)

BEGIN_DUMMY_CLASS(Global_Variables)
  DUMMY_MEMBER(g_cHandleTableArray)
  DUMMY_MEMBER(g_DbgEnabled)
  DUMMY_MEMBER(g_HandleTableMap)
  DUMMY_MEMBER(g_pFreeObjectMethodTable)
  DUMMY_MEMBER(g_pHandleTableArray)
  DUMMY_MEMBER(g_pObjectClass)
  DUMMY_MEMBER(g_pRCWCleanupList)
  DUMMY_MEMBER(g_pStringClass)
  DUMMY_MEMBER(g_pSyncTable)
  DUMMY_MEMBER(g_pThreadStore)
  DUMMY_MEMBER(g_SyncBlockCacheInstance)
  DUMMY_MEMBER(QueueUserWorkItemCallback)
  DUMMY_MEMBER(hlpFuncTable)
  DUMMY_MEMBER(g_Version)
END_DUMMY_CLASS(Global_Variables)

BEGIN_DUMMY_CLASS(ThreadpoolMgr)
  DUMMY_MEMBER(cpuUtilization)
  DUMMY_MEMBER(NumWorkerThreads)
  DUMMY_MEMBER(NumRunningWorkerThreads)
  DUMMY_MEMBER(NumIdleWorkerThreads)
  DUMMY_MEMBER(MaxLimitTotalWorkerThreads)
  DUMMY_MEMBER(MinLimitTotalWorkerThreads)
  DUMMY_MEMBER(NumQueuedWorkRequests)
  DUMMY_MEMBER(AsyncCallbackCompletion)
  DUMMY_MEMBER(AsyncTimerCallbackCompletion)
  DUMMY_MEMBER(WorkRequestHead)
  DUMMY_MEMBER(WorkRequestTail)
  DUMMY_MEMBER(NumTimers)
  DUMMY_MEMBER(NumCPThreads)
  DUMMY_MEMBER(NumFreeCPThreads)
  DUMMY_MEMBER(MaxFreeCPThreads)
  DUMMY_MEMBER(CurrentLimitTotalCPThreads)
  DUMMY_MEMBER(MinLimitTotalCPThreads)
  DUMMY_MEMBER(MaxLimitTotalCPThreads)
END_DUMMY_CLASS(ThreadpoolMgr)

BEGIN_DUMMY_CLASS(GCHeap)
  DUMMY_MEMBER(FinalizerThread)
  DUMMY_MEMBER(GcThread)
END_DUMMY_CLASS(GCHeap)

BEGIN_DUMMY_CLASS(SystemNative)
  DUMMY_MEMBER(GetVersionString)
END_DUMMY_CLASS(SystemNative)

BEGIN_DUMMY_CLASS(TimerNative)
  DUMMY_MEMBER(timerDeleteWorkItem)
END_DUMMY_CLASS(TimerNative)

BEGIN_DUMMY_CLASS(PerfUtil)
  DUMMY_MEMBER(g_PerfAllocHeapInitialized)
  DUMMY_MEMBER(g_PerfAllocVariables)
END_DUMMY_CLASS(PerfUtil)


/*
 * We can provide an automated implementation of all the member functions by
 * providing a new implementation of the macros used in <dump-types.h>.
 */

#include <clear-class-dump-defs.h>

#define BEGIN_CLASS_DUMP_INFO(klass)                                  \
ULONG_PTR klass::GetFieldOffset(offset_member_ ## klass::members field)  \
{                                                                     \
    return GetMemberInformation(offset_class_ ## klass, field);       \
}                                                                     \
                                                                      \
SIZE_T klass::size()                                                  \
{                                                                     \
    return GetClassSize(offset_class_ ## klass);                      \
}                                                                     \
                                                                      \
void klass::Fill(DWORD_PTR& dwStartAddr)                              \
{                                                                     \
    _ASSERTE(dwStartAddr >= 0x1000);                                  \
    m_vLoadAddr = dwStartAddr;                                        \
    typedef offset_member_ ## klass _member_offsets;                  \
    const ULONG_PTR invalid = static_cast<ULONG_PTR>(-1);             \
    CallStatus = FALSE;                                               \
    _ASSERTE(size() > 0 || !"for class: " #klass);                    \
    ULONG_PTR moffset = 0; /* member offset */                        \
    if (size() > 0)                                                   \
      {

#define BEGIN_ABSTRACT_CLASS_DUMP_INFO(klass) BEGIN_CLASS_DUMP_INFO(klass)

#define BEGIN_CLASS_DUMP_INFO_DERIVED(klass, parent)                  \
ULONG_PTR klass::GetFieldOffset(offset_member_ ## klass::members field)  \
{                                                                     \
    return GetMemberInformation(offset_class_ ## klass, field);       \
}                                                                     \
                                                                      \
SIZE_T klass::size()                                                  \
{                                                                     \
    return GetClassSize(offset_class_ ## klass);                      \
}                                                                     \
                                                                      \
void klass::Fill(DWORD_PTR& dwStartAddr)                              \
{                                                                     \
    m_vLoadAddr = dwStartAddr;                                        \
    DWORD_PTR dwTmpStartAddr = dwStartAddr;                           \
    parent::Fill(dwTmpStartAddr);                                     \
    typedef offset_member_ ## klass _member_offsets;                  \
    const ULONG_PTR invalid = static_cast<ULONG_PTR>(-1);             \
    CallStatus = FALSE;                                               \
    _ASSERTE(size() > 0 || !"for class: " #klass);                    \
    ULONG_PTR moffset = 0; /* member offset */                        \
    if (size() > 0)                                                   \
      {

#define BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent)         \
    BEGIN_CLASS_DUMP_INFO_DERIVED(klass, parent)

/*
 * This is a kludge.  This is only a kludge.  But it works. ;-)
 *
 * The gc_heap class has static members on Workstation builds, and non-static
 * members on Server builds.  Yet they both have the same entry in the tables.
 * So how do we know which one it is?
 *
 * In Win32, processes can't access the first 4096 bytes of memory (Win 9x) or
 * the first 64 KB of memory (NT).  (Source: Advanced Windows, pg 116-121.)
 *
 * The liklihood of a runtime class being larger than 4096 is also very small,
 * unless we start implementing B-tree or some variant.
 *
 * Thus, we can say that any "address" larger than 4096 bytes is an absolute
 * address, while anything smaller is an offset.
 *
 * This isn't perfect, but it'll work for now, and it'll simplify the gc_heap
 * declaration in ``inc/dump-types.h''.
 *
 * @param base  The address of the beginning of the structure
 * @param offset  The offset of the structure member
 *
 * @return  If offset < 4096, base+offset.  Otherwise, offset.
 */
DWORD_PTR address (DWORD_PTR base, DWORD_PTR offset)
  {
  const DWORD_PTR max_offset = 0xFFF;
  if (offset < max_offset)
     return base + offset;
  return offset;
  }


/*
 * Some fields are class members on Server builds, and static members on
 * Workstation builds.  This macro is for those fields.
 * It automatically detects whether if's an address or an offset, and copies
 * the member appropriately.
 */
#define CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS(field)                 \
      if ((moffset = GetFieldOffset (_member_offsets::field))         \
          != invalid)                                                 \
        {                                                             \
        DWORD_PTR dwAddr = address (dwStartAddr, moffset);            \
        move (field, dwAddr);                                         \
        }


/*
 * The only member that uses this macro is gc_heap::generation_table.
 * This is why we assert that it's the correct field.
 *
 * If this changes in the future, we'll probably have to INJECT the Filling of
 * the generation_table array into ``inc/dump-tables.h''.
 */
#define CDI_CLASS_FIELD_SVR_OFFSET_WKS_GLOBAL(field)                  \
      _ASSERTE(strcmp("generation_table", #field) == 0);              \
      if ((moffset = GetFieldOffset (_member_offsets::field))         \
          != invalid)                                                 \
        {                                                             \
        DWORD_PTR dwAddr = address (dwStartAddr, moffset);            \
        for (int n = 0; n < NUMBERGENERATIONS; ++n)                   \
            field[n].Fill (dwAddr);                                   \
        }

#define CDI_CLASS_MEMBER_OFFSET(member)                               \
      if ((moffset = GetFieldOffset(_member_offsets :: member))       \
        != invalid)                                                   \
        move(member, dwStartAddr + moffset);                          \

#define CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(member)            \
      CDI_CLASS_MEMBER_OFFSET(member)

#define CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY(member)                    \
      if (IsDebugBuildEE() &&                                         \
        ((moffset = GetFieldOffset(_member_offsets::member))          \
         != invalid))                                                 \
        move(member, dwStartAddr + moffset);

#define CDI_CLASS_MEMBER_OFFSET_MH_AND_NIH_ONLY(member) \
      CDI_CLASS_MEMBER_OFFSET(member)

#define CDI_CLASS_MEMBER_OFFSET_BITFIELD(member, size)                \
      if ((moffset = GetFieldOffset(_member_offsets :: member))      \
        != invalid)                                                   \
        {                                                             \
        int csize = size/8;                                           \
        if ((size % 8) != 0)                                          \
           ++csize;                                                   \
        if (FAILED(g_ExtData->ReadVirtual (                           \
            (ULONG64)dwStartAddr+moffset,                             \
            ((unsigned char*)& member ## _begin) +                    \
            sizeof (member ## _begin),                                \
            csize, NULL)))                                            \
           return;                                                    \
        }

#define CDI_GLOBAL_ADDRESS(name) \
      if ((moffset = GetFieldOffset (_member_offsets::name)) != invalid) \
        move(name, moffset);

#define CDI_GLOBAL_ADDRESS_DEBUG_ONLY(name) \
      CDI_GLOBAL_ADDRESS(name)

#define CDI_CLASS_STATIC_ADDRESS(member)                              \
      moffset = GetFieldOffset (_member_offsets::member);             \
      if (moffset == invalid)                                         \
        moffset = 0;                                                  \
      move(member, moffset);

#define CDI_CLASS_STATIC_ADDRESS_PERF_TRACKING_ONLY(member)           \
      CDI_CLASS_STATIC_ADDRESS(member)

#define CDI_CLASS_STATIC_ADDRESS_MH_AND_NIH_ONLY(member) \
      CDI_CLASS_STATIC_ADDRESS(member)

#define FOR_STRIKE(m) m

#define CDI_CLASS_INJECT(member) member

#define END_CLASS_DUMP_INFO(klass)                                    \
      dwStartAddr += size ();                                         \
      CallStatus = TRUE;                                              \
      return;                                                         \
      }                                                               \
    move (*this, dwStartAddr);                                        \
    dwStartAddr += sizeof(*this);                                     \
    CallStatus = TRUE;                                                \
}

#define END_CLASS_DUMP_INFO_DERIVED(klass, parent) END_CLASS_DUMP_INFO(klass)
#define END_ABSTRACT_CLASS_DUMP_INFO(klass) END_CLASS_DUMP_INFO(klass)
#define END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent) END_CLASS_DUMP_INFO(klass)

/* we don't care about the table stuff. */
#define BEGIN_CLASS_DUMP_TABLE(name)
#define CDT_CLASS_ENTRY(klass)
#define END_CLASS_DUMP_TABLE(name)

/* do the magic */
#include <dump-types.h>

void MethodDesc::FillMdcAndSdi (DWORD_PTR& dwStartAddr)
{
    // DWORD_PTR dwAddr = dwStartAddr + g_pMDID->cbMD_IndexOffset;
    DWORD_PTR dwAddr = dwStartAddr + MD_IndexOffset();
    char ch;
    move (ch, dwAddr);
    dwAddr = dwStartAddr + ch * MethodDesc::ALIGNMENT + MD_SkewOffset();

    MethodDescChunk vMDChunk;
    vMDChunk.Fill(dwAddr);

    BYTE tokrange = vMDChunk.m_tokrange;
    dwAddr = dwStartAddr - METHOD_PREPAD;

    StubCallInstrs vStubCall;
    vStubCall.Fill(dwAddr);

    unsigned __int16 tokremainder = vStubCall.m_wTokenRemainder;
    m_dwToken = (tokrange << 16) | tokremainder;
    m_dwToken |= mdtMethodDef;

    GetMethodTable(dwStartAddr, m_MTAddr);
}


void MethodTable::FillVtableInit (DWORD_PTR& dwStartAddr)
{
    size_t o = GetFieldOffset (offset_member_MethodTable::m_Vtable);
    m_Vtable[0] = (SLOT)(dwStartAddr + o);
}


/* XXX: ArrayList: check to see if:
 *
        FILLCLASSMEMBER (offset, nEntry, m_count, dwStartAddr);

   is supposed to be the same as:
        ULONG value = 0;
        MEMBEROFFSET(offset, nEntry, "m_firstBlock", value);
        DWORD_PTR dwAddr = dwStartAddr + value;
        move (m_firstBlock, dwAddr);
 */


void *ArrayList::Get (DWORD index)
{
    ArrayListBlock* pBlock  = (ArrayListBlock*)malloc(sizeof(FirstArrayListBlock));
    SIZE_T          nEntries;
    SIZE_T          cbBlock;
    void*           pvReturnVal;
    DWORD_PTR       nextBlockAddr;

    memcpy (pBlock, &m_firstBlock, sizeof(FirstArrayListBlock));
    nEntries = pBlock->m_blockSize;

    while (index >= nEntries)
    {
        index -= nEntries;

        nextBlockAddr = (DWORD_PTR)(pBlock->m_next);
        if (!SafeReadMemory(nextBlockAddr, pBlock, sizeof(ArrayListBlock), NULL))
        {
            free(pBlock);
            return 0;
        }

        nEntries = pBlock->m_blockSize;
        cbBlock  = sizeof(ArrayListBlock) + ((nEntries-1) * sizeof(void*));
        free(pBlock);
        pBlock = (ArrayListBlock*)malloc(cbBlock);

        if (!SafeReadMemory(nextBlockAddr, pBlock, cbBlock, NULL))
        {
            free(pBlock);
            return 0;
        }
    }
    pvReturnVal = pBlock->m_array[index];
    free(pBlock);
    return pvReturnVal;
}

void EEJitManager::JitCode2MethodTokenAndOffset(DWORD_PTR ip, METHODTOKEN *pMethodToken, DWORD *pPCOffset)
{
    *pMethodToken = 0;
    *pPCOffset = 0;

    HeapList vHp;
    DWORD_PTR pHp = (DWORD_PTR) m_pCodeHeap;
    vHp.Fill(pHp);
    DWORD_PTR pCHdr = 0;

    while (1)
    {
        if (vHp.startAddress < ip && vHp.endAddress >= ip)
        {
            DWORD_PTR codeHead;
            FindHeader(vHp.pHdrMap, ip - vHp.mapBase, codeHead);
            pCHdr = codeHead + vHp.mapBase;
            break;
        }
        if (vHp.hpNext == 0)
            break;

        pHp = vHp.hpNext;
        vHp.Fill(pHp);
    }

    if (pCHdr == 0)
        return;

    *pMethodToken = (METHODTOKEN) pCHdr;
    *pPCOffset = (DWORD_PTR)(ip - GetCodeBody(pCHdr)); // @TODO - LBS pointer math
}


DWORD_PTR EEJitManager::JitToken2StartAddress(METHODTOKEN methodToken)
{
    if (methodToken)
        return GetCodeBody((DWORD_PTR)methodToken);
    return NULL;
}


void MNativeJitManager::JitCode2MethodTokenAndOffset(DWORD_PTR ip, METHODTOKEN *pMethodToken, DWORD *pPCOffset)
{
    *pMethodToken = 0;
    *pPCOffset = 0;

    DWORD_PTR codeHead;
    FindHeader (m_jitMan.m_RS.ptable, ip - m_jitMan.m_RS.LowAddress, codeHead);
    DWORD_PTR pCHdr = codeHead + m_jitMan.m_RS.LowAddress;
    CORCOMPILE_METHOD_HEADER head;
    head.Fill(pCHdr);

    DWORD_PTR methodStart = head.m_vLoadAddr + CORCOMPILE_METHOD_HEADER::size();

    *pMethodToken = (METHODTOKEN) methodStart;
    *pPCOffset = (DWORD)(ip - methodStart);
}


DWORD_PTR MNativeJitManager::JitToken2StartAddress(METHODTOKEN methodToken)
{
    return ((DWORD_PTR) methodToken);
}


bool Thread::InitRegDisplay(const PREGDISPLAY pRD, PCONTEXT pctx, bool validContext)
{
#ifdef _X86_
    if (!validContext)
    {
        if (GetFilterContext() != NULL)
        {
            safemove(m_debuggerWord1Ctx, GetFilterContext());
            pctx = &m_debuggerWord1Ctx;
        }
        else
        {
            pctx->ContextFlags = CONTEXT_FULL;


            HRESULT hr = g_ExtAdvanced->GetThreadContext((PVOID) pctx, sizeof(*pctx));
            if (FAILED(hr))
            {
                pctx->Eip = 0;
                pRD->pPC  = (SLOT*)&(pctx->Eip);

                return false;
            }
        }
    }

    pRD->pContext = pctx;

    pRD->pEdi = &(pctx->Edi);
    pRD->pEsi = &(pctx->Esi);
    pRD->pEbx = &(pctx->Ebx);
    pRD->pEbp = &(pctx->Ebp);
    pRD->pEax = &(pctx->Eax);
    pRD->pEcx = &(pctx->Ecx);
    pRD->pEdx = &(pctx->Edx);
    pRD->Esp = pctx->Esp;
    pRD->pPC  = (SLOT*)&(pctx->Eip);

    return true;

#else // !_X86_
    return false;
#endif // _X86_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\exts.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning(disable:4245)   // signed/unsigned mismatch
#pragma warning(disable:4100)   // unreferenced formal parameter
#pragma warning(disable:4201)   // nonstandard extension used : nameless struct/union
#pragma warning(disable:4127)   // conditional expression is constant
#include <wdbgexts.h>
#include <dbgeng.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MINIDUMP

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYMBOLS2       g_ExtSymbols2;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

// Normal output.
void __cdecl ExtOut(PCSTR Format, ...);
// Error output.
void __cdecl ExtErr(PCSTR Format, ...);
// Warning output.
void __cdecl ExtWarn(PCSTR Format, ...);
// Verbose output.
void __cdecl ExtVerb(PCSTR Format, ...);

extern BOOL ControlC;

inline BOOL IsInterrupt() 
{
    if (ControlC) {
        return ControlC;
    }
    if (g_ExtControl->GetInterrupt() == S_OK)
        ControlC = TRUE;
    return ControlC;
}
    
//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

class __ExtensionCleanUp
{
public:
    __ExtensionCleanUp(){}
    ~__ExtensionCleanUp(){ExtRelease();}
};
    
#define INIT_API()                                           \
    HRESULT Status;                                          \
    __ExtensionCleanUp __extensionCleanUp;                   \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;  \
    ControlC = FALSE;                                        \
    CheckEEDll ();
    

#define PAGE_ALIGN64(Va) ((ULONG64)((Va) & ~((ULONG64) ((LONG64) (LONG) PageSize - 1))))

extern ULONG PageSize;

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;

extern ULONG g_VDbgEng;

#define moveN(dst, src)\
{                                                                       \
    HRESULT ret = g_ExtData->ReadVirtual((ULONG64)src, &dst, sizeof(dst), NULL);  \
    if (FAILED(ret)) return ret;                                        \
}

#define moveBlockN(dst, src, size)\
{                                                                       \
    HRESULT ret = g_ExtData->ReadVirtual((ULONG64)src, &dst, size, NULL);         \
    if (FAILED(ret)) return ret;                                        \
}

#define move(dst, src)\
{                                                                       \
    HRESULT ret = g_ExtData->ReadVirtual((ULONG64)src, &dst, sizeof(dst), NULL);  \
    if (FAILED(ret)) return;                                            \
}

#define moveBlock(dst, src, size)\
{                                                                       \
    HRESULT ret = g_ExtData->ReadVirtual((ULONG64)src, &dst, size, NULL);         \
    if (FAILED(ret)) return;                                            \
}

#define moveBlockFailRet(dst, src, size, retVal)\
{                                                                       \
    HRESULT ret = g_ExtData->ReadVirtual((ULONG64)src, &dst, size, NULL);         \
    if (FAILED(ret)) return retVal;                                        \
}

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)

#ifndef UNDER_CE
#ifndef malloc
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef free
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif
#endif //!UNDER_CE

//-----------------------------------------------------------------------------------------
//
//  prototypes for internal non-exported support functions
//
//-----------------------------------------------------------------------------------------

/////////////////////////////////////////////
//
//  Util.c
//
/////////////////////////////////////////////

typedef VOID
(*PDUMP_SPLAY_NODE_FN)(
    ULONG64 RemoteAddress,
    ULONG   Level
    );

ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    );

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

ULONG
GetBitFieldOffset (
   IN LPSTR     Type, 
   IN LPSTR     Field, 
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   );

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    );

VOID
DumpUnicode(
    UNICODE_STRING u
    );

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    );


ULONG64
GetPointerValue (
    PCHAR String
    );

BOOLEAN
IsHexNumber(
   const char *szExpression
   );

BOOLEAN
IsDecNumber(
   const char *szExpression
   );

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    );

#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\eestructs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __eestructs_h__
#define __eestructs_h__

#ifdef STRIKE
#pragma warning(disable:4200)
#include "..\..\vm\specialstatics.h"
#pragma warning(default:4200)
#include "data.h"

#endif //STRIKE

#define volatile

#include "symbol.h"

#include <dump-type-info.h>

#ifdef STRIKE
#define DEFINE_STD_FILL_FUNCS(klass)                                                    \
    DWORD_PTR m_vLoadAddr;                                                              \
    void Fill(DWORD_PTR &dwStartAddr);                                                  \
    static ULONG GetFieldOffset(offset_member_ ## klass ## ::members field);            \
    static ULONG size();                                                                
//    virtual PWSTR GetFrameTypeName() { return L#klass; }
#else
#define DEFINE_STD_FILL_FUNCS(klass)                                                    \
    DWORD_PTR m_vLoadAddr;                                                              \
    void Fill(DWORD_PTR &dwStartAddr);
#endif    

    
#include "MiniEE.h"

#ifdef STRIKE
#include "strikeEE.h"
#endif

#endif  // __eestructs_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\gcroot.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"

#define _ASSERTE(a) {;}
#include "..\..\vm\gcdesc.h"

struct OBJSTATE
{
    enum ROOTSTATE {IsRoot, NotRoot, InProcess, Unknown};
};

static const int BITSIZE = sizeof(size_t)*8;
static const int BITWORD = sizeof(size_t);

// 1 bit corresponds to 4 byte (32bit platform).
// We use 2 bits to mark the state of an object: IsRoot/NotRoot/InProcess/Unknown
// since each object has at least 12 bytes.
class SegmentInfo
{
    size_t m_start;     // begin of a segment
    size_t m_end;       // end of a segment
    size_t*  m_bitMap;  // mask

public:
    SegmentInfo *m_next;    // for next segment on the gc heap

    SegmentInfo (size_t start, size_t end)
        : m_start(start), m_end(end)
    {
        m_next = NULL;
        size_t nelem = (end-start)/BITSIZE/BITWORD;
        if ((end-start)%(BITSIZE*sizeof(size_t))) {
            nelem ++;
        }
        m_bitMap = new size_t[nelem];
        memset (m_bitMap, 0, nelem*sizeof(size_t));
    }
    ~SegmentInfo ()
    {
        if (m_bitMap) {
            delete[] m_bitMap;
            m_bitMap = NULL;
        }
        if (m_next) {
            delete m_next;
            m_next = NULL;
        }
    }

    BOOL HasObject(size_t obj)
    {
        return obj >= m_start && obj <= m_end;
    }

    OBJSTATE::ROOTSTATE GetObjectState(size_t obj)
    {
        //assert (HasObject(obj));
        size_t offset = (obj - m_start)/BITWORD;
        size_t knownPos = offset/BITSIZE;
        size_t statePos = (offset+1)/BITSIZE;
        size_t knownOffset = offset%BITSIZE;
        size_t stateOffset = (offset+1)%BITSIZE;
        size_t knownMask = (size_t)(1<<knownOffset);
        size_t stateMask = (size_t)(1<<stateOffset);

        if (m_bitMap[knownPos] & knownMask) {
            if (m_bitMap[statePos] & stateMask) {
                return OBJSTATE::IsRoot;
            }
            else {
                return OBJSTATE::NotRoot;
            }
        }
        else
        {
            if (m_bitMap[statePos] & stateMask) {
                return OBJSTATE::InProcess;
            }
            else {
                return OBJSTATE::Unknown;
            }
        }
    }

    OBJSTATE::ROOTSTATE AddObject(size_t obj)
    {
        //assert (HasObject(obj));
        size_t offset = (obj - m_start)/BITWORD;
        size_t knownPos = offset/BITSIZE;
        size_t statePos = (offset+1)/BITSIZE;
        size_t knownOffset = offset%BITSIZE;
        size_t stateOffset = (offset+1)%BITSIZE;
        size_t knownMask = (size_t)(1<<knownOffset);
        size_t stateMask = (size_t)(1<<stateOffset);
        
        if (m_bitMap[knownPos] & knownMask) {
            if (m_bitMap[statePos] & stateMask) {
                return OBJSTATE::IsRoot;
            }
            else {
                return OBJSTATE::NotRoot;
            }
        }
        else
        {
            if (m_bitMap[statePos] & stateMask) {
                return OBJSTATE::InProcess;
            }
            else {
                m_bitMap[statePos] |= stateMask;
                return OBJSTATE::Unknown;
            }
        }
    }
    
    void MarkObject(size_t obj, BOOL fIsRoot)
    {
        // assert (HasObject(obj));
        size_t offset = (obj - m_start)/BITWORD;
        size_t knownPos = offset/BITSIZE;
        size_t statePos = (offset+1)/BITSIZE;
        size_t knownOffset = offset%BITSIZE;
        size_t stateOffset = (offset+1)%BITSIZE;
        size_t knownMask = (size_t)(1<<knownOffset);
        size_t stateMask = (size_t)(1<<stateOffset);
        
        m_bitMap[knownPos] |= knownMask;
        if (fIsRoot) {
            m_bitMap[statePos] |= stateMask;
        }
        else {
            m_bitMap[statePos] &= ~stateMask;
        }
    }

    void ResetObject(size_t obj)
    {
        // assert (HasObject(obj));
        size_t offset = (obj - m_start)/BITWORD;
        size_t knownPos = offset/BITSIZE;
        size_t statePos = (offset+1)/BITSIZE;
        size_t knownOffset = offset%BITSIZE;
        size_t stateOffset = (offset+1)%BITSIZE;
        size_t knownMask = (size_t)(1<<knownOffset);
        size_t stateMask = (size_t)(1<<stateOffset);
        
        m_bitMap[knownPos] &= ~knownMask;
        m_bitMap[statePos] &= ~stateMask;
    }

    void Reset()
    {
        size_t nelem = (m_end-m_start)/BITSIZE/BITWORD;
        if ((m_end-m_start)%(BITSIZE*sizeof(size_t))) {
            nelem ++;
        }
        memset (m_bitMap, 0, nelem*sizeof(size_t));
    }

    BOOL MatchRange (size_t start, size_t end)
    {
        return m_start == start && m_end == end;
    }
};

class GCRootInfo
{
public:

    GCRootInfo()
    {
        pSegmentInfo = NULL;
    }
    ~GCRootInfo()
    {
        if (pSegmentInfo) {
            delete pSegmentInfo;
            pSegmentInfo = NULL;
        }
    }
    void AddGCSegment(size_t start, size_t end)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return;
            if (walk->MatchRange(start, end)) {
                return;
            }
            walk = walk->m_next;
        }
        SegmentInfo *pSegInfo = new SegmentInfo (start, end);
        pSegInfo->m_next = pSegmentInfo;
        pSegmentInfo = pSegInfo;
    }

    void AddToLargeHeap(size_t obj, OBJSTATE::ROOTSTATE state)
    {
    }

    OBJSTATE::ROOTSTATE GetObjectState (size_t obj)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return OBJSTATE::InProcess;
            if (walk->HasObject(obj)) {
                break;
            }
            walk = walk->m_next;
        }

        if (walk) {
            return walk->GetObjectState(obj);
        } else {
            return OBJSTATE::InProcess;
        }
    }
    
    OBJSTATE::ROOTSTATE AddObject (size_t obj)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return OBJSTATE::InProcess;
            if (walk->HasObject(obj)) {
                break;
            }
            walk = walk->m_next;
        }

        if (walk) {
            return walk->AddObject(obj);
        } else {
            return OBJSTATE::InProcess;
        }
    }

    void MarkObject (size_t obj, BOOL fIsRoot)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return;
            if (walk->HasObject(obj)) {
                break;
            }
            walk = walk->m_next;
        }

        if (walk) {
            walk->MarkObject(obj, fIsRoot);
        }
    }

    BOOL HasObject (size_t obj)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return FALSE;
            if (walk->HasObject(obj)) {
                return TRUE;
            }
            walk = walk->m_next;
        }

        return FALSE;
    }

    void ResetObject (size_t obj)
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return;
            if (walk->HasObject(obj)) {
                break;
            }
            walk = walk->m_next;
        }

        if (walk) {
            walk->ResetObject(obj);
        }
    }

    void Reset ()
    {
        SegmentInfo *walk = pSegmentInfo;
        while (walk) {
            if (IsInterrupt())
                return;
            walk->Reset();
            walk = walk->m_next;
        }
    }

    void Release ()
    {
        if (pSegmentInfo) {
            delete pSegmentInfo;
            pSegmentInfo = NULL;
        }
    }

private:
    SegmentInfo *pSegmentInfo;
};

GCRootInfo gcRootInfo;

class Entry
{
    size_t m_obj;
    DWORD index;
    DWORD length;
    OBJSTATE::ROOTSTATE state;
    size_t *member;
public:
    Entry()
    {
        m_obj = 0;
        index = 0;
        length = 0;
        state = OBJSTATE::Unknown;
        member = NULL;
    }
    ~Entry()
    {
        if (member) {
            delete [] member;
        }
        member = NULL;
    }
    
    void SetObject (size_t obj)
    {
        m_obj = obj;
    }

    size_t GetObject ()
    {
        return m_obj;
    }

    DWORD NumberOfMember ()
    {
        return index;
    }

    size_t PopMember ()
    {
        if (index > 0) {
            index --;
            return member[index];
        }
        else
            return 0;
    }

    size_t LastMember ()
    {
        if (index == 0) {
            return 0;
        }
        else
            return member[index-1];
    }

    void PushMember (size_t obj)
    {
        if (member == NULL) {
            length = 10;
            member = new size_t[length];
        }
        else if (index == length) {
            length += 10;
            size_t *tmp = new size_t[length];
            memcpy (tmp, member, index*sizeof(size_t));
            delete [] member;
            member = tmp;
        }
        member[index++] = obj;
    }

    void Reset()
    {
        if (member)
        {
            for (size_t i = 0; i < index; i ++) {
                gcRootInfo.ResetObject(member[i]);
            }
            delete [] member;
        }
        member = NULL;
        m_obj = 0;
        index = 0;
        length = 0;
        state = OBJSTATE::Unknown;
    }
    void SetState (BOOL bIsRoot)
    {
        if (bIsRoot) {
            state = OBJSTATE::IsRoot;
        }
        else
            state = OBJSTATE::NotRoot;
    }

    OBJSTATE::ROOTSTATE GetState ()
    {
        return state;
    }
};

#define plug_skew           sizeof(DWORD)   // syncblock size. 


void GetListOfRefs (Entry *pEntry)
{
    DWORD_PTR dwAddr;
    size_t obj = pEntry->GetObject();
    OBJSTATE::ROOTSTATE state = gcRootInfo.GetObjectState(obj);
    if (state == OBJSTATE::IsRoot) {
        pEntry->SetState(TRUE);
        return;
    }
    else if (state == OBJSTATE::NotRoot) {
        pEntry->SetState(FALSE);
        return;
    }
    move (dwAddr, obj);

    if (dwAddr == MTForString()) {
        return;
    }

    static int MT_wFlagsOffset = 0x7fffffff;
    if (MT_wFlagsOffset == 0x7fffffff)
    {
        MT_wFlagsOffset = 
          MethodTable::GetFieldOffset(offset_member_MethodTable::m_wFlags);

    }
    
    DWORD wFlags;
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(dwAddr+MT_wFlagsOffset), &wFlags, sizeof(wFlags), NULL))) {
        return;
    }
    if ((wFlags & MethodTable::enum_flag_ContainsPointers) == 0) {
        return;
    }

    INT_PTR nEntries;
    move (nEntries, dwAddr-sizeof(PVOID));
    if (nEntries<0) {
        nEntries = -nEntries;
    }

    DWORD nSlots = 1+nEntries*sizeof(CGCDescSeries)/sizeof(DWORD_PTR);
    DWORD_PTR *buffer = (DWORD_PTR*) malloc(sizeof(DWORD_PTR)*nSlots);
    ToDestroy des0((void**)&buffer);

    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(dwAddr - nSlots*sizeof(DWORD_PTR)),
                                      buffer, nSlots*sizeof(DWORD_PTR), NULL))) {
        return;
    }
    CGCDesc *map = (CGCDesc *)(buffer+nSlots);
    size_t size = ObjectSize (obj);
    
    CGCDescSeries* cur = map->GetHighestSeries();                           
    CGCDescSeries* last = map->GetLowestSeries();                           
                                                                            
    const size_t bufferSize = 512;
    size_t objBuffer[bufferSize/sizeof(size_t)];
    size_t dwBeginAddr = obj;
    size_t bytesInBuffer = bufferSize;
    if (size < bytesInBuffer) {
        bytesInBuffer = size;
    }
    if (FAILED(g_ExtData->ReadVirtual(dwBeginAddr, objBuffer, bytesInBuffer,NULL))) {
        return;
    }

    if (cur >= last)                                                        
    {                                                                       
        do                                                                  
        {                                                                   
            BYTE** parm = (BYTE**)((obj) + cur->GetSeriesOffset());           
            BYTE** ppstop =                                                 
                (BYTE**)((BYTE*)parm + cur->GetSeriesSize() + (size));      
            while (parm < ppstop)                                           
            {                                                               
                if (IsInterrupt())
                    return;
                {
                     size_t dwAddr;
                     // Do we run out of cache?
                     if ((size_t)parm >= dwBeginAddr+bytesInBuffer) {
                         dwBeginAddr += bytesInBuffer;
                         if (dwBeginAddr >= obj + size) {
                             return;
                         }
                         bytesInBuffer = bufferSize;
                         if (obj+size-dwBeginAddr < bytesInBuffer) {
                             bytesInBuffer = obj+size-dwBeginAddr;
                         }
                         if (FAILED(g_ExtData->ReadVirtual(dwBeginAddr, objBuffer, bytesInBuffer, NULL))) {
                             return;
                         }
                     }
                     dwAddr = objBuffer[((size_t)parm-dwBeginAddr)/sizeof(size_t)];
                     if (dwAddr && IsObject(dwAddr)) {
                         OBJSTATE::ROOTSTATE status = gcRootInfo.AddObject (dwAddr);
                         if (status == OBJSTATE::Unknown) {
                             // add to list
                             pEntry->PushMember(dwAddr);
                         }
                         else if (status == OBJSTATE::IsRoot) {
                             pEntry->PushMember(dwAddr);
                             gcRootInfo.MarkObject(pEntry->GetObject(), TRUE);
                             pEntry->SetState(TRUE);
                             return;
                         }
                     }
                }
                parm++;                                                     
            }                                                               
            cur--;                                                          
            if (IsInterrupt())
                return;
                                                                            
        } while (cur >= last);                                              
    }                                                                       
    else                                                                    
    {                                                                       
        int cnt = map->GetNumSeries();                                      
        BYTE** parm = (BYTE**)((obj) + cur->startoffset);                     
        while ((BYTE*)parm < (BYTE*)((obj)+(size)-plug_skew))                 
        {                                                                   
            if (IsInterrupt())
                return;
            for (int __i = 0; __i > cnt; __i--)                             
            {                                                               
                if (IsInterrupt())
                    return;
                unsigned skip =  cur->val_serie[__i].skip;                  
                unsigned nptrs = cur->val_serie[__i].nptrs;                 
                BYTE** ppstop = parm + nptrs;                               
                do                                                          
                {                                                           
                    {
                         size_t dwAddr;
                         move (dwAddr, (size_t)parm);
                         if (dwAddr && IsObject(dwAddr)) {
                             OBJSTATE::ROOTSTATE status = gcRootInfo.AddObject (dwAddr);
                             if (status == OBJSTATE::Unknown) {
                                 // add to list
                                 pEntry->PushMember(dwAddr);
                             }
                             else if (status == OBJSTATE::IsRoot) {
                                 gcRootInfo.MarkObject(pEntry->GetObject(), TRUE);
                                 pEntry->SetState(TRUE);
                                 return;
                             }
                         }
                    }
                   parm++;                                                  
                   if (IsInterrupt())
                       return;
                } while (parm < ppstop);                                    
                parm = (BYTE**)((BYTE*)parm + skip);                        
            }                                                               
        }                                                                   
    }                                                                       

    if (pEntry->NumberOfMember() == 0) {
        pEntry->SetState(FALSE);
    }
}


void ProcessSmallHeap(gc_heap &heap)
{
    DWORD_PTR dwAddrSeg = (DWORD_PTR)heap.generation_table[heap.g_max_generation].start_segment;

    int n = 0;
    DWORD_PTR dwAddr;
    heap_segment segment;
    while (dwAddrSeg != (DWORD_PTR)heap.generation_table[0].start_segment)
    {
        if (IsInterrupt())
            return;
        dwAddr = dwAddrSeg;
        segment.Fill (dwAddr);
        gcRootInfo.AddGCSegment((size_t)segment.mem, (size_t)segment.allocated);
        dwAddrSeg = (DWORD_PTR)segment.next;
        n ++;
        if (n > 20)
            break;
    }

    dwAddr = (DWORD_PTR)heap.generation_table[0].start_segment;
    segment.Fill (dwAddr);
    gcRootInfo.AddGCSegment((size_t)segment.mem, (size_t)heap.alloc_allocated);
}

void InitGCRoot (size_t obj)
{
    // GC Heap
    DWORD_PTR dwNHeaps = 1;
    if (IsServerBuild())
    {
        static DWORD_PTR dwAddrNHeaps = 0;
        if (dwAddrNHeaps == 0)
            dwAddrNHeaps = GetAddressOf (offset_class_gc_heap, 
              offset_member_gc_heap::n_heaps);

        move (dwNHeaps, dwAddrNHeaps);
    }

    gc_heap heap = {0};
    if (!IsServerBuild())
    {
        DWORD_PTR dwAddr = 0;
        heap.Fill (dwAddr);
        if (!CallStatus)
            return;
        ProcessSmallHeap (heap);
    }
    else
    {
        DWORD_PTR dwAddrGHeaps =
            GetAddressOf (offset_class_gc_heap, offset_member_gc_heap::g_heaps);

        move (dwAddrGHeaps, dwAddrGHeaps);
        DWORD n;
        for (n = 0; n < dwNHeaps; n ++)
        {
            DWORD_PTR dwAddrGCHeap = dwAddrGHeaps + n*sizeof(VOID*);
            move (dwAddrGCHeap, dwAddrGCHeap);

            heap.Fill (dwAddrGCHeap);
            ProcessSmallHeap (heap);
        }
    }
    
    gcRootInfo.MarkObject(obj, TRUE);
}

class WorkQueue
{
    struct Node{
        Entry entry[8];
        size_t index;
        Node *next;
        Node ()
        {
            next = 0;
            index = 0;
        }
        ~Node ()
        {
        }
        void Release ()
        {
            Node *walk = next;
            if (walk) {
                Node *tmp = walk;
                walk = walk->next;
                delete tmp;
            }
            next = NULL;
            index = 0;
        }
    };
    Node head;
    Entry *top;

public:
    WorkQueue ()
    {
        top = NULL;
    }

    ~WorkQueue ()
    {
        Release ();
    }

    void Release ()
    {
        head.Release();
        top = NULL;
    }

    Entry* Top()
    {
        return top;
    }

    Entry* GetEntry ()
    {
        Node *walk = &head;
        while (walk->index == 8 && walk->next) {
            if (IsInterrupt())
                return NULL;
            walk = walk->next;
        }
        if (walk->index == 8) {
            walk->next = new Node;
            walk = walk->next;
        }
        Entry *pEntry = &walk->entry[walk->index];
        pEntry->Reset();
        top = pEntry;
        walk->index ++;
        return pEntry;
    }

    Entry* PopEntry ()
    {
        top->Reset();
        if (head.index == 1) {
            head.index --;
            top = NULL;
            return top;
        }
        top = NULL;
        Node *walk = &head;
        while (walk->index == 8 && walk->next) {
            if (IsInterrupt())
                return NULL;
            if (walk->next->index == 0) {
                break;
            }
            else if (walk->next->index == 1) {
                top = &walk->entry[7];
                walk->next->index = 0;
                return top;
            }
            walk = walk->next;
        }

        walk->index --;
        top = &walk->entry[walk->index-1];
        return top;
    }

    void Print ()
    {
        Node *walk =&head;
        ExtOut ("Root:");
        size_t lastObj=0;

        while (walk && walk->index > 0) {
            if (IsInterrupt())
                return;
            for (size_t i = 0; i < walk->index; i ++) {
                if (IsInterrupt())
                    break;
                lastObj = walk->entry[i].LastMember();
                if (lastObj == 0) {
                    lastObj = walk->entry[i].GetObject();
                    if (i == walk->index-1)
                        break;
                }
                size_t obj = walk->entry[i].GetObject();
                ExtOut ("%p", (ULONG64)obj);
                NameForObject (obj, g_mdName);
                ExtOut ("(%S)->", g_mdName);
            }
            walk = walk->next;
        }
        NameForObject (lastObj, g_mdName);
        ExtOut ("%p(%S)\n", (ULONG64)lastObj, g_mdName);
    }
};

WorkQueue wq;

void TraceObjectGraph (size_t obj, const char* name=NULL)
{
    if (!IsObject (obj)) {
        return;
    }

    Entry *pEntry = wq.GetEntry();
    pEntry->SetObject(obj);
    GetListOfRefs (pEntry);
    switch (pEntry->GetState()) {
    case OBJSTATE::IsRoot:
        if (name) {
            ExtOut ("%s:", name);
        }
        wq.Print();
        wq.PopEntry();
        return;
    case OBJSTATE::NotRoot:
        wq.PopEntry();
        return;
    }

    while (1) {
        if (IsInterrupt())
            return;
        size_t nextobj = pEntry->PopMember();
        if (nextobj == 0) {
            gcRootInfo.MarkObject(pEntry->GetObject(),FALSE);
            pEntry = wq.PopEntry();
            if (pEntry == NULL) {
                return;
            }
            continue;
        }
        pEntry = wq.GetEntry();
        pEntry->SetObject(nextobj);
        GetListOfRefs (pEntry);
        switch (pEntry->GetState()) {
        case OBJSTATE::IsRoot:
            if (name) {
                ExtOut ("%s:", name);
            }
            wq.Print();
            while (wq.PopEntry())
            {
                if (IsInterrupt())
                    return;
            }
            return;
        case OBJSTATE::NotRoot:
            gcRootInfo.MarkObject(pEntry->GetObject(), FALSE);
            pEntry = wq.PopEntry();
            if (pEntry == NULL) {
                break;
            }
        }
    }
}

typedef void (*GCInfoCallback)(size_t obj, const char* name);

void FindGCRootInReg (const char* regName, GCInfoCallback callback)
{
    ULONG IREG;
    DEBUG_VALUE value;
    DWORD_PTR reg;
    
    g_ExtRegisters->GetIndexByName(regName, &IREG);
    g_ExtRegisters->GetValue(IREG, &value);
    reg = value.I32;
    if (IsObject(reg)) {
        callback (reg, regName);
    }
}

void FindGCRootOnOneStack (size_t StackTop, size_t StackBottom, GCInfoCallback callback)
{
    // Registers:ECX, EDX, ESI, EBX, EBP
    FindGCRootInReg ("eax", callback);
    FindGCRootInReg ("ebx", callback);
    FindGCRootInReg ("ecx", callback);
    FindGCRootInReg ("edx", callback);
    FindGCRootInReg ("esi", callback);
    FindGCRootInReg ("edi", callback);
    FindGCRootInReg ("ebp", callback);

    char name[20] = "ESP:";
    DWORD_PTR ptr = StackTop & ~3;  // make certain dword aligned
    for (;ptr < StackBottom; ptr += sizeof(DWORD_PTR))
    {
        if (IsInterrupt())
            return;
        DWORD_PTR objAddr;
        move (objAddr, ptr);
        DWORD_PTR mtAddr;
        if (SUCCEEDED(g_ExtData->ReadVirtual((ULONG64)objAddr, &mtAddr, sizeof(mtAddr), NULL))) {
            if (IsMethodTable(mtAddr)) {
                _itoa (ptr, &name[4], 16);
                callback (objAddr, name);
            }
        }
    }
}

void FindGCRootOnStacks (GCInfoCallback callback)
{
    ULONG CurrentThreadId;
    g_ExtSystem->GetCurrentThreadId (&CurrentThreadId);
    
    DWORD_PTR *threadList = NULL;
    int numThread = 0;
    GetThreadList (threadList, numThread);
    ToDestroy des0((void**)&threadList);
    
    int i;
/*
    static ULONG OffsetToStackBase = -1;
    if (OffsetToStackBase == -1)
    {
        ULONG64 modBase;
        g_ExtSymbols->GetSymbolModule ("TEB", &modBase);
        ULONG TypeId;
        g_ExtSymbols->GetTypeId (modBase, "TEB", &TypeId);
        g_ExtSymbols->GetFieldOffset (modBase, TypeId, "StackBase",
                                      &OffsetToStackBase);
    }
*/
    ULONG ProcessId;
    g_ExtSystem->GetCurrentProcessSystemId (&ProcessId);

    Thread vThread;
    for (i = 0; i < numThread; i ++)
    {
        if (IsInterrupt())
            return;
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        ULONG id=0;
        if (FAILED(g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id)))
        {
            continue;
        }
        
        g_ExtSystem->SetCurrentThreadId (i);
        
        ULONG64 StackOffset;
        g_ExtRegisters->GetStackOffset (&StackOffset);

        ULONG64 Offset;
        g_ExtSystem->GetCurrentThreadTeb (&Offset);
#if 0
        size_t stackBase;
        g_ExtData->ReadVirtual (Offset+OffsetToStackBase, &stackBase, sizeof(stackBase), NULL);
#endif
        
        NT_TIB teb;
        if (SafeReadMemory ((ULONG_PTR)Offset, &teb, sizeof (NT_TIB), NULL))
        {
            ExtOut ("Scan Thread %d (%x)\n", i, vThread.m_ThreadId);
            FindGCRootOnOneStack ((size_t)StackOffset, (size_t)teb.StackBase, callback);
        }
    }

    g_ExtSystem->SetCurrentThreadId (CurrentThreadId);
}

/*
 * HANDLES
 *
 * The default type of handle is a strong handle.
 *
 */
#define HNDTYPE_DEFAULT                         HNDTYPE_STRONG


/*
 * WEAK HANDLES
 *
 * Weak handles are handles that track an object as long as it is alive,
 * but do not keep the object alive if there are no strong references to it.
 *
 * The default type of weak handle is 'long-lived' weak handle.
 *
 */
#define HNDTYPE_WEAK_DEFAULT                    HNDTYPE_WEAK_LONG


/*
 * SHORT-LIVED WEAK HANDLES
 *
 * Short-lived weak handles are weak handles that track an object until the
 * first time it is detected to be unreachable.  At this point, the handle is
 * severed, even if the object will be visible from a pending finalization
 * graph.  This further implies that short weak handles do not track
 * across object resurrections.
 *
 */
#define HNDTYPE_WEAK_SHORT                      (0)


/*
 * LONG-LIVED WEAK HANDLES
 *
 * Long-lived weak handles are weak handles that track an object until the
 * object is actually reclaimed.  Unlike short weak handles, long weak handles
 * continue to track their referents through finalization and across any
 * resurrections that may occur.
 *
 */
#define HNDTYPE_WEAK_LONG                       (1)


/*
 * STRONG HANDLES
 *
 * Strong handles are handles which function like a normal object reference.
 * The existence of a strong handle for an object will cause the object to
 * be promoted (remain alive) through a garbage collection cycle.
 *
 */
#define HNDTYPE_STRONG                          (2)


/*
 * PINNED HANDLES
 *
 * Pinned handles are strong handles which have the added property that they
 * prevent an object from moving during a garbage collection cycle.  This is
 * useful when passing a pointer to object innards out of the runtime while GC
 * may be enabled.
 *
 * NOTE:  PINNING AN OBJECT IS EXPENSIVE AS IT PREVENTS THE GC FROM ACHIEVING
 *        OPTIMAL PACKING OF OBJECTS DURING EPHEMERAL COLLECTIONS.  THIS TYPE
 *        OF HANDLE SHOULD BE USED SPARINGLY!
 */
#define HNDTYPE_PINNED                          (3)


/*
 * VARIABLE HANDLES
 *
 * Variable handles are handles whose type can be changed dynamically.  They
 * are larger than other types of handles, and are scanned a little more often,
 * but are useful when the handle owner needs an efficient way to change the
 * strength of a handle on the fly.
 * 
 */
#define HNDTYPE_VARIABLE                        (4)


/*
 * REFCOUNTED HANDLES
 *
 * Refcounted handles are handles that behave as strong handles while the
 * refcount on them is greater than 0 and behave as weak handles otherwise.
 *
 * N.B. These are currently NOT general purpose.
 *      The implementation is tied to COM Interop.
 *
 */
#define HNDTYPE_REFCOUNTED                      (5)


void FindGCRootOnOneHandleTable(DWORD_PTR tableAddr, GCInfoCallback callback)
{
    ExtOut ("Scan HandleTable %x\n", tableAddr);

    HandleTable table;
    table.Fill (tableAddr);

    TableSegment segment;
    DWORD_PTR dwAddr = (DWORD_PTR)table.pSegmentList;
    static char nameS[30] = "HANDLE(Strong):";
    static char nameP[30] = "HANDLE(Pinned):";
    static char nameR[30] = "HANDLE(RefCnt):";
    static char nameU[30] = "HANDLE(Unknwn):";

    while (dwAddr) {
        if (IsInterrupt())
            return;
        segment.Fill(dwAddr);
        if (!CallStatus) {
            break;
        }

        for (BYTE i = 0; i < segment.bEmptyLine; i ++) {
            if (IsInterrupt())
                return;
            if (segment.rgBlockType[i] == HNDTYPE_PINNED
                || segment.rgBlockType[i] == HNDTYPE_REFCOUNTED
                || segment.rgBlockType[i] == HNDTYPE_STRONG) {
                int start=i*HANDLE_HANDLES_PER_BLOCK;
                for (int j = 0; j < HANDLE_HANDLES_PER_BLOCK; j ++)
                {
                    if (segment.rgValue[start+j]) {
                        char *name;
                        if (segment.rgBlockType[i] == HNDTYPE_PINNED) {
                            name = nameP;
                        }
                        else if (segment.rgBlockType[i] == HNDTYPE_REFCOUNTED) {
                            name = nameR;
                        }
                        else if (segment.rgBlockType[i] == HNDTYPE_STRONG) {
                            name = nameS;
                        }
                        else
                            name = nameU;
                        _itoa (segment.firstHandle+(start+j)*HANDLE_SIZE, &name[15], 16);
                        callback (segment.rgValue[start+j], name);
                    }
                }
            }
        }
        dwAddr = (DWORD_PTR)segment.pNextSegment;
    }
}

#if 0
void FindGCRootOnHandleTables1(GCInfoCallback callback)
{
    // For old handle table code
    static DWORD_PTR sHandleTableAddr = -1;
    if (sHandleTableAddr == -1)
    {
        sHandleTableAddr = GetValueFromExpression("MSCOREE!g_pHandleTableArray");
    }
    if (sHandleTableAddr == 0) {
        return;
    }

    static DWORD_PTR handleTableCountAddr = 0;
    if (handleTableCountAddr == 0)
    {
        handleTableCountAddr = GetValueFromExpression("MSCOREE!g_cHandleTableArray");
    }

    size_t handleTableAddr;
    move (handleTableAddr, sHandleTableAddr);
    if (handleTableAddr == 0) {
        return;
    }
    UINT handleTableCount;
    move (handleTableCount, handleTableCountAddr);

    size_t tableAddr;
    for (UINT i = 0; i < handleTableCount; i++) {
        if (IsInterrupt())
            return;
        move (tableAddr, handleTableAddr+i*sizeof(size_t));
        if (tableAddr) {
            FindGCRootOnOneHandleTable (tableAddr, callback);
        }
    }
}
#endif

void FindGCRootOnHandleTables2(GCInfoCallback callback)
{
    // For old handle table code
    static DWORD_PTR sHandleTableMapAddr = -1;
    if (sHandleTableMapAddr == -1)
    {
        sHandleTableMapAddr = GetAddressOf (offset_class_Global_Variables,
          offset_member_Global_Variables::g_HandleTableMap);

    }

    if (sHandleTableMapAddr == 0) {
        return;
    }

    DWORD_PTR handleTableMapAddr = sHandleTableMapAddr;
    HandleTableMap map;
    DWORD offset = 0;

    size_t tableAddr;
    while (handleTableMapAddr) {
        if (IsInterrupt())
            return;
        map.Fill (handleTableMapAddr);
        for (DWORD i = 0; i < map.dwMaxIndex-offset; i++) {
            if (IsInterrupt())
                return;
            move (tableAddr, map.pTable+i*sizeof(size_t));
            if (tableAddr) {
                FindGCRootOnOneHandleTable (tableAddr, callback);
            }
        }
        offset = map.dwMaxIndex;
        handleTableMapAddr = (DWORD_PTR)map.pNext;
    }
}

void FindGCRootOnHandleTables(GCInfoCallback callback)
{
    // FindGCRootOnHandleTables1(callback);
    FindGCRootOnHandleTables2(callback);
}

class GCRootCleanUp {
public:
    GCRootCleanUp(){}
    ~GCRootCleanUp()
    {
        gcRootInfo.Release();
        wq.Release();
    }
};

void FindGCRoot (size_t obj)
{
    GCRootCleanUp cleanup;

    InitGCRoot (obj);

    FindGCRootOnStacks (TraceObjectGraph);

    FindGCRootOnHandleTables(TraceObjectGraph);
}


void TraceObjectGraphForSize (size_t obj, const char *name=NULL)
{
    if (!IsObject (obj)) {
        return;
    }
    gcRootInfo.Reset();
    size_t size = 0;

    Entry *pEntry = wq.GetEntry();
    pEntry->SetObject(obj);
    GetListOfRefs (pEntry);

    while (1) {
        if (IsInterrupt())
            return;
        size_t nextobj = pEntry->PopMember();
        if (nextobj == 0) {
            size += ObjectSize(pEntry->GetObject());
            pEntry = wq.PopEntry();
            if (pEntry == NULL) {
                if (name) {
                    ExtOut ("%s: ", name);
                }
                ExtOut ("sizeof(%p) = %8d (%#8x) bytes", (ULONG64)obj, size, size);
                NameForObject (obj, g_mdName);
                ExtOut (" (%S)\n", g_mdName);
                return;
            }
            continue;
        }
        pEntry = wq.GetEntry();
        pEntry->SetObject(nextobj);
        GetListOfRefs (pEntry);
    }
}

void FindObjSize (size_t obj)
{
    GCRootCleanUp cleanup;

    InitGCRoot (0);

    TraceObjectGraphForSize(obj, NULL);
}

void FindAllRootSize ()
{
    GCRootCleanUp cleanup;

    InitGCRoot (0);

    FindGCRootOnStacks (TraceObjectGraphForSize);

    FindGCRootOnHandleTables(TraceObjectGraphForSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\get-table-info.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 */
#ifndef INC_GET_TABLE_INFO
#define INC_GET_TABLE_INFO

#include <stddef.h>
#include <basetsd.h>

struct ClassDumpTable;

ClassDumpTable *GetClassDumpTable();
ULONG_PTR GetMemberInformation (size_t klass, size_t member);
SIZE_T GetClassSize (size_t klass);
ULONG_PTR GetEEJitManager ();
ULONG_PTR GetEconoJitManager ();
ULONG_PTR GetMNativeJitManager ();

#endif /* ndef INC_GET_TABLE_INFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\gcdumpia64.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 *                               GCDumpX86.cpp
 */

/*****************************************************************************/
#ifdef _IA64_
/*****************************************************************************/

#include "GCDump.h"
#include "Endian.h"


/*****************************************************************************/

/*****************************************************************************/

/*****************************************************************************/

unsigned    GCDump::DumpCodeInfo (const BYTE *   table,
                                 CodeInfo*       header,
                                 unsigned*      methodSize,
                                 bool           verifyGCTables)
{
    _ASSERTE(!"NYI");
    return 0;
}

/*****************************************************************************/

unsigned    GCDump::DumpGCTable(const BYTE *   table,
                                const CodeInfo& header,
                                unsigned       methodSize,
                                bool           verifyGCTables)
{
    _ASSERTE(!"NYI");
    return 0;
}


/*****************************************************************************/

void    GCDump::DumpPtrsInFrame(const void *infoBlock,
                                const void *codeBlock,
                                unsigned    offs,
                                bool        verifyGCTables)
{
    _ASSERTE(!"NYI");
}

/*****************************************************************************/
#endif // _IA64_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\get-table-info.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Read from the class/offset table that resides within a debugged process.
 */

#include "strike.h"
#include "util.h"
#include "get-table-info.h"
#include <dump-tables.h>
#include "process-info.h"

#ifdef _DEBUG
    #define DOUT OutputDebugStringW
#else
static void _ods (const wchar_t* s)
{
}
    #define DOUT _ods
#endif

const ULONG_PTR InvalidOffset = static_cast<ULONG_PTR>(-1);

static HANDLE g_CurrentProcess = INVALID_HANDLE_VALUE;
static ClassDumpTable g_ClassTable;
static BOOL           g_fClassTableInit = FALSE;

/**
 * Initialize g_ClassTable to point to the class dump table in the debuggee
 * process.
 */
bool InitializeOffsetTable ()
{
    if (g_fClassTableInit)
        return (true);

    // We use the process handle to determine if we're debugging the same
    // process.  It's conceivable that the same debugger session will debug
    // multiple programs, so the process may change, requiring everything to be
    // re-loaded.
    ULONG64 ProcHandle;
    HANDLE hProcess;
    HRESULT hr = E_FAIL;
    if (SUCCEEDED(hr = g_ExtSystem->GetCurrentProcessHandle (&ProcHandle)))
    {
        // we cache the ClassDumpTable info, so we should only update it if the
        // process changes.
        hProcess = (HANDLE) ProcHandle;
        if (g_CurrentProcess == hProcess)
            return (true);
    }
    else
    {
        DOUT (L"Unable to get the current process.");
        return (false);
    }

    // Module names don't include file name extensions.
    ULONG64 BaseOfDll;
    if (FAILED(hr = g_ExtSymbols->GetModuleByModuleName (
                                                        "mscorwks", 0, NULL, &BaseOfDll)))
    {
        DOUT (L"unable to get base of mscorwks.dll; trying mscorsvr.dll");
        if (FAILED(hr = g_ExtSymbols->GetModuleByModuleName (
                                                            "mscorsvr", 0, NULL, &BaseOfDll)))
        {
            DOUT (L"unable to get base of mscorsvr.dll; stopping.");
            return (false);
        }
    }

    int tableName = 80;
    ULONG_PTR TableAddress = NULL;
    if (!GetExportByName ((ULONG_PTR) BaseOfDll, 
                          reinterpret_cast<const char*>(tableName), &TableAddress))
    {
        DOUT (L"unable to find class dump table");
        return (false);
    }

    ULONG bytesRead;
    if (!SafeReadMemory (TableAddress, &g_ClassTable, 
                         sizeof(g_ClassTable), &bytesRead))
    {
        DOUT (L"Lunable to read class dump table");
        return (false);
    }

    // Is the version what we're expecting?  If it isn't, we don't know what the
    // correct indexes are.
    if (g_ClassTable.version != 1)
        return (false);

    // At this point, everything has been initialized properly.  Cache the
    // process handle so we don't repeat all this.
    g_CurrentProcess = hProcess;
    g_fClassTableInit = TRUE;
    return (true);
}

/**
 * Return pointer to initialized class dump table.
 */
ClassDumpTable *GetClassDumpTable()
{
    if (InitializeOffsetTable())
        return &g_ClassTable;

    return (NULL);
}

/**
 * Return the memory location of the beginning of the ClassDumpInfo for the
 * requested class.
 */
static ULONG_PTR GetClassInfo (size_t klass)
{
    // is the requested class correct?
    if (klass == (size_t)-1)
        return (InvalidOffset);

    // make sure our data is current.
    if (!InitializeOffsetTable ())
        return (InvalidOffset);

    if (klass >= g_ClassTable.nentries)
        return (InvalidOffset);


    // g_ClassTable.classes is a continuous array of pointers to ClassDumpInfo
    // objects.  We need the address of the correct object.
    ULONG BR; // bytes read
    ULONG_PTR Class;
    if (!SafeReadMemory (
                        reinterpret_cast<ULONG_PTR>(g_ClassTable.classes) + // base of array
                        (klass*sizeof(ClassDumpInfo*)), // memory offset into array
                        &Class, 
                        sizeof(Class), &BR))
        return (InvalidOffset);

    return (Class);
}


ULONG_PTR GetMemberInformation (size_t klass, size_t member)
{
    const ULONG_PTR error = InvalidOffset;

    // get the location of the class in memory
    ULONG_PTR pcdi;
    if ((pcdi = GetClassInfo(klass)) == InvalidOffset)
        return (error);

    ULONG BR; // bytes read
    ClassDumpInfo cdi;
    if (!SafeReadMemory (pcdi, &cdi, sizeof(cdi), &BR))
        return (error);

    // get the member
    if (member == (size_t)-1)
        return (error);
    if (member >= cdi.nmembers)
        return (error);

    ULONG_PTR size;
    if (!SafeReadMemory (
                        reinterpret_cast<ULONG_PTR>(cdi.memberOffsets) + // base of offset array
                        (member*sizeof(ULONG_PTR)),  // member index
                        &size,
                        sizeof(size),
                        &BR))
        return (error);

    return (size);
}


SIZE_T GetClassSize (size_t klass)
{
    // reminder: in C++, all classes must be at least 1 byte in size
    // (this is to prevent two variables from having the same memory address)
    // Thus, 0 is an invalid class size value.
    const SIZE_T error = 0;

    // get the location of the class in memory
    ULONG_PTR pcdi;
    if ((pcdi = GetClassInfo(klass)) == InvalidOffset)
        return (error);

    // read in the class information.
    ULONG BR; // bytes read
    ClassDumpInfo cdi;
    if (!SafeReadMemory (pcdi, &cdi, sizeof(cdi), &BR))
        return (error);

    return (cdi.classSize);
}

ULONG_PTR GetEEJitManager ()
{
    if (InitializeOffsetTable())
        return (g_ClassTable.pEEJitManagerVtable);
    return (0);
}

ULONG_PTR GetEconoJitManager ()
{
    if (InitializeOffsetTable())
        return (g_ClassTable.pEconoJitManagerVtable);
    return (0);
}

ULONG_PTR GetMNativeJitManager ()
{
    if (InitializeOffsetTable())
        return (g_ClassTable.pMNativeJitManagerVtable);
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\process-info.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#ifndef INC_PROCESS_INFO
#define INC_PROCESS_INFO

BOOL GetExportByName (
  ULONG_PTR   BaseOfDll, 
  const char* ExportName,
  ULONG_PTR*  ExportAddress);

#endif /* ndef INC_PROCESS_INFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\ntinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _ntinfo_h__
#define _ntinfo_h__

//+---------------------------------------------------------------------------
//
// forward declarations (in order to avoid type casting when accessing
// data members of the SOleTlsData structure).
//
//+---------------------------------------------------------------------------

class  CAptCallCtrl;                        // see callctrl.hxx
class  CSrvCallState;                       // see callctrl.hxx
class  CObjServer;                          // see sobjact.hxx
class  CSmAllocator;                        // see stg\h\smalloc.hxx
class  CMessageCall;                        // see call.hxx
class  CClientCall;                         // see call.hxx
class  CAsyncCall;                          // see call.hxx
class  CClipDataObject;                     // see ole232\clipbrd\clipdata.h
class  CSurrogatedObjectList;               // see com\inc\comsrgt.hxx
class  CCtxCall;                            // see PSTable.hxx
class  CPolicySet;                          // see PSTable.hxx
class  CObjectContext;                      // see context.hxx
class  CComApartment;                       // see aprtmnt.hxx
class  ContextStackNode;
//+-------------------------------------------------------------------
//
//  Struct:     CallEntry
//
//  Synopsis:   Call Table Entry.
//
//+-------------------------------------------------------------------
typedef struct tagCallEntry
{
    void  *pNext;        // ptr to next entry
    void  *pvObject;     // Entry object
} CallEntry;

//+---------------------------------------------------------------------------
//
//  Enum:       OLETLSFLAGS
//
//  Synopsys:   bit values for dwFlags field of SOleTlsData. If you just want
//              to store a BOOL in TLS, use this enum and the dwFlag field.
//
//+---------------------------------------------------------------------------
typedef enum tagOLETLSFLAGS
{
    OLETLS_LOCALTID             = 0x01,   // This TID is in the current process.
    OLETLS_UUIDINITIALIZED      = 0x02,   // This Logical thread is init'd.
    OLETLS_INTHREADDETACH       = 0x04,   // This is in thread detach. Needed
                                          // due to NT's special thread detach
                                          // rules.
    OLETLS_CHANNELTHREADINITIALZED = 0x08,// This channel has been init'd
    OLETLS_WOWTHREAD            = 0x10,   // This thread is a 16-bit WOW thread.
    OLETLS_THREADUNINITIALIZING = 0x20,   // This thread is in CoUninitialize.
    OLETLS_DISABLE_OLE1DDE      = 0x40,   // This thread can't use a DDE window.
    OLETLS_APARTMENTTHREADED    = 0x80,   // This is an STA apartment thread
    OLETLS_MULTITHREADED        = 0x100,  // This is an MTA apartment thread
    OLETLS_IMPERSONATING        = 0x200,  // This thread is impersonating
    OLETLS_DISABLE_EVENTLOGGER  = 0x400,  // Prevent recursion in event logger
    OLETLS_INNEUTRALAPT         = 0x800,  // This thread is in the NTA
    OLETLS_DISPATCHTHREAD       = 0x1000, // This is a dispatch thread
    OLETLS_HOSTTHREAD           = 0x2000, // This is a host thread
    OLETLS_ALLOWCOINIT          = 0x4000, // This thread allows inits
    OLETLS_PENDINGUNINIT        = 0x8000, // This thread has pending uninit
    OLETLS_FIRSTMTAINIT         = 0x10000,// First thread to attempt an MTA init
    OLETLS_FIRSTNTAINIT         = 0x20000,// First thread to attempt an NTA init
    OLETLS_APTINITIALIZING      = 0x40000 // Apartment Object is initializing
}  OLETLSFLAGS;


//+---------------------------------------------------------------------------
//
//  Structure:  SOleTlsData
//
//  Synopsis:   structure holding per thread state needed by OLE32
//
//+---------------------------------------------------------------------------
typedef struct tagSOleTlsData
{
    // jsimmons 5/23/2001
    // Alert Alert:  nefarious folks (eg, URT) are looking in our TLS at
    // various stuff.   They expect that pCurrentCtx will be at a certain
    // offset from the beginning of the tls struct. So don't add, delete, or 
    // move any members within this block.

/////////////////////////////////////////////////////////////////////////////////////////
// ********* BEGIN "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////
    // Docfile multiple allocator support
    void               *pvThreadBase;       // per thread base pointer
    CSmAllocator       *pSmAllocator;       // per thread docfile allocator

    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see OLETLSFLAGS above

    LONG                TlsMapIndex;        // index in the global TLSMap
    void              **ppTlsSlot;          // Back pointer to the thread tls slot
    DWORD               cComInits;          // number of per-thread inits
    DWORD               cOleInits;          // number of per-thread OLE inits

    DWORD               cCalls;             // number of outstanding calls
    CMessageCall       *pCallInfo;          // channel call info
    CAsyncCall         *pFreeAsyncCall;     // ptr to available call object for this thread.
    CClientCall        *pFreeClientCall;    // ptr to available call object for this thread.

    CObjServer         *pObjServer;         // Activation Server Object for this apartment.
    DWORD               dwTIDCaller;        // TID of current calling app
    CObjectContext     *pCurrentCtx;        // Current context
/////////////////////////////////////////////////////////////////////////////////////////
//  ********* END "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////

    CObjectContext     *pEmptyCtx;          // Empty context

    CObjectContext     *pNativeCtx;         // Native context
    ULONGLONG           ContextId;          // Uniquely identifies the current context
    CComApartment      *pNativeApt;         // Native apartment for the thread.
    IUnknown           *pCallContext;       // call context object
    CCtxCall           *pCtxCall;           // Context call object

    CPolicySet         *pPS;                // Policy set
    PVOID               pvPendingCallsFront;// Per Apt pending async calls
    PVOID               pvPendingCallsBack;
    CAptCallCtrl       *pCallCtrl;          // call control for RPC for this apartment

    CSrvCallState      *pTopSCS;            // top server-side callctrl state
    IMessageFilter     *pMsgFilter;         // temp storage for App MsgFilter
    HWND                hwndSTA;            // STA server window same as poxid->hServerSTA
                                            // ...needed on Win95 before oxid registration
    LONG                cORPCNestingLevel;  // call nesting level (DBG only)

    DWORD               cDebugData;         // count of bytes of debug data in call

    UUID                LogicalThreadId;    // current logical thread id

    HANDLE              hThread;            // Thread handle used for cancel
    HANDLE              hRevert;            // Token before first impersonate.
    IUnknown           *pAsyncRelease;      // Controlling unknown for async release
    // DDE data
    HWND                hwndDdeServer;      // Per thread Common DDE server

    HWND                hwndDdeClient;      // Per thread Common DDE client
    ULONG               cServeDdeObjects;   // non-zero if objects DDE should serve
    // ClassCache data
    LPVOID              pSTALSvrsFront;     // Chain of LServers registers in this thread if STA
    // upper layer data
    HWND                hwndClip;           // Clipboard window

    IDataObject         *pDataObjClip;      // Current Clipboard DataObject
    DWORD               dwClipSeqNum;       // Clipboard Sequence # for the above DataObject
    DWORD               fIsClipWrapper;     // Did we hand out the wrapper Clipboard DataObject?
    IUnknown            *punkState;         // Per thread "state" object
    // cancel data
    DWORD              cCallCancellation;   // count of CoEnableCallCancellation
    // async sends data
    DWORD              cAsyncSends;         // count of async sends outstanding

    CAsyncCall*           pAsyncCallList;   // async calls outstanding
    CSurrogatedObjectList *pSurrogateList;  // Objects in the surrogate

    LockEntry             lockEntry;        // Locks currently held by the thread
    CallEntry             CallEntry;        // client-side call chain for this thread

#ifdef WX86OLE
    IUnknown           *punkStateWx86;      // Per thread "state" object for Wx86
#endif
    void               *pDragCursors;       // Per thread drag cursor table.

    IUnknown           *punkError;          // Per thread error object.
    ULONG               cbErrorData;        // Maximum size of error data.

    IUnknown           *punkActiveXSafetyProvider;

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for OLETRACE
#endif

    ContextStackNode* pContextStack;

} SOleTlsData;

#endif //_ntinfo_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\process-info.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**
 *
 */

#include "strike.h"
#include "util.h"
#include "process-info.h"
#include <assert.h>

/**
 * The maxiumum value that we'll consider to be an ordinal.  This may be
 * smaller than the maximum possible, but should suffice for now.
 */
const int MAX_ORDINAL_VALUE = 128;

/**
 * Search for the export by the ordinal
 */
static BOOL _searchExportsByOrdinal (
    DWORD_PTR               BaseOfDll,
    const char*             ExportName,
    IMAGE_EXPORT_DIRECTORY* Table,
    ULONG_PTR*              ExportAddress)
{
    // An ordinal is merely a direct index into the AddressOfFunctions array.
    DWORD ordinal = reinterpret_cast<DWORD>(ExportName);

    assert (ordinal < MAX_ORDINAL_VALUE);

    // Ordinal values are modified by a Base value.
    ordinal -= Table->Base;

    if (ordinal > Table->NumberOfFunctions)
        // invalid ordinal value
        return false;

    ULONG_PTR offsetT;

    //
    // read AddressOfFunctions [ordinal];
    //

    // TODO: Is DWORD_PTR the correct type for the AddressOfFunctions offsets?
    // This may be important under Win64.
    if (!SafeReadMemory ( (ULONG_PTR)(BaseOfDll +
            (ULONG) Table->AddressOfFunctions +
            ordinal * sizeof (DWORD_PTR)),
        &offsetT,
        sizeof (offsetT),
        NULL))
        return FALSE;

    offsetT += BaseOfDll;

    *ExportAddress = offsetT;
    return TRUE;
}

#define MAX_SYMBOL_LENGTH	(260)

//
// This searches for the name in an alphabetical list
//
// TODO: This was originally written for Win32.  Is it correct for Win64?
static BOOL _searchExportsByName (
    DWORD_PTR               BaseOfDll,
    const char*             ExportName,
    IMAGE_EXPORT_DIRECTORY* Table,
    ULONG_PTR*              ExportAddress)
{
    ULONG cbT = sizeof (DWORD) * Table->NumberOfNames;

    PDWORD NamePointerTable = (PDWORD) _alloca(cbT);

    memset (NamePointerTable, 0, cbT);

    if (!SafeReadMemory (
        (ULONG_PTR)((ULONG)Table->AddressOfNames + BaseOfDll),
        NamePointerTable,
        cbT,
        NULL))
        return FALSE;

    //
    // Bsearch the name table
    //
    LONG low = 0;
    LONG high = Table->NumberOfNames - 1;

    while (low <= high)
        {
        CHAR    Buffer [MAX_SYMBOL_LENGTH];
        ULONG i = (low + high) / 2;

        ULONG cbRead;
        if (!SafeReadMemory (
            (ULONG_PTR)(NamePointerTable [i] + BaseOfDll),
            Buffer,
            sizeof(Buffer),
            &cbRead))
            return FALSE;

        LONG iRet = strncmp(Buffer, ExportName, cbRead);

        if (iRet < 0)
            low = i + 1;
        else if (iRet > 0)
            high = i - 1;
        else
            {	// match
            //
            // ordinal = AddressOfNameOrdinals [i];
            //
            ULONG_PTR offsetT = BaseOfDll +
                (ULONG) Table->AddressOfNameOrdinals +
                i * sizeof (USHORT);

            WORD wordT;
            if (!SafeReadMemory ( (ULONG_PTR) offsetT,
                &wordT,
                sizeof (wordT),
                NULL))
                return FALSE;

            DWORD ordinal = wordT;

            //
            // read AddressOfFunctions [ordinal];
            //
            if (!SafeReadMemory ( (ULONG_PTR)(BaseOfDll +
                    (ULONG) Table->AddressOfFunctions +
                    ordinal * sizeof (DWORD)),
                &offsetT,
                sizeof (offsetT),
                NULL))
                return FALSE;

            offsetT += BaseOfDll;

            *ExportAddress = offsetT;
            return TRUE;
            }
        }

    return FALSE;
}


//
// GetExportByName -- look up an exported symbol in a DLL in another
// process. Call this after receiving LOAD_DLL_DEBUG_EVENT.
//
// This code simply reads the export table out of the DLL from the remote
// process and searches it.
//
// This code was snagged, with very little change, from the sources to
// the VC7 debugger. Matt Hendell pointed out the location and provided
// the source.
//

BOOL GetExportByName(
    DWORD_PTR   BaseOfDll,
    const char* ExportName,
    ULONG_PTR*  ExportAddress)
{
    IMAGE_DOS_HEADER        dosHdr;
    IMAGE_NT_HEADERS        ntHdr;
    PIMAGE_DATA_DIRECTORY	  ExportDataDirectory = NULL;
    IMAGE_EXPORT_DIRECTORY  ExportDirectoryTable;
    ULONG                   SectionTableBase;
    ULONG                   NumberOfSections;
    IMAGE_SECTION_HEADER*   rgSecHdr = NULL;

    //
    // Read the DOS header from the front of the image.
    //
    if (!SafeReadMemory ((ULONG_PTR) BaseOfDll,
        &dosHdr,
        sizeof(dosHdr),
        NULL))
        return FALSE;

    //
    // Verify that we've got a valid DOS header.
    //
    if (dosHdr.e_magic != IMAGE_DOS_SIGNATURE)
        return FALSE;

    //
    // Read the NT Header next.
    //
    if (!SafeReadMemory ((ULONG_PTR) (dosHdr.e_lfanew + BaseOfDll),
        &ntHdr,
        sizeof(ntHdr),
        NULL))
        return FALSE;

    //
    // Verify that we've got a valid NT Header.
    //
    if (ntHdr.Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    //
    // Grab the section info from the optional headers.
    //
    NumberOfSections = ntHdr.FileHeader.NumberOfSections;
    rgSecHdr = (IMAGE_SECTION_HEADER *) _alloca(NumberOfSections *
        sizeof(IMAGE_SECTION_HEADER));

    assert(sizeof(ntHdr.OptionalHeader) ==
        ntHdr.FileHeader.SizeOfOptionalHeader);

    SectionTableBase = BaseOfDll + dosHdr.e_lfanew + sizeof(IMAGE_NT_HEADERS);

    if (!SafeReadMemory ((ULONG_PTR) SectionTableBase,
        rgSecHdr,
        NumberOfSections * sizeof (IMAGE_SECTION_HEADER),
        NULL))
        return FALSE;

    ExportDataDirectory =
        &ntHdr.OptionalHeader.DataDirectory [IMAGE_DIRECTORY_ENTRY_EXPORT];

    if (ExportDataDirectory->VirtualAddress == 0 ||
        ExportDataDirectory->Size == 0)
        {
        //
        // No exports.  This happens often -- exes generally do not have
        // exports.
        //
        return FALSE;
        }

    if (!SafeReadMemory ((ULONG_PTR) (ExportDataDirectory->VirtualAddress +
            BaseOfDll),
        &ExportDirectoryTable,
        sizeof (ExportDirectoryTable),
        NULL))
        return FALSE;

    if (ExportDirectoryTable.NumberOfNames == 0L)
        return FALSE;

    // Ordinals are values below a given value.  In this case, we'll assume
    // that ordinals will be values less than MAX_ORDINAL_VALUE
    if (ExportName < reinterpret_cast<const char*>(MAX_ORDINAL_VALUE))
        return _searchExportsByOrdinal (BaseOfDll, ExportName, 
            &ExportDirectoryTable, ExportAddress);

    return _searchExportsByName (BaseOfDll, ExportName, 
        &ExportDirectoryTable, ExportAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\miniee.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// !!! Do not include any other header files here.

#include "..\..\inc\corhdr.h"
#include "..\..\inc\cor.h"

// !!!CLR Minidump includes this file.  If you make a change in this file,
// !!!be sure to build ..\minidump

typedef LPCSTR  LPCUTF8;
typedef LPSTR   LPUTF8;

DECLARE_HANDLE(OBJECTHANDLE);

// This will need ifdefs for 64 bit!
#define SLOT    DWORD
#define METHOD_HASH_BYTES  8

class EEClass;
class MethodTable;
class InterfaceInfo_t;
class ClassLoader;
class FieldDesc;
class SecurityProperties;
class Module;
class PEFile;
class Assembly;
class Crst;
class ISymUnmanagedReader;
struct LoaderHeapBlock;

typedef void* OpaqueCtxInfo;
typedef void* IMDInternalImport;
typedef DWORD_PTR IMetaDataDebugImport;
typedef DWORD_PTR IMetaDataHelper;
typedef DWORD_PTR VASigCookieBlock;
typedef DWORD_PTR RangeList;
typedef DWORD_PTR Compare;

#ifndef STRIKE
// Max length in WCHAR for a buffer to store metadata name
const int mdNameLen = 2048;
extern WCHAR g_mdName[mdNameLen];

#ifdef _X86_

struct CodeInfo
{
    JitType jitType;
    DWORD_PTR IPBegin;
    unsigned methodSize;
    DWORD_PTR gcinfoAddr;
    unsigned char prologSize;
    unsigned char epilogStart;
    unsigned char epilogCount:3;
    unsigned char epilogAtEnd:1;
    unsigned char ediSaved   :1;
    unsigned char esiSaved   :1;
    unsigned char ebxSaved   :1;
    unsigned char ebpSaved   :1;
    unsigned char ebpFrame;
    unsigned short argCount;
};

#endif // _X86_

#ifdef _IA64_

struct CodeInfo
{
    JitType jitType;
    DWORD_PTR IPBegin;
    unsigned methodSize;
    DWORD_PTR gcinfoAddr;
    unsigned char prologSize;
    unsigned char epilogStart;
    unsigned char epilogCount:3;
    unsigned char epilogAtEnd:1;
//    unsigned char ediSaved   :1;
//    unsigned char esiSaved   :1;
//    unsigned char ebxSaved   :1;
//    unsigned char ebpSaved   :1;
//    unsigned char ebpFrame;
    unsigned short argCount;
};


#endif // _IA64_
#endif // STRIKE

enum MethodClassification
{
    mcIL        = 0, // IL
    mcECall     = 1, // ECall
    mcNDirect   = 2, // N/Direct
    mcEEImpl    = 3, // special method; implementation provided by EE
    mcArray     = 4, // Array ECall
    mcComInterop  = 5, 
};

enum MethodDescClassification
{
    
    // Method is IL, ECall etc., see MethodClassification above.
    mdcClassification                   = 0x0007,
    mdcClassificationShift              = 0,
};

class MethodDesc
{
public :
    enum
    {
#ifdef _IA64_
        ALIGNMENT_SHIFT = 4,
#else
        ALIGNMENT_SHIFT = 3,
#endif

        ALIGNMENT       = (1<<ALIGNMENT_SHIFT),
        ALIGNMENT_MASK  = (ALIGNMENT-1)
    };
    
//#ifdef _DEBUG

    // These are set only for MethodDescs but every time I want to use the debugger
    // to examine these fields, the code has the silly thing stored in a MethodDesc*.
    // So...
    LPCUTF8         m_pszDebugMethodName;
    LPUTF8          m_pszDebugClassName;
    LPUTF8          m_pszDebugMethodSignature;
    EEClass        *m_pDebugEEClass;
    MethodTable    *m_pDebugMethodTable;
    DWORD           m_alignpad1;             // unused field to keep things 8-byte aligned

//#ifdef STRESS_HEAP
    class GCCoverageInfo* m_GcCover;
    DWORD           m_alignpad2;             // unused field to keep things 8-byte aligned
//#endif
//#endif  // _DEBUG

    // Returns the slot number of this MethodDesc in the vtable array.
    WORD           m_wSlotNumber;

    // Flags.
    WORD           m_wFlags;

//#ifndef TOKEN_IN_PREPAD
    // Lower three bytes are method def token, upper byte is a combination of
    // offset (in method descs) from a pointer to the method table or module and
    // a flag bit (upper bit) that's 0 for a method and 1 for a global function.
    // The value of the type flag is chosen carefully so that GetMethodTable can
    // ignore it and remain fast, pushing the extra effort on the lesser used
    // GetModule for global functions.
    DWORD          m_dwToken;
//#endif

    // Stores either a native code address or an IL RVA (the high bit is set to
    // indicate IL). If an IL RVA is held, native address is assumed to be the
    // prestub address.
    size_t      m_CodeOrIL;

    DWORD_PTR   m_MTAddr;

	DEFINE_STD_FILL_FUNCS(MethodDesc)
    void FillMdcAndSdi (DWORD_PTR& dwStartAddr);
};

#define METHOD_PREPAD 8

#pragma pack(push,1)

struct StubCallInstrs
{
    unsigned __int16 m_wTokenRemainder;      //a portion of the methoddef token. The rest is stored in the chunk
    BYTE        m_chunkIndex;           //index to recover chunk

// This is a stable and efficient entrypoint for the method
    BYTE        m_op;                   //this is either a jump (0xe9) or a call (0xe8)
    UINT32      m_target;               //pc-relative target for jump or call
	DEFINE_STD_FILL_FUNCS(StubCallInstrs)
};

#pragma pack(pop)

class MethodDescChunk
{
public:
        // This must be at the beginning for the asm routines to work.
        MethodTable *m_methodTable;

        MethodDescChunk     *m_next;
        USHORT               m_count;
        BYTE                 m_kind;
        BYTE                 m_tokrange;
        UINT32               m_alignpad;

	DEFINE_STD_FILL_FUNCS(MethodDescChunk)
};

class MethodTable
{
public:
    enum
    {
        //
        // DO NOT use flags that have bits set in the low 2 bytes.
        // These flags are DWORD sized so that our atomic masking
        // operations can operate on the entire 4-byte aligned DWORD
        // inestead of the logical non-aligned WORD of flags.  This
        // is also the reason for the union around m_ComponentSize
        // and m_wFlags below.
        //
        enum_flag_Array                 =    0x10000,
        enum_flag_large_Object          =    0x20000,
        enum_flag_ContainsPointers      =    0x40000,
        enum_flag_ClassInited           =    0x80000, // definitely ran vs. maybe not ran <clinit>
        enum_flag_HasFinalizer          =   0x100000, // instances require finalization
        enum_flag_Sparse                =   0x200000, // vtables for this interface are sparse
        enum_flag_Shared                =   0x400000, // This method table is shared among multiple logical classes
        enum_flag_Unrestored            =   0x800000, // Preloaded class needs to be restored

        enum_TransparentProxy           =  0x1000000, // tranparent proxy
        enum_flag_SharedAssembly        =  0x2000000, // Class is in a shared assembly
        enum_ComEmulateMask             =  0x4000000, // class is a COM view of managed class
        enum_ServicedComponentMask      =  0x8000000, // class is ServicedComponent

        enum_CtxProxyMask               = 0x10000000, // class is a context proxy
        enum_ComObjectMask              = 0x40000000, // class is a com object
        enum_InterfaceMask              = 0x80000000, // class is a interface
    };


    union
    {
        WORD            m_ComponentSize;            // Component size for array objects or value classes, zero otherwise    
        DWORD           m_wFlags;
    };

    DWORD               m_BaseSize;                 // Base size of instance of this class
    EEClass*            m_pEEClass;                 // class object

    LPVOID*             m_pInterfaceVTableMap;      // pointer to subtable for interface/vtable mapping

    WORD                m_wNumInterface;           // number of interfaces in the interface map
    BYTE                m_NormType;                 // The CorElementType for this class (most classes = ELEMENT_TYPE_CLASS)

    Module*             m_pModule;

    WORD                m_wCCtorSlot;               // slot of class constructor
    WORD                m_wDefaultCtorSlot;         // slot of default constructor

    InterfaceInfo_t*    m_pIMap;                    // pointer interface map

    union
    {
        // valid only if EEClass::IsBlittable() or EEClass::HasLayout() is true
        UINT32      m_cbNativeSize; // size of fixed portion in bytes

        // valid only for interfaces.
        UINT32      m_cbNumImpls; // for interfaces number of implementations

        // valid only for ArrayClasses
        // THIS IS REALLY AN EMBEDDED ARRAYCRACKER CLASS WHICH CONTAINS ONLY A
        // C++ VPTR.
        LPVOID      m_ArrayCracker;

        // For COM+ wrapper objects that extend an unmanaged class, this field
        // may contain a delegate to be called to allocate the aggregated
        // unmanaged class (instead of using CoCreateInstance).
        OBJECTHANDLE    m_ohDelegate;
    };

    DWORD   m_cbSlots; // total slots in this vtable

    SLOT    m_Vtable[1];
/*
    static MethodDesc  *m_FinalizerMD;
    static MetaSig     *m_FinalizerSig;
*/
    void FillVtableInit (DWORD_PTR& dwStartAddr);

	DEFINE_STD_FILL_FUNCS(MethodTable)
};

class EEClass
{
public :
//#ifdef _DEBUG
    LPUTF8  m_szDebugClassName; // This is the *fully qualified* class name
//#endif

    UINT32 m_dwInterfaceId;
    EEClass *m_pParentClass;
    WORD   m_wNumVtableSlots;  // Includes only vtable methods (which come first in the table)
    WORD   m_wNumMethodSlots;  // Includes vtable + non-vtable methods, but NOT duplicate interface methods
    WORD   m_wDupSlots;         // value classes have some duplicate slots at the end

    WORD   m_wNumInterfaces;

    // We have the parent pointer above.  In order to efficiently backpatch, we need
    // to find all the children of the current type.  This is achieved with a chain of
    // children.  The SiblingsChain is used as the linkage of that chain.
    //
    // Strictly speaking, we could remove m_pParentClass and put it at the end of the
    // sibling chain.  But the perf would really suffer for casting, so we burn the space.
    EEClass *m_SiblingsChain;
    EEClass *m_ChildrenChain;

        // Number of fields in the class, including inherited fields (includes
    WORD   m_wNumInstanceFields;
    WORD   m_wNumStaticFields;

    // Number of pointer series
    WORD    m_wNumGCPointerSeries;

    // TODO: There is a free WORD here 

    // # of bytes of instance fields stored in GC object
    DWORD   m_dwNumInstanceFieldBytes;  // Warning, this can be any number, it is NOT rounded up to DWORD alignment etc

    ClassLoader *m_pLoader;

    // includes all methods in the vtable
    MethodTable *m_pMethodTable;

    // a pointer to a list of FieldDescs declared in this class
    // There are (m_wNumInstanceFields - m_pParentClass->m_wNumInstanceFields + m_wNumStaticFields) entries
    // in this array
    FieldDesc *m_pFieldDescList;


    // Number of elements in pInterfaces or pBuildingInterfaceList (depending on whether the class
    DWORD   m_dwAttrClass;
    DWORD   m_VMFlags;

    BYTE    m_MethodHash[METHOD_HASH_BYTES];

    SecurityProperties *m_pSecProps ;

    mdTypeDef m_cl; // CL is valid only in the context of the module (and its scope)
    

	MethodDescChunk		*m_pChunks;

    WORD    m_wThreadStaticOffset;  // Offset which points to the TLS storage
    WORD    m_wContextStaticOffset; // Offset which points to the CLS storage
    WORD    m_wThreadStaticsSize;   // Size of TLS fields 
    WORD    m_wContextStaticsSize;  // Size of CLS fields

    OBJECTHANDLE   m_ExposedClassObject;
    LPVOID         m_pComData;  // com specific data

    // If a class has special attribute declarations that affect how (where) it
    // should be instantiated, they are stored here.  This is opaque unless you
    // compiler ctxmgr.h
    OpaqueCtxInfo  m_OpaqueCtxInfo;

	DEFINE_STD_FILL_FUNCS(EEClass)
};

class Crst
{
    public:

        CRITICAL_SECTION    m_criticalsection;
//#ifdef _DEBUG
        char                m_tag[20];          // descriptive string
        enum CrstLevel { Low };
        CrstLevel           m_crstlevel;        // what level is the crst in?
        DWORD               m_holderthreadid;   // current holder (or NULL)
        UINT                m_entercount;       // # of unmatched Enters
        BOOL                m_fAllowReentrancy; // can m_entercount > 1?
        Crst               *m_next;             // link for global linked list
        Crst               *m_prev;             // link for global linked list
//#endif //_DEBUG

//#ifdef _DEBUG
        // This Crst serves as a head-node for double-linked list of crsts.
        // We use its embedded critical-section to guard insertion and
        // deletion into this list.
        //static Crst m_DummyHeadCrst;
//#endif
	DEFINE_STD_FILL_FUNCS(Crst)
};

class UnlockedLoaderHeap
{
public:
    DWORD_PTR vtbl;
    // Linked list of VirtualAlloc'd pages
    LoaderHeapBlock *   m_pFirstBlock;

    // Allocation pointer in current block
    BYTE *              m_pAllocPtr;

    // Points to the end of the committed region in the current block
    BYTE *              m_pPtrToEndOfCommittedRegion;
    BYTE *              m_pEndReservedRegion;

    LoaderHeapBlock *   m_pCurBlock;

    // When we need to VirtualAlloc() MEM_RESERVE a new set of pages, number of bytes to reserve
    DWORD               m_dwReserveBlockSize;

    // When we need to commit pages from our reserved list, number of bytes to commit at a time
    DWORD               m_dwCommitBlockSize;

    //static DWORD        m_dwSystemPageSize;

    // Created by in-place new?
    BOOL                m_fInPlace;
    // Release memory on destruct
    BOOL                m_fReleaseMemory;

    // Range list to record memory ranges in
    RangeList *         m_pRangeList;

    DWORD               m_dwTotalAlloc;
public:
//#ifdef _DEBUG
    DWORD               m_dwDebugWastedBytes;
//#endif

	DEFINE_STD_FILL_FUNCS(UnlockedLoaderHeap)
};

typedef struct LookupMap
{
    // This is not actually a pointer to the beginning of the allocated memory, but instead a pointer
    // to &pTable[-MinIndex].  Thus, if we know that this LookupMap is the correct one, simply index
    // into it.
    void **             pTable;
    struct LookupMap *  pNext;
    DWORD               dwMaxIndex;
    DWORD *             pdwBlockSize; // These all point to the same block size
    
	DEFINE_STD_FILL_FUNCS(LookupMap)
} LookupMap_t;

struct LoaderHeap : public UnlockedLoaderHeap
{
public:
    CRITICAL_SECTION    m_CriticalSection;
	DEFINE_STD_FILL_FUNCS(LoaderHeap)
};

class Bucket
{
public:
    ULONG_PTR m_rgKeys[4];
    ULONG_PTR m_rgValues[4];
#define VALUE_MASK (sizeof(LPVOID) == 4 ? 0x7FFFFFFF : 0x7FFFFFFFFFFFFFFF)
    
	DEFINE_STD_FILL_FUNCS(Bucket)
};

class HashMap
{
public:
	#ifdef PROFILE
		unsigned	m_cbRehash;    // number of times rehashed
		unsigned	m_cbRehashSlots; // number of slots that were rehashed
		unsigned	m_cbObsoleteTables;
		unsigned	m_cbTotalBuckets;
		unsigned	m_cbInsertProbesGt8; // inserts that needed more than 8 probes
		LONG		m_rgLookupProbes[20]; // lookup probes
		UPTR		maxFailureProbe; // cost of failed lookup

	#endif

	//#ifdef _DEBUG
		bool			m_fInSyncCode; // test for non-synchronus access
	//#endif

	Bucket*			m_pObsoleteTables;	// list of obsolete tables
	Compare*		m_pCompare;			// compare object to be used in lookup
	unsigned		m_iPrimeIndex;		// current size (index into prime array)
	Bucket*			m_rgBuckets;		// array of buckets

	// track the number of inserts and deletes
	unsigned		m_cbPrevSlotsInUse;
	unsigned		m_cbInserts;
	unsigned		m_cbDeletes;
	// mode of operation, synchronus or single user
	unsigned		m_fSyncMode;

	DEFINE_STD_FILL_FUNCS(HashMap)
};

struct PtrHashMap
{
    HashMap m_HashMap;
    
	DEFINE_STD_FILL_FUNCS(PtrHashMap)
};

#define JUMP_ALLOCATE_SIZE 8

class Module
{
 public:

    WCHAR                   m_wszSourceFile[MAX_PATH];
    DWORD                   m_dwSourceFile;

//#ifdef _DEBUG
	// Force verification even if it's turned off
    BOOL                    m_fForceVerify;
//#endif

	PEFile					*m_file;
	PEFile					*m_zapFile;

	BYTE					*m_ilBase;

    IMDInternalImport       *m_pMDImport;
    IMetaDataEmit           *m_pEmitter;
    IMetaDataImport         *m_pImporter;
    IMetaDataDebugImport    *m_pDebugImport;
    IMetaDataHelper         *m_pHelper;
    IMetaDataDispenserEx    *m_pDispenser;

    MethodDesc              *m_pDllMain;

    enum {
        INITIALIZED					= 0x0001,
        HAS_CRITICAL_SECTION		= 0x0002,
		IS_IN_MEMORY				= 0x0004,
		IS_REFLECTION				= 0x0008,
		IS_PRELOAD					= 0x0010,
		SUPPORTS_UPDATEABLE_METHODS	= 0x0020,
		CLASSES_FREED				= 0x0040,
		IS_PEFILE					= 0x0080,
		IS_PRECOMPILE				= 0x0100,
		IS_EDIT_AND_CONTINUE		= 0x0200,
    };

    DWORD                   m_dwFlags;

    // Linked list of VASig cookie blocks: protected by m_pStubListCrst
    VASigCookieBlock        *m_pVASigCookieBlock;

    Assembly                *m_pAssembly;
	mdFile					m_moduleRef;
	int						m_dwModuleIndex;

    Crst                   *m_pCrst;
    BYTE                    m_CrstInstance[sizeof(Crst)];

    // If a TypeLib is ever required for this module, cache the pointer here.
    ITypeLib                *m_pITypeLib;
    ITypeLib                *m_pITypeLibTCE;

    // May point to the default instruction decoding table, in which
    // case we should not free it
    void *                  m_pInstructionDecodingTable;

    MethodDescChunk         *m_pChunks;

    MethodTable             *m_pMethodTable;

	// Debugging symbols reader interface. This will only be
	// initialized if needed, either by the debugging subsystem or for
	// an exception.
	ISymUnmanagedReader     *m_pISymUnmanagedReader;

    // Next module loaded by the same classloader (all modules loaded by the same classloader
    // are linked through this field).
    Module *				m_pNextModule;

	// Base DLS index for classes in this module
	DWORD					m_dwBaseClassIndex;

	// Range of preloaded image, to facilitate proper cleanup
	void					*m_pPreloadRangeStart;
	void					*m_pPreloadRangeEnd;

	// Table of thunks for unmanaged vtables
    BYTE *					m_pThunkTable;

    // Exposed object of Class object for the module
    OBJECTHANDLE            m_ExposedModuleObject;

    LoaderHeap *			m_pLookupTableHeap;
    BYTE					m_LookupTableHeapInstance[sizeof(LoaderHeap)]; // For in-place new()

    // For protecting additions to the heap
    Crst                   *m_pLookupTableCrst;
    BYTE                    m_LookupTableCrstInstance[sizeof(Crst)];

    // Linear mapping from TypeDef token to MethodTable *
    LookupMap 				m_TypeDefToMethodTableMap;
    DWORD					m_dwTypeDefMapBlockSize;

    // Linear mapping from TypeRef token to TypeHandle *
    LookupMap 				m_TypeRefToMethodTableMap;

    DWORD					m_dwTypeRefMapBlockSize;

    // Linear mapping from MethodDef token to MethodDesc *
    LookupMap 				m_MethodDefToDescMap;
    DWORD					m_dwMethodDefMapBlockSize;

    // Linear mapping from FieldDef token to FieldDesc*
    LookupMap 				m_FieldDefToDescMap;
    DWORD					m_dwFieldDefMapBlockSize;

    // Linear mapping from MemberRef token to MethodDesc*, FieldDesc*
    LookupMap 				m_MemberRefToDescMap;
    DWORD					m_dwMemberRefMapBlockSize;

    // Mapping from File token to Module *
    LookupMap 				m_FileReferencesMap;
    DWORD					m_dwFileReferencesMapBlockSize;

    // Mapping of AssemblyRef token to Assembly *
    LookupMap 				m_AssemblyReferencesMap;
    DWORD					m_dwAssemblyReferencesMapBlockSize;

    // Object handle cache for declarative demands
    PtrHashMap              m_LinktimeDemandsHashMap;

    // This buffer is used to jump to the prestub in preloaded modules
    BYTE					m_PrestubJumpStub[JUMP_ALLOCATE_SIZE];

    // This buffer is used to jump to the ndirect import stub in preloaded modules
    BYTE					m_NDirectImportJumpStub[JUMP_ALLOCATE_SIZE];

	DEFINE_STD_FILL_FUNCS(Module)
};

typedef struct _dummyCOR { BYTE b; } *HCORMODULE;

class PEFile
{
  public:

    WCHAR               m_wszSourceFile[MAX_PATH];

	HMODULE				m_hModule;
	HCORMODULE			m_hCorModule;
	BYTE				*m_base;
    IMAGE_NT_HEADERS	*m_pNT;
	IMAGE_COR20_HEADER	*m_pCOR;

	PEFile				*m_pNext;
	BOOL				m_orphan;

	DEFINE_STD_FILL_FUNCS(PEFile)
};

typedef struct _rangesection
{
    DWORD_PTR    LowAddress;
    DWORD_PTR    HighAddress;

    DWORD_PTR    pjit;
    DWORD_PTR    ptable;

    DWORD_PTR    pright;
    DWORD_PTR    pleft;
	DEFINE_STD_FILL_FUNCS(RangeSection)
} RangeSection;

typedef struct _heapList {
    DWORD_PTR hpNext;
    DWORD_PTR pHeap;
    DWORD   startAddress;
    DWORD   endAddress;
    volatile DWORD  changeStart;
    volatile DWORD  changeEnd;
    DWORD   mapBase;
    DWORD   pHdrMap;
    DWORD   cBlocks;
	DEFINE_STD_FILL_FUNCS(HeapList)
} HeapList;

struct COR_ILMETHOD_SECT_EH_FAT;
struct CORCOMPILE_METHOD_HEADER
{
    BYTE                        *gcInfo;
    COR_ILMETHOD_SECT_EH_FAT    *exceptionInfo;
    void                        *methodDesc;
    BYTE                        *fixupList;

	DEFINE_STD_FILL_FUNCS(CORCOMPILE_METHOD_HEADER)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\metadata.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a TypeDef using       *  
*    metadata API.                                                     *
*                                                                      *
\**********************************************************************/
// Caller should guard against exception
// !!! mdName should have at least mdNameLen WCHAR
static HRESULT NameForTypeDef(mdTypeDef tkTypeDef, IMetaDataImport *pImport,
                              WCHAR *mdName)
{
    DWORD flags;
    ULONG nameLen;
    HRESULT hr = pImport->GetTypeDefProps(tkTypeDef, mdName,
                                          mdNameLen, &nameLen,
                                          &flags, NULL);
    if (hr != S_OK) {
        return hr;
    }

    if (!IsTdNested(flags)) {
        return hr;
    }
    mdTypeDef tkEnclosingClass;
    hr = pImport->GetNestedClassProps(tkTypeDef, &tkEnclosingClass);
    if (hr != S_OK) {
        return hr;
    }
    WCHAR *name = (WCHAR*)_alloca((nameLen+1)*sizeof(WCHAR));
    wcscpy (name, mdName);
    hr = NameForTypeDef(tkEnclosingClass,pImport,mdName);
    if (hr != S_OK) {
        return hr;
    }
    ULONG Len = wcslen (mdName);
    if (Len < mdNameLen-2) {
        mdName[Len++] = L'.';
        mdName[Len] = L'\0';
    }
    Len = mdNameLen-1 - Len;
    if (Len > nameLen) {
        Len = nameLen;
    }
    wcsncat (mdName,name,Len);
    return hr;
}

MDImportSet mdImportSet;

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the Module MD Importer given the name of the Module.         *
*                                                                      *
\**********************************************************************/
IMetaDataImport* MDImportForModule (WCHAR* moduleName)
{
    return mdImportSet.GetImport(moduleName);
}

// Release memory
void MDImportSet::Destroy()
{
    DestroyInternal(root);
}

void MDImportSet::DestroyInternal(MDIMPORT *node)
{
    if (node == NULL)
        return;
    DestroyInternal(node->left);
    DestroyInternal(node->right);

    if (node->name)
        free (node->name);
    if (node->pImport)
        node->pImport->Release();
    free (node);
}

// Search the BST to get IMetaDataImport for file moduleName.
// If not exist yet, add node and create one.
IMetaDataImport *MDImportSet::GetImport(WCHAR *moduleName)
{
    MDIMPORT **pNode = &root;
    while (*pNode)
    {
        int value = _wcsicmp(moduleName, (*pNode)->name);
        if (value < 0)
            pNode = &((*pNode)->left);
        else if (value > 0)
            pNode = &((*pNode)->right);
        else
            return (*pNode)->pImport;
    }
    
    *pNode = (MDIMPORT *)malloc (sizeof (MDIMPORT));
    if (*pNode == NULL)
    {
        dprintf ("Not enough memory\n");
        return NULL;
    }
    MDIMPORT *curNode = *pNode;
    curNode->left = NULL;
    curNode->right = NULL;
    curNode->pImport = NULL;
    curNode->name = (WCHAR *)malloc ((wcslen(moduleName)+1)*sizeof(WCHAR));
    if (curNode->name == NULL)
    {
        dprintf ("Not enough memory\n");
        return NULL;
    }
    wcscpy (curNode->name, moduleName);

    if (pDisp == NULL)
        return NULL;
    IMetaDataImport *pImport;
    // open scope and get import pointer
    HRESULT hr = pDisp->OpenScope(moduleName, ofRead, IID_IMetaDataImport,
                                  (IUnknown**)&pImport);
    if (FAILED (hr))
        return NULL;
    
    curNode->pImport = pImport;
    
    return curNode->pImport;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the name for a metadata token given an importer.             *
*                                                                      *
\**********************************************************************/
HRESULT NameForToken(mdTypeDef mb, IMetaDataImport *pImport, WCHAR *mdName,
                     bool bClassName)
{
    mdName[0] = L'\0';
    if ((mb & 0xff000000) != mdtTypeDef
        && (mb & 0xff000000) != mdtFieldDef
        && (mb & 0xff000000) != mdtMethodDef)
    {
        //dprintf ("unsupported\n");
        return E_FAIL;
    }
    
    HRESULT hr;
    
    __try
        {
            static WCHAR name[MAX_CLASSNAME_LENGTH];
            if ((mb & 0xff000000) == mdtTypeDef)
            {
                hr = NameForTypeDef (mb, pImport, mdName);
            }
            else if ((mb & 0xff000000) ==  mdtFieldDef)
            {
                mdTypeDef mdClass;
                ULONG size;
                hr = pImport->GetMemberProps(mb, &mdClass,
                                             name, sizeof(name)/sizeof(WCHAR)-1, &size,
                                             NULL, NULL, NULL, NULL,
                                             NULL, NULL, NULL, NULL);
                if (SUCCEEDED (hr))
                {
                    if (mdClass != mdTypeDefNil && bClassName)
                    {
                        hr = NameForTypeDef (mdClass, pImport, mdName);
                        wcscat (mdName, L".");
                    }
                    name[size] = L'\0';
                    wcscat (mdName, name);
                }
            }
            else if ((mb & 0xff000000) ==  mdtMethodDef)
            {
                mdTypeDef mdClass;
                ULONG size;
                hr = pImport->GetMethodProps(mb, &mdClass,
                                             name, sizeof(name)/sizeof(WCHAR)-1, &size,
                                             NULL, NULL, NULL, NULL, NULL);
                if (SUCCEEDED (hr))
                {
                    if (mdClass != mdTypeDefNil && bClassName)
                    {
                        hr = NameForTypeDef (mdClass, pImport, mdName);
                        wcscat (mdName, L".");
                    }
                    name[size] = L'\0';
                    wcscat (mdName, name);
                }
            }
            else
            {
                ExtOut ("Unsupported token type\n");
                hr = E_FAIL;
            }
        }
    __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //dprintf ("Metadata operation failure\n");
            hr = E_FAIL;
        }
    return hr;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a metadata token      *  
*    using metadata API.                                               *
*                                                                      *
\**********************************************************************/
void NameForToken(WCHAR* moduleName, mdTypeDef mb, WCHAR *mdName,
                  bool bClassName)
{
#ifdef UNDER_CE
    mdName[0] = L'\0';
    wsprintf (mdName,
              L" mdToken: %08x (%ws)",
              mb,
              moduleName[0] ? moduleName : L"Unknown Module" );
    return;
#else
    mdName[0] = L'\0';
    if (moduleName[0] == L'\0' || mb == 0x2000000 || 
        (IsDumpFile() && wcsncmp (moduleName, L"Not Available", 13) == 0))
    {
        wsprintfW (mdName,
                   L" mdToken: %08x (%ws)",
                   mb,
                   moduleName[0] ? moduleName : L"Unknown Module" );
        return;
    }

    HRESULT hr = 0;
    IMetaDataImport *pImport = MDImportForModule(moduleName);
    hr = (pImport != NULL);
    if (pImport)
    {
        hr = NameForToken (mb, pImport, mdName, bClassName);
    }
    
    if (!SUCCEEDED (hr))
        wsprintfW (mdName,
                   L" mdToken: %08x (%ws)",
                   mb,
                   moduleName[0] ? moduleName : L"Unknown Module" );
#endif
}

#define STRING_BUFFER_LEN 1024

class MDInfo
{
public:
    MDInfo (WCHAR *fileName)
    {
        m_pImport = MDImportForModule(fileName);
        m_pSigBuf = NULL;
    }

    void GetMethodName(mdTypeDef token, CQuickBytes *fullName);

    LPCWSTR TypeDefName(mdTypeDef inTypeDef);
    LPCWSTR TypeRefName(mdTypeRef tr);
    LPCWSTR TypeDeforRefName(mdToken inToken);
private:
    // helper to init signature buffer
    void InitSigBuffer()
    {
        ((LPWSTR)m_pSigBuf->Ptr())[0] = L'\0';
    }

    HRESULT AddToSigBuffer(LPCWSTR string);

    void GetFullNameForMD(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob);
    HRESULT GetOneElementType(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb);

    IMetaDataImport *m_pImport;
	// Signature buffer.
	CQuickBytes		*m_pSigBuf;

	// temporary buffer for TypeDef or TypeRef name. Consume immediately
	// because other functions may overwrite it.
	static WCHAR			m_szTempBuf[MAX_CLASSNAME_LENGTH];

    static WCHAR            m_szName[MAX_CLASSNAME_LENGTH];
};

WCHAR MDInfo::m_szTempBuf[MAX_CLASSNAME_LENGTH];
WCHAR MDInfo::m_szName[MAX_CLASSNAME_LENGTH];

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the signiture of a metadata token *  
*    using metadata API.                                               *
*                                                                      *
\**********************************************************************/
void FullNameForMD(MethodDesc *pMD, CQuickBytes *fullName)
{
    DWORD_PTR dwAddr = pMD->m_MTAddr;

    MethodTable MT;
    MT.Fill (dwAddr);
    if (!CallStatus)
    {
        return;
    }
    WCHAR StringData[MAX_PATH+1];
    FileNameForMT (&MT, StringData);
    MDInfo mdInfo(StringData);

    mdInfo.GetMethodName(pMD->m_dwToken, fullName);
}

// Tables for mapping element type to text
WCHAR *g_wszMapElementType[] = 
{
    L"End",          // 0x0
    L"Void",         // 0x1
    L"Boolean",
    L"Char", 
    L"I1",
    L"UI1",
    L"I2",           // 0x6
    L"UI2",
    L"I4",
    L"UI4",
    L"I8",
    L"UI8",
    L"R4",
    L"R8",
    L"String",
    L"Ptr",          // 0xf
    L"ByRef",        // 0x10
    L"ValueClass",
    L"Class",
    L"CopyCtor",
    L"MDArray",      // 0x14
    L"GENArray",
    L"TypedByRef",
    L"VALUEARRAY",
    L"I",
    L"U",
    L"R",            // 0x1a
    L"FNPTR",
    L"Object",
    L"SZArray",
    L"GENERICArray",
    L"CMOD_REQD",
    L"CMOD_OPT",
    L"INTERNAL",
};
 
WCHAR *g_wszCalling[] = 
{   
    L"[DEFAULT]",
    L"[C]",
    L"[STDCALL]",
    L"[THISCALL]",
    L"[FASTCALL]",
    L"[VARARG]",
    L"[FIELD]",
    L"[LOCALSIG]",
    L"[PROPERTY]",
    L"[UNMANAGED]",
};

void MDInfo::GetMethodName(mdTypeDef token, CQuickBytes *fullName)
{
    HRESULT hr;
    mdTypeDef memTypeDef;
    ULONG nameLen;
    DWORD flags;
    PCCOR_SIGNATURE pbSigBlob;
    ULONG ulSigBlob;
    ULONG ulCodeRVA;
    ULONG ulImplFlags;

    m_pSigBuf = fullName;
    InitSigBuffer();

    hr = m_pImport->GetMethodProps(token, &memTypeDef, 
                                   m_szTempBuf, MAX_CLASSNAME_LENGTH, &nameLen, 
                                   &flags, &pbSigBlob, &ulSigBlob, &ulCodeRVA, &ulImplFlags);
    if (FAILED (hr))
    {
        return;
    }
    
    m_szTempBuf[nameLen] = L'\0';
    m_szName[0] = L'\0';
    if (memTypeDef != mdTypeDefNil)
    {
        hr = NameForTypeDef (memTypeDef, m_pImport, m_szName);
        if (SUCCEEDED (hr)) {
            wcscat (m_szName, L".");
        }
    }
    wcscat (m_szName, m_szTempBuf);

    GetFullNameForMD(pbSigBlob, ulSigBlob);
}

inline bool isCallConv(unsigned sigByte, CorCallingConvention conv)
{
    return ((sigByte & IMAGE_CEE_CS_CALLCONV_MASK) == (unsigned) conv); 
}

#ifndef IfFailGoto
#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { goto LABEL; } } while (0)
#endif

#ifndef IfFailGo
#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)
#endif

#ifndef IfFailRet
#define IfFailRet(EXPR) do { hr = (EXPR); if(FAILED(hr)) { return (hr); } } while (0)
#endif

#ifndef _ASSERTE
#define _ASSERTE(expr)
#endif

void MDInfo::GetFullNameForMD(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob)
{
    ULONG       cbCur = 0;
    ULONG       cb;
    ULONG       ulData;
    ULONG       ulArgs;
    HRESULT     hr = NOERROR;

    cb = CorSigUncompressData(pbSigBlob, &ulData);
    AddToSigBuffer (g_wszCalling[ulData & IMAGE_CEE_CS_CALLCONV_MASK]);
    if (cb>ulSigBlob) 
        goto ErrExit;
    cbCur += cb;
    ulSigBlob -= cb;

    if (ulData & IMAGE_CEE_CS_CALLCONV_HASTHIS)
        AddToSigBuffer ( L" [hasThis]");
    if (ulData & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)
        AddToSigBuffer ( L" [explicit]");

    AddToSigBuffer (L" ");
    if ( isCallConv(ulData,IMAGE_CEE_CS_CALLCONV_FIELD) )
    {
        // display field type
        if (FAILED(hr = GetOneElementType(&pbSigBlob[cbCur], ulSigBlob, &cb)))
            goto ErrExit;
        AddToSigBuffer ( L" ");
        AddToSigBuffer ( m_szName);
        if (cb>ulSigBlob) 
            goto ErrExit;
        cbCur += cb;
        ulSigBlob -= cb;
    }
    else 
    {
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulArgs);
        if (cb>ulSigBlob) 
            goto ErrExit;
        cbCur += cb;
        ulSigBlob -= cb;

        if (ulData != IMAGE_CEE_CS_CALLCONV_LOCAL_SIG)
        {
            // display return type when it is not a local varsig
            if (FAILED(hr = GetOneElementType(&pbSigBlob[cbCur], ulSigBlob, &cb)))
                goto ErrExit;
            AddToSigBuffer (L" ");
            AddToSigBuffer (m_szName);
            AddToSigBuffer ( L"(");
            if (cb>ulSigBlob) 
                goto ErrExit;
            cbCur += cb;
            ulSigBlob -= cb;
        }

        ULONG       i = 0;
        while (i < ulArgs && ulSigBlob > 0)
        {
            ULONG       ulData;

            // Handle the sentinal for varargs because it isn't counted in the args.
            CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
            ++i;

            if (FAILED(hr = GetOneElementType(&pbSigBlob[cbCur], ulSigBlob, &cb)))
                goto ErrExit;
            if (i != ulArgs) {
                AddToSigBuffer ( L",");
            }
            if (cb>ulSigBlob) 
                goto ErrExit;

            cbCur += cb;
            ulSigBlob -= cb;
        }
        AddToSigBuffer ( L")");
    }

    // Nothing consumed but not yet counted.
    cb = 0;

ErrExit:
    // We should have consumed all signature blob.  If not, dump the sig in hex.
    //  Also dump in hex if so requested.
    if (ulSigBlob != 0)
    {
        // Did we not consume enough, or try to consume too much?
        if (cb > ulSigBlob)
            ExtOut("ERROR IN SIGNATURE:  Signature should be larger.\n");
        else
        if (cb < ulSigBlob)
        {
            ExtOut("ERROR IN SIGNATURE:  Not all of signature blob was consumed.  %d byte(s) remain\n", ulSigBlob);
        }
    }
    if (FAILED(hr))
        ExtOut("ERROR!! Bad signature blob value!");
    return;
}

LPCWSTR MDInfo::TypeDefName(mdTypeDef inTypeDef)
{
    HRESULT hr;

    hr = m_pImport->GetTypeDefProps(
                            // [IN] The import scope.
        inTypeDef,              // [IN] TypeDef token for inquiry.
        m_szTempBuf,            // [OUT] Put name here.
        MAX_CLASSNAME_LENGTH,      // [IN] size of name buffer in wide chars.
        NULL,                   // [OUT] put size of name (wide chars) here.
        NULL,                   // [OUT] Put flags here.
        NULL);                  // [OUT] Put base class TypeDef/TypeRef here.

    if (FAILED(hr)) return (L"NoName");
    return (m_szTempBuf);
} // LPCWSTR MDInfo::TypeDefName()
LPCWSTR MDInfo::TypeRefName(mdTypeRef tr)
{
    HRESULT hr;
    
    hr = m_pImport->GetTypeRefProps(           
        tr,                 // The class ref token.
        NULL,               // Resolution scope.
        m_szTempBuf,             // Put the name here.
        MAX_CLASSNAME_LENGTH,             // Size of the name buffer, wide chars.
        NULL);              // Put actual size of name here.
    if (FAILED(hr)) return (L"NoName");

    return (m_szTempBuf);
} // LPCWSTR MDInfo::TypeRefName()

LPCWSTR MDInfo::TypeDeforRefName(mdToken inToken)
{
    if (RidFromToken(inToken))
    {
        if (TypeFromToken(inToken) == mdtTypeDef)
            return (TypeDefName((mdTypeDef) inToken));
        else if (TypeFromToken(inToken) == mdtTypeRef)
            return (TypeRefName((mdTypeRef) inToken));
        else
            return (L"[InvalidReference]");
    }
    else
        return (L"");
} // LPCWSTR MDInfo::TypeDeforRefName()


HRESULT MDInfo::AddToSigBuffer(LPCWSTR string)
{
    HRESULT     hr;
    IfFailRet( m_pSigBuf->ReSize((wcslen((LPWSTR)m_pSigBuf->Ptr()) + wcslen(string) + 1) * sizeof(WCHAR)));
    wcscat((LPWSTR)m_pSigBuf->Ptr(), string);
    return NOERROR;
}

HRESULT MDInfo::GetOneElementType(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb)
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       cbCur = 0;
    ULONG       cb;
    ULONG       ulData;
    ULONG       ulTemp;
    int         iTemp;
    mdToken     tk;

    cb = CorSigUncompressData(pbSigBlob, &ulData);
    cbCur += cb;

    // Handle the modifiers.
    if (ulData & ELEMENT_TYPE_MODIFIER)
    {
        if (ulData == ELEMENT_TYPE_SENTINEL)
            IfFailGo(AddToSigBuffer(L"<ELEMENT_TYPE_SENTINEL> "));
        else if (ulData == ELEMENT_TYPE_PINNED)
            IfFailGo(AddToSigBuffer(L"PINNED "));
        else
        {
            hr = E_FAIL;
            goto ErrExit;
        }
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;
        goto ErrExit;
    }

    // Handle the underlying element types.
    if (ulData >= ELEMENT_TYPE_MAX) 
    {
        hr = E_FAIL;
        goto ErrExit;
    }
    while (ulData == ELEMENT_TYPE_PTR || ulData == ELEMENT_TYPE_BYREF)
    {
        IfFailGo(AddToSigBuffer(g_wszMapElementType[ulData]));
        IfFailGo(AddToSigBuffer(L" "));
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
        cbCur += cb;
    }
    IfFailGo(AddToSigBuffer(g_wszMapElementType[ulData]));
    if (CorIsPrimitiveType((CorElementType)ulData) || 
        ulData == ELEMENT_TYPE_TYPEDBYREF ||
        ulData == ELEMENT_TYPE_OBJECT ||
        ulData == ELEMENT_TYPE_I ||
        ulData == ELEMENT_TYPE_U ||
        ulData == ELEMENT_TYPE_R)
    {
        // If this is a primitive type, we are done
        goto ErrExit;
    }

    AddToSigBuffer(L" ");
    if (ulData == ELEMENT_TYPE_VALUETYPE || 
        ulData == ELEMENT_TYPE_CLASS || 
        ulData == ELEMENT_TYPE_CMOD_REQD ||
        ulData == ELEMENT_TYPE_CMOD_OPT)
    {
        cb = CorSigUncompressToken(&pbSigBlob[cbCur], &tk);
        cbCur += cb;

        // get the name of type ref. Don't care if truncated
        if (TypeFromToken(tk) == mdtTypeDef || TypeFromToken(tk) == mdtTypeRef)
        {
            IfFailGo(AddToSigBuffer(TypeDeforRefName(tk)));
        }
        else
        {
            _ASSERTE(TypeFromToken(tk) == mdtTypeSpec);
            WCHAR buffer[9];
            _itow (tk, buffer, 16);
            IfFailGo(AddToSigBuffer(buffer));
        }
        if (ulData == ELEMENT_TYPE_CMOD_REQD ||
            ulData == ELEMENT_TYPE_CMOD_OPT)
        {
            IfFailGo(AddToSigBuffer(L" "));
            if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
                goto ErrExit;
            cbCur += cb;
        }

        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_VALUEARRAY)
    {
        // display the base type of SDARRAY
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;

        // display the size of SDARRAY
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
        cbCur += cb;
        WCHAR buffer[9];
        _itow (ulData,buffer,10);
        IfFailGo(AddToSigBuffer(L" "));
        IfFailGo(AddToSigBuffer(buffer));
        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_SZARRAY)
    {
        // display the base type of SZARRAY or GENERICARRAY
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;
        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_FNPTR) 
    {
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
        cbCur += cb;
        if (ulData & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)
            IfFailGo(AddToSigBuffer(L"[explicit] "));
        if (ulData & IMAGE_CEE_CS_CALLCONV_HASTHIS)
            IfFailGo(AddToSigBuffer(L"[hasThis] "));

        IfFailGo(AddToSigBuffer(g_wszCalling[ulData & IMAGE_CEE_CS_CALLCONV_MASK]));

            // Get number of args
        ULONG numArgs;
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &numArgs);
        cbCur += cb;

            // do return type
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;

        IfFailGo(AddToSigBuffer(L"("));
        while (numArgs > 0) 
        {
            if (cbCur > ulSigBlob)
                goto ErrExit;
            if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
                goto ErrExit;
            cbCur += cb;
            --numArgs;
            if (numArgs > 0) 
                IfFailGo(AddToSigBuffer(L","));
        }
        IfFailGo(AddToSigBuffer(L")"));
        goto ErrExit;
    }

    if(ulData != ELEMENT_TYPE_ARRAY) return E_FAIL;

    // display the base type of SDARRAY
    if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
        goto ErrExit;
    cbCur += cb;

    IfFailGo(AddToSigBuffer(L" "));
    // display the rank of MDARRAY
    cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
    cbCur += cb;
    WCHAR buffer[9];
    _itow (ulData, buffer, 10);
    IfFailGo(AddToSigBuffer(buffer));
    if (ulData == 0)
        // we are done if no rank specified
        goto ErrExit;

    IfFailGo(AddToSigBuffer(L" "));
    // how many dimensions have size specified?
    cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
    cbCur += cb;
    _itow (ulData, buffer, 10);
    IfFailGo(AddToSigBuffer(buffer));
    if (ulData == 0) {
        IfFailGo(AddToSigBuffer(L" "));
    }
    while (ulData)
    {

        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulTemp);
        _itow (ulTemp, buffer, 10);
        IfFailGo(AddToSigBuffer(buffer));
        IfFailGo(AddToSigBuffer(L" "));
        cbCur += cb;
        ulData--;
    }
    // how many dimensions have lower bounds specified?
    cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
    cbCur += cb;
    _itow (ulData, buffer, 10);
    IfFailGo(AddToSigBuffer(buffer));
    while (ulData)
    {

        cb = CorSigUncompressSignedInt(&pbSigBlob[cbCur], &iTemp);
        _itow (iTemp, buffer, 10);
        IfFailGo(AddToSigBuffer(buffer));
        IfFailGo(AddToSigBuffer(L" "));
        cbCur += cb;
        ulData--;
    }
    
ErrExit:
    if (cbCur > ulSigBlob)
        hr = E_FAIL;
    *pcb = cbCur;
    return hr;
}

#if 0
enum CorInfoGCType
{
    TYPE_GC_NONE,   // no embedded objectrefs   
    TYPE_GC_REF,    // Is an object ref 
    TYPE_GC_BYREF,  // Is an interior pointer - promote it but don't scan it    
    TYPE_GC_OTHER   // requires type-specific treatment 
};  

// uncompress encoded element type. throw away any custom modifier prefixes along
// the way.
FORCEINLINE CorElementType CorSigEatCustomModifiersAndUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    while (ELEMENT_TYPE_CMOD_REQD == *pData || ELEMENT_TYPE_CMOD_OPT == *pData)
    {
        pData++;
        CorSigUncompressToken(pData);
    }
    return (CorElementType)*pData++;
}

// CorSig helpers which won't overflow your buffer

inline ULONG CorSigCompressDataSafe(ULONG iLen, BYTE *pDataOut, BYTE *pDataMax)
{
    BYTE buffer[4];
    ULONG result = CorSigCompressData(iLen, buffer);
    if (pDataOut + result < pDataMax)
        pDataMax = pDataOut + result;
	if (pDataMax > pDataOut)
		CopyMemory(pDataOut, buffer, pDataMax - pDataOut);
    return result;
}

inline ULONG CorSigCompressTokenSafe(mdToken tk, BYTE *pDataOut, BYTE *pDataMax)
{
    BYTE buffer[4];
    ULONG result = CorSigCompressToken(tk, buffer);
    if (pDataOut + result < pDataMax)
        pDataMax = pDataOut + result;
	if (pDataMax > pDataOut)
		CopyMemory(pDataOut, buffer, pDataMax - pDataOut);
    return result;
}

inline ULONG CorSigCompressSignedIntSafe(int iData, BYTE *pDataOut, BYTE *pDataMax)
{
    BYTE buffer[4];
    ULONG result = CorSigCompressSignedInt(iData, buffer);
    if (pDataOut + result < pDataMax)
        pDataMax = pDataOut + result;
	if (pDataMax > pDataOut)
		CopyMemory(pDataOut, buffer, pDataMax - pDataOut);
    return result;
}

inline ULONG CorSigCompressElementTypeSafe(CorElementType et, 
                                           BYTE *pDataOut, BYTE *pDataMax)
{
    if (pDataMax > pDataOut)
        return CorSigCompressElementType(et, pDataOut);
    else
        return 1;
}

struct ElementTypeInfo {
#ifdef _DEBUG
    int            m_elementType;     
#endif
    int            m_cbSize;
    CorInfoGCType  m_gc         : 3;
    int            m_fp         : 1;
    int            m_enregister : 1;
    int            m_isBaseType : 1;

};

const ElementTypeInfo __gElementTypeInfo[] = {

#ifdef _DEBUG
#define DEFINEELEMENTTYPEINFO(etname, cbsize, gcness, isfp, inreg, base) {(int)(etname),cbsize,gcness,isfp,inreg,base},
#else
#define DEFINEELEMENTTYPEINFO(etname, cbsize, gcness, isfp, inreg, base) {cbsize,gcness,isfp,inreg,base},
#endif


// Meaning of columns:
//
//     name     - The checked build uses this to verify that the table is sorted
//                correctly. This is a lookup table that uses ELEMENT_TYPE_*
//                as an array index.
//
//     cbsize   - The byte size of this value as returned by SizeOf(). SPECIAL VALUE: -1
//                requires type-specific treatment.
//
//     gc       - 0    no embedded objectrefs
//                1    value is an objectref
//                2    value is an interior pointer - promote it but don't scan it
//                3    requires type-specific treatment
//
//
//     fp       - boolean: does this require special fpu treatment on return?
//
//     reg      - put in a register?
//
//                    name                         cbsize               gc      fp reg Base
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_END,            -1,             TYPE_GC_NONE, 0, 0,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VOID,           0,              TYPE_GC_NONE, 0, 0,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_BOOLEAN,        1,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CHAR,           2,              TYPE_GC_NONE, 0, 1,  1)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I1,             1,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U1,             1,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I2,             2,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U2,             2,              TYPE_GC_NONE, 0, 1,  1)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I4,             4,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U4,             4,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I8,             8,              TYPE_GC_NONE, 0, 0,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U8,             8,              TYPE_GC_NONE, 0, 0,  1)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_R4,             4,              TYPE_GC_NONE, 1, 0,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_R8,             8,              TYPE_GC_NONE, 1, 0,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_STRING,         sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_PTR,            sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  0)  

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_BYREF,          sizeof(LPVOID), TYPE_GC_BYREF, 0, 1, 0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VALUETYPE,      -1,             TYPE_GC_OTHER, 0, 0,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CLASS,          sizeof(LPVOID), TYPE_GC_REF,   0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VAR,            sizeof(LPVOID), TYPE_GC_REF,   0, 1,  0)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_ARRAY,          sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0)

// The following element used to be ELEMENT_TYPE_COPYCTOR, but it was removed, though the gap left.
//DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_COPYCTOR,       sizeof(LPVOID), TYPE_GC_BYREF, 0, 1,  0)       
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_ARRAY+1,        0,              TYPE_GC_NONE,  0, 0,  0)       

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_TYPEDBYREF,         sizeof(LPVOID)*2,TYPE_GC_BYREF, 0, 0,0)            
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VALUEARRAY,     -1,             TYPE_GC_OTHER, 0, 0, 0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I,              sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U,              sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_R,              8,              TYPE_GC_NONE, 1, 0,  1)


DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_FNPTR,          sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_OBJECT,         sizeof(LPVOID), TYPE_GC_REF, 0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_SZARRAY,        sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0)

// generic array have been removed. Fill the gap
//DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_GENERICARRAY,   sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0) 
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_SZARRAY+1,      0,              TYPE_GC_NONE, 0, 0,  0)       

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CMOD_REQD,      -1,             TYPE_GC_NONE,  0, 1,  0)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CMOD_OPT,       -1,             TYPE_GC_NONE,  0, 1,  0)       

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_INTERNAL,       sizeof(LPVOID), TYPE_GC_NONE,  0, 0,  0)       
};

//=========================================================================
// Indicates whether an argument is to be put in a register using the
// default IL calling convention. This should be called on each parameter
// in the order it appears in the call signature. For a non-static method,
// this function should also be called once for the "this" argument, prior
// to calling it for the "real" arguments. Pass in a typ of ELEMENT_TYPE_CLASS.
//
//  *pNumRegistersUsed:  [in,out]: keeps track of the number of argument
//                       registers assigned previously. The caller should
//                       initialize this variable to 0 - then each call
//                       will update it.
//
//  typ:                 the signature type
//  structSize:          for structs, the size in bytes
//  fThis:               is this about the "this" pointer?
//  callconv:            see IMAGE_CEE_CS_CALLCONV_*
//  *pOffsetIntoArgumentRegisters:
//                       If this function returns TRUE, then this out variable
//                       receives the identity of the register, expressed as a
//                       byte offset into the ArgumentRegisters structure.
//
// 
//=========================================================================

BOOL IsArgumentInRegister(int   *pNumRegistersUsed,
                          BYTE   typ,
                          UINT32 structSize,
                          BOOL   fThis,
                          BYTE   callconv,
                          int   *pOffsetIntoArgumentRegisters)
{
    int dummy;
    if (pOffsetIntoArgumentRegisters == NULL)
    {
        pOffsetIntoArgumentRegisters = &dummy;
    }

#ifdef _X86_

    if ((*pNumRegistersUsed) == NUM_ARGUMENT_REGISTERS || (callconv == IMAGE_CEE_CS_CALLCONV_VARARG && !fThis))
    {
        return (FALSE);
    }
    else
    {

        if (__gElementTypeInfo[typ].m_enregister)
        {
            int registerIndex = (*pNumRegistersUsed)++;
            *pOffsetIntoArgumentRegisters = sizeof(ArgumentRegisters) - sizeof(UINT32)*(1+registerIndex);
            return (TRUE);
        }
        return (FALSE);
    }
#else
    return (FALSE);
#endif
}

CorElementType GetReturnTypeNormalized(PCCOR_SIGNATURE pSig)
{
    
    MetaSig *tempSig = (MetaSig *)this;
    tempSig->m_corNormalizedRetType = m_pRetType.Normalize(m_pModule);
    tempSig->m_fCacheInitted |= SIG_RET_TYPE_INITTED;
    return tempSig->m_corNormalizedRetType;
}

BOOL HasRetBuffArg(PCCOR_SIGNATURE pSig)
{
    CorElementType type = GetReturnTypeNormalized(pSig);
    return(type == ELEMENT_TYPE_VALUETYPE || type == ELEMENT_TYPE_TYPEDBYREF);
}


CorElementType GetElemType(PCCOR_SIGNATURE pSig)
{
    return (CorElementType) CorSigEatCustomModifiersAndUncompressElementType(pSig);
}

ULONG GetData(PCCOR_SIGNATURE &pSig)
{
    return CorSigUncompressData(pSig);
}

ULONG PeekData(PCCOR_SIGNATURE &pSig)
{
    PCCOR_SIGNATURE tmp = pSig;
    return CorSigUncompressData(pSig);
}


//------------------------------------------------------------------------
// Removes a compressed metadata token and returns it.
//------------------------------------------------------------------------
mdTypeRef GetToken(PCCOR_SIGNATURE &pSig)
{
    return CorSigUncompressToken(pSig);
}

// Skip a sub signature (as immediately follows an ELEMENT_TYPE_FNPTR).
VOID SigPointer::SkipSignature(PCCOR_SIGNATURE &pSig)
{
    // Skip calling convention;
    ULONG uCallConv = GetData(pSig);

    // Get arg count;
    ULONG cArgs = GetData(pSig);

    // Skip return type;
    SkipExactlyOne(pSig);

    // Skip args.
    while (cArgs) {
        SkipExactlyOne(pSig);
        cArgs--;
    }
}

VOID SkipExactlyOne(PCCOR_SIGNATURE &pSig)
{
    ULONG typ;

    typ = GetElemType();

    if (!CorIsPrimitiveType((CorElementType)typ))
    {
        switch (typ)
        {
            default:
                break;
            case ELEMENT_TYPE_VAR:
                GetData(pSig);      // Skip variable number
                break;
            case ELEMENT_TYPE_OBJECT:
            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_TYPEDBYREF:
            case ELEMENT_TYPE_U:
            case ELEMENT_TYPE_I:
            case ELEMENT_TYPE_R:
                break;

            case ELEMENT_TYPE_BYREF: //fallthru
            case ELEMENT_TYPE_PTR:
            case ELEMENT_TYPE_PINNED:
            case ELEMENT_TYPE_SZARRAY:
                SkipExactlyOne(pSig);              // Skip referenced type
                break;

            case ELEMENT_TYPE_VALUETYPE: //fallthru
            case ELEMENT_TYPE_CLASS:
                GetToken(pSig);          // Skip RID
                break;

            case ELEMENT_TYPE_VALUEARRAY: 
                SkipExactlyOne(pSig);         // Skip element type
                GetData(pSig);      // Skip array size
                break;

            case ELEMENT_TYPE_FNPTR: 
                SkipSignature(pSig);
                break;

            case ELEMENT_TYPE_ARRAY: 
                {
                    SkipExactlyOne(pSig);     // Skip element type
                    UINT32 rank = GetData(pSig);    // Get rank
                    if (rank)
                    {
                        UINT32 nsizes = GetData(pSig); // Get # of sizes
                        while (nsizes--)
                        {
                            GetData(pSig);           // Skip size
                        }

                        UINT32 nlbounds = GetData(pSig); // Get # of lower bounds
                        while (nlbounds--)
                        {
                            GetData(pSig);           // Skip lower bounds
                        }
                    }

                }
                break;

            case ELEMENT_TYPE_SENTINEL:
                break;
        }
    }
}

VOID Skip(PCCOR_SIGNATURE &pSig)
{
    SkipExactlyOne(pSig);

    if (PeekData(pSig) == ELEMENT_TYPE_SENTINEL)
        GetData(pSig);
}

ULONG GetCallingConvInfo(PCCOR_SIGNATURE &pSig)
{   
    return CorSigUncompressCallingConv(pSig);  
}   


//------------------------------------------------------------------------
// Returns # of stack bytes required to create a call-stack using
// the actual calling convention.
// Includes indication of "this" pointer since that's not reflected
// in the sig.
//------------------------------------------------------------------------
UINT SizeOfActualFixedArgStack(PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic)
{
    UINT cb = 0;
    int numregsused = 0;
    BOOL fIsVarArg = IsVarArg(szMetaSig);
    BYTE callconv  = GetCallingConvention(szMetaSig);

    if (!fIsStatic) {
        if (!IsArgumentInRegister(&numregsused, ELEMENT_TYPE_CLASS, 0, TRUE, callconv, NULL)) {
            cb += StackElemSize(sizeof(/*OBJECTREF*/ void *));
        }
    }

    /* @TODO
    if (msig.HasRetBuffArg())
        numregsused++;
    */

    if (fIsVarArg /*|| msig.IsTreatAsVarArg() */) {
        numregsused = NUM_ARGUMENT_REGISTERS;   // No other params in registers 
        cb += StackElemSize(sizeof(LPVOID));    // VASigCookie
    }

    CorElementType mtype;
    while (ELEMENT_TYPE_END != (mtype = msig.NextArgNormalized())) {
        UINT cbSize = msig.GetLastTypeSize();

        if (!IsArgumentInRegister(&numregsused, mtype, cbSize, FALSE, callconv, NULL))
        {
            cb += StackElemSize(cbSize);
        }
    }

        // Parameterized type passed as last parameter, but not mentioned in the sig
    if (msig.GetCallingConventionInfo() & CORINFO_CALLCONV_PARAMTYPE)
        if (!IsArgumentInRegister(&numregsused, ELEMENT_TYPE_I, sizeof(void*), FALSE, callconv, NULL))
            cb += sizeof(void*);

    return cb;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\strikeee.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _strikeEE_h
#define _strikeEE_h

#include "tst-stackwalk.h"

//typedef ULONG32 mdTypeDef;              // TypeDef in this scope
//typedef ULONG32 mdFieldDef;             // Field in this scope  
//typedef ULONG32 mdMethodDef;            // Method in this scope 

enum JitType {UNKNOWN=0, JIT, EJIT, PJIT};

// Support for stackwalker
struct JitMan
{
    DWORD_PTR    m_jitMan;
    JitType      m_jitType;
    RangeSection m_RS;
};

class Module;
class MethodTable;
class MethodDescChunk;
class InterfaceHintCache;
class Frame;
class Context;
class AppDomain;
class GCCoverageInfo;

#ifdef _IA64_
#define METHOD_IS_IL_FLAG   0x8000000000000000
#else
#define METHOD_IS_IL_FLAG   0x80000000
#endif

typedef struct _REGDISPLAY {
    PCONTEXT pContext;          // points to current Context; either
                                // returned by GetContext or provided
                                // at exception time.

    DWORD * pEdi;
    DWORD * pEsi;
    DWORD * pEbx;
    DWORD * pEdx;
    DWORD * pEcx;
    DWORD * pEax;

    DWORD * pEbp;
    DWORD   Esp;
    DWORD * pPC;                // processor neutral name

} REGDISPLAY;
typedef REGDISPLAY *PREGDISPLAY;

class BaseObject
{
    MethodTable    *m_pMethTab;
};

class Object : public BaseObject
{
    BYTE            m_Data[1];
};

class StringObject : public BaseObject
{
    DWORD   m_ArrayLength;
    DWORD   m_StringLength;
    WCHAR   m_Characters[1];
};


class TypeDesc {
public:
    // !!!! keep this for bit field;
    void* m_Type_begin;
    CorElementType  m_Type : 8;          // This is used to discriminate what kind of TypeDesc we are
class TypeDesc;
    
    DEFINE_STD_FILL_FUNCS(TypeDesc)
};


class TypeHandle 
{
public:
    union 
    {
        INT_PTR         m_asInt;        // we look at the low order bits 
        void*           m_asPtr;
        TypeDesc*       m_asTypeDesc;
        MethodTable*    m_asMT;
    };
};

class ReflectClass;

class ParamTypeDesc : public TypeDesc {
public:
        // the m_Type field in TypeDesc tell what kind of parameterized type we have
    MethodTable*    m_TemplateMT;       // The shared method table, some variants do not use this field (it is null)
    TypeHandle      m_Arg;              // The type that is being modifiedj
    ReflectClass    *m_ReflectClassObject;    // pointer back to the internal reflection Type object
    
    DEFINE_STD_FILL_FUNCS(ParamTypeDesc)
};


// Dynamically generated array class structure
class ArrayClass
{
public:
    ArrayClass *    m_pNext;            // next array class loaded by the same classloader
    // !!!! keep this for bit field;
    void* m_dwRank_begin;
    unsigned        m_dwRank      : 8;
    void* m_ElementType_begin;
    CorElementType  m_ElementType  : 8;  // Cache of element type in m_ElementTypeHnd
    TypeHandle      m_ElementTypeHnd;
    MethodDesc*     m_elementCtor; // if is a value class array and has a default constructor, this is it

	DEFINE_STD_FILL_FUNCS(ArrayClass)
};

struct SLink
{
    SLink* m_pNext;
};

struct SList
{
    SLink m_link;
    SLink* m_pHead;
    SLink* m_pTail;
};

struct SyncBlock;
class Thread;

struct WaitEventLink;

struct AwareLock
{
    HANDLE          m_SemEvent;
    LONG   m_MonitorHeld;
    ULONG           m_Recursion;
    DWORD_PTR       m_HoldingThread;

        //static Crst *AllocLockCrst;
        //static BYTE AllocLockCrstInstance[sizeof(Crst)];
	DEFINE_STD_FILL_FUNCS(AwareLock)
};

struct SyncBlock
{
    AwareLock  m_Monitor;                    // the actual monitor

    // If this object is exposed to COM, or it is a proxy over a COM object,
    // we keep some extra info here:
    DWORD_PTR       m_pComData;

    // Likewise, if this object has been exposed through a context boundary, we
    // keep a backpointer to its proxy.
    DWORD_PTR m_CtxProxy;

#ifndef UNDER_CE
    // And if the object has new fields added via EnC, this is a list of them
    DWORD_PTR m_pEnCInfo;
#endif

    // We thread two different lists through this link.  When the SyncBlock is
    // active, we create a list of waiting threads here.  When the SyncBlock is
    // released (we recycle them), the SyncBlockCache maintains a free list of
    // SyncBlocks here.
    //
    // We can't afford to use an SList<> here because we only want to burn
    // space for the minimum, which is the pointer within an SLink.
    SLink       m_Link;
    
	DEFINE_STD_FILL_FUNCS(SyncBlock)
};


struct SyncTableEntry
{
    DWORD_PTR   m_SyncBlock;
    DWORD_PTR   m_Object;
        //static SyncTableEntry* s_pSyncTableEntry;

	DEFINE_STD_FILL_FUNCS(SyncTableEntry)
};


// this class stores free sync blocks after they're allocated and
// unused

struct SyncBlockCache
{
	DWORD_PTR	m_pCleanupBlockList;	// list of sync blocks that need cleanup
    DWORD_PTR	m_FreeBlockList;        // list of free sync blocks
    Crst        m_CacheLock;            // cache lock
    DWORD       m_FreeCount;            // count of active sync blocks
    DWORD       m_ActiveCount;          // number active
    DWORD_PTR   m_SyncBlocks;       // Array of new SyncBlocks.
    DWORD       m_FreeSyncBlock;        // Next Free Syncblock in the array
    DWORD       m_FreeSyncTableIndex;   // free index in the SyncBlocktable
    DWORD       m_FreeSyncTableList;    // index of the free list of SyncBlock
                                        // Table entry
    DWORD       m_SyncTableSize;
    DWORD_PTR   m_OldSyncTables;    // Next old SyncTable

        //static SyncBlockCache* s_pSyncBlockCache;
        //static SyncBlockCache*& GetSyncBlockCache();
	DEFINE_STD_FILL_FUNCS(SyncBlockCache)
};

struct ThreadStore
{
    enum ThreadStoreState
    {
        TSS_Normal       = 0,
        TSS_ShuttingDown = 1,

    }              m_StoreState;
    HANDLE          m_TerminationEvent;

    // Critical section for adding and removing threads to the store
    Crst        m_Crst;

    // List of all the threads known to the ThreadStore (started & unstarted).
    SList  m_ThreadList;

    LONG        m_ThreadCount;
    LONG        m_UnstartedThreadCount;
    LONG        m_BackgroundThreadCount;
    LONG        m_PendingThreadCount;
    LONG        m_DeadThreadCount;

    // Space for the lazily-created GUID.
    GUID        m_EEGuid;
    BOOL        m_GuidCreated;

    DWORD_PTR     m_HoldingThread;
	DEFINE_STD_FILL_FUNCS(ThreadStore)
};

typedef HANDLE CorHandle;

//typedef DWORD_PTR IMetaDataEmit;
//typedef DWORD_PTR IMetaDataImport;
//typedef DWORD_PTR IMetaDataDispenserEx;
typedef DWORD_PTR ModuleSecurityDesc;
typedef DWORD_PTR Stub;

class Bucket;

struct LoaderHeapBlock
{
    struct LoaderHeapBlock *pNext;
    void *                  pVirtualAddress;
    DWORD                   dwVirtualSize;

	DEFINE_STD_FILL_FUNCS(LoaderHeapBlock)
};


class GCHeap;
struct alloc_context 
{
	BYTE*   alloc_ptr;
	BYTE*   alloc_limit;
    _int64  alloc_bytes;
	GCHeap* alloc_heap;
	DEFINE_STD_FILL_FUNCS(alloc_context )
};

struct plug
{
	BYTE *	skew[sizeof(DWORD) / sizeof(BYTE *)];
};

class gc_heap;

class heap_segment
{
public:
    BYTE*           allocated;
    BYTE*           committed;
    BYTE*           reserved;
	BYTE* 			used;
    BYTE*           mem;
    heap_segment*   next;
    BYTE*           plan_allocated;
	int				status;
	BYTE*			aliased;
	BYTE*			padx;

	gc_heap*        heap;

	BYTE*			pad0;
#if (SIZEOF_OBJHEADER % 8) != 0
	BYTE			pad1[8 - (SIZEOF_OBJHEADER % 8)];	// Must pad to quad word
#endif
	plug            plug;

	DEFINE_STD_FILL_FUNCS(heap_segment)
};

//no constructors because we initialize in make_generation
class generation
{
public:
	// Don't move these first two fields without adjusting the references
	// from the __asm in jitinterface.cpp.
	alloc_context   allocation_context;
    heap_segment*   allocation_segment;
    BYTE*           free_list;
    heap_segment*   start_segment;
    BYTE*           allocation_start;
    BYTE*           plan_allocation_start;
    BYTE*           last_gap;
    size_t          free_list_space;
    size_t          allocation_size;

	DEFINE_STD_FILL_FUNCS(generation)
};


#define NUMBERGENERATIONS 5

class CFinalize
{
public:

    Object** m_Array;
    Object** m_FillPointers[NUMBERGENERATIONS+2];
    Object** m_EndArray;
    
	DEFINE_STD_FILL_FUNCS(CFinalize)
};

class gc_heap
{
public:
    DWORD_PTR alloc_allocated;
    generation generation_table [NUMBERGENERATIONS];
    heap_segment* ephemeral_heap_segment;
    int g_max_generation;
    CFinalize* finalize_queue;
    
	DEFINE_STD_FILL_FUNCS(gc_heap)

    // These are class static variables that are present in the table (because
    // their index is used elsewhere), but weren't present in the original
    // Strike.
    void* g_heaps;
    void* n_heaps;
    void* verify_heap;
};

#define SIZEOF_OBJHEADER 4

class FieldDesc
{
public:
    MethodTable *m_pMTOfEnclosingClass; // Note, 2 bits of info are stolen from this pointer

    // !!!! Keep this for bit field
    void *m_mb_begin;
    unsigned m_mb               : 24; 

    // 8 bits...
    unsigned m_isStatic         : 1;
    unsigned m_isThreadLocal    : 1;
    unsigned m_isContextLocal   : 1;
    unsigned m_isRVA            : 1;
    unsigned m_prot             : 3;
    unsigned m_isDangerousAppDomainAgileField : 1; // Note: this is used in checked only

    void *m_dwOffset_begin;
    // Note: this has been as low as 22 bits in the past & seemed to be OK.
    // we can steal some more bits here if we need them.
    unsigned m_dwOffset         : 27;
    unsigned m_type             : 5;

    const char* m_debugName;
    
		DEFINE_STD_FILL_FUNCS(FieldDesc)
};

extern char *CorElementTypeName[];

typedef struct tagLockEntry
{
    tagLockEntry *pNext;    // next entry
    tagLockEntry *pPrev;    // prev entry
    DWORD dwULockID;
    DWORD dwLLockID;        // owning lock
    WORD wReaderLevel;      // reader nesting level
    
		DEFINE_STD_FILL_FUNCS(LockEntry)
} LockEntry;

class StackingAllocator
{
public:

    enum {
        MinBlockSize    = 128,
        MaxBlockSize    = 4096,
        InitBlockSize   = 512
    };

    // Blocks from which allocations are carved. Size is determined dynamically,
    // with upper and lower bounds of MinBlockSize and MaxBlockSize respectively
    // (though large allocation requests will cause a block of exactly the right
    // size to be allocated).
    struct Block
    {
        Block      *m_Next;         // Next oldest block in list
        unsigned    m_Length;       // Length of block excluding header
        char        m_Data[1];       // Start of user allocation space
    };

    // Whenever a checkpoint is requested, a checkpoint structure is allocated
    // (as a normal allocation) and is filled with information about the state
    // of the allocator prior to the checkpoint. When a Collapse request comes
    // in we can therefore restore the state of the allocator.
    // It is the address of the checkpoint structure that we hand out to the
    // caller of GetCheckpoint as an opaque checkpoint marker.
    struct Checkpoint
    {
        Block      *m_OldBlock;     // Head of block list before checkpoint
        unsigned    m_OldBytesLeft; // Number of free bytes before checkpoint
    };

    Block      *m_FirstBlock;       // Pointer to head of allocation block list
    char       *m_FirstFree;        // Pointer to first free byte in head block
    unsigned    m_BytesLeft;        // Number of free bytes left in head block
    Block      *m_InitialBlock;     // The first block is special, we never free it

//#ifdef _DEBUG
    unsigned    m_CheckpointDepth;
    unsigned    m_Allocs;
    unsigned    m_Checkpoints;
    unsigned    m_Collapses;
    unsigned    m_BlockAllocs;
    unsigned    m_MaxAlloc;
//#endif
#if 0
	DEFINE_STD_FILL_FUNCS(StackingAllocator)
#endif
};


class Thread
{
public:

    enum ThreadState
    {
        TS_Unknown                = 0x00000000,    // threads are initialized this way

        TS_StopRequested          = 0x00000001,    // process stop at next opportunity
        TS_GCSuspendPending       = 0x00000002,    // waiting to get to safe spot for GC
        TS_UserSuspendPending     = 0x00000004,    // user suspension at next opportunity
        TS_DebugSuspendPending    = 0x00000008,    // Is the debugger suspending threads?
        TS_GCOnTransitions        = 0x00000010,    // Force a GC on stub transitions (GCStress only)

        TS_LegalToJoin            = 0x00000020,    // Is it now legal to attempt a Join()
        TS_Hijacked               = 0x00000080,    // Return address has been hijacked

        TS_Background             = 0x00000200,    // Thread is a background thread
        TS_Unstarted              = 0x00000400,    // Thread has never been started
        TS_Dead                   = 0x00000800,    // Thread is dead

        TS_WeOwn                  = 0x00001000,    // Exposed object initiated this thread
        TS_CoInitialized          = 0x00002000,    // CoInitialize has been called for this thread
        TS_InSTA                  = 0x00004000,    // Thread hosts an STA
        TS_InMTA                  = 0x00008000,    // Thread is part of the MTA

        // Some bits that only have meaning for reporting the state to clients.
        TS_ReportDead             = 0x00010000,    // in WaitForOtherThreads()

        TS_SyncSuspended          = 0x00080000,    // Suspended via WaitSuspendEvent
        TS_DebugWillSync          = 0x00100000,    // Debugger will wait for this thread to sync
        TS_RedirectingEntryPoint  = 0x00200000,    // Redirecting entrypoint. Do not call managed entrypoint when set 

        TS_SuspendUnstarted       = 0x00400000,    // latch a user suspension on an unstarted thread

        TS_ThreadPoolThread       = 0x00800000,    // is this a threadpool thread?
        TS_TPWorkerThread         = 0x01000000,    // is this a threadpool worker thread? (if not, it is a threadpool completionport thread)

        TS_Interruptible          = 0x02000000,    // sitting in a Sleep(), Wait(), Join()
        TS_Interrupted            = 0x04000000,    // was awakened by an interrupt APC

        TS_AbortRequested         = 0x08000000,    // same as TS_StopRequested in order to trip the thread
        TS_AbortInitiated         = 0x10000000,    // set when abort is begun
        TS_UserStopRequested      = 0x20000000,    // set when a user stop is requested. This is different from TS_StopRequested
        TS_GuardPageGone          = 0x40000000,    // stack overflow, not yet reset.
        TS_Detached               = 0x80000000,    // Thread was detached by DllMain

        // @TODO: We need to reclaim the bits that have no concurrency issues (i.e. they are only 
        //         manipulated by the owning thread) and move them off to a different DWORD

        // We require (and assert) that the following bits are less than 0x100.
        TS_CatchAtSafePoint = (TS_UserSuspendPending | TS_StopRequested |
                               TS_GCSuspendPending | TS_DebugSuspendPending | TS_GCOnTransitions),
    };

    // Offsets for the following variables need to fit in 1 byte, so keep near
    // the top of the object.
    volatile ThreadState m_State;   // Bits for the state of the thread

    // If TRUE, GC is scheduled cooperatively with this thread.
    // NOTE: This "byte" is actually a boolean - we don't allow
    // recursive disables.
    volatile ULONG       m_fPreemptiveGCDisabled;

    DWORD                m_dwLockCount;
    
    Frame               *m_pFrame;  // The Current Frame

    DWORD       m_dwCachePin;

    // RWLock state 
    BOOL                 m_fNativeFrameSetup;
    LockEntry           *m_pHead;
    LockEntry            m_embeddedEntry;

    // on MP systems, each thread has its own allocation chunk so we can avoid
    // lock prefixes and expensive MP cache snooping stuff
    alloc_context        m_alloc_context;

    // Allocator used during marshaling for temporary buffers, much faster than
    // heap allocation.
    StackingAllocator    m_MarshalAlloc;
    INT32 m_ctxID;
    OBJECTHANDLE    m_LastThrownObjectHandle;
    
    struct HandlerInfo {
        // Note: the debugger assumes that m_pThrowable is a strong
        // reference so it can check it for NULL with preemptive GC
        // enabled.
	    OBJECTHANDLE    m_pThrowable;	// thrown exception
        Frame  *m_pSearchBoundary;		// topmost frame for current managed frame group
		union {
			EXCEPTION_REGISTRATION_RECORD *m_pBottomMostHandler; // most recent EH record registered
			EXCEPTION_REGISTRATION_RECORD *m_pCatchHandler;      // reg frame for catching handler
		};

        // for building stack trace info
        void *m_pStackTrace;              // pointer to stack trace storage (of type SystemNative::StackTraceElement)
        unsigned m_cStackTrace;           // size of stack trace storage
        unsigned m_dFrameCount;           // current frame in stack trace

        HandlerInfo *m_pPrevNestedInfo; // pointer to nested info if are handling nested exception

        DWORD * m_pShadowSP;            // Zero this after endcatch

        // pointer to original exception info for rethrow
        EXCEPTION_RECORD *m_pExceptionRecord;   
        CONTEXT *m_pContext;

#ifdef _X86_
        DWORD   m_dEsp;         // Esp when  fault occured, OR esp to restore on endcatch
#endif
    };
        
    DWORD          m_ResumeControlEIP;

    // The ThreadStore manages a list of all the threads in the system.  I
    // can't figure out how to expand the ThreadList template type without
    // making m_LinkStore public.
    SLink       m_LinkStore;

    // For N/Direct calls with the "setLastError" bit, this field stores
    // the errorcode from that call.
    DWORD       m_dwLastError;
    
    VOID          *m_pvHJRetAddr;             // original return address (before hijack)
    VOID         **m_ppvHJRetAddrPtr;         // place we bashed a new return address
    MethodDesc  *m_HijackedFunction;        // remember what we hijacked


    DWORD       m_Win32FaultAddress;
    DWORD       m_Win32FaultCode;


    LONG         m_UserInterrupt;

public:


//#ifdef _DEBUG
    ULONG  m_ulGCForbidCount;
//#endif

//#ifdef _DEBUG
#ifdef _X86_
#ifdef _MSC_VER
    // fs:[0] that was current at the time of the last COMPLUS_TRY
    // entry (fs:[0] is set on a per-function basis so the value
    // doesn't actually change when execution "crosses" the COMPLUS_TRY.
    LPVOID  m_pComPlusTryEntrySEHRecord;
    __int32 m_pComPlusTryEntryTryLevel;
#endif
#endif
//#endif

    // For suspends:
    HANDLE          m_SafeEvent;
    HANDLE          m_SuspendEvent;

    // For Object::Wait, Notify and NotifyAll, we use an Event inside the
    // thread and we queue the threads onto the SyncBlock of the object they
    // are waiting for.
    HANDLE          m_EventWait;
    SLink           m_LinkSB;
    SyncBlock      *m_WaitSB;

    // We maintain a correspondence between this object, the ThreadId and ThreadHandle
    // in Win32, and the exposed Thread object.
    HANDLE          m_ThreadHandle;
    DWORD           m_ThreadId;
    OBJECTHANDLE    m_ExposedObject;
	OBJECTHANDLE	m_StrongHndToExposedObject;

    DWORD           m_Priority;     // initialized to INVALID_THREAD_PRIORITY, set to actual priority when a 
                                    // thread does a busy wait for GC, reset to INVALID_THREAD_PRIORITY after wait is over 

    // serialize access to the Thread's state
    Crst            m_Crst;
    ULONG           m_ExternalRefCount;

	LONG			m_TraceCallCount;

    // The context within which this thread is executing.  As the thread crosses
    // context boundaries, the context mechanism adjusts this so it's always
    // current.
    // @TODO cwb: When we add COM+ 1.0 Context Interop, this should get moved out
    // of the Thread object and into its own slot in the TLS.
    Context        *m_Context;

    //---------------------------------------------------------------
    // Exception handler info
    //---------------------------------------------------------------
    HandlerInfo m_handlerInfo;

    //-----------------------------------------------------------
    // Inherited code-access security permissions for the thread.
    //-----------------------------------------------------------
    OBJECTHANDLE    m_pSecurityStack;

    //-----------------------------------------------------------
    // If the thread has wandered in from the outside this is
    // its Domain. This is temporary until domains are true contexts
    //-----------------------------------------------------------
    AppDomain      *m_pDomain;

    //---------------------------------------------------------------
    // m_debuggerWord1 is now shared between the CONTEXT * and the
    // lowest bit, which is used as a boolean to indicate whether
    // we want to keep this thread suspended when everything resumes.
    //---------------------------------------------------------------
    void *m_debuggerWord1;
    CONTEXT m_debuggerWord1Ctx;

    //---------------------------------------------------------------
    // A word reserved for use by the COM+ Debugging 
    //---------------------------------------------------------------
    DWORD    m_debuggerWord2;
public:

    // Don't allow a thread to be asynchronously stopped or interrupted (e.g. because
    // it is performing a <clinit>)
    int         m_PreventAsync;

    // Access the base and limit of the stack.  (I.e. the memory ranges that
    // the thread has reserved for its stack).
    //
    // Note that the base is at a higher address than the limit, since the stack
    // grows downwards.
    //
    // Note that we generally access the stack of the thread we are crawling, which
    // is cached in the ScanContext
    void       *m_CacheStackBase;
    void       *m_CacheStackLimit;

    // IP cache used by QueueCleanupIP.
    #define CLEANUP_IPS_PER_CHUNK 4
    struct CleanupIPs {
        IUnknown    *m_Slots[CLEANUP_IPS_PER_CHUNK];
        CleanupIPs  *m_Next;
    };
    CleanupIPs   m_CleanupIPs;

    _NT_TIB* m_pTEB;
    
    // The following variables are used to store thread local static data
    STATIC_DATA  *m_pUnsharedStaticData;
    STATIC_DATA  *m_pSharedStaticData;

    STATIC_DATA_LIST *m_pStaticDataList;

	DEFINE_STD_FILL_FUNCS(Thread)

    //************************************************************************
    // Enumerate all frames.
    //************************************************************************
    
    /* Flags used for StackWalkFramesEx */
    
    #define FUNCTIONSONLY   0x1
    #define POPFRAMES       0x2
    
    /* use the following  flag only if you REALLY know what you are doing !!! */
    
    #define QUICKUNWIND     0x4           // do not restore all registers during unwind

    #define HANDLESKIPPEDFRAMES 0x10    // temporary to handle skipped frames for appdomain unload
                                        // stack crawl. Eventually need to always do this but it
                                        // breaks the debugger right now.

    StackWalkAction StackWalkFramesEx(
                        PREGDISPLAY pRD,        // virtual register set at crawl start
                        PSTACKWALKFRAMESCALLBACK pCallback,
                        VOID *pData,
                        unsigned flags,
                        Frame *pStartFrame = NULL);

    bool InitRegDisplay(const PREGDISPLAY, const PCONTEXT, bool validContext);

    DWORD_PTR GetFrame() { return (DWORD_PTR) m_pFrame; }

    DWORD_PTR GetFilterContext() { return ((DWORD_PTR)m_debuggerWord1); }
};

const DWORD gElementTypeInfo[] = {
#define TYPEINFO(e,c,s,g,ie,ia,ip,if,im,ial)    s,
#include "cortypeinfo.h"
#undef TYPEINFO
};

typedef SList TypArbitraryPolicyList;

enum WellKnownPolicies;
typedef DWORD_PTR ICtxSynchronize;
typedef DWORD_PTR ICtxHeap;
typedef DWORD_PTR ICtxComContext;
typedef DWORD_PTR ComPlusWrapperCache;

class Context
{
public:
    // @todo rudim: revisit this once we have working thread affinity domains
    ComPlusWrapperCache *m_pComPlusWrapperCache;


    // Non-static Data Members:
    STATIC_DATA* m_pUnsharedStaticData;     // Pointer to native context static data
    STATIC_DATA* m_pSharedStaticData;       // Pointer to native context static data

    // @TODO: CTS. Domains should really be policies on a context and not
    // entry in the context object. When AppDomains become an attribute of
    // a context then add the policy.
    AppDomain*          m_pDomain;

	DEFINE_STD_FILL_FUNCS(Context)
};

class ExposedType
{
public:
    DWORD_PTR vtbl;
    OBJECTHANDLE m_ExposedTypeObject;
    /*
	DEFINE_STD_FILL_FUNCS(ExposedType)
    */
};
// const size_t offset_class_ExposedType = (size_t) -1;

class BaseDomain;
class CorModule;
class AssemblyMetaDataInternal;
class IAssembly;
class IAssemblyName;
class LockedListElement;

class ListLock
{
public:
    CRITICAL_SECTION    m_CriticalSection;
    BOOL                m_fInited;
    LockedListElement * m_pHead;
};

class EEUtf8StringHashTable;

class Assembly : public ExposedType
{
public:
    ListLock     m_ClassInitLock;
    ListLock     m_JITLock;
    short int m_FreeFlag;
    BaseDomain*           m_pDomain;        // Parent Domain

    ClassLoader*          m_pClassLoader;   // Single Loader
    CorModule*            m_pDynamicCode;   // Dynamic writer
    
    mdFile                m_tEntryModule;    // File token indicating the file that has the entry point
    Module*               m_pEntryPoint;     // Module containing the entry point in the COM plus HEasder

    Module*               m_pManifest;
    mdAssembly            m_kManifest;
    IMDInternalImport*    m_pManifestImport;
    PBYTE                 m_pbManifestBlob;
    CorModule*            m_pOnDiskManifest;  // This is the module containing the on disk manifest.
    mdAssembly            m_tkOnDiskManifest;
    bool                  m_fEmbeddedManifest;  

    LPWSTR                m_pwCodeBase;     // Cached code base for the assembly
    DWORD                 m_dwCodeBase;     //  size of code base 
    ULONG                 m_ulHashAlgId;    // Hash algorithm used in the Assembly
    AssemblyMetaDataInternal *m_Context;
    DWORD                 m_dwFlags;

    // Hash of files in manifest by name to File token
    EEUtf8StringHashTable *m_pAllowedFiles;

    // Set the appropriate m_FreeFlag bit if you malloc these.
    LPCUTF8               m_psName;         // Name of assembly
    LPCUTF8               m_psAlias;
    LPCUTF8               m_psTitle;
    PBYTE                 m_pbPublicKey;
    DWORD                 m_cbPublicKey;
    LPCUTF8               m_psDescription;
    

    BOOL                  m_fFromFusion;
    bool                  m_isDynamic;
    IAssembly*            m_pFusionAssembly;     // Assembly object to assembly in fusion cache
    IAssemblyName*        m_pFusionAssemblyName; // name of assembly in cache

    IInternetSecurityManager    *m_pSecurityManager;

	DEFINE_STD_FILL_FUNCS(Assembly)
};

class EEStringHashTable;
class EEUnicodeStringHashTable;
class EEMarshalingData;
class AssemblySink;
class IApplicationContext;
class AppSecurityBoundary;
class ApplicationSecurityDescriptor;

class ArrayList
{
 public:

	enum
	{
		ARRAY_BLOCK_SIZE_START = 15,
	};

    struct ArrayListBlock
    {
        struct ArrayListBlock   *m_next;
        DWORD                   m_blockSize;
        void                    *m_array[1];
    };

    struct FirstArrayListBlock
    {
        struct ArrayListBlock   *m_next;
        DWORD                   m_blockSize;
        void                    *m_array[ARRAY_BLOCK_SIZE_START];
    };

    DWORD               m_count;
    union
    {
          ArrayListBlock        m_block;
          FirstArrayListBlock   m_firstBlock;
    };
    
	DEFINE_STD_FILL_FUNCS(ArrayList)
    void *Get (DWORD index);
};

class BaseDomain : public ExposedType
{
public:   
    // Hash table that maps a clsid to a EEClass
    PtrHashMap          m_clsidHash;

    BYTE                m_LowFreqHeapInstance[sizeof(LoaderHeap)];
    BYTE                m_HighFreqHeapInstance[sizeof(LoaderHeap)];
    BYTE                m_StubHeapInstance[sizeof(LoaderHeap)];
    LoaderHeap *        m_pLowFrequencyHeap;
    LoaderHeap *        m_pHighFrequencyHeap;
    LoaderHeap *        m_pStubHeap;

    // The domain critical section.
    Crst *m_pDomainCrst;

    // Hash tables that map a UTF8 and a Unicode string to a COM+ string handle.
    EEUnicodeStringHashTable    *m_pUnicodeStringConstToHandleMap;

    // The static container critical section.
    Crst *m_pStaticContainerCrst;

    // The string hash table version.
    int m_StringHashTableVersion;

    // Static container COM+ object that contains the actual COM+ string objects.
    OBJECTHANDLE                m_hndStaticContainer;

    EEMarshalingData            *m_pMarshalingData; 

    ArrayList          m_Assemblies;

	DEFINE_STD_FILL_FUNCS(BaseDomain)
};


typedef enum AttachAppDomainEventsEnum
{
    SEND_ALL_EVENTS,
    ONLY_SEND_APP_DOMAIN_CREATE_EVENTS,
    DONT_SEND_CLASS_EVENTS,
    ONLY_SEND_CLASS_EVENTS
} AttachAppDomainEventsEnum;


// Forward reference
class SystemDomain;
class ComCallWrapperCache;
class DomainLocalBlock
{
public:
    AppDomain        *m_pDomain;
    SIZE_T            m_cSlots;
    SIZE_T           *m_pSlots;

	DEFINE_STD_FILL_FUNCS(DomainLocalBlock)
};

class AppDomain : public BaseDomain
{
public:
    Assembly*          m_pRootAssembly; // Used by the shell host to set the application (do not delete or release)
    AppDomain*         m_pSibling;    // Sibling

    // GUID to uniquely identify this AppDomain - used by the AppDomain publishing
    // service (to publish the list of all appdomains present in the process), 
    // which in turn is used by, for eg., the debugger (to decide which App-
    // Domain(s) to attach to).
    GUID            m_guid;

    // General purpose flags. 
    DWORD           m_dwFlags;

    // When an application domain is created the ref count is artifically incremented
    // by one. For it to hit zero an explicit close must have happened.
    ULONG       m_cRef;                    // Ref count.

    ApplicationSecurityDescriptor *m_pSecDesc;  // Application Security Descriptor


    OBJECTHANDLE    m_AppDomainProxy;   // Handle to the proxy object for this appdomain

    // The wrapper cache for this domain - it has it's onw CCacheLineAllocator on a per domain basis
    // to allow the domain to go away and eventually kill the memory when all refs are gone
    ComCallWrapperCache *m_pComCallWrapperCache;

    IApplicationContext* m_pFusionContext; // Binding context for the application

    LPWSTR             m_pwzFriendlyName;

    AssemblySink*      m_pAsyncPool;  // asynchronous retrival object pool (only one is kept)

    // The index of this app domain starting from 1
    DWORD m_dwIndex;
    
    DomainLocalBlock   *m_pDomainLocalBlock;
    
    DomainLocalBlock    m_sDomainLocalBlock;

    // The count of the number of threads that have entered this AD
    ULONG m_dwThreadEnterCount;

    // Class loader locks
    // DeadlockAwareListLock     m_ClassInitLock;
    
    // The method table used for unknown COM interfaces. The initial MT is created
    // in the system domain and copied to each active domain.
    MethodTable*    m_pComObjectMT;  // global method table for ComObject class

    Context *m_pDefaultContext;
    
	DEFINE_STD_FILL_FUNCS(AppDomain)
};

class SystemDomain : public BaseDomain
{
public:
    Assembly*   m_pSystemAssembly;  // Single assembly (here for quicker reference);
    AppDomain*  m_pChildren;        // Children domain
    AppDomain*  m_pCOMDomain;       // Default domain for COM+ classes exposed through IClassFactory.
    AppDomain*  m_pPool;            // Created and pooled objects
    EEClass*    m_pBaseComObjectClass; // The default wrapper class for COM
	DEFINE_STD_FILL_FUNCS(SystemDomain)
private:
    // These are class static variables that are present in the table (because
    // their index is used elsewhere), but weren't present in the original
    // Strike.
    void* m_appDomainIndexList;
    void* m_pSystemDomain;
};

class SharedDomain : public BaseDomain
{
    public:
    
    struct DLSRecord
    {
      Module *pModule;
      DWORD   DLSBase;
    };
    
    SIZE_T                  m_nextClassIndex;
    HashMap                 m_assemblyMap;
    
    DLSRecord               *m_pDLSRecords;
    DWORD                   m_cDLSRecords;
    DWORD                   m_aDLSRecords;
    
    
	DEFINE_STD_FILL_FUNCS(SharedDomain)
private:
    // These are class static variables that are present in the table (because
    // their index is used elsewhere), but weren't present in the original
    // Strike.
    void* m_pSharedDomain;
};

class EEScopeClassHashTable;
class EEClassHashTable;
class ArrayClass;

class ClassLoader
{
public:
    // Classes for which load is in progress
    EEScopeClassHashTable * m_pUnresolvedClassHash;
    CRITICAL_SECTION    m_UnresolvedClassLock;

    // Protects linked list of Modules loaded by this loader
    CRITICAL_SECTION    m_ModuleListCrst; 

    // Hash of available classes by name to Module or EEClass
    EEClassHashTable  * m_pAvailableClasses;

    // Cannoically-cased hashtable of the available class names for 
    // case insensitive lookup.  Contains pointers into 
    // m_pAvailableClasses.
    EEStringHashTable * m_pAvailableClassesCaseIns;

    // Protects addition of elements to m_pAvailableClasses
    CRITICAL_SECTION    m_AvailableClassLock;

    // Converter module for this loader (may be NULL if we haven't converted a file yet)
    CorModule   *   m_pConverterModule;

    // Have we created all of the critical sections yet?
    BOOL                m_fCreatedCriticalSections;

    // Hash table that maps a clsid to a EEClass
    PtrHashMap*         m_pclsidHash;

    // List of ArrayClasses loaded by this loader
    // This list is protected by m_pAvailableClassLock
    ArrayClass *        m_pHeadArrayClass;

    // Back reference to the assembly
    Assembly*           m_pAssembly;
    
    // Converter module needs to access these - enforces single-threaded conversion of class files
    // within this loader (and instance of the ClassConverter)
    CRITICAL_SECTION    m_ConverterModuleLock;

    // Next classloader in global list
    ClassLoader *       m_pNext; 

    // Head of list of modules loaded by this loader
    Module *            m_pHeadModule;

#if 0
//#ifdef _DEBUG
    DWORD               m_dwDebugMethods;
    DWORD               m_dwDebugFieldDescs; // Doesn't include anything we don't allocate a FieldDesc for
    DWORD               m_dwDebugClasses;
    DWORD               m_dwDebugDuplicateInterfaceSlots;
    DWORD               m_dwDebugArrayClassRefs;
    DWORD               m_dwDebugArrayClassSize;
    DWORD               m_dwDebugConvertedSigSize;
    DWORD               m_dwGCSize;
    DWORD               m_dwInterfaceMapSize;
    DWORD               m_dwMethodTableSize;
    DWORD               m_dwVtableData;
    DWORD               m_dwStaticFieldData;
    DWORD               m_dwFieldDescData;
    DWORD               m_dwMethodDescData;
    DWORD               m_dwEEClassData;
#endif
	DEFINE_STD_FILL_FUNCS(ClassLoader)
};

const int CODEMAN_STATE_SIZE = 256;

struct CodeManState
{
    DWORD       dwIsSet; // Is set to 0 by the stackwalk as appropriate
    BYTE        stateBuf[CODEMAN_STATE_SIZE];
};

/******************************************************************************
   These flags are used by some functions, although not all combinations might
   make sense for all functions.
*/

enum ICodeManagerFlags 
{
    ActiveStackFrame =  0x0001, // this is the currently active function
    ExecutionAborted =  0x0002, // execution of this function has been aborted
                                    // (i.e. it will not continue execution at the
                                    // current location)
    AbortingCall    =   0x0004, // The current call will never return
    UpdateAllRegs   =   0x0008, // update full register set
    CodeAltered     =   0x0010, // code of that function might be altered
                                    // (e.g. by debugger), need to call EE
                                    // for original code
};

class ICodeManager;
struct _METHODTOKEN {};
typedef struct _METHODTOKEN * METHODTOKEN;
class EE_ILEXCEPTION;
class IJitManager;

class CrawlFrame {
public:
      CodeManState      codeManState;

      bool              isFrameless;
      bool              isFirst;
      bool              isInterrupted;
      bool              hasFaulted;
      bool              isIPadjusted;
      Frame            *pFrame;
      MethodDesc       *pFunc;
      // the rest is only used for "frameless methods"
      ICodeManager     *codeMgrInstance;
//#if JIT_OR_NATIVE_SUPPORTED
      PREGDISPLAY       pRD; // "thread context"/"virtual register set"
      METHODTOKEN       methodToken;
      unsigned          relOffset;
      //LPVOID            methodInfo;
      EE_ILEXCEPTION   *methodEHInfo;
      IJitManager      *JitManagerInstance;
//#endif
      void GotoNextFrame();
};

class CRWLock
{
public:
    // Private data
    DWORD_PTR _pMT;
    HANDLE _hWriterEvent;
    HANDLE _hReaderEvent;
    volatile DWORD _dwState;
    DWORD _dwULockID;
    DWORD _dwLLockID;
    DWORD _dwWriterID;
    DWORD _dwWriterSeqNum;
    WORD _wFlags;
    WORD _wWriterLevel;
    
	DEFINE_STD_FILL_FUNCS(CRWLock)
};

// For FJIT
typedef struct {
    BYTE           *phdrJitGCInfo;
    MethodDesc *    hdrMDesc;

	DEFINE_STD_FILL_FUNCS(CodeHeader)
} CodeHeader;

//Type info not exist in pdb
struct JittedMethodInfo {
    BYTE      JmpInstruction[5]  ;          // this is the start address that is exposed to the EE so it can
                                            // patch all the vtables, etc. It contains a jump to the real start.
    // TODO: adding preBit here.  We need EHInfoExists.
    struct {
        __int8 JittedMethodPitched: 1 ;   // if 1, the jitted method has been pitched
        __int8 MarkedForPitching  : 1 ;   // if 1, the jitted method is scheduled to be pitched, but has not been pitched yet
        __int8 EHInfoExists       : 1 ;   // if 0, no exception info in this method 
        __int8 GCInfoExists       : 1 ;   // if 0, no gc info in this method
        __int8 EHandGCInfoPitched : 1 ;   // (if at least one of EHInfo or GCInfo exists) if 1, the info has been pitched
        __int8 Unused             : 3 ;
    } flags;
    unsigned short EhGcInfo_len;
    union {
        MethodDesc* pMethodDescriptor;      // If code pitched
        CodeHeader* pCodeHeader;            // If not pitched : points to code header which points to the methoddesc. Code begins after the code header
    } u1;
    union {
        BYTE*       pEhGcInfo;        // If code pitched: points to beginning of EH/GC info
        BYTE*       pCodeEnd;               // If not pitched : points to end of jitted code for this method. 
    } u2;
};

/*****************************************************************************
 ToDo: Do we want to include JIT/IL/target.h? 
 */

enum regNum
{
        REGI_EAX, REGI_ECX, REGI_EDX, REGI_EBX,
        REGI_ESP, REGI_EBP, REGI_ESI, REGI_EDI,
        REGI_COUNT,
        REGI_NA = REGI_COUNT
};

/*****************************************************************************
 Register masks
 */

enum RegMask
{
    RM_EAX = 0x01,
    RM_ECX = 0x02,
    RM_EDX = 0x04,
    RM_EBX = 0x08,
    RM_ESP = 0x10,
    RM_EBP = 0x20,
    RM_ESI = 0x40,
    RM_EDI = 0x80,

    RM_NONE = 0x00,
    RM_ALL = (RM_EAX|RM_ECX|RM_EDX|RM_EBX|RM_ESP|RM_EBP|RM_ESI|RM_EDI),
    RM_CALLEE_SAVED = (RM_EBP|RM_EBX|RM_ESI|RM_EDI),
    RM_CALLEE_TRASHED = (RM_ALL & ~RM_CALLEE_SAVED),
};

/*****************************************************************************
 *
 *  Helper to extract basic info from a method info block.
 */

struct hdrInfo
{
    unsigned int        methodSize;     // native code bytes
    unsigned int        argSize;        // in bytes
    unsigned int        stackSize;      /* including callee saved registers */
    unsigned int        rawStkSize;     /* excluding callee saved registers */

    unsigned int        prologSize;
    unsigned int        epilogSize;

    unsigned char       epilogCnt;
    bool                epilogEnd;      // is the epilog at the end of the method
    bool                ebpFrame;       // locals addressed relative to EBP
    bool                interruptible;  // intr. at all times (excluding prolog/epilog), not just call sites

    bool                securityCheck;  // has a slot for security object
    bool                handlers;       // has callable handlers
    bool                localloc;       // uses localloc
    bool                editNcontinue;  // has been compiled in EnC mode
    bool                varargs;        // is this a varargs routine
    bool                doubleAlign;    // is the stack double-aligned

    void *              savedRegMask_begin;
    RegMask             savedRegMask:8; // which callee-saved regs are saved on stack

    unsigned short      untrackedCnt;
    unsigned short      varPtrTableSize;

    int                 prologOffs;     // -1 if not in prolog
    int                 epilogOffs;     // -1 if not in epilog (is never 0)

    //
    // Results passed back from scanArgRegTable
    //
    regNum              thisPtrResult;  // register holding "this"
    RegMask             regMaskResult;  // registers currently holding GC ptrs
    RegMask            iregMaskResult;  // iptr qualifier for regMaskResult
    unsigned            argMaskResult;  // pending arguments mask
    unsigned           iargMaskResult;  // iptr qualifier for argMaskResult
    unsigned            argHnumResult;
    BYTE *               argTabResult;  // Table of encoded offsets of pending ptr args
    unsigned              argTabBytes;  // Number of bytes in argTabResult[]

	DEFINE_STD_FILL_FUNCS(hdrInfo)
};

struct CodeManStateBuf
{
    DWORD       hdrInfoSize;
    hdrInfo     hdrInfoBody;

	DEFINE_STD_FILL_FUNCS(CodeManStateBuf)
};

/*****************************************************************************
 *
 *  Decodes the methodInfoPtr and returns the decoded information
 *  in the hdrInfo struct.  The EIP parameter is the PC location
 *  within the active method.
 */
static size_t   crackMethodInfoHdr(BYTE *         methodInfoPtr,
                                   unsigned       curOffset,
                                   hdrInfo       *infoPtr);

struct Fjit_hdrInfo
{
    size_t              methodSize;
    unsigned short      methodFrame;      /* includes all save regs and security obj, units are sizeof(void*) */
    unsigned short      methodArgsSize;   /* amount to pop off in epilog */
    unsigned short      methodJitGeneratedLocalsSize; /* number of jit generated locals in method */
    unsigned char       prologSize;
    unsigned char       epilogSize;
    bool                hasThis;
	bool				EnCMode;		   /* has been compiled in EnC mode */
    
	DEFINE_STD_FILL_FUNCS(Fjit_hdrInfo)
};

class IJitCompiler;

class IJitManager 
{
public:
    // The calls onto the jit!
    IJitCompiler           *m_jit;
    IJitManager           *m_next;

    DWORD           m_CodeType;
    BOOL            m_IsDefaultCodeMan;
    ICodeManager*   m_runtimeSupport;
    HINSTANCE       m_JITCompiler;
    
	DEFINE_STD_FILL_FUNCS(IJitManager )

// Support for stackwalker
    JitMan m_jitMan;

    virtual void JitCode2MethodTokenAndOffset(DWORD_PTR ip, METHODTOKEN *pMethodToken, DWORD *pPCOffset)
        { DebugBreak(); }

    virtual DWORD_PTR JitToken2StartAddress(METHODTOKEN methodToken)
        { DebugBreak(); return 0;}
};

class ICodeManager;
class EECodeManager;

class EEJitManager : public IJitManager
{
public:
    HeapList    *m_pCodeHeap;

	DEFINE_STD_FILL_FUNCS(EEJitManager)

// Support for stackwalker
    virtual void      JitCode2MethodTokenAndOffset(DWORD_PTR ip, METHODTOKEN *pMethodToken, DWORD *pPCOffset);

    virtual DWORD_PTR JitToken2StartAddress(METHODTOKEN methodToken);

    DWORD_PTR GetCodeBody(DWORD_PTR pCodeHeader)
        { return (pCodeHeader + CodeHeader::size()); }
};

class MNativeJitManager : public IJitManager
{
public:
	DEFINE_STD_FILL_FUNCS(MNativeJitManager)

// Support for stackwalker
    virtual void      JitCode2MethodTokenAndOffset(DWORD_PTR ip, METHODTOKEN *pMethodToken, DWORD *pPCOffset);

    virtual DWORD_PTR JitToken2StartAddress(METHODTOKEN methodToken);
};

class ICodeInfo;

/*
    Unwind the current stack frame, i.e. update the virtual register
    set in pContext. This will be similar to the state after the function
    returns back to caller (IP points to after the call, Frame and Stack
    pointer has been reset, callee-saved registers restored 
    (if UpdateAllRegs), callee-UNsaved registers are trashed)
    Returns success of operation.
*/
bool UnwindStackFrame(PREGDISPLAY     pContext,
                      DWORD_PTR       methodInfoPtr,
                      ICodeInfo      *pCodeInfo,
                      unsigned        flags,
                      CodeManState   *pState);


// Allocation header prepended to allocated memory.
struct PerfAllocHeader {
    unsigned         m_Length;           // Length of user data in packet
    PerfAllocHeader *m_Next;             // Next packet in chain of live allocations
    PerfAllocHeader *m_Prev;             // Previous packet in chain of live allocations
    void            *m_AllocEIP;         // EIP of allocator

	DEFINE_STD_FILL_FUNCS(PerfAllocHeader)
};

class PerfAllocVars
{
public:
    PerfAllocHeader    *g_AllocListFirst;
    DWORD               g_PerfEnabled;

	DEFINE_STD_FILL_FUNCS(PerfAllocVars)
};

// The "blob" you get to store in the hash table

typedef void* HashDatum;

// The heap that you want the allocation to be done in

typedef void* AllocationHeap;

// Used inside Thread class to chain all events that a thread is waiting for by Object::Wait
struct WaitEventLink {
    SyncBlock      *m_WaitSB;
    HANDLE          m_EventWait;
    Thread         *m_Thread;       // Owner of this WaitEventLink.
    WaitEventLink  *m_Next;         // Chain to the next waited SyncBlock.
    SLink           m_LinkSB;       // Chain to the next thread waiting on the same SyncBlock.
    DWORD           m_RefCount;     // How many times Object::Wait is called on the same SyncBlock.
    
	DEFINE_STD_FILL_FUNCS(WaitEventLink)
};

// One of these is present for each element in the table.
// Update the SIZEOF_EEHASH_ENTRY macro below if you change this
// struct

struct EEHashEntry
{
    struct EEHashEntry *pNext;
    DWORD               dwHashValue;
    HashDatum           Data;
    BYTE                Key[1]; // The key is stored inline
	DEFINE_STD_FILL_FUNCS(EEHashEntry)
};

// The key[1] is a place holder for the key. sizeof(EEHashEntry) 
// return 16 bytes since it packs the struct with 3 bytes. 
#define SIZEOF_EEHASH_ENTRY (sizeof(EEHashEntry) - 4)

struct EEHashTableOfEEClass
{
    struct BucketTable
    {
        EEHashEntry   ** m_pBuckets;    // Pointer to first entry for each bucket  
        DWORD            m_dwNumBuckets;
    } m_BucketTable[2];

    DWORD_PTR       m_pFirstBucketTable;
    BucketTable*    m_pVolatileBucketTable;

    DWORD           m_dwNumEntries;
	AllocationHeap  m_Heap;
	DEFINE_STD_FILL_FUNCS(EEHashTableOfEEClass)
};

#ifndef _WIN64
    
    // Win32 - 64k reserved per segment with 4k as header
    #define HANDLE_SEGMENT_SIZE     (0x10000)   // MUST be a power of 2
    #define HANDLE_HEADER_SIZE      (0x1000)    // SHOULD be <= OS page size

#else

    // Win64 - 128k reserved per segment with 4k as header
    #define HANDLE_SEGMENT_SIZE     (0x20000)   // MUST be a power of 2
    #define HANDLE_HEADER_SIZE      (0x1000)    // SHOULD be <= OS page size

#endif

#define HANDLE_HANDLES_PER_BLOCK    (64)        // segment suballocation granularity

typedef size_t * _UNCHECKED_OBJECTREF;

#define HANDLE_SIZE                     sizeof(_UNCHECKED_OBJECTREF)
#define HANDLE_HANDLES_PER_SEGMENT      ((HANDLE_SEGMENT_SIZE - HANDLE_HEADER_SIZE) / HANDLE_SIZE)
#define HANDLE_BLOCKS_PER_SEGMENT       (HANDLE_HANDLES_PER_SEGMENT / HANDLE_HANDLES_PER_BLOCK)
//#define HANDLE_CLUMPS_PER_SEGMENT       (HANDLE_HANDLES_PER_SEGMENT / HANDLE_HANDLES_PER_CLUMP)
//#define HANDLE_CLUMPS_PER_BLOCK         (HANDLE_HANDLES_PER_BLOCK / HANDLE_HANDLES_PER_CLUMP)
//#define HANDLE_BYTES_PER_BLOCK          (HANDLE_HANDLES_PER_BLOCK * HANDLE_SIZE)
//#define HANDLE_HANDLES_PER_MASK         (sizeof(DWORD32) * BITS_PER_BYTE)
#define HANDLE_MASKS_PER_SEGMENT        (HANDLE_HANDLES_PER_SEGMENT / HANDLE_HANDLES_PER_MASK)
//#define HANDLE_MASKS_PER_BLOCK          (HANDLE_HANDLES_PER_BLOCK / HANDLE_HANDLES_PER_MASK)
//#define HANDLE_CLUMPS_PER_MASK          (HANDLE_HANDLES_PER_MASK / HANDLE_HANDLES_PER_CLUMP)

/*
 * we need byte packing for the handle table layout to work
 */
#pragma pack(push)
#pragma pack(1)

/*
 * Table Segment Header
 *
 * Defines the layout for a segment's header data.
 */
struct _TableSegmentHeader
{
    /*
     * Block Handle Types
     *
     * Each slot holds the handle type of the associated block.
     */
    BYTE rgBlockType[HANDLE_BLOCKS_PER_SEGMENT];

    /*
     * Next Segment
     *
     * Points to the next segment in the chain (if we ran out of space in this one).
     */
    struct TableSegment *pNextSegment;

    /*
     * Empty Line
     *
     * Index of the first KNOWN block of the last group of unused blocks in the segment.
     */
    BYTE bEmptyLine;
};


/*
 * Table Segment
 *
 * Defines the layout for a handle table segment.
 */
struct TableSegment : public _TableSegmentHeader
{
    /*
     * Handles
     */
    size_t rgValue[HANDLE_HANDLES_PER_SEGMENT];
    size_t firstHandle;
	DEFINE_STD_FILL_FUNCS(TableSegment)
};

/*
 * restore default packing
 */
#pragma pack(pop)

/*
 * Handle Table
 *
 * Defines the layout of a handle table object.
 */
struct HandleTable
{
    /*
     * head of segment list for this table
     */
    TableSegment *pSegmentList;

	DEFINE_STD_FILL_FUNCS(HandleTable)
};

typedef HANDLE HHANDLETABLE;

struct HandleTableMap
{
    HHANDLETABLE            *pTable;
    struct HandleTableMap   *pNext;
    DWORD                    dwMaxIndex;
    
	DEFINE_STD_FILL_FUNCS(HandleTableMap)
};

#define EEPtrHashTable EEHashTableOfEEClass

class ComPlusApartmentCleanupGroup
{
public:
    // Hashtable that maps from a context cookie to a list of ctx clean up groups.
    EEPtrHashTable m_CtxCookieToContextCleanupGroupMap;

    Thread *       m_pSTAThread;
    
	DEFINE_STD_FILL_FUNCS(ComPlusApartmentCleanupGroup)
};

class ComPlusWrapper;
enum {CLEANUP_LIST_GROUP_SIZE = 256};
class ComPlusContextCleanupGroup
{
public:
    ComPlusContextCleanupGroup *        m_pNext;
    ComPlusWrapper *                    m_apWrapper[CLEANUP_LIST_GROUP_SIZE];
    DWORD                               m_dwNumWrappers;
    //CtxEntry *                          m_pCtxEntry;
    
	DEFINE_STD_FILL_FUNCS(ComPlusContextCleanupGroup)
};

class ComPlusWrapperCleanupList
{
public:
    // Hashtable that maps from a context cookie to a list of apt clean up groups.
    EEPtrHashTable                  m_STAThreadToApartmentCleanupGroupMap;

    ComPlusApartmentCleanupGroup *  m_pMTACleanupGroup;
    
	DEFINE_STD_FILL_FUNCS(ComPlusWrapperCleanupList)
};

struct VMHELPDEF
{
public:
    void * pfnHelper;
    
	DEFINE_STD_FILL_FUNCS(VMHELPDEF)
};

struct WorkRequest {
    WorkRequest*            next;
    LPTHREAD_START_ROUTINE  Function; 
    PVOID                   Context;

	DEFINE_STD_FILL_FUNCS(WorkRequest)
};

class ICodeInfo
{
public:
    // Returns the  CorInfoFlag's from corinfo.h
    virtual DWORD       __stdcall getMethodAttribs() = 0;

    // Returns the  CorInfoFlag's from corinfo.h
    virtual DWORD       __stdcall getClassAttribs() = 0;

    virtual void        __stdcall getMethodSig(/*CORINFO_SIG_INFO*/ DWORD_PTR sig /* OUT */ ) = 0;

    // Start IP of the method
    virtual DWORD_PTR   __stdcall getStartAddress() = 0;
};

class EECodeInfo : public ICodeInfo
{
public:
    METHODTOKEN     m_methodToken;
    MethodDesc     *m_pMD;
    IJitManager    *m_pJM;

    // Returns the  CorInfoFlag's from corinfo.h
    virtual DWORD       __stdcall getMethodAttribs()
        { DebugBreak(); return 0;}

    // Returns the  CorInfoFlag's from corinfo.h
    virtual DWORD       __stdcall getClassAttribs()
        { DebugBreak(); return 0;}

    virtual void        __stdcall getMethodSig(/*CORINFO_SIG_INFO*/ DWORD_PTR sig /* OUT */ )
        { DebugBreak(); return;}

    // Start IP of the method
    virtual DWORD_PTR   __stdcall getStartAddress()
        { return (m_pJM->JitToken2StartAddress(m_methodToken)); }

	DEFINE_STD_FILL_FUNCS(EECodeInfo)
};

/*
struct DebuggerEval
{
    bool m_evalDuringException;

	DEFINE_STD_FILL_FUNCS(DebuggerEval)
};
*/

// 
// VASigCookies are allocated to encapsulate a varargs call signature.
// A reference to the cookie is embedded in the code stream.  Cookies
// are shared amongst call sites with identical signatures in the same 
// module
//

struct VASigCookie
{
    // The JIT wants knows that the size of the arguments comes first   
    // so please keep this field first  
    unsigned        sizeOfArgs;             // size of argument list

	DEFINE_STD_FILL_FUNCS(VASigCookie)
};

//-----------------------------------------------------------------------
// Operations specific to NDirect methods. We use a derived class to get
// the compiler involved in enforcing proper method type usage.
// DO NOT ADD FIELDS TO THIS CLASS.
//-----------------------------------------------------------------------
#define METHOD_CALL_PRESTUB_SIZE    5 // x86: CALL(E8) xx xx xx xx
struct MLHeader;
class NDirectMethodDesc
{
public:
    struct
    {
        // Initially points to m_ImportThunkGlue (which has an embedded call
        // to link the method.
        //
        // After linking, points to the actual unmanaged target.
        //
        // The JIT generates an indirect call through this location in some cases.
        LPVOID      m_pNDirectTarget;
        MLHeader    *m_pMLHeader;        // If not ASM'ized, points to
                                         //  marshaling code and info.

        // Embeds a "call NDirectImportThunk" instruction. m_pNDirectTarget
        // initially points to this "call" instruction.
        BYTE        m_ImportThunkGlue[METHOD_CALL_PRESTUB_SIZE];

        // Various attributes needed at runtime
        // !! Ensure there are at least 4 bytes before or after this
        // field inside NDirectMethodDesc. See the implementation of
        // ProbabilisticallyUpdateMarshCategory() if you want to know why. 
        BYTE        m_flags;

        // Size of outgoing arguments (on stack)
        WORD        m_cbDstBufSize;

        LPCUTF8     m_szLibName;
        LPCUTF8     m_szEntrypointName;
        
    } ndirect;

	DEFINE_STD_FILL_FUNCS(NDirectMethodDesc)
};

#include "tst-frames.h"

#endif // _strikeEE_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\strike.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __strike_h__
#define __strike_h__

#pragma warning(disable:4245)   // signed/unsigned mismatch
#pragma warning(disable:4100)   // unreferenced formal parameter
#pragma warning(disable:4201)   // nonstandard extension used : nameless struct/union
#pragma warning(disable:4127)   // conditional expression is constant

#ifndef UNDER_CE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wchar.h>
//#include <heap.h>
//#include <ntsdexts.h>
#endif

#include <windows.h>

//#define NOEXTAPI
#define KDEXT_64BIT
#include <wdbgexts.h>
#undef DECLARE_API

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <malloc.h>
#include <stddef.h>

#include <basetsd.h>  

#define  CORHANDLE_MASK 0x1

// C_ASSERT() can be used to perform many compile-time assertions:
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#include "exts.h"

extern BOOL CallStatus;

// Function Prototypes (implemented in strike.cpp; needed by SonOfStrike.cpp)
DECLARE_API(DumpStack);
DECLARE_API(SyncBlk);
DECLARE_API(RWLock);
DECLARE_API(DumpObj);
DECLARE_API(DumpDomain);
DECLARE_API(EEVersion);
DECLARE_API(EEDLLPath);

#endif // __strike_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\symbol.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __symbol_h__
#define __symbol_h__

struct SYM_OFFSET
{
    char *name;
    ULONG offset;
};
    
/* Fill a member of a class if the offset for the symbol exists. */
#define FILLCLASSMEMBER(symOffset, symCount, member, addr)        \
{                                                                 \
    size_t n;                                                     \
    for (n = 0; n < symCount; n ++)                               \
    {                                                             \
        if (strcmp (#member, symOffset[n].name) == 0)             \
        {                                                         \
            if (symOffset[n].offset == -1)                        \
            {                                                     \
                /*dprintf ("offset not exist for %s\n", #member);*/   \
                break;                                            \
            }                                                     \
            move (member, addr+symOffset[n].offset);              \
            break;                                                \
        }                                                         \
    }                                                             \
                                                                  \
    if (n == symCount)                                            \
    {                                                             \
        dprintf ("offset not found for %s\n", #member);           \
        /*return;*/                                               \
    }                                                             \
}

/* Fill a member of a class if the offset for the symbol exists. */
#define FILLCLASSBITMEMBER(symOffset, symCount, preBit, member, addr, size) \
{                                                                 \
    size_t n;                                                     \
    for (n = 0; n < symCount; n ++)                               \
    {                                                             \
        if (strcmp (#member, symOffset[n].name) == 0)             \
        {                                                         \
            if (symOffset[n].offset == -1)                        \
            {                                                     \
                dprintf ("offset not exist for %s\n", #member);   \
                break;                                            \
            }                                                     \
            int csize = size/8;                                   \
            if ((size % 8) != 0) {                                \
                 csize += 1;                                      \
            }                                                     \
            g_ExtData->ReadVirtual(                               \
                (ULONG64)addr+symOffset[n].offset,                \
                (BYTE*)&preBit+sizeof(void*),                     \
                csize, NULL);                                     \
            break;                                                \
        }                                                         \
    }                                                             \
                                                                  \
    if (n == symCount)                                            \
    {                                                             \
        dprintf ("offset not found for %s\n", #member);           \
        /*return;*/                                               \
    }                                                             \
}

DWORD_PTR GetSymbolType (const char* name, SYM_OFFSET *offset, int count);
ULONG Get1DArrayLength (const char *name);

// Get Name in a enum type for a constant.
// Will allocate buffer in EnumName if succeeds
void NameForEnumValue (const char *EnumType, DWORD_PTR EnumValue, char ** EnumName);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\strike.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
* STRIKE.C                                                                  *
*   Routines for the NTSD extension - STRIKE                                *
*                                                                           *
* History:                                                                  *
*   09/07/99  larrysu     Created                                           *
*                                                                           *
*                                                                           *
\***************************************************************************/

#ifndef UNDER_CE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wchar.h>
//#include <heap.h>
//#include <ntsdexts.h>
#endif // UNDER_CE

#include <windows.h>

#define NOEXTAPI
#define KDEXT_64BIT
#include <wdbgexts.h>
#undef DECLARE_API

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <malloc.h>
#include <stddef.h>

#include "strike.h"

#ifndef UNDER_CE
#include <dbghelp.h>
#endif

#include "..\..\inc\corhdr.h"
#include "..\..\inc\cor.h"

#define  CORHANDLE_MASK 0x1

#include "eestructs.h"

#define DEFINE_EXT_GLOBALS

#include "data.h"
#include "disasm.h"

BOOL CallStatus;
DWORD_PTR EEManager = NULL;
int DebugVersionDll = -1;
BOOL ControlC = FALSE;

IMetaDataDispenserEx *pDisp = NULL;
WCHAR g_mdName[mdNameLen];

#include "util.h"
#include "..\..\inc\gcdump.h"
#pragma warning(disable:4244)   // conversion from 'unsigned int' to 'unsigned short', possible loss of data
#pragma warning(disable:4189)   // local variable is initialized but not referenced
#define assert(a)
#include "..\..\inc\gcdecoder.cpp"
#define _ASSERTE(a) {;}
#include "..\..\gcdump\gcdump.cpp"

#ifdef _X86_
#include "..\..\gcdump\i386\gcdumpx86.cpp"
#endif
#ifdef _IA64_
#include "GCDumpIA64.cpp"
#endif
#undef assert
#pragma warning(default:4244)
#pragma warning(default:4189)

#include <ntpsapi.h>
#include "ntinfo.h"

#ifndef UNDER_CE
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CoInitialize(0);
        CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER, IID_IMetaDataDispenserEx, (void**)&pDisp);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpReserved == 0)
        {
            mdImportSet.Destroy();
        }
		if (pDisp)
        	pDisp->Release();
        if (DllPath) {
            delete DllPath;
        }
        CoUninitialize();
    }
    return true;
}
#endif


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to get the MethodDesc for a given eip     *  
*                                                                      *
\**********************************************************************/
DECLARE_API (IP2MD)
{
    INIT_API ();
    DWORD_PTR IP = GetExpression(args);
    if (IP == 0)
    {
        ExtOut("%s is not IP\n", args);
        return Status;
    }
    JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc)
    {
        ExtOut("MethodDesc: 0x%p\n", (ULONG64)methodDesc);
        if (jitType == EJIT)
            ExtOut ("Jitted by EJIT\n");
        else if (jitType == JIT)
            ExtOut ("Jitted by normal JIT\n");
        else if (jitType == PJIT)
            ExtOut ("Jitted by PreJIT\n");
        DumpMDInfo (methodDesc);
    }
    else
    {
        ExtOut("%p not in jit code range\n", (ULONG64)IP);
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function displays the stack trace.  It looks at each DWORD   *  
*    on stack.  If the DWORD is a return address, the symbol name or
*    managed function name is displayed.                               *
*                                                                      *
\**********************************************************************/
void DumpStackInternal(PCSTR args)
{
    DumpStackFlag DSFlag;
    BOOL bSmart = FALSE;
    DSFlag.fEEonly = FALSE;
    DSFlag.top = 0;
    DSFlag.end = 0;

    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-EE", &DSFlag.fEEonly, COBOOL, FALSE},
        {"-smart", &bSmart, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&DSFlag.top, COHEX},
        {&DSFlag.end, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return;
    }
    
    ReloadSymbolWithLineInfo();
    
    ULONG64 StackOffset;
    g_ExtRegisters->GetStackOffset (&StackOffset);
    if (nArg == 0) {
        DSFlag.top = (DWORD_PTR)StackOffset;
    }
    size_t value;
    while (g_ExtData->ReadVirtual(DSFlag.top,&value,sizeof(size_t),NULL) != S_OK) {
        if (IsInterrupt())
            return;
        DSFlag.top = NextOSPageAddress (DSFlag.top);
    }
    
    if (nArg < 2) {
        // Find the current stack range
        NT_TIB teb;
        ULONG64 dwTebAddr=0;

        g_ExtSystem->GetCurrentThreadTeb (&dwTebAddr);
        if (SafeReadMemory ((ULONG_PTR)dwTebAddr, &teb, sizeof (NT_TIB), NULL))
        {
            if (DSFlag.top > (DWORD_PTR)teb.StackLimit
            && DSFlag.top <= (DWORD_PTR)teb.StackBase)
            {
                if (DSFlag.end == 0 || DSFlag.end > (DWORD_PTR)teb.StackBase)
                    DSFlag.end = (DWORD_PTR)teb.StackBase;
            }
        }
    }

    
    if (DSFlag.end == 0)
        DSFlag.end = DSFlag.top + 0xFFFF;
    
    if (DSFlag.end < DSFlag.top)
    {
        ExtOut ("Wrong optione: stack selection wrong\n");
        return;
    }

    if (!bSmart || DSFlag.top != (DWORD_PTR)StackOffset)
        DumpStackDummy (DSFlag);
    else
        DumpStackSmart (DSFlag);
}


DECLARE_API (DumpStack)
{
    INIT_API();
    DumpStackInternal (args);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function displays the stack trace for threads that EE knows  *  
*    from ThreadStore.                                                 *
*                                                                      *
\**********************************************************************/
DECLARE_API (EEStack)
{
    INIT_API();
    
    CHAR control[80] = "\0";
    BOOL bEEOnly = FALSE;
    BOOL bDumb = TRUE;
    BOOL bAllEEThread = TRUE;

    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-EE", &bEEOnly, COBOOL, FALSE},
        {"-smart", &bDumb, COBOOL, FALSE},
        {"-short", &bAllEEThread, COBOOL, FALSE}
    };

    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),NULL,0,NULL)) {
        return Status;
    }

    if (bEEOnly) {
        strcat (control," -EE");
    }
    if (!bDumb) {
        strcat (control," -smart");
    }
    ULONG Tid;
    g_ExtSystem->GetCurrentThreadId(&Tid);

    DWORD_PTR *threadList = NULL;
    int numThread = 0;
    GetThreadList (threadList, numThread);
    ToDestroy des0((void**)&threadList);
    
    int i;
    Thread vThread;
    for (i = 0; i < numThread; i ++)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        ULONG id=0;
        if (g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id) != S_OK)
            continue;
        ExtOut ("---------------------------------------------\n");
        ExtOut ("Thread %3d\n", id);
        BOOL doIt = FALSE;
        if (bAllEEThread) {
            doIt = TRUE;
        }
        else if (vThread.m_dwLockCount > 0 || (int)vThread.m_pFrame != -1 || (vThread.m_State & Thread::TS_Hijacked)) {
            doIt = TRUE;
        }
        else {
            ULONG64 IP;
            g_ExtRegisters->GetInstructionOffset (&IP);
            JitType jitType;
            DWORD_PTR methodDesc;
            DWORD_PTR gcinfoAddr;
            IP2MethodDesc ((DWORD_PTR)IP, methodDesc, jitType, gcinfoAddr);
            if (methodDesc)
            {
                doIt = TRUE;
            }
        }
        if (doIt) {
            g_ExtSystem->SetCurrentThreadId(id);
            DumpStackInternal (control);
        }
    }

    g_ExtSystem->SetCurrentThreadId(Tid);
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the address and name of all       *
*    Managed Objects on the stack.                                     *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpStackObjects)
{
    INIT_API();
    
    size_t StackTop = 0;
    size_t StackBottom = 0;

    while (isspace (args[0]))
        args ++;
    PCSTR pch = args;
    char* endptr;
    
    if (pch[0] == '\0')
    {
        ULONG64 StackOffset;
        g_ExtRegisters->GetStackOffset (&StackOffset);

        StackTop = (DWORD_PTR)StackOffset;
    }
    else
    {
        char buffer[80];
        StackTop = strtoul (pch, &endptr, 16);
        if (endptr[0] != '\0' && !isspace (endptr[0]))
        {
            strncpy (buffer,pch,79);
            buffer[79] = '\0';
            char * tmp = buffer;
            while (tmp[0] != '\0' && !isspace (tmp[0]))
                tmp ++;
            tmp[0] = '\0';
            StackTop = GetExpression(buffer);
            if (StackTop == 0)
            {
                ExtOut ("wrong option: %s\n", pch);
                return Status;
            }
            pch += strlen(buffer);
        }
        else
            pch = endptr;
        while (pch[0] != '\0' && isspace (pch[0]))
            pch ++;
        if (pch[0] != '\0')
        {
            StackBottom = strtoul (pch, &endptr, 16);
            if (endptr[0] != '\0' && !isspace (endptr[0]))
            {
                strncpy (buffer,pch,79);
                buffer[79] = '\0';
                char * tmp = buffer;
                while (tmp[0] != '\0' && !isspace (tmp[0]))
                    tmp ++;
                tmp[0] = '\0';
                StackBottom = GetExpression(buffer);
                if (StackBottom == 0)
                {
                    ExtOut ("wrong option: %s\n", pch);
                    return Status;
                }
            }
        }
    }
    
    NT_TIB teb;
    ULONG64 dwTebAddr=0;
    g_ExtSystem->GetCurrentThreadTeb (&dwTebAddr);
    if (SafeReadMemory ((ULONG_PTR)dwTebAddr, &teb, sizeof (NT_TIB), NULL))
    {
        if (StackTop > (DWORD_PTR)teb.StackLimit
        && StackTop <= (DWORD_PTR)teb.StackBase)
        {
            if (StackBottom == 0 || StackBottom > (DWORD_PTR)teb.StackBase)
                StackBottom = (DWORD_PTR)teb.StackBase;
        }
    }
    if (StackBottom == 0)
        StackBottom = StackTop + 0xFFFF;
    
    if (StackBottom < StackTop)
    {
        ExtOut ("Wrong optione: stack selection wrong\n");
        return Status;
    }

    DumpStackObjectsHelper (StackTop, StackBottom);
    return Status;
}




/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a MethodDesc      *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpMD)
{
    DWORD_PTR dwStartAddr;

    INIT_API();
    
    dwStartAddr = GetExpression(args);
    DumpMDInfo (dwStartAddr);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of an EEClass from   *  
*    a given address
*                                                                      *
\**********************************************************************/
DECLARE_API (DumpClass)
{
    DWORD_PTR dwStartAddr;
    EEClass EECls;
    EEClass *pEECls = &EECls;
    
    INIT_API();

    BOOL bDumpChain = FALSE;
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-chain", &bDumpChain, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&dwStartAddr, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    if (nArg == 0) {
        ExtOut ("Missing EEClass address\n");
        return Status;
    }
    DWORD_PTR dwAddr = dwStartAddr;
    if (!IsEEClass (dwAddr))
    {
        ExtOut ("%p is not an EEClass\n", (ULONG64)dwStartAddr);
        return Status;
    }
    pEECls->Fill (dwStartAddr);
    if (!CallStatus)
    {
	    ExtOut( "DumpClass : ReadProcessMemory failed.\r\n" );
	    return Status;
    }
    
    ExtOut("Class Name : ");
    NameForEEClass (pEECls, g_mdName);
    ExtOut("%S", g_mdName);
    ExtOut ("\n");

    MethodTable vMethTable;
    moveN (vMethTable, pEECls->m_pMethodTable);
    WCHAR fileName[MAX_PATH+1];
    FileNameForMT (&vMethTable, fileName);
    ExtOut("mdToken : %p (%S)\n",(ULONG64)pEECls->m_cl, fileName);

    ExtOut("Parent Class : %p\r\n",(ULONG64)pEECls->m_pParentClass);

    ExtOut("ClassLoader : %p\r\n",(ULONG64)pEECls->m_pLoader);

    ExtOut("Method Table : %p\r\n",(ULONG64)pEECls->m_pMethodTable);

    ExtOut("Vtable Slots : %x\r\n",pEECls->m_wNumVtableSlots);

    ExtOut("Total Method Slots : %x\r\n",pEECls->m_wNumMethodSlots);

    ExtOut("Class Attributes : %x : ",pEECls->m_dwAttrClass);
#if 0
    if (IsTdValueType(pEECls->m_dwAttrClass))
    {
        ExtOut ("Value Class, ");
    }
    if (IsTdEnum(pEECls->m_dwAttrClass))
    {
        ExtOut ("Enum type, ");
    }
    if (IsTdUnmanagedValueType(pEECls->m_dwAttrClass))
    {
        ExtOut ("Unmanaged Value Class, ");
    }
#endif
    if (IsTdInterface(pEECls->m_dwAttrClass))
    {
        ExtOut ("Interface, ");
    }
    if (IsTdAbstract(pEECls->m_dwAttrClass))
    {
        ExtOut ("Abstract, ");
    }
    if (IsTdImport(pEECls->m_dwAttrClass))
    {
        ExtOut ("ComImport, ");
    }
    
    ExtOut ("\n");
    
    
    ExtOut("Flags : %x\r\n",pEECls->m_VMFlags);

    ExtOut("NumInstanceFields: %x\n", pEECls->m_wNumInstanceFields);
    ExtOut("NumStaticFields: %x\n", pEECls->m_wNumStaticFields);
    ExtOut("ThreadStaticOffset: %x\n", pEECls->m_wThreadStaticOffset);
    ExtOut("ThreadStaticsSize: %x\n", pEECls->m_wThreadStaticsSize);
    ExtOut("ContextStaticOffset: %x\n", pEECls->m_wContextStaticOffset);
    ExtOut("ContextStaticsSize: %x\n", pEECls->m_wContextStaticsSize);
    
    if (pEECls->m_wNumInstanceFields + pEECls->m_wNumStaticFields > 0)
    {
        ExtOut ("FieldDesc*: %p\n", (ULONG64)pEECls->m_pFieldDescList);
        DisplayFields(pEECls);
    }

    if (bDumpChain) {
    }
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a MethodTable     *  
*    from a given address                                              *
*                                                                      *
\**********************************************************************/
DECLARE_API (DumpEEHash)
{
    INIT_API();
    
    DWORD_PTR dwTableAddr;
    size_t nitem = 1;
    
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-length", &nitem, COSIZE_T, TRUE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&dwTableAddr, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    if (dwTableAddr == 0) {
        goto Exit;
    }
    EEHashTableOfEEClass vTable;
    vTable.Fill(dwTableAddr);
    ExtOut ("NumBuckets slot 0: %d\n", vTable.m_BucketTable[0].m_dwNumBuckets);
    ExtOut ("NumBuckets slot 1: %d\n", vTable.m_BucketTable[1].m_dwNumBuckets);
    ExtOut ("NumEntries       : %d\n", vTable.m_dwNumEntries);
    ExtOut ("Actual slot: %08x\n", vTable.m_pVolatileBucketTable);

    DWORD n;
    size_t dwBucketAddr;
    EEHashEntry vEntry;
    ULONG offsetKey = EEHashEntry::GetFieldOffset (
      offset_member_EEHashEntry::Key);

    EEHashTableOfEEClass::BucketTable* pBucketTable;
    pBucketTable = ((EEHashTableOfEEClass::BucketTable*) vTable.m_pFirstBucketTable == &vTable.m_BucketTable[0]) ? 
                        &vTable.m_BucketTable[0]: 
                        &vTable.m_BucketTable[1];

    ExtOut ("Bucket   Data     Key\n");
    for (n = 0; n < pBucketTable->m_dwNumBuckets; n ++) {
        if (IsInterrupt())
            break;
        dwBucketAddr = (size_t)pBucketTable->m_pBuckets + n * sizeof(PVOID);
        moveN (dwBucketAddr, dwBucketAddr);
        while (dwBucketAddr) {
            if (IsInterrupt())
                break;
            DWORD_PTR dwAddr = dwBucketAddr;
            vEntry.Fill(dwAddr);
            size_t Key;
            ExtOut ("%p %p ", (ULONG64)dwBucketAddr, (ULONG64)vEntry.Data);
            dwAddr = dwBucketAddr + offsetKey;
            for (size_t i = 0; i < nitem; i ++) {
                moveN (Key, dwAddr+i*sizeof(size_t));
                ExtOut ("%p ", (ULONG64)Key);
            }
            ExtOut ("\n");
            dwBucketAddr = (size_t)vEntry.pNext;
        }
    }

Exit:
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a MethodTable     *  
*    from a given address                                              *
*                                                                      *
\**********************************************************************/
DECLARE_API (DumpMT)
{
    DWORD_PTR dwStartAddr;
    MethodTable vMethTable;
    
    INIT_API();
    
    BOOL bDumpMDTable = FALSE;
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-MD", &bDumpMDTable, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&dwStartAddr, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    if (nArg == 0) {
        ExtOut ("Missing MethodTable address\n");
        return Status;
    }

    dwStartAddr = dwStartAddr&~3;
    
    if (!IsMethodTable (dwStartAddr))
    {
        ExtOut ("%p is not a MethodTable\n", (ULONG64)dwStartAddr);
        return Status;
    }
    if (dwStartAddr == MTForFreeObject()) {
        ExtOut ("Free MethodTable\n");
        return Status;
    }
    
    vMethTable.Fill (dwStartAddr);
    if (!CallStatus)
        return Status;
    
    ExtOut("EEClass : %p\r\n",(ULONG64)vMethTable.m_pEEClass);

    ExtOut("Module : %p\r\n",(ULONG64)vMethTable.m_pModule);

    EEClass eeclass;
    DWORD_PTR dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
    eeclass.Fill (dwAddr);
    if (!CallStatus)
        return Status;
    WCHAR fileName[MAX_PATH+1];
    if (eeclass.m_cl == 0x2000000)
    {
        ArrayClass vArray;
        dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
        vArray.Fill (dwAddr);
        ExtOut("Array: Rank %d, Type %s\n", vArray.m_dwRank,
                ElementTypeName(vArray.m_ElementType));
        //ExtOut ("Name: ");
        //ExtOut ("\n");
        dwAddr = (DWORD_PTR) vArray.m_ElementTypeHnd.m_asMT;
        while (dwAddr&2) {
            if (IsInterrupt())
                return Status;
            ParamTypeDesc param;
            DWORD_PTR dwTDAddr = dwAddr&~2;
            param.Fill(dwTDAddr);
            dwAddr = (DWORD_PTR)param.m_Arg.m_asMT;
        }
        NameForMT (dwAddr, g_mdName);
        ExtOut ("Element Type: %S\n", g_mdName);
    }
    else
    {
        FileNameForMT (&vMethTable, fileName);
        NameForToken(fileName, eeclass.m_cl, g_mdName);
        ExtOut ("Name: %S\n", g_mdName);
        ExtOut("mdToken: %08x ", eeclass.m_cl);
        ExtOut( " (%ws)\n",
                 fileName[0] ? fileName : L"Unknown Module" );
        ExtOut("MethodTable Flags : %x\r\n",vMethTable.m_wFlags & 0xFFFF0000); // low WORD is m_ComponentSize
        if (vMethTable.m_ComponentSize)
            ExtOut ("Number of elements in array: %x\n",
                     vMethTable.m_ComponentSize);
        ExtOut("Number of IFaces in IFaceMap : %x\r\n",
                vMethTable.m_wNumInterface);
        
        ExtOut("Interface Map : %p\r\n",(ULONG64)vMethTable.m_pIMap);
        
        ExtOut("Slots in VTable : %d\r\n",vMethTable.m_cbSlots);
    }

    if (bDumpMDTable)
    {
        ExtOut ("--------------------------------------\n");
        ExtOut ("MethodDesc Table\n");
#ifdef _IA64_
        ExtOut ("     Entry          MethodDesc     JIT   Name\n");
//                123456789abcdef0 123456789abcdef0 PreJIT xxxxxxxx
#else
        ExtOut ("  Entry  MethodDesc   JIT   Name\n");
//                12345678 12345678    PreJIT xxxxxxxx
#endif
        DWORD_PTR dwAddr = vMethTable.m_Vtable[0];
        for (DWORD n = 0; n < vMethTable.m_cbSlots; n ++)
        {
            DWORD_PTR entry;
            moveN (entry, dwAddr);
            JitType jitType;
            DWORD_PTR methodDesc=0;
            DWORD_PTR gcinfoAddr;
            IP2MethodDesc (entry, methodDesc, jitType, gcinfoAddr);
            if (!methodDesc)
            {
                methodDesc = entry + 5;
            }
#ifdef _IA64_
            ExtOut ("%p %p ", (ULONG64)entry, (ULONG64)methodDesc);
#else
            ExtOut ("%p %p    ", (ULONG64)entry, (ULONG64)methodDesc);
#endif
            if (jitType == EJIT)
                ExtOut ("EJIT  ");
            else if (jitType == JIT)
                ExtOut ("JIT   ");
            else if (jitType == PJIT)
                ExtOut ("PreJIT");
            else
                ExtOut ("None  ");
            
            MethodDesc vMD;
            DWORD_PTR dwMDAddr = methodDesc;
            vMD.Fill (dwMDAddr);
            
            CQuickBytes fullname;
            FullNameForMD (&vMD, &fullname);
            ExtOut (" %S\n", (WCHAR*)fullname.Ptr());
            dwAddr += sizeof(PVOID);
        }
    }
    return Status;
}

extern size_t Align (size_t nbytes);

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of an object from a  *  
*    given address
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpObj)    
{
    INIT_API();
    DWORD_PTR p_Object = GetExpression (args);
    if (p_Object == 0)
        return Status;
    DWORD_PTR p_MT;
    moveN (p_MT, p_Object);
    p_MT = p_MT&~3;

    if (!IsMethodTable (p_MT))
    {
        ExtOut ("%s is not a managed object\n", args);
        return Status;
    }

    if (p_MT == MTForFreeObject()) {
        ExtOut ("Free Object\n");
        DWORD size = ObjectSize (p_Object);
        ExtOut ("Size %d(0x%x) bytes\n", size, size);
        return Status;
    }

    DWORD_PTR size = 0;
    MethodTable vMethTable;
    DWORD_PTR dwAddr = p_MT;
    vMethTable.Fill (dwAddr);
    NameForMT (vMethTable, g_mdName);
    ExtOut ("Name: %S\n", g_mdName);
    ExtOut ("MethodTable 0x%p\n", (ULONG64)p_MT);
    ExtOut ("EEClass 0x%p\n", (ULONG64)vMethTable.m_pEEClass);
    size = ObjectSize (p_Object);
    ExtOut ("Size  %d(0x%x) bytes\n", size,size);
    EEClass vEECls;
    dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
    vEECls.Fill (dwAddr);
    if (!CallStatus)
        return Status;
    if (vEECls.m_cl == 0x2000000)
    {
        ArrayClass vArray;
        dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
        vArray.Fill (dwAddr);
        ExtOut("Array: Rank %d, Type %s\n", vArray.m_dwRank,
                ElementTypeName(vArray.m_ElementType));
        //ExtOut ("Name: ");
        //ExtOut ("\n");
        dwAddr = (DWORD_PTR) vArray.m_ElementTypeHnd.m_asMT;
        NameForMT (dwAddr, g_mdName);
        ExtOut ("Element Type: %S\n", g_mdName);
        if (vArray.m_ElementType == 3)
        {
            ExtOut ("Content:\n");
            dwAddr = p_Object + 4;
            DWORD_PTR num;
            moveN (num, dwAddr);
            PrintString (dwAddr+4, TRUE, num);
            ExtOut ("\n");
        }
    }
    else
    {
        FileNameForMT (&vMethTable, g_mdName);
        ExtOut("mdToken: %08x ", vEECls.m_cl);
        ExtOut( " (%ws)\n",
                 g_mdName[0] ? g_mdName : L"Unknown Module" );
    }
    
    if (p_MT == MTForString())
    {
        ExtOut ("String: ");
        StringObjectContent (p_Object);
        ExtOut ("\n");
    }
    else if (p_MT == MTForObject())
    {
        ExtOut ("Object\n");
    }

    if (vEECls.m_wNumInstanceFields + vEECls.m_wNumStaticFields > 0)
    {
        ExtOut ("FieldDesc*: %p\n", (ULONG64)vEECls.m_pFieldDescList);
        DisplayFields(&vEECls, p_Object, TRUE);
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function dumps GC heap size.                                 *  
*                                                                      *
\**********************************************************************/
DECLARE_API(EEHeap)
{
#ifdef UNDER_CE
    ExtOut ("Not yet implemented\n");
    return Status;
#else
    INIT_API();

#define GC_HEAP_ONLY          0x00000001
#define LOADER_HEAP_ONLY      0x00000002
#define WIN32_HEAP_ONLY       0x00000004
#define EE_HEAP_MASK          0x00000007

    BOOL bEEHeapFlags = EE_HEAP_MASK;

    if (_stricmp (args, "-gc") == 0)
        bEEHeapFlags = GC_HEAP_ONLY;

    if (_stricmp (args, "-win32") == 0)
        bEEHeapFlags = WIN32_HEAP_ONLY;

    if (_stricmp (args, "-loader") == 0)
        bEEHeapFlags = LOADER_HEAP_ONLY;

    if (bEEHeapFlags & LOADER_HEAP_ONLY)
    {
        // Loader heap.
        LoaderHeap v_LoaderHeap;
        DWORD_PTR p_DomainAddr;
        AppDomain v_AppDomain;

        DWORD_PTR allHeapSize = 0;
        DWORD_PTR domainHeapSize;
    
        int numDomain;
        DWORD_PTR *domainList = NULL;
        GetDomainList (domainList, numDomain);
        ToDestroy des0 ((void**) &domainList);
        
        // The first one is the system domain.
        p_DomainAddr = domainList[0];
        ExtOut ("Loader Heap:\n");
        ExtOut ("--------------------------------------\n");
        ExtOut ("System Domain: %p\n", (ULONG64)p_DomainAddr);
        v_AppDomain.Fill (p_DomainAddr);
        domainHeapSize = 0;
        ExtOut ("LowFrequencyHeap:");
        DWORD_PTR dwStartAddr = (DWORD_PTR)v_AppDomain.m_pLowFrequencyHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("HighFrequencyHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pHighFrequencyHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("StubHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pStubHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("Total size: 0x%x(%d)bytes\n", domainHeapSize, domainHeapSize);
        allHeapSize += domainHeapSize;

        ExtOut ("--------------------------------------\n");
        p_DomainAddr = domainList[1];
        ExtOut ("Shared Domain: %x\n", p_DomainAddr);
        v_AppDomain.Fill (p_DomainAddr);
        domainHeapSize = 0;
        ExtOut ("LowFrequencyHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pLowFrequencyHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("HighFrequencyHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pHighFrequencyHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("StubHeap:");
        dwStartAddr = (DWORD_PTR)v_AppDomain.m_pStubHeap;
        v_LoaderHeap.Fill (dwStartAddr);
        domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
        ExtOut ("Total size: 0x%x(%d)bytes\n", domainHeapSize, domainHeapSize);
        allHeapSize += domainHeapSize;

        int n;
        int n0 = 2;
        for (n = n0; n < numDomain; n++)
        {
            if (IsInterrupt())
                break;

            p_DomainAddr = domainList[n];
            // Check if this domain already appears.
            int i;
            for (i = 0; i < n; i ++)
            {
                if (domainList[i] == p_DomainAddr)
                    break;
            }
            if (i == n)
            {
                ExtOut ("--------------------------------------\n");
                ExtOut ("Domain %d: %x\n", n-n0, p_DomainAddr);
                v_AppDomain.Fill (p_DomainAddr);
                domainHeapSize = 0;
                ExtOut ("LowFrequencyHeap:");
                DWORD_PTR dwStartAddr = (DWORD_PTR)v_AppDomain.m_pLowFrequencyHeap;
                v_LoaderHeap.Fill (dwStartAddr);
                domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
                ExtOut ("HighFrequencyHeap:");
                dwStartAddr = (DWORD_PTR)v_AppDomain.m_pHighFrequencyHeap;
                v_LoaderHeap.Fill (dwStartAddr);
                domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
                ExtOut ("StubHeap:");
                dwStartAddr = (DWORD_PTR)v_AppDomain.m_pStubHeap;
                v_LoaderHeap.Fill (dwStartAddr);
                domainHeapSize += LoaderHeapInfo (&v_LoaderHeap);
                ExtOut ("Total size: 0x%x(%d)bytes\n", domainHeapSize, domainHeapSize);
                allHeapSize += domainHeapSize;
            }
        }
    
        // Jit code heap
        ExtOut ("--------------------------------------\n");
        ExtOut ("Jit code heap:\n");
        allHeapSize += JitHeapInfo();
    
        ExtOut ("--------------------------------------\n");
        ExtOut ("Total LoaderHeap size: 0x%x(%d)bytes\n", allHeapSize, allHeapSize);
        ExtOut ("=======================================\n");
    }

    if (bEEHeapFlags & WIN32_HEAP_ONLY)
    {
        DWORD bIsInit = GetAddressOf (offset_class_PerfUtil, 
            offset_member_PerfUtil::g_PerfAllocHeapInitialized);
        if (bIsInit)
        {
            PerfAllocVars v_perfVars;
            DWORD dwStartAddr = GetAddressOf (offset_class_PerfUtil,
                offset_member_PerfUtil::g_PerfAllocVariables);
            v_perfVars.Fill (dwStartAddr);
            if (!v_perfVars.g_PerfEnabled)
                ExtOut ("Win32 heap allocation stats not collected, enable by setting reg key Complus\\EnablePerfAllocStats to 1\n");
            else
            {
                ExtOut ("--------------------------------------\n");
                ExtOut ("Win32 Process Heap (Verbose)\n");
                ExtOut ("--------------------------------------\n");
        
                PerfAllocHeader h;
                DWORD dwNextNodeAddr = (DWORD)v_perfVars.g_AllocListFirst;
                
                ExtOut ("Alloc Addr\tSize\tSymbol\n");
                while(1)
                {
                    h.Fill (dwNextNodeAddr);
                    ExtOut ("%x\t%u\t%x\n", dwNextNodeAddr, h.m_Length, h.m_AllocEIP);   
                    if (h.m_Next == NULL)
                        break;
                    dwNextNodeAddr = (DWORD)h.m_Next;
                }
            }
        }
    }
    
    if (bEEHeapFlags & GC_HEAP_ONLY)
    {   
        // GC Heap
        DWORD_PTR dwNHeaps = 1;
        if (IsServerBuild())
        {
            static DWORD_PTR dwAddrNHeaps = 0;
            if (dwAddrNHeaps == 0)
                dwAddrNHeaps = GetAddressOf (offset_class_gc_heap, 
                  offset_member_gc_heap::n_heaps);

            moveN (dwNHeaps, dwAddrNHeaps);
        }

        ExtOut ("Number of GC Heaps: %d\n", dwNHeaps);
    
        gc_heap heap = {0};
        DWORD_PTR totalSize = 0;
        if (!IsServerBuild())
        {
            DWORD_PTR dwAddr = 0;
            heap.Fill (dwAddr);
            if (!CallStatus)
                return Status;
            GCHeapInfo (heap, totalSize);
        }
        else
        {
            DWORD_PTR dwAddrGHeaps =
                GetAddressOf (offset_class_gc_heap, 
                  offset_member_gc_heap::g_heaps);

            moveN (dwAddrGHeaps, dwAddrGHeaps);
            DWORD n;
            for (n = 0; n < dwNHeaps; n ++)
            {
                DWORD_PTR dwAddrGCHeap = dwAddrGHeaps + n*sizeof(VOID*);
                moveN (dwAddrGCHeap, dwAddrGCHeap);

                heap.Fill (dwAddrGCHeap);
                DWORD_PTR heapSize = 0;
                ExtOut ("------------------------------\n");
                ExtOut ("Heap %d\n", n);
                GCHeapInfo (heap, heapSize);
                totalSize += heapSize;
            }
        }
        ExtOut ("------------------------------\n");
        ExtOut ("GC Heap Size  %#8x(%d)\n", totalSize, totalSize);
    }
#endif
    return Status;
}

HeapStat *stat = NULL;

void PrintGCStat ()
{
    if (stat)
    {
        ExtOut ("Statistics:\n");
        ExtOut ("%8s %8s %9s %s\n",
                 "MT", "Count", "TotalSize", "Class Name");
        __try 
        {
            stat->Sort();
        } __except (EXCEPTION_EXECUTE_HANDLER)
        {
            ExtOut ("exception during sorting\n");
            stat->Delete();
            return;
        }        
        __try 
        {
            stat->Print();
        } __except (EXCEPTION_EXECUTE_HANDLER)
        {
            ExtOut ("exception during printing\n");
            stat->Delete();
            return;
        }        
        stat->Delete();
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function dumps all objects on GC heap. It also displays      *  
*    statistics of objects.  If GC heap is corrupted, it will stop at 
*    the bad place.  (May not work if GC is in progress.)              *
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpHeap)
{
    INIT_API();

    DumpHeapFlags flags;
    
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-min", &flags.min_size, COSIZE_T, TRUE},
        {"-max", &flags.max_size, COSIZE_T, TRUE},
        {"-mt", &flags.MT, COHEX, TRUE},
        {"-stat", &flags.bStatOnly, COBOOL, FALSE},
        {"-fix", &flags.bFixRange, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&flags.startObject, COHEX},
        {&flags.endObject, COHEX}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    if (flags.min_size > flags.max_size)
    {
        ExtOut ("wrong argument\n");
        return Status;
    }
    
    if (flags.endObject == 0)
        flags.endObject = -1;

    if (stat == NULL)
    {
        stat = (HeapStat *)malloc(sizeof (HeapStat));
        stat = new(stat) HeapStat;
    }

    ToDestroy des2 ((void**) &stat);
    
    // Obtain allocation context for each managed thread.
    DWORD_PTR *threadList = NULL;
    ToDestroy des0 ((void**)&threadList);
    int numThread = 0;
    GetThreadList (threadList, numThread);
    
    AllocInfo allocInfo;
    allocInfo.num = 0;
    allocInfo.array = NULL;

    
    if (numThread)
    {
        allocInfo.array =
            (alloc_context*)malloc(numThread * sizeof(alloc_context));
    }
    ToDestroy des1 ((void**)&allocInfo.array);
    
    Thread vThread;
    int i;

    for (i = 0; i < numThread; i ++)
    {
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        if (vThread.m_alloc_context.alloc_ptr == 0)
            continue;
        
        int j;
        for (j = 0; j < allocInfo.num; j ++)
        {
            if (allocInfo.array[j].alloc_ptr ==
                vThread.m_alloc_context.alloc_ptr)
                break;
        }
        if (j == allocInfo.num)
        {
            allocInfo.num ++;
            allocInfo.array[j].alloc_ptr =
                vThread.m_alloc_context.alloc_ptr;
            allocInfo.array[j].alloc_limit =
                vThread.m_alloc_context.alloc_limit;
        }
    }
    
    gc_heap heap;
    DWORD_PTR nObj = 0;
    if (!IsServerBuild())
    {
        DWORD_PTR dwAddr = 0;
        heap.Fill (dwAddr);
        if (!CallStatus)
            return Status;
        if (!flags.bStatOnly)
            ExtOut ("%8s %8s %8s\n", "Address", "MT", "Size");
        GCHeapDump (heap, nObj, flags,
                    &allocInfo);
    }
    else
    {
        DWORD_PTR dwNHeaps = 1;
        static DWORD_PTR dwAddrNHeaps = 0;
        if (dwAddrNHeaps == 0)
            dwAddrNHeaps = GetAddressOf (offset_class_gc_heap, 
                  offset_member_gc_heap::n_heaps);

        safemove_ret (dwNHeaps, dwAddrNHeaps);
        
        static DWORD_PTR dwAddrGHeaps0 = 0;
        if (dwAddrGHeaps0 == 0)
            dwAddrGHeaps0 = GetAddressOf (offset_class_gc_heap, 
                  offset_member_gc_heap::g_heaps);

        DWORD_PTR dwAddrGHeaps;
        safemove_ret (dwAddrGHeaps, dwAddrGHeaps0);
        DWORD n;
        for (n = 0; n < dwNHeaps; n ++)
        {
            DWORD_PTR dwAddrGCHeap = dwAddrGHeaps + n*sizeof(VOID*);
            safemove_ret (dwAddrGCHeap, dwAddrGCHeap);

            heap.Fill (dwAddrGCHeap);
            DWORD_PTR cObj = 0;
            ExtOut ("------------------------------\n");
            ExtOut ("Heap %d\n", n);
            if (!flags.bStatOnly)
                ExtOut ("%8s %8s %8s\n", "Address", "MT", "Size");
            GCHeapDump (heap, cObj, flags,
                        &allocInfo);
            ExtOut ("total %d objects\n", cObj);
            nObj += cObj;
        }
        ExtOut ("------------------------------\n");
    }
    
    ExtOut ("total %d objects\n", nObj);

    PrintGCStat();
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function dumps what is in the syncblock cache.  By default   *  
*    it dumps all active syncblocks.  Using -all to dump all syncblocks
*                                                                      *
\**********************************************************************/
DECLARE_API(SyncBlk)
{
    INIT_API();

    BOOL bDumpAll = FALSE;
    size_t nbAsked = 0;
    
    CMDOption option[] = {
        // name, vptr, type, hasValue
        {"-all", &bDumpAll, COBOOL, FALSE}
    };
    CMDValue arg[] = {
        // vptr, type
        {&nbAsked, COSIZE_T}
    };
    size_t nArg;
    if (!GetCMDOption(args,option,sizeof(option)/sizeof(CMDOption),
                      arg,sizeof(arg)/sizeof(CMDValue),&nArg)) {
        return Status;
    }

    DWORD_PTR p_s_pSyncBlockCache = GetAddressOf (offset_class_Global_Variables,
      offset_member_Global_Variables::g_SyncBlockCacheInstance);

    SyncBlockCache s_pSyncBlockCache;
    s_pSyncBlockCache.Fill (p_s_pSyncBlockCache);
    if (!CallStatus)
    {
        ExtOut ("Can not get mscoree!g_SyncBlockCacheInstance\n");
        return Status;
    }
    
    DWORD_PTR p_g_pSyncTable = GetAddressOf (offset_class_Global_Variables, 
      offset_member_Global_Variables::g_pSyncTable);

    DWORD_PTR pSyncTable;
    moveN (pSyncTable, p_g_pSyncTable);
    pSyncTable += SyncTableEntry::size();
    SyncTableEntry v_SyncTableEntry;
    if (s_pSyncBlockCache.m_FreeSyncTableIndex < 2)
        return Status;
    DWORD_PTR dwAddr;
    SyncBlock vSyncBlock;
    ULONG offsetHolding = 
        AwareLock::GetFieldOffset(offset_member_AwareLock::m_HoldingThread);
    ULONG offsetLinkSB = 
        WaitEventLink::GetFieldOffset(offset_member_WaitEventLink::m_LinkSB);
    ExtOut ("Index SyncBlock MonitorHeld Recursion   Thread  ThreadID     Object Waiting\n");
    ULONG freeCount = 0;
    ULONG CCWCount = 0;
    ULONG RCWCount = 0;
    ULONG CFCount = 0;
    for (DWORD nb = 1; nb < s_pSyncBlockCache.m_FreeSyncTableIndex; nb++)
    {
        if (IsInterrupt())
            return Status;
        if (nbAsked && nb != nbAsked) {
            pSyncTable += SyncTableEntry::size();
            continue;
        }
        dwAddr = (DWORD_PTR)pSyncTable;
        v_SyncTableEntry.Fill(dwAddr);
        if (v_SyncTableEntry.m_SyncBlock == 0) {
            if (bDumpAll || nbAsked == nb) {
                ExtOut ("%5d ", nb);
                ExtOut ("%08x  ", 0);
                ExtOut ("%11s ", " ");
                ExtOut ("%9s ", " ");
                ExtOut ("%8s ", " ");
                ExtOut ("%10s" , " ");
                ExtOut ("  %08x", (v_SyncTableEntry.m_Object));
                ExtOut ("\n");
            }
            pSyncTable += SyncTableEntry::size();
            continue;
        }
        dwAddr = v_SyncTableEntry.m_SyncBlock;
        vSyncBlock.Fill (dwAddr);
        BOOL bPrint = (bDumpAll || nb == nbAsked);
        if (!bPrint && v_SyncTableEntry.m_SyncBlock != 0
            && vSyncBlock.m_Monitor.m_MonitorHeld > 0
            && (v_SyncTableEntry.m_Object & 0x1) == 0)
            bPrint = TRUE;
        if (bPrint)
        {
            ExtOut ("%5d ", nb);
            ExtOut ("%08x  ", v_SyncTableEntry.m_SyncBlock);
            ExtOut ("%11d ", vSyncBlock.m_Monitor.m_MonitorHeld);
            ExtOut ("%9d ", vSyncBlock.m_Monitor.m_Recursion);
        }
        DWORD_PTR p_thread;
        p_thread = v_SyncTableEntry.m_SyncBlock + offsetHolding;
        DWORD_PTR thread = vSyncBlock.m_Monitor.m_HoldingThread;
        if (bPrint)
            ExtOut ("%8x ", thread);
        DWORD_PTR threadID = 0;
        if (thread != 0)
        {
            Thread vThread;
            threadID = thread;
            vThread.Fill (threadID);
            if (bPrint)
            {
                ExtOut ("%5x", vThread.m_ThreadId);
                ULONG id;
                if (g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id) == S_OK)
                {
                    ExtOut ("%4d ", id);
                }
                else
                {
                    ExtOut (" XXX ");
                }
            }
        }
        else
        {
            if (bPrint)
                ExtOut ("    none  ");
        }
        if (bPrint) {
            if (v_SyncTableEntry.m_Object & 0x1) {
                ExtOut ("  %8d", (v_SyncTableEntry.m_Object & ~0x1)>>1);
            }
            else {
                ExtOut ("  %p", (ULONG64)v_SyncTableEntry.m_Object);
                NameForObject((DWORD_PTR)v_SyncTableEntry.m_Object, g_mdName);
                ExtOut (" %S", g_mdName);
            }
        }
        if (v_SyncTableEntry.m_Object & 0x1) {
            freeCount ++;
            if (bPrint) {
                ExtOut (" Free");
            }
        }
        else {
            if (vSyncBlock.m_pComData) {
                switch (vSyncBlock.m_pComData & 3) {
                case 0:
                    CCWCount ++;
                    break;
                case 1:
                    RCWCount ++;
                    break;
                case 3:
                    CFCount ++;
                    break;
                }
            }
        }

        if (v_SyncTableEntry.m_SyncBlock != 0
            && vSyncBlock.m_Monitor.m_MonitorHeld > 1
            && vSyncBlock.m_Link.m_pNext > 0)
        {
            ExtOut (" ");
            DWORD_PTR pHead = (DWORD_PTR)vSyncBlock.m_Link.m_pNext;
            DWORD_PTR pNext = pHead;
            Thread vThread;
    
            while (1)
            {
                if (IsInterrupt())
                    return Status;
                DWORD_PTR pWaitEventLink = pNext - offsetLinkSB;
                WaitEventLink vWaitEventLink;
                vWaitEventLink.Fill(pWaitEventLink);
                if (!CallStatus) {
                    break;
                }
                DWORD_PTR dwAddr = (DWORD_PTR)vWaitEventLink.m_Thread;
                ExtOut ("%x ", dwAddr);
                vThread.Fill (dwAddr);
                if (!CallStatus) {
                    break;
                }
                if (bPrint)
                    ExtOut ("%x,", vThread.m_ThreadId);
                pNext = (DWORD_PTR)vWaitEventLink.m_LinkSB.m_pNext;
                if (pNext == 0)
                    break;
            }            
        }
        if (bPrint)
            ExtOut ("\n");
        pSyncTable += SyncTableEntry::size();
    }
    
    ExtOut ("-----------------------------\n");
    ExtOut ("Total           %d\n", s_pSyncBlockCache.m_FreeSyncTableIndex);
    ExtOut ("ComCallWrapper  %d\n", CCWCount);
    ExtOut ("ComPlusWrapper  %d\n", RCWCount);
    ExtOut ("ComClassFactory %d\n", CFCount);
    ExtOut ("Free            %d\n", freeCount);

    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a Module          *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(FinalizeQueue)
{
    INIT_API();
    BOOL bDetail = FALSE;

    if (_stricmp (args,"-detail") == 0) {
        bDetail = TRUE;
    }
    
    DWORD_PTR p_s_pSyncBlockCache = GetAddressOf (offset_class_Global_Variables,
      offset_member_Global_Variables::g_SyncBlockCacheInstance);

    SyncBlockCache s_pSyncBlockCache;
    s_pSyncBlockCache.Fill (p_s_pSyncBlockCache);
    if (!CallStatus)
    {
        ExtOut ("Can not get mscoree!g_SyncBlockCacheInstance\n");
        return Status;
    }
    
    // Get cleanup list
    ULONG cleanCount = 0;
    DWORD_PTR cleanAddr = s_pSyncBlockCache.m_pCleanupBlockList;
    SyncBlock vSyncBlock;
    ULONG offsetLink = 
        SyncBlock::GetFieldOffset(offset_member_SyncBlock::m_Link);

    DWORD_PTR dwAddr;
    if (bDetail) {
        ExtOut ("To be cleaned Com Data\n");
    }
    while (cleanAddr) {
        dwAddr = cleanAddr - offsetLink;
        vSyncBlock.Fill (dwAddr);
        if (bDetail) {
            ExtOut ("%p  ", (ULONG64)(vSyncBlock.m_pComData&~3));
            switch (vSyncBlock.m_pComData & 3) {
            case 0:
                ExtOut ("ComCallWrapper\n");
                break;
            case 1:
                ExtOut ("ComPlusWrapper\n");
                break;
            case 3:
                ExtOut ("ComClassFactory\n");
                break;
            }
        }
        cleanCount ++;
        cleanAddr = (DWORD_PTR)vSyncBlock.m_Link.m_pNext;
    }
    ExtOut ("SyncBlock to be cleaned up: %d\n", cleanCount);

    static DWORD_PTR addrRCWCleanup = 0;
    if (addrRCWCleanup == 0) {
        addrRCWCleanup = GetAddressOf (offset_class_Global_Variables,
          offset_member_Global_Variables::g_pRCWCleanupList);

    }
    if (addrRCWCleanup == 0) {
        goto noRCW;
    }
    moveN (dwAddr, addrRCWCleanup);
    if (dwAddr == 0) {
        goto noRCW;
    }
    ExtOut ("----------------------------------\n");
    ComPlusWrapperCleanupList wrapperList;
    wrapperList.Fill (dwAddr);
    ComPlusApartmentCleanupGroup group;
    // Com Interfaces already in queue
    if (wrapperList.m_pMTACleanupGroup) {
        dwAddr = (DWORD_PTR)wrapperList.m_pMTACleanupGroup;
        group.Fill (dwAddr);
        DWORD count = ComPlusAptCleanupGroupInfo(&group, bDetail);
        ExtOut ("MTA interfaces to be released: %d\n", count);
    }

    // STA interfaces
    EEHashTableOfEEClass *pTable = &wrapperList.m_STAThreadToApartmentCleanupGroupMap;

    EEHashTableOfEEClass::BucketTable* pBucketTable;
    pBucketTable = ((EEHashTableOfEEClass::BucketTable*) pTable->m_pFirstBucketTable == &pTable->m_BucketTable[0]) ? 
                        &pTable->m_BucketTable[0]: 
                        &pTable->m_BucketTable[1];


    DWORD n;
    DWORD STACount = 0;
    if (pTable->m_dwNumEntries > 0) {
        for (n = 0; n < pBucketTable->m_dwNumBuckets; n ++) {
            if (IsInterrupt())
                break;
            DWORD_PTR dwBucketAddr = (size_t)pBucketTable->m_pBuckets + n * sizeof(PVOID);
            moveN (dwBucketAddr, dwBucketAddr);
            while (dwBucketAddr) {
                if (IsInterrupt())
                    break;
                DWORD_PTR dwAddr = dwBucketAddr;
                EEHashEntry vEntry;
                vEntry.Fill(dwAddr);
                dwBucketAddr = (DWORD_PTR)vEntry.pNext;
                dwAddr = (DWORD_PTR)vEntry.Data;
                group.Fill (dwAddr);
                dwAddr = (DWORD_PTR)group.m_pSTAThread;
                Thread vThread;
                vThread.Fill (dwAddr);
                ULONG id=0;
                ExtOut ("Thread ");
                if (g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id) == S_OK)
                {
                    ExtOut ("%3d", id);
                }
                else
                {
                    ExtOut ("XXX");
                }
                ExtOut ("(%#3x) ", vThread.m_ThreadId);
                DWORD count = ComPlusAptCleanupGroupInfo(&group, bDetail);
                ExtOut ("STA interfaces to be released: %d\n", count);
                STACount += count;
            }
        }
    }
    ExtOut ("Total STA interfaces to be released: %d\n", STACount);

noRCW:
    ExtOut ("----------------------------------\n");
    // GC Heap
    DWORD_PTR dwNHeaps = 1;
    if (IsServerBuild())
    {
        static DWORD_PTR dwAddrNHeaps = 0;
        if (dwAddrNHeaps == 0)
            dwAddrNHeaps = GetAddressOf (offset_class_gc_heap, 
                  offset_member_gc_heap::n_heaps);

        moveN (dwNHeaps, dwAddrNHeaps);
    }


    if (stat == NULL)
    {
        stat = (HeapStat *)malloc(sizeof (HeapStat));
        stat = new(stat) HeapStat;
    }

    ToDestroy des1 ((void**) &stat);
    
	CFinalize finalize;
    gc_heap heap = {0};
    int m;
    if (!IsServerBuild())
    {
        DWORD_PTR dwAddr = 0;
        heap.Fill (dwAddr);
        if (!CallStatus)
            return Status;
        dwAddr = (DWORD_PTR)heap.finalize_queue;
        finalize.Fill(dwAddr);
        for (m = 0; m <= heap.g_max_generation; m ++)
        {
            if (IsInterrupt())
                return Status;
             
            ExtOut ("generation %d has %d finalizable objects (%p->%p)\n",
                    m, finalize.m_FillPointers[NUMBERGENERATIONS-m-1] 
                    - finalize.m_FillPointers[NUMBERGENERATIONS-m-2],
					(ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-m-2],
					(ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-m-1]
					);
        }
        ExtOut ("Ready for finalization %d objects (%p->%p)\n",
                finalize.m_FillPointers[NUMBERGENERATIONS]
                - finalize.m_FillPointers[NUMBERGENERATIONS-1],
                (ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-1],
                (ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS]
                );
        for (dwAddr = (DWORD_PTR)finalize.m_FillPointers[NUMBERGENERATIONS - heap.g_max_generation - 2];
             dwAddr <= (DWORD_PTR)finalize.m_FillPointers[NUMBERGENERATIONS];
             dwAddr += sizeof (dwAddr)) {
            if (IsInterrupt())
                return Status;
            DWORD_PTR objAddr;
            if (g_ExtData->ReadVirtual(dwAddr, &objAddr, sizeof(objAddr), NULL) != S_OK) {
                continue;
            }
            DWORD_PTR MTAddr;
            if (g_ExtData->ReadVirtual(objAddr, &MTAddr, sizeof(MTAddr), NULL) != S_OK) {
                continue;
            }
            if (MTAddr) {
                size_t s = ObjectSize (objAddr);
                stat->Add (MTAddr, (DWORD)s);
            }
        }
    }
    else
    {
        DWORD_PTR dwAddrGHeaps =
            GetAddressOf (offset_class_gc_heap, offset_member_gc_heap::g_heaps);

        moveN (dwAddrGHeaps, dwAddrGHeaps);
        DWORD n;
        for (n = 0; n < dwNHeaps; n ++)
        {
            DWORD_PTR dwAddrGCHeap = dwAddrGHeaps + n*sizeof(VOID*);
            moveN (dwAddrGCHeap, dwAddrGCHeap);

            heap.Fill (dwAddrGCHeap);
            ExtOut ("------------------------------\n");
            ExtOut ("Heap %d\n", n);
            DWORD_PTR dwAddr = (DWORD_PTR)heap.finalize_queue;
            finalize.Fill(dwAddr);
            for (m = 0; m <= heap.g_max_generation; m ++)
            {
                if (IsInterrupt())
                    return Status;
                ExtOut ("generation %d has %d finalizable objects (%p->%p)\n",
                         m, finalize.m_FillPointers[NUMBERGENERATIONS-m-1] 
                         - finalize.m_FillPointers[NUMBERGENERATIONS-m-2],
						(ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-m-2],
						(ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-m-1]
						);
            }
            ExtOut ("Ready for finalization %d objects (%p->%p)\n",
                    finalize.m_FillPointers[NUMBERGENERATIONS]
                    - finalize.m_FillPointers[NUMBERGENERATIONS-1],
                    (ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS-1],
                    (ULONG64)finalize.m_FillPointers[NUMBERGENERATIONS]);
            for (dwAddr = (DWORD_PTR)finalize.m_FillPointers[NUMBERGENERATIONS - heap.g_max_generation - 2];
                 dwAddr <= (DWORD_PTR)finalize.m_FillPointers[NUMBERGENERATIONS];
                 dwAddr += sizeof (dwAddr)) {
                if (IsInterrupt())
                    return Status;
                DWORD_PTR objAddr;
                if (g_ExtData->ReadVirtual(dwAddr, &objAddr, sizeof(objAddr), NULL) != S_OK) {
                    continue;
                }
				DWORD_PTR MTAddr;
                if (g_ExtData->ReadVirtual(objAddr, &MTAddr, sizeof(MTAddr), NULL) != S_OK) {
                    continue;
                }
                if (MTAddr) {
                    size_t s = ObjectSize (objAddr);
                    stat->Add (MTAddr, (DWORD)s);
                }
            }
        }
    }
    
	PrintGCStat();

    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a Module          *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpModule)
{
    INIT_API();
    DWORD_PTR p_ModuleAddr = GetExpression (args);
    if (p_ModuleAddr == 0)
        return Status;
    Module v_Module;
    v_Module.Fill (p_ModuleAddr);
    if (!CallStatus)
    {
        ExtOut ("Fail to fill Module\n");
        return Status;
    }
    WCHAR FileName[MAX_PATH+1];
    FileNameForModule (&v_Module, FileName);
    ExtOut ("Name %ws\n", FileName[0] ? FileName : L"Unknown Module");
    ExtOut ("dwFlags %08x\n", v_Module.m_dwFlags);
    ExtOut ("Attribute ");
    if (v_Module.m_dwFlags & Module::IS_IN_MEMORY)
        ExtOut ("%s", "InMemory ");
    if (v_Module.m_dwFlags & Module::IS_PRELOAD)
        ExtOut ("%s", "Preload ");
    if (v_Module.m_dwFlags & Module::IS_PEFILE)
        ExtOut ("%s", "PEFile ");
    if (v_Module.m_dwFlags & Module::IS_REFLECTION)
        ExtOut ("%s", "Reflection ");
    if (v_Module.m_dwFlags & Module::IS_PRECOMPILE)
        ExtOut ("%s", "PreCompile ");
    if (v_Module.m_dwFlags & Module::IS_EDIT_AND_CONTINUE)
        ExtOut ("%s", "Edit&Continue ");
    if (v_Module.m_dwFlags & Module::SUPPORTS_UPDATEABLE_METHODS)
        ExtOut ("%s", "SupportsUpdateableMethods");
    ExtOut ("\n");
    ExtOut ("Assembly %p\n", (ULONG64)v_Module.m_pAssembly);

    ExtOut ("LoaderHeap* %p\n", (ULONG64)v_Module.m_pLookupTableHeap);
    ExtOut ("TypeDefToMethodTableMap* %p\n",
             (ULONG64)v_Module.m_TypeDefToMethodTableMap.pTable);
    ExtOut ("TypeRefToMethodTableMap* %p\n",
             (ULONG64)v_Module.m_TypeRefToMethodTableMap.pTable);
    ExtOut ("MethodDefToDescMap* %p\n",
             (ULONG64)v_Module.m_MethodDefToDescMap.pTable);
    ExtOut ("FieldDefToDescMap* %p\n",
             (ULONG64)v_Module.m_FieldDefToDescMap.pTable);
    ExtOut ("MemberRefToDescMap* %p\n",
             (ULONG64)v_Module.m_MemberRefToDescMap.pTable);
    ExtOut ("FileReferencesMap* %p\n",
             (ULONG64)v_Module.m_FileReferencesMap.pTable);
    ExtOut ("AssemblyReferencesMap* %p\n",
             (ULONG64)v_Module.m_AssemblyReferencesMap.pTable);
    
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a Domain          *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpDomain)
{
    INIT_API();
    DWORD_PTR p_DomainAddr = GetExpression (args);
    
    AppDomain v_AppDomain;
    if (p_DomainAddr)
    {
        ExtOut ("Domain: %p\n", (ULONG64)p_DomainAddr);
        v_AppDomain.Fill (p_DomainAddr);
        if (!CallStatus)
        {
            ExtOut ("Fail to fill AppDomain\n");
            return Status;
        }
        DomainInfo (&v_AppDomain);
        return Status;
    }
    
    // List all domain
    int numDomain;
    DWORD_PTR *domainList = NULL;
    GetDomainList (domainList, numDomain);
    ToDestroy des0 ((void**)&domainList);
    
    // The first one is the system domain.
    p_DomainAddr = domainList[0];
    ExtOut ("--------------------------------------\n");
    ExtOut ("System Domain: %p\n", (ULONG64)p_DomainAddr);
    v_AppDomain.Fill (p_DomainAddr);
    DomainInfo (&v_AppDomain);

    // The second one is the shared domain.
    p_DomainAddr = domainList[1];
    ExtOut ("--------------------------------------\n");
    ExtOut ("Shared Domain: %x\n", p_DomainAddr);
    SharedDomainInfo (p_DomainAddr);

    int n;
    int n0 = 2;
    for (n = n0; n < numDomain; n++)
    {
        if (IsInterrupt())
            break;

        p_DomainAddr = domainList[n];
        ExtOut ("--------------------------------------\n");
        ExtOut ("Domain %d: %x\n", n-n0+1, p_DomainAddr);
        if (p_DomainAddr == 0) {
            continue;
        }
        // Check if this domain already appears.
        int i;
        for (i = 0; i < n; i ++)
        {
            if (domainList[i] == p_DomainAddr)
                break;
        }
        if (i < n)
        {
            ExtOut ("Same as Domain %d\n", i-n0);
        }
        else
        {
            v_AppDomain.Fill (p_DomainAddr);
            DomainInfo (&v_AppDomain);
        }
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a RWLock          *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(RWLock)
{
    INIT_API();
    DWORD_PTR pAddr = 0;
    BOOL bDumpAll = FALSE;
    if (_stricmp (args, "-all") == 0)
        bDumpAll = TRUE;
    else
    {
        pAddr = GetExpression (args);
        if (pAddr == 0)
        {
            return Status;
        }
    }
    
    CRWLock v_RWLock = {0};
    if (!bDumpAll)
    {
        v_RWLock.Fill(pAddr);
        ExtOut ("MethodTable: %p\n", (ULONG64)v_RWLock._pMT);
        ExtOut ("WriterEvent=%x, ReaderEvent=%x\n",
                 v_RWLock._hWriterEvent, v_RWLock._hReaderEvent);
        ExtOut ("State: %x\n", v_RWLock._dwState);
        ExtOut ("ULockID=%x, LLockID=%x, WriterID=%x\n",
                 v_RWLock._dwULockID, v_RWLock._dwLLockID,
                 v_RWLock._dwWriterID);
        ExtOut ("WriterSeqNum=%x\n", v_RWLock._dwWriterSeqNum);
        ExtOut ("Flags=%x, WriterLevel=%x\n", v_RWLock._wFlags,
                 v_RWLock._wWriterLevel);
    }

    DWORD_PTR *threadList = NULL;
    int numThread = 0;
    GetThreadList (threadList, numThread);
    ToDestroy des0((void**)&threadList);
    
    Thread vThread;
    int i;

    for (i = 0; i < numThread; i++)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        if (vThread.m_pHead != NULL)
        {
            BOOL bNeedsHeader = TRUE;
            LockEntry vLockEntry;
            dwAddr = (DWORD_PTR)vThread.m_pHead;
            vLockEntry.Fill (dwAddr);
            if (!CallStatus)
                break;
            while (1)
            {
                if (vLockEntry.dwULockID || vLockEntry.dwLLockID)
                {
                    if (bDumpAll)
                    {
                        if (bNeedsHeader)
                        {
                            bNeedsHeader = FALSE;
                            ExtOut ("Thread: %8x   %p\n",
                                     vThread.m_ThreadId, (ULONG64)threadList[i]);
                        }
                        ExtOut ("ID %x:%x, ReaderLevel %d\n",
                                 vLockEntry.dwULockID,
                                 vLockEntry.dwLLockID,
                                 vLockEntry.wReaderLevel);
                    }
                    else if (v_RWLock._dwULockID == vLockEntry.dwULockID &&
                         v_RWLock._dwLLockID == vLockEntry.dwLLockID)
                        ExtOut ("Thread: %8x   %p\n", vThread.m_ThreadId,
                                 (ULONG64)threadList[i]);
                }
                if (vLockEntry.pNext == vThread.m_pHead)
                    break;
                dwAddr = (DWORD_PTR)vLockEntry.pNext;
                vLockEntry.Fill(dwAddr);
                if (!CallStatus)
                    break;
            }
        }
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a Assembly        *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpAssembly)
{
    INIT_API();
    DWORD_PTR p_AssemblyAddr = GetExpression (args);
    if (p_AssemblyAddr == 0)
        return Status;
    Assembly v_Assembly;
    v_Assembly.Fill (p_AssemblyAddr);
    if (!CallStatus)
    {
        ExtOut ("Fail to fill Assembly\n");
        return Status;
    }
    ExtOut ("Parent Domain: %p\n", (ULONG64)v_Assembly.m_pDomain);
    ExtOut ("Name: ");
    PrintString ((DWORD_PTR) v_Assembly.m_psName);
    ExtOut ("\n");
    AssemblyInfo (&v_Assembly);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a ClassLoader     *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API(DumpLoader)
{
    INIT_API();
    DWORD_PTR p_ClassLoaderAddr = GetExpression (args);
    if (p_ClassLoaderAddr == 0)
        return Status;
    ClassLoader v_ClassLoader;
    v_ClassLoader.Fill (p_ClassLoaderAddr);
    if (!CallStatus)
    {
        ExtOut ("Fail to fill ClassLoader\n");
        return Status;
    }
    ExtOut ("Assembly: %p\n", (ULONG64)v_ClassLoader.m_pAssembly);
    ExtOut ("Next ClassLoader: %p\n", (ULONG64)v_ClassLoader.m_pNext);
    ClassLoaderInfo(&v_ClassLoader);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the managed threads               *
*                                                                      *
\**********************************************************************/
DECLARE_API(Threads)
{
    INIT_API();

    DWORD_PTR p_g_pThreadStore = GetAddressOf (offset_class_Global_Variables, 
      offset_member_Global_Variables::g_pThreadStore);

    DWORD_PTR g_pThreadStore;
    HRESULT hr;
    if (FAILED (hr = g_ExtData->ReadVirtual (p_g_pThreadStore, &g_pThreadStore,
                                             sizeof (DWORD_PTR), NULL)))
        return hr;
    if (g_pThreadStore == 0)
        return S_FALSE;
    
    ThreadStore vThreadStore;
    DWORD_PTR dwAddr = g_pThreadStore;
    vThreadStore.Fill (dwAddr);
    if (!CallStatus)
    {
        ExtOut ("Fail to fill ThreadStore\n");
        return Status;
    }

    ExtOut ("ThreadCount: %d\n", vThreadStore.m_ThreadCount);
    ExtOut ("UnstartedThread: %d\n", vThreadStore.m_UnstartedThreadCount);
    ExtOut ("BackgroundThread: %d\n", vThreadStore.m_BackgroundThreadCount);
    ExtOut ("PendingThread: %d\n", vThreadStore.m_PendingThreadCount);
    ExtOut ("DeadThread: %d\n", vThreadStore.m_DeadThreadCount);
    
    
    DWORD_PTR *threadList = NULL;
    int numThread = 0;
    GetThreadList (threadList, numThread);
    ToDestroy des0((void**)&threadList);
    
    static DWORD_PTR FinalizerThreadAddr = 0;
    if (FinalizerThreadAddr == 0)
    {
        FinalizerThreadAddr = GetAddressOf (offset_class_GCHeap, 
          offset_member_GCHeap::FinalizerThread);

    }
    DWORD_PTR finalizerThread;
    moveN (finalizerThread, FinalizerThreadAddr);

    static DWORD_PTR GcThreadAddr = 0;
    if (GcThreadAddr == 0)
    {
        GcThreadAddr = GetAddressOf (offset_class_GCHeap, 
          offset_member_GCHeap::GcThread);

    }
    DWORD_PTR GcThread;
    moveN (GcThread, GcThreadAddr);

    // Due to a bug in dbgeng.dll of v1, getting debug thread id
    // more than once leads to deadlock.
    
    ExtOut ("                             PreEmptive        Lock  \n");
    ExtOut ("       ID ThreadOBJ    State     GC     Domain Count APT Exception\n");
    int i;
    Thread vThread;
    for (i = 0; i < numThread; i ++)
    {
        if (IsInterrupt())
            break;
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        if (!IsKernelDebugger()) {
            ULONG id=0;
            if (g_ExtSystem->GetThreadIdBySystemId (vThread.m_ThreadId, &id) == S_OK)
            {
                ExtOut ("%3d ", id);
            }
            else
            {
                ExtOut ("XXX ");
            }
        }
        else
            ExtOut ("    ");
        
        ExtOut ("%5x %p  %8x", vThread.m_ThreadId, (ULONG64)threadList[i],
                vThread.m_State);
        if (vThread.m_fPreemptiveGCDisabled == 1)
            ExtOut (" Disabled");
        else
            ExtOut (" Enabled ");

        Context vContext;
        DWORD_PTR dwAddrTmp = (DWORD_PTR)vThread.m_Context;
        vContext.Fill (dwAddrTmp);
        if (vThread.m_pDomain)
            ExtOut (" %p", (ULONG64)vThread.m_pDomain);
        else
        {
            ExtOut (" %p", (ULONG64)vContext.m_pDomain);
        }
        ExtOut (" %5d", vThread.m_dwLockCount);

        // Apartment state
        DWORD_PTR OleTlsDataAddr;
        if (SafeReadMemory((size_t)vThread.m_pTEB + offsetof(TEB,ReservedForOle),
                            &OleTlsDataAddr,
                            sizeof(OleTlsDataAddr), NULL) && OleTlsDataAddr != 0) {
            DWORD AptState;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,dwFlags),
                               &AptState,
                               sizeof(AptState), NULL)) {
                if (AptState & OLETLS_APARTMENTTHREADED) {
                    ExtOut (" STA");
                }
                else if (AptState & OLETLS_MULTITHREADED) {
                    ExtOut (" MTA");
                }
                else if (AptState & OLETLS_INNEUTRALAPT) {
                    ExtOut (" NTA");
                }
                else {
                    ExtOut (" Ukn");
                }
            }
            else
                ExtOut (" Ukn");
        }
        else
            ExtOut (" Ukn");
#if 0
        DWORD_PTR tmp = (DWORD_PTR)vThread.m_pSharedStaticData;
        if (tmp)
            tmp += offsetof(STATIC_DATA, dataPtr);
        ExtOut (" %p", (ULONG64)tmp);
        tmp = (DWORD_PTR)vThread.m_pUnsharedStaticData;
        if (tmp)
            tmp += offsetof(STATIC_DATA, dataPtr);
        ExtOut (" %p", (ULONG64)tmp);
        
        tmp = (DWORD_PTR)vContext.m_pSharedStaticData;
        if (tmp)
            tmp += offsetof(STATIC_DATA, dataPtr);
        ExtOut (" %p", (ULONG64)tmp);
        tmp = (DWORD_PTR)vContext.m_pUnsharedStaticData;
        if (tmp)
            tmp += offsetof(STATIC_DATA, dataPtr);
        ExtOut (" %p", (ULONG64)tmp);
#endif
        if (threadList[i] == finalizerThread)
            ExtOut (" (Finalizer)");
        if (threadList[i] == GcThread)
            ExtOut (" (GC)");
        if (vThread.m_State & Thread::TS_ThreadPoolThread) {
            if (vThread.m_State & Thread::TS_TPWorkerThread) {
                ExtOut (" (Threadpool Worker)");
            }
            else
                ExtOut (" (Threadpool Completion Port)");
        }
        if (!SafeReadMemory((DWORD_PTR)vThread.m_LastThrownObjectHandle,
                            &dwAddr,
                            sizeof(dwAddr), NULL))
            goto end_of_loop;
        if (dwAddr)
        {
            DWORD_PTR MTAddr;
            if (!SafeReadMemory(dwAddr, &MTAddr, sizeof(MTAddr), NULL))
                goto end_of_loop;
            MethodTable vMethTable;
            vMethTable.Fill (MTAddr);
            NameForMT (vMethTable, g_mdName);
            ExtOut (" %S", g_mdName);
        }
end_of_loop:
        ExtOut ("\n");
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the managed threadpool            *
*                                                                      *
\**********************************************************************/
DECLARE_API(ThreadPool)
{
    INIT_API();

    static DWORD_PTR cpuUtilizationAddr = 0;
    if (cpuUtilizationAddr == 0) {
        cpuUtilizationAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::cpuUtilization);
    }
    long lValue;
    if (g_ExtData->ReadVirtual(cpuUtilizationAddr,&lValue,sizeof(lValue),NULL) == S_OK
        && lValue != 0) {
        ExtOut ("CPU utilization %d%%\n", lValue);
    }
    
    ExtOut ("Worker Thread:");
    static DWORD_PTR NumWorkerThreadsAddr = 0;
    if (NumWorkerThreadsAddr == 0) {
        NumWorkerThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::NumWorkerThreads);
    }
    int iValue;
    if (g_ExtData->ReadVirtual(NumWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Total: %d", iValue);
    }
    
    static DWORD_PTR NumRunningWorkerThreadsAddr = 0;
    if (NumRunningWorkerThreadsAddr == 0) {
        NumRunningWorkerThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::NumRunningWorkerThreads);
    }
    if (g_ExtData->ReadVirtual(NumRunningWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Running: %d", iValue);
    }
    
    static DWORD_PTR NumIdleWorkerThreadsAddr = 0;
    if (NumIdleWorkerThreadsAddr == 0) {
        NumIdleWorkerThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::NumIdleWorkerThreads);
    }
    if (g_ExtData->ReadVirtual(NumIdleWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Idle: %d", iValue);
    }
    
    static DWORD_PTR MaxLimitTotalWorkerThreadsAddr = 0;
    if (MaxLimitTotalWorkerThreadsAddr == 0) {
        MaxLimitTotalWorkerThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::MaxLimitTotalWorkerThreads);
    }
    if (g_ExtData->ReadVirtual(MaxLimitTotalWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MaxLimit: %d", iValue);
    }
    
    static DWORD_PTR MinLimitTotalWorkerThreadsAddr = 0;
    if (MinLimitTotalWorkerThreadsAddr == 0) {
        MinLimitTotalWorkerThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::MinLimitTotalWorkerThreads);
    }
    if (g_ExtData->ReadVirtual(MinLimitTotalWorkerThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MinLimit: %d", iValue);
    }
    ExtOut ("\n");
    
    static DWORD_PTR NumQueuedWorkRequestsAddr = 0;
    if (NumQueuedWorkRequestsAddr == 0) {
        NumQueuedWorkRequestsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::NumQueuedWorkRequests);
    }
    if (g_ExtData->ReadVirtual(NumQueuedWorkRequestsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut ("Work Request in Queue: %d\n", iValue);
    }

    if (iValue > 0) {
        // Display work request
        static DWORD_PTR FQueueUserWorkItemCallback = 0;
        static DWORD_PTR FtimerDeleteWorkItem = 0;
        static DWORD_PTR FAsyncCallbackCompletion = 0;
        static DWORD_PTR FAsyncTimerCallbackCompletion = 0;

        if (FQueueUserWorkItemCallback == 0) {
            FQueueUserWorkItemCallback = GetAddressOf (offset_class_Global_Variables, 
              offset_member_Global_Variables::QueueUserWorkItemCallback);
        }
        if (FtimerDeleteWorkItem == 0) {
            FtimerDeleteWorkItem = GetAddressOf (offset_class_TimerNative, 
              offset_member_TimerNative::timerDeleteWorkItem);
        }
        if (FAsyncCallbackCompletion == 0) {
            FAsyncCallbackCompletion = GetAddressOf (offset_class_ThreadpoolMgr, 
              offset_member_ThreadpoolMgr::AsyncCallbackCompletion);
        }
        if (FAsyncTimerCallbackCompletion == 0) {
            FAsyncTimerCallbackCompletion = GetAddressOf (offset_class_ThreadpoolMgr, 
              offset_member_ThreadpoolMgr::AsyncTimerCallbackCompletion);
        }

        static DWORD_PTR headAddr = 0;
        static DWORD_PTR tailAddr = 0;
        if (headAddr == 0) {
            headAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
              offset_member_ThreadpoolMgr::WorkRequestHead);
        }
        if (tailAddr == 0) {
            tailAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
              offset_member_ThreadpoolMgr::WorkRequestTail);
        }
        DWORD_PTR head;
        g_ExtData->ReadVirtual(headAddr,&head,sizeof(head),NULL);
        DWORD_PTR dwAddr = head;
        WorkRequest work;
        while (dwAddr) {
            if (IsInterrupt())
                break;
            work.Fill(dwAddr);
            if ((DWORD_PTR)work.Function == FQueueUserWorkItemCallback)
                ExtOut ("QueueUserWorkItemCallback DelegateInfo@%p\n", (ULONG64)work.Context);
            else if ((DWORD_PTR)work.Function == FtimerDeleteWorkItem)
                ExtOut ("timerDeleteWorkItem TimerDeleteInfo@%p\n", (ULONG64)work.Context);
            else if ((DWORD_PTR)work.Function == FAsyncCallbackCompletion)
                ExtOut ("AsyncCallbackCompletion AsyncCallback@%p\n", (ULONG64)work.Context);
            else if ((DWORD_PTR)work.Function == FAsyncTimerCallbackCompletion)
                ExtOut ("AsyncTimerCallbackCompletion TimerInfo@%p\n", (ULONG64)work.Context);
            else
                ExtOut ("Unknown %p\n", (ULONG64)work.Context);
            
            dwAddr = (DWORD_PTR)work.next;
        }
    }
    ExtOut ("--------------------------------------\n");

    static DWORD_PTR NumTimersAddr = 0;
    if (NumTimersAddr == 0) {
        NumTimersAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::NumTimers);
    }
    DWORD dValue;
    if (g_ExtData->ReadVirtual(NumTimersAddr,&dValue,sizeof(dValue),NULL) == S_OK) {
        ExtOut ("Number of Timers: %d\n", dValue);
    }

    ExtOut ("--------------------------------------\n");
    
    ExtOut ("Completion Port Thread:");
    
    static DWORD_PTR NumCPThreadsAddr = 0;
    if (NumCPThreadsAddr == 0) {
        NumCPThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::NumCPThreads);
    }
    if (g_ExtData->ReadVirtual(NumCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Total: %d", iValue);
    }

    static DWORD_PTR NumFreeCPThreadsAddr = 0;
    if (NumFreeCPThreadsAddr == 0) {
        NumFreeCPThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::NumFreeCPThreads);
    }
    if (g_ExtData->ReadVirtual(NumFreeCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" Free: %d", iValue);
    }

    static DWORD_PTR MaxFreeCPThreadsAddr = 0;
    if (MaxFreeCPThreadsAddr == 0) {
        MaxFreeCPThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::MaxFreeCPThreads);
    }
    if (g_ExtData->ReadVirtual(MaxFreeCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MaxFree: %d", iValue);
    }

    static DWORD_PTR CurrentLimitTotalCPThreadsAddr = 0;
    if (CurrentLimitTotalCPThreadsAddr == 0) {
        CurrentLimitTotalCPThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::CurrentLimitTotalCPThreads);
    }
    if (g_ExtData->ReadVirtual(CurrentLimitTotalCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" CurrentLimit: %d", iValue);
    }

    static DWORD_PTR MaxLimitTotalCPThreadsAddr = 0;
    if (MaxLimitTotalCPThreadsAddr == 0) {
        MaxLimitTotalCPThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::MaxLimitTotalCPThreads);
    }
    if (g_ExtData->ReadVirtual(MaxLimitTotalCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MaxLimit: %d", iValue);
    }

    static DWORD_PTR MinLimitTotalCPThreadsAddr = 0;
    if (MinLimitTotalCPThreadsAddr == 0) {
        MinLimitTotalCPThreadsAddr = GetAddressOf (offset_class_ThreadpoolMgr, 
          offset_member_ThreadpoolMgr::MinLimitTotalCPThreads);
    }
    if (g_ExtData->ReadVirtual(MinLimitTotalCPThreadsAddr,&iValue,sizeof(iValue),NULL) == S_OK) {
        ExtOut (" MinLimit: %d", iValue);
    }

    ExtOut ("\n");

    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to get the COM state (e.g. APT,contexe    *
*    activity.                                                         *  
*                                                                      *
\**********************************************************************/
DECLARE_API(COMState)
{
    INIT_API();

    ULONG numThread;
    ULONG maxId;
    g_ExtSystem->GetTotalNumberThreads(&numThread,&maxId);

    ULONG curId;
    g_ExtSystem->GetCurrentThreadId(&curId);

    ULONG *ids = (ULONG*)alloca(sizeof(ULONG)*numThread);
    ULONG *sysIds = (ULONG*)alloca(sizeof(ULONG)*numThread);
    g_ExtSystem->GetThreadIdsByIndex(0,numThread,ids,sysIds);

    ExtOut ("     ID     TEB   APT    APTId CallerTID Context\n");
    for (ULONG i = 0; i < numThread; i ++) {
        g_ExtSystem->SetCurrentThreadId(ids[i]);
        ULONG64 tebAddr;
        g_ExtSystem->GetCurrentThreadTeb(&tebAddr);
        ExtOut ("%3d %4x %p", ids[i], sysIds[i], tebAddr);
        // Apartment state
        DWORD_PTR OleTlsDataAddr;
        if (SafeReadMemory((ULONG_PTR)tebAddr + offsetof(TEB,ReservedForOle),
                            &OleTlsDataAddr,
                            sizeof(OleTlsDataAddr), NULL) && OleTlsDataAddr != 0) {
            DWORD AptState;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,dwFlags),
                               &AptState,
                               sizeof(AptState), NULL)) {
                if (AptState & OLETLS_APARTMENTTHREADED) {
                    ExtOut (" STA");
                }
                else if (AptState & OLETLS_MULTITHREADED) {
                    ExtOut (" MTA");
                }
                else if (AptState & OLETLS_INNEUTRALAPT) {
                    ExtOut (" NTA");
                }
                else {
                    ExtOut (" Ukn");
                }
            }
            else
                ExtOut (" Ukn");
            
            DWORD dwApartmentID;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,dwApartmentID),
                               &dwApartmentID,
                               sizeof(dwApartmentID), NULL)) {
                ExtOut (" %8x", dwApartmentID);
            }
            else
                ExtOut (" %8x", 0);
            
            DWORD dwTIDCaller;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,dwTIDCaller),
                               &dwTIDCaller,
                               sizeof(dwTIDCaller), NULL)) {
                ExtOut ("  %8x", dwTIDCaller);
            }
            else
                ExtOut ("  %8x", 0);
            
            size_t Context;
            if (SafeReadMemory(OleTlsDataAddr+offsetof(SOleTlsData,pCurrentCtx),
                               &Context,
                               sizeof(Context), NULL)) {
                ExtOut (" %p", (ULONG64)Context);
            }
            else
                ExtOut (" %p", (ULONG64)0);
        }
        else
            ExtOut (" Ukn");
        ExtOut ("\n");
    }

    g_ExtSystem->SetCurrentThreadId(curId);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the GC encoding of a managed      *
*    function.                                                         *  
*                                                                      *
\**********************************************************************/
DECLARE_API(GCInfo)
{
    DWORD_PTR dwStartAddr;
    MethodDesc MD;

    INIT_API();

    dwStartAddr = GetExpression(args);
    DWORD_PTR tmpAddr = dwStartAddr;
    if (!IsMethodDesc(dwStartAddr)) {
        JitType jitType;
        DWORD_PTR methodDesc;
        DWORD_PTR gcinfoAddr;
        IP2MethodDesc (dwStartAddr, methodDesc, jitType, gcinfoAddr);
        if (methodDesc) {
            tmpAddr = methodDesc;
        }
        else
            tmpAddr = 0;
    }

    if (tmpAddr == 0)
    {
        ExtOut("not a valid MethodDesc\n");
        return Status;
    }

    MD.Fill (tmpAddr);
    if (!CallStatus)
        return Status;
    
    if(MD.m_CodeOrIL & METHOD_IS_IL_FLAG)
    {
        ExtOut("No GC info available\n");
        return Status;
    }

    CodeInfo infoHdr;
    CodeInfoForMethodDesc (MD, infoHdr);
    if (infoHdr.jitType == UNKNOWN)
    {
        ExtOut ("unknown Jit\n");
        return Status;
    }
    else if (infoHdr.jitType == EJIT)
    {
        ExtOut ("GCinfo for EJIT not supported\n");
        return Status;
    }
    else if (infoHdr.jitType == JIT)
    {
        ExtOut ("Normal JIT generated code\n");
    }
    else if (infoHdr.jitType == PJIT)
    {
        ExtOut ("preJIT generated code\n");
    }
    
    DWORD_PTR vAddr = infoHdr.gcinfoAddr;
    GCDump gcDump;
    gcDump.gcPrintf = ExtOut;

    // assume that GC encoding table is never more than
    // 40 + methodSize * 2
    int tableSize = 40 + infoHdr.methodSize*2;
    BYTE *table = (BYTE*) _alloca (tableSize);
    memset (table, 0, tableSize);
    // We avoid using move here, because we do not want to return
    if (!SafeReadMemory(vAddr, table, tableSize, NULL))
    {
        ExtOut ("Could not read memory %p\n", (ULONG64)vAddr);
        return Status;
    }
    
    InfoHdr header;
    ExtOut ("Method info block:\n");
    table += gcDump.DumpInfoHdr(table, &header, &infoHdr.methodSize, 0);
    ExtOut ("\n");
    ExtOut ("Pointer table:\n");
    table += gcDump.DumpGCTable(table, header, infoHdr.methodSize, 0);    
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to unassembly a managed function.         *
*    It tries to print symbolic info for function call, contants...    *  
*                                                                      *
\**********************************************************************/
DECLARE_API(u)
{
    DWORD_PTR dwStartAddr;
    MethodDesc MD;

    INIT_API();

    dwStartAddr = GetExpression (args);
    
    DWORD_PTR tmpAddr = dwStartAddr;
    CodeInfo infoHdr;
    DWORD_PTR methodDesc = tmpAddr;
    if (!IsMethodDesc (tmpAddr))
    {
        tmpAddr = dwStartAddr;
        IP2MethodDesc (tmpAddr, methodDesc, infoHdr.jitType,
                       infoHdr.gcinfoAddr);
        if (!methodDesc || infoHdr.jitType == UNKNOWN)
        {
            // It is not managed code.
            ExtOut ("Unmanaged code\n");
            UnassemblyUnmanaged(dwStartAddr);
            return Status;
        }
        tmpAddr = methodDesc;
    }
    MD.Fill (tmpAddr);
    if (!CallStatus)
        return Status;
    

    if(MD.m_CodeOrIL & METHOD_IS_IL_FLAG)
    {
        ExtOut("Not jitted yet\n");
        return Status;
    }

    CodeInfoForMethodDesc (MD, infoHdr);
    if (infoHdr.IPBegin == 0)
    {
        ExtOut("not a valid MethodDesc\n");
        return Status;
    }
    if (infoHdr.jitType == UNKNOWN)
    {
        ExtOut ("unknown Jit\n");
        return Status;
    }
    else if (infoHdr.jitType == EJIT)
    {
        ExtOut ("EJIT generated code\n");
    }
    else if (infoHdr.jitType == JIT)
    {
        ExtOut ("Normal JIT generated code\n");
    }
    else if (infoHdr.jitType == PJIT)
    {
        ExtOut ("preJIT generated code\n");
    }
    CQuickBytes fullname;
    FullNameForMD (&MD, &fullname);
    ExtOut ("%S\n", (WCHAR*)fullname.Ptr());
    
    ExtOut ("Begin %p, size %x\n", (ULONG64)infoHdr.IPBegin, infoHdr.methodSize);

    Unassembly (infoHdr.IPBegin, infoHdr.IPBegin+infoHdr.methodSize);
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to search a DWORD on stack                *
*                                                                      *
\**********************************************************************/
DECLARE_API (SearchStack)
{
    INIT_API();

    DWORD_PTR num[2];
    int index = 0;
    
    while (isspace (args[0]))
        args ++;
    char buffer[100];
    strcpy (buffer, args);
    LPSTR pch = buffer;
    while (pch[0] != '\0')
    {
        if (IsInterrupt())
            return Status;
        while (isspace (pch[0]))
            pch ++;
        char *endptr;
        num[index] = strtoul (pch, &endptr, 16);
        if (pch == endptr)
        {
            ExtOut ("wrong argument\n");
            return Status;
        }
        index ++;
        if (index == 2)
            break;
        pch = endptr;
    }

    DWORD_PTR top;
    ULONG64 StackOffset;
    g_ExtRegisters->GetStackOffset (&StackOffset);
    if (index <= 1)
    {
        top = (DWORD_PTR)StackOffset;
    }
    else
    {
        top = num[1];
    }
    
    DWORD_PTR end = top + 0xFFFF;
    DWORD_PTR ptr = top & ~3;  // make certain dword aligned
    while (ptr < end)
    {
        if (IsInterrupt())
            return Status;
        DWORD_PTR value;
        moveN (value, ptr);
        if (value == num[0])
            ExtOut ("%p\n", (ULONG64)ptr);
        ptr += sizeof (DWORD_PTR);
    }
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a CrawlFrame      *
*    for a given address                                               *  
*                                                                      *
\**********************************************************************/
DECLARE_API (DumpCrawlFrame)
{
    INIT_API();
    DWORD_PTR dwStartAddr = GetExpression(args);
    if (dwStartAddr == 0)
        return Status;
    
    CrawlFrame crawlFrame;
    moveN (crawlFrame, dwStartAddr);
    ExtOut ("MethodDesc: %p\n", (ULONG64)crawlFrame.pFunc);
    REGDISPLAY RD;
    moveN (RD, crawlFrame.pRD);
    DWORD_PTR Edi, Esi, Ebx, Edx, Ecx, Eax, Ebp, PC;
    moveN (Edi, RD.pEdi);
    moveN (Esi, RD.pEsi);
    moveN (Ebx, RD.pEbx);
    moveN (Edx, RD.pEdx);
    moveN (Ecx, RD.pEcx);
    moveN (Eax, RD.pEax);
    moveN (Ebp, RD.pEbp);
    moveN (PC, RD.pPC);
    
    ExtOut ("EDI=%8x ESI=%8x EBX=%8x EDX=%8x ", Edi, Esi, Ebx, Edx);
    ExtOut ("ECX=%8x EAX=%8x\n", Ecx, Eax);
    ExtOut ("EBP=%8x ESP=%8x PC=%8x\n", Ebp, RD.Esp, PC);
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the build number and type of the  *  
*    mscoree.dll                                                       *
*                                                                      *
\**********************************************************************/
DECLARE_API (EEVersion)
{
    INIT_API();

    if (GetEEFlavor() == UNKNOWNEE) {
        ExtOut("CLR not loaded\n");
        return Status;
    }

    static DWORD_PTR dwg_Version = GetAddressOf (offset_class_Global_Variables, 
      offset_member_Global_Variables::g_Version);

#ifdef GOLDEN
    static DWORD_PTR dwg_ProbeGolden = GetAddressOf (offset_class_gc_heap, 
      offset_member_gc_heap::verify_heap);

    BOOL bGolden = (dwg_ProbeGolden == 0);
#endif
    WCHAR buffer[100];
    
    if (g_ExtSymbols2) {
        static VS_FIXEDFILEINFO version;
        static DWORD fDone = 0;
        if (fDone == 0) {
            if (g_ExtSymbols2->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                           moduleInfo[GetEEFlavor()].baseAddr,
                                                           "\\", &version, sizeof(VS_FIXEDFILEINFO), NULL)
                == S_OK)
                fDone = 1;
            else
                fDone = 2;
        }
        if (fDone == 1) {
            if(version.dwFileVersionMS != (DWORD)-1)
            {
                ExtOut("%u.%u.%u.%u",
                       HIWORD(version.dwFileVersionMS),
                       LOWORD(version.dwFileVersionMS),
                       HIWORD(version.dwFileVersionLS),
                       LOWORD(version.dwFileVersionLS));
                if (version.dwFileFlags & VS_FF_DEBUG) {
                    GetVersionString (buffer);
                    if (wcsstr(buffer, L"Debug")) {
                        ExtOut (" checked");
                    }
                    else if (wcsstr(buffer, L"fastchecked")) {
                        ExtOut (" fastchecked");
                    }
                    else {
                        ExtOut (" unknown debug build\n");
                    }
                }
                else
                { 
                    static BOOL fRet = IsRetailBuild ((size_t)moduleInfo[GetEEFlavor()].baseAddr);
                    if (fRet) {
                        ExtOut (" retail");
                    }
                    else
                        ExtOut (" free");
                }

#ifdef GOLDEN
                if (bGolden) {
                    ExtOut (" Golden");
                }
#endif
                ExtOut ("\n");

                goto BuildType;
            }
        }
    }

    GetVersionString (buffer);
    if (buffer[0] != L'\0') {
        WCHAR *pt = wcsstr(buffer, L"Debug");
        if (pt == NULL)
            pt = wcsstr(buffer, L"fastchecked");
        if ((DebugVersionDll == 1 && pt == NULL)
            || (DebugVersionDll == 0 && pt != NULL))
        {
            ExtOut ("mismatched mscoree.dll and symbol file\n");
        }
        ExtOut ("%S", buffer);


        if (DebugVersionDll == 0)
        {
            static BOOL fRet = IsRetailBuild ((size_t)moduleInfo[GetEEFlavor()].baseAddr);
            if (fRet) {
                ExtOut (" retail");
            }
            else
                ExtOut (" free");
        }

#ifdef GOLDEN
        if (bGolden)
            ExtOut (" Golden");
#endif

        ExtOut ("\n");
    }
    
BuildType:
    if (IsServerBuild())
    {
        static DWORD_PTR dwAddrNHeaps = 0;
        if (dwAddrNHeaps == 0)
            dwAddrNHeaps =
                GetAddressOf (offset_class_gc_heap, 
                  offset_member_gc_heap::n_heaps);

        DWORD_PTR dwNHeaps;
        moveN (dwNHeaps, dwAddrNHeaps);
        ExtOut ("Server build with %d gc heaps\n", dwNHeaps);
    }
    else
        ExtOut ("Workstation build\n");

    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to set the symbol and source path         *  
*                                                                      *
\**********************************************************************/
DECLARE_API (EEDebug)
{
    INIT_API();
    while (isspace (args[0]))
        args ++;
    if (args[0] == '\0') {
        ExtOut ("Usage: EEDebug 2204\n");
        return Status;
    }
    char buffer[100];
    strcpy (buffer, args);
    LPSTR version = buffer;
    LPSTR flavor = buffer;
    while (flavor[0] != '\0' && !isspace(flavor[0])) {
        flavor ++;
    }
    if (flavor[0] != '\0') {
        flavor[0] = '\0';
        flavor++;
        while (isspace (flavor[0])) {
            flavor ++;
        }
    }
    
    if (flavor[0] != '\0') {
        ExtOut ("Usage: EEDebug 2204\n");
        return Status;
    }
    
    char *EESymbol="symsrv*symsrv.dll*\\\\urtdist\\builds\\symbols";
    char *NTSymbol="symsrv*symsrv.dll*\\\\symbols\\symbols";
    char symbol[2048];
    g_ExtSymbols->GetSymbolPath(symbol,2048,NULL);
    char Final[2048] = "\0";
    char *pt = symbol;
    BOOL fExist = FALSE;
    BOOL fCopy;
    BOOL fServer = FALSE;
    while (pt) {
        char *sep = strchr (pt, ';');
        if (sep) {
            sep[0] = '\0';
        }
        char *server = NULL;
        if (_strnicmp(pt,"symsrv*symsrv.dll*",sizeof("symsrv*symsrv.dll*")-1) == 0) {
            server = pt + sizeof("symsrv*symsrv.dll*")-1;
        }
        else if (_strnicmp(pt,"srv*",sizeof("srv*")-1) == 0) {
            server = pt + sizeof("srv*")-1;
        }
        if (server)
        {        
            char *tmp = strstr (server, "\\\\");
            if (tmp) {
                server = tmp;
            }
            if (!fExist && _stricmp (server, "\\\\urtdist\\builds\\symbols") == 0) {
                fExist = TRUE;
            }
            else if (!fServer && _stricmp (server, "\\\\symbols\\symbols") == 0) {
                fServer = TRUE;
            }
        }
        if (sep == NULL) {
            break;
        }
        else
        {
            sep[0] = ';';
            pt = sep + 1;
        }
        if (fExist && fServer) {
            break;
        }
    }

    if (!fExist || !fServer) {
        strcpy (Final,symbol);
    }
    if (!fExist) {
        if (Final[0] != '\0') {
            strcat (Final, ";");
        }
        strcat (Final, EESymbol);
    }

    if (!fServer) {
        // Add symbol server path.
        if (Final[0] != '\0') {
            strcat (Final, ";");
        }
        strcat (Final, NTSymbol);
    }
    if (!fExist || !fServer) {
        g_ExtSymbols->SetSymbolPath(Final);
    }
    // g_ExtSymbols->AddSymbolOptions(SYMOPT_UNDNAME | SYMOPT_LOAD_LINES | SYMOPT_NO_CPP);
    const char *EEFileRoot = "\\\\urtdist\\builds\\src\\";
    const char *EEFileTail = "\\lightning\\src\\vm";
    char EEFile[MAX_PATH];
    strcpy (EEFile, EEFileRoot);
    strcat (EEFile, version);
    strcat (EEFile, EEFileTail);
    strcpy (symbol, EEFile);
    strcat (symbol, "\\ceemain.cpp");
    
    //strcpy (Final,".lsrcpath ");
    //strcat (Final,EEFile);
    //g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,"$<R:\temp\test.txt",DEBUG_EXECUTE_DEFAULT);
    
    if (!FileExist (symbol)) {
        ExtOut ("%s not exist\n", EEFile);
        return Status;
    }
    g_ExtSymbols->GetSourcePath(symbol,2048,NULL);
    pt = symbol;
    strcpy (Final, EEFile);
    strcat (Final, ";");
    while (pt) {
        fCopy = TRUE;
        char *sep = strchr (pt, ';');
        if (sep) {
            sep[0] = '\0';
        }
        if (_strnicmp (pt, EEFileRoot, strlen(EEFileRoot)) == 0) {
            if (_stricmp (pt, EEFile) == 0) {
                fCopy = FALSE;
            }
            else {
                char *tmp = pt + strlen(EEFileRoot);
                tmp = strchr (tmp, '\\');
                if (tmp) {
                    tmp++;
                    tmp = strchr (tmp, '\\');
                    if (tmp) {
                        if (_strnicmp (tmp, EEFileTail, strlen(EEFileTail)) == 0) {
                            fCopy = FALSE;
                        }
                    }
                }
            }
        }
        if (fCopy) {
            strcat (Final, pt);
            if (sep) {
                strcat (Final, ";");
            }
        }
        if (sep == NULL) {
            break;
        }
        else
        {
            pt = sep + 1;
        }
    }
    if (Final[strlen(Final)-1] == ';') {
        Final[strlen(Final)-1] = '\0';
    }
    g_ExtSymbols->SetSourcePath(Final);

    return Status;
}


EEDllPath *DllPath = NULL;

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to set the path for managed dlls          *
*    for dumps.  
*                                                                      *
\**********************************************************************/
DECLARE_API (EEDLLPath)
{
    INIT_API();

    if (!IsDumpFile() && !IsKernelDebugger()) {
        ExtOut ("Can not set path for managed dll for live user debugging\n");
        return Status;
    }

    if (DllPath == NULL) {
        DllPath = new EEDllPath;
    }

    while (isspace (args[0]))
        args ++;

    char EEPath[MAX_PATH];
    if (args[0] == '\0') {
        DllPath->DisplayPath();
    }
    else if (_strnicmp (args, "-reset", sizeof("-reset")-1) == 0) {
        DllPath->Reset();
    }
    else if (_strnicmp (args, "-std", sizeof("-std")-1) == 0) {
        args += sizeof("-std")-1;
        if (!isspace(args[0])) {
            ExtOut ("Usage: EEDLLPath -std 2204 x86chk\n");
            return Status;
        }
        while (isspace(args[0])) {
            args ++;
        }
        char *buffer = (char *)_alloca(strlen(args));
        strcpy (buffer, args);
        LPSTR version = buffer;
        LPSTR flavor = buffer;
        while (flavor[0] != '\0' && !isspace(flavor[0])) {
            flavor ++;
        }
        if (flavor[0] == '\0') {
            ExtOut ("Usage: EEDLLPath -std 2204 x86chk\n");
            return Status;
        }
        flavor[0] = '\0';
        flavor++;
        while (isspace (flavor[0])) {
            flavor ++;
        }
        if (flavor[0] == '\0') {
            ExtOut ("Usage: EEDLLPath -std 2204 x86chk\n");
            return Status;
        }

        const char *URTRoot = "\\\\urtdist\\builds\\bin\\";
        strcpy (EEPath, URTRoot);
        strcat (EEPath, version);
        strcat (EEPath, "\\");
        strcat (EEPath, flavor);
        strcat (EEPath, "\\");
        char *ptr = EEPath + strlen(EEPath);
        char *end;
        strcpy (ptr, "NDP");
        end = EEPath + strlen(EEPath);
        strcpy (end, "\\mscorlib.dll");
        if (FileExist(EEPath)) {
            end[0] = '\0';
            DllPath->AddPath(EEPath);
        }
        else
        {
            strcpy (ptr, "DNA");
            end = EEPath + strlen(EEPath);
            strcpy (end, "\\System.Dll");
            if (!FileExist(EEPath)) {
                ExtOut ("%s not exist\n", EEPath);
            }
            else
            {
                end[0] = '\0';
                DllPath->AddPath(EEPath);
            }

            strcpy (ptr, "lightning\\workstation");
            end = EEPath + strlen(EEPath);
            strcpy (end, "\\mscorlib.dll");
            if (!FileExist(EEPath)) {
                ExtOut ("%s not exist\n", EEPath);
            }
            else {
                end[0] = '\0';
                DllPath->AddPath(EEPath);
            }
        }
    
        strcpy (ptr, "config");
        end = EEPath + strlen(EEPath);
        strcpy (end, "\\System.Management.dll");
        if (!FileExist(EEPath)) {
            ExtOut ("%s not exist\n", EEPath);
        }
        else {
            end[0] = '\0';
            DllPath->AddPath(EEPath);
        }
    }
    else
    {
        const char *ptr = args;
        char *sep;
        while (ptr) {
            sep = strchr (ptr, ';');
            if (sep) {
                int length = sep-ptr;
                strncpy (EEPath,ptr,length);
                EEPath[length] = '\0';
                DllPath->AddPath(EEPath);
            }
            else {
                DllPath->AddPath(ptr);
                break;
            }

        }
    }
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to set the symbol option suitable for     *  
*    strike.                                                           *
*                                                                      *
\**********************************************************************/
DECLARE_API (SymOpt)
{
    INIT_API();

    ULONG Options;
    g_ExtSymbols->GetSymbolOptions(&Options);
    ULONG NewOptions = Options | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES | SYMOPT_NO_CPP;
    ExtOut ("%x\n", Options);
    if (Options != NewOptions)
        g_ExtSymbols->SetSymbolOptions(Options);
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to print the environment setting for      *  
*    the current process.                                              *
*                                                                      *
\**********************************************************************/
DECLARE_API (ProcInfo)
{
    INIT_API();

#define INFO_ENV        0x00000001
#define INFO_TIME       0x00000002
#define INFO_MEM        0x00000004
#define INFO_ALL        0xFFFFFFFF

    DWORD fProcInfo = INFO_ALL;

    if (_stricmp (args, "-env") == 0) {
        fProcInfo = INFO_ENV;
    }

    if (_stricmp (args, "-time") == 0) {
        fProcInfo = INFO_TIME;
    }

    if (_stricmp (args, "-mem") == 0) {
        fProcInfo = INFO_MEM;
    }

    if (fProcInfo & INFO_ENV) {
        ExtOut ("---------------------------------------\n");
        ExtOut ("Environment\n");
        ULONG64 pPeb;
        g_ExtSystem->GetCurrentProcessPeb(&pPeb);

        static ULONG Offset_ProcessParam = -1;
        static ULONG Offset_Environment = -1;
        if (Offset_ProcessParam == -1)
        {
            ULONG TypeId;
            ULONG64 NtDllBase;
            if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName ("ntdll",0,NULL,
                                                               &NtDllBase)))
            {
                if (SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "PEB", &TypeId)))
                {
                    if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                         "ProcessParameters", &Offset_ProcessParam)))
                        Offset_ProcessParam = -1;
                }
                if (SUCCEEDED(g_ExtSymbols->GetTypeId (NtDllBase, "_RTL_USER_PROCESS_PARAMETERS", &TypeId)))
                {
                    if (FAILED (g_ExtSymbols->GetFieldOffset(NtDllBase, TypeId,
                                                         "Environment", &Offset_Environment)))
                        Offset_Environment = -1;
                }
            }
        }
        // We can not get it from PDB.  Use the fixed one.
        if (Offset_ProcessParam == -1)
            Offset_ProcessParam = offsetof (PEB, ProcessParameters);

        if (Offset_Environment == -1)
            Offset_Environment = offsetof (_RTL_USER_PROCESS_PARAMETERS, Environment);


        ULONG64 addr = pPeb + Offset_ProcessParam;
        DWORD_PTR value;
        g_ExtData->ReadVirtual(addr, &value, sizeof(PVOID), NULL);
        addr = value + Offset_Environment;
        g_ExtData->ReadVirtual(addr, &value, sizeof(PVOID), NULL);

        static WCHAR buffer[OS_PAGE_SIZE/2];
        static ULONG readBytes = 0;
        if (readBytes == 0) {
            ULONG64 Page;
            readBytes = OS_PAGE_SIZE;
            if ((g_ExtData->ReadDebuggerData( DEBUG_DATA_MmPageSize, &Page, sizeof(Page), NULL)) == S_OK
                && Page > 0)
            {
                ULONG PageSize = (ULONG)(ULONG_PTR)Page;
                if (readBytes > PageSize) {
                    readBytes = PageSize;
                }
            }        
        }
        addr = value;
        while (1) {
            if (IsInterrupt())
                return Status;
            if (FAILED(g_ExtData->ReadVirtual(addr, &buffer, readBytes, NULL)))
                break;
            addr += readBytes;
            WCHAR *pt = buffer;
            WCHAR *end = pt;
            while (pt < &buffer[OS_PAGE_SIZE/2]) {
                end = wcschr (pt, L'\0');
                if (end == NULL) {
                    char format[20];
                    sprintf (format, "%dS", &buffer[OS_PAGE_SIZE/2] - pt);
                    ExtOut (format, pt);
                    break;
                }
                else if (end == pt) {
                    break;
                }
                ExtOut ("%S\n", pt);
                pt = end + 1;
            }
            if (end == pt) {
                break;
            }
        }
    }
    
    HANDLE hProcess = INVALID_HANDLE_VALUE;
    if (fProcInfo & (INFO_TIME | INFO_MEM)) {
        ULONG64 handle;
        g_ExtSystem->GetCurrentProcessHandle(&handle);
        hProcess = (HANDLE)handle;
    }
    
    if (!IsDumpFile() && fProcInfo & INFO_TIME) {
        FILETIME CreationTime;
        FILETIME ExitTime;
        FILETIME KernelTime;
        FILETIME UserTime;

        typedef BOOL (WINAPI *FntGetProcessTimes)(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME);
        static FntGetProcessTimes pFntGetProcessTimes = (FntGetProcessTimes)-1;
        if (pFntGetProcessTimes == (FntGetProcessTimes)-1) {
            HINSTANCE hstat = LoadLibrary ("Kernel32.dll");
            if (hstat != 0)
            {
                pFntGetProcessTimes = (FntGetProcessTimes)GetProcAddress (hstat, "GetProcessTimes");
                FreeLibrary (hstat);
            }
            else
                pFntGetProcessTimes = NULL;
        }

        if (pFntGetProcessTimes && pFntGetProcessTimes (hProcess,&CreationTime,&ExitTime,&KernelTime,&UserTime)) {
            ExtOut ("---------------------------------------\n");
            ExtOut ("Process Times\n");
            static char *Month[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",
                        "Oct", "Nov", "Dec"};
            SYSTEMTIME SystemTime;
            FILETIME LocalFileTime;
            if (FileTimeToLocalFileTime (&CreationTime,&LocalFileTime)
                && FileTimeToSystemTime (&LocalFileTime,&SystemTime)) {
                ExtOut ("Process Started at: %4d %s %2d %d:%d:%d.%02d\n",
                        SystemTime.wYear, Month[SystemTime.wMonth-1], SystemTime.wDay,
                        SystemTime.wHour, SystemTime.wMinute,
                        SystemTime.wSecond, SystemTime.wMilliseconds/10);
            }
        
            DWORD nDay = 0;
            DWORD nHour = 0;
            DWORD nMin = 0;
            DWORD nSec = 0;
            DWORD nHundred = 0;
            
            ULONG64 totalTime;
             
            totalTime = KernelTime.dwLowDateTime + (KernelTime.dwHighDateTime << 32);
            nDay = (DWORD)(totalTime/(24*3600*10000000ui64));
            totalTime %= 24*3600*10000000ui64;
            nHour = (DWORD)(totalTime/(3600*10000000ui64));
            totalTime %= 3600*10000000ui64;
            nMin = (DWORD)(totalTime/(60*10000000));
            totalTime %= 60*10000000;
            nSec = (DWORD)(totalTime/10000000);
            totalTime %= 10000000;
            nHundred = (DWORD)(totalTime/100000);
            ExtOut ("Kernel CPU time   : %d days %02d:%02d:%02d.%02d\n",
                    nDay, nHour, nMin, nSec, nHundred);
            
            DWORD sDay = nDay;
            DWORD sHour = nHour;
            DWORD sMin = nMin;
            DWORD sSec = nSec;
            DWORD sHundred = nHundred;
            
            totalTime = UserTime.dwLowDateTime + (UserTime.dwHighDateTime << 32);
            nDay = (DWORD)(totalTime/(24*3600*10000000ui64));
            totalTime %= 24*3600*10000000ui64;
            nHour = (DWORD)(totalTime/(3600*10000000ui64));
            totalTime %= 3600*10000000ui64;
            nMin = (DWORD)(totalTime/(60*10000000));
            totalTime %= 60*10000000;
            nSec = (DWORD)(totalTime/10000000);
            totalTime %= 10000000;
            nHundred = (DWORD)(totalTime/100000);
            ExtOut ("User   CPU time   : %d days %02d:%02d:%02d.%02d\n",
                    nDay, nHour, nMin, nSec, nHundred);
        
            sDay += nDay;
            sHour += nHour;
            sMin += nMin;
            sSec += nSec;
            sHundred += nHundred;
            if (sHundred >= 100) {
                sSec += sHundred/100;
                sHundred %= 100;
            }
            if (sSec >= 60) {
                sMin += sSec/60;
                sSec %= 60;
            }
            if (sMin >= 60) {
                sHour += sMin/60;
                sMin %= 60;
            }
            if (sHour >= 24) {
                sDay += sHour/24;
                sHour %= 24;
            }
            ExtOut ("Total  CPU time   : %d days %02d:%02d:%02d.%02d\n",
                    sDay, sHour, sMin, sSec, sHundred);
        }
    }

    if (!IsDumpFile() && fProcInfo & INFO_MEM) {
        typedef
        NTSTATUS
        (NTAPI
         *FntNtQueryInformationProcess)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);

        static FntNtQueryInformationProcess pFntNtQueryInformationProcess = (FntNtQueryInformationProcess)-1;
        if (pFntNtQueryInformationProcess == (FntNtQueryInformationProcess)-1) {
            HINSTANCE hstat = LoadLibrary ("ntdll.dll");
            if (hstat != 0)
            {
                pFntNtQueryInformationProcess = (FntNtQueryInformationProcess)GetProcAddress (hstat, "NtQueryInformationProcess");
                FreeLibrary (hstat);
            }
            else
                pFntNtQueryInformationProcess = NULL;
        }
        VM_COUNTERS memory;
        if (pFntNtQueryInformationProcess &&
            NT_SUCCESS (pFntNtQueryInformationProcess (hProcess,ProcessVmCounters,&memory,sizeof(memory),NULL))) {
            ExtOut ("---------------------------------------\n");
            ExtOut ("Process Memory\n");
            ExtOut ("WorkingSetSize: %8d KB       PeakWorkingSetSize: %8d KB\n",
                    memory.WorkingSetSize/1024, memory.PeakWorkingSetSize/1024);
            ExtOut ("VirtualSize:    %8d KB       PeakVirtualSize:    %8d KB\n", 
                    memory.VirtualSize/1024, memory.PeakVirtualSize/1024);
            ExtOut ("PagefileUsage:  %8d KB       PeakPagefileUsage:  %8d KB\n", 
                    memory.PagefileUsage/1024, memory.PeakPagefileUsage/1024);
        }

        MEMORYSTATUS stat;
        GlobalMemoryStatus (&stat);
        ExtOut ("---------------------------------------\n");
        ExtOut ("%ld percent of memory is in use.\n\n",
                stat.dwMemoryLoad);
        ExtOut ("Memory Availability (Numbers in MB)\n\n");
        ExtOut ("                  %8s     %8s\n", "Total", "Avail");
        ExtOut ("Physical Memory   %8d     %8d\n", stat.dwTotalPhys/1024/1024, stat.dwAvailPhys/1024/1024);
        ExtOut ("Page File         %8d     %8d\n", stat.dwTotalPageFile/1024/1024, stat.dwAvailPageFile/1024/1024);
        ExtOut ("Virtual Memory    %8d     %8d\n", stat.dwTotalVirtual/1024/1024, stat.dwAvailVirtual/1024/1024);
    }

    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the address of EE data for a      *  
*    metadata token.                                                   *
*                                                                      *
\**********************************************************************/
DECLARE_API (Token2EE)
{
    INIT_API();
#ifdef UNDER_CE
    ExtOut ("not implemented\n");
#else
    while (isspace (args[0]))
        args ++;
    char buffer[100];
    strcpy (buffer, args);
    LPSTR pch = buffer;
    LPSTR mName = buffer;
    while (!isspace (pch[0]) && pch[0] != '\0')
        pch ++;
    if (pch[0] == '\0')
    {
        ExtOut ("Usage: Token2EE module_name mdToken\n");
        return Status;
    }
    pch[0] = '\0';
    pch ++;
    char *endptr;
    ULONG token = strtoul (pch, &endptr, 16);
    pch = endptr;
    while (isspace (pch[0]))
        pch ++;
    if (pch[0] != '\0')
    {
        ExtOut ("Usage: Token2EE module_name mdToken\n");
        return Status;
    }

    int numModule;
    DWORD_PTR *moduleList = NULL;
    ModuleFromName(moduleList, mName, numModule);
    ToDestroy des0 ((void**)&moduleList);
    
    for (int i = 0; i < numModule; i ++)
    {
        if (IsInterrupt())
            break;

        Module vModule;
        DWORD_PTR dwAddr = moduleList[i];
        vModule.Fill (dwAddr);
        ExtOut ("--------------------------------------\n");
        GetInfoFromModule (vModule, token);
    }
#endif
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the address of EE data for a      *  
*    metadata token.
*                                                                      *
\**********************************************************************/
DECLARE_API (Name2EE)
{
    INIT_API();
#ifdef UNDER_CE
    ExtOut ("not implemented\n");
#else
    while (isspace (args[0]))
        args ++;
    char buffer[100];
    strcpy (buffer, args);
    LPSTR pch = buffer;
    LPSTR mName = buffer;
    while (!isspace (pch[0]) && pch[0] != '\0')
        pch ++;
    if (pch[0] == '\0')
    {
        ExtOut ("Usage: Name2EE module_name mdToken\n");
        return Status;
    }
    pch[0] = '\0';
    pch ++;
    char *name = pch;
    while (isspace (name[0]))
        name ++;
    pch = name;
    while (!isspace (pch[0]) && pch[0] != '\0')
        pch ++;
    pch[0] = '\0';

    int numModule;
    DWORD_PTR *moduleList = NULL;
    ModuleFromName(moduleList, mName, numModule);
    ToDestroy des0 ((void**)&moduleList);
    
    for (int i = 0; i < numModule; i ++)
    {
        if (IsInterrupt())
            break;

        Module vModule;
        DWORD_PTR dwAddr = moduleList[i];
        vModule.Fill (dwAddr);
        ExtOut ("--------------------------------------\n");
        GetInfoFromName(vModule, name);
    }
#endif
    return Status;
}



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function finds all roots (on stack or in handles) for a      *  
*    given object.
*                                                                      *
\**********************************************************************/
DECLARE_API(GCRoot)
{
    INIT_API();

    DWORD_PTR obj = GetExpression (args);
    if (obj == 0)
        return Status;
    
    FindGCRoot (obj);
    return Status;
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function finds the size of an object or all roots.           *  
*                                                                      *
\**********************************************************************/
DECLARE_API(ObjSize)
{
    INIT_API();

    DWORD_PTR obj = GetExpression (args);
    if (obj == 0)
        FindAllRootSize();
    else
        FindObjSize (obj);
    return Status;
}

void TrueStackTrace();

DECLARE_API(tst)
{
    INIT_API();

    TrueStackTrace();
    return Status;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function displays the commands available in strike and the   *  
*    arguments passed into each.
*                                                                      *
\**********************************************************************/
extern "C" HRESULT CALLBACK
Help(PDEBUG_CLIENT Client, PCSTR Args)
{
    INIT_API();

    ExtOut( "Strike : Help\n" );
    ExtOut( "IP2MD <addr>         | Find MethodDesc from IP\n" );
    ExtOut( "DumpMD <addr>        | Dump MethodDesc info\n" );
    ExtOut( "DumpMT [-MD] <addr>  | Dump MethodTable info\n" );
    ExtOut( "DumpClass <addr>     | Dump EEClass info\n" );
    ExtOut( "DumpModule <addr>    | Dump EE Module info\n" );
    ExtOut( "DumpObj <addr>       | Dump an object on GC heap\n" );
    ExtOut( "u [<MD>] [IP]        | Unassembly a managed code\n" );
    ExtOut( "Threads              | List managed threads\n" );
    ExtOut( "ThreadPool           | Display CLR threadpool state\n" );
    ExtOut( "COMState             | List COM state for each thread\n");
    ExtOut( "DumpStack [-EE] [top stack [bottom stack]\n" );
    ExtOut( "DumpStackObjects [top stack [bottom stack]\n" );
    ExtOut( "EEStack [-short] [-EE] | List all stacks EE knows\n" );
    ExtOut( "SyncBlk [-all|#]     | List syncblock\n" );
    ExtOut( "FinalizeQueue [-detail]     | Work queue for finalize thread\n" );
    ExtOut( "EEHeap [-gc] [-win32] [-loader] | List GC/Loader heap info\n" );
    ExtOut( "DumpHeap [-stat] [-min 100] [-max 2000] [-mt 0x3000000] [-fix] [start [end]] | Dump GC heap contents\n" );
    ExtOut( "GCRoot <addr>        | Find roots on stack/handle for object\n");
    ExtOut( "ObjSize [<addr>]     | Find number of bytes that a root or all roots keep alive on GC heap.\n");
    ExtOut( "DumpDomain [<addr>]  | List assemblies and modules in a domain\n" );
    ExtOut( "GCInfo [<MD>] [IP]   | Dump GC encoding info for a managed method\n" );
    ExtOut( "RWLock [-all] <addr> | List info for a Read/Write lock\n");
    ExtOut( "Token2EE             | Find memory address of EE data for metadata token\n");
    ExtOut( "Name2EE              | Find memory address of EE data given a class/method name\n");
    ExtOut( "DumpEEHash [-length 2] <addr> | Dump content of EEHashTable\n");
    ExtOut( "EEVersion            | List mscoree.dll version\n");
    ExtOut( "EEDebug 2204         | Setup symbol and source path\n");
    ExtOut( "EEDLLPath [-std 2204 x86fstchk] [-reset] [path] | Setup path for managed Dll to debug dump file\n");
    ExtOut( "ProcInfo [-env] [-time] [-mem] | Display the process info\n");
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\tst-frames.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma warning(disable:4100 4245)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wchar.h>
#include <windows.h>

#include "dbgeng.h"
#include "util.h"
#include "strike.h"
#include "eestructs.h"
#include "dump-tables.h"
#include "tst-frames.h"
#include "get-table-info.h"
#include "tst-siginfo.h"

extern Frame *g_pFrameNukeList;

Frame *ResolveFrame(DWORD_PTR prFrame)
{
    if ((Frame *)prFrame == FRAME_TOP)
        return ((Frame *)FRAME_TOP);

    ClassDumpTable *pTable = GetClassDumpTable();

    if (pTable == NULL)
        return (FALSE);

    DWORD_PTR prVtable;
    safemove(prVtable, prFrame);

    Frame *pFrame;

    if (prVtable == NULL)
        return (FALSE);

#include <clear-class-dump-defs.h>

#define BEGIN_CLASS_DUMP_INFO_DERIVED(klass, parent)                    \
    else if (prVtable == pTable->p ## klass ## Vtable)                  \
    {                                                                   \
        klass *pNewFrame = new klass();                                 \
        pNewFrame->m_This = (Frame *)prFrame;                           \
        pNewFrame->Fill(prFrame);                                       \
        pFrame = (Frame *) pNewFrame;                                   \
        pFrame->m_pNukeNext = g_pFrameNukeList;                         \
        g_pFrameNukeList = pFrame;                                      \
    }
    
#include <frame-types.h>
#include <clear-class-dump-defs.h>

    else
    {
        pFrame = NULL;
    }

    return pFrame;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
CalleeSavedRegisters *FramedMethodFrame::GetCalleeSavedRegisters()
{
    safemove(m_savedRegs, (((BYTE*)m_vLoadAddr) - sizeof(CalleeSavedRegisters)));
    return &m_savedRegs;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void FramedMethodFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
#ifdef _X86_

    CalleeSavedRegisters* regs = GetCalleeSavedRegisters();
    MethodDesc *pFunc = GetFunction();


    // reset pContext; it's only valid for active (top-most) frame
    pRD->pContext = NULL;

    pRD->pEdi = (DWORD*) &regs->edi;
    pRD->pEsi = (DWORD*) &regs->esi;
    pRD->pEbx = (DWORD*) &regs->ebx;
    pRD->pEbp = (DWORD*) &regs->ebp;
    pRD->pPC  = (SLOT*) GetReturnAddressPtr();
    pRD->Esp  = (DWORD)((size_t)pRD->pPC + sizeof(void*));


    //@TODO: We still need to the following things:
    //          - figure out if we are in a hijacked slot
    //            (no adjustment of ESP necessary)
    //          - adjust ESP (popping the args)
    //          - figure out if the aborted flag is set

    if (pFunc)
    {
        DWORD_PTR pdw = (DWORD_PTR) pFunc;

        MethodDesc vMD;
        vMD.Fill(pdw);

        pdw = (DWORD_PTR) pFunc;
        DWORD_PTR pMT;
        GetMethodTable((DWORD_PTR) pFunc, pMT);

        MethodTable vMT;
        vMT.Fill(pMT);

        DWORD_PTR pModule = (DWORD_PTR) vMT.m_pModule;
        Module vModule;
        vModule.Fill(pModule);

        WCHAR StringData[MAX_PATH+1];
        FileNameForModule(&vModule, StringData);
        if (StringData[0] == 0)
            return;

        IMetaDataImport *pImport = MDImportForModule (StringData);

        // Now get the signature
        mdTypeDef mdClass;
        DWORD dwAttr;
        PCCOR_SIGNATURE pvSigBlob;
        ULONG cbSigBlob;
        DWORD dwImplFlags;
        pImport->GetMethodProps(
            vMD.m_dwToken, &mdClass, NULL, 0, NULL, &dwAttr, &pvSigBlob, &cbSigBlob, NULL, &dwImplFlags);

        pRD->Esp += MetaSig::CbStackPop(0, pvSigBlob, dwImplFlags & mdStatic);
    }
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void UnmanagedToManagedFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
#ifdef _X86_

    DWORD *savedRegs = (DWORD *)((size_t)this - (sizeof(CalleeSavedRegisters)));

    // reset pContext; it's only valid for active (top-most) frame

    pRD->pContext = NULL;

    pRD->pEdi = savedRegs++;
    pRD->pEsi = savedRegs++;
    pRD->pEbx = savedRegs++;
    pRD->pEbp = savedRegs++;
    pRD->pPC  = (SLOT*)GetReturnAddressPtr();
    pRD->Esp  = (DWORD)(size_t)pRD->pPC + sizeof(void*);

    pRD->Esp += (DWORD) GetNumCallerStackBytes();

#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void PInvokeCalliFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    FramedMethodFrame::UpdateRegDisplay(pRD);

    DWORD_PTR pVASigCookie = (DWORD_PTR)NonVirtual_GetCookie();
    VASigCookie vVASigCookie;
    vVASigCookie.Fill(pVASigCookie);

    pRD->Esp += (vVASigCookie.sizeOfArgs+sizeof(int));
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
LPVOID PInvokeCalliFrame::NonVirtual_GetCookie()
{
    LPVOID ptr = NonVirtual_GetPointerToArguments();
    safemove(ptr, ptr);
    return ptr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
CalleeSavedRegisters *ComPrestubMethodFrame::GetCalleeSavedRegisters()
{
    safemove(m_savedRegs, (((BYTE*)m_vLoadAddr) - sizeof(CalleeSavedRegisters)));
    return &m_savedRegs;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void ComPrestubMethodFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    CalleeSavedRegisters* regs = GetCalleeSavedRegisters();

    // reset pContext; it's only valid for active (top-most) frame

    pRD->pContext = NULL;


    pRD->pEdi = (DWORD*) &regs->edi;
    pRD->pEsi = (DWORD*) &regs->esi;
    pRD->pEbx = (DWORD*) &regs->ebx;
    pRD->pEbp = (DWORD*) &regs->ebp;
    pRD->pPC  = (SLOT*) GetReturnAddressPtr();
    pRD->Esp  = (DWORD)((size_t)pRD->pPC + sizeof(void*));
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void InlinedCallFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    DWORD *savedRegs = (DWORD*) &m_pCalleeSavedRegisters;
    DWORD stackArgSize = (DWORD)(size_t) m_Datum;


    if (stackArgSize & ~0xFFFF)
    {
        DWORD_PTR pMD = (DWORD_PTR)m_Datum;
        NDirectMethodDesc vMD;
        vMD.Fill(pMD);
        stackArgSize = vMD.ndirect.m_cbDstBufSize;
    }

    // reset pContext; it's only valid for active (top-most) frame
    pRD->pContext = NULL;

    pRD->pEdi = savedRegs++;
    pRD->pEsi = savedRegs++;
    pRD->pEbx = savedRegs++;
    pRD->pEbp = savedRegs++;

    /* The return address is just above the "ESP" */
    pRD->pPC  = (SLOT*) &m_pCallerReturnAddress;

    /* Now we need to pop off the outgoing arguments */
    pRD->Esp  = (DWORD)(size_t) m_pCallSiteTracker + stackArgSize;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void ResumableFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    // reset pContext; it's only valid for active (top-most) frame
    pRD->pContext = NULL;

    pRD->pEdi = &m_Regs->Edi;
    pRD->pEsi = &m_Regs->Esi;
    pRD->pEbx = &m_Regs->Ebx;
    pRD->pEbp = &m_Regs->Ebp;
    pRD->pPC  = (SLOT*)&m_Regs->Eip;
    pRD->Esp  = m_Regs->Esp;

    pRD->pEax = &m_Regs->Eax;
    pRD->pEcx = &m_Regs->Ecx;
    pRD->pEdx = &m_Regs->Edx;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void **ResumableFrame::GetReturnAddressPtr(void)
{
    return (LPVOID*) &m_Regs->Eip;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void *ResumableFrame::GetReturnAddress(void)
{
    return (LPVOID)(size_t) m_Regs->Eip;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void FaultingExceptionFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    CalleeSavedRegisters* regs = GetCalleeSavedRegisters();

    // reset pContext; it's only valid for active (top-most) frame
    pRD->pContext = NULL;


    pRD->pEdi = (DWORD*) &regs->edi;
    pRD->pEsi = (DWORD*) &regs->esi;
    pRD->pEbx = (DWORD*) &regs->ebx;
    pRD->pEbp = (DWORD*) &regs->ebp;
    pRD->pPC  = (SLOT*) GetReturnAddressPtr();
    pRD->Esp = m_Esp;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void FuncEvalFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
#if 0
    DebuggerEval *pDE = (DebuggerEval*)GetDebuggerEval();

    // No context to update if we're doing a func eval from within exception processing.
    if (pDE->m_evalDuringException)
        return;
    
#ifdef _X86_
    // Reset pContext; it's only valid for active (top-most) frame.
    pRD->pContext = NULL;

    // Update all registers in the reg display from the CONTEXT we stored when the thread was hijacked for this func
    // eval. We have to update all registers, not just the callee saved registers, because we can hijack a thread at any
    // point for a func eval, not just at a call site.
    pRD->pEdi = &(pDE->m_context.Edi);
    pRD->pEsi = &(pDE->m_context.Esi);
    pRD->pEbx = &(pDE->m_context.Ebx);
    pRD->pEdx = &(pDE->m_context.Edx);
    pRD->pEcx = &(pDE->m_context.Ecx);
    pRD->pEax = &(pDE->m_context.Eax);
    pRD->pEbp = &(pDE->m_context.Ebp);
    pRD->Esp  =   pDE->m_context.Esp;
    pRD->pPC  = (SLOT*)GetReturnAddressPtr();

#else // _X86_
    _ASSERTE(!"@TODO Alpha - UpdateRegDisplay (Debugger.cpp)");
#endif
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void *FuncEvalFrame::GetReturnAddress(void)
{
    return (NULL);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
unsigned int FuncEvalFrame::GetFrameAttribs(void)
{
    return (0);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void HelperMethodFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
void HijackFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
Frame *Frame::Next()
{
    return (ResolveFrame((DWORD_PTR)m_Next));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\tst-helperframe.h ===
#pragma once

struct MachState {
		// Create a machine state explicitly
	MachState(void** aPEdi, void** aPEsi, void** aPEbx, void** aPEbp, void* aEsp, void** aPRetAddr)
    {
        _esp = aEsp;
        _pRetAddr = aPRetAddr;
        _pEdi = aPEdi;
        _pEsi = aPEsi;
        _pEbx = aPEbx;
        _pEbp = aPEbp;
    }


	MachState() {}

    typedef void* (*TestFtn)(void*);
	void getState(int funCallDepth=1, TestFtn testFtn=0);									

	bool  isValid()		{ return(_pRetAddr != 0); }
	void** pEdi() 		{ return(_pEdi); }
	void** pEsi() 		{ return(_pEsi); }
	void** pEbx() 		{ return(_pEbx); }
	void** pEbp() 		{ return(_pEbp); }
	void*  esp() 		{ return(_esp); }
	void**&  pRetAddr()	{ return(_pRetAddr); }

    // Note the fields are layed out to make generating a
    // MachState structure from assembly code very easy

    // The state of all the callee saved registers.
    // If the register has been spill to the stack p<REG>
    // points at this location, otherwise it points
    // at the field <REG> field itself 
	void** _pEdi; 
    void* 	_edi;
    void** _pEsi;
    void* 	_esi;
    void** _pEbx;
    void* 	_ebx;
    void** _pEbp;
    void* 	_ebp;

    void* _esp;          // stack pointer after the function returns
    void** _pRetAddr;   // The address of the stored IP address (points to the stack)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\tst-frames.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// FRAMES.H -
//
// These C++ classes expose activation frames to the rest of the EE.
// Activation frames are actually created by JIT-generated or stub-generated
// code on the machine stack. Thus, the layout of the Frame classes and
// the JIT/Stub code generators are tightly interwined.
//
// IMPORTANT: Since frames are not actually constructed by C++,
// don't try to define constructor/destructor functions. They won't get
// called.
//
// IMPORTANT: Not all methods have full-fledged activation frames (in
// particular, the JIT may create frameless methods.) This is one reason
// why Frame doesn't expose a public "Next()" method: such a method would
// skip frameless method calls. You must instead use one of the
// StackWalk methods.
//
//
// The following is the hierarchy of frames:
//
//    Frame                   - the root class. There are no actual instances
//    |                         of Frames.
//    |
//    +-ComPrestubMethodFrame - prestub frame for calls from com to com+
//    |
//    |
//    +-GCFrame               - this frame doesn't represent a method call.
//    |                         it's sole purpose is to let the EE gc-protect
//    |                         object references that it is manipulating.
//    |
//    +-HijackFrame           - if a method's return address is hijacked, we
//    |                         construct one of these to allow crawling back
//    |                         to where the return should have gone.
//    |
//    +-InlinedCallFrame      - if a call to unmanaged code is hoisted into
//    |                         a JIT'ted caller, the calling method keeps
//    |                         this frame linked throughout its activation.
//    |
//    +-ResumableFrame        - this frame provides the context necessary to
//    | |                       allow garbage collection during handling of
//    | |                       a resumable exception (e.g. during edit-and-continue,
//    | |                       or under GCStress4).
//    | |
//    | +-RedirectedThreadFrame - this frame is used for redirecting threads during suspension
//    |
//    +-TransitionFrame       - this frame represents a transition from
//    | |                       one or more nested frameless method calls
//    | |                       to either a EE runtime helper function or
//    | |                       a framed method.
//    | |
//    | +-ExceptionFrame        - this frame has caused an exception
//    | | |
//    | | |
//    | | +- FaultingExceptionFrame - this frame was placed on a method which faulted
//    | |                              to save additional state information
//    | |
//    | +-FuncEvalFrame         - frame for debugger function evaluation
//    | |
//    | |
//    | +-HelperMethodFrame     - frame used allow stack crawling inside jit helpers and fcalls
//    | |
//    | |
//    | +-FramedMethodFrame   - this frame represents a call to a method
//    |   |                     that generates a full-fledged frame.
//    |   |
//    |   +-ECallMethodFrame     - represents a direct call to the EE.
//    |   |
//    |   +-FCallMethodFrame     - represents a fast direct call to the EE.
//    |   |
//    |   +-NDirectMethodFrame   - represents an N/Direct call.
//    |   | |
//    |   | +-NDirectMethodFrameEx - represents an N/Direct call w/ cleanup
//    |   |
//    |   +-ComPlusMethodFrame   - represents a complus to com call
//    |   | |
//    |   | +-ComPlusMethodFrameEx - represents an complus to com call w/ cleanup
//    |   |
//    |   +-PrestubFrame         - represents a call to a prestub
//    |   |
//    |   +-CtxCrossingFrame     - this frame marks a call across a context
//    |   |                        boundary
//    |   |
//    |   +-MulticastFrame       - this frame protects arguments to a MulticastDelegate
//    |   |                         Invoke() call while calling each subscriber.
//    |   |
//    |   +-PInovkeCalliFrame   - represents a calli to unmanaged target
//    |  
//    |  
//    +-UnmanagedToManagedFrame - this frame represents a transition from
//    | |                         unmanaged code back to managed code. It's
//    | |                         main functions are to stop COM+ exception
//    | |                         propagation and to expose unmanaged parameters.
//    | |
//    | +-UnmanagedToManagedCallFrame - this frame is used when the target
//    |   |                             is a COM+ function or method call. it
//    |   |                             adds the capability to gc-promote callee
//    |   |                             arguments during marshaling.
//    |   |
//    |   +-ComMethodFrame      - this frame represents a transition from
//    |   |                       com to com+
//    |   |
//    |   +-UMThunkCallFrame    - this frame represents an unmanaged->managed
//    |                           transition through N/Direct
//    |
//    +-CtxMarshaledFrame  - this frame represent a cross context marshalled call
//    |                      (cross thread,inter-process, cross m/c scenarios)
//    |
//    +-CtxByValueFrame    - this frame is used to support protection of a by-
//    |                      value marshaling session, even though the thread is
//    |                      not pushing a call across a context boundary.
//    |
//    +-ContextTransitionFrame - this frame is used to mark an appdomain transition
//    |
//    +-NativeClientSecurityFrame -  this frame is used to capture the security 
//       |                           context in a Native -> Managed call. Code 
//       |                           Acess security stack walk use caller 
//       |                           information in  this frame to apply 
//       |                           security policy to the  native client.
//       |
//       +-ComClientSecurityFrame -  Security frame for Com clients. 
//                                   VBScript, JScript, IE ..


#pragma once

#include "tst-helperframe.h"

// Forward references
class Frame;
class FieldMarshaler;
class FramedMethodFrame;
struct HijackArgs;
class UMEntryThunk;
class UMThunkMarshInfo;
class Marshaler;
class SecurityDescriptor;


// This will take a pointer to an out-of-process Frame, resolve it to
// the proper type and create and fill that type and return a pointer
// to it.  This must be 'delete'd.  prFrame will be advanced by the
// size of the frame object.
Frame *ResolveFrame(DWORD_PTR prFrame);

//--------------------------------------------------------------------
// This represents some of the TransitionFrame fields that are
// stored at negative offsets.
//--------------------------------------------------------------------
struct CalleeSavedRegisters {
    INT32       edi;
    INT32       esi;
    INT32       ebx;
    INT32       ebp;
};

//--------------------------------------------------------------------
// This represents the arguments that are stored in volatile registers.
// This should not overlap the CalleeSavedRegisters since those are already
// saved separately and it would be wasteful to save the same register twice.
// If we do use a non-volatile register as an argument, then the ArgIterator
// will probably have to communicate this back to the PromoteCallerStack
// routine to avoid a double promotion.
//
// @todo M6: It's silly for a method that has <N arguments to save N
// registers. A good perf item would be for the frame to save only
// the registers it actually needs. This means that NegSpaceSize()
// becomes a function of the callsig.
//--------------------------------------------------------------------
struct ArgumentRegisters {

#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)  INT32 regname;
#include "..\..\vm\eecallconv.h"

};

// Note: the value (-1) is used to generate the largest
// possible pointer value: this keeps frame addresses
// increasing upward.
#define FRAME_TOP ((Frame*)(-1))

#define RETURNFRAMEVPTR(classname) \
    classname boilerplate;      \
    return *((LPVOID*)&boilerplate)

#define DEFINE_STD_FRAME_FUNCS(klass)                                   \
    virtual PWSTR GetFrameTypeName() { return L#klass; }

//------------------------------------------------------------------------
// Frame defines methods common to all frame types. There are no actual
// instances of root frames.
//------------------------------------------------------------------------


class Frame
{
public:
    DEFINE_STD_FILL_FUNCS(Frame)
    DEFINE_STD_FRAME_FUNCS(Frame)

    Frame *m_pNukeNext;

    //------------------------------------------------------------------------
    // Special characteristics of a frame
    //------------------------------------------------------------------------
    enum FrameAttribs
    {
        FRAME_ATTR_NONE = 0,
        FRAME_ATTR_EXCEPTION = 1,           // This frame caused an exception
        FRAME_ATTR_OUT_OF_LINE = 2,         // The exception out of line (IP of the frame is not correct)
        FRAME_ATTR_FAULTED = 4,             // Exception caused by Win32 fault
        FRAME_ATTR_RESUMABLE = 8,           // We may resume from this frame
        FRAME_ATTR_RETURNOBJ = 0x10,        // Frame returns an object (helperFrame only)
        FRAME_ATTR_RETURN_INTERIOR = 0x20,  // Frame returns an interior GC poitner (helperFrame only)
        FRAME_ATTR_CAPUTURE_DEPTH_2 = 0x40, // This is a helperMethodFrame and the capture occured at depth 2
        FRAME_ATTR_EXACT_DEPTH = 0x80,      // This is a helperMethodFrame and a jit helper, but only crawl to the given depth
    };

    virtual MethodDesc *GetFunction()
    {
        return (NULL);
    }

    virtual unsigned GetFrameAttribs()
    {
        return (FRAME_ATTR_NONE);
    }

    virtual LPVOID GetReturnAddress()
    {
        return (NULL);
    }

    virtual LPVOID* GetReturnAddressPtr()
    {
        return (NULL);
    }

    virtual void UpdateRegDisplay(const PREGDISPLAY)
    {
        return;
    }

    //------------------------------------------------------------------------
    // Debugger support
    //------------------------------------------------------------------------

    enum
    {
        TYPE_INTERNAL,
        TYPE_ENTRY,
        TYPE_EXIT,
        TYPE_CONTEXT_CROSS,
        TYPE_INTERCEPTION,
        TYPE_SECURITY,
        TYPE_CALL,
        TYPE_FUNC_EVAL,
        TYPE_TP_METHOD_FRAME,
        TYPE_MULTICAST,

        TYPE_COUNT
    };

    virtual int GetFrameType()
    {
        return (TYPE_INTERNAL);
    };

    // When stepping into a method, various other methods may be called.
    // These are refererred to as interceptors. They are all invoked
    // with frames of various types. GetInterception() indicates whether
    // the frame was set up for execution of such interceptors

    enum Interception
    {
        INTERCEPTION_NONE,
        INTERCEPTION_CLASS_INIT,
        INTERCEPTION_EXCEPTION,
        INTERCEPTION_CONTEXT,
        INTERCEPTION_SECURITY,
        INTERCEPTION_OTHER,

        INTERCEPTION_COUNT
    };

    virtual Interception GetInterception()
    {
        return (INTERCEPTION_NONE);
    }

    // get your VTablePointer (can be used to check what type the frame is)
    LPVOID GetVTablePtr()
    {
        return(*((LPVOID*) this));
    }

    // Returns true only for frames derived from FramedMethodFrame.
    virtual BOOL IsFramedMethodFrame()
    {
        return (FALSE);
    }

    Frame     *m_This;        // This is remote pointer value of this frame
    Frame     *m_Next;        // This is the remote pointer value of the next frame

    // Because JIT-method activations cannot be expressed as Frames,
    // everyone must use the StackCrawler to walk the frame chain
    // reliably. We'll expose the Next method only to the StackCrawler
    // to prevent mistakes.
    Frame   *Next();

    // Frame is considered an abstract class: this protected constructor
    // causes any attempt to instantiate one to fail at compile-time.
    Frame()
    {
    }
};


//-------------------------------------------
// This frame provides context for a frame that
// took an exception that is going to be resumed.
//
// It is necessary to create this frame if garbage
// collection may happen during handling of the
// exception.  The FRAME_ATTR_RESUMABLE flag tells
// the GC that the preceding frame needs to be treated
// like the top of stack (with the important implication that
// caller-save-regsiters will be potential roots).
class ResumableFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(ResumableFrame)
    DEFINE_STD_FRAME_FUNCS(ResumableFrame)

    virtual LPVOID* GetReturnAddressPtr();
    virtual LPVOID GetReturnAddress();
    virtual void UpdateRegDisplay(const PREGDISPLAY pRD);

    virtual unsigned GetFrameAttribs()
    {
        return (FRAME_ATTR_RESUMABLE);    // Treat the next frame as the top frame.
    }

    virtual CONTEXT *GetFrameContext()
    {
        return(m_Regs);
    }

    CONTEXT* m_Regs;
};

class RedirectedThreadFrame : public ResumableFrame
{
public:
    DEFINE_STD_FILL_FUNCS(RedirectedThreadFrame)
    DEFINE_STD_FRAME_FUNCS(RedirectedThreadFrame)
};

//#define ISREDIRECTEDTHREAD(thread)                                                      \
//    (thread->GetFrame() != FRAME_TOP &&                                                 \
//     thread->GetFrame()->GetVTablePtr() == RedirectedThreadFrame::GetRedirectedThreadFrameVPtr())

//------------------------------------------------------------------------
// This frame represents a transition from one or more nested frameless
// method calls to either a EE runtime helper function or a framed method.
// Because most stackwalks from the EE start with a full-fledged frame,
// anything but the most trivial call into the EE has to push this
// frame in order to prevent the frameless methods inbetween from
// getting lost.
//------------------------------------------------------------------------
class TransitionFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(TransitionFrame)
    DEFINE_STD_FRAME_FUNCS(TransitionFrame)

    // Retrieves the return address into the code that called the
    // helper or method.
    virtual LPVOID GetReturnAddress()
    {
        return (m_ReturnAddress);
    }

    // Retrieves the return address into the code that called the
    // helper or method.
    virtual LPVOID* GetReturnAddressPtr()
    {
        return (&m_ReturnAddress);
    }

    virtual void UpdateRegDisplay(const PREGDISPLAY) = 0;

    LPVOID  m_Datum;          // offset +8: contents depend on subclass type.
    LPVOID  m_ReturnAddress;  // return address into JIT'ted code
};


//-----------------------------------------------------------------------
// TransitionFrames for exceptions
//-----------------------------------------------------------------------

class ExceptionFrame : public TransitionFrame
{
public:
    DEFINE_STD_FILL_FUNCS(ExceptionFrame)
    DEFINE_STD_FRAME_FUNCS(ExceptionFrame)

    unsigned GetFrameAttribs()
    {
        return (FRAME_ATTR_EXCEPTION);
    }
};

class FaultingExceptionFrame : public ExceptionFrame
{
public:
    DEFINE_STD_FILL_FUNCS(FaultingExceptionFrame)
    DEFINE_STD_FRAME_FUNCS(FaultingExceptionFrame)

    DWORD m_Esp;
    CalleeSavedRegisters m_regs;

    CalleeSavedRegisters *GetCalleeSavedRegisters()
    {
        return (&m_regs);
    }

    unsigned GetFrameAttribs()
    {
        return (FRAME_ATTR_EXCEPTION | FRAME_ATTR_FAULTED);
    }

    virtual void UpdateRegDisplay(const PREGDISPLAY);
};



//-----------------------------------------------------------------------
// TransitionFrame for debugger function evaluation
//
// m_Datum holds a ptr to a DebuggerEval object which contains a copy
// of the thread's context at the time it was hijacked for the func
// eval.
//
// UpdateRegDisplay updates all registers inthe REGDISPLAY, not just
// the callee saved registers, because we can hijack for a func eval
// at any point in a thread's execution.
//
// No callee saved registers are held in the negative space for this
// type of frame.
//
//-----------------------------------------------------------------------

class FuncEvalFrame : public TransitionFrame
{
public:
    DEFINE_STD_FILL_FUNCS(FuncEvalFrame)
    DEFINE_STD_FRAME_FUNCS(FuncEvalFrame)

    virtual BOOL IsTransitionToNativeFrame()
    {
        return (FALSE); 
    }

    virtual int GetFrameType()
    {
        return (TYPE_FUNC_EVAL);
    };

    virtual void *GetDebuggerEval()
    {
        return (void*)m_Datum;
    }
    
    virtual unsigned GetFrameAttribs();

    virtual void UpdateRegDisplay(const PREGDISPLAY);

    virtual LPVOID GetReturnAddress(); 
};


//------------------------------------------------------------------------
// A HelperMethodFrame is created by jit helper (Modified slightly it could be used
// for native routines).   This frame just does the callee saved register
// fixup, it does NOT protect arguments (you can use GCPROTECT or the HelperMethodFrame subclases)
// see JitInterface for sample use, YOU CAN'T RETURN STATEMENT WHILE IN THE PROTECTED STATE!
//------------------------------------------------------------------------

class HelperMethodFrame : public TransitionFrame
{
public:
    DEFINE_STD_FILL_FUNCS(HelperMethodFrame)
    DEFINE_STD_FRAME_FUNCS(HelperMethodFrame)

    virtual LPVOID GetReturnAddress()
    {
        return (*m_MachState->_pRetAddr);
    }

    virtual void UpdateRegDisplay(const PREGDISPLAY);
    virtual unsigned GetFrameAttribs()
    {
        return(m_Attribs);
    }
    void InsureInit();
    void Init(Thread *pThread, struct MachState* ms, MethodDesc* pMD, ArgumentRegisters * regArgs);

    unsigned m_Attribs;
    MachState* m_MachState;         // pRetAddr points to the return address and the stack arguments
    ArgumentRegisters * m_RegArgs;  // if non-zero we also report these as the register arguments 
    Thread *m_pThread;
    void* m_FCallEntry;             // used to determine our identity for stack traces
};

/***********************************************************************************/
/* a HelplerMethodFrames that also report additional object references */

class HelperMethodFrame_1OBJ : public HelperMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(HelperMethodFrame_1OBJ)
    DEFINE_STD_FRAME_FUNCS(HelperMethodFrame_1OBJ)

    /*OBJECTREF*/ DWORD_PTR gcPtrs[1];
};

class HelperMethodFrame_2OBJ : public HelperMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(HelperMethodFrame_2OBJ)
    DEFINE_STD_FRAME_FUNCS(HelperMethodFrame_2OBJ)

    /*OBJECTREF*/ DWORD_PTR gcPtrs[2];
};

class HelperMethodFrame_4OBJ : public HelperMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(HelperMethodFrame_4OBJ)
    DEFINE_STD_FRAME_FUNCS(HelperMethodFrame_4OBJ)

    /*OBJECTREF*/ DWORD_PTR gcPtrs[4];
};

//------------------------------------------------------------------------
// This frame represents a method call. No actual instances of this
// frame exist: there are subclasses for each method type.
//
// However, they all share a similar image ...
//
//              +...    stack-based arguments here
//              +12     return address
//              +8      datum (typically a MethodDesc*)
//              +4      m_Next
//              +0      the frame vptr
//              -...    preserved CalleeSavedRegisters
//              -...    VC5Frame (debug only)
//              -...    ArgumentRegisters
//
//------------------------------------------------------------------------
class FramedMethodFrame : public TransitionFrame
{
public:
    DEFINE_STD_FILL_FUNCS(FramedMethodFrame)
    DEFINE_STD_FRAME_FUNCS(FramedMethodFrame)

    virtual MethodDesc *GetFunction()
    {
        return(MethodDesc*)m_Datum;
    }

    virtual void UpdateRegDisplay(const PREGDISPLAY);

    int GetFrameType()
    {
        return (TYPE_CALL);
    }

    CalleeSavedRegisters *GetCalleeSavedRegisters();

    virtual BOOL IsFramedMethodFrame()
    {
        return (TRUE);
    }

    CalleeSavedRegisters m_savedRegs;
};



//+----------------------------------------------------------------------------
//
//  Class:      TPMethodFrame            private
//
//  Synopsis:   This frame is pushed onto the stack for calls on transparent
//              proxy
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
class TPMethodFrame : public FramedMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(TPMethodFrame)
    DEFINE_STD_FRAME_FUNCS(TPMethodFrame)

    virtual int GetFrameType()
    {
        return (TYPE_TP_METHOD_FRAME);
    }

    // Get offset used during stub generation
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(TPMethodFrame);
    }
};


//------------------------------------------------------------------------
// This represents a call to a ECall method.
//------------------------------------------------------------------------
class ECallMethodFrame : public FramedMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(ECallMethodFrame)
    DEFINE_STD_FRAME_FUNCS(ECallMethodFrame)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(ECallMethodFrame);
    }

    int GetFrameType()
    {
        return (TYPE_EXIT);
    };
};


//------------------------------------------------------------------------
// This represents a call to a FCall method.
// Note that this frame is pushed only if the FCall throws an exception.
// For normal execution, FCall methods run frameless. That's the whole
// reason for FCall's existence.
//------------------------------------------------------------------------
class FCallMethodFrame : public FramedMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(FCallMethodFrame)
    DEFINE_STD_FRAME_FUNCS(FCallMethodFrame)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(FCallMethodFrame);
    }

    int GetFrameType()
    {
        return (TYPE_EXIT);
    };
};



//------------------------------------------------------------------------
// This represents a call to a NDirect method.
//------------------------------------------------------------------------
class NDirectMethodFrame : public FramedMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(NDirectMethodFrame)
    DEFINE_STD_FRAME_FUNCS(NDirectMethodFrame)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------

    int GetFrameType()
    {
        return (TYPE_EXIT);
    };
};



//------------------------------------------------------------------------
// This represents a call to a NDirect method with cleanup.
//------------------------------------------------------------------------
class NDirectMethodFrameEx : public NDirectMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(NDirectMethodFrameEx)
    DEFINE_STD_FRAME_FUNCS(NDirectMethodFrameEx)
};


//------------------------------------------------------------------------
// This represents a call to a NDirect method with the generic worker
// (the subclass is so the debugger can tell the difference)
//------------------------------------------------------------------------
class NDirectMethodFrameGeneric : public NDirectMethodFrameEx
{
public:
    DEFINE_STD_FILL_FUNCS(NDirectMethodFrameGeneric)
    DEFINE_STD_FRAME_FUNCS(NDirectMethodFrameGeneric)
};


//------------------------------------------------------------------------
// This represents a call to a NDirect method with the slimstub
// (the subclass is so the debugger can tell the difference)
//------------------------------------------------------------------------
class NDirectMethodFrameSlim : public NDirectMethodFrameEx
{
public:
    DEFINE_STD_FILL_FUNCS(NDirectMethodFrameSlim)
    DEFINE_STD_FRAME_FUNCS(NDirectMethodFrameSlim)
};


//------------------------------------------------------------------------
// This represents a call to a NDirect method with the standalone stub (no cleanup)
// (the subclass is so the debugger can tell the difference)
//------------------------------------------------------------------------
class NDirectMethodFrameStandalone : public NDirectMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(NDirectMethodFrameStandalone)
    DEFINE_STD_FRAME_FUNCS(NDirectMethodFrameStandalone)
};


//------------------------------------------------------------------------
// This represents a call to a NDirect method with the standalone stub (with cleanup)
// (the subclass is so the debugger can tell the difference)
//------------------------------------------------------------------------
class NDirectMethodFrameStandaloneCleanup : public NDirectMethodFrameEx
{
public:
    DEFINE_STD_FILL_FUNCS(NDirectMethodFrameStandaloneCleanup)
    DEFINE_STD_FRAME_FUNCS(NDirectMethodFrameStandaloneCleanup)
};


//------------------------------------------------------------------------
// This represents a call Multicast.Invoke. It's only used to gc-protect
// the arguments during the iteration.
//------------------------------------------------------------------------
class MulticastFrame : public FramedMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(MulticastFrame)
    DEFINE_STD_FRAME_FUNCS(MulticastFrame)

    int GetFrameType()
    {
        return (TYPE_MULTICAST);
    }
};


//-----------------------------------------------------------------------
// Transition frame from unmanaged to managed
//-----------------------------------------------------------------------
class UnmanagedToManagedFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(UnmanagedToManagedFrame)
    DEFINE_STD_FRAME_FUNCS(UnmanagedToManagedFrame)

    // Retrieves the return address into the code that called the
    // helper or method.
    virtual LPVOID GetReturnAddress()
    {
        return (m_ReturnAddress);
    }

    virtual LPVOID* GetReturnAddressPtr()
    {
        return (&m_ReturnAddress);
    }

    // depends on the sub frames to return approp. type here
    virtual LPVOID GetDatum()
    {
        return (m_pvDatum);
    }

    int GetFrameType()
    {
        return (TYPE_ENTRY);
    };

    virtual const BYTE* GetManagedTarget()
    {
        return (NULL);
    }

    // Return the # of stack bytes pushed by the unmanaged caller.
    virtual UINT GetNumCallerStackBytes() = 0;

    virtual void UpdateRegDisplay(const PREGDISPLAY);

    LPVOID    m_pvDatum;       // type depends on the sub class
    LPVOID    m_ReturnAddress;  // return address into unmanaged code
};


//-----------------------------------------------------------------------
// Transition frame from unmanaged to managed
//
// this frame contains some object reference at negative
// offset which need to be promoted, the references could be [in] args during
// in the middle of marshalling or [out], [in,out] args that need to be tracked
//------------------------------------------------------------------------
class UnmanagedToManagedCallFrame : public UnmanagedToManagedFrame
{
public:
    DEFINE_STD_FILL_FUNCS(UnmanagedToManagedCallFrame)
    DEFINE_STD_FRAME_FUNCS(UnmanagedToManagedCallFrame)

    // Return the # of stack bytes pushed by the unmanaged caller.
    virtual UINT GetNumCallerStackBytes()
    {
        return (0);
    }
};

//------------------------------------------------------------------------
// This frame represents a transition from COM to COM+
// this frame contains some object reference at negative
// offset which need to be promoted, the references could be [in] args during
// in the middle of marshalling or [out], [in,out] args that need to be tracked
//------------------------------------------------------------------------
class ComMethodFrame : public UnmanagedToManagedCallFrame
{
public:
    DEFINE_STD_FILL_FUNCS(ComMethodFrame)
    DEFINE_STD_FRAME_FUNCS(ComMethodFrame)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(ComMethodFrame);
    }
};


//------------------------------------------------------------------------
// This represents a call from ComPlus to COM
//------------------------------------------------------------------------
class ComPlusMethodFrame : public FramedMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(ComPlusMethodFrame)
    DEFINE_STD_FRAME_FUNCS(ComPlusMethodFrame)


    virtual BOOL IsTransitionToNativeFrame()
    {
        return (TRUE);
    }

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    int GetFrameType()
    {
        return (TYPE_EXIT);
    };
};






//------------------------------------------------------------------------
// This represents a call from COM+ to COM with cleanup.
//------------------------------------------------------------------------
class ComPlusMethodFrameEx : public ComPlusMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(ComPlusMethodFrameEx)
    DEFINE_STD_FRAME_FUNCS(ComPlusMethodFrameEx)
};





//------------------------------------------------------------------------
// This represents a call from COM+ to COM using the generic worker
//------------------------------------------------------------------------
class ComPlusMethodFrameGeneric : public ComPlusMethodFrameEx
{
public:
    DEFINE_STD_FILL_FUNCS(ComPlusMethodFrameGeneric)
    DEFINE_STD_FRAME_FUNCS(ComPlusMethodFrameGeneric)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(ComPlusMethodFrameGeneric);
    }
};




//------------------------------------------------------------------------
// This represents a call from COM+ to COM using the standalone stub (no cleanup)
//------------------------------------------------------------------------
class ComPlusMethodFrameStandalone : public ComPlusMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(ComPlusMethodFrameStandalone)
    DEFINE_STD_FRAME_FUNCS(ComPlusMethodFrameStandalone)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(ComPlusMethodFrameStandalone);
    }
};


//------------------------------------------------------------------------
// This represents a call from COM+ to COM using the standalone stub using cleanup
//------------------------------------------------------------------------
class ComPlusMethodFrameStandaloneCleanup : public ComPlusMethodFrameEx
{
public:
    DEFINE_STD_FILL_FUNCS(ComPlusMethodFrameStandaloneCleanup)
    DEFINE_STD_FRAME_FUNCS(ComPlusMethodFrameStandaloneCleanup)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(ComPlusMethodFrameStandaloneCleanup);
    }
};





//------------------------------------------------------------------------
// This represents a call from ComPlus to COM
//------------------------------------------------------------------------
class PInvokeCalliFrame : public FramedMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(PInvokeCalliFrame)
    DEFINE_STD_FRAME_FUNCS(PInvokeCalliFrame)

    virtual BOOL IsTransitionToNativeFrame()
    {
        return (TRUE);
    }

    // not a method
    virtual MethodDesc *GetFunction()
    {
        return (NULL);
    }

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(PInvokeCalliFrame);
    }

    int GetFrameType()
    {
        return (TYPE_EXIT);
    };

    LPVOID NonVirtual_GetCookie();

    // Retrives pointer to the lowest-addressed argument on
    // the stack.
    LPVOID NonVirtual_GetPointerToArguments()
    {
        return (LPVOID)(m_vLoadAddr + size());
    }

    virtual void UpdateRegDisplay(const PREGDISPLAY);
};


// Some context-related forwards.

//------------------------------------------------------------------------
// This frame represents a hijacked return.  If we crawl back through it,
// it gets us back to where the return should have gone (and eventually will
// go).
//------------------------------------------------------------------------
class HijackFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(HijackFrame)
    DEFINE_STD_FRAME_FUNCS(HijackFrame)

    // Retrieves the return address into the code that called the
    // helper or method.
    virtual LPVOID GetReturnAddress()
    {
        return (m_ReturnAddress);
    }

    virtual LPVOID* GetReturnAddressPtr()
    {
        return (&m_ReturnAddress);
    }

    virtual void UpdateRegDisplay(const PREGDISPLAY);

    VOID        *m_ReturnAddress;
    Thread      *m_Thread;
    HijackArgs  *m_Args;
};

//------------------------------------------------------------------------
// This represents a declarative secuirty check. This frame is inserted
// prior to calls on methods that have declarative security defined for
// the class or the specific method that is being called. This frame
// is only created when the prestubworker creates a real stub.
//------------------------------------------------------------------------
class SecurityFrame : public FramedMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(SecurityFrame)
    DEFINE_STD_FRAME_FUNCS(SecurityFrame)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(SecurityFrame);
    }

    int GetFrameType()
    {
        return (TYPE_SECURITY);
    }
};


//------------------------------------------------------------------------
// This represents a call to a method prestub. Because the prestub
// can do gc and throw exceptions while building the replacement
// stub, we need this frame to keep things straight.
//------------------------------------------------------------------------
class PrestubMethodFrame : public FramedMethodFrame
{
public:
    DEFINE_STD_FILL_FUNCS(PrestubMethodFrame)
    DEFINE_STD_FRAME_FUNCS(PrestubMethodFrame)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(PrestubMethodFrame);
    }

    int GetFrameType()
    {
        return (TYPE_INTERCEPTION);
    }
};

//------------------------------------------------------------------------
// This represents a call to a method prestub. Because the prestub
// can do gc and throw exceptions while building the replacement
// stub, we need this frame to keep things straight.
//------------------------------------------------------------------------
class InterceptorFrame : public SecurityFrame
{
public:
    DEFINE_STD_FILL_FUNCS(InterceptorFrame)
    DEFINE_STD_FRAME_FUNCS(InterceptorFrame)

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(InterceptorFrame);
    }
};

//------------------------------------------------------------------------
// This represents a com to com+ call method prestub.
// we need to catch exceptions etc. so this frame is not the same
// as the prestub method frame
// Note that in rare IJW cases, the immediate caller could be a managed method
// which pinvoke-inlined a call to a COM interface, which happenned to be
// implemented by a managed function via COM-interop.
//------------------------------------------------------------------------
class ComPrestubMethodFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(ComPrestubMethodFrame)
    DEFINE_STD_FRAME_FUNCS(ComPrestubMethodFrame)

    // Retrieves the return address into the code that called the
    // helper or method.
    virtual LPVOID GetReturnAddress()
    {
        return (m_ReturnAddress);
    }

    virtual LPVOID* GetReturnAddressPtr()
    {
        return (&m_ReturnAddress);
    }

    CalleeSavedRegisters *GetCalleeSavedRegisters();

    virtual void UpdateRegDisplay(const PREGDISPLAY pRD);

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(ComPrestubMethodFrame);
    }

    int GetFrameType()
    {
        return (TYPE_INTERCEPTION);
    }

    MethodDesc*     m_pFuncDesc;      // func desc of the function being called
    LPVOID          m_ReturnAddress;  // return address into Com code
    CalleeSavedRegisters m_savedRegs;
};



//------------------------------------------------------------------------
// This frame protects object references for the EE's convenience.
// This frame type actually is created from C++.
//------------------------------------------------------------------------
class GCFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(GCFrame)
    DEFINE_STD_FRAME_FUNCS(GCFrame)

    //--------------------------------------------------------------------
    // This constructor pushes a new GCFrame on the frame chain.
    //--------------------------------------------------------------------
    GCFrame()
    {
    }; 

    /*OBJECTREF*/

void *m_pObjRefs;
    UINT       m_numObjRefs;
    Thread    *m_pCurThread;
    BOOL       m_MaybeInterior;
};

struct ByRefInfo;

class ProtectByRefsFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(ProtectByRefsFrame)
    DEFINE_STD_FRAME_FUNCS(ProtectByRefsFrame)

    ByRefInfo *m_brInfo;
    Thread    *m_pThread;
};

struct ValueClassInfo;

class ProtectValueClassFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(ProtectValueClassFrame)
    DEFINE_STD_FRAME_FUNCS(ProtectValueClassFrame)

    ValueClassInfo *m_pVCInfo;
    Thread    *m_pThread;
};

//------------------------------------------------------------------------
// DebuggerClassInitMarkFrame is a small frame whose only purpose in
// life is to mark for the debugger that "class initialization code" is
// being run. It does nothing useful except return good values from
// GetFrameType and GetInterception.
//------------------------------------------------------------------------
class DebuggerClassInitMarkFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(DebuggerClassInitMarkFrame)
    DEFINE_STD_FRAME_FUNCS(DebuggerClassInitMarkFrame)

    virtual int GetFrameType()
    {
        return (TYPE_INTERCEPTION);
    }
};

//------------------------------------------------------------------------
// DebuggerSecurityCodeMarkFrame is a small frame whose only purpose in
// life is to mark for the debugger that "security code" is
// being run. It does nothing useful except return good values from
// GetFrameType and GetInterception.
//------------------------------------------------------------------------
class DebuggerSecurityCodeMarkFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(DebuggerSecurityCodeMarkFrame)
    DEFINE_STD_FRAME_FUNCS(DebuggerSecurityCodeMarkFrame)

    virtual int GetFrameType()
    {
        return (TYPE_INTERCEPTION);
    }
};

//------------------------------------------------------------------------
// DebuggerExitFrame is a small frame whose only purpose in
// life is to mark for the debugger that there is an exit transiton on
// the stack.  This is special cased for the "break" IL instruction since
// it is an fcall using a helper frame which returns TYPE_CALL instead of
// an ecall (as in System.Diagnostics.Debugger.Break()) which returns
// TYPE_EXIT.  This just makes the two consistent for debugging services.
//------------------------------------------------------------------------
class DebuggerExitFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(DebuggerExitFrame)
    DEFINE_STD_FRAME_FUNCS(DebuggerExitFrame)

    virtual int GetFrameType()
    {
        return (TYPE_EXIT);
    }
};




//------------------------------------------------------------------------
// This frame guards an unmanaged->managed transition thru a UMThk
//------------------------------------------------------------------------
class UMThkCallFrame : public UnmanagedToManagedCallFrame
{
public:
    DEFINE_STD_FILL_FUNCS(UMThkCallFrame)
    DEFINE_STD_FRAME_FUNCS(UMThkCallFrame)
};




//------------------------------------------------------------------------
// This frame is pushed by any JIT'ted method that contains one or more
// inlined N/Direct calls. Note that the JIT'ted method keeps it pushed
// the whole time to amortize the pushing cost across the entire method.
//------------------------------------------------------------------------
class InlinedCallFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(InlinedCallFrame)
    DEFINE_STD_FRAME_FUNCS(InlinedCallFrame)

    // Retrieves the return address into the code that called out
    // to managed code
    virtual LPVOID GetReturnAddress()
    {
        /* m_pCallSiteTracker contains the ESP just before the call, i.e.*/
        /* the return address pushed by the call is just in front of it  */

        if (FrameHasActiveCall(this))
            return (m_pCallerReturnAddress);
        else
            return (NULL);
    }

    virtual LPVOID* GetReturnAddressPtr()
    {
        if (FrameHasActiveCall(this))
            return (&m_pCallerReturnAddress);
        else
            return (NULL);
    }

    virtual void UpdateRegDisplay(const PREGDISPLAY);

    DWORD_PTR            m_Datum;   // func desc of the function being called
                                    // or stack argument size (for calli)
    LPVOID               m_pCallSiteTracker;
    LPVOID               m_pCallerReturnAddress;
    CalleeSavedRegisters m_pCalleeSavedRegisters;

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static LPVOID GetInlinedCallFrameFrameVPtr()
    {
        RETURNFRAMEVPTR(InlinedCallFrame);
    }

    // Is the specified frame an InlinedCallFrame which has an active call
    // inside it right now?
    static BOOL FrameHasActiveCall(Frame *pFrame)
    {
        return(pFrame &&
               (pFrame != FRAME_TOP) &&
               (GetInlinedCallFrameFrameVPtr() == pFrame->GetVTablePtr()) &&
               (((InlinedCallFrame *)pFrame)->m_pCallSiteTracker != 0));
    }

    int GetFrameType()
    {
        return (TYPE_INTERNAL); // will have to revisit this case later
    }

    virtual BOOL IsTransitionToNativeFrame()
    {
        return (TRUE);
    }
};

//------------------------------------------------------------------------
// This frame is used to mark a Context/AppDomain Transition
//------------------------------------------------------------------------
class ContextTransitionFrame : public Frame
{
public:
    DEFINE_STD_FILL_FUNCS(ContextTransitionFrame)
    DEFINE_STD_FRAME_FUNCS(ContextTransitionFrame)

    static LPVOID GetMethodFrameVPtr()
    {
        RETURNFRAMEVPTR(ContextTransitionFrame);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\symbol.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef UNDER_CE
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include "symbol.h"
#include <dbghelp.h>

#if 0
static ULONG
CheckForTypeInfo(
    IN HANDLE  hProcess,
    IN DWORD_PTR ModBaseAddress
    );

//
// Callback routine to find if any symbol has type info
//
BOOL CheckIndexedType (PSYMBOL_INFO pSym, ULONG Sz, PVOID ctxt) {
    PULONG pTypeInfoPresent = (PULONG) ctxt;
    
    if (pSym->TypeIndex) {
        *pTypeInfoPresent = TRUE;
        return FALSE;
    }
    return TRUE;
}


static ULONG
CheckForTypeInfo(
    IN HANDLE  hProcess,
    IN ULONG64 ModBaseAddress
    )
/*
  This routines checks whether the given module referred by ModBaseAddress has
  any type info or not. This is done by trying to get type info for a basic type 
  like PVOID/ULONG which would always be present in a pdb.
*/
{
    ULONG TypeInfoPresent = FALSE;

    SymEnumTypes(
        hProcess,
        ModBaseAddress,
        &CheckIndexedType,
        &TypeInfoPresent);
    if (TypeInfoPresent) {
        return TRUE;
    }
    
    SymEnumSym(
        hProcess,
        ModBaseAddress,
        &CheckIndexedType,
        &TypeInfoPresent);
    if (TypeInfoPresent) {
        return TRUE;
    }
    
    return FALSE;
}
#endif

DWORD_PTR GetSymbolType (const char *name, SYM_OFFSET *symOffset,
                    int symCount)
{
    // Initialize all offset to -1
    int n;
    for (n = 0; n < symCount; n ++) {
        if (symOffset[n].offset == -2) {
            if (IsDebugBuildEE()){
                symOffset[n].offset = -1;
            }
        }
        else
            symOffset[n].offset = -1;
    }

    EEFLAVOR flavor = GetEEFlavor ();
    if (moduleInfo[flavor].baseAddr == 0)
        return 0;
    if (moduleInfo[flavor].hasPdb == FALSE)
    {
        if (flavor == MSCOREE)
            ExtOut ("mscoree.pdb not exist\n");
        else if (flavor == MSCORWKS)
            ExtOut ("mscorwks.pdb not exist\n");
        else if (flavor == MSCORSVR)
            ExtOut ("mscorsvr.pdb not exist\n");
        ExtOut ("Use alternate method which may not work.\n");
        return 0;
    }

#if 0
    static bTypeInfo = FALSE;
    if (!bTypeInfo)
    {
        if (!CheckForTypeInfo(g_hCurrentProcess,moduleInfo[flavor].baseAddr))
        {
            ExtOut ("Symbol type info not exist\n");
            return 0;
        }
    }
    bTypeInfo = TRUE;
#endif
    
    ULONG TypeId;
    const char *pt = strchr(name, '!');
    if (pt == NULL)
        pt = name;
    else
        pt ++;
    if (FAILED(g_ExtSymbols->GetTypeId (moduleInfo[flavor].baseAddr,
                                        pt, &TypeId)))
        return 0;
    
    for (n = 0; n < symCount; n++) {
        if (symOffset[n].offset != -2) {
            g_ExtSymbols->GetFieldOffset(moduleInfo[flavor].baseAddr, TypeId,
                                         symOffset[n].name, &symOffset[n].offset);
            if (symOffset[n].offset == -1)
                ExtOut ("offset not exist for %s\n", symOffset[n].name);
        }
        else
            symOffset[n].offset = -1;
    }

    ULONG Size;
    if (SUCCEEDED(g_ExtSymbols->GetTypeSize (moduleInfo[flavor].baseAddr,
                                             TypeId, &Size)))
        return Size;
    else
        return 0;
}

ULONG WStrlen(PWCHAR str)
{
    ULONG result = 0;

    while (*str++ != UNICODE_NULL) {
        result++;
    }

    return result;
}

LPSTR
UnicodeToAnsi(BSTR wStr)
{
    ULONG len = WStrlen(wStr);
    LPSTR str = (LPSTR) malloc(len + 1);

    if (str) {
        sprintf(str,"%ws", wStr);
    }
    return str;
}

BOOL
GetConstantNameAndVal(
    HANDLE hProcess,
    DWORD64 baseAddress,
    ULONG typeId,
    PCHAR *pName,
    PULONG64 pValue
    )
{
    PWCHAR pWname;
    VARIANT var;
    ULONG len;

    *pName = NULL;
    if (!SymGetTypeInfo(hProcess, baseAddress, typeId, TI_GET_SYMNAME, (PVOID) &pWname) ||
        !SymGetTypeInfo(hProcess, baseAddress, typeId, TI_GET_VALUE, (PVOID) &var)) {
        return FALSE;
    }
    
    if (pWname) {
        *pName = UnicodeToAnsi(pWname);
        LocalFree (pWname);
    } else {
        *pName = NULL;
        return FALSE;
    }

    switch (var.vt) { 
    case VT_UI2: 
    case VT_I2:
        *pValue = var.iVal;
        len = 2;
        break;
    case VT_R4:
        *pValue = (ULONG64) var.fltVal;
        len=4;
        break;
    case VT_R8:
        *pValue = (ULONG64) var.dblVal;
        len=8;
        break;
    case VT_BOOL:
        *pValue = var.lVal;
        len=4;
        break;
    case VT_I1:
    case VT_UI1: 
        *pValue = var.bVal;
        len=1;
        break;
    case VT_I8:
    case VT_UI8:
        *pValue = var.ullVal;
        len=8;
        break;
    case VT_UI4:
    case VT_I4:
    case VT_INT:
    case VT_UINT:
    case VT_HRESULT:
        *pValue = var.lVal;
        len=4;
        break;
    default:
//        sprintf(Buffer, "UNIMPLEMENTED %lx %lx", var.vt, var.lVal);
        len=4;
        break;
    }
    return TRUE;
}

struct Exam1dArrayInfo
{
    HANDLE hProcess;
    ULONG64 baseAddr;
    ULONG length;
};

BOOL CALLBACK
Parse1DArraySymbolInfo(
    PSYMBOL_INFO    SymInfo,
    ULONG           Size,
    PVOID           ArrayInfoArg
    )
{
    Exam1dArrayInfo *pInfo = (Exam1dArrayInfo *)ArrayInfoArg;
    
    if (Size == 0) {
        return TRUE;
    }
    
    ULONG BaseId;
    ULONGLONG BaseSz;

    if (!SymGetTypeInfo(pInfo->hProcess, pInfo->baseAddr, SymInfo->TypeIndex, TI_GET_TYPEID, &BaseId))
        return FALSE;
    if (!SymGetTypeInfo(pInfo->hProcess, pInfo->baseAddr, BaseId, TI_GET_LENGTH, (PVOID) &BaseSz))
        return FALSE;

    pInfo->length = (ULONG)(BaseSz ? (Size / (ULONG)(ULONG_PTR)BaseSz) : 1);
    return FALSE;
}

ULONG Get1DArrayLength (const char *name)
{
    EEFLAVOR flavor = GetEEFlavor ();
    if (moduleInfo[flavor].baseAddr == 0)
        return 0;
    if (moduleInfo[flavor].hasPdb == FALSE)
    {
        if (flavor == MSCOREE)
            ExtOut ("mscoree.pdb not exist\n");
        else if (flavor == MSCORWKS)
            ExtOut ("mscorwks.pdb not exist\n");
        else if (flavor == MSCORSVR)
            ExtOut ("mscorsvr.pdb not exist\n");
        ExtOut ("Use alternate method which may not work.\n");
        return 0;
    }

    ULONG64 value;
    if (FAILED(g_ExtSystem->GetCurrentProcessHandle(&value)))
        return 0;
    HANDLE hProcess = (HANDLE)value;
    
    Exam1dArrayInfo arrayInfo = {hProcess, moduleInfo[flavor].baseAddr, 0};

    SymEnumSymbols (hProcess, moduleInfo[flavor].baseAddr, name, Parse1DArraySymbolInfo, &arrayInfo);
    return arrayInfo.length;
}

void NameForEnumValue (const char *EnumType, DWORD_PTR EnumValue, char **EnumName)
{
    *EnumName = NULL;
    EEFLAVOR flavor = GetEEFlavor ();
    if (moduleInfo[flavor].baseAddr == 0)
        return;
    if (moduleInfo[flavor].hasPdb == FALSE)
    {
        if (flavor == MSCOREE)
            ExtOut ("mscoree.pdb not exist\n");
        else if (flavor == MSCORWKS)
            ExtOut ("mscorwks.pdb not exist\n");
        else if (flavor == MSCORSVR)
            ExtOut ("mscorsvr.pdb not exist\n");
        ExtOut ("Use alternate method which may not work.\n");
        return;
    }

    ULONG TypeId;
    const char *pt = strchr(EnumType, '!');
    if (pt == NULL)
        pt = EnumType;
    else
        pt ++;
    if (FAILED(g_ExtSymbols2->GetTypeId (moduleInfo[flavor].baseAddr,
                                        pt, &TypeId)))
        return;
    
    ULONG size;
    if (FAILED(g_ExtSymbols2->GetConstantName(moduleInfo[flavor].baseAddr,TypeId,EnumValue,NULL,0,&size))) {
        return;
    }
    size ++;
    *EnumName = (char *)malloc (size*sizeof(char));;
    if (FAILED(g_ExtSymbols2->GetConstantName(moduleInfo[flavor].baseAddr,TypeId,EnumValue,*EnumName,size,NULL))) {
        free (*EnumName);
        *EnumName = NULL;
        return;
    }
}
#endif  // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\tst-siginfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// siginfo.hpp
//
#ifndef _H_SIGINFO
#define _H_SIGINFO

#pragma warning(disable:4510 4512 4610 4100 4244 4245 4189 4127)
#include "corinfo.h"

#define Module mdScope

typedef INT32 StackElemType;
#define STACK_ELEM_SIZE sizeof(StackElemType)


// !! This expression assumes STACK_ELEM_SIZE is a power of 2.
#define StackElemSize(parmSize) (((parmSize) + STACK_ELEM_SIZE - 1) & ~((ULONG)(STACK_ELEM_SIZE - 1)))

// uncompress encoded element type. throw away any custom modifier prefixes along
// the way.
FORCEINLINE CorElementType CorSigEatCustomModifiersAndUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    while (ELEMENT_TYPE_CMOD_REQD == *pData || ELEMENT_TYPE_CMOD_OPT == *pData)
    {
        pData++;
        CorSigUncompressToken(pData);
    }
    return (CorElementType)*pData++;
}

// CorSig helpers which won't overflow your buffer

inline ULONG CorSigCompressDataSafe(ULONG iLen, BYTE *pDataOut, BYTE *pDataMax)
{
    BYTE buffer[4];
    ULONG result = CorSigCompressData(iLen, buffer);
    if (pDataOut + result < pDataMax)
        pDataMax = pDataOut + result;
	if (pDataMax > pDataOut)
		CopyMemory(pDataOut, buffer, pDataMax - pDataOut);
    return result;
}

inline ULONG CorSigCompressTokenSafe(mdToken tk, BYTE *pDataOut, BYTE *pDataMax)
{
    BYTE buffer[4];
    ULONG result = CorSigCompressToken(tk, buffer);
    if (pDataOut + result < pDataMax)
        pDataMax = pDataOut + result;
	if (pDataMax > pDataOut)
		CopyMemory(pDataOut, buffer, pDataMax - pDataOut);
    return result;
}

inline ULONG CorSigCompressSignedIntSafe(int iData, BYTE *pDataOut, BYTE *pDataMax)
{
    BYTE buffer[4];
    ULONG result = CorSigCompressSignedInt(iData, buffer);
    if (pDataOut + result < pDataMax)
        pDataMax = pDataOut + result;
	if (pDataMax > pDataOut)
		CopyMemory(pDataOut, buffer, pDataMax - pDataOut);
    return result;
}

inline ULONG CorSigCompressElementTypeSafe(CorElementType et, 
                                           BYTE *pDataOut, BYTE *pDataMax)
{
    if (pDataMax > pDataOut)
        return CorSigCompressElementType(et, pDataOut);
    else
        return 1;
}


struct ElementTypeInfo {
#ifdef _DEBUG
    int            m_elementType;     
#endif
    int            m_cbSize;
    CorInfoGCType  m_gc         : 3;
    int            m_fp         : 1;
    int            m_enregister : 1;
    int            m_isBaseType : 1;

};
extern const ElementTypeInfo gElementTypeInfoSig[];

unsigned GetSizeForCorElementType(CorElementType etyp);
const ElementTypeInfo* GetElementTypeInfo(CorElementType etyp);
BOOL    IsFP(CorElementType etyp);
BOOL    IsBaseElementType(CorElementType etyp);

//----------------------------------------------------------------------------
// enum StringType
// defines the various string types
enum StringType
{
    enum_BSTR = 0,
    enum_WSTR = 1,
    enum_CSTR = 2,
    enum_AnsiBSTR = 3,
};


//----------------------------------------------------------------------------
// IsAnsi
inline  BOOL IsAnsi(StringType styp)
{
    return styp == enum_CSTR;
}


//----------------------------------------------------------------------------
// IsBSTR
inline  BOOL IsBSTR(StringType styp)
{
    return styp == enum_BSTR;
}


//----------------------------------------------------------------------------
// IsWSTR
inline  BOOL IsWSTR(StringType styp)
{
    return styp == enum_WSTR;
}

//----------------------------------------------------------------------------
// Free String call appropriate free
inline VOID FreeString(LPVOID pv, StringType styp)
{
    if (pv != NULL)
    {
        if (IsBSTR(styp))
        {
            SysFreeString((BSTR)pv);
        }
        else
        {
            CoTaskMemFree(pv);
        }
    }
}


//------------------------------------------------------------------------
// Encapsulates how compressed integers and typeref tokens are encoded into
// a bytestream.
//
// For M3.5, the bytestream *is* a bytestream. Later on, we may change
// to a nibble-based or var-length encoding, in which case, the implementation
// of this class will become more complex.
//------------------------------------------------------------------------
class SigPointer
{
    private:
        PCCOR_SIGNATURE m_ptr;

    public:
        //------------------------------------------------------------------------
        // Constructor.
        //------------------------------------------------------------------------
        SigPointer() {}

        //------------------------------------------------------------------------
        // Initialize 
        //------------------------------------------------------------------------
        FORCEINLINE SigPointer(PCCOR_SIGNATURE ptr)
        {
            m_ptr = ptr;
        }

        FORCEINLINE SetSig(PCCOR_SIGNATURE ptr)
        {
            m_ptr = ptr;
        }

        //------------------------------------------------------------------------
        // Remove one compressed integer (using CorSigUncompressData) from
        // the head of the stream and return it.
        //------------------------------------------------------------------------
        FORCEINLINE ULONG GetData()
        {
            return CorSigUncompressData(m_ptr);
        }


        //-------------------------------------------------------------------------
        // Remove one byte and return it.
        //-------------------------------------------------------------------------
        FORCEINLINE BYTE GetByte()
        {
            return *(m_ptr++);
        }


        FORCEINLINE CorElementType GetElemType()
        {
            return (CorElementType) CorSigEatCustomModifiersAndUncompressElementType(m_ptr);
        }

        ULONG GetCallingConvInfo()  
        {   
            return CorSigUncompressCallingConv(m_ptr);  
        }   

        ULONG GetCallingConv()  
        {   
            return IMAGE_CEE_CS_CALLCONV_MASK & CorSigUncompressCallingConv(m_ptr); 
        }   

        //------------------------------------------------------------------------
        // Non-destructive read of compressed integer.
        //------------------------------------------------------------------------
        ULONG PeekData() const
        {
            PCCOR_SIGNATURE tmp = m_ptr;
            return CorSigUncompressData(tmp);
        }


        //------------------------------------------------------------------------
        // Non-destructive read of element type.
        //
        // This routine makes it look as if the String type is encoded
        // via ELEMENT_TYPE_CLASS followed by a token for the String class,
        // rather than the ELEMENT_TYPE_STRING. This is partially to avoid
        // rewriting client code which depended on this behavior previously.
        // But it also seems like the right thing to do generally.
        //------------------------------------------------------------------------
        CorElementType PeekElemType() const
        {
            PCCOR_SIGNATURE tmp = m_ptr;
            CorElementType typ = CorSigEatCustomModifiersAndUncompressElementType(tmp);
            if (typ == ELEMENT_TYPE_STRING || typ == ELEMENT_TYPE_OBJECT)
                return ELEMENT_TYPE_CLASS;
            return typ;
        }


        //------------------------------------------------------------------------
        // Removes a compressed metadata token and returns it.
        //------------------------------------------------------------------------
        FORCEINLINE mdTypeRef GetToken()
        {
            return CorSigUncompressToken(m_ptr);
        }


        //------------------------------------------------------------------------
        // Tests if two SigPointers point to the same location in the stream.
        //------------------------------------------------------------------------
        FORCEINLINE BOOL Equals(SigPointer sp) const
        {
            return m_ptr == sp.m_ptr;
        }


        //------------------------------------------------------------------------
        // Assumes that the SigPointer points to the start of an element type
        // (i.e. function parameter, function return type or field type.)
        // Advances the pointer to the first data after the element type.  This
        // will skip the following varargs sentinal if it is there.
        //------------------------------------------------------------------------
        VOID Skip();

        //------------------------------------------------------------------------
        // Like Skip, but will not skip a following varargs sentinal.
        //------------------------------------------------------------------------
        VOID SkipExactlyOne();

        //------------------------------------------------------------------------
        // Skip a sub signature (as immediately follows an ELEMENT_TYPE_FNPTR).
        //------------------------------------------------------------------------
        VOID SkipSignature();


        //------------------------------------------------------------------------
        // Get info about single-dimensional arrays
        //------------------------------------------------------------------------
        VOID GetSDArrayElementProps(SigPointer *pElemType, ULONG *pElemCount) const;

        //------------------------------------------------------------------------
        // Assumes that the SigPointer points to the start of an element type.
        // Returns size of that element in bytes. This is the minimum size that a
        // field of this type would occupy inside an object. 
        //------------------------------------------------------------------------
        UINT SizeOf(Module* pModule) const;
        UINT SizeOf(Module* pModule, CorElementType type) const;
};


//------------------------------------------------------------------------
// Encapsulates the format and simplifies walking of MetaData sigs.
//------------------------------------------------------------------------
#ifdef _DEBUG
#define MAX_CACHED_SIG_SIZE     3       // To excercize non-cached code path
#else
#define MAX_CACHED_SIG_SIZE     15
#endif

#define SIG_OFFSETS_INITTED     0x0001
#define SIG_RET_TYPE_INITTED    0x0002

class MetaSig
{
    friend class ArgIterator;
    public:
        enum MetaSigKind { 
            sigMember, 
            sigLocalVars,
            sigField
            };

        //------------------------------------------------------------------
        // Constructor. Warning: Does NOT make a copy of szMetaSig.
        //------------------------------------------------------------------
        MetaSig(PCCOR_SIGNATURE szMetaSig, Module* pModule, BOOL fConvertSigAsVarArg = FALSE, MetaSigKind kind = sigMember);

        //------------------------------------------------------------------
        // Constructor. Copy state from existing MetaSig (does not deep copy
        // zsMetaSig). Iterator fields are reset.
        //------------------------------------------------------------------
        MetaSig(MetaSig *pSig) { memcpy(this, pSig, sizeof(MetaSig)); Reset(); }

        void GetRawSig(BOOL fIsStatic, PCCOR_SIGNATURE *pszMetaSig, DWORD *cbSize);

    //------------------------------------------------------------------
        // Returns type of current argument, then advances the argument
        // index. Returns ELEMENT_TYPE_END if already past end of arguments.
        //------------------------------------------------------------------
        CorElementType NextArg();

        //------------------------------------------------------------------
        // Retreats argument index, then returns type of the argument
        // under the new index. Returns ELEMENT_TYPE_END if already at first
        // argument.
        //------------------------------------------------------------------
        CorElementType PrevArg();

        //------------------------------------------------------------------
        // Returns type of current argument index. Returns ELEMENT_TYPE_END if already past end of arguments.
        //------------------------------------------------------------------
        CorElementType PeekArg();

        //------------------------------------------------------------------
        // Returns a read-only SigPointer for the last type to be returned
        // via NextArg() or PrevArg(). This allows extracting more information
        // for complex types.
        //------------------------------------------------------------------
        const SigPointer & GetArgProps() const
        {
            return m_pLastType;
        }

        //------------------------------------------------------------------
        // Returns a read-only SigPointer for the return type.
        // This allows extracting more information for complex types.
        //------------------------------------------------------------------
        const SigPointer & GetReturnProps() const
        {
            return m_pRetType;
        }


        //------------------------------------------------------------------------
        // Returns # of arguments. Does not count the return value.
        // Does not count the "this" argument (which is not reflected om the
        // sig.) 64-bit arguments are counted as one argument.
        //------------------------------------------------------------------------
        static UINT NumFixedArgs(Module* pModule, PCCOR_SIGNATURE pSig);

        //------------------------------------------------------------------------
        // Returns # of arguments. Does not count the return value.
        // Does not count the "this" argument (which is not reflected om the
        // sig.) 64-bit arguments are counted as one argument.
        //------------------------------------------------------------------------
        UINT NumFixedArgs()
        {
            return m_nArgs;
        }
        
        //----------------------------------------------------------
        // Returns the calling convention (see IMAGE_CEE_CS_CALLCONV_*
        // defines in cor.h)
        //----------------------------------------------------------
        static BYTE GetCallingConvention(Module* pModule, PCCOR_SIGNATURE pSig)
        {
            return (BYTE)(IMAGE_CEE_CS_CALLCONV_MASK & (CorSigUncompressCallingConv(/*modifies*/pSig)));
        }

        //----------------------------------------------------------
        // Returns the calling convention (see IMAGE_CEE_CS_CALLCONV_*
        // defines in cor.h)
        //----------------------------------------------------------
        static BYTE GetCallingConventionInfo(Module* pModule, PCCOR_SIGNATURE pSig)
        {
            return (BYTE)CorSigUncompressCallingConv(/*modifies*/pSig);
        }

        //----------------------------------------------------------
        // Returns the calling convention (see IMAGE_CEE_CS_CALLCONV_*
        // defines in cor.h)
        //----------------------------------------------------------
        BYTE GetCallingConvention()
        {
            return m_CallConv & IMAGE_CEE_CS_CALLCONV_MASK; 
        }

        //----------------------------------------------------------
        // Returns the calling convention & flags (see IMAGE_CEE_CS_CALLCONV_*
        // defines in cor.h)
        //----------------------------------------------------------
        BYTE GetCallingConventionInfo()
        {
            return m_CallConv;
        }

        //----------------------------------------------------------
        // Has a 'this' pointer?
        //----------------------------------------------------------
        BOOL HasThis()
        {
            return m_CallConv & IMAGE_CEE_CS_CALLCONV_HASTHIS;
        }

        //----------------------------------------------------------
        // Is vararg?
        //----------------------------------------------------------
        BOOL IsVarArg()
        {
            return GetCallingConvention() == IMAGE_CEE_CS_CALLCONV_VARARG;
        }

        //----------------------------------------------------------
        // Is vararg?
        //----------------------------------------------------------
        static BOOL IsVarArg(Module* pModule, PCCOR_SIGNATURE pSig)
        {
            return GetCallingConvention(pModule, pSig) == IMAGE_CEE_CS_CALLCONV_VARARG;
        }

        //------------------------------------------------------------------
        // Moves index to end of argument list.
        //------------------------------------------------------------------
        VOID GotoEnd();

        //------------------------------------------------------------------
        // reset: goto start pos
        //------------------------------------------------------------------
        VOID Reset();

        //------------------------------------------------------------------
        // Returns type of return value.
        //------------------------------------------------------------------
        FORCEINLINE CorElementType GetReturnType() const
        {
            return m_pRetType.PeekElemType();
        }

        int GetLastTypeSize() 
        {
            return m_pLastType.SizeOf(m_pModule);
        }

        //------------------------------------------------------------------------
        // Returns # of stack bytes required to create a call-stack using
        // the internal calling convention.
        // Includes indication of "this" pointer since that's not reflected
        // in the sig.
        //------------------------------------------------------------------------
        static UINT SizeOfVirtualFixedArgStack(Module* pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic);
        static UINT SizeOfActualFixedArgStack(Module* pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic);

        //------------------------------------------------------------------------
        // Returns # of stack bytes to pop upon return.
        // Includes indication of "this" pointer since that's not reflected
        // in the sig.
        //------------------------------------------------------------------------
        static UINT CbStackPop(Module* pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic)
        {
            if (MetaSig::IsVarArg(pModule, szMetaSig))
            {
                return 0;
            }
            else
            {
                return SizeOfActualFixedArgStack(pModule, szMetaSig, fIsStatic);
            }
        }


    // These are protected because Reflection subclasses Metasig
    protected:

    static const UINT32 s_cSigHeaderOffset;

        // @todo: These fields are only used for new-style signatures.
        Module*      m_pModule;
        SigPointer   m_pStart;
        SigPointer   m_pWalk;
        SigPointer   m_pLastType;
        SigPointer   m_pRetType;
        UINT32       m_nArgs;
        UINT32       m_iCurArg;
    UINT32       m_cbSigSize;
    PCCOR_SIGNATURE m_pszMetaSig;


        // The following are cached so we don't the signature
        //  multiple times
        UINT32       m_nVirtualStack;   // Size of the virtual stack
        UINT32       m_nActualStack;    // Size of the actual stack

        BYTE         m_CallConv;
        BYTE         m_WalkStatic;      // The type of function we walked

        BYTE            m_types[MAX_CACHED_SIG_SIZE + 1];
        short           m_sizes[MAX_CACHED_SIG_SIZE + 1];
        short           m_offsets[MAX_CACHED_SIG_SIZE + 1];
        CorElementType  m_corNormalizedRetType;
        DWORD           m_fCacheInitted;

            // used to treat some sigs as special case vararg
            // used by calli to unmanaged target
        BYTE         m_fTreatAsVarArg;
        BOOL        IsTreatAsVarArg()
        {
                    return m_fTreatAsVarArg;
        }
};

class FieldSig

{
    // For new-style signatures only.
    SigPointer m_pStart;
    Module*    m_pModule;
public:
        //------------------------------------------------------------------
        // Constructor. Warning: Does NOT make a copy of szMetaSig.
        //------------------------------------------------------------------
        
        FieldSig(PCCOR_SIGNATURE szMetaSig, Module* pModule)
        {
            m_pModule = pModule;
            m_pStart = SigPointer(szMetaSig);
            m_pStart.GetData();     // Skip "calling convention"
        }
        //------------------------------------------------------------------
        // Returns type of the field
        //------------------------------------------------------------------
        CorElementType GetFieldType()
        {
            return m_pStart.PeekElemType();
        }

};




//=========================================================================
// Indicates whether an argument is to be put in a register using the
// default IL calling convention. This should be called on each parameter
// in the order it appears in the call signature. For a non-static method,
// this function should also be called once for the "this" argument, prior
// to calling it for the "real" arguments. Pass in a typ of IMAGE_CEE_CS_OBJECT.
//
//  *pNumRegistersUsed:  [in,out]: keeps track of the number of argument
//                       registers assigned previously. The caller should
//                       initialize this variable to 0 - then each call
//                       will update it.
//
//  typ:                 the signature type
//  structSize:          for structs, the size in bytes
//  fThis:               is this about the "this" pointer?
//  callconv:            see IMAGE_CEE_CS_CALLCONV_*
//  *pOffsetIntoArgumentRegisters:
//                       If this function returns TRUE, then this out variable
//                       receives the identity of the register, expressed as a
//                       byte offset into the ArgumentRegisters structure.
//
// 
//=========================================================================
BOOL IsArgumentInRegister(int   *pNumRegistersUsed,
                          BYTE   typ,
                          UINT32 structSize,
                          BOOL   fThis,
                          BYTE   callconv,
                          int    *pOffsetIntoArgumentRegisters);

#undef Module 

#endif /* _H_SIGINFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\tst-stackwalk.h ===
#pragma once

class CrawlFrame;

//************************************************************************
// Stack walking
//************************************************************************
enum StackWalkAction {
    SWA_CONTINUE    = 0,    // continue walking
    SWA_ABORT       = 1,    // stop walking, early out in "failure case"
    SWA_FAILED      = 2     // couldn't walk stack
};

#define SWA_DONE SWA_CONTINUE

// Pointer to the StackWalk callback function.
typedef StackWalkAction (*PSTACKWALKFRAMESCALLBACK)(
    CrawlFrame       *pCF,      //
    VOID*             pData     // Caller's private data

);

enum StackCrawlMark
{
    LookForMe = 0,
    LookForMyCaller = 1,
    LookForMyCallersCaller = 2,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\tst-siginfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// siginfo.cpp
//
// Signature parsing code
//
#pragma warning(disable:4510 4512 4610 4100 4244 4245 4189 4127 4211 4714)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wchar.h>
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <malloc.h>
#include <stddef.h>

#include <dbghelp.h>

#include "strike.h"
#include "cor.h"
#include "corhdr.h"
#include "eestructs.h"
#include "tst-siginfo.h"

#define DEFINE_ARGUMENT_REGISTER_NOTHING
#include "..\..\vm\eecallconv.h"
#undef DEFINE_ARGUMENT_REGISTER_NOTHING

#define Module mdScope
#define OBJECTREF PVOID

typedef enum CorElementTypeInternal
{
    ELEMENT_TYPE_VAR_INTERNAL            = 0x13,     // a type variable VAR <U1>

    ELEMENT_TYPE_VALUEARRAY_INTERNAL     = 0x17,     // VALUEARRAY <type> <bound>

    ELEMENT_TYPE_R_INTERNAL              = 0x1A,     // native real size

    ELEMENT_TYPE_GENERICARRAY_INTERNAL   = 0x1E,     // Array with unknown rank
                                            // GZARRAY <type>

} CorElementTypeInternal;

#define ELEMENT_TYPE_VAR           ((CorElementType) ELEMENT_TYPE_VAR_INTERNAL          )
#define ELEMENT_TYPE_VALUEARRAY    ((CorElementType) ELEMENT_TYPE_VALUEARRAY_INTERNAL   )
#define ELEMENT_TYPE_R             ((CorElementType) ELEMENT_TYPE_R_INTERNAL            )
#define ELEMENT_TYPE_GENERICARRAY  ((CorElementType) ELEMENT_TYPE_GENERICARRAY_INTERNAL )

const ElementTypeInfo gElementTypeInfoSig[] = {

#ifdef _DEBUG
#define DEFINEELEMENTTYPEINFO(etname, cbsize, gcness, isfp, inreg, base) {(int)(etname),cbsize,gcness,isfp,inreg,base},
#else
#define DEFINEELEMENTTYPEINFO(etname, cbsize, gcness, isfp, inreg, base) {cbsize,gcness,isfp,inreg,base},
#endif


// Meaning of columns:
//
//     name     - The checked build uses this to verify that the table is sorted
//                correctly. This is a lookup table that uses ELEMENT_TYPE_*
//                as an array index.
//
//     cbsize   - The byte size of this value as returned by SizeOf(). SPECIAL VALUE: -1
//                requires type-specific treatment.
//
//     gc       - 0    no embedded objectrefs
//                1    value is an objectref
//                2    value is an interior pointer - promote it but don't scan it
//                3    requires type-specific treatment
//
//
//     fp       - boolean: does this require special fpu treatment on return?
//
//     reg      - put in a register?
//
//                    name                         cbsize               gc      fp reg Base
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_END,            -1,             TYPE_GC_NONE, 0, 0,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VOID,           0,              TYPE_GC_NONE, 0, 0,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_BOOLEAN,        1,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CHAR,           2,              TYPE_GC_NONE, 0, 1,  1)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I1,             1,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U1,             1,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I2,             2,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U2,             2,              TYPE_GC_NONE, 0, 1,  1)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I4,             4,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U4,             4,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I8,             8,              TYPE_GC_NONE, 0, 0,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U8,             8,              TYPE_GC_NONE, 0, 0,  1)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_R4,             4,              TYPE_GC_NONE, 1, 0,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_R8,             8,              TYPE_GC_NONE, 1, 0,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_STRING,         sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_PTR,            sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  0)  

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_BYREF,          sizeof(LPVOID), TYPE_GC_BYREF, 0, 1, 0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VALUETYPE,      -1,             TYPE_GC_OTHER, 0, 0,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CLASS,          sizeof(LPVOID), TYPE_GC_REF,   0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VAR,            sizeof(LPVOID), TYPE_GC_REF,   0, 1,  0)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_ARRAY,          sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0)

// The following element used to be ELEMENT_TYPE_COPYCTOR, but it was removed, though the gap left.
//DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_COPYCTOR,       sizeof(LPVOID), TYPE_GC_BYREF, 0, 1,  0)       
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_ARRAY+1,        0,              TYPE_GC_NONE,  0, 0,  0)       

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_TYPEDBYREF,         sizeof(LPVOID)*2,TYPE_GC_BYREF, 0, 0,0)            
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VALUEARRAY,     -1,             TYPE_GC_OTHER, 0, 0, 0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I,              sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U,              sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_R,              8,              TYPE_GC_NONE, 1, 0,  1)


DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_FNPTR,          sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_OBJECT,         sizeof(LPVOID), TYPE_GC_REF, 0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_SZARRAY,        sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0)

// generic array have been removed. Fill the gap
//DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_GENERICARRAY,   sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0) 
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_SZARRAY+1,      0,              TYPE_GC_NONE, 0, 0,  0)       

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CMOD_REQD,      -1,             TYPE_GC_NONE,  0, 1,  0)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CMOD_OPT,       -1,             TYPE_GC_NONE,  0, 1,  0)       

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_INTERNAL,       sizeof(LPVOID), TYPE_GC_NONE,  0, 0,  0)       
};


unsigned GetSizeForCorElementType(CorElementType etyp)
{
        return gElementTypeInfoSig[etyp].m_cbSize;
}

const ElementTypeInfo* GetElementTypeInfo(CorElementType etyp)
{
        return &gElementTypeInfoSig[etyp];
}

BOOL    IsFP(CorElementType etyp)
{
        return gElementTypeInfoSig[etyp].m_fp;
}

BOOL    IsBaseElementType(CorElementType etyp)
{
        return gElementTypeInfoSig[etyp].m_isBaseType;

}

// This skips one element and then checks for and skips a varargs sentinal.
VOID SigPointer::Skip()
{
    SkipExactlyOne();

    if (PeekData() == ELEMENT_TYPE_SENTINEL)
        GetData();
}

VOID SigPointer::SkipExactlyOne()
{
    ULONG typ;

    typ = GetElemType();

    if (!CorIsPrimitiveType((CorElementType)typ))
    {
        switch (typ)
        {
            default:
                break;
            case ELEMENT_TYPE_VAR:
                GetData();      // Skip variable number
                break;
            case ELEMENT_TYPE_OBJECT:
            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_TYPEDBYREF:
            case ELEMENT_TYPE_U:
            case ELEMENT_TYPE_I:
            case ELEMENT_TYPE_R:
                break;

            case ELEMENT_TYPE_BYREF: //fallthru
            case ELEMENT_TYPE_PTR:
            case ELEMENT_TYPE_PINNED:
            case ELEMENT_TYPE_SZARRAY:
                SkipExactlyOne();              // Skip referenced type
                break;

            case ELEMENT_TYPE_VALUETYPE: //fallthru
            case ELEMENT_TYPE_CLASS:
                GetToken();          // Skip RID
                break;

            case ELEMENT_TYPE_VALUEARRAY: 
                SkipExactlyOne();         // Skip element type
                GetData();      // Skip array size
                break;

            case ELEMENT_TYPE_FNPTR: 
                SkipSignature();
                break;

            case ELEMENT_TYPE_ARRAY: 
                {
                    SkipExactlyOne();     // Skip element type
                    UINT32 rank = GetData();    // Get rank
                    if (rank)
                    {
                        UINT32 nsizes = GetData(); // Get # of sizes
                        while (nsizes--)
                        {
                            GetData();           // Skip size
                        }

                        UINT32 nlbounds = GetData(); // Get # of lower bounds
                        while (nlbounds--)
                        {
                            GetData();           // Skip lower bounds
                        }
                    }

                }
                break;

            case ELEMENT_TYPE_SENTINEL:
                break;
        }
    }
}

// Skip a sub signature (as immediately follows an ELEMENT_TYPE_FNPTR).
VOID SigPointer::SkipSignature()
{
    // Skip calling convention;
    ULONG uCallConv = GetData();

    // Get arg count;
    ULONG cArgs = GetData();

    // Skip return type;
    SkipExactlyOne();

    // Skip args.
    while (cArgs) {
        SkipExactlyOne();
        cArgs--;
    }
}


//------------------------------------------------------------------------
// Get info about single-dimensional arrays
//------------------------------------------------------------------------
VOID SigPointer::GetSDArrayElementProps(SigPointer *pElemType, ULONG *pElemCount) const
{
    SigPointer sp = *this;
    ULONG typ = sp.GetElemType();
    *pElemType = sp;
    sp.Skip();
    *pElemCount = sp.GetData();
}

//------------------------------------------------------------------
// Constructor.
//------------------------------------------------------------------

MetaSig::MetaSig(PCCOR_SIGNATURE szMetaSig, Module* pModule, 
                 BOOL fConvertSigAsVarArg, MetaSigKind kind)
{
    m_pModule = pModule;
    m_pszMetaSig = szMetaSig;
    SigPointer psig(szMetaSig);

    switch(kind)
    {
        case sigLocalVars:
        {
            m_CallConv = (BYTE)psig.GetCallingConvInfo(); // Store calling convention
            m_nArgs     = psig.GetData();  // Store number of arguments.
            m_pRetType = NULL;
            break;
        }
        case sigMember:
        {
            m_CallConv = (BYTE)psig.GetCallingConvInfo(); // Store calling convention
            m_nArgs     = psig.GetData();  // Store number of arguments.
            m_pRetType  = psig;
            psig.Skip();
            break;
        }
        case sigField:
        {
            m_CallConv = (BYTE)psig.GetCallingConvInfo(); // Store calling convention
            m_nArgs = 1; //There's only 1 'arg' - the type.
            m_pRetType = NULL;
            break;
        }
    }
    
    m_pStart    = psig;
    // used to treat some sigs as special case vararg
    // used by calli to unmanaged target
    m_fTreatAsVarArg = fConvertSigAsVarArg;

    // Intialize the actual sizes
    m_nActualStack = (UINT32) -1;
    m_nVirtualStack = (UINT32) -1;
    m_cbSigSize = (UINT32) -1;

    m_fCacheInitted = 0;
    // Reset the iterator fields
    Reset();
}

void MetaSig::GetRawSig(BOOL fIsStatic, PCCOR_SIGNATURE *ppszMetaSig, DWORD *pcbSize)
{
    *ppszMetaSig = m_pszMetaSig;
    *pcbSize = m_cbSigSize;
}


//------------------------------------------------------------------
// Returns type of current argument index. Returns ELEMENT_TYPE_END 
// if already past end of arguments.
//------------------------------------------------------------------
CorElementType MetaSig::PeekArg()
{
    if (m_iCurArg == m_nArgs)
    {
        return ELEMENT_TYPE_END;
    }
    else
    {
        CorElementType mt = m_pWalk.PeekElemType();
        return mt;
    }
}


//------------------------------------------------------------------
// Returns type of current argument, then advances the argument
// index. Returns ELEMENT_TYPE_END if already past end of arguments.
//------------------------------------------------------------------
CorElementType MetaSig::NextArg()
{
    m_pLastType = m_pWalk;
    if (m_iCurArg == m_nArgs)
    {
        return ELEMENT_TYPE_END;
    }
    else
    {
        m_iCurArg++;
        CorElementType mt = m_pWalk.PeekElemType();
        m_pWalk.Skip();
        return mt;
    }
}

//------------------------------------------------------------------
// Retreats argument index, then returns type of the argument
// under the new index. Returns ELEMENT_TYPE_END if already at first
// argument.
//------------------------------------------------------------------
CorElementType MetaSig::PrevArg()
{
    if (m_iCurArg == 0)
    {
        return ELEMENT_TYPE_END;
    }
    else
    {
        m_iCurArg--;
        m_pWalk = m_pStart;
        for (UINT32 i = 0; i < m_iCurArg; i++)
        {
            m_pWalk.Skip();
        }
        m_pLastType = m_pWalk;
        return m_pWalk.PeekElemType();
    }
}

//------------------------------------------------------------------------
// Returns # of arguments. Does not count the return value.
// Does not count the "this" argument (which is not reflected om the
// sig.) 64-bit arguments are counted as one argument.
//------------------------------------------------------------------------
/*static*/ UINT MetaSig::NumFixedArgs(Module* pModule, PCCOR_SIGNATURE pSig)
{
    MetaSig msig(pSig, pModule);

    return msig.NumFixedArgs();
}

//------------------------------------------------------------------
// reset: goto start pos
//------------------------------------------------------------------
VOID MetaSig::Reset()
{
    m_pWalk = m_pStart;
    m_iCurArg  = 0;
}

//------------------------------------------------------------------
// Moves index to end of argument list.
//------------------------------------------------------------------
VOID MetaSig::GotoEnd()
{
    m_pWalk = m_pStart;
    for (UINT32 i = 0; i < m_nArgs; i++)
    {
        m_pWalk.Skip();
    }
    m_iCurArg = m_nArgs;

}

//=========================================================================
// Indicates whether an argument is to be put in a register using the
// default IL calling convention. This should be called on each parameter
// in the order it appears in the call signature. For a non-static method,
// this function should also be called once for the "this" argument, prior
// to calling it for the "real" arguments. Pass in a typ of ELEMENT_TYPE_CLASS.
//
//  *pNumRegistersUsed:  [in,out]: keeps track of the number of argument
//                       registers assigned previously. The caller should
//                       initialize this variable to 0 - then each call
//                       will update it.
//
//  typ:                 the signature type
//  structSize:          for structs, the size in bytes
//  fThis:               is this about the "this" pointer?
//  callconv:            see IMAGE_CEE_CS_CALLCONV_*
//  *pOffsetIntoArgumentRegisters:
//                       If this function returns TRUE, then this out variable
//                       receives the identity of the register, expressed as a
//                       byte offset into the ArgumentRegisters structure.
//
// 
//=========================================================================
BOOL IsArgumentInRegister(int   *pNumRegistersUsed,
                          BYTE   typ,
                          UINT32 structSize,
                          BOOL   fThis,
                          BYTE   callconv,
                          int   *pOffsetIntoArgumentRegisters)
{
    int dummy;
    if (pOffsetIntoArgumentRegisters == NULL) {
        pOffsetIntoArgumentRegisters = &dummy;
    }

#ifdef _X86_

    if ( (*pNumRegistersUsed) == NUM_ARGUMENT_REGISTERS || (callconv == IMAGE_CEE_CS_CALLCONV_VARARG && !fThis) ) {
        return FALSE;
    } else {

        if (gElementTypeInfoSig[typ].m_enregister) {
            int registerIndex = (*pNumRegistersUsed)++;
            *pOffsetIntoArgumentRegisters = sizeof(ArgumentRegisters) - sizeof(UINT32)*(1+registerIndex);
            return TRUE;
        }
        return FALSE;
    }
#else
    return FALSE;
#endif
}


//------------------------------------------------------------------------
// Returns # of stack bytes required to create a call-stack using
// the internal calling convention.
// Includes indication of "this" pointer since that's not reflected
// in the sig.
//------------------------------------------------------------------------
/*static*/ UINT MetaSig::SizeOfVirtualFixedArgStack(Module* pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic)
{
    UINT cb = 0;
    MetaSig msig(szMetaSig, pModule);

    if (!fIsStatic)
        cb += StackElemSize(sizeof(OBJECTREF));

//     if (msig.HasRetBuffArg())
//         cb += StackElemSize(sizeof(OBJECTREF));

    while (ELEMENT_TYPE_END != msig.NextArg()) {
        cb += StackElemSize(msig.GetArgProps().SizeOf(pModule));
    }
    return cb;

}

//------------------------------------------------------------------------
// Returns # of stack bytes required to create a call-stack using
// the actual calling convention.
// Includes indication of "this" pointer since that's not reflected
// in the sig.
//------------------------------------------------------------------------
/*static*/ UINT MetaSig::SizeOfActualFixedArgStack(Module *pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic)
{
    UINT cb = 0;
#ifndef _ALPHA_  // Alpha stack usage must be multiples of 16 bytes
    MetaSig msig(szMetaSig, pModule);
    int numregsused = 0;
    BOOL fIsVarArg = msig.IsVarArg();
    BYTE callconv  = msig.GetCallingConvention();

    if (!fIsStatic) {
        if (!IsArgumentInRegister(&numregsused, ELEMENT_TYPE_CLASS, 0, TRUE, callconv, NULL)) {
            cb += StackElemSize(sizeof(OBJECTREF));
        }
    }
    /*
    if (msig.HasRetBuffArg())
        numregsused++;
    */

    if (fIsVarArg || msig.IsTreatAsVarArg()) {
        numregsused = NUM_ARGUMENT_REGISTERS;   // No other params in registers 
        cb += StackElemSize(sizeof(LPVOID));    // VASigCookie
    }

    CorElementType mtype;
    while (ELEMENT_TYPE_END != (mtype = msig.NextArg/*Normalized*/())) {
        UINT cbSize = msig.GetLastTypeSize();

        if (!IsArgumentInRegister(&numregsused, mtype, cbSize, FALSE, callconv, NULL))
        {
            cb += StackElemSize(cbSize);
        }
    }

        // Parameterized type passed as last parameter, but not mentioned in the sig
    if (msig.GetCallingConventionInfo() & CORINFO_CALLCONV_PARAMTYPE)
        if (!IsArgumentInRegister(&numregsused, ELEMENT_TYPE_I, sizeof(void*), FALSE, callconv, NULL))
            cb += sizeof(void*);

#else _ALPHA_
    #endif // !_ALPHA_
    return cb;
}


//------------------------------------------------------------------------
// Assumes that the SigPointer points to the start of an element type.
// Returns size of that element in bytes. This is the minimum size that a
// field of this type would occupy inside an object. 
//------------------------------------------------------------------------
UINT SigPointer::SizeOf(Module* pModule) const
{
    CorElementType etype = PeekElemType();
    return SizeOf(pModule, etype);
}

UINT SigPointer::SizeOf(Module* pModule, CorElementType etype) const
{
    int cbsize = gElementTypeInfoSig[etype].m_cbSize;
    if (cbsize != -1)
    {
        return cbsize;
    }

//     if (etype == ELEMENT_TYPE_VALUETYPE)
//     {
//         TypeHandle th = GetTypeHandle(pModule, NULL, TRUE);
//         EEClass* pClass = th.AsClass();
//         return pClass->GetAlignedNumInstanceFieldBytes();
//     }
    else if (etype == ELEMENT_TYPE_VALUEARRAY)
    {   
        SigPointer elemType;    
        ULONG count;    
        GetSDArrayElementProps(&elemType, &count);  
        UINT ret = elemType.SizeOf(pModule) * count;   
        ret = (ret + 3) & ~3;       // round up to dword alignment  
        return(ret);    
    }   
    return 0;
}

#undef Module
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\utilia64.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "data.h"
#include "eestructs.h"
#include "util.h"


void CodeInfoForMethodDesc (MethodDesc &MD, CodeInfo &infoHdr, BOOL bSimple)
{
    dprintf("CodeInfoForMethodDesc not yet implemented\n");

    infoHdr.IPBegin    = 0;
    infoHdr.methodSize = 0;
    infoHdr.jitType    = UNKNOWN;
    
    size_t ip = MD.m_CodeOrIL;

    //
    // @todo: handle case where m_CodeOrIL points to the prestub in front 
    //        of the method desc
    //

    DWORD_PTR methodDesc;
    IP2MethodDesc(ip, methodDesc, infoHdr.jitType, infoHdr.gcinfoAddr);
    if (!methodDesc || infoHdr.jitType == UNKNOWN)
    {
        dprintf("Not jitted code\n");
        return;
    }

    if (infoHdr.jitType == JIT || infoHdr.jitType == PJIT)
    {
        
    }
    else if (infoHdr.jitType == EJIT)
    {
    }    

    infoHdr.IPBegin = ip;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\util.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "data.h"
#include "eestructs.h"
#include "util.h"
#include "gcinfo.h"
#include "disasm.h"
#include <dbghelp.h>
#include "get-table-info.h"

#define MAX_SYMBOL_LEN 4096
#define SYM_BUFFER_SIZE (sizeof(IMAGEHLP_SYMBOL) + MAX_SYMBOL_LEN)
char symBuffer[SYM_BUFFER_SIZE];
PIMAGEHLP_SYMBOL sym = (PIMAGEHLP_SYMBOL) symBuffer;

JitType GetJitType (DWORD_PTR Jit_vtbl);

char *CorElementTypeName[ELEMENT_TYPE_MAX]=
{
#define TYPEINFO(e,c,s,g,ie,ia,ip,if,im,ial)    c,
#include "cortypeinfo.h"
#undef TYPEINFO
};

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to get the memory address given a symbol  *  
*    name.  It handles difference in symbol name between ntsd and      *
*    windbg.                                                           *
*                                                                      *
\**********************************************************************/
#if 0
DWORD_PTR GetValueFromExpression (char *instr)
{
    ULONG64 dwAddr;
    char *str;
    char name[256];

    EEFLAVOR flavor = GetEEFlavor ();
    if (flavor == MSCOREE)
        str = instr;
    else if (flavor == UNKNOWNEE)
        return 0;
    else
    {
        if (_strnicmp (instr, "mscoree!", sizeof ("mscoree!")-1) != 0)
        {
            str = instr;
        }
        else
        {
            if (flavor == MSCORWKS)
            {
                strcpy (name, "mscorwks!");
            }
            else
            {
                strcpy (name, "mscorsvr!");
            }
            strcat (name, instr+sizeof("mscoree!")-1);
            str = name;
        }
    }

    dwAddr = 0;
    HRESULT hr = g_ExtSymbols->GetOffsetByName (str, &dwAddr);
    if (SUCCEEDED(hr))
        return (DWORD_PTR)dwAddr;
    else if (hr == S_FALSE && dwAddr)
        return (DWORD_PTR)dwAddr;

    strcpy (name, str);
    char *ptr;
    if ((ptr = strstr (name, "__")) != NULL)
    {
        ptr[0] = ':';
        ptr[1] = ':';
        ptr += 2;
        while ((ptr = strstr(ptr, "__")) != NULL)
        {
            ptr[0] = ':';
            ptr[1] = ':';
            ptr += 2;
        }
        dwAddr = 0;
        hr = g_ExtSymbols->GetOffsetByName (name, &dwAddr);
        if (SUCCEEDED(hr))
            return (DWORD_PTR)dwAddr;
        else if (hr == S_FALSE && dwAddr)
            return (DWORD_PTR)dwAddr;
    }
    else if ((ptr = strstr (name, "::")) != NULL)
    {
        ptr[0] = '_';
        ptr[1] = '_';
        ptr += 2;
        while ((ptr = strstr(ptr, "::")) != NULL)
        {
            ptr[0] = '_';
            ptr[1] = '_';
            ptr += 2;
        }
        dwAddr = 0;
        hr = g_ExtSymbols->GetOffsetByName (name, &dwAddr);
        if (SUCCEEDED(hr))
            return (DWORD_PTR)dwAddr;
        else if (hr == S_FALSE && dwAddr)
            return (DWORD_PTR)dwAddr;
    }
    return 0;
}
#endif

DWORD_PTR GetAddressOf (size_t klass, size_t member)
{
    // GetMemberInformation returns -1 for invalid values.
    // 0 makes more sense for pointers.
    ULONG_PTR r = GetMemberInformation (klass, member);
    if (r == static_cast<ULONG_PTR>(-1))
      return 0;
    return r;
}

ModuleInfo moduleInfo[MSCOREND] = {{0,FALSE},{0,FALSE},{0,FALSE},{0,FALSE}};

BOOL CheckEEDll ()
{
    DEBUG_MODULE_PARAMETERS Params;

    static BOOL MscoreeDone = FALSE;
    static BOOL MscorwksDone = FALSE;
    static BOOL MscorsvrDone = FALSE;

#if 0
    if (!MscoreeDone) {
        MscoreeDone = TRUE;
    
        // Do we have mscoree.dll loaded?
        if (moduleInfo[MSCOREE].baseAddr == 0)
                g_ExtSymbols->GetModuleByModuleName ("mscoree",0,NULL,
                                                     &moduleInfo[MSCOREE].baseAddr);
        if (moduleInfo[MSCOREE].baseAddr == 0)
            return TRUE;

        if (moduleInfo[MSCOREE].baseAddr != 0 && moduleInfo[MSCOREE].hasPdb == FALSE)
        {
            g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCOREE].baseAddr, 0, &Params);
            if (Params.SymbolType == SymDeferred)
            {
                g_ExtSymbols->Reload("/f mscoree.dll");
                g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCOREE].baseAddr, 0, &Params);
            }

            if (Params.SymbolType == SymPdb || Params.SymbolType == SymDia)
            {
                moduleInfo[MSCOREE].hasPdb = TRUE;
            }
        }
        if (moduleInfo[MSCOREE].baseAddr != 0 && moduleInfo[MSCOREE].hasPdb == FALSE)
            dprintf ("PDB symbol for mscoree.dll not loaded\n");
    }
#endif
    
    if (!MscorwksDone) {
        MscorwksDone = TRUE;
    
        // Do we have mscorwks.dll or mscorsvr.dll
        if (moduleInfo[MSCORSVR].baseAddr == 0)
        {
            if (moduleInfo[MSCORWKS].baseAddr == 0)
                g_ExtSymbols->GetModuleByModuleName ("mscorwks",0,NULL,
                                                     &moduleInfo[MSCORWKS].baseAddr);
            if (moduleInfo[MSCORWKS].baseAddr != 0 && moduleInfo[MSCORWKS].hasPdb == FALSE)
            {
                g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCORWKS].baseAddr, 0, &Params);
                if (Params.SymbolType == SymDeferred)
                {
                    g_ExtSymbols->Reload("/f mscorwks.dll");
                    g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCORWKS].baseAddr, 0, &Params);
                }

                if (Params.SymbolType == SymPdb || Params.SymbolType == SymDia)
                {
                    moduleInfo[MSCORWKS].hasPdb = TRUE;
                }
            }
            if (moduleInfo[MSCORWKS].baseAddr != 0 && moduleInfo[MSCORWKS].hasPdb == FALSE)
                dprintf ("PDB symbol for mscorwks.dll not loaded\n");
            if (moduleInfo[MSCORWKS].baseAddr)
                return TRUE;
        }
    }

    if (!MscorsvrDone) {
        MscorsvrDone = TRUE;
    
        if (moduleInfo[MSCORWKS].baseAddr == 0)
        {
            if (moduleInfo[MSCORSVR].baseAddr == 0)
                g_ExtSymbols->GetModuleByModuleName ("mscorsvr",0,NULL,
                                                     &moduleInfo[MSCORSVR].baseAddr);
            if (moduleInfo[MSCORSVR].baseAddr != 0 && moduleInfo[MSCORSVR].hasPdb == FALSE)
            {
                g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCORSVR].baseAddr, 0, &Params);
                if (Params.SymbolType == SymDeferred)
                {
                    g_ExtSymbols->Reload("/f mscorsvr.dll");
                    g_ExtSymbols->GetModuleParameters (1, &moduleInfo[MSCORSVR].baseAddr, 0, &Params);
                }

                if (Params.SymbolType == SymPdb || Params.SymbolType == SymDia)
                {
                    moduleInfo[MSCORSVR].hasPdb = TRUE;
                }
            }
            if (moduleInfo[MSCORSVR].baseAddr != 0 && moduleInfo[MSCORSVR].hasPdb == FALSE)
                dprintf ("PDB symbol for mscorsvr.dll not loaded\n");
        }
    }
    
    return TRUE;
}

EEFLAVOR GetEEFlavor ()
{
    static EEFLAVOR flavor = UNKNOWNEE;
    if (flavor != UNKNOWNEE)
        return flavor;
    
    if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName("mscorwks",0,NULL,NULL))) {
        flavor = MSCORWKS;
    }
    else if (SUCCEEDED(g_ExtSymbols->GetModuleByModuleName("mscorsvr",0,NULL,NULL))) {
        flavor = MSCORSVR;
    }
#if 0
    ULONG64 addr;
    if (SUCCEEDED(g_ExtSymbols->GetOffsetByName("mscorwks!_CorExeMain", &addr)))
        flavor = MSCORWKS;
    else if (SUCCEEDED(g_ExtSymbols->GetOffsetByName("mscorsvr!_CorExeMain", &addr)))
        flavor = MSCORSVR;
    else if (SUCCEEDED(g_ExtSymbols->GetOffsetByName("mscoree!_CorExeMain", &addr)))
        flavor = MSCOREE;
#endif
    return flavor;
}

BOOL IsDumpFile ()
{
    static int g_fDumpFile = -1;
    if (g_fDumpFile == -1) {
        ULONG Class;
        ULONG Qualifier;
        g_ExtControl->GetDebuggeeType(&Class,&Qualifier);
        if (Qualifier)
            g_fDumpFile = 1;
        else
            g_fDumpFile = 0;
    }
    return g_fDumpFile != 0;
}

ULONG TargetPlatform()
{
    static ULONG platform = -1;
    if (platform == -1) {
        ULONG major;
        ULONG minor;
        ULONG SPNum;
        g_ExtControl->GetSystemVersion(&platform,&major,&minor,NULL,0,NULL,&SPNum,NULL,0,NULL);
    }
    return platform;
}

ULONG DebuggeeType()
{
    static ULONG Class = DEBUG_CLASS_UNINITIALIZED;
    if (Class == DEBUG_CLASS_UNINITIALIZED) {
        ULONG Qualifier;
        g_ExtControl->GetDebuggeeType(&Class,&Qualifier);
    }
    return Class;
}

// Check if a file exist
BOOL FileExist (const char *filename)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE handle = FindFirstFile (filename, &FindFileData);
    if (handle != INVALID_HANDLE_VALUE) {
        FindClose (handle);
        return TRUE;
    }
    else
        return FALSE;
}


BOOL FileExist (const WCHAR *filename)
{
    if (TargetPlatform() == VER_PLATFORM_WIN32_WINDOWS) {
        char filenameA[MAX_PATH+1];
        WideCharToMultiByte (CP_ACP,0,filename,-1,filenameA,MAX_PATH,0,NULL);
        filenameA[MAX_PATH] = '\0';
        return FileExist (filenameA);
    }
    WIN32_FIND_DATAW FindFileData;
    HANDLE handle = FindFirstFileW (filename, &FindFileData);
    if (handle != INVALID_HANDLE_VALUE) {
        FindClose (handle);
        return TRUE;
    }
    else
        return FALSE;
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find out if runtime is checked build   *  
*                                                                      *
\**********************************************************************/
BOOL IsDebugBuildEE ()
{
    static int DebugVersionDll = -1;
    if (DebugVersionDll == -1)
    {
        if (GetAddressOf (offset_class_Global_Variables, 
            offset_member_Global_Variables::g_DbgEnabled) == 0)
            DebugVersionDll = 0;
        else
            DebugVersionDll = 1;
    }    
    return DebugVersionDll == 1;
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find out if runtime is server build    *  
*                                                                      *
\**********************************************************************/
BOOL IsServerBuild ()
{
    return GetEEFlavor () == MSCORSVR;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find out if a dll is bbt-ized          *  
*                                                                      *
\**********************************************************************/
BOOL IsRetailBuild (size_t base)
{
    IMAGE_DOS_HEADER DosHeader;
    if (g_ExtData->ReadVirtual(base, &DosHeader, sizeof(DosHeader), NULL) != S_OK)
        return FALSE;
    IMAGE_NT_HEADERS32 Header32;
    if (g_ExtData->ReadVirtual(base + DosHeader.e_lfanew, &Header32, sizeof(Header32), NULL) != S_OK)
        return FALSE;
    // If there is no COMHeader, this can not be managed code.
    if (Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress == 0)
        return FALSE;

    size_t debugDirAddr = base + Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
    size_t nSize = Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
    IMAGE_DEBUG_DIRECTORY debugDir;
    size_t nbytes = 0;
    while (nbytes < nSize) {
        if (g_ExtData->ReadVirtual(debugDirAddr+nbytes, &debugDir, sizeof(debugDir), NULL) != S_OK)
            return FALSE;
        if (debugDir.Type == 0xA) {
            return TRUE;
        }
        nbytes += sizeof(debugDir);
    }
    return FALSE;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to read memory from the debugee's         *  
*    address space.  If the initial read fails, it attempts to read    *
*    only up to the edge of the page containing "offset".              *
*                                                                      *
\**********************************************************************/
BOOL SafeReadMemory (ULONG_PTR offset, PVOID lpBuffer, ULONG_PTR cb,
                     PULONG lpcbBytesRead)
{
    BOOL bRet = FALSE;

    bRet = SUCCEEDED(g_ExtData->ReadVirtual(offset, lpBuffer, cb,
                                            lpcbBytesRead));
    
    if (!bRet)
    {
        cb   = NextOSPageAddress(offset) - offset;
        bRet = SUCCEEDED(g_ExtData->ReadVirtual(offset, lpBuffer, cb,
                                                lpcbBytesRead));
    }
    return bRet;
}

size_t OSPageSize ()
{
    static ULONG pageSize = 0;
    if (pageSize == 0)
        g_ExtControl->GetPageSize(&pageSize);

    return pageSize;
}

size_t NextOSPageAddress (size_t addr)
{

    return (addr+OSPageSize())&(~(OSPageSize()-1));
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to get the address of MethodDesc          *  
*    given an ip address                                               *
*                                                                      *
\**********************************************************************/
// @todo - The following static was moved to file global to avoid the VC7
//         compiler problem with statics in functions containing trys.
//         When the next VC7 LKG comes out, these can be returned to the function
static DWORD_PTR pJMIT = 0;
// jitType: 1 for normal JIT generated code, 2 for EJIT, 0 for unknown
void IP2MethodDesc (DWORD_PTR IP, DWORD_PTR &methodDesc, JitType &jitType,
                    DWORD_PTR &gcinfoAddr)
{
    jitType = UNKNOWN;
    DWORD_PTR dwAddrString;
    methodDesc = 0;
    gcinfoAddr = 0;
    if (EEManager == NULL)
    {
        dwAddrString = GetAddressOf (offset_class_ExecutionManager, 
          offset_member_ExecutionManager::m_RangeTree);

        move(EEManager, dwAddrString);
    }
    RangeSection RS = {0};

    DWORD_PTR RSAddr = EEManager;
    while (RSAddr)
    {
        if (IsInterrupt())
            return;
        DWORD_PTR dwAddr = RSAddr;
        RS.Fill (dwAddr);
        if (IP < RS.LowAddress)
            RSAddr = RS.pleft;
        else if (IP > RS.HighAddress)
            RSAddr = RS.pright;
        else
            break;
    }
    
    if (RSAddr == 0)
    {
        return;
    }

    DWORD_PTR JitMan = RS.pjit;

    DWORD_PTR vtbl;
    move (vtbl, JitMan);
    jitType = GetJitType (vtbl);
    
    // for EEJitManager
    if (jitType == JIT)
    {
        dwAddrString = JitMan + sizeof(DWORD_PTR)*7;
        DWORD_PTR HeapListAddr;
        move (HeapListAddr, dwAddrString);
        HeapList Hp;
        move (Hp, HeapListAddr);
        DWORD_PTR pCHdr = 0;
        while (1)
        {
            if (IsInterrupt())
                return;
            if (Hp.startAddress < IP && Hp.endAddress >= IP)
            {
                DWORD_PTR codeHead;
                FindHeader(Hp.pHdrMap, IP-Hp.mapBase, codeHead);
                if (codeHead == 0)
                {
                    dprintf ("fail in FindHeader\n");
                    return;
                }
                pCHdr = codeHead + Hp.mapBase;
                break;
            }
            if (Hp.hpNext == 0)
                break;
            move (Hp, Hp.hpNext);
        }
        if (pCHdr == 0)
        {
            return;
        }
        pCHdr += 2*sizeof(PVOID);
        move (methodDesc, pCHdr);

        MethodDesc vMD;
        DWORD_PTR dwAddr = methodDesc;
        vMD.Fill (dwAddr);
        dwAddr = vMD.m_CodeOrIL;

        // for EJit and Profiler, m_CodeOrIL has the address of a stub
        unsigned char ch;
        move (ch, dwAddr);
        if (ch == 0xe9)
        {
            int offsetValue;
            move (offsetValue, dwAddr + 1);
            dwAddr = dwAddr + 5 + offsetValue;
        }
        dwAddr = dwAddr - 3*sizeof(void*);
        move(gcinfoAddr, dwAddr);
    }
    else if (jitType == EJIT)
    {
        // First see if IP is the stub address

        if (pJMIT == 0)
            pJMIT = GetAddressOf (offset_class_EconoJitManager, 
                offset_member_EconoJitManager::m_JittedMethodInfoHdr);


        DWORD_PTR vJMIT;
        // static for pJMIT moved to file static
        move (vJMIT, pJMIT);
#define PAGE_SIZE 0x1000
#define JMIT_BLOCK_SIZE PAGE_SIZE           // size of individual blocks of JMITs that are chained together                     
        while (vJMIT)
        {
            if (IsInterrupt())
                return;
            if (IP >= vJMIT && IP < vJMIT + JMIT_BLOCK_SIZE)
            {
                DWORD_PTR u1 = IP + 8;
                DWORD_PTR MD;
                move (u1, u1);
                if (u1 & 1)
                    MD = u1 & ~1;
                else
                    move (MD, u1);
                methodDesc = MD;
                return;
            }
            move (vJMIT, vJMIT);
        }
        
        signed low, mid, high;
        low = 0;
        static DWORD_PTR m_PcToMdMap_len = 0;
        static DWORD_PTR m_PcToMdMap = 0;
        if (m_PcToMdMap_len == 0)
        {
            m_PcToMdMap_len =
                GetAddressOf (offset_class_EconoJitManager, 
                  offset_member_EconoJitManager::m_PcToMdMap_len);

            m_PcToMdMap =
                GetAddressOf (offset_class_EconoJitManager, 
                  offset_member_EconoJitManager::m_PcToMdMap);

        }
        DWORD_PTR v_m_PcToMdMap_len;
        DWORD_PTR v_m_PcToMdMap;
        move (v_m_PcToMdMap_len, m_PcToMdMap_len);
        move (v_m_PcToMdMap, m_PcToMdMap);

        typedef struct {
            MethodDesc*     pMD;
            BYTE*           pCodeEnd;
        } PCToMDMap;
        high = (int)((v_m_PcToMdMap_len/ sizeof(PCToMDMap)) - 1);
        PCToMDMap vPCToMDMap;
        
        while (low < high) {
            if (IsInterrupt())
                return;
            mid = (low+high)/2;
            move (vPCToMDMap, v_m_PcToMdMap+mid*sizeof(PCToMDMap));
            if ( (unsigned) vPCToMDMap.pCodeEnd < IP ) {
                low = mid+1;
            }
            else {
                high = mid;
            }
        }
        move (vPCToMDMap, v_m_PcToMdMap+low*sizeof(PCToMDMap));
        methodDesc =  (DWORD_PTR)vPCToMDMap.pMD;
    }
    else if (jitType == PJIT)
    {
        DWORD_PTR codeHead;
        FindHeader (RS.ptable, IP-RS.LowAddress, codeHead);
        DWORD_PTR pCHdr = codeHead + RS.LowAddress;
        CORCOMPILE_METHOD_HEADER head;
        head.Fill(pCHdr);
        methodDesc = (DWORD_PTR)head.methodDesc;
        gcinfoAddr = (DWORD_PTR)head.gcInfo;
    }
    return;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Gets the JitManager for the IP, returning NULL if there is none.  *
*                                                                      *
\**********************************************************************/
void FindJitMan(DWORD_PTR IP, JitMan &jitMan)
{
    DWORD_PTR dwAddrString;

    if (EEManager == NULL)
    {
        dwAddrString = GetAddressOf (offset_class_ExecutionManager, 
          offset_member_ExecutionManager::m_RangeTree);

        move(EEManager, dwAddrString);
    }

    RangeSection RS = {0};

    DWORD_PTR RSAddr = EEManager;
    while (RSAddr)
    {
        if (IsInterrupt())
            return;
        DWORD_PTR dwAddr = RSAddr;
        RS.Fill (dwAddr);
        if (IP < RS.LowAddress)
            RSAddr = RS.pleft;
        else if (IP > RS.HighAddress)
            RSAddr = RS.pright;
        else
            break;
    }

    if (RSAddr == 0)
        return;

    DWORD_PTR vtbl;
    move (vtbl, RS.pjit);

    jitMan.m_jitType = GetJitType (vtbl);
    jitMan.m_RS = RS;
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Get the offset of curIP relative to the beginning of a MD method  *
*    considering if we JMP to the body of MD from m_CodeOrIL,        *  
*    e.g.  EJIT or Profiler                                            *
*                                                                      *
\**********************************************************************/
void GetMDIPOffset (DWORD_PTR curIP, MethodDesc *pMD, ULONG64 &offset)
{
    DWORD_PTR IPBegin = pMD->m_CodeOrIL;
    GetCalleeSite (pMD->m_CodeOrIL, IPBegin);
    
    // If we have ECall, Array ECall, special method
    int mdType = (pMD->m_wFlags & mdcClassification)
        >> mdcClassificationShift;
    if (mdType == mcECall || mdType == mcArray || mdType == mcEEImpl)
    {
        offset = -1;
        return;
    }
    
    CodeInfo infoHdr;
    CodeInfoForMethodDesc (*pMD, infoHdr);

    offset = curIP - IPBegin;
    if (!(curIP >= IPBegin && offset <= infoHdr.methodSize))
        offset = -1;
}

#define NPDW  (sizeof(DWORD)*2)
#define ADDR2POS(x) ((x) >> 5)
#define ADDR2OFFS(x) ((((x)&0x1f)>> 2)+1)
#define POS2SHIFTCOUNT(x) (28 - (((x)%NPDW)<< 2))
#define POSOFF2ADDR(pos, of) (((pos) << 5) + (((of)-1)<< 2))

void FindHeader(DWORD_PTR pMap, DWORD_PTR addr, DWORD_PTR &codeHead)
{
    DWORD_PTR tmp;

    DWORD_PTR startPos = ADDR2POS(addr);    // align to 32byte buckets
                                            // ( == index into the array of nibbles)
    codeHead = 0;
    DWORD_PTR offset = ADDR2OFFS(addr);     // this is the offset inside the bucket + 1


    pMap += (startPos/NPDW)*sizeof(DWORD*);        // points to the proper DWORD of the map
                                    // get DWORD and shift down our nibble

    move (tmp, pMap);
    tmp = tmp >> POS2SHIFTCOUNT(startPos);


    // don't allow equality in the next check (tmp&0xf == offset)
    // there are code blocks that terminate with a call instruction
    // (like call throwobject), i.e. their return address is
    // right behind the code block. If the memory manager allocates
    // heap blocks w/o gaps, we could find the next header in such
    // cases. Therefore we exclude the first DWORD of the header
    // from our search, but since we call this function for code
    // anyway (which starts at the end of the header) this is not
    // a problem.
    if ((tmp&0xf) && ((tmp&0xf) < offset) )
    {
        codeHead = POSOFF2ADDR(startPos, tmp&0xf);
        return;
    }

    // is there a header in the remainder of the DWORD ?
    tmp = tmp >> 4;

    if (tmp)
    {
        startPos--;
        while (!(tmp&0xf))
        {
            if (IsInterrupt())
                return;
            tmp = tmp >> 4;
            startPos--;
        }
        codeHead = POSOFF2ADDR(startPos, tmp&0xf);
        return;
    }

    // we skipped the remainder of the DWORD,
    // so we must set startPos to the highest position of
    // previous DWORD

    startPos = (startPos/NPDW) * NPDW - 1;

    // skip "headerless" DWORDS

    pMap -= sizeof(DWORD*);
    move (tmp, pMap);
    while (!tmp)
    {
        if (IsInterrupt())
            return;
        startPos -= NPDW;
        pMap -= sizeof(DWORD*);
        move (tmp, pMap);
    }
    
    while (!(tmp&0xf))
    {
        if (IsInterrupt())
            return;
        tmp = tmp >> 4;
        startPos--;
    }

    codeHead = POSOFF2ADDR(startPos, tmp&0xf);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to print a string beginning at strAddr.   *  
*    If buffer is non-NULL, print to buffer; Otherwise to screen.
*    If bWCHAR is true, treat the memory contents as WCHAR.            *
*    If length is not -1, it specifies the number of CHAR/WCHAR to be  *
*    read; Otherwise the string length is determined by NULL char.     *
*                                                                      *
\**********************************************************************/
// if buffer is not NULL, always convert to WCHAR
void PrintString (DWORD_PTR strAddr, BOOL bWCHAR, DWORD_PTR length, WCHAR *buffer)
{
    if (buffer)
        buffer[0] = L'\0';
    DWORD len = 0;
    char name[256];
    DWORD totallen = 0;
    int gap;
    if (bWCHAR)
    {
        gap = 2;
        if (length != -1)
            length *= 2;
    }
    else
    {
        gap = 1;
    }
    while (1)
    {
        if (IsInterrupt())
            return;
        ULONG readLen = 256;
        if (IsInterrupt())
            return;
        if (!SafeReadMemory ((ULONG_PTR)strAddr + totallen, name, readLen,
                             &readLen))
            return;
            
        // move might return
        // move (name, (BYTE*)strAddr + totallen);
        if (length == -1)
        {
            for (len = 0; len <= 256u-gap; len += gap)
                if (name[len] == '\0' && (!bWCHAR || name[len+1] == '\0'))
                    break;
        }
        else
            len = 256;
        if (len == 256)
        {
            len -= gap;
            for (int n = 0; n < gap; n ++)
                name[255-n] = '\0';
        }
        if (bWCHAR)
        {
            if (buffer)
            {
                wcscat (buffer, (WCHAR*)name);
            }
            else
                dprintf ("%S", name);
        }
        else
        {
            if (buffer)
            {
                WCHAR temp[256];
                for (int n = 0; name[n] != '\0'; n ++)
                    temp[n] = name[n];
                temp[n] = L'\0';
                wcscat (buffer, temp);
            }
            else
                dprintf ("%s", name);
        }
        totallen += len;
        if (length != -1)
        {
            if (totallen >= length)
            {
                break;
            }
        }
        else if (len < 255 || totallen > 1024)
        {
            break;
        }
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the module name given a method    *  
*    table.  The name is stored in StringData.                         *
*                                                                      *
\**********************************************************************/
void FileNameForMT (MethodTable *pMT, WCHAR *fileName)
{
    fileName[0] = L'\0';
    DWORD_PTR addr = (DWORD_PTR)pMT->m_pModule;
    Module vModule;
    vModule.Fill (addr);
    FileNameForModule (&vModule, fileName);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the address of Methodtable for    *  
*    a given MethodDesc.                                               *
*                                                                      *
\**********************************************************************/
void GetMethodTable(DWORD_PTR MDAddr, DWORD_PTR &methodTable)
{
    DWORD_PTR mdc;
    GetMDChunk(MDAddr, mdc);
    move (methodTable, mdc);
}

void GetMDChunk(DWORD_PTR MDAddr, DWORD_PTR &mdChunk)
{
    DWORD_PTR pMT = MDAddr + MD_IndexOffset();
    char ch;
    move (ch, pMT);
    mdChunk = MDAddr + (ch * MethodDesc::ALIGNMENT) + MD_SkewOffset();
}

void DisplayDataMember (FieldDesc* pFD, DWORD_PTR dwAddr, BOOL fAlign=TRUE)
{
    if (dwAddr > 0)
    {
        DWORD_PTR dwTmp = dwAddr;
        if (gElementTypeInfo[pFD->m_type] != -1)
        {
            union Value
            {
                char ch;
                short Short;
                DWORD_PTR ptr;
                int Int;
                unsigned int UInt;
                __int64 Int64;
                unsigned __int64 UInt64;
                float Float;
                double Double;
            } value;

            moveBlock (value, dwTmp, gElementTypeInfo[pFD->m_type]);
            switch (pFD->m_type) 
            {
                case ELEMENT_TYPE_I1:
                    if (fAlign)
                        dprintf ("%8d", value.ch);
                    else
                        dprintf ("%d", value.ch);
                    break;
                case ELEMENT_TYPE_I2:
                    if (fAlign)
                        dprintf ("%8d", value.Short);
                    else
                        dprintf ("%d", value.Short);
                    break;
                case ELEMENT_TYPE_I4:
                case ELEMENT_TYPE_I:
                    if (fAlign)
                        dprintf ("%8d", value.Int);
                    else
                        dprintf ("%d", value.Int);
                    break;
                case ELEMENT_TYPE_I8:
                    dprintf ("%I64d", value.Int64);
                    break;
                case ELEMENT_TYPE_U1:
                case ELEMENT_TYPE_BOOLEAN:
                    if (fAlign)
                        dprintf ("%8u", value.ch);
                    else
                        dprintf ("%u", value.ch);
                    break;
                case ELEMENT_TYPE_U2:
                    if (fAlign)
                        dprintf ("%8u", value.Short);
                    else
                        dprintf ("%u", value.Short);
                    break;
                case ELEMENT_TYPE_U4:
                case ELEMENT_TYPE_U:
                    if (fAlign)
                        dprintf ("%8u", value.UInt);
                    else
                        dprintf ("%u", value.UInt);
                    break;
                case ELEMENT_TYPE_U8:
                    dprintf ("%I64u", value.UInt64);
                    break;
                case ELEMENT_TYPE_R4:
                    dprintf ("%f", value.Float);
                    break;
                // case ELEMENT_TYPE_R:
                case ELEMENT_TYPE_R8:
                    dprintf ("%f", value.Double);
                    break;
                case ELEMENT_TYPE_CHAR:
                    if (fAlign)
                        dprintf ("%8x", value.Short);
                    else
                        dprintf ("%x", value.Short);
                    break;
                default:
                    dprintf ("%p", (ULONG64)value.ptr);
                    break;
            }
        }
        else
        {
            dprintf ("start at %p", (ULONG64)dwTmp);
        }
    }
    else
        dprintf ("%8s", " ");
}

void DisplaySharedStatic (FieldDesc *pFD, int offset)
{
    int numDomain;
    DWORD_PTR *domainList = NULL;
    GetDomainList (domainList, numDomain);
    ToDestroy des0 ((void**)&domainList);
    AppDomain v_AppDomain;

    dprintf ("    >> Domain:Value");
    // Skip the SystemDomain and SharedDomain
    for (int i = 2; i < numDomain; i ++)
    {
        DWORD_PTR dwAddr = domainList[i];
        if (dwAddr == 0) {
            continue;
        }
        v_AppDomain.Fill (dwAddr);
        dwAddr = (DWORD_PTR)v_AppDomain.m_sDomainLocalBlock.m_pSlots;
        if (dwAddr == 0)
            continue;
        dwAddr += offset;
        
        if (safemove (dwAddr, dwAddr) == 0)
            continue;
        if ((dwAddr&1) == 0) {
            // We have not initialized this yet.
            dprintf (" %p:NotInit ", (ULONG64)domainList[i]);
            continue;
        }
        else if (dwAddr & 2) {
            // We have not initialized this yet.
            dprintf (" %p:FailInit", (ULONG64)domainList[i]);
            continue;
        }
        dwAddr &= ~3;
        dwAddr += pFD->m_dwOffset;
        if (pFD->m_type == ELEMENT_TYPE_CLASS
            || pFD->m_type == ELEMENT_TYPE_VALUETYPE)
        {
            if (safemove (dwAddr, dwAddr) == 0)
                continue;
        }
        if (dwAddr == 0)
        {
            // We have not initialized this yet.
            dprintf (" %p:UnInit2 ", (ULONG64)domainList[i]);
            continue;
        }
        dprintf (" %p:", (ULONG64)domainList[i]);
        DisplayDataMember (pFD, dwAddr, FALSE);
    }
    dprintf (" <<\n");
}

void DisplayContextStatic (FieldDesc *pFD, int offset, BOOL fIsShared)
{
    int numDomain;
    DWORD_PTR *domainList = NULL;
    GetDomainList (domainList, numDomain);
    ToDestroy des0 ((void**)&domainList);
    AppDomain vAppDomain;
    Context vContext;
    
    dprintf ("    >> Domain:Value");
    for (int i = 0; i < numDomain; i ++)
    {
        DWORD_PTR dwAddr = domainList[i];
        if (dwAddr == 0) {
            continue;
        }
        vAppDomain.Fill (dwAddr);
        if (vAppDomain.m_pDefaultContext == 0)
            continue;
        dwAddr = (DWORD_PTR)vAppDomain.m_pDefaultContext;
        vContext.Fill (dwAddr);
        
        if (fIsShared)
            dwAddr = (DWORD_PTR)vContext.m_pSharedStaticData;
        else
            dwAddr = (DWORD_PTR)vContext.m_pUnsharedStaticData;
        if (dwAddr == 0)
            continue;
        dwAddr += offsetof(STATIC_DATA, dataPtr);
        dwAddr += offset;
        if (safemove (dwAddr, dwAddr) == 0)
            continue;
        if (dwAddr == 0)
            // We have not initialized this yet.
            continue;
        
        dwAddr += pFD->m_dwOffset;
        if (pFD->m_type == ELEMENT_TYPE_CLASS
            || pFD->m_type == ELEMENT_TYPE_VALUETYPE)
        {
            if (safemove (dwAddr, dwAddr) == 0)
                continue;
        }
        if (dwAddr == 0)
            // We have not initialized this yet.
            continue;
        dprintf (" %p:", (ULONG64)domainList[i]);
        DisplayDataMember (pFD, dwAddr, FALSE);
    }
    dprintf (" <<\n");
}

void DisplayThreadStatic (FieldDesc *pFD, int offset, BOOL fIsShared)
{
    int numThread;
    DWORD_PTR *threadList = NULL;
    GetThreadList (threadList, numThread);
    ToDestroy des0 ((void**)&threadList);
    Thread vThread;

    dprintf ("    >> Thread:Value");
    for (int i = 0; i < numThread; i ++)
    {
        DWORD_PTR dwAddr = threadList[i];
        vThread.Fill (dwAddr);
        if (vThread.m_ThreadId == 0)
            continue;
        
        if (fIsShared)
            dwAddr = (DWORD_PTR)vThread.m_pSharedStaticData;
        else
            dwAddr = (DWORD_PTR)vThread.m_pUnsharedStaticData;
        if (dwAddr == 0)
            continue;
        dwAddr += offsetof(STATIC_DATA, dataPtr);
        dwAddr += offset;
        if (safemove (dwAddr, dwAddr) == 0)
            continue;
        if (dwAddr == 0)
            // We have not initialized this yet.
            continue;
        
        dwAddr += pFD->m_dwOffset;
        if (pFD->m_type == ELEMENT_TYPE_CLASS
            || pFD->m_type == ELEMENT_TYPE_VALUETYPE)
        {
            if (safemove (dwAddr, dwAddr) == 0)
                continue;
        }
        if (dwAddr == 0)
            // We have not initialized this yet.
            continue;
        dprintf (" %x:", vThread.m_ThreadId);
        DisplayDataMember (pFD, dwAddr, FALSE);
    }
    dprintf (" <<\n");
}

char *ElementTypeName (unsigned type)
{
    switch (type) {
    case ELEMENT_TYPE_PTR:
        return "PTR";
        break;
    case ELEMENT_TYPE_BYREF:
        return "BYREF";
        break;
    case ELEMENT_TYPE_VALUETYPE:
        return "VALUETYPE";
        break;
    case ELEMENT_TYPE_CLASS:
        return "CLASS";
        break;
    case ELEMENT_TYPE_VAR:
        return "VAR";
        break;
    case ELEMENT_TYPE_ARRAY:
        return "ARRAY";
        break;
    case ELEMENT_TYPE_VALUEARRAY:
        return "VALUEARRAY";
        break;
    case ELEMENT_TYPE_R:
        return "Native Real";
        break;
    case ELEMENT_TYPE_FNPTR:
        return "FNPTR";
        break;
    case ELEMENT_TYPE_SZARRAY:
        return "SZARRAY";
        break;
    case ELEMENT_TYPE_GENERICARRAY:
        return "GENERICARRAY";
        break;
    default:
        if (CorElementTypeName[type] == NULL) {
            return "";
        }
        return CorElementTypeName[type];
        break;
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump all fields of a managed object.   *  
*    pEECls specifies the type of object.                              *
*    dwStartAddr specifies the beginning memory address.               *
*    bFirst is used to avoid printing header everytime.                *
*                                                                      *
\**********************************************************************/
void DisplayFields (EEClass *pEECls, DWORD_PTR dwStartAddr, BOOL bFirst)
{
    static DWORD numInstanceFields = 0;
    if (bFirst)
    {
        dprintf ("%8s %8s %8s %20s %10s %8s %s\n", "MT", "Field",
                 "Offset", "Type", "Attr", "Value", "Name");
        numInstanceFields = 0;
    }
    
    if (pEECls->m_pParentClass)
    {
        EEClass vEEClass;
        DWORD_PTR dwAddr = (DWORD_PTR)pEECls->m_pParentClass;
        vEEClass.Fill (dwAddr);
        if (!CallStatus)
            return;
        DisplayFields (&vEEClass, dwStartAddr, FALSE);
    }
    DWORD numStaticFields = 0;

    DWORD_PTR dwAddr = (DWORD_PTR)pEECls->m_pFieldDescList;
    FieldDesc vFieldDesc;

    // Get the module name
    WCHAR fileName[MAX_PATH];
    MethodTable vMethTable;
    DWORD_PTR dwTmp = (DWORD_PTR)pEECls->m_pMethodTable;
    vMethTable.Fill (dwTmp);
    BOOL fIsShared = vMethTable.m_wFlags & MethodTable::enum_flag_SharedAssembly;
    FileNameForMT (&vMethTable, fileName);
    while (numInstanceFields < pEECls->m_wNumInstanceFields
           || numStaticFields < pEECls->m_wNumStaticFields)
    {
        if (IsInterrupt())
            return;
        vFieldDesc.Fill (dwAddr);
        if (vFieldDesc.m_type >= ELEMENT_TYPE_MAX)
        {
            dprintf ("something is bad\n");
            return;
        }
        dprintf ("%p %8x %8x ",
                 ((ULONG64)vFieldDesc.m_pMTOfEnclosingClass & ~0x3),
                 TokenFromRid(vFieldDesc.m_mb, mdtFieldDef),
                 vFieldDesc.m_dwOffset+
                 (((vFieldDesc.m_isThreadLocal || vFieldDesc.m_isContextLocal || fIsShared)
                  && vFieldDesc.m_isStatic)?0:sizeof(BaseObject)));
        dprintf ("%20s ", ElementTypeName(vFieldDesc.m_type));
        if (vFieldDesc.m_isStatic && (vFieldDesc.m_isThreadLocal || vFieldDesc.m_isContextLocal))
        {
            numStaticFields ++;
            if (fIsShared)
                dprintf ("Shared ");
            
            NameForToken (fileName, TokenFromRid(vFieldDesc.m_mb, mdtFieldDef), g_mdName, false);
            dprintf (" %S\n", g_mdName);
            
            if (vFieldDesc.m_isThreadLocal)
                DisplayThreadStatic(&vFieldDesc,
                                    pEECls->m_wThreadStaticOffset,
                                    fIsShared);
            else if (vFieldDesc.m_isContextLocal)
                DisplayContextStatic(&vFieldDesc,
                                     pEECls->m_wContextStaticOffset,
                                     fIsShared);
            continue;
        }
        else if (vFieldDesc.m_isStatic)
        {
            numStaticFields ++;
            if (fIsShared)
            {
                dprintf ("%10s %8s", "shared", "static");
                Module vModule;
                DWORD_PTR dwAddrTmp = (DWORD_PTR)vMethTable.m_pModule;
                vModule.Fill (dwAddrTmp);
                int offset = vModule.m_dwBaseClassIndex;
                EEClass vEEClass;
                dwAddrTmp = (DWORD_PTR)vMethTable.m_pEEClass;
                vEEClass.Fill (dwAddrTmp);
                offset += RidFromToken(vEEClass.m_cl) - 1;
                offset *= 4;
                NameForToken (fileName, TokenFromRid(vFieldDesc.m_mb, mdtFieldDef), g_mdName, false);
                dprintf (" %S\n", g_mdName);
                DisplaySharedStatic (&vFieldDesc, offset);
                continue;
            }
            else
            {
                dprintf ("%10s", "static");
                DWORD_PTR dwTmp = (DWORD_PTR)vFieldDesc.m_pMTOfEnclosingClass
                    + vMethTable.size() - sizeof (SLOT*)
                    + vFieldDesc.m_dwOffset;
                // Get the handle address
                move (dwTmp, dwTmp);
                if (vFieldDesc.m_type == ELEMENT_TYPE_VALUETYPE
                    || vFieldDesc.m_type == ELEMENT_TYPE_CLASS)
                    // get the object the handle pointing to
                    move (dwTmp, dwTmp);
                dprintf (" %p", (ULONG64)dwTmp);
            }
        }
        else
        {
            numInstanceFields ++;
            dprintf ("%10s ", "instance");
            if (dwStartAddr > 0)
            {
                DWORD_PTR dwTmp = dwStartAddr + vFieldDesc.m_dwOffset
                    + sizeof(BaseObject);
                DisplayDataMember (&vFieldDesc, dwTmp);
            }
            else
                dprintf (" %8s", " ");
        }
        NameForToken (fileName, TokenFromRid(vFieldDesc.m_mb, mdtFieldDef), g_mdName, false);
        dprintf (" %S\n", g_mdName);
    }
    
    return;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the file name given a Module.     *  
*                                                                      *
\**********************************************************************/
void FileNameForModule (Module *pModule, WCHAR *fileName)
{
    DWORD_PTR dwAddr = (DWORD_PTR)pModule->m_file;
    if (dwAddr == 0)
        dwAddr = (DWORD_PTR)pModule->m_zapFile;
    PEFile vPEFile;
    vPEFile.Fill (dwAddr);
    if (vPEFile.m_wszSourceFile[0] != L'\0') {
        MatchDllsName (vPEFile.m_wszSourceFile, fileName, (ULONG64)vPEFile.m_base);
    }
    else
        FileNameForHandle (vPEFile.m_base, fileName);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the file name given a file        *  
*    handle.                                                           *
*                                                                      *
\**********************************************************************/
void FileNameForHandle (HANDLE handle, WCHAR *fileName)
{
    fileName[0] = L'\0';
    if (((UINT_PTR)handle & CORHANDLE_MASK) != 0)
    {
        handle = (HANDLE)(((UINT_PTR)handle) & ~CORHANDLE_MASK);
        DWORD_PTR addr = (DWORD_PTR)(((PBYTE) handle) - sizeof(LPSTR*));
        DWORD_PTR first;
        move (first, addr);
        if (first == 0)
        {
            return;
        }
        DWORD length = (DWORD)(((UINT_PTR) handle - (UINT_PTR)first) - sizeof(LPSTR*));
        char name[4*MAX_PATH+1];
        if (length > 4*MAX_PATH+1)
            length = 4*MAX_PATH+1;
        moveBlock (name, first, length);
        MultiByteToWideChar(CP_UTF8, 0, name, length, fileName, MAX_PATH);
    }
    else
    {
        DllsName ((INT_PTR)handle, fileName);
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a class loader.   *  
*                                                                      *
\**********************************************************************/
void ClassLoaderInfo (ClassLoader *pClsLoader)
{
    dprintf ("  Module Name\n");
    DWORD_PTR dwModuleAddr = (DWORD_PTR)pClsLoader->m_pHeadModule;
    while (dwModuleAddr)
    {
        if (IsInterrupt())
            return;
        Module vModule;
        dprintf ("%p ", (ULONG64)dwModuleAddr);
        vModule.Fill (dwModuleAddr);
        if (!CallStatus)
            return;
        WCHAR fileName[MAX_PATH+1];
        FileNameForModule (&vModule, fileName);
        dprintf ("%ws\n", fileName[0] ? fileName : L"Unknown Module");
        dwModuleAddr = (DWORD_PTR)vModule.m_pNextModule;
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of an assembly.      *  
*                                                                      *
\**********************************************************************/
void AssemblyInfo (Assembly *pAssembly)
{
    dprintf ("ClassLoader: %p\n", (ULONG64)pAssembly->m_pClassLoader);
    ClassLoader vClsLoader;
    DWORD_PTR dwAddr = (DWORD_PTR)pAssembly->m_pClassLoader;
    vClsLoader.Fill (dwAddr);
    ClassLoaderInfo (&vClsLoader);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a domain.         *  
*                                                                      *
\**********************************************************************/
void DomainInfo (AppDomain *pDomain)
{
    dprintf ("LowFrequencyHeap: %p\n", (ULONG64)pDomain->m_pLowFrequencyHeap);
    dprintf ("HighFrequencyHeap: %p\n", (ULONG64)pDomain->m_pHighFrequencyHeap);
    dprintf ("StubHeap: %p\n", (ULONG64)pDomain->m_pStubHeap);
    dprintf ("Name: ");
    if (pDomain->m_pwzFriendlyName)
    {
        PrintString((DWORD_PTR)pDomain->m_pwzFriendlyName, TRUE);
        dprintf ("\n");
    }
    else
        dprintf ("None\n");

    DWORD_PTR dwAssemAddr;

    DWORD n;
    Assembly vAssembly;
    for (n = 0; n < pDomain->m_Assemblies.m_count; n ++)
    {
        if (IsInterrupt())
            return;
        dwAssemAddr = (DWORD_PTR)pDomain->m_Assemblies.Get(n);
        dprintf ("Assembly: %p  ", (ULONG64)dwAssemAddr);
        vAssembly.Fill (dwAssemAddr);
        if (!CallStatus)
            return;
        AssemblyInfo (&vAssembly);
    }
    
    // dprintf ("AsyncPool: %8x\n", pDomain->m_pAsyncPool);
    //dprintf ("RootAssembly: %8x\n", pDomain->m_pRootAssembly);
    //dprintf ("Sibling: %8x\n", pDomain->m_pSibling);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to dump the contents of a shared domain.  *  
*                                                                      *
\**********************************************************************/
void SharedDomainInfo (DWORD_PTR DomainAddr)
{
    SharedDomain v_SharedDomain;
    v_SharedDomain.Fill (DomainAddr);
    
    dprintf ("LowFrequencyHeap: %p\n", (ULONG64)v_SharedDomain.m_pLowFrequencyHeap);
    dprintf ("HighFrequencyHeap: %p\n", (ULONG64)v_SharedDomain.m_pHighFrequencyHeap);
    dprintf ("StubHeap: %p\n", (ULONG64)v_SharedDomain.m_pStubHeap);

    Assembly vAssembly;
    DWORD_PTR dwAssemblyAddr;

    Bucket vBucket;
    size_t nBucket;
    DWORD_PTR dwBucketAddr = (DWORD_PTR)v_SharedDomain.m_assemblyMap.m_rgBuckets;
    vBucket.Fill (dwBucketAddr);
    nBucket = vBucket.m_rgKeys[0];

    while (nBucket > 0) {
        if (IsInterrupt())
            return;
        vBucket.Fill (dwBucketAddr);
        if (!CallStatus) {
            return;
        }
        for (int i = 0; i < 4; i ++) {
            dwAssemblyAddr = vBucket.m_rgValues[i];
            if (dwAssemblyAddr) {
                dprintf ("Assembly: %p  ", (ULONG64)dwAssemblyAddr);
                vAssembly.Fill (dwAssemblyAddr);
                if (!CallStatus) {
                    continue;
                }
                AssemblyInfo (&vAssembly);
            }
        }
        nBucket --;
    }
}


void EEDllPath::DisplayPath ()
{
    if (path[0][0] == L'\0') {
        ExtOut ("No path is set for managed dll\n");
        return;
    }

    ExtOut ("Path to Managed Dll:\n");
    EEDllPath *ptr = this;
    while (ptr) {
        for (int i = 0; i < NumEEDllPath; i ++) {
            if (ptr->path[i][0] == '\0') {
                return;
            }
            ExtOut ("%S\n", ptr->path[i]);
        }
        ptr = ptr->next;
    }
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a MethodDesc using    *  
*    metadata API.                                                     *
*                                                                      *
\**********************************************************************/
void NameForMD (MethodDesc *pMD, WCHAR *mdName)
{
    mdName[0] = L'\0';
    if (CallStatus)
    {
        if (IsDebugBuildEE())
        {
            DWORD_PTR EEClassAddr;
            move (EEClassAddr, pMD->m_pDebugEEClass);
            PrintString (EEClassAddr, FALSE, -1, mdName);
            wcscat (mdName, L".");
            static WCHAR name[2048];
            name[0] = L'\0';
            PrintString ((DWORD_PTR)pMD->m_pszDebugMethodName,
                         FALSE, -1, name);
            wcscat (mdName, name);
        }
        else
        {
            DWORD_PTR pMT = pMD->m_MTAddr;
                    
            MethodTable MT;
            MT.Fill (pMT);
            if (CallStatus)
            {
                WCHAR StringData[MAX_PATH+1];
                FileNameForMT (&MT, StringData);
                NameForToken(StringData,
                             (pMD->m_dwToken & 0x00ffffff)|0x06000000,
                             mdName);
            }
        }
    }
}

void NameForObject (DWORD_PTR ObjAddr, WCHAR *mdName)
{
    mdName[0] = L'\0';
    DWORD_PTR dwAddr;
    move(dwAddr, ObjAddr);
    NameForMT (dwAddr,mdName);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a MethodTable using   *  
*    metadata API.                                                     *
*                                                                      *
\**********************************************************************/
void NameForMT (DWORD_PTR MTAddr, WCHAR *mdName)
{
    MethodTable vMethTable;
    vMethTable.Fill (MTAddr);
    NameForMT (vMethTable, mdName);
}


void NameForMT (MethodTable &vMethTable, WCHAR *mdName)
{
    mdName[0] = L'\0';
    EEClass eeclass;
    DWORD_PTR dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
    eeclass.Fill (dwAddr);
    if (!CallStatus)
        return;
    if (eeclass.m_cl == 0x2000000)
    {
        ArrayClass vArray;
        dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
        vArray.Fill (dwAddr);
        dwAddr = (DWORD_PTR) vArray.m_ElementTypeHnd.m_asMT;
        size_t count = 1;
        while (dwAddr&2) {
            if (IsInterrupt())
                return;
            ParamTypeDesc param;
            DWORD_PTR dwTDAddr = dwAddr&~2;
            param.Fill(dwTDAddr);
            dwAddr = (DWORD_PTR)param.m_Arg.m_asMT;
            count ++;
        }
        NameForMT (dwAddr, mdName);
        while (count > 0) {
            count --;
            wcscat (mdName, L"[]");
        }
    }
    else
    {
        WCHAR fileName[MAX_PATH+1];
        FileNameForMT (&vMethTable, fileName);
        NameForToken (fileName, eeclass.m_cl, mdName);
    }
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the name of a EEClass using       *  
*    metadata API.                                                     *
*                                                                      *
\**********************************************************************/
void NameForEEClass (EEClass *pEECls, WCHAR *mdName)
{
    mdName[0] = L'\0';
    if (IsDebugBuildEE())
    {
        PrintString ((DWORD_PTR)pEECls->m_szDebugClassName,
                     FALSE, -1, mdName);
    }
    else
    {
        NameForMT ((DWORD_PTR)pEECls->m_pMethodTable, mdName);
    }
}


/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if str2 is a substring of str1 and str1 and str2      *  
*    share the same file path.
*                                                                      *
\**********************************************************************/
BOOL IsSameModuleName (const char *str1, const char *str2)
{
    if (strlen (str1) < strlen (str2))
        return FALSE;
    const char *ptr1 = str1 + strlen(str1)-1;
    const char *ptr2 = str2 + strlen(str2)-1;
    while (ptr2 >= str2)
    {
        if (tolower(*ptr1) != tolower(*ptr2))
            return FALSE;
        ptr2 --;
        ptr1 --;
    }
    if (ptr1 >= str1 && *ptr1 != '\\' && *ptr1 != ':')
        return FALSE;
    return TRUE;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if value is the address of a MethodTable.             *  
*    We verify that MethodTable and EEClass are right.
*                                                                      *
\**********************************************************************/
BOOL IsMethodTable (DWORD_PTR value)
{
    if (value == MTForFreeObject()) {
        return TRUE;
    }

    static int MT_EEClassOffset = 0x7fffffff;
    if (MT_EEClassOffset == 0x7fffffff)
    {
        MT_EEClassOffset = 
          MethodTable::GetFieldOffset(offset_member_MethodTable::m_pEEClass);

    }
    
    static int EEClass_MTOffset = 0x7fffffff;
    if (EEClass_MTOffset == 0x7fffffff)
    {
        EEClass_MTOffset = 
          EEClass::GetFieldOffset (offset_member_EEClass::m_pMethodTable);

    }
    
    DWORD_PTR dwAddr;
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(value+MT_EEClassOffset), &dwAddr, sizeof(dwAddr), NULL))) {
        return FALSE;
    }
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(dwAddr+EEClass_MTOffset), &dwAddr, sizeof(dwAddr), NULL))) {
        return FALSE;
    }
    if (dwAddr != value) {
        return FALSE;
    }
    return TRUE;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if value is the address of an EEClass.                *  
*    We verify that MethodTable and EEClass are right.
*                                                                      *
\**********************************************************************/
BOOL IsEEClass (DWORD_PTR value)
{
    static int MT_EEClassOffset = 0x7fffffff;
    if (MT_EEClassOffset == 0x7fffffff)
    {
        MT_EEClassOffset = 
            MethodTable::GetFieldOffset(offset_member_MethodTable::m_pEEClass);
    }
    
    static int EEClass_MTOffset = 0x7fffffff;
    if (EEClass_MTOffset == 0x7fffffff)
    {
        EEClass_MTOffset = 
            EEClass::GetFieldOffset (offset_member_EEClass::m_pMethodTable);
    }
    
    DWORD_PTR dwAddr;
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(value+EEClass_MTOffset), &dwAddr, sizeof(dwAddr), NULL))) {
        return FALSE;
    }
    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(dwAddr+MT_EEClassOffset), &dwAddr, sizeof(dwAddr), NULL))) {
        return FALSE;
    }
    if (dwAddr != value) {
        return FALSE;
    }
    return TRUE;
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if value is the address of a MethodDesc.              *  
*    We verify that MethodTable and EEClass are right.
*                                                                      *
\**********************************************************************/
BOOL IsMethodDesc (DWORD_PTR value)
{
    DWORD_PTR dwAddr;
    GetMethodTable(value, dwAddr);
    if (dwAddr == 0)
        return FALSE;
    return IsMethodTable (dwAddr);
}


BOOL IsObject (size_t obj)
{
    DWORD_PTR dwAddr;

    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(obj), &dwAddr, sizeof(dwAddr), NULL))) {
        return 0;
    }
    
    dwAddr &= ~3;
    return IsMethodTable (dwAddr);
}


void AddToModuleList(DWORD_PTR * &moduleList, int &numModule, int &maxList,
                     DWORD_PTR dwModuleAddr)
{
    int i;
    for (i = 0; i < numModule; i ++)
    {
        if (moduleList[i] == dwModuleAddr)
            break;
    }
    if (i == numModule)
    {
        moduleList[numModule] = dwModuleAddr;
        numModule ++;
        if (numModule == maxList)
        {
            DWORD_PTR *list = (DWORD_PTR *)
                malloc (2*maxList * sizeof(PVOID));
            if (list == NULL)
            {
                numModule = 0;
                ControlC = 1;
            }
            memcpy (list, moduleList, maxList * sizeof(PVOID));
            free (moduleList);
            moduleList = list;
            maxList *= 2;
        }
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the list of Module address given the name of the Module.     *  
*                                                                      *
\**********************************************************************/
void ModuleFromName(DWORD_PTR * &moduleList, LPSTR mName, int &numModule)
{
    moduleList = NULL;
    numModule = 0;
    // List all domain
    int numDomain;
    DWORD_PTR *domainList = NULL;
    GetDomainList (domainList, numDomain);
    if (numDomain == 0)
        return;

    int maxList = numDomain;
    moduleList = (DWORD_PTR *) malloc (maxList * sizeof(PVOID));
    if (moduleList == NULL)
        return;
    
    WCHAR StringData[MAX_PATH+1];
    char fileName[sizeof(StringData)/2];
    // Search all domains to find a module
    for (int n = 0; n < numDomain; n++)
    {
        if (IsInterrupt())
            break;

        int i;
        for (i = 0; i < n; i ++)
        {
            if (IsInterrupt())
                break;
            if (domainList[i] == domainList[n])
                break;
        }
        if (i < n)
        {
            continue;
        }

        if (n == 1)  
        {
            //Shared Domain.
            SharedDomain v_SharedDomain;
            DWORD_PTR dwAddr = domainList[1];
            v_SharedDomain.Fill (dwAddr);
            
            DWORD_PTR dwModuleAddr;

            SharedDomain::DLSRecord vDLSRecord;
            DWORD_PTR dwDLSAddr = (DWORD_PTR)v_SharedDomain.m_pDLSRecords;
            for (size_t k = 0; k < v_SharedDomain.m_cDLSRecords; k ++)
            {
                if (IsInterrupt())
                    return;
                move (vDLSRecord, dwDLSAddr);
                dwDLSAddr += sizeof (vDLSRecord);
                Module vModule;
                dwModuleAddr = (DWORD_PTR)vDLSRecord.pModule;
                vModule.Fill (dwModuleAddr);
                if (!CallStatus)
                {
                    continue;
                }
                FileNameForModule (&vModule, StringData);
                for (int m = 0; StringData[m] != L'\0'; m ++)
                {
                    fileName[m] = (char)StringData[m];
                }
                fileName[m] = '\0';
                if (IsSameModuleName (fileName, mName))
                {
                    AddToModuleList (moduleList, numModule, maxList,
                                     dwModuleAddr);
                }
            }
            continue;
        }
        
        AppDomain v_AppDomain;
        DWORD_PTR dwAddr = domainList[n];
        if (dwAddr == 0) {
            continue;
        }
        v_AppDomain.Fill (dwAddr);
        if (!CallStatus) {
            continue;
        }
        DWORD nAssem;
        Assembly vAssembly;
        for (nAssem = 0;
             nAssem < v_AppDomain.m_Assemblies.m_count;
             nAssem ++)
        {
            if (IsInterrupt())
                break;

            DWORD_PTR dwAssemAddr =
                (DWORD_PTR)v_AppDomain.m_Assemblies.Get(nAssem);
            vAssembly.Fill (dwAssemAddr);
            ClassLoader vClsLoader;
            DWORD_PTR dwLoaderAddr = (DWORD_PTR)vAssembly.m_pClassLoader;
            vClsLoader.Fill (dwLoaderAddr);
            
            DWORD_PTR dwModuleAddr = (DWORD_PTR)vClsLoader.m_pHeadModule;
            while (dwModuleAddr)
            {
                if (IsInterrupt())
                    break;
                DWORD_PTR dwAddr = dwModuleAddr;
                Module vModule;
                vModule.Fill (dwAddr);
                FileNameForModule (&vModule, StringData);
                for (int m = 0; StringData[m] != L'\0'; m ++)
                {
                    fileName[m] = (char)StringData[m];
                }
                fileName[m] = '\0';
                if (IsSameModuleName (fileName, mName))
                {
                    AddToModuleList (moduleList, numModule, maxList,
                                     dwModuleAddr);
                }
                
                dwModuleAddr = (DWORD_PTR)vModule.m_pNextModule;
            }
        }
    }
    
    if (domainList)
        free (domainList);
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the EE data given a name.                                    *  
*                                                                      *
\**********************************************************************/
void GetInfoFromName(Module &vModule, const char* name)
{
    WCHAR StringData[MAX_PATH+1];
    FileNameForModule (&vModule, StringData);
    if (StringData[0] == 0)
        return;
    
    IMetaDataImport* pImport = MDImportForModule (StringData);
    if (pImport == 0)
        return;

    static WCHAR wszName[MAX_CLASSNAME_LENGTH];
    size_t n;
    size_t length = strlen (name);
    for (n = 0; n <= length; n ++)
        wszName[n] = name[n];

    mdTypeDef cl;
    
    // @todo:  Handle Nested classes correctly.
    if (SUCCEEDED (pImport->FindTypeDefByName (wszName, mdTokenNil, &cl)))
    {
        GetInfoFromModule(vModule, cl);
        return;
    }
    
    // See if it is a method
    WCHAR *pwzMethod;
    if ((pwzMethod = wcsrchr(wszName, L'.')) == NULL)
        return;

    if (pwzMethod[-1] == L'.')
        pwzMethod --;
    pwzMethod[0] = L'\0';
    pwzMethod ++;
    
    // @todo:  Handle Nested classes correctly.
    if (SUCCEEDED (pImport->FindTypeDefByName (wszName, mdTokenNil, &cl)))
    {
        mdMethodDef token;
        ULONG cTokens;
        HCORENUM henum = NULL;
        BOOL fStatus = FALSE;
        while (SUCCEEDED (pImport->EnumMethodsWithName (&henum, cl, pwzMethod,
                                                     &token, 1, &cTokens))
               && cTokens == 1)
        {
            fStatus = TRUE;
            GetInfoFromModule (vModule, token);
            dprintf ("-----------------------\n");
        }
        if (fStatus)
            return;

        // is Member?
        henum = NULL;
        if (SUCCEEDED (pImport->EnumMembersWithName (&henum, cl, pwzMethod,
                                                     &token, 1, &cTokens))
            && cTokens == 1)
        {
            dprintf ("Member (mdToken token) of\n");
            GetInfoFromModule (vModule, cl);
            return;
        }

        // is Field?
        henum = NULL;
        if (SUCCEEDED (pImport->EnumFieldsWithName (&henum, cl, pwzMethod,
                                                     &token, 1, &cTokens))
            && cTokens == 1)
        {
            dprintf ("Field (mdToken token) of\n");
            GetInfoFromModule (vModule, cl);
            return;
        }
    }
}

/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the EE data given a token.                                   *  
*                                                                      *
\**********************************************************************/
void GetInfoFromModule (Module &vModule, ULONG token, DWORD_PTR *ret)
{
    LookupMap_t *pMap;
    LookupMap_t vMap;
    DWORD rid = token & 0xffffff;
    switch (token & 0xff000000)
    {
        case mdtMethodDef:
            pMap = &vModule.m_MethodDefToDescMap;
            break;
        case mdtTypeDef:
            pMap = &vModule.m_TypeDefToMethodTableMap;
            break;
        case mdtTypeRef:
            pMap = &vModule.m_TypeRefToMethodTableMap;
            break;
        default:
            dprintf ("not supported\n");
            return;
            break;
    }
    
    DWORD_PTR addr = 0;
    while (1)
    {
        if (IsInterrupt())
            return;
        if (rid < pMap->dwMaxIndex)
        {
            addr = (DWORD_PTR)(pMap->pTable)+rid*sizeof(PVOID);
            move (addr, addr);
            break;
        }
        if (pMap->pNext == NULL)
            break;
        DWORD_PTR dwAddr = (DWORD_PTR)pMap->pNext;
        vMap.Fill(dwAddr);
        pMap = &vMap;
    }
    if (ret != NULL)
    {
        *ret = addr;
        return;
    }
    
    if (addr == 0)
    {
        dprintf ("not created yet\n");
        return;
    }

    switch (token & 0xff000000)
    {
        case mdtMethodDef:
            {
                dprintf ("MethodDesc: %x\n", addr);
                MethodDesc vMD;
                vMD.Fill (addr);
                CQuickBytes fullname;
                FullNameForMD (&vMD, &fullname);
                dprintf ("Name: %S\n", (WCHAR*)fullname.Ptr());
                break;
            }
        case mdtTypeDef:
        case mdtTypeRef:
            dprintf ("MethodTable: %p\n", (ULONG64)addr);
            MethodTable vMethTable;
            vMethTable.Fill (addr);
            addr = (DWORD_PTR)vMethTable.m_pEEClass;
            dprintf ("EEClass: %p\n", (ULONG64)addr);
            EEClass eeclass;
            eeclass.Fill (addr);
            WCHAR fileName[MAX_PATH+1];
            FileNameForMT (&vMethTable, fileName);
            NameForToken(fileName, eeclass.m_cl, g_mdName);
            dprintf ("Name: %S\n", g_mdName);
            break;
        default:
            break;
    }
    return;
}

DWORD_PTR MTForObject()
{
    static DWORD_PTR dwMT = 0;
    
    if (dwMT == 0)
    {
        DWORD_PTR dwMTAddr =
            GetAddressOf (offset_class_Global_Variables, 
              offset_member_Global_Variables::g_pObjectClass);
        SafeReadMemory (dwMTAddr, &dwMT, sizeof(dwMT), NULL);
        dwMT = dwMT & ~3;
    }
    return dwMT;
}

DWORD_PTR MTForFreeObject()
{
    static DWORD_PTR dwMT = 0;
    
    if (dwMT == 0)
    {
        DWORD_PTR dwMTAddr =
            GetAddressOf (offset_class_Global_Variables, 
                offset_member_Global_Variables::g_pFreeObjectMethodTable);

        SafeReadMemory (dwMTAddr, &dwMT, sizeof(dwMT), NULL);
        dwMT = dwMT & ~3;
    }
    return dwMT;
}

DWORD_PTR MTForString()
{
    static DWORD_PTR dwMT = 0;
    
    if (dwMT == 0)
    {
        DWORD_PTR dwMTAddr =
            GetAddressOf (offset_class_Global_Variables, 
                offset_member_Global_Variables::g_pStringClass);

        SafeReadMemory (dwMTAddr, &dwMT, sizeof(dwMT), NULL);
        dwMT = dwMT & ~3;
    }
    return dwMT;
}

DWORD_PTR MTForFreeObj()
{
    static DWORD_PTR dwMT = 0;
    
    if (dwMT == 0)
    {
        DWORD_PTR dwMTAddr =
            GetAddressOf (offset_class_Global_Variables, 
                offset_member_Global_Variables::g_pFreeObjectMethodTable);

        SafeReadMemory (dwMTAddr, &dwMT, 4, NULL);
        dwMT = dwMT & ~3;
    }
    return dwMT;
}

int MD_IndexOffset ()
{
    static int MD_IndexOffset = 0x7fffffff;
    if (MD_IndexOffset == 0x7fffffff)
    {
#ifndef UNDER_CE
        MD_IndexOffset = StubCallInstrs::GetFieldOffset(
          offset_member_StubCallInstrs::m_chunkIndex) 
          - METHOD_PREPAD;

#endif
    }
    return MD_IndexOffset;
}

int MD_SkewOffset ()
{
    static int MD_SkewOffset = 0x7fffffff;
    if (MD_SkewOffset == 0x7fffffff)
    {
#ifndef UNDER_CE
        MD_SkewOffset = MethodDescChunk::size();
#endif
        MD_SkewOffset = - (METHOD_PREPAD + MD_SkewOffset);
    }
    return MD_SkewOffset;
}

void DumpMDInfo(DWORD_PTR dwStartAddr, BOOL fStackTraceFormat)
{
    if (!IsMethodDesc (dwStartAddr))
    {
        dprintf ("%p is not a MethodDesc\n", (ULONG64)dwStartAddr);
        return;
    }
    
    MethodDesc *pMD = NULL;
    pMD = (MethodDesc*)_alloca(sizeof(MethodDesc));
    if (!pMD)
        return;

    DWORD_PTR tmpAddr = dwStartAddr;
    pMD->Fill (tmpAddr);
    if (!CallStatus)
        return;

    DWORD_PTR pMT = pMD->m_MTAddr;
    if (pMT == 0)
    {
        dprintf ("Fail in GetMethodTable\n");
        return;
    }

    CQuickBytes fullname;
    FullNameForMD (pMD,&fullname);

    if (!fStackTraceFormat)
    {
        dprintf ("Method Name : %S\n", (WCHAR*)fullname.Ptr());
        if (IsDebugBuildEE())
        {
            dprintf ("Class : %x\r\n",pMD->m_pDebugEEClass);
            dprintf ("MethodTable %x\n", (DWORD_PTR)pMT);
            dprintf ("mdToken: %08x\n",
                     (pMD->m_dwToken & 0x00ffffff)|0x06000000);
        }
        else
        {
            MethodTable MT;
            ULONG_PTR dwAddr = pMT;
            MT.Fill(dwAddr);

            if (((pMD->m_wFlags & 0x10) == 0)
                && (MT.m_wFlags & MethodTable::enum_flag_Array) != 0)
            {
                DWORD_PTR *addr = (DWORD_PTR*)((BYTE*)pMD + MethodDesc::size()
                                               + 3*sizeof(DWORD_PTR));
                DWORD_PTR pname = *addr;

                PrintString (pname);
                dprintf ("\n");
                dprintf ("MethodTable %x\n", (DWORD_PTR)pMT);
            }
            else
            {
                dprintf ("MethodTable %x\n", (DWORD_PTR)pMT);
                dprintf ("Module: %x\n", (DWORD_PTR)MT.m_pModule);
                dprintf ("mdToken: %08x",
                         (pMD->m_dwToken & 0x00ffffff)|0x06000000);
                WCHAR fileName[MAX_PATH+1];
                FileNameForMT (&MT, fileName);
                dprintf( " (%ws)\n",
                         fileName[0] ? fileName : L"Unknown Module" );
                /*
                  dprintf (" (Do !dlls -c %08x to find the module name)\n",
                  module_addr);
                */
            }
        }


        dprintf("Flags : %x\r\n",pMD->m_wFlags);
        if (pMD->m_CodeOrIL & METHOD_IS_IL_FLAG)
        {
            dprintf("IL RVA : %p\r\n",pMD->m_CodeOrIL);
        }
        else
        {
            dprintf("Method VA : %p\r\n",(pMD->m_CodeOrIL & ~METHOD_IS_IL_FLAG));
        }
    }
    else
        dprintf ("%S\n", (WCHAR*)fullname.Ptr());
}

void GetDomainList (DWORD_PTR *&domainList, int &numDomain)
{
    static DWORD_PTR    p_SystemDomainAddr = 0;
    static DWORD_PTR    p_SharedDomainAddr = 0;
    DWORD_PTR           domainListAddr;
    ArrayList           appDomainIndexList;

    numDomain = 0;

    //
    // do not cache this value, it may change
    //
    domainListAddr = GetAddressOf (offset_class_SystemDomain,
      offset_member_SystemDomain::m_appDomainIndexList);


    appDomainIndexList.Fill(domainListAddr);
    if (!CallStatus)
    {
        return;
    }

    domainList = (DWORD_PTR*) malloc ((appDomainIndexList.m_count + 2)*sizeof(PVOID));
    if (domainList == NULL)
    {
        return;
    }

    if (p_SystemDomainAddr == 0)
        p_SystemDomainAddr = GetAddressOf (offset_class_SystemDomain,
          offset_member_SystemDomain::m_pSystemDomain);


    if (!SafeReadMemory(p_SystemDomainAddr, &domainList[numDomain],
                        sizeof(PVOID), NULL))
    {
        return;
    }
    numDomain ++;
    
    if (0 == p_SharedDomainAddr)
        p_SharedDomainAddr = GetAddressOf (offset_class_SharedDomain,
          offset_member_SharedDomain::m_pSharedDomain);


    if (p_SharedDomainAddr)
    {
        if (!SafeReadMemory(p_SharedDomainAddr, &domainList[numDomain],
                            sizeof(PVOID), NULL))
        {
            return;
        }
        numDomain ++;
    }

    unsigned int i;
    for (i = 0; i < appDomainIndexList.m_count; i ++)
    {
        if (IsInterrupt())
            break;

        domainList[numDomain] = (DWORD_PTR)appDomainIndexList.Get(i);
        numDomain++;
    }
}

//@TODO: get rid of this function and remove all calls to it
BOOL HaveToFixThreadSymbol()
{
    return FALSE;
#if 0
    static ULONG bFixBadSymbols=-1;
    if (bFixBadSymbols != -1) {
        return bFixBadSymbols;
    }
    if (bFixBadSymbols == -1) {
        if (!IsServerBuild ()) {
            bFixBadSymbols = 0;
        }
        else
        {
            if (alloc_context::GetFieldOffset (
                offset_member_alloc_context::alloc_heap) == -1)
                bFixBadSymbols = 1;
            else
            {
                bFixBadSymbols = 0;
                ExtOut ("Remove this hack.  Symbol problem has been fixed.\n");
            }
        }
    }

    return bFixBadSymbols;
#endif
}


void GetThreadList (DWORD_PTR *&threadList, int &numThread)
{
    numThread = 0;
    static DWORD_PTR p_g_pThreadStore = 0;
    if (p_g_pThreadStore == 0)
        p_g_pThreadStore = GetAddressOf (offset_class_Global_Variables, 
            offset_member_Global_Variables::g_pThreadStore);

    DWORD_PTR g_pThreadStore;
    move (g_pThreadStore, p_g_pThreadStore);
    ThreadStore vThreadStore;
    DWORD_PTR dwAddr = g_pThreadStore;
    vThreadStore.Fill (dwAddr);
    if (!CallStatus)
    {
        dprintf ("Fail to fill ThreadStore\n");
        return;
    }

    threadList = (DWORD_PTR*) malloc (vThreadStore.m_ThreadCount * sizeof(PVOID));
    
    if (threadList == NULL)
        return;
    
    DWORD_PTR pHead = (DWORD_PTR)vThreadStore.m_ThreadList.m_pHead;
    DWORD_PTR pNext;
    move (pNext, pHead);
    DWORD_PTR pThread;

#ifndef UNDER_CE
    static int offset_LinkStore = -1;
    if (offset_LinkStore == -1)
    {
        offset_LinkStore = 
            Thread::GetFieldOffset(offset_member_Thread::m_LinkStore);

    }
#endif

    BOOL bFixThreadSymbol = HaveToFixThreadSymbol ();
    while (1)
    {
        if (IsInterrupt())
            return;
#ifndef UNDER_CE
        if (offset_LinkStore != -1)
        {
            pThread = pNext - offset_LinkStore;
        }
        else
#endif
            return;

        threadList[numThread++] = pThread - (bFixThreadSymbol?8:0);

        move (pNext, pNext);
        if (pNext == 0)
            return;
    }

}

JitType GetJitType (DWORD_PTR Jit_vtbl)
{
    // Decide EEJitManager/EconoJitManager
    static DWORD_PTR EEJitManager_vtbl = 0;
    static DWORD_PTR EconoJitManager_vtbl = 0;
    static DWORD_PTR MNativeJitManager_vtbl = 0;

    if (EEJitManager_vtbl == 0)
    {
        EEJitManager_vtbl =
            GetEEJitManager ();

    }
    if (EconoJitManager_vtbl == 0)
    {
        EconoJitManager_vtbl =
            GetEconoJitManager ();

    }
    if (MNativeJitManager_vtbl == 0)
    {
        MNativeJitManager_vtbl =
            GetMNativeJitManager ();
    }

    if (Jit_vtbl == EEJitManager_vtbl)
        return JIT;
    else if (Jit_vtbl == EconoJitManager_vtbl)
        return EJIT;
    else if (Jit_vtbl == MNativeJitManager_vtbl)
        return PJIT;
    else
        return UNKNOWN;
}

void ReloadSymbolWithLineInfo()
{
    static BOOL bLoadSymbol = FALSE;
    if (!bLoadSymbol)
    {
        ULONG Options;
        g_ExtSymbols->GetSymbolOptions (&Options);
        if (!(Options & SYMOPT_LOAD_LINES))
        {
            g_ExtSymbols->AddSymbolOptions (SYMOPT_LOAD_LINES);
            g_ExtSymbols->Reload ("/f mscoree.dll");
            EEFLAVOR flavor = GetEEFlavor ();
            if (flavor == MSCORWKS)
                g_ExtSymbols->Reload ("/f mscorwks.dll");
            else if (flavor == MSCORSVR)
                g_ExtSymbols->Reload ("/f mscorsvr.dll");
            //g_ExtSymbols->Reload ("mscorjit.dll");
        }
        
        // reload mscoree.pdb and mscorjit.pdb to get line info
        bLoadSymbol = TRUE;
    }
}

#ifndef _WIN64
// Return 1 if the function is our stub
// Return MethodDesc if the function is managed
// Otherwise return 0
size_t FunctionType (size_t EIP)
{
    ULONG64 base = 0;
    if (SUCCEEDED(g_ExtSymbols->GetModuleByOffset(EIP, 0, NULL, &base)) && base != 0)
    {
        IMAGE_DOS_HEADER DosHeader;
        if (g_ExtData->ReadVirtual(base, &DosHeader, sizeof(DosHeader), NULL) != S_OK)
            return 0;
        IMAGE_NT_HEADERS32 Header32;
        if (g_ExtData->ReadVirtual(base + DosHeader.e_lfanew, &Header32, sizeof(Header32), NULL) != S_OK)
            return 0;
        // If there is no COMHeader, this can not be managed code.
        if (Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress == 0)
            return 0;
        
        IMAGE_COR20_HEADER ComPlusHeader;
        if (g_ExtData->ReadVirtual(base + Header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress,
                                   &ComPlusHeader, sizeof(ComPlusHeader), NULL))
            return 0;
        
        // If there is no Precompiled image info, it can not be prejit code
        if (ComPlusHeader.ManagedNativeHeader.VirtualAddress == 0) {
            return 0;
        }
    }

    JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (EIP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc) {
        return methodDesc;
    }
    else
        return 1;

#if 0
    IMAGE_COR20_HEADER *pComPlusHeader = (IMAGE_COR20_HEADER*) (pImage + 
                pHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress);

    if (pComPlusHeader->MajorRuntimeVersion < 2) {
        return 0;
    }

    // For IJW, if EIP is within the code range
    if (EIP >= base+pHeader32->OptionalHeader.BaseOfCode 
        && EIP < base+pHeader32->OptionalHeader.BaseOfCode+pHeader32->OptionalHeader.SizeOfCode) {
        return TRUE;
    }

    return FALSE;
#endif
}
#endif

void GetVersionString (WCHAR *version)
{
    static WCHAR buffer[100] = L"\0";
    version[0] = L'\0';

    if (buffer[0] == L'\0') {
        memset (buffer, 0, sizeof(buffer));
        DWORD_PTR dwStartAddr = GetAddressOf (offset_class_Global_Variables, 
            offset_member_Global_Variables::g_Version);

        if (dwStartAddr)
        {
            PrintString (dwStartAddr, FALSE, -1, buffer);
        }
        else
        {
            char code[100];
            dwStartAddr =
                GetAddressOf (offset_class_SystemNative, 
                    offset_member_SystemNative::GetVersionString);


            if (dwStartAddr == 0)
                return;
            move (code, dwStartAddr);
            int n;
            for (n = 0; n < 100; n ++)
            {
                if (code[n] == 0x68)
                {
                    DWORD_PTR verAddr;
                    memcpy (&verAddr, &code[n+1], sizeof(DWORD_PTR));
                    PrintString (verAddr, TRUE, -1, buffer);
                    break;
                }
            }
        }
    }

    if (buffer[0] != L'\0') {
        wcsncpy (version, buffer, wcslen(buffer)+1);
    }
}


size_t ObjectSize (DWORD_PTR obj)
{
    DWORD_PTR dwAddr;

    if (FAILED(g_ExtData->ReadVirtual((ULONG64)(obj), &dwAddr, sizeof(dwAddr), NULL))) {
        return 0;
    }
    
    dwAddr &= ~3;
    if (!IsMethodTable (dwAddr)) {
        return 0;
    }

    MethodTable vMT;
    vMT.Fill (dwAddr);
    size_t size = vMT.m_BaseSize;
    if (vMT.m_ComponentSize > 0)
    {
        DWORD_PTR pComp = obj + 4;
        DWORD_PTR numComp;
        moveN (numComp, pComp);
        size += vMT.m_ComponentSize*numComp;
    }
    size = Align (size);
    return size;
}

void StringObjectContent (size_t obj, BOOL fLiteral, const int length)
{
    DWORD_PTR dwAddr = obj + 2*sizeof(PVOID);
    DWORD_PTR count;
    move (count, dwAddr);
    count &= (sizeof(PVOID)==4)?0xfffffff:0xfffffffffffffff;
    if (length != -1 && (int)count > length) {
        count = length;
    }
    dwAddr += sizeof(PVOID);
    
    WCHAR buffer[256];
    WCHAR out[512];
    while (count) {
        DWORD toRead = 255;
        if (count < toRead) {
            toRead = count;
        }
        ULONG bytesRead;
        if (FAILED(g_ExtData->ReadVirtual(dwAddr, buffer, toRead*sizeof(WCHAR), &bytesRead)) || bytesRead == 0) {
            break;
        }
        DWORD wcharsRead = bytesRead/2;
        buffer[wcharsRead] = L'\0';
        
        if (!fLiteral) {
            ExtOut ("%S", buffer);
        }
        else
        {
            ULONG j,k=0;
            for (j = 0; j < wcharsRead; j ++) {
                if (iswprint (buffer[j])) {
                    out[k] = buffer[j];
                    k ++;
                }
                else
                {
                    out[k++] = L'\\';
                    switch (buffer[j]) {
                    case L'\n':
                        out[k++] = L'n';
                        break;
                    case L'\0':
                        out[k++] = L'0';
                        break;
                    case L'\t':
                        out[k++] = L't';
                        break;
                    case L'\v':
                        out[k++] = L'v';
                        break;
                    case L'\b':
                        out[k++] = L'b';
                        break;
                    case L'\r':
                        out[k++] = L'r';
                        break;
                    case L'\f':
                        out[k++] = L'f';
                        break;
                    case L'\a':
                        out[k++] = L'a';
                        break;
                    case L'\\':
                        break;
                    case L'\?':
                        out[k++] = L'?';
                        break;
                    default:
                        out[k++] = L'?';
                        break;
                    }
                }
            }

            out[k] = L'\0';
            ExtOut ("%S", out);
        }

        count -= wcharsRead;
        dwAddr += bytesRead;
    }
}

BOOL GetValueForCMD (const char *ptr, const char *end, ARGTYPE type, size_t *value)
{
    char *last;
    if (type == COHEX) {
        *value = strtoul(ptr,&last,16);
    }
    else
        *value = strtoul(ptr,&last,10);
    if (last != end) {
        return FALSE;
    }

    return TRUE;
}

void SetValueForCMD (void *vptr, ARGTYPE type, size_t value)
{
    switch (type) {
    case COBOOL:
        *(BOOL*)vptr = value;
        break;
    case COSIZE_T:
    case COHEX:
        *(SIZE_T*)vptr = value;
        break;
    }
}

BOOL GetCMDOption(const char *string, CMDOption *option, size_t nOption,
                  CMDValue *arg, size_t maxArg, size_t *nArg)
{
    const char *end;
    const char *ptr = string;
    BOOL endofOption = FALSE;

    for (size_t n = 0; n < nOption; n ++) {
        option[n].hasSeen = FALSE;
    }
    if (nArg) {
        *nArg = 0;
    }

    while (ptr[0] != '\0') {
        if (IsInterrupt())
            return FALSE;
        
        // skip any space
        if (isspace (ptr[0])) {
            while (isspace (ptr[0]))
                ptr ++;
            continue;
        }
        end = ptr;
        while (!isspace(end[0]) && end[0] != '\0') {
            end ++;
        }

        if (ptr[0] != '-') {
            if (maxArg == 0) {
                ExtOut ("Incorrect option: %s\n", ptr);
                return FALSE;
            }
            endofOption = TRUE;
            if (*nArg >= maxArg) {
                ExtOut ("Incorrect option: %s\n", ptr);
                return FALSE;
            }
            
            size_t value;
            if (!GetValueForCMD (ptr,end,arg[*nArg].type,&value)) {
                char buffer[80];
                if (end-ptr > 79) {
                    ExtOut ("Invalid option %s\n", ptr);
                    return FALSE;
                }
                strncpy (buffer, ptr, end-ptr);
                buffer[end-ptr] = '\0';
                value = (size_t)GetExpression (buffer);
                if (value == 0) {
                    ExtOut ("Invalid option: %s\n", ptr);
                    return FALSE;
                }
            }

            SetValueForCMD (arg[*nArg].vptr, arg[*nArg].type, value);

            (*nArg) ++;
        }
        else if (endofOption) {
            ExtOut ("Wrong option: %s\n", ptr);
            return FALSE;
        }
        else {
            char buffer[80];
            if (end-ptr > 79) {
                ExtOut ("Invalid option %s\n", ptr);
                return FALSE;
            }
            strncpy (buffer, ptr, end-ptr);
            buffer[end-ptr] = '\0';
            size_t n;
            for (n = 0; n < nOption; n ++) {
                if (_stricmp (buffer, option[n].name) == 0) {
                    if (option[n].hasSeen) {
                        ExtOut ("Invalid option: option specified multiple times: %s\n", buffer);
                        return FALSE;
                    }
                    option[n].hasSeen = TRUE;
                    if (option[n].hasValue) {
                        // skip any space
                        ptr = end;
                        if (isspace (ptr[0])) {
                            while (isspace (ptr[0]))
                                ptr ++;
                        }
                        if (ptr[0] == '\0') {
                            ExtOut ("Missing value for option %s\n", buffer);
                            return FALSE;
                        }
                        end = ptr;
                        while (!isspace(end[0]) && end[0] != '\0') {
                            end ++;
                        }

                        size_t value;
                        if (!GetValueForCMD (ptr,end,option[n].type,&value)) {
                            ExtOut ("Invalid option: %s\n", ptr);
                            return FALSE;
                        }

                        SetValueForCMD (option[n].vptr,option[n].type,value);
                    }
                    else {
                        SetValueForCMD (option[n].vptr,option[n].type,TRUE);
                    }
                    break;
                }
            }
            if (n == nOption) {
                ExtOut ("Unknown option: %s\n", buffer);
                return FALSE;
            }
        }

        ptr = end;
    }
    return TRUE;
}

DWORD ComPlusAptCleanupGroupInfo(ComPlusApartmentCleanupGroup *group, BOOL bDetail)
{
    size_t count = 0;

    EEHashTableOfEEClass *pTable = &group->m_CtxCookieToContextCleanupGroupMap;
    if (pTable->m_dwNumEntries == 0) {
        return 0;
    }

    DWORD n;
    size_t dwBucketAddr;
    EEHashEntry vEntry;

    EEHashTableOfEEClass::BucketTable* pBucketTable;
    pBucketTable = ((EEHashTableOfEEClass::BucketTable*) pTable->m_pFirstBucketTable == &pTable->m_BucketTable[0]) ? 
                        &pTable->m_BucketTable[0]: 
                        &pTable->m_BucketTable[1];

    for (n = 0; n < pBucketTable->m_dwNumBuckets; n ++) {
        if (IsInterrupt())
            break;
        dwBucketAddr = (size_t)pBucketTable->m_pBuckets + n * sizeof(PVOID);
        moveN (dwBucketAddr, dwBucketAddr);
        while (dwBucketAddr) {
            if (IsInterrupt())
                break;
            DWORD_PTR dwAddr = dwBucketAddr;
            vEntry.Fill(dwAddr);
            dwAddr = (DWORD_PTR)vEntry.Data;
            ComPlusContextCleanupGroup ctxGroup;
            while (dwAddr) {
                ctxGroup.Fill (dwAddr);
                if (bDetail) {
                    for (DWORD i = 0; i < ctxGroup.m_dwNumWrappers; i++) {
                        ExtOut ("%p\n", (ULONG64)ctxGroup.m_apWrapper[i]);
                    }
                }
                count += ctxGroup.m_dwNumWrappers;
                dwAddr = (DWORD_PTR)ctxGroup.m_pNext;
            }
            dwBucketAddr = (size_t)vEntry.pNext;
        }
    }

    return count;
}

BOOL IsDebuggeeInNewState ()
{
    if (IsDumpFile()) {
        return FALSE;
    }

    if (TargetPlatform() == VER_PLATFORM_WIN32_WINDOWS)
        return TRUE;

    typedef BOOL (WINAPI *FntGetProcessTimes)(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME);
    static FntGetProcessTimes pFntGetProcessTimes = (FntGetProcessTimes)-1;
    if (pFntGetProcessTimes == (FntGetProcessTimes)-1) {
        HINSTANCE hstat = LoadLibrary ("Kernel32.dll");
        if (hstat != 0)
        {
            pFntGetProcessTimes = (FntGetProcessTimes)GetProcAddress (hstat, "GetProcessTimes");
            FreeLibrary (hstat);
        }
        else
            pFntGetProcessTimes = NULL;
    }

    if (pFntGetProcessTimes == NULL) {
        return TRUE;
    }

    static FILETIME s_KernelTime = {0,0};
    static FILETIME s_UserTime = {0,0};
    
    FILETIME CreationTime;
    FILETIME ExitTime;
    FILETIME KernelTime;
    FILETIME UserTime;

    ULONG64 value;
    if (FAILED(g_ExtSystem->GetCurrentProcessHandle(&value)))
        return 0;
    HANDLE hProcess = (HANDLE)value;
    
    if (pFntGetProcessTimes && pFntGetProcessTimes (hProcess,&CreationTime,&ExitTime,&KernelTime,&UserTime)) {
        if (s_UserTime.dwHighDateTime == 0 && s_UserTime.dwLowDateTime == 0
            && s_KernelTime.dwHighDateTime == 0 && s_KernelTime.dwLowDateTime == 0) {
            memcpy (&s_KernelTime, &KernelTime, sizeof(FILETIME));
            memcpy (&s_UserTime, &UserTime, sizeof(FILETIME));
            return FALSE;
        }
        BOOL status = FALSE;
        if (memcmp (&s_KernelTime, &KernelTime, sizeof(FILETIME))) {
            status = TRUE;
            memcpy (&s_KernelTime, &KernelTime, sizeof(FILETIME));
        }
        if (memcmp (&s_UserTime, &UserTime, sizeof(FILETIME))) {
            status = TRUE;
            memcpy (&s_UserTime, &UserTime, sizeof(FILETIME));
        }
        return status;
    }
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\utilcode.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// An empty file so that gcdump.cpp does not include the one from other
// places.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\util.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __util_h__
#define __util_h__

#include "eestructs.h"

#define MAX_CLASSNAME_LENGTH    1024

#ifdef _IA64_
#define OS_PAGE_SIZE   8192
#else
#define OS_PAGE_SIZE   4096
#endif

enum EEFLAVOR {UNKNOWNEE, MSCOREE, MSCORWKS, MSCORSVR,MSCOREND};

void FileNameForModule (Module *pModule, WCHAR *fileName);
void FileNameForHandle (HANDLE handle, WCHAR *fileName);
void FindHeader(DWORD_PTR pMap, DWORD_PTR addr, DWORD_PTR &codeHead);
void IP2MethodDesc (DWORD_PTR IP, DWORD_PTR &methodDesc, JitType &jitType,
                    DWORD_PTR &gcinfoAddr);
void GetMDIPOffset (DWORD_PTR curIP, MethodDesc *pMD, ULONG64 &offset);
char *ElementTypeName (unsigned type);
void DisplayFields (EEClass *pEECls,
                    DWORD_PTR dwStartAddr = 0, BOOL bFirst=TRUE);
void NameForToken(WCHAR* moduleName, mdTypeDef mb, WCHAR *mdName,
                  bool bClassName=true);


///////////////////////////////////////////////////////////////////////////////////////////////////
// Support for managed stack tracing
//

void FindJitMan(DWORD_PTR ip, JitMan &jitMan);

///////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef UNDER_CE
VOID
DllsName(
    ULONG_PTR addrContaining,
    WCHAR *dllName
    );
VOID
MatchDllsName (WCHAR *wname, WCHAR *dllName, ULONG64 base);
#endif

#define safemove(dst, src) \
SafeReadMemory ((ULONG_PTR) (src), &(dst), sizeof(dst), NULL)

#define safemove_ret(dst, src) \
if (safemove(dst, src) == 0)   \
    return 0;

class ToDestroy
{
public:
    ToDestroy(void **toDestroy)
        : mem(toDestroy)
    {}
    ~ToDestroy()
    {
        if (*mem)
        {
            free (*mem);
            *(DWORD_PTR**)mem = NULL;
        }
    }
private:
    void **mem;
};

template <class A>
class ToDestroyCxx
{
public:
    ToDestroyCxx(A **toDestroy)
        : mem(toDestroy)
    {}
    ~ToDestroyCxx()
    {
        if (*mem)
        {
            delete *mem;
            *mem = NULL;
        }
    }
private:
    A **mem;
};

template <class A>
class ToDestroyCxxArray
{
public:
    ToDestroyCxxArray(A **toDestroy)
        : mem(toDestroy)
    {}
    ~ToDestroyCxxArray()
    {
        if (*mem)
        {
            delete[] *mem;
            *mem = NULL;
        }
    }
private:
    A **mem;
};

struct ModuleInfo
{
    ULONG64 baseAddr;
    BOOL hasPdb;
};
extern ModuleInfo moduleInfo[];

BOOL HaveToFixThreadSymbol();
BOOL IsServerBuild ();
BOOL IsDebugBuildEE ();
BOOL IsRetailBuild (size_t base);
EEFLAVOR GetEEFlavor ();
BOOL IsDumpFile ();
BOOL SafeReadMemory (ULONG_PTR offset, PVOID lpBuffer, ULONG_PTR cb,
                     PULONG lpcbBytesRead);
void NameForMD (MethodDesc *pMD, WCHAR *mdName);
void NameForMT (DWORD_PTR MTAddr, WCHAR *mdName);
void NameForMT (MethodTable &vMethTable, WCHAR *mdName);
void NameForObject (DWORD_PTR ObjAddr, WCHAR *mdName);
void isRetAddr(DWORD_PTR retAddr, DWORD_PTR* whereCalled);
void GetMethodTable(DWORD MDAddr, DWORD_PTR &methodTable);
void GetMDChunk(DWORD_PTR MDAddr, DWORD_PTR &mdChunk);
void PrintString (DWORD_PTR strAddr, BOOL bWCHAR = FALSE, DWORD_PTR length=-1,
    WCHAR *buffer = NULL);
void NameForEEClass (EEClass *pEECls, WCHAR *mdName);
void FileNameForMT (MethodTable *pMT, WCHAR *fileName);
DWORD_PTR GetAddressOf (size_t klass, size_t member);
void* operator new(size_t, void* p);
void DomainInfo (AppDomain *pDomain);
void SharedDomainInfo (DWORD_PTR DomainAddr);
void AssemblyInfo (Assembly *pAssembly);
void ClassLoaderInfo (ClassLoader *pClsLoader);

DWORD_PTR LoaderHeapInfo (LoaderHeap *pLoaderHeap);
DWORD_PTR JitHeapInfo ();

class HeapStat
{
private:
    struct Node
    {
        DWORD_PTR MT;
        DWORD count;
        DWORD totalSize;
        Node* left;
        Node* right;
        Node ()
            : MT(0), count(0), totalSize(0), left(NULL), right(NULL)
        {
        }
    };
    Node *head;
public:
    HeapStat ()
        : head(NULL)
    {}
    void Add (DWORD_PTR aMT, DWORD aSize);
    void Sort ();
    void Print ();
    void Delete ();
private:
    void SortAdd (Node *&root, Node *entry);
    void LinearAdd (Node *&root, Node *entry);
    void ReverseLeftMost (Node *root);
};

extern HeapStat *stat;

struct DumpHeapFlags
{
    DWORD_PTR min_size;
    DWORD_PTR max_size;
    BOOL bStatOnly;
    BOOL bFixRange;
    DWORD_PTR startObject;
    DWORD_PTR endObject;
    DWORD_PTR MT;
    
    DumpHeapFlags ()
        : min_size(0), max_size(-1), bStatOnly(FALSE), bFixRange(FALSE),
          startObject(0), endObject(0), MT(0)
    {}
};

struct AllocInfo
{
    alloc_context *array;
    int num;
};

BOOL IsSameModuleName (const char *str1, const char *str2);
BOOL IsMethodDesc (DWORD_PTR value);
BOOL IsMethodTable (DWORD_PTR value);
BOOL IsEEClass (DWORD_PTR value);
BOOL IsObject (size_t obj);
void ModuleFromName(DWORD_PTR * &vModule, LPSTR mName, int &numModule);
void GetInfoFromName(Module &vModule, const char* name);
void GetInfoFromModule (Module &vModule, ULONG token, DWORD_PTR *ret=NULL);
void GCHeapInfo(gc_heap &heap, DWORD_PTR &total_size);
void GCHeapDump(gc_heap &heap, DWORD_PTR &nObj, DumpHeapFlags &flags,
                AllocInfo* pallocInfo);

void CodeInfoForMethodDesc (MethodDesc &MD, CodeInfo &infoHdr,
                            BOOL bSimple = TRUE);

DWORD_PTR MTForObject();
DWORD_PTR MTForFreeObject();
DWORD_PTR MTForString();
DWORD_PTR MTForFreeObj();

int MD_IndexOffset ();
int MD_SkewOffset ();

void DumpMDInfo(DWORD_PTR dwStartAddr, BOOL fStackTraceFormat = FALSE);
void GetDomainList (DWORD_PTR *&domainList, int &numDomain);
void GetThreadList (DWORD_PTR *&threadList, int &numThread);

void ReloadSymbolWithLineInfo();

JitType GetJitType (DWORD_PTR Jit_vtbl);

size_t FunctionType (size_t EIP);
void GetVersionString (WCHAR *version);

size_t Align (size_t nbytes);

size_t OSPageSize ();
size_t NextOSPageAddress (size_t addr);

size_t ObjectSize (DWORD_PTR obj);
void StringObjectContent (size_t obj, BOOL fLiteral=FALSE, const int length=-1);  // length=-1: dump everything in the string object.

void FindGCRoot (size_t obj);
void FindAllRootSize ();
void FindObjSize (size_t obj);

enum ARGTYPE {COBOOL,COSIZE_T,COHEX};
struct CMDOption
{
    const char* name;
    void *vptr;
    ARGTYPE type;
    BOOL hasValue;
    BOOL hasSeen;
};
struct CMDValue
{
    void *vptr;
    ARGTYPE type;
};
BOOL GetCMDOption(const char *string, CMDOption *option, size_t nOption,
                  CMDValue *arg, size_t maxArg, size_t *nArg);

DWORD ComPlusAptCleanupGroupInfo(ComPlusApartmentCleanupGroup *groupr, BOOL bDetail);

ULONG TargetPlatform();
ULONG DebuggeeType();

inline BOOL IsKernelDebugger ()
{
    return DebuggeeType() == DEBUG_CLASS_KERNEL;
}

typedef enum CorElementTypeInternal
{
    ELEMENT_TYPE_VAR_INTERNAL            = 0x13,     // a type variable VAR <U1>

    ELEMENT_TYPE_VALUEARRAY_INTERNAL     = 0x17,     // VALUEARRAY <type> <bound>

    ELEMENT_TYPE_R_INTERNAL              = 0x1A,     // native real size

    ELEMENT_TYPE_GENERICARRAY_INTERNAL   = 0x1E,     // Array with unknown rank
                                            // GZARRAY <type>

} CorElementTypeInternal;

#define ELEMENT_TYPE_VAR           ((CorElementType) ELEMENT_TYPE_VAR_INTERNAL          )
#define ELEMENT_TYPE_VALUEARRAY    ((CorElementType) ELEMENT_TYPE_VALUEARRAY_INTERNAL   )
#define ELEMENT_TYPE_R             ((CorElementType) ELEMENT_TYPE_R_INTERNAL            )
#define ELEMENT_TYPE_GENERICARRAY  ((CorElementType) ELEMENT_TYPE_GENERICARRAY_INTERNAL )

extern IMetaDataImport* MDImportForModule (WCHAR* moduleName);

//*****************************************************************************
//
// **** CQuickBytes
// This helper class is useful for cases where 90% of the time you allocate 512
// or less bytes for a data structure.  This class contains a 512 byte buffer.
// Alloc() will return a pointer to this buffer if your allocation is small
// enough, otherwise it asks the heap for a larger buffer which is freed for
// you.  No mutex locking is required for the small allocation case, making the
// code run faster, less heap fragmentation, etc...  Each instance will allocate
// 520 bytes, so use accordinly.
//
//*****************************************************************************
template <DWORD SIZE, DWORD INCREMENT> 
class CQuickBytesBase
{
public:
    CQuickBytesBase() :
        pbBuff(0),
        iSize(0),
        cbTotal(SIZE)
    { }

    void Destroy()
    {
        if (pbBuff)
        {
            free(pbBuff);
            pbBuff = 0;
        }
    }

    void *Alloc(SIZE_T iItems)
    {
        iSize = iItems;
        if (iItems <= SIZE)
        {
            cbTotal = SIZE;
            return (&rgData[0]);
        }
        else
        {
            if (pbBuff) free(pbBuff);
            pbBuff = malloc(iItems);
            cbTotal = pbBuff ? iItems : 0;
            return (pbBuff);
        }
    }

    HRESULT ReSize(SIZE_T iItems)
    {
        void *pbBuffNew;
        if (iItems <= cbTotal)
        {
            iSize = iItems;
            return NOERROR;
        }

        pbBuffNew = malloc(iItems + INCREMENT);
        if (!pbBuffNew)
            return E_OUTOFMEMORY;
        if (pbBuff) 
        {
            memcpy(pbBuffNew, pbBuff, cbTotal);
            free(pbBuff);
        }
        else
        {
            memcpy(pbBuffNew, rgData, cbTotal);
        }
        cbTotal = iItems + INCREMENT;
        iSize = iItems;
        pbBuff = pbBuffNew;
        return NOERROR;
        
    }

    operator PVOID()
    { return ((pbBuff) ? pbBuff : &rgData[0]); }

    void *Ptr()
    { return ((pbBuff) ? pbBuff : &rgData[0]); }

    SIZE_T Size()
    { return (iSize); }

    SIZE_T MaxSize()
    { return (cbTotal); }

    void Maximize()
    { 
        HRESULT hr = ReSize(MaxSize());
        _ASSERTE(hr == NOERROR);
    }

    void        *pbBuff;
    SIZE_T      iSize;              // number of bytes used
    SIZE_T      cbTotal;            // total bytes allocated in the buffer
    BYTE        rgData[SIZE];
};

#define     CQUICKBYTES_BASE_SIZE           512
#define     CQUICKBYTES_INCREMENTAL_SIZE    128

class CQuickBytesNoDtor : public CQuickBytesBase<CQUICKBYTES_BASE_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

class CQuickBytes : public CQuickBytesNoDtor
{
public:
    CQuickBytes() { }

    ~CQuickBytes()
    {
        Destroy();
    }
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE> 
class CQuickBytesNoDtorSpecifySize : public CQuickBytesBase<CQUICKBYTES_BASE_SPECIFY_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE> 
class CQuickBytesSpecifySize : public CQuickBytesNoDtorSpecifySize<CQUICKBYTES_BASE_SPECIFY_SIZE>
{
public:
    CQuickBytesSpecifySize() { }

    ~CQuickBytesSpecifySize()
    {
        Destroy();
    }
};


#define STRING_SIZE 10
class CQuickString : public CQuickBytesBase<STRING_SIZE, STRING_SIZE> 
{
public:
    CQuickString() { }

    ~CQuickString()
    {
        Destroy();
    }
    
    void *Alloc(SIZE_T iItems)
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::Alloc(iItems*sizeof(WCHAR));
    }

    HRESULT ReSize(SIZE_T iItems)
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::ReSize(iItems * sizeof(WCHAR));
    }

    SIZE_T Size()
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::Size() / sizeof(WCHAR);
    }

    SIZE_T MaxSize()
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::MaxSize() / sizeof(WCHAR);
    }

    WCHAR* String()
    {
        return (WCHAR*) Ptr();
    }

};

void FullNameForMD(MethodDesc *pMD, CQuickBytes *fullName);

BOOL IsDebuggeeInNewState ();
#endif // __util_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\tst-stackwalk.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*  STACKWALK.CPP:
 *
 */

#pragma warning(disable:4189)
#pragma warning(disable:4244) // conversion from 'unsigned int' to 'unsigned short', possible loss of data

#include <malloc.h>

#include "exts.h"
#include "util.h"
#include "eestructs.h"
#include "gcinfo.h"
#include "endian.h"

#ifdef _DEBUG
#include <assert.h>
#define _ASSERTE(a) assert(a)
#else
#define _ASSERTE(a)
#define assert(a)
#endif

/*
template <class T>
class smartPtr
{
public:
    smartPtr(DWORD_PTR remoteAddr) : m_remoteAddr(remoteAddr) { }

    T operator *()
    {
        T var;
        safemove(var, m_remoteAddr);
        return var;
    }

    T *operator&()
    {
        return (T *)m_remoteAddr;
    }

    operator++()
    {
        m_remoteAddr += sizeof(T);
    }

    operator--()
    {
        m_remoteAddr -= sizeof(T);
    }

    T *operator ()
    {
        return 
    }

protected:
    DWORD_PTR m_remoteAddr;
};
*/

Frame *g_pFrameNukeList = NULL;

void CleanupStackWalk()
{
    while (g_pFrameNukeList != NULL)
    {
        Frame *pDel = g_pFrameNukeList;
        g_pFrameNukeList = g_pFrameNukeList->m_pNukeNext;
        delete pDel;
    }
}

void UpdateJitMan(SLOT PC, IJitManager **ppIJM)
{
    static EEJitManager eejm;
    static MNativeJitManager mnjm;

    *ppIJM = NULL;

    // Get the jit manager and assign appropriate fields into crawl frame
    JitMan jitMan;
    FindJitMan(PC, jitMan);

    if (jitMan.m_RS.pjit != 0)
    {
        switch (jitMan.m_jitType)
        {
        case JIT:
            {
                DWORD_PTR pjm = jitMan.m_RS.pjit;
                eejm.Fill(pjm);

                pjm = jitMan.m_RS.pjit;
                eejm.IJitManager::Fill(pjm);

                eejm.m_jitMan = jitMan;
                *ppIJM = (IJitManager *)&eejm;
            }
            break;
        case PJIT:
            {
                DWORD_PTR pjm = jitMan.m_RS.pjit;
                mnjm.Fill(pjm);

                pjm = jitMan.m_RS.pjit;
                mnjm.IJitManager::Fill(pjm);

                mnjm.m_jitMan = jitMan;
                *ppIJM = (IJitManager *)&mnjm;
            }
            break;
        default:
            DebugBreak();
            break;
        }
    }
}

StackWalkAction Thread::StackWalkFramesEx(
                    PREGDISPLAY pRD,        // virtual register set at crawl start
                    PSTACKWALKFRAMESCALLBACK pCallback,
                    VOID *pData,
                    unsigned flags,
                    Frame *pStartFrame
                )
{
    CrawlFrame cf;
    StackWalkAction retVal = SWA_FAILED;
    Frame *pInlinedFrame = NULL;

    if (pStartFrame)
        cf.pFrame = ResolveFrame((DWORD_PTR)m_pFrame);
    else
        cf.pFrame = ResolveFrame((DWORD_PTR)m_pFrame);

    _ASSERTE(cf.pFrame != NULL);

    cf.isFirst = true;
    cf.isInterrupted = false;
    cf.hasFaulted = false;
    cf.isIPadjusted = false;

    // Currently we always do a quick unwind
    //unsigned unwindFlags = (flags & QUICKUNWIND) ? 0 : UpdateAllRegs;
    unsigned unwindFlags = 0;

    // Get the jit manager and assign appropriate fields into crawl frame
    IJitManager *pEEJM;
    UpdateJitMan(*pRD->pPC, &pEEJM);

    cf.isFrameless = pEEJM != 0;
    cf.JitManagerInstance = pEEJM;
    cf.pRD = pRD;


    // can debugger handle skipped frames?
    BOOL fHandleSkippedFrames = !(flags & HANDLESKIPPEDFRAMES);

    while (cf.isFrameless || (cf.pFrame != FRAME_TOP))
    {
        retVal = SWA_DONE;

        cf.codeManState.dwIsSet = 0;

        if (cf.isFrameless)
        {
            // This must be a JITed/managed native method
            DWORD_PTR prMD;
            JitType jitType;
            DWORD_PTR prGCInfo;
            IP2MethodDesc(*pRD->pPC, prMD, jitType, prGCInfo);

            // Get token and offset
            pEEJM->JitCode2MethodTokenAndOffset((*pRD->pPC),&(cf.methodToken),(DWORD*)&(cf.relOffset));

            // Fill method desc
            MethodDesc md;
            md.Fill(prMD);
            cf.pFunc = &md;

            EECodeInfo codeInfo;
            codeInfo.m_methodToken = cf.methodToken;
            codeInfo.m_pJM = pEEJM;
            codeInfo.m_pMD = cf.pFunc;
            //cf.methodInfo = pEEJM->GetGCInfo(&codeInfo);

            if (SWA_ABORT == pCallback(&cf, (VOID*)pData)) 
                return SWA_ABORT;

            /* Get rid of the frame (actually, it isn't really popped) */
            UnwindStackFrame(pRD,
                             prGCInfo,
                             &codeInfo,
                             unwindFlags /* | cf.GetCodeManagerFlags()*/,
                             &cf.codeManState);

            cf.isFirst = FALSE;
            cf.isInterrupted = cf.hasFaulted = cf.isIPadjusted = FALSE;

#ifdef _X86_
            /* We might have skipped past some Frames */
            /* This happens with InlinedCallFrames and if we unwound */
            /* out of a finally in managed code or for ContextTransitionFrames that are
            /* inserted into the managed call stack */
            while (cf.pFrame->m_This != FRAME_TOP && (size_t)cf.pFrame->m_This < (size_t)cf.pRD->Esp)
            {
                if (!fHandleSkippedFrames || InlinedCallFrame::FrameHasActiveCall(cf.pFrame))
                {
                    cf.GotoNextFrame();
                }
                else
                {
                    cf.codeMgrInstance = NULL;
                    cf.isFrameless     = false;

                    DWORD_PTR pMD = (DWORD_PTR) cf.pFrame->GetFunction();

                    // process that frame
                    if (pMD || !(flags&FUNCTIONSONLY))
                    {
                        MethodDesc vMD;
                        if (pMD)
                        {
                            vMD.Fill(pMD);
                            cf.pFunc = &vMD;
                        }
                        else
                            cf.pFunc = NULL;

                        if (SWA_ABORT == pCallback(&cf, (VOID*)pData)) 
                            return SWA_ABORT;
                    }

                    /* go to the next frame */
                    cf.GotoNextFrame();
                }
            }
            /* Now inspect caller (i.e. is it again in "native" code ?) */
            UpdateJitMan(*(pRD->pPC), &pEEJM);

            cf.JitManagerInstance = pEEJM;
            cf.codeMgrInstance = NULL;
            cf.isFrameless = (pEEJM != NULL);

#endif // _X86_
        }
        else
        {
            if (InlinedCallFrame::FrameHasActiveCall(cf.pFrame))
                pInlinedFrame = cf.pFrame;
            else
                pInlinedFrame = NULL;

            DWORD_PTR pMD = (DWORD_PTR) cf.pFrame->GetFunction();

            // process that frame
            /* Are we supposed to filter non-function frames? */
            if (pMD || !(flags&FUNCTIONSONLY))
            {
                MethodDesc vMD;
                if (pMD)
                {
                    vMD.Fill(pMD);
                    cf.pFunc = &vMD;
                }
                else
                    cf.pFunc = NULL;

                if (SWA_ABORT == pCallback(&cf, (VOID*)pData)) 
                    return SWA_ABORT;
            }

            // Special resumable frames make believe they are on top of the stack
            cf.isFirst = (cf.pFrame->GetFrameAttribs() & Frame::FRAME_ATTR_RESUMABLE) != 0;

            // If the frame is a subclass of ExceptionFrame,
            // then we know this is interrupted

            cf.isInterrupted = (cf.pFrame->GetFrameAttribs() & Frame::FRAME_ATTR_EXCEPTION) != 0;

            if (cf.isInterrupted)
            {
                cf.hasFaulted   = (cf.pFrame->GetFrameAttribs() & Frame::FRAME_ATTR_FAULTED) != 0;
                cf.isIPadjusted = (cf.pFrame->GetFrameAttribs() & Frame::FRAME_ATTR_OUT_OF_LINE) != 0;
            }

            SLOT adr = (SLOT)cf.pFrame->GetReturnAddress();

            if (adr)
            {
                /* is caller in managed code ? */
                UpdateJitMan(adr, &pEEJM);
                cf.JitManagerInstance = pEEJM;

                cf.codeMgrInstance = NULL;

                if ((cf.isFrameless = (pEEJM != NULL)) == true)
                {
                    cf.pFrame->UpdateRegDisplay(pRD);
                    //cf.codeMgrInstance = pEEJM->GetCodeManager(); // CHANGE, VC6.0
                }
            }

            if (!pInlinedFrame)
            {
                /* go to the next frame */
                cf.GotoNextFrame();
            }
        }
    }

    CleanupStackWalk();

    return retVal;
}

void CrawlFrame::GotoNextFrame()
{
    pFrame = pFrame->Next();
}

//#######################################################################################################################
//#######################################################################################################################
//
// UnwindStackFrame-related code
//
//#######################################################################################################################
//#######################################################################################################################

/*****************************************************************************
 *  Sizes of certain i386 instructions which are used in the prolog/epilog
 */

// Can we use sign-extended byte to encode the imm value, or do we need a dword
#define CAN_COMPRESS(val)       (((int)(val) > -(int)0x100) && \
                                 ((int)(val) <  (int) 0x80))


#define SZ_RET(argSize)         ((argSize)?3:1)
#define SZ_ADD_REG(val)         ( 2 +  (CAN_COMPRESS(val) ? 1 : 4))
#define SZ_AND_REG(val)         SZ_ADD_REG(val)
#define SZ_POP_REG              1
#define SZ_LEA(offset)          SZ_ADD_REG(offset)
#define SZ_MOV_REG_REG          2


    // skips past a Arith REG, IMM.
inline unsigned SKIP_ARITH_REG(int val, BYTE* base, unsigned offset)
{
    unsigned delta = 0;
    if (val != 0)
    {
        delta = 2 + (CAN_COMPRESS(val) ? 1 : 4);
    }
    return(offset + delta);
}

inline unsigned SKIP_PUSH_REG(BYTE* base, unsigned offset)
{
    return(offset + 1);
}

inline unsigned SKIP_POP_REG(BYTE* base, unsigned offset)
{
    return(offset + 1);
}

inline unsigned SKIP_MOV_REG_REG(BYTE* base, unsigned offset)
{
    return(offset + 2);
}

unsigned SKIP_ALLOC_FRAME(int size, BYTE* base, unsigned offset)
{
    if (size == 4) {
        // We do "push eax" instead of "sub esp,4"
        return (SKIP_PUSH_REG(base, offset));
    }

    if (size >= 0x1000) {
        if (size < 0x3000) {
            // add 7 bytes for one or two TEST EAX, [ESP+0x1000]
            offset += (size / 0x1000) * 7;
        }
        else {
			// 		xor eax, eax				2
			// loop:
			// 		test [esp + eax], eax		3
			// 		sub eax, 0x1000				5
			// 		cmp EAX, -size				5
			// 		jge loop					2
            offset += 17;
        }
    } 
		// sub ESP, size
    return (SKIP_ARITH_REG(size, base, offset));
}

/*****************************************************************************/

static
BYTE *   skipToArgReg(const hdrInfo& info, BYTE * table)
{
    unsigned count;

    /* Skip over the untracked frame variable table */

    count = info.untrackedCnt;
    while (count-- > 0) {
        int  stkOffs;
        table += decodeSigned(table, &stkOffs);
    }

    /* Skip over the frame variable lifetime table */

    count = info.varPtrTableSize;
    unsigned curOffs = 0;
    while (count-- > 0) {
        unsigned varOfs;
        unsigned begOfs;
        unsigned endOfs;
        table += decodeUnsigned(table, &varOfs);
        table += decodeUDelta(table, &begOfs, curOffs);
        table += decodeUDelta(table, &endOfs, begOfs);
        curOffs = begOfs;
    }

    return table;
}

/*****************************************************************************
 Helper for scanArgRegTable() and scanArgRegTableI() for regMasks
 */

void *      getCalleeSavedReg(PREGDISPLAY pContext, regNum reg)
{
#ifndef _X86_
    assert(!"NYI");
    return NULL;
#else
    switch (reg)
    {
        case REGI_EBP: return pContext->pEbp;
        case REGI_EBX: return pContext->pEbx;
        case REGI_ESI: return pContext->pEsi;
        case REGI_EDI: return pContext->pEdi;

        default: _ASSERTE(!"bad info.thisPtrResult"); return NULL;
    }
#endif
}

inline
RegMask     convertCalleeSavedRegsMask(unsigned inMask) // EBP,EBX,ESI,EDI
{
    assert((inMask & 0x0F) == inMask);

    unsigned outMask = RM_NONE;
    if (inMask & 0x1) outMask |= RM_EDI;
    if (inMask & 0x2) outMask |= RM_ESI;
    if (inMask & 0x4) outMask |= RM_EBX;
    if (inMask & 0x8) outMask |= RM_EBP;

    return (RegMask) outMask;
}

inline
RegMask     convertAllRegsMask(unsigned inMask) // EAX,ECX,EDX,EBX, EBP,ESI,EDI
{
    assert((inMask & 0xEF) == inMask);

    unsigned outMask = RM_NONE;
    if (inMask & 0x01) outMask |= RM_EAX;
    if (inMask & 0x02) outMask |= RM_ECX;
    if (inMask & 0x04) outMask |= RM_EDX;
    if (inMask & 0x08) outMask |= RM_EBX;
    if (inMask & 0x20) outMask |= RM_EBP;
    if (inMask & 0x40) outMask |= RM_ESI;
    if (inMask & 0x80) outMask |= RM_EDI;

    return (RegMask)outMask;
}

typedef unsigned  ptrArgTP;
#define MAX_PTRARG_OFS  (sizeof(ptrArgTP)*8)

/*****************************************************************************
 * scan the register argument table for the not fully interruptible case.
   this function is called to find all live objects (pushed arguments)
   and to get the stack base for EBP-less methods.

   NOTE: If info->argTabResult is NULL, info->argHnumResult indicates 
         how many bits in argMask are valid
         If info->argTabResult is non-NULL, then the argMask field does 
         not fit in 32-bits and the value in argMask meaningless. 
         Instead argHnum specifies the number of (variable-lenght) elements
         in the array, and argTabBytes specifies the total byte size of the
         array. [ Note this is an extremely rare case ]
 */

static
unsigned scanArgRegTable(BYTE       * table,
                         unsigned     curOffs,
                         hdrInfo    * info)
{
    regNum thisPtrReg       = REGI_NA;
    unsigned  regMask       = 0;    // EBP,EBX,ESI,EDI
    unsigned  argMask       = 0;
    unsigned  argHnum       = 0;
    BYTE    * argTab        = 0;
    unsigned  argTabBytes   = 0;
    unsigned  stackDepth    = 0;
                            
    unsigned  iregMask      = 0;    // EBP,EBX,ESI,EDI
    unsigned  iargMask      = 0;
    unsigned  iptrMask      = 0;

    unsigned scanOffs = 0;

    assert(scanOffs <= info->methodSize);

    if (info->ebpFrame) {
  /*
      Encoding table for methods with an EBP frame and
                         that are not fully interruptible

      The encoding used is as follows:

      this pointer encodings:

         01000000          this pointer in EBX
         00100000          this pointer in ESI
         00010000          this pointer in EDI

      tiny encoding:

         0bsdDDDD
                           requires code delta     < 16 (4-bits)
                           requires pushed argmask == 0

           where    DDDD   is code delta
                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer

      small encoding:

         1DDDDDDD bsdAAAAA

                           requires code delta     < 120 (7-bits)
                           requires pushed argmask <  64 (5-bits)

           where DDDDDDD   is code delta
                   AAAAA   is the pushed args mask
                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer

      medium encoding

         0xFD aaaaaaaa AAAAdddd bseDDDDD

                           requires code delta     <    0x1000000000  (9-bits)
                           requires pushed argmask < 0x1000000000000 (12-bits)

           where    DDDDD  is the upper 5-bits of the code delta
                     dddd  is the low   4-bits of the code delta
                     AAAA  is the upper 4-bits of the pushed arg mask
                 aaaaaaaa  is the low   8-bits of the pushed arg mask
                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        e  indicates that register EDI is a live pointer

      medium encoding with interior pointers

         0xF9 DDDDDDDD bsdAAAAAA iiiIIIII

                           requires code delta     < (8-bits)
                           requires pushed argmask < (5-bits)

           where  DDDDDDD  is the code delta
                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                    AAAAA  is the pushed arg mask
                      iii  indicates that EBX,EDI,ESI are interior pointers
                    IIIII  indicates that bits is the arg mask are interior
                           pointers

      large encoding

         0xFE [0BSD0bsd][32-bit code delta][32-bit argMask]

                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                        B  indicates that register EBX is an interior pointer
                        S  indicates that register ESI is an interior pointer
                        D  indicates that register EDI is an interior pointer
                           requires pushed  argmask < 32-bits

      large encoding  with interior pointers

         0xFA [0BSD0bsd][32-bit code delta][32-bit argMask][32-bit interior pointer mask]  
                               

                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                        B  indicates that register EBX is an interior pointer
                        S  indicates that register ESI is an interior pointer
                        D  indicates that register EDI is an interior pointer
                           requires pushed  argmask < 32-bits
                           requires pushed iArgmask < 32-bits

      huge encoding        This is the only encoding that supports
                           a pushed argmask which is greater than
                           32-bits.

         0xFB [0BSD0bsd][32-bit code delta]
              [32-bit table count][32-bit table size]
              [pushed ptr offsets table...]

                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer
                       B   indicates that register EBX is an interior pointer
                       S   indicates that register ESI is an interior pointer
                       D   indicates that register EDI is an interior pointer
                       the list count is the number of entries in the list
                       the list size gives the byte-lenght of the list
                       the offsets in the list are variable-length
  */
        while (scanOffs < curOffs)
        {
            iregMask =
            iargMask = 0;
            argTab = NULL;

            /* Get the next byte and check for a 'special' entry */

            unsigned encType = *table++;

            switch (encType)
            {
                unsigned    val, nxt;

            default:

                /* A tiny or small call entry */
                val = encType;
                if ((val & 0x80) == 0x00) {
                    if (val & 0x0F) {
                        /* A tiny call entry */
                        scanOffs += (val & 0x0F);
                        regMask   = (val & 0x70) >> 4;
                        argMask   = 0;
                        argHnum   = 0;
                    }
                    else {
                        /* This pointer liveness encoding */
                        regMask   = (val & 0x70) >> 4;
                        if (regMask == 0x1)
                            thisPtrReg = REGI_EDI;
                        else if (regMask == 0x2)
                            thisPtrReg = REGI_ESI;
                        else if (regMask == 0x4)
                            thisPtrReg = REGI_EBX;
                        else
                           _ASSERTE(!"illegal encoding for 'this' pointer liveness");
                    }
                }
                else {
                    /* A small call entry */
                    scanOffs += (val & 0x7F);
                    val       = *table++;
                    regMask   = val >> 5;
                    argMask   = val & 0x1F;
                    argHnum   = 5;
                }
                break;

            case 0xFD:  // medium encoding

                argMask   = *table++;
                val       = *table++;
                argMask  |= (val & 0xF0) << 4;
                argHnum   = 12;
                nxt       = *table++;
                scanOffs += (val & 0x0F) + ((nxt & 0x1F) << 4);
                regMask   = nxt >> 5;                   // EBX,ESI,EDI

                break;

            case 0xF9:  // medium encoding with interior pointers

                scanOffs   += *table++;
                val         = *table++;
                argMask     = val & 0x1F;
                argHnum     = 5;
                regMask     = val >> 5;
                val         = *table++;
                iargMask    = val & 0x1F;
                iregMask    = val >> 5;

                break;

            case 0xFE:  // large encoding
            case 0xFA:  // large encoding with interior pointers

                val         = *table++;
                regMask     = val & 0x7;
                iregMask    = val >> 4;
                scanOffs   += readDWordSmallEndian(table);  table += sizeof(DWORD);
                argMask     = readDWordSmallEndian(table);  table += sizeof(DWORD);
                argHnum     = 31;
                if (encType == 0xFA) // read iargMask
                {
                    iargMask = readDWordSmallEndian(table); table += sizeof(DWORD);
                }
                break;

            case 0xFB:  // huge encoding

                val         = *table++;
                regMask     = val & 0x7;
                iregMask    = val >> 4;
                scanOffs   += readDWordSmallEndian(table); table += sizeof(DWORD);
                argHnum     = readDWordSmallEndian(table); table += sizeof(DWORD);
                argTabBytes = readDWordSmallEndian(table); table += sizeof(DWORD);
                argTab      = table;                       table += argTabBytes;

                argMask     = 0xdeadbeef;
                break;

            case 0xFF:
                scanOffs = curOffs + 1;
                break;

            } // end case

            // iregMask & iargMask are subsets of regMask & argMask respectively

            assert((iregMask & regMask) == iregMask);
            assert((iargMask & argMask) == iargMask);

        } // end while

    }
    else {

/*
 *    Encoding table for methods without an EBP frame and are not fully interruptible
 *
 *               The encoding used is as follows:
 *
 *  push     000DDDDD                     ESP push one item with 5-bit delta
 *  push     00100000 [pushCount]         ESP push multiple items
 *  reserved 0011xxxx
 *  skip     01000000 [Delta]             Skip Delta, arbitrary sized delta
 *  skip     0100DDDD                     Skip small Delta, for call (DDDD != 0)
 *  pop      01CCDDDD                     ESP pop  CC items with 4-bit delta (CC != 00)
 *  call     1PPPPPPP                     Call Pattern, P=[0..79]
 *  call     1101pbsd DDCCCMMM            Call RegMask=pbsd,ArgCnt=CCC,
 *                                        ArgMask=MMM Delta=commonDelta[DD]
 *  call     1110pbsd [ArgCnt] [ArgMask]  Call ArgCnt,RegMask=pbsd,ArgMask
 *  call     11111000 [PBSDpbsd][32-bit delta][32-bit ArgCnt]
 *                    [32-bit PndCnt][32-bit PndSize][PndOffs...]
 *  iptr     11110000 [IPtrMask]          Arbitrary Interior Pointer Mask
 *  thisptr  111101RR                     This pointer is in Register RR
 *                                        00=EDI,01=ESI,10=EBX,11=EBP
 *  reserved 111100xx                     xx  != 00
 *  reserved 111110xx                     xx  != 00
 *  reserved 11111xxx                     xxx != 000 && xxx != 111(EOT)
 *
 *   The value 11111111 [0xFF] indicates the end of the table.
 *
 *  An offset (at which stack-walking is performed) without an explicit encoding
 *  is assumed to be a trivial call-site (no GC registers, stack empty before and 
 *  after) to avoid having to encode all trivial calls.
 *
 * Note on the encoding used for interior pointers
 *
 *   The iptr encoding must immediately preceed a call encoding.  It is used to
 *   transform a normal GC pointer addresses into an interior pointers for GC purposes.
 *   The mask supplied to the iptr encoding is read from the least signicant bit
 *   to the most signicant bit. (i.e the lowest bit is read first)
 *
 *   p   indicates that register EBP is a live pointer
 *   b   indicates that register EBX is a live pointer
 *   s   indicates that register ESI is a live pointer
 *   d   indicates that register EDI is a live pointer
 *   P   indicates that register EBP is an interior pointer
 *   B   indicates that register EBX is an interior pointer
 *   S   indicates that register ESI is an interior pointer
 *   D   indicates that register EDI is an interior pointer
 *
 *   As an example the following sequence indicates that EDI.ESI and the 2nd pushed pointer
 *   in ArgMask are really interior pointers.  The pointer in ESI in a normal pointer:
 *
 *   iptr 11110000 00010011           => read Interior Ptr, Interior Ptr, Normal Ptr, Normal Ptr, Interior Ptr
 *   call 11010011 DDCCC011 RRRR=1011 => read EDI is a GC-pointer, ESI is a GC-pointer. EBP is a GC-pointer
 *                           MMM=0011 => read two GC-pointers arguments on the stack (nested call)
 *
 *   Since the call instruction mentions 5 GC-pointers we list them in the required order:
 *   EDI, ESI, EBP, 1st-pushed pointer, 2nd-pushed pointer
 *
 *   And we apply the Interior Pointer mask mmmm=10011 to the above five ordered GC-pointers
 *   we learn that EDI and ESI are interior GC-pointers and that the second push arg is an
 *   interior GC-pointer.
 */

        while (scanOffs <= curOffs)
        {
            unsigned callArgCnt;
            unsigned skip;
            unsigned newRegMask, inewRegMask;
            unsigned newArgMask, inewArgMask;
            unsigned oldScanOffs = scanOffs;

            if (iptrMask)
            {
                // We found this iptrMask in the previous iteration.
                // This iteration must be for a call. Set these variables
                // so that they are available at the end of the loop

                inewRegMask = iptrMask & 0x0F; // EBP,EBX,ESI,EDI
                inewArgMask = iptrMask >> 4;

                iptrMask    = 0;
            }
            else
            {
                // Zero out any stale values.

                inewRegMask =
                inewArgMask = 0;
            }

            /* Get the next byte and decode it */

            unsigned val = *table++;

            /* Check pushes, pops, and skips */

            if  (!(val & 0x80)) {

                //  iptrMask can immediately precede only calls

                assert(!inewRegMask & !inewArgMask);

                if (!(val & 0x40)) {

                    unsigned pushCount;

                    if (!(val & 0x20))
                    {
                        //
                        // push    000DDDDD                 ESP push one item, 5-bit delta
                        //
                        pushCount   = 1;
                        scanOffs   += val & 0x1f;
                    }
                    else
                    {
                        //
                        // push    00100000 [pushCount]     ESP push multiple items
                        //
                        assert(val == 0x20);
                        table    += decodeUnsigned(table, &pushCount);
                    }

                    if (scanOffs > curOffs)
                    {
                        scanOffs = oldScanOffs;
                        goto FINISHED;
                    }

                    stackDepth +=  pushCount;
                }
                else if ((val & 0x3f) != 0) {
                    //
                    //  pop     01CCDDDD         pop CC items, 4-bit delta
                    //
                    scanOffs   +=  val & 0x0f;
                    if (scanOffs > curOffs)
                    {
                        scanOffs = oldScanOffs;
                        goto FINISHED;
                    }
                    stackDepth -= (val & 0x30) >> 4;

                } else if (scanOffs < curOffs) {
                    //
                    // skip    01000000 [Delta]  Skip arbitrary sized delta
                    //
                    table    += decodeUnsigned(table, &skip);
                    scanOffs += skip;
                }
                else // don't process a skip if we are already at curOffs
                    goto FINISHED;

                /* reset regs and args state since we advance past last call site */

                 regMask    =
                iregMask    = 0;
                 argMask    =
                iargMask    = 0;
                argHnum     = 0;

            }
            else /* It must be a call, thisptr, or iptr */
            {
                switch ((val & 0x70) >> 4) {
                default:    // case 0-4, 1000xxxx through 1100xxxx
                    //
                    // call    1PPPPPPP          Call Pattern, P=[0..79]
                    //
                    decodeCallPattern((val & 0x7f), &callArgCnt,
                                      &newRegMask, &newArgMask, &skip);
                    // If we've already reached curOffs and the skip amount
                    // is non-zero then we are done
                    if ((scanOffs == curOffs) && (skip > 0))
                        goto FINISHED;
                    // otherwise process this call pattern
                    scanOffs   += skip;
                    if (scanOffs > curOffs)
                        goto FINISHED;
                     regMask    = newRegMask;
                     argMask    = newArgMask;   argTab = NULL;
                    iregMask    = inewRegMask;
                    iargMask    = inewArgMask;
                    stackDepth -= callArgCnt;
                    argHnum     = 2;             // argMask is known to be <= 3
                    break;

                  case 5:
                    //
                    // call    1101RRRR DDCCCMMM  Call RegMask=RRRR,ArgCnt=CCC,
                    //                        ArgMask=MMM Delta=commonDelta[DD]
                    //
                    newRegMask  = val & 0xf;    // EBP,EBX,ESI,EDI
                    val         = *table++;     // read next byte
                    skip        = callCommonDelta[val>>6];
                    // If we've already reached curOffs and the skip amount
                    // is non-zero then we are done
                    if ((scanOffs == curOffs) && (skip > 0))
                        goto FINISHED;
                    // otherwise process this call encoding
                    scanOffs   += skip;
                    if (scanOffs > curOffs)
                        goto FINISHED;
                     regMask    = newRegMask;
                    iregMask    = inewRegMask;
                    callArgCnt  = (val >> 3) & 0x7;
                    stackDepth -= callArgCnt;
                     argMask    = (val & 0x7);  argTab = NULL;
                    iargMask    = inewArgMask;
                    argHnum     = 3;
                    break;

                  case 6:
                    //
                    // call    1110RRRR [ArgCnt] [ArgMask]
                    //                          Call ArgCnt,RegMask=RRR,ArgMask
                    //
                     regMask    = val & 0xf;    // EBP,EBX,ESI,EDI
                    iregMask    = inewRegMask;
                    table      += decodeUnsigned(table, &callArgCnt);
                    stackDepth -= callArgCnt;
                    table      += decodeUnsigned(table, &argMask);  argTab = NULL;
                    iargMask    = inewArgMask;
                    argHnum     = 31;
                    break;

                  case 7:
                    switch (val & 0x0C) 
                    {
                      case 0x00:
                        //
                        //  iptr 11110000 [IPtrMask] Arbitrary Interior Pointer Mask
                        //
                        table      += decodeUnsigned(table, &iptrMask);
                        break;

                      case 0x04:
                        {
                          static const regNum calleeSavedRegs[] = 
                                    { REGI_EDI, REGI_ESI, REGI_EBX, REGI_EBP };
                          thisPtrReg = calleeSavedRegs[val&0x3];
                        }
                        break;

                      case 0x08:
                        val         = *table++;
                        skip        = readDWordSmallEndian(table); table += sizeof(DWORD);
                        scanOffs   += skip;
                        if (scanOffs > curOffs)
                            goto FINISHED;
                        regMask     = val & 0xF;
                        iregMask    = val >> 4;
                        callArgCnt  = readDWordSmallEndian(table); table += sizeof(DWORD);
                        stackDepth -= callArgCnt;
                        argHnum     = readDWordSmallEndian(table); table += sizeof(DWORD);
                        argTabBytes = readDWordSmallEndian(table); table += sizeof(DWORD);
                        argTab      = table;
                        table      += argTabBytes;
                        break;

                      case 0x0C:
                        assert(val==0xff);
                        goto FINISHED;

                      default:
                        assert(!"reserved GC encoding");
                        break;
                    }
                    break;

                } // end switch

            } // end else (!(val & 0x80))

            // iregMask & iargMask are subsets of regMask & argMask respectively

            assert((iregMask & regMask) == iregMask);
            assert((iargMask & argMask) == iargMask);

        } // end while

    } // end else ebp-less frame

FINISHED:

    // iregMask & iargMask are subsets of regMask & argMask respectively

    assert((iregMask & regMask) == iregMask);
    assert((iargMask & argMask) == iargMask);

    info->thisPtrResult  = thisPtrReg;

    if (scanOffs != curOffs)
    {
        /* must have been a boring call */
        info->regMaskResult  = RM_NONE;
        info->argMaskResult  = 0;
        info->iregMaskResult = RM_NONE;
        info->iargMaskResult = 0;
        info->argHnumResult  = 0;
        info->argTabResult   = NULL;
        info->argTabBytes    = 0;
    }
    else
    {
        info->regMaskResult     = convertCalleeSavedRegsMask(regMask);
        info->argMaskResult     = argMask;
        info->argHnumResult     = argHnum;
        info->iregMaskResult    = convertCalleeSavedRegsMask(iregMask);
        info->iargMaskResult    = iargMask;
        info->argTabResult      = argTab;
        info->argTabBytes       = argTabBytes;
        if ((stackDepth != 0) || (argMask != 0))
        {
            argMask = argMask;
        }
    }
    return (stackDepth * sizeof(unsigned));
}


/*****************************************************************************
 * scan the register argument table for the fully interruptible case.
   this function is called to find all live objects (pushed arguments)
   and to get the stack base for fully interruptible methods.
   Returns size of things pushed on the stack for ESP frames
 */

static
unsigned scanArgRegTableI(BYTE      *  table,
                          unsigned     curOffs,
                          hdrInfo   *  info)
{
    regNum thisPtrReg = REGI_NA;
    unsigned  ptrRegs    = 0;
    unsigned iptrRegs    = 0;
    unsigned  ptrOffs    = 0;
    unsigned  argCnt     = 0;

    ptrArgTP  ptrArgs    = 0;
    ptrArgTP iptrArgs    = 0;
    ptrArgTP  argHigh    = 0;

    bool      isThis     = false;
    bool      iptr       = false;

#if VERIFY_GC_TABLES
    assert(*castto(table, unsigned short *)++ == 0xBABE);
#endif

  /*
      Encoding table for methods that are fully interruptible

      The encoding used is as follows:

          ptr reg dead        00RRRDDD    [RRR != 100]
          ptr reg live        01RRRDDD    [RRR != 100]

      non-ptr arg push        10110DDD                    [SSS == 110]
          ptr arg push        10SSSDDD                    [SSS != 110] && [SSS != 111]
          ptr arg pop         11CCCDDD    [CCC != 000] && [CCC != 110] && [CCC != 111]
      little delta skip       11000DDD    [CCC == 000]
      bigger delta skip       11110BBB                    [CCC == 110]

      The values used in the encodings are as follows:

        DDD                 code offset delta from previous entry (0-7)
        BBB                 bigger delta 000=8,001=16,010=24,...,111=64
        RRR                 register number (EAX=000,ECX=001,EDX=010,EBX=011,
                              EBP=101,ESI=110,EDI=111), ESP=100 is reserved
        SSS                 argument offset from base of stack. This is 
                              redundant for frameless methods as we can
                              infer it from the previous pushes+pops. However,
                              for EBP-methods, we only report GC pushes, and
                              so we need SSS
        CCC                 argument count being popped (includes only ptrs for EBP methods)

      The following are the 'large' versions:

        large delta skip        10111000 [0xB8] , encodeUnsigned(delta)

        large     ptr arg push  11111000 [0xF8] , encodeUnsigned(pushCount)
        large non-ptr arg push  11111001 [0xF9] , encodeUnsigned(pushCount)
        large     ptr arg pop   11111100 [0xFC] , encodeUnsigned(popCount)
        large         arg dead  11111101 [0xFD] , encodeUnsigned(popCount) for caller-pop args.
                                                    Any GC args go dead after the call, 
                                                    but are still sitting on the stack

        this pointer prefix     10111100 [0xBC]   the next encoding is a ptr live
                                                    or a ptr arg push
                                                    and contains the this pointer

        interior or by-ref      10111111 [0xBF]   the next encoding is a ptr live
             pointer prefix                         or a ptr arg push
                                                    and contains an interior
                                                    or by-ref pointer


        The value 11111111 [0xFF] indicates the end of the table.
  */

    /* Have we reached the instruction we're looking for? */

    while (ptrOffs <= curOffs)
    {
        unsigned    val;

        int         isPop;
        unsigned    argOfs;

        unsigned    regMask;

        // iptrRegs & iptrArgs are subsets of ptrRegs & ptrArgs respectively

        assert((iptrRegs & ptrRegs) == iptrRegs);
        assert((iptrArgs & ptrArgs) == iptrArgs);

        /* Now find the next 'life' transition */

        val = *table++;

        if  (!(val & 0x80))
        {
            /* A small 'regPtr' encoding */

            regNum       reg;

            ptrOffs += (val     ) & 0x7;
            if (ptrOffs > curOffs) {
                iptr = isThis = false;
                goto REPORT_REFS;
            }

            reg     = (regNum)((val >> 3) & 0x7);
            regMask = 1 << reg;         // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI

#if 0
            printf("regMask = %04X -> %04X\n", ptrRegs,
                       (val & 0x40) ? (ptrRegs |  regMask)
                                    : (ptrRegs & ~regMask));
#endif

            /* The register is becoming live/dead here */

            if  (val & 0x40)
            {
                /* Becomes Live */
                assert((ptrRegs  &  regMask) == 0);

                ptrRegs |=  regMask;

                if  (isThis)
                {
                    thisPtrReg = reg;
                }
                if  (iptr)
                {
                    iptrRegs |= regMask;
                }
            }
            else
            {
                /* Becomes Dead */
                assert((ptrRegs  &  regMask) != 0);

                ptrRegs &= ~regMask;

                if  (reg == thisPtrReg)
                {
                    thisPtrReg = REGI_NA;
                }
                if  (iptrRegs & regMask)
                {
                    iptrRegs &= ~regMask;
                }
            }
            iptr = isThis = false;
            continue;
        }

        /* This is probably an argument push/pop */

        argOfs = (val & 0x38) >> 3;

        /* 6 [110] and 7 [111] are reserved for other encodings */
        if  (argOfs < 6)
        {
            ptrArgTP    argMask;

            /* A small argument encoding */

            ptrOffs += (val & 0x07);
            if (ptrOffs > curOffs) {
                iptr = isThis = false;
                goto REPORT_REFS;
            }
            isPop    = (val & 0x40);

        ARG:

            if  (isPop)
            {
                if (argOfs == 0)
                    continue;           // little skip encoding

                /* We remove (pop) the top 'argOfs' entries */

                assert(argOfs || argOfs <= argCnt);

                /* adjust # of arguments */

                argCnt -= argOfs;
                assert(argCnt < MAX_PTRARG_OFS);

//              printf("[%04X] popping %u args: mask = %04X\n", ptrOffs, argOfs, (int)ptrArgs);

                do
                {
                    assert(argHigh);

                    /* Do we have an argument bit that's on? */

                    if  (ptrArgs & argHigh)
                    {
                        /* Turn off the bit */

                        ptrArgs &= ~argHigh;
                       iptrArgs &= ~argHigh;

                        /* We've removed one more argument bit */

                        argOfs--;
                    }
                    else if (info->ebpFrame)
                        argCnt--;
                    else /* !ebpFrame && not a ref */
                        argOfs--;

                    /* Continue with the next lower bit */

                    argHigh >>= 1;
                }
                while (argOfs);

                assert (info->ebpFrame != 0         ||
                        argHigh == 0                ||
                        (argHigh == (ptrArgTP)(1 << (argCnt-1))));

                if (info->ebpFrame)
                {
                    while (!(argHigh&ptrArgs) && (argHigh != 0))
                        argHigh >>= 1;
                }

            }
            else
            {
                /* Add a new ptr arg entry at stack offset 'argOfs' */

                if  (argOfs >= MAX_PTRARG_OFS)
                {
                    assert(!"UNDONE: args pushed 'too deep'");
                }
                else
                {
                    /* For ESP-frames, all pushes are reported, and so 
                       argOffs has to be consistent with argCnt */

                    assert(info->ebpFrame || argCnt == argOfs);

                    /* store arg count */

                    argCnt  = argOfs + 1;
                    assert((argCnt < MAX_PTRARG_OFS));

                    /* Compute the appropriate argument offset bit */

                    argMask = (ptrArgTP)1 << argOfs;

//                  printf("push arg at offset %02u --> mask = %04X\n", argOfs, (int)argMask);

                    /* We should never push twice at the same offset */

                    assert(( ptrArgs & argMask) == 0);
                    assert((iptrArgs & argMask) == 0);

                    /* We should never push within the current highest offset */

                    assert(argHigh < argMask);

                    /* This is now the highest bit we've set */

                    argHigh = argMask;

                    /* Set the appropriate bit in the argument mask */

                    ptrArgs |= argMask;

                    if (iptr)
                        iptrArgs |= argMask;
                }

                iptr = isThis = false;
            }
            continue;
        }
        else if (argOfs == 6)
        {
            if (val & 0x40) {
                /* Bigger delta  000=8,001=16,010=24,...,111=64 */
                ptrOffs += (((val & 0x07) + 1) << 3);
            }
            else {
                /* non-ptr arg push */
                assert(!(info->ebpFrame));
                ptrOffs += (val & 0x07);
                if (ptrOffs > curOffs) {
                    iptr = isThis = false;
                    goto REPORT_REFS;
                }
                argHigh = (ptrArgTP)1 << argCnt;
                argCnt++;
                assert(argCnt < MAX_PTRARG_OFS);
            }
            continue;
        }

        /* argOfs was 7 [111] which is reserved for the larger encodings */

        assert(argOfs==7);

        switch (val)
        {
        case 0xFF:
            iptr = isThis = false;
            goto REPORT_REFS;   // the method might loop !!!

        case 0xB8:
            table   += decodeUnsigned(table, &val);
            ptrOffs += val;
            continue;

        case 0xBC:
            isThis = true;
            break;

        case 0xBF:
            iptr = true;
            break;

        case 0xF8:
        case 0xFC:
            isPop    = val & 0x04;
            table   += decodeUnsigned(table, &argOfs);
            goto ARG;

        case 0xFD:
            table   += decodeUnsigned(table, &argOfs);
            assert(argOfs && argOfs <= argCnt);

            // Kill the top "argOfs" pointers.

            ptrArgTP    argMask;
            for(argMask = (ptrArgTP)1 << argCnt; argOfs; argMask >>= 1)
            {
                assert(argMask && ptrArgs); // there should be remaining pointers

                if (ptrArgs & argMask)
                {
                    ptrArgs  &= ~argMask;
                    iptrArgs &= ~argMask;
                    argOfs--;
                }
            }

            // For ebp-frames, need to find the next higest pointer for argHigh

            if (info->ebpFrame)
            {
                for(argHigh = 0; argMask; argMask >>= 1) 
                {
                    if (ptrArgs & argMask) {
                        argHigh = argMask;
                        break;
                    }
                }
            }
            break;

        case 0xF9:
            table   += decodeUnsigned(table, &argOfs);
            argCnt  += argOfs;
            break;

        default:
#ifdef _DEBUG
            printf("Unexpected special code %04X\n", val);
#endif
            assert(!"");
        }
    }

    /* Report all live pointer registers */
REPORT_REFS:

    assert((iptrRegs & ptrRegs) == iptrRegs); // iptrRegs is a subset of ptrRegs
    assert((iptrArgs & ptrArgs) == iptrArgs); // iptrArgs is a subset of ptrArgs

    /* Save the current live register, argument set, and argCnt */
    info->thisPtrResult  = thisPtrReg;
    info->regMaskResult  = convertAllRegsMask(ptrRegs);
    info->argMaskResult  = ptrArgs;
    info->argHnumResult  = 0;
    info->iregMaskResult = convertAllRegsMask(iptrRegs);
    info->iargMaskResult = iptrArgs;

    if (info->ebpFrame)
        return 0;
    else
        return (argCnt * sizeof(unsigned));
}

/*****************************************************************************/

const LCL_FIN_MARK = 0xFC; // FC = "Finally Call"

// We do a "pop eax; jmp eax" to return from a fault or finally handler
const END_FIN_POP_STACK = sizeof(void*);

/*****************************************************************************
 *  Returns the start of the hidden slots for the shadowSP for functions
 *  with exception handlers. There is one slot per nesting level starting
 *  near Ebp and is zero-terminated after the active slots.
 */

inline
size_t *     GetFirstBaseSPslotPtr(size_t ebp, hdrInfo * info)
{
    size_t  distFromEBP = info->securityCheck
        + info->localloc
        + 1 // Slot for end-of-last-executed-filter
        + 1; // to get to the *start* of the next slot

    return (size_t *)(ebp -  distFromEBP * sizeof(void*));
}

/*****************************************************************************
 *    returns the base ESP corresponding to the target nesting level.
 */
inline
size_t GetBaseSPForHandler(size_t ebp, hdrInfo * info)
{
        // we are not taking into account double alignment.  We are
        // safe because the jit currently bails on double alignment if there
        // are handles or localalloc
    if (info->localloc)
    {
        // If the function uses localloc we will fetch the ESP from the localloc
        // slot.
        size_t* pLocalloc=
            (size_t *)
            (ebp-
              (info->securityCheck
             + 1)
             * sizeof(void*));
                    
        size_t localloc;
        safemove(localloc, pLocalloc);
        return (localloc);
    }
    else
    {
        // Default, go back all the method's local stack size
        return (ebp - info->stackSize + sizeof(int));
    }       
}

/*****************************************************************************
 *
 *  For functions with handlers, checks if it is currently in a handler.
 *  Either of unwindESP or unwindLevel will specify the target nesting level.
 *  If unwindLevel is specified, info about the funclet at that nesting level
 *    will be returned. (Use if you are interested in a specific nesting level.)
 *  If unwindESP is specified, info for nesting level invoked before the stack
 *   reached unwindESP will be returned. (Use if you have a specific ESP value
 *   during stack walking.)
 *
 *  *pBaseSP is set to the base SP (base of the stack on entry to
 *    the current funclet) corresponding to the target nesting level.
 *  *pNestLevel is set to the nesting level of the target nesting level (useful
 *    if unwindESP!=IGNORE_VAL
 *  *hasInnerFilter will be set to true (only when unwindESP!=IGNORE_VAL) if a filter
 *    is currently active, but the target nesting level is an outer nesting level.
 */

enum FrameType 
{    
    FR_NORMAL,              // Normal method frame - no exceptions currently active
    FR_FILTER,              // Frame-let of a filter
    FR_HANDLER,             // Frame-let of a callable catch/fault/finally

    FR_COUNT
};

enum { IGNORE_VAL = -1 };

enum ContextType
{
    FILTER_CONTEXT,
    CATCH_CONTEXT,
    FINALLY_CONTEXT
};

/* Type of funclet corresponding to a shadow stack-pointer */

enum
{
    SHADOW_SP_IN_FILTER = 0x1,
    SHADOW_SP_FILTER_DONE = 0x2,
    SHADOW_SP_BITS = 0x3
};

FrameType   GetHandlerFrameInfo(hdrInfo   * info,
                                size_t      frameEBP, 
                                size_t      unwindESP, 
                                DWORD       unwindLevel,
                                size_t    * pBaseSP = NULL,         /* OUT */
                                DWORD     * pNestLevel = NULL,      /* OUT */
                                bool      * pHasInnerFilter = NULL, /* OUT */
                                bool      * pHadInnerFilter = NULL) /* OUT */
{
    size_t * pFirstBaseSPslot = GetFirstBaseSPslotPtr(frameEBP, info);
    size_t  baseSP           = GetBaseSPForHandler(frameEBP , info);
    bool    nonLocalHandlers = false; // Are the funclets invoked by EE (instead of managed code itself)
    bool    hasInnerFilter   = false;
    bool    hadInnerFilter   = false;

    /* Get the last non-zero slot >= unwindESP, or lvl<unwindLevel.
       Also do some sanity checks */

//     for(size_t *pSlot = pFirstBaseSPslot, lvl = 0;
//         *pSlot && lvl < unwindLevel;
//         pSlot--, lvl++)

    size_t *pSlot = pFirstBaseSPslot;
    size_t lvl = 0;

    while (TRUE)
    {
        size_t curSlotVal;
        safemove(curSlotVal, pSlot);

        if (!(curSlotVal && lvl < unwindLevel))
            break;

        if (curSlotVal == LCL_FIN_MARK)
        {   
            // Locally called finally
            baseSP -= sizeof(void*);    
        }
        else
        {
            if (unwindESP != IGNORE_VAL && unwindESP > END_FIN_POP_STACK + (curSlotVal & ~SHADOW_SP_BITS))
            {
                if (curSlotVal & SHADOW_SP_FILTER_DONE)
                    hadInnerFilter = true;
                else
                    hasInnerFilter = true;
                break;
            }

            nonLocalHandlers = true;
            baseSP = curSlotVal;
        }

        pSlot--;
        lvl++;
    }

    if (unwindESP != IGNORE_VAL)
    {
        if (baseSP < unwindESP)                       // About to locally call a finally
            baseSP = unwindESP;
    }

    if (pBaseSP)
        *pBaseSP = baseSP & ~SHADOW_SP_BITS;

    if (pNestLevel)
    {
        *pNestLevel = (DWORD)lvl;
    }
    
    if (pHasInnerFilter)
        *pHasInnerFilter = hasInnerFilter;

    if (pHadInnerFilter)
        *pHadInnerFilter = hadInnerFilter;

    if (baseSP & SHADOW_SP_IN_FILTER)
    {
        return FR_FILTER;
    }
    else if (nonLocalHandlers)
    {
        return FR_HANDLER;
    }
    else
    {
        return FR_NORMAL;
    }
}

/*
    Unwind the current stack frame, i.e. update the virtual register
    set in pContext. This will be similar to the state after the function
    returns back to caller (IP points to after the call, Frame and Stack
    pointer has been reset, callee-saved registers restored 
    (if UpdateAllRegs), callee-UNsaved registers are trashed)
    Returns success of operation.
*/
#define RETURN_ADDR_OFFS        1       // in DWORDS
static CONTEXT g_ctx;

bool UnwindStackFrame(PREGDISPLAY     pContext,
                      DWORD_PTR       methodInfoPtr,
                      ICodeInfo      *pCodeInfo,
                      unsigned        flags,
                      CodeManState   *pState)
{
#ifdef _X86_
    // Address where the method has been interrupted
    size_t           breakPC = (size_t) *(pContext->pPC);

    /* Extract the necessary information from the info block header */
    BYTE* methodStart = (BYTE*) pCodeInfo->getStartAddress();
    DWORD  curOffs = (DWORD)((size_t)breakPC - (size_t)methodStart);

    BYTE *table = (BYTE *) methodInfoPtr;

    assert(sizeof(CodeManStateBuf) <= sizeof(pState->stateBuf));
    CodeManStateBuf * stateBuf = (CodeManStateBuf*)pState->stateBuf;

    if (pState->dwIsSet == 0)
    {
        // This takes care of all reads from table, which is actually
        // a pointer to memory on the other process
        BYTE methodInfoBuf[4096];
        safemove(methodInfoBuf, methodInfoPtr);

        /* Extract the necessary information from the info block header */
        stateBuf->hdrInfoSize = (DWORD)crackMethodInfoHdr(&methodInfoBuf[0],
                                                          curOffs,
                                                          &stateBuf->hdrInfoBody);
    }

    BYTE *methodBuf = (BYTE *)_alloca(stateBuf->hdrInfoBody.methodSize);
    moveBlockFailRet(*methodBuf, methodStart, stateBuf->hdrInfoBody.methodSize, false);

    table += stateBuf->hdrInfoSize;

    // Register values at "curOffs"

    const unsigned curESP =  pContext->Esp;
    const unsigned curEBP = *pContext->pEbp;

    /*-------------------------------------------------------------------------
     *  First, handle the epilog
     */

    if  (stateBuf->hdrInfoBody.epilogOffs != -1)
    {
        BYTE* epilogBase = methodBuf + (curOffs-stateBuf->hdrInfoBody.epilogOffs);

        RegMask regsMask = stateBuf->hdrInfoBody.savedRegMask; // currently remaining regs

        // Used for UpdateAllRegs. Points to the topmost of the 
        // remaining callee-saved regs

        DWORD *     pSavedRegs = NULL; 

        if  (stateBuf->hdrInfoBody.ebpFrame || stateBuf->hdrInfoBody.doubleAlign)
        {
            assert(stateBuf->hdrInfoBody.argSize < 0x10000); // "ret" only has a 2 byte operand
            
           /* See how many instructions we have executed in the 
              epilog to determine which callee-saved registers
              have already been popped */
            int offset = 0;
            
            // stacksize includes all things pushed by this routine (including EBP
            // for EBP based frames.  Thus we need to subrack off the size of EBP
            // to get the EBP relative offset.
            pSavedRegs = (DWORD *)(size_t)(curEBP - (stateBuf->hdrInfoBody.stackSize - sizeof(void*)));
            
            if (stateBuf->hdrInfoBody.doubleAlign && (curEBP & 0x04))
                pSavedRegs--;
            
            // At this point pSavedRegs points at the last callee saved register that
            // was pushed by the prolog.  
            
            // We reset ESP before popping regs
            if ((stateBuf->hdrInfoBody.localloc) &&
                (stateBuf->hdrInfoBody.savedRegMask & (RM_EBX|RM_ESI|RM_EDI))) 
            {
                // The -sizeof void* is because EBP is pushed (and thus
                // is part of stackSize), but we want the displacement from
                // where EBP points (which does not include the pushed EBP)
                offset += SZ_LEA(stateBuf->hdrInfoBody.stackSize - sizeof(void*));
                if (stateBuf->hdrInfoBody.doubleAlign) offset += SZ_AND_REG(-8);
            }
            
            /* Increment "offset" in steps to see which callee-saved
            registers have already been popped */
            
#define determineReg(mask)                                          \
            if ((offset < stateBuf->hdrInfoBody.epilogOffs) &&      \
                (stateBuf->hdrInfoBody.savedRegMask & mask))        \
                {                                                   \
                regsMask = (RegMask)(regsMask & ~mask);             \
                pSavedRegs++;                                       \
                offset = SKIP_POP_REG(epilogBase, offset);          \
                }
            
            determineReg(RM_EBX);        // EBX
            determineReg(RM_ESI);        // ESI
            determineReg(RM_EDI);        // EDI
#undef determineReg

            if (stateBuf->hdrInfoBody.rawStkSize != 0 || stateBuf->hdrInfoBody.localloc)
                offset += SZ_MOV_REG_REG;                           // mov ESP, EBP

            DWORD_PTR vpCurEip;

            if (offset < stateBuf->hdrInfoBody.epilogOffs)          // have we executed the pop EBP
            {
                // We are after the pop, thus EBP is already the unwound value, however
                // and ESP points at the return address.  
/*                
                _ASSERTE((regsMask & RM_ALL) == RM_EBP);     // no register besides EBP need to be restored.
                pContext->pPC = (SLOT *)(DWORD_PTR)curESP;

*/
                _ASSERTE((regsMask & RM_ALL) == RM_EBP);     // no register besides EBP need to be restored.
                vpCurEip = curESP;
                safemove(g_ctx.Eip, vpCurEip);
                pContext->pPC = &g_ctx.Eip;

                // since we don't need offset from here on out don't bother updating.  
                if (IsDebugBuildEE())
                    offset = SKIP_POP_REG(epilogBase, offset);          // POP EBP
            }
            else
            {
                // This means EBP is still valid, find the previous EBP and return address
                // based on this
/*
                pContext->pEbp = (DWORD *)(DWORD_PTR)curEBP;    // restore EBP
                pContext->pPC = (SLOT*)(pContext->pEbp+1);
*/
                safemove(g_ctx.Ebp, curEBP);
                pContext->pEbp = &g_ctx.Ebp;

                vpCurEip = curEBP + sizeof(DWORD *);
                safemove(g_ctx.Eip, vpCurEip);
                pContext->pPC = &g_ctx.Eip;
            }

            // now pop return address and arguments base of return address
            // location. Note varargs is caller-popped
/*
            pContext->Esp = (DWORD)(size_t) pContext->pPC + sizeof(void*) +
                (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize);
*/
            pContext->Esp = (DWORD)(size_t) vpCurEip + sizeof(void*) +
                (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize);
        
        
        }
        else // (stateBuf->hdrInfoBody.ebpFrame || stateBuf->hdrInfoBody.doubleAlign)
        {
            int offset = 0;

            /* at this point we know we don't have to restore EBP
               because this is always the first instruction of the epilog
               (if EBP was saved at all).
               First we have to find out where we are in the epilog, i.e.
               how much of the local stacksize has been already popped.
             */

            assert(stateBuf->hdrInfoBody.epilogOffs > 0);

            /* Remaining callee-saved regs are at curESP. Need to update 
               regsMask as well to exclude registers which have already 
               been popped. */

            pSavedRegs = (DWORD *)(DWORD_PTR)curESP;

            /* Increment "offset" in steps to see which callee-saved
               registers have already been popped */

#define determineReg(mask)                                              \
            if  (offset < stateBuf->hdrInfoBody.epilogOffs && (regsMask & mask)) \
            {                                                           \
                stateBuf->hdrInfoBody.stackSize  -= sizeof(unsigned);   \
                offset++;                                               \
                regsMask = (RegMask)(regsMask & ~mask);                 \
            }

            determineReg(RM_EBP);       // EBP
            determineReg(RM_EBX);       // EBX
            determineReg(RM_ESI);       // ESI
            determineReg(RM_EDI);       // EDI
#undef determineReg

            /* If we are not past popping the local frame
               we have to adjust pContext->Esp.
             */

            if  (offset >= stateBuf->hdrInfoBody.epilogOffs)
            {
                /* We have not executed the ADD ESP, FrameSize, so manually adjust stack pointer */
                pContext->Esp += stateBuf->hdrInfoBody.stackSize;
            }
            else if (IsDebugBuildEE())
            {
                   /* we may use POP ecx for doing ADD ESP, 4, or we may not (in the case of JMP epilogs) */
             if ((epilogBase[offset] & 0xF8) == 0x58)    // Pop ECX
                 _ASSERTE(stateBuf->hdrInfoBody.stackSize == 4);
             else                
                 SKIP_ARITH_REG(stateBuf->hdrInfoBody.stackSize, epilogBase, offset);
            }

            /* Finally we can set pPC */
            // pContext->pPC = (SLOT*)(size_t)pContext->Esp;
            safemove(g_ctx.Eip, pContext->Esp);
            pContext->pPC = &g_ctx.Eip;

            /* Now adjust stack pointer, pop return address and arguments. 
              Note varargs is caller-popped. */

            pContext->Esp += sizeof(void *) + (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize);
        }

#if 0
        if (flags & UpdateAllRegs)
        {
            /* If we are not done popping all the callee-saved regs, 
               regsMask should indicate the remaining regs and
               pSavedRegs should indicate where the first of the
               remaining regs are sitting. */

#define restoreReg(reg,mask)                                \
            if  (regsMask & mask)                           \
            {                                               \
                safemove(g_ctx.##reg, pSavedRegs);          \
                pContext->p##reg = &g_ctx.##reg;            \
                pSavedRegs++;                               \
            }

            // For EBP frames, ebp is not near the other callee-saved
            // registers, and is already updated above
            if (!stateBuf->hdrInfoBody.ebpFrame && !stateBuf->hdrInfoBody.doubleAlign)
                restoreReg(Ebp, RM_EBP);

            restoreReg(Ebx, RM_EBX);
            restoreReg(Esi, RM_ESI);
            restoreReg(Edi, RM_EDI);
#undef  restoreReg
        }
#endif

        return true;
    }

    /*-------------------------------------------------------------------------
     *  Now handle ESP frames
     */

    if (!stateBuf->hdrInfoBody.ebpFrame && !stateBuf->hdrInfoBody.doubleAlign)
    {
        unsigned ESP = curESP;

        if (stateBuf->hdrInfoBody.prologOffs == -1)
        {
            // This takes care of all reads from table, which is actually
            // a pointer to memory on the other process
            BYTE tableBuf[4096];
            safemove(tableBuf, table);

            if  (stateBuf->hdrInfoBody.interruptible)
            {

                ESP += scanArgRegTableI(skipToArgReg(stateBuf->hdrInfoBody, &tableBuf[0]),
                                        curOffs,
                                        &stateBuf->hdrInfoBody);
            }
            else
            {
                ESP += scanArgRegTable (skipToArgReg(stateBuf->hdrInfoBody, &tableBuf[0]),
                                        curOffs,
                                        &stateBuf->hdrInfoBody);
            }
        }

        /* Unwind ESP and restore EBP (if necessary) */

        if (stateBuf->hdrInfoBody.prologOffs != 0)
        {

            if  (stateBuf->hdrInfoBody.prologOffs == -1)
            {
                /* we are past the prolog, ESP has been set above */
/*
#define restoreReg(reg, mask)                                   \
                if  (stateBuf->hdrInfoBody.savedRegMask & mask) \
                {                                               \
                    pContext->p##reg  = (DWORD *)(size_t) ESP;  \
                    ESP              += sizeof(unsigned);       \
                    stateBuf->hdrInfoBody.stackSize -= sizeof(unsigned); \
                }
*/

#define restoreReg(reg, mask)                                   \
                if  (stateBuf->hdrInfoBody.savedRegMask & mask) \
                {                                               \
                    safemove(g_ctx.##reg, ESP);                 \
                    pContext->p##reg  = &g_ctx.##reg;           \
                    ESP              += sizeof(unsigned);       \
                    stateBuf->hdrInfoBody.stackSize -= sizeof(unsigned); \
                }

                restoreReg(Ebp, RM_EBP);
                restoreReg(Ebx, RM_EBX);
                restoreReg(Esi, RM_ESI);
                restoreReg(Edi, RM_EDI);

#undef restoreReg
                /* pop local stack frame */

                ESP += stateBuf->hdrInfoBody.stackSize;

            }
            else
            {
                /* we are in the middle of the prolog */

                unsigned  codeOffset = 0;
                unsigned stackOffset = 0;
                unsigned    regsMask = 0;
//#ifdef _DEBUG
                    // if the first instructions are 'nop, int3' 
                    // we will assume that is from a jithalt operation
                    // ad skip past it
                if (IsDebugBuildEE() && methodBuf[0] == 0x90 && methodBuf[1] == 0xCC)
                    codeOffset += 2;
//#endif

                if  (stateBuf->hdrInfoBody.rawStkSize)
                {
                    /* (possible stack tickle code) 
                       sub esp,size */
                    codeOffset = SKIP_ALLOC_FRAME(stateBuf->hdrInfoBody.rawStkSize, methodStart, codeOffset);

                    /* only the last instruction in the sequence above updates ESP
                       thus if we are less than it, we have not updated ESP */
                    if (curOffs >= codeOffset)
                        stackOffset += stateBuf->hdrInfoBody.rawStkSize;
                }

                // Now find out how many callee-saved regs have already been pushed

#define isRegSaved(mask)    ((codeOffset < curOffs) &&                      \
                             (stateBuf->hdrInfoBody.savedRegMask & (mask)))
                                
#define doRegIsSaved(mask)  do { codeOffset = SKIP_PUSH_REG(methodStart, codeOffset);   \
                                 stackOffset += sizeof(void*);                          \
                                 regsMask    |= mask; } while(0)

#define determineReg(mask)  do { if (isRegSaved(mask)) doRegIsSaved(mask); } while(0)

                determineReg(RM_EDI);               // EDI
                determineReg(RM_ESI);               // ESI
                determineReg(RM_EBX);               // EBX
                determineReg(RM_EBP);               // EBP

#undef isRegSaved
#undef doRegIsSaved
#undef determineReg
                
#if 0
#ifdef PROFILING_SUPPORTED
                // If profiler is active, we have following code after
                // callee saved registers:
                //     push MethodDesc      (or push [MethodDescPtr])
                //     call EnterNaked      (or call [EnterNakedPtr])
                // We need to adjust stack offset if breakPC is at the call instruction.
                if (CORProfilerPresent() && !CORProfilerInprocEnabled() && codeOffset <= unsigned(stateBuf->hdrInfoBody.prologOffs))
                {
                    // This is a bit of a hack, as we don't update codeOffset, however we don't need it 
                    // from here on out.  We only need to make certain we are not certain the ESP is
                    // adjusted correct (which only happens between the push and the call
                    if (methodBuf[curOffs] == 0xe8)                           // call addr
                    {
                        _ASSERTE(methodBuf[codeOffset] == 0x68 &&             // push XXXX
                                 codeOffset + 5 == curOffs);
                        ESP += sizeof(DWORD);                        
                    }
                    else if (methodBuf[curOffs] == 0xFF && methodBuf[curOffs+1] == 0x15)  // call [addr]
                    {
                        _ASSERTE(methodBuf[codeOffset]   == 0xFF &&  
                                 methodBuf[codeOffset+1] == 0x35 &&             // push [XXXX]
                                 codeOffset + 6 == curOffs);
                        ESP += sizeof(DWORD);
                    }
                }
				INDEBUG(codeOffset = 0xCCCCCCCC);		// Poison the value, we don't set it properly in the profiling case

#endif // PROFILING_SUPPORTED
#endif // 0

                    // Always restore EBP 
                DWORD* savedRegPtr = (DWORD*) (size_t) ESP;
                if (regsMask & RM_EBP)
                {
                    //pContext->pEbp = savedRegPtr++;
                    safemove(g_ctx.Ebp, savedRegPtr);
                    pContext->pEbp = &g_ctx.Ebp;
                    savedRegPtr++;
                }

                if (flags & UpdateAllRegs)
                {
                    if (regsMask & RM_EBX)
                    {
                        //pContext->pEbx = savedRegPtr++;
                        safemove(g_ctx.Ebx, savedRegPtr);
                        pContext->pEbx = &g_ctx.Ebx;
                        savedRegPtr++;
                    }
                    if (regsMask & RM_ESI)
                    {
                        //pContext->pEsi = savedRegPtr++;
                        safemove(g_ctx.Esi, savedRegPtr);
                        pContext->pEsi = &g_ctx.Esi;
                        savedRegPtr++;
                    }
                    if (regsMask & RM_EDI)
                    {
                        //pContext->pEdi = savedRegPtr++;
                        safemove(g_ctx.Edi, savedRegPtr);
                        pContext->pEdi = &g_ctx.Edi;
                        savedRegPtr++;
                    }
                }

                ESP += stackOffset;
            }
        }

        /* we can now set the (address of the) return address */

        //pContext->pPC = (SLOT *)(size_t)ESP;
        safemove(g_ctx.Eip, ESP);
        pContext->pPC = &g_ctx.Eip;

        /* Now adjust stack pointer, pop return address and arguments.
           Note varargs is caller-popped. */

        pContext->Esp = ESP + sizeof(void*) + (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize);

        return true;
    }

    /*-------------------------------------------------------------------------
     *  Now we know that have an EBP frame
     */

    _ASSERTE(stateBuf->hdrInfoBody.ebpFrame || stateBuf->hdrInfoBody.doubleAlign);

    /* Check for the case where ebp has not been updated yet */

    if  (stateBuf->hdrInfoBody.prologOffs == 0 || stateBuf->hdrInfoBody.prologOffs == 1)
    {
        /* If we're past the "push ebp", adjust ESP to pop EBP off */

        if  (stateBuf->hdrInfoBody.prologOffs == 1)
            pContext->Esp += sizeof(void *);

        /* Stack pointer points to return address */

        //pContext->pPC = (SLOT *)(size_t)pContext->Esp;
        safemove(g_ctx.Eip, pContext->Esp);
        pContext->pPC = &g_ctx.Eip;

        /* Now adjust stack pointer, pop return address and arguments.
           Note varargs is caller-popped. */

        pContext->Esp += sizeof(void *) + (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize);

        /* EBP and callee-saved registers still have the correct value */
        return true;
    }
    else    /* */
    {
        if (stateBuf->hdrInfoBody.handlers && stateBuf->hdrInfoBody.prologOffs == -1)
        {
            size_t  baseSP;

            FrameType frameType = GetHandlerFrameInfo(&stateBuf->hdrInfoBody, curEBP,
                                                      curESP, IGNORE_VAL,
                                                      &baseSP);

            /* If we are in a filter, we only need to unwind the funclet stack. 
               For catches/finallies, the normal handling will 
               cause the frame to be unwound all the way up to ebp skipping
               other frames above it. This is OK, as those frames will be 
               dead. Also, the EE will detect that this has happened and it
               will handle any EE frames correctly.
             */

            if (frameType == FR_FILTER)
            {
                //pContext->pPC = (SLOT*)(size_t)baseSP;
                safemove(g_ctx.Eip, baseSP);
                pContext->pPC = &g_ctx.Eip;

                pContext->Esp = (DWORD)(baseSP + sizeof(void*));

             // pContext->pEbp = same as before;
                
#if 0
#ifdef _DEBUG
                /* The filter has to be called by the VM. So we dont need to
                   update callee-saved registers.
                 */

                if (flags & UpdateAllRegs)
                {
                    static DWORD s_badData = 0xDEADBEEF;
                    
                    pContext->pEax = pContext->pEbx = pContext->pEcx = 
                    pContext->pEdx = pContext->pEsi = pContext->pEdi = &s_badData;
                }
#endif
#endif
                return true;
            }
        }

        if (flags & UpdateAllRegs)
        {
            // Get to the first callee-saved register
            DWORD * pSavedRegs = (DWORD*)(size_t)(curEBP - stateBuf->hdrInfoBody.rawStkSize - sizeof(DWORD));

            // Start after the "push ebp, mov ebp, esp"

            DWORD offset = 0;

//#ifdef _DEBUG
            // If the first instructions are 'nop, int3', we will assume
            // that is from a JitHalt instruction and skip past it
//             if (methodStart[0] == 0x90 && methodStart[1] == 0xCC)
//                 offset += 2;
            if (IsDebugBuildEE() && methodBuf[0] == 0x90 && methodBuf[1]==0xCC)
                offset+=2;
//#endif
            offset = SKIP_MOV_REG_REG(methodStart, 
                                SKIP_PUSH_REG(methodStart, offset));

            /* make sure that we align ESP just like the method's prolog did */
            if  (stateBuf->hdrInfoBody.doubleAlign)
            {
                offset = SKIP_ARITH_REG(-8, methodStart, offset); // "and esp,-8"
                if (curEBP & 0x04)
                {
                    pSavedRegs--;
                }
            }

            // sub esp, FRAME_SIZE
            offset = SKIP_ALLOC_FRAME(stateBuf->hdrInfoBody.rawStkSize, methodStart, offset);

            /* Increment "offset" in steps to see which callee-saved
               registers have been pushed already */

#define restoreReg(reg,mask)                                            \
                                                                        \
            /* Check offset in case we are still in the prolog */       \
                                                                        \
            if ((offset < curOffs) && (stateBuf->hdrInfoBody.savedRegMask & mask))       \
            {                                                           \
                /*pContext->p##reg = pSavedRegs--;*/                    \
                safemove(g_ctx.##reg, pSavedRegs);                      \
                pContext->p##reg = &g_ctx.##reg;                        \
                offset = SKIP_PUSH_REG(methodStart, offset) ; /* "push reg" */ \
            }

            restoreReg(Edi,RM_EDI);
            restoreReg(Esi,RM_ESI);
            restoreReg(Ebx,RM_EBX);

#undef restoreReg
        }

        /* The caller's ESP will be equal to EBP + retAddrSize + argSize.
           Note varargs is caller-popped. */

        pContext->Esp = (DWORD)(curEBP + 
                                (RETURN_ADDR_OFFS+1)*sizeof(void *) +
                                (stateBuf->hdrInfoBody.varargs ? 0 : stateBuf->hdrInfoBody.argSize));

        /* The caller's saved EIP is right after our EBP */
        safemove(g_ctx.Eip, (curEBP + (sizeof(DWORD) * RETURN_ADDR_OFFS)));
        pContext->pPC = &g_ctx.Eip;

        /* The caller's saved EBP is pointed to by our EBP */
        safemove(g_ctx.Ebp, curEBP);
        pContext->pEbp = &g_ctx.Ebp;
    }

    return true;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - EECodeManager::UnwindStackFrame (EETwain.cpp)");
    return false;
#endif // _X86_
}

/*****************************************************************************
 *
 *  Decodes the methodInfoPtr and returns the decoded information
 *  in the hdrInfo struct.  The EIP parameter is the PC location
 *  within the active method.
 */
static size_t   crackMethodInfoHdr(BYTE *         methodInfoPtr,
                                   unsigned       curOffset,
                                   hdrInfo       *infoPtr)
{
    BYTE * table = (BYTE *) methodInfoPtr;

    table += decodeUnsigned(table, &infoPtr->methodSize);

    assert(curOffset >= 0);
    assert(curOffset <= infoPtr->methodSize);

    /* Decode the InfoHdr */

    InfoHdr header;
    memset(&header, 0, sizeof(InfoHdr));

    BYTE headerEncoding = *table++;

    decodeHeaderFirst(headerEncoding, &header);

    BYTE encoding = headerEncoding;

    while (encoding & 0x80)
    {
        encoding = *table++;
        decodeHeaderNext(encoding, &header);
    }

    {
        unsigned count = 0xffff;
        if (header.untrackedCnt == count)
        {
            table += decodeUnsigned(table, &count);
            header.untrackedCnt = count;
        }
    }

    {
        unsigned count = 0xffff;
        if (header.varPtrTableSize == count)
        {
            table += decodeUnsigned(table, &count);
            header.varPtrTableSize = count;
        }
    }

    /* Some sanity checks on header */

    assert( header.prologSize + 
           (size_t)(header.epilogCount*header.epilogSize) <= infoPtr->methodSize);
    assert( header.epilogCount == 1 || !header.epilogAtEnd);

    assert( header.untrackedCnt <= header.argCount+header.frameSize);

    assert(!header.ebpFrame || !header.doubleAlign  );
    assert( header.ebpFrame || !header.security     );
    assert( header.ebpFrame || !header.handlers     );
    assert( header.ebpFrame || !header.localloc     );
    assert( header.ebpFrame || !header.editNcontinue);  // @TODO : Esp frames NYI for EnC

    /* Initialize the infoPtr struct */

    infoPtr->argSize         = header.argCount * 4;
    infoPtr->ebpFrame        = header.ebpFrame;
    infoPtr->interruptible   = header.interruptible;

    infoPtr->prologSize      = header.prologSize;
    infoPtr->epilogSize      = header.epilogSize;
    infoPtr->epilogCnt       = header.epilogCount;
    infoPtr->epilogEnd       = header.epilogAtEnd;

    infoPtr->untrackedCnt    = header.untrackedCnt;
    infoPtr->varPtrTableSize = header.varPtrTableSize;

    infoPtr->doubleAlign     = header.doubleAlign;
    infoPtr->securityCheck   = header.security;
    infoPtr->handlers        = header.handlers;
    infoPtr->localloc        = header.localloc;
    infoPtr->editNcontinue   = header.editNcontinue;
    infoPtr->varargs         = header.varargs;

    /* Are we within the prolog of the method? */

    if  (curOffset < infoPtr->prologSize)
    {
        infoPtr->prologOffs = curOffset;
    }
    else
    {
        infoPtr->prologOffs = -1;
    }

    /* Assume we're not in the epilog of the method */

    infoPtr->epilogOffs = -1;

    /* Are we within an epilog of the method? */

    if  (infoPtr->epilogCnt)
    {
        unsigned epilogStart;

        if  (infoPtr->epilogCnt > 1 || !infoPtr->epilogEnd)
        {
#if VERIFY_GC_TABLES
            assert(*castto(table, unsigned short *)++ == 0xFACE);
#endif
            epilogStart = 0;
            for (unsigned i = 0; i < infoPtr->epilogCnt; i++)
            {
                table += decodeUDelta(table, &epilogStart, epilogStart);
                if  (curOffset > epilogStart &&
                     curOffset < epilogStart + infoPtr->epilogSize)
                {
                    infoPtr->epilogOffs = curOffset - epilogStart;
                }
            }
        }
        else
        {
            epilogStart = infoPtr->methodSize - infoPtr->epilogSize;

            if  (curOffset > epilogStart &&
                 curOffset < epilogStart + infoPtr->epilogSize)
            {
                infoPtr->epilogOffs = curOffset - epilogStart;
            }
        }
    }

    size_t frameSize = header.frameSize;

    /* Set the rawStackSize to the number of bytes that it bumps ESP */

    infoPtr->rawStkSize = (UINT)(frameSize * sizeof(size_t));

    /* Calculate the callee saves regMask and adjust stackSize to */
    /* include the callee saves register spills                   */

    unsigned savedRegs = RM_NONE;

    if  (header.ediSaved)
    {
        frameSize++;
        savedRegs |= RM_EDI;
    }
    if  (header.esiSaved)
    {
        frameSize++;
        savedRegs |= RM_ESI;
    }
    if  (header.ebxSaved)
    {
        frameSize++;
        savedRegs |= RM_EBX;
    }
    if  (header.ebpSaved)
    {
        frameSize++;
        savedRegs |= RM_EBP;
    }

    infoPtr->savedRegMask = (RegMask)savedRegs;

    infoPtr->stackSize  =  (UINT)(frameSize * sizeof(size_t));

    return  table - ((BYTE *) methodInfoPtr);
}

void GetThreadList(DWORD_PTR *&threadList, int &numThread);

DWORD_PTR GetThread()
{
    DWORD_PTR *rgThreads;
    int cThreads;

    ULONG id;
    g_ExtSystem->GetCurrentThreadSystemId(&id);

    GetThreadList(rgThreads, cThreads);

    Thread vThread;

    for (int i = 0; i < cThreads; i++)
    {
        DWORD_PTR pThread = rgThreads[i];
        vThread.Fill(rgThreads[i]);

        if (vThread.m_ThreadId == (DWORD)id)
            return vThread.m_vLoadAddr;
    }

    return (0);
}

StackWalkAction StackTraceCallBack(CrawlFrame *pCF, VOID* pData)
{
    if (pCF->pFunc != NULL)
    {
        if (!pCF->isFrameless)
            dprintf("[FRAMED] ");

        DumpMDInfo(pCF->pFunc->m_vLoadAddr, TRUE);
    }
    else if (pCF->pFrame != NULL)
    {
        dprintf("[FRAME] %S. ESP: 0x%08x\n", pCF->pFrame->GetFrameTypeName(), pCF->pFrame->m_vLoadAddr);
    }

    return SWA_CONTINUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//

void TrueStackTrace()
{
    ULONG id;
    g_ExtSystem->GetCurrentThreadId(&id);
    dprintf("Thread %d\n", id);

    DWORD_PTR pThread = GetThread();

    if (pThread == 0)
    {
        dprintf("Not a managed thread.\n");
        return;
    }

    Thread vThread;
    vThread.Fill(pThread);

    REGDISPLAY rd;
    CONTEXT ctx;
    vThread.InitRegDisplay(&rd, &ctx, false);

    vThread.StackWalkFramesEx(&rd, &StackTraceCallBack, NULL, 0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"SOS.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft NTSD extension for .NET Runtime\0"
#define VER_ORIGFILENAME_STR    "SOS.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\disasm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __disasm_h__
#define __disasm_h__

struct DumpStackFlag
{
    BOOL fEEonly;
    DWORD_PTR top;
    DWORD_PTR end;
};

void Unassembly (DWORD_PTR IPBegin, DWORD_PTR IPEnd);

void DumpStackDummy (DumpStackFlag &DSFlag);
void DumpStackSmart (DumpStackFlag &DSFlag);

void DumpStackObjectsHelper (size_t StackTop, size_t StackBottom);

void UnassemblyUnmanaged (DWORD_PTR IP);

BOOL GetCalleeSite (DWORD_PTR IP, DWORD_PTR &IPCallee);

BOOL CheckEEDll ();

void DisasmAndClean (DWORD_PTR &IP, char *line, ULONG length);

INT_PTR GetValueFromExpr(char *ptr, INT_PTR &value);

void NextTerm (char *& ptr);

BOOL IsByRef (char *& ptr);

BOOL IsTermSep (char ch);

const char * HelperFuncName (size_t IP);

#endif // __disasm_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\inc\basetsd.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    basetsd.h

Abstract:

    Type definitions for the basic sized types.

Author:

Revision History:

--*/

#ifndef _BASETSD_H_
#define _BASETSD_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef signed char         INT8, *PINT8;
typedef signed short        INT16, *PINT16;
typedef signed int          INT32, *PINT32;
typedef signed __int64      INT64, *PINT64;
typedef unsigned char       UINT8, *PUINT8;
typedef unsigned short      UINT16, *PUINT16;
typedef unsigned int        UINT32, *PUINT32;
typedef unsigned __int64    UINT64, *PUINT64;

//
// The following types are guaranteed to be signed and 32 bits wide.
//

typedef signed int LONG32, *PLONG32;

//
// The following types are guaranteed to be unsigned and 32 bits wide.
//

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//
#if ( 501 < __midl )

    typedef [public] __int3264 INT_PTR, *PINT_PTR;
    typedef [public] unsigned __int3264 UINT_PTR, *PUINT_PTR;

    typedef [public] __int3264 LONG_PTR, *PLONG_PTR;
    typedef [public] unsigned __int3264 ULONG_PTR, *PULONG_PTR;

#else  // midl64
// old midl and C++ compiler

#if defined(_WIN64)
    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int64

#else
    typedef _W64 int INT_PTR, *PINT_PTR;
    typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

    typedef _W64 long LONG_PTR, *PLONG_PTR;
    typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int32

#endif
#endif // midl64

//
// HALF_PTR is half the size of a pointer it intended for use with
// within strcuture which contain a pointer and two small fields.
// UHALF_PTR is the unsigned variation.
//

#ifdef _WIN64

#define ADDRESS_TAG_BIT 0x40000000000UI64

typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;

#pragma warning(disable:4311)   // type cast truncation
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4305)   // type cast truncation

#if !defined(__midl)
__inline
unsigned long
HandleToULong(
    const void *h
    )
{
    return((unsigned long) h );
}

__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) h );
}

__inline
void *
ULongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}


__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}


__inline
unsigned long
PtrToUlong(
    const void  *p
    )
{
    return((unsigned long) p );
}

__inline
unsigned int
PtrToUint(
    const void  *p
    )
{
    return((unsigned int) p );
}

__inline
unsigned short
PtrToUshort(
    const void  *p
    )
{
    return((unsigned short) p );
}

__inline
long
PtrToLong(
    const void  *p
    )
{
    return((long) p );
}

__inline
int
PtrToInt(
    const void  *p
    )
{
    return((int) p );
}

__inline
short
PtrToShort(
    const void  *p
    )
{
    return((short) p );
}

__inline
void *
IntToPtr(
    const int i
    )
// Caution: IntToPtr() sign-extends the int value.
{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}

__inline
void *
LongToPtr(
    const long l
    )
// Caution: LongToPtr() sign-extends the long value.
{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
ULongToPtr(
    const unsigned long ul
    )
// Caution: ULongToPtr() zero-extends the unsigned long value.
{
    return( (void *)(ULONG_PTR)ul );
}

#endif // !_midl
#if _MSC_VER >= 1200
#pragma warning(pop)      // restore 4305
#endif
#pragma warning(3:4311)   // bump 4311 to a level 3

#else  // !_WIN64

#define ADDRESS_TAG_BIT 0x80000000UL

typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef _W64 unsigned long HANDLE_PTR;

#define HandleToULong( h ) ((ULONG)(ULONG_PTR)(h) )
#define HandleToLong( h )  ((LONG)(LONG_PTR) (h) )
#define ULongToHandle( ul ) ((HANDLE)(ULONG_PTR) (ul) )
#define LongToHandle( h )   ((HANDLE)(LONG_PTR) (h) )
#define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
#define PtrToLong( p )  ((LONG)(LONG_PTR) (p) )
#define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
#define PtrToInt( p )  ((INT)(INT_PTR) (p) )
#define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
#define PtrToShort( p )  ((short)(LONG_PTR)(p) )
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
#define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
#define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
#define ULongToPtr( ul ) ((VOID *)(ULONG_PTR)((unsigned long)ul))

#endif // !_WIN64

#define HandleToUlong(h)  HandleToULong(h)
#define UlongToHandle(ul) ULongToHandle(ul)
#define UlongToPtr(ul) ULongToPtr(ul)
#define UintToPtr(ui)  UIntToPtr(ui)

#define MAXUINT_PTR  (~((UINT_PTR)0))
#define MAXINT_PTR   ((INT_PTR)(MAXUINT_PTR >> 1))
#define MININT_PTR   (~MAXINT_PTR)

#define MAXULONG_PTR (~((ULONG_PTR)0))
#define MAXLONG_PTR  ((LONG_PTR)(MAXULONG_PTR >> 1))
#define MINLONG_PTR  (~MAXLONG_PTR)

#define MAXUHALF_PTR ((UHALF_PTR)~0)
#define MAXHALF_PTR  ((HALF_PTR)(MAXUHALF_PTR >> 1))
#define MINHALF_PTR  (~MAXHALF_PTR)

//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//

typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;

//
// Add Windows flavor DWORD_PTR types
//

typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

//
// The following types are guaranteed to be signed and 64 bits wide.
//

typedef __int64 LONG64, *PLONG64;


//
// The following types are guaranteed to be unsigned and 64 bits wide.
//

typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;

//
// Thread affinity.
//

typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;

#ifdef __cplusplus
}
#endif

#endif // _BASETSD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\utilx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "data.h"
#include "eestructs.h"
#include "util.h"
#include "gcinfo.h"

size_t FASTCALL decodeUnsigned(const BYTE *src, unsigned* val);
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the begin and end of the code for a managed function.        *  
*                                                                      *
\**********************************************************************/
void CodeInfoForMethodDesc (MethodDesc &MD, CodeInfo &infoHdr, BOOL bSimple)
{
    infoHdr.IPBegin = 0;
    infoHdr.methodSize = 0;
    
    size_t ip = MD.m_CodeOrIL;

    // for EJit and Profiler, m_CodeOrIL has the address of a stub
    unsigned char ch;
    move (ch, ip);
    if (ch == 0xe9)
    {
        int offsetValue;
        move (offsetValue, ip + 1);
        ip = ip + 5 + offsetValue;
    }
    
    DWORD_PTR methodDesc;
    IP2MethodDesc (ip, methodDesc, infoHdr.jitType, infoHdr.gcinfoAddr);
    if (!methodDesc || infoHdr.jitType == UNKNOWN)
    {
        dprintf ("Not jitted code\n");
        return;
    }

    if (infoHdr.jitType == JIT || infoHdr.jitType == PJIT)
    {
        DWORD_PTR vAddr = infoHdr.gcinfoAddr;
        BYTE tmp[8];
        // We avoid using move here, because we do not want to return
        if (!SafeReadMemory (vAddr, &tmp, 8, NULL))
        {
            dprintf ("Fail to read memory at %x\n", vAddr);
            return;
        }
        decodeUnsigned(tmp, &infoHdr.methodSize);
        if (!bSimple)
        {
            // assume that GC encoding table is never more than
            // 40 + methodSize * 2
            int tableSize = 40 + infoHdr.methodSize*2;
            BYTE *table = (BYTE*) _alloca (tableSize);
            memset (table, 0, tableSize);
            // We avoid using move here, because we do not want to return
            if (!SafeReadMemory(vAddr, table, tableSize, NULL))
            {
                dprintf ("Could not read memory %x\n", vAddr);
                return;
            }
        
            InfoHdr vheader;
            InfoHdr *header = &vheader;
            unsigned count;
        
            table += decodeUnsigned(table, &infoHdr.methodSize);

            BYTE headerEncoding = *table++;

            decodeHeaderFirst(headerEncoding, header);
            while (headerEncoding & 0x80)
            {
                headerEncoding = *table++;
                decodeHeaderNext(headerEncoding, header);
            }

            if (header->untrackedCnt == 0xffff)
            {
                table += decodeUnsigned(table, &count);
                header->untrackedCnt = (unsigned short)count;
            }

            if (header->varPtrTableSize == 0xffff)
            {
                table += decodeUnsigned(table, &count);
                header->varPtrTableSize = (unsigned short)count;
            }

            infoHdr.prologSize = header->prologSize;
            infoHdr.epilogStart = header->epilogSize;
            infoHdr.epilogCount = header->epilogCount;
            infoHdr.epilogAtEnd = header->epilogAtEnd;
            infoHdr.ediSaved = header->ediSaved;
            infoHdr.esiSaved = header->esiSaved;
            infoHdr.ebxSaved = header->ebxSaved;
            infoHdr.ebpSaved = header->ebpSaved;
            infoHdr.ebpFrame = header->ebpFrame;
            infoHdr.argCount = header->argCount * sizeof(void*);
            
            if  (header->epilogCount > 1 || (header->epilogCount != 0 &&
                                             header->epilogAtEnd == 0))
            {
                unsigned offs = 0;

                //for (unsigned i = 0; i < header->epilogCount; i++)
                {
                    table += decodeUDelta(table, &offs, offs);
                    infoHdr.epilogStart = (unsigned char)offs;
                    //break;
                }
            }
            else
            {
                if  (header->epilogCount)
                    infoHdr.epilogStart = (unsigned char)(infoHdr.methodSize
                        - infoHdr.epilogStart);
            }
        }
    }
    else if (infoHdr.jitType == EJIT)
    {
        JittedMethodInfo jittedMethodInfo;
        move (jittedMethodInfo, MD.m_CodeOrIL);
        BYTE* pEhGcInfo = jittedMethodInfo.u2.pEhGcInfo;
        if ((unsigned)pEhGcInfo & 1)
            pEhGcInfo = (BYTE*) ((unsigned) pEhGcInfo & ~1);       // lose the mark bit
        else    // code has not been pitched, and it is guaranteed to not be pitched while we are here
        {
            CodeHeader* pCodeHeader = jittedMethodInfo.u1.pCodeHeader;
            move (pEhGcInfo, pCodeHeader-1);
        }
        
        if (jittedMethodInfo.flags.EHInfoExists)
        {
            short cEHbytes;
            move (cEHbytes, pEhGcInfo);
            pEhGcInfo = (pEhGcInfo + cEHbytes);
        }
        Fjit_hdrInfo hdrInfo;
        DWORD_PTR dwAddr = (DWORD_PTR)pEhGcInfo;
        hdrInfo.Fill(dwAddr);
        infoHdr.methodSize = (unsigned)hdrInfo.methodSize;
        if (!bSimple)
        {
            infoHdr.prologSize = hdrInfo.prologSize;
            infoHdr.epilogStart = (unsigned char)(infoHdr.methodSize - hdrInfo.epilogSize);
            infoHdr.epilogCount = 1;
            infoHdr.epilogAtEnd = 1;
            infoHdr.ediSaved = 1;
            infoHdr.esiSaved = 1;
            infoHdr.ebxSaved = 1;
            infoHdr.ebpSaved = 1;
            infoHdr.ebpFrame = 1;
            infoHdr.argCount = hdrInfo.methodArgsSize;
        }
    }
    
    infoHdr.IPBegin = ip;
}





/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to determine if a DWORD on the stack is   *  
*    a return address.
*    It does this by checking several bytes before the DWORD to see if *
*    there is a call instruction.                                      *
*                                                                      *
\**********************************************************************/
void isRetAddr(DWORD_PTR retAddr, DWORD_PTR* whereCalled)
{
    *whereCalled = 0;
    // don't waste time values clearly out of range
    if (retAddr < 0x1000 || retAddr > 0x80000000)   
        return;

    unsigned char spotend[6];
    move (spotend, retAddr-6);
    unsigned char *spot = spotend+6;
    DWORD_PTR addr;
    
    // Note this is possible to be spoofed, but pretty unlikely
    // call XXXXXXXX
    if (spot[-5] == 0xE8) {
        move (*whereCalled, retAddr-4);
        *whereCalled += retAddr;
        //*whereCalled = *((int*) (retAddr-4)) + retAddr;
        if (*whereCalled < 0x80000000 && *whereCalled > 0x1000)
            return;
        else
            *whereCalled = 0;
    }

    // call [XXXXXXXX]
    if (spot[-6] == 0xFF && (spot[-5] == 025))  {
        move (addr, retAddr-4);
        move (*whereCalled, addr);
        //*whereCalled = **((unsigned**) (retAddr-4));
        if (*whereCalled < 0x80000000 && *whereCalled > 0x1000)
            return;
        else
            *whereCalled = 0;
    }

    // call [REG+XX]
    if (spot[-3] == 0xFF && (spot[-2] & ~7) == 0120 && (spot[-2] & 7) != 4)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    if (spot[-4] == 0xFF && spot[-3] == 0124)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }

    // call [REG+XXXX]
    if (spot[-6] == 0xFF && (spot[-5] & ~7) == 0220 && (spot[-5] & 7) != 4)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    if (spot[-7] == 0xFF && spot[-6] == 0224)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    
    // call [REG]
    if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0020 && (spot[-1] & 7) != 4 && (spot[-1] & 7) != 5)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    
    // call REG
    if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0320 && (spot[-1] & 7) != 4)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    
    // There are other cases, but I don't believe they are used.
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\disasmia64.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include "disasm.h"
#ifndef UNDER_CE
#include <dbghelp.h>
#endif



/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Unassembly a managed code.  Translating managed object,           *  
*    call.                                                             *
*                                                                      *
\**********************************************************************/
void Unassembly (DWORD_PTR IPBegin, DWORD_PTR IPEnd)
{
    dprintf("Unassembly not yet implemented\n");

    ULONG_PTR IP = IPBegin;
    char line[256];

    while (IP < IPEnd)
    {
        if (IsInterrupt())
            return;

        DisasmAndClean(IP, line, 256);

        dprintf(line);

        //
        // @TODO: need to implement this
        //

        dprintf("\n");
    }
}


void DumpStackDummy (DumpStackFlag &DSFlag)
{
    dprintf("DumpStackDummy not yet implemented\n");
}

void DumpStackSmart (DumpStackFlag &DSFlag)
{
    dprintf("DumpStackSmart not yet implemented\n");
}


void DumpStackObjectsHelper (size_t StackTop, size_t StackBottom)
{
    dprintf("DumpStackObjectsHelper not yet implemented\n");
}

// Find the real callee site.  Handle JMP instruction.
// Return TRUE if we get the address, FALSE if not.
BOOL GetCalleeSite (DWORD_PTR IP, DWORD_PTR &IPCallee)
{
    dprintf("GetCalleeSite not yet implemented\n");
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\inc\dbgeng.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//----------------------------------------------------------------------------
//
// Debugger engine interfaces.
//
//----------------------------------------------------------------------------

#ifndef __DBGENG_H__
#define __DBGENG_H__

#include <stdarg.h>
#include <objbase.h>

#ifndef _WDBGEXTS_
typedef struct _WINDBG_EXTENSION_APIS32* PWINDBG_EXTENSION_APIS32;
typedef struct _WINDBG_EXTENSION_APIS64* PWINDBG_EXTENSION_APIS64;
#endif

#ifndef _CRASHLIB_
typedef struct _MEMORY_BASIC_INFORMATION64* PMEMORY_BASIC_INFORMATION64;
#endif

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//
// GUIDs and interface forward declarations.
//
//----------------------------------------------------------------------------

/* f2df5f53-071f-47bd-9de6-5734c3fed689 */
DEFINE_GUID(IID_IDebugAdvanced, 0xf2df5f53, 0x071f, 0x47bd,
            0x9d, 0xe6, 0x57, 0x34, 0xc3, 0xfe, 0xd6, 0x89);
/* 5bd9d474-5975-423a-b88b-65a8e7110e65 */
DEFINE_GUID(IID_IDebugBreakpoint, 0x5bd9d474, 0x5975, 0x423a,
            0xb8, 0x8b, 0x65, 0xa8, 0xe7, 0x11, 0x0e, 0x65);
/* 27fe5639-8407-4f47-8364-ee118fb08ac8 */
DEFINE_GUID(IID_IDebugClient, 0x27fe5639, 0x8407, 0x4f47,
            0x83, 0x64, 0xee, 0x11, 0x8f, 0xb0, 0x8a, 0xc8);
/* edbed635-372e-4dab-bbfe-ed0d2f63be81 */
DEFINE_GUID(IID_IDebugClient2, 0xedbed635, 0x372e, 0x4dab,
        0xbb, 0xfe, 0xed, 0x0d, 0x2f, 0x63, 0xbe, 0x81);
/* 5182e668-105e-416e-ad92-24ef800424ba */
DEFINE_GUID(IID_IDebugControl, 0x5182e668, 0x105e, 0x416e,
            0xad, 0x92, 0x24, 0xef, 0x80, 0x04, 0x24, 0xba);
/* d4366723-44df-4bed-8c7e-4c05424f4588 */
DEFINE_GUID(IID_IDebugControl2, 0xd4366723, 0x44df, 0x4bed,
            0x8c, 0x7e, 0x4c, 0x05, 0x42, 0x4f, 0x45, 0x88);
/* 88f7dfab-3ea7-4c3a-aefb-c4e8106173aa */
DEFINE_GUID(IID_IDebugDataSpaces, 0x88f7dfab, 0x3ea7, 0x4c3a,
            0xae, 0xfb, 0xc4, 0xe8, 0x10, 0x61, 0x73, 0xaa);
/* 7a5e852f-96e9-468f-ac1b-0b3addc4a049 */
DEFINE_GUID(IID_IDebugDataSpaces2, 0x7a5e852f, 0x96e9, 0x468f,
            0xac, 0x1b, 0x0b, 0x3a, 0xdd, 0xc4, 0xa0, 0x49);
/* 337be28b-5036-4d72-b6bf-c45fbb9f2eaa */
DEFINE_GUID(IID_IDebugEventCallbacks, 0x337be28b, 0x5036, 0x4d72,
            0xb6, 0xbf, 0xc4, 0x5f, 0xbb, 0x9f, 0x2e, 0xaa);
/* 9f50e42c-f136-499e-9a97-73036c94ed2d */
DEFINE_GUID(IID_IDebugInputCallbacks, 0x9f50e42c, 0xf136, 0x499e,
            0x9a, 0x97, 0x73, 0x03, 0x6c, 0x94, 0xed, 0x2d);
/* 4bf58045-d654-4c40-b0af-683090f356dc */
DEFINE_GUID(IID_IDebugOutputCallbacks, 0x4bf58045, 0xd654, 0x4c40,
            0xb0, 0xaf, 0x68, 0x30, 0x90, 0xf3, 0x56, 0xdc);
/* ce289126-9e84-45a7-937e-67bb18691493 */
DEFINE_GUID(IID_IDebugRegisters, 0xce289126, 0x9e84, 0x45a7,
            0x93, 0x7e, 0x67, 0xbb, 0x18, 0x69, 0x14, 0x93);
/* f2528316-0f1a-4431-aeed-11d096e1e2ab */
DEFINE_GUID(IID_IDebugSymbolGroup, 0xf2528316, 0x0f1a, 0x4431,
            0xae, 0xed, 0x11, 0xd0, 0x96, 0xe1, 0xe2, 0xab);
/* 8c31e98c-983a-48a5-9016-6fe5d667a950 */
DEFINE_GUID(IID_IDebugSymbols, 0x8c31e98c, 0x983a, 0x48a5,
            0x90, 0x16, 0x6f, 0xe5, 0xd6, 0x67, 0xa9, 0x50);
/* 3a707211-afdd-4495-ad4f-56fecdf8163f */
DEFINE_GUID(IID_IDebugSymbols2, 0x3a707211, 0xafdd, 0x4495,
            0xad, 0x4f, 0x56, 0xfe, 0xcd, 0xf8, 0x16, 0x3f);
/* 6b86fe2c-2c4f-4f0c-9da2-174311acc327 */
DEFINE_GUID(IID_IDebugSystemObjects, 0x6b86fe2c, 0x2c4f, 0x4f0c,
            0x9d, 0xa2, 0x17, 0x43, 0x11, 0xac, 0xc3, 0x27);
/* 0ae9f5ff-1852-4679-b055-494bee6407ee */
DEFINE_GUID(IID_IDebugSystemObjects2, 0x0ae9f5ff, 0x1852, 0x4679,
            0xb0, 0x55, 0x49, 0x4b, 0xee, 0x64, 0x07, 0xee);

typedef interface DECLSPEC_UUID("f2df5f53-071f-47bd-9de6-5734c3fed689")
    IDebugAdvanced* PDEBUG_ADVANCED;
typedef interface DECLSPEC_UUID("5bd9d474-5975-423a-b88b-65a8e7110e65")
    IDebugBreakpoint* PDEBUG_BREAKPOINT;
typedef interface DECLSPEC_UUID("27fe5639-8407-4f47-8364-ee118fb08ac8")
    IDebugClient* PDEBUG_CLIENT;
typedef interface DECLSPEC_UUID("edbed635-372e-4dab-bbfe-ed0d2f63be81")
    IDebugClient2* PDEBUG_CLIENT2;
typedef interface DECLSPEC_UUID("5182e668-105e-416e-ad92-24ef800424ba")
    IDebugControl* PDEBUG_CONTROL;
typedef interface DECLSPEC_UUID("d4366723-44df-4bed-8c7e-4c05424f4588")
    IDebugControl2* PDEBUG_CONTROL2;
typedef interface DECLSPEC_UUID("88f7dfab-3ea7-4c3a-aefb-c4e8106173aa")
    IDebugDataSpaces* PDEBUG_DATA_SPACES;
typedef interface DECLSPEC_UUID("7a5e852f-96e9-468f-ac1b-0b3addc4a049")
    IDebugDataSpaces2* PDEBUG_DATA_SPACES2;
typedef interface DECLSPEC_UUID("337be28b-5036-4d72-b6bf-c45fbb9f2eaa")
    IDebugEventCallbacks* PDEBUG_EVENT_CALLBACKS;
typedef interface DECLSPEC_UUID("9f50e42c-f136-499e-9a97-73036c94ed2d")
    IDebugInputCallbacks* PDEBUG_INPUT_CALLBACKS;
typedef interface DECLSPEC_UUID("4bf58045-d654-4c40-b0af-683090f356dc")
    IDebugOutputCallbacks* PDEBUG_OUTPUT_CALLBACKS;
typedef interface DECLSPEC_UUID("ce289126-9e84-45a7-937e-67bb18691493")
    IDebugRegisters* PDEBUG_REGISTERS;
typedef interface DECLSPEC_UUID("f2528316-0f1a-4431-aeed-11d096e1e2ab")
    IDebugSymbolGroup* PDEBUG_SYMBOL_GROUP;
typedef interface DECLSPEC_UUID("8c31e98c-983a-48a5-9016-6fe5d667a950")
    IDebugSymbols* PDEBUG_SYMBOLS;
typedef interface DECLSPEC_UUID("3a707211-afdd-4495-ad4f-56fecdf8163f")
    IDebugSymbols2* PDEBUG_SYMBOLS2;
typedef interface DECLSPEC_UUID("6b86fe2c-2c4f-4f0c-9da2-174311acc327")
    IDebugSystemObjects* PDEBUG_SYSTEM_OBJECTS;
typedef interface DECLSPEC_UUID("0ae9f5ff-1852-4679-b055-494bee6407ee")
    IDebugSystemObjects2* PDEBUG_SYSTEM_OBJECTS2;

//----------------------------------------------------------------------------
//
// Macros.
//
//----------------------------------------------------------------------------

// Extends a 32-bit address into a 64-bit address.
#define DEBUG_EXTEND64(Addr) ((ULONG64)(LONG64)(LONG)(Addr))
    
//----------------------------------------------------------------------------
//
// Client creation functions.
//
//----------------------------------------------------------------------------

// RemoteOptions specifies connection types and
// their parameters.  Supported strings are:
//    npipe:Server=<Machine>,Pipe=<Pipe name>
//    tcp:Server=<Machine>,Port=<IP port>
STDAPI
DebugConnect(
    IN PCSTR RemoteOptions,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );

STDAPI
DebugCreate(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );
    
//----------------------------------------------------------------------------
//
// IDebugAdvanced.
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugAdvanced
DECLARE_INTERFACE_(IDebugAdvanced, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugAdvanced.

    // Get/SetThreadContext offer control over
    // the full processor context for a thread.
    // Higher-level functions, such as the
    // IDebugRegisters interface, allow similar
    // access in simpler and more generic ways.
    // Get/SetThreadContext are useful when
    // large amounts of thread context must
    // be changed and processor-specific code
    // is not a problem.
    STDMETHOD(GetThreadContext)(
        THIS_
        OUT /* align_is(16) */ PVOID Context,
        IN ULONG ContextSize
        ) PURE;
    STDMETHOD(SetThreadContext)(
        THIS_
        IN /* align_is(16) */ PVOID Context,
        IN ULONG ContextSize
        ) PURE;
};
    
//----------------------------------------------------------------------------
//
// IDebugBreakpoint.
//
//----------------------------------------------------------------------------

// Types of breakpoints.
#define DEBUG_BREAKPOINT_CODE 0
#define DEBUG_BREAKPOINT_DATA 1

// Breakpoint flags.
// Go-only breakpoints are only active when
// the engine is in unrestricted execution
// mode.  They do not fire when the engine
// is stepping.
#define DEBUG_BREAKPOINT_GO_ONLY    0x00000001
// A breakpoint is flagged as deferred as long as
// its offset expression cannot be evaluated.
// A deferred breakpoint is not active.
#define DEBUG_BREAKPOINT_DEFERRED   0x00000002
#define DEBUG_BREAKPOINT_ENABLED    0x00000004
// The adder-only flag does not affect breakpoint
// operation.  It is just a marker to restrict
// output and notifications for the breakpoint to
// the client that added the breakpoint.  Breakpoint
// callbacks for adder-only breaks will only be delivered
// to the adding client.  The breakpoint can not
// be enumerated and accessed by other clients.
#define DEBUG_BREAKPOINT_ADDER_ONLY 0x00000008

// Data breakpoint access types.
// Different architectures support different
// sets of these bits.
#define DEBUG_BREAK_READ    0x00000001
#define DEBUG_BREAK_WRITE   0x00000002
#define DEBUG_BREAK_EXECUTE 0x00000004
#define DEBUG_BREAK_IO      0x00000008

// Structure for querying breakpoint information
// all at once.
typedef struct _DEBUG_BREAKPOINT_PARAMETERS
{
    ULONG64 Offset;
    ULONG Id;
    ULONG BreakType;
    ULONG ProcType;
    ULONG Flags;
    ULONG DataSize;
    ULONG DataAccessType;
    ULONG PassCount;
    ULONG CurrentPassCount;
    ULONG MatchThread;
    ULONG CommandSize;
    ULONG OffsetExpressionSize;
} DEBUG_BREAKPOINT_PARAMETERS, *PDEBUG_BREAKPOINT_PARAMETERS;

#undef INTERFACE
#define INTERFACE IDebugBreakpoint
DECLARE_INTERFACE_(IDebugBreakpoint, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugBreakpoint.
    
    // Retrieves debugger engine unique ID
    // for the breakpoint.  This ID is
    // fixed as long as the breakpoint exists
    // but after that may be reused.
    STDMETHOD(GetId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    // Retrieves the type of break and
    // processor type for the breakpoint.
    STDMETHOD(GetType)(
        THIS_
        OUT PULONG BreakType,
        OUT PULONG ProcType
        ) PURE;
    // Returns the client that called AddBreakpoint.
    STDMETHOD(GetAdder)(
        THIS_
        OUT PDEBUG_CLIENT* Adder
        ) PURE;
        
    STDMETHOD(GetFlags)(
        THIS_
        OUT PULONG Flags
        ) PURE;
    // Only certain flags can be changed.  Flags
    // are: GO_ONLY, ENABLE.
    // Sets the given flags.
    STDMETHOD(AddFlags)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // Clears the given flags.
    STDMETHOD(RemoveFlags)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // Sets the flags.
    STDMETHOD(SetFlags)(
        THIS_
        IN ULONG Flags
        ) PURE;
        
    // Controls the offset of the breakpoint.  The
    // interpretation of the offset value depends on
    // the type of breakpoint and its settings.  It
    // may be a code address, a data address, an
    // I/O port, etc.
    STDMETHOD(GetOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(SetOffset)(
        THIS_
        IN ULONG64 Offset
        ) PURE;

    // Data breakpoint methods will fail is the
    // target platform does not support the
    // parameters used.
    // These methods only function for breakpoints
    // created as data breakpoints.
    STDMETHOD(GetDataParameters)(
        THIS_
        OUT PULONG Size,
        OUT PULONG AccessType
        ) PURE;
    STDMETHOD(SetDataParameters)(
        THIS_
        IN ULONG Size,
        IN ULONG AccessType
        ) PURE;
                    
    // Pass count defaults to one.
    STDMETHOD(GetPassCount)(
        THIS_
        OUT PULONG Count
        ) PURE;
    STDMETHOD(SetPassCount)(
        THIS_
        IN ULONG Count
        ) PURE;
    // Gets the current number of times
    // the breakpoint has been hit since
    // it was last triggered.
    STDMETHOD(GetCurrentPassCount)(
        THIS_
        OUT PULONG Count
        ) PURE;

    // If a match thread is set this breakpoint will
    // only trigger if it occurs on the match thread.
    // Otherwise it triggers for all threads.
    // Thread restrictions are not currently supported
    // in kernel mode.
    STDMETHOD(GetMatchThreadId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(SetMatchThreadId)(
        THIS_
        IN ULONG Thread
        ) PURE;

    // The command for a breakpoint is automatically
    // executed by the engine before the event
    // is propagated.  If the breakpoint continues
    // execution the event will begin with a continue
    // status.  If the breakpoint does not continue
    // the event will begin with a break status.
    // This allows breakpoint commands to participate
    // in the normal event status voting.
    // Breakpoint commands are only executed until
    // the first command that alters the execution
    // status, such as g, p and t.
    // Breakpoint commands are removed when the
    // current syntax changes.
    STDMETHOD(GetCommand)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetCommand)(
        THIS_
        IN PCSTR Command
        ) PURE;

    // Offset expressions are evaluated immediately
    // and at module load and unload events.  If the
    // evaluation is successful the breakpoints
    // offset is updated and the breakpoint is
    // handled normally.  If the expression cannot
    // be evaluated the breakpoint is deferred.
    // Currently the only offset expression
    // supported is a module-relative symbol
    // of the form <Module>!<Symbol>.
    STDMETHOD(GetOffsetExpression)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExpressionSize
        ) PURE;
    STDMETHOD(SetOffsetExpression)(
        THIS_
        IN PCSTR Expression
        ) PURE;

    STDMETHOD(GetParameters)(
        THIS_
        OUT PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
};


//----------------------------------------------------------------------------
//
// IDebugClient.
//
//----------------------------------------------------------------------------

// Kernel attach flags.
#define DEBUG_ATTACH_KERNEL_CONNECTION 0x00000000
// Attach to the local machine.  If this flag is not set
// a connection is made to a separate target machine using
// the given connection options.
#define DEBUG_ATTACH_LOCAL_KERNEL      0x00000001
// Attach to an eXDI driver.
#define DEBUG_ATTACH_EXDI_DRIVER       0x00000002

// GetRunningProcessSystemIdByExecutableName flags.
// By default the match allows a tail match on
// just the filename.  The match returns the first hit
// even if multiple matches exist.
#define DEBUG_GET_PROC_DEFAULT    0x00000000
// The name must match fully.
#define DEBUG_GET_PROC_FULL_MATCH 0x00000001
// The match must be the only match.
#define DEBUG_GET_PROC_ONLY_MATCH 0x00000002

// GetRunningProcessDescription flags.
#define DEBUG_PROC_DESC_DEFAULT  0x00000000
// Return only filenames, not full paths.
#define DEBUG_PROC_DESC_NO_PATHS 0x00000001

//
// Attach flags.
//

// Call DebugActiveProcess when attaching.
#define DEBUG_ATTACH_DEFAULT     0x00000000
// When attaching to a process just examine
// the process state and suspend the threads.
// DebugActiveProcess is not called so the process
// is not actually being debugged.  This is useful
// for debugging processes holding locks which
// interfere with the operation of DebugActiveProcess
// or in situations where it is not desirable to
// actually set up as a debugger.
#define DEBUG_ATTACH_NONINVASIVE 0x00000001
// Attempt to attach to a process that was abandoned
// when being debugged.  This is only supported in
// some system versions.
// This flag also allows multiple debuggers to
// attach to the same process, which can result
// in numerous problems unless very carefully
// managed.
#define DEBUG_ATTACH_EXISTING    0x00000002

// Process creation flags.
// On Windows Whistler this flag prevents the debug
// heap from being used in the new process.
#define DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP CREATE_UNICODE_ENVIRONMENT

//
// Process options.
//

// Indicates that the debuggee process should be
// automatically detached when the debugger exits.
// A debugger can explicitly detach on exit or this
// flag can be set so that detach occurs regardless
// of how the debugger exits.
// This is only supported on some system versions.
#define DEBUG_PROCESS_DETACH_ON_EXIT    0x00000001
// Indicates that processes created by the current
// process should not be debugged.
// Modifying this flag is only supported on some
// system versions.
#define DEBUG_PROCESS_ONLY_THIS_PROCESS 0x00000002

// ConnectSession flags.
// Default connect.
#define DEBUG_CONNECT_SESSION_DEFAULT     0x00000000
// Do not output the debugger version.
#define DEBUG_CONNECT_SESSION_NO_VERSION  0x00000001
// Do not announce the connection.
#define DEBUG_CONNECT_SESSION_NO_ANNOUNCE 0x00000002

// OutputServers flags.
// Debugger servers from StartSever.
#define DEBUG_SERVERS_DEBUGGER 0x00000001
// Process servers from StartProcessServer.
#define DEBUG_SERVERS_PROCESS  0x00000002
#define DEBUG_SERVERS_ALL      0x00000003

// EndSession flags.
// Perform cleanup for the session.
#define DEBUG_END_PASSIVE          0x00000000
// Actively terminate the session and then perform cleanup.
#define DEBUG_END_ACTIVE_TERMINATE 0x00000001
// If possible, detach from all processes and then perform cleanup.
#define DEBUG_END_ACTIVE_DETACH    0x00000002
// Perform whatever cleanup is possible that doesn't require
// acquiring any locks.  This is useful for situations where
// a thread is currently using the engine but the application
// needs to exit and still wants to give the engine
// the opportunity to clean up as much as possible.
// This may leave the engine in an indeterminate state so
// further engine calls should not be made.
// When making a reentrant EndSession call from a remote
// client it is the callers responsibility to ensure
// that the server can process the request.  It is best
// to avoid making such calls.
#define DEBUG_END_REENTRANT        0x00000003

// Output mask bits.
// Normal output.
#define DEBUG_OUTPUT_NORMAL            0x00000001
// Error output.
#define DEBUG_OUTPUT_ERROR             0x00000002
// Warnings.
#define DEBUG_OUTPUT_WARNING           0x00000004
// Additional output.
#define DEBUG_OUTPUT_VERBOSE           0x00000008
// Prompt output.
#define DEBUG_OUTPUT_PROMPT            0x00000010
// Register dump before prompt.
#define DEBUG_OUTPUT_PROMPT_REGISTERS  0x00000020
// Warnings specific to extension operation.
#define DEBUG_OUTPUT_EXTENSION_WARNING 0x00000040
// Debuggee debug output, such as from OutputDebugString.
#define DEBUG_OUTPUT_DEBUGGEE          0x00000080
// Debuggee-generated prompt, such as from DbgPrompt.
#define DEBUG_OUTPUT_DEBUGGEE_PROMPT   0x00000100

// Internal debugger output, used mainly
// for debugging the debugger.  Output
// may only occur in debug builds.
// KD protocol output.
#define DEBUG_IOUTPUT_KD_PROTOCOL      0x80000000
// Remoting output.
#define DEBUG_IOUTPUT_REMOTING         0x40000000
// Breakpoint output.
#define DEBUG_IOUTPUT_BREAKPOINT       0x20000000
// Event output.
#define DEBUG_IOUTPUT_EVENT            0x10000000

// OutputIdentity flags.
#define DEBUG_OUTPUT_IDENTITY_DEFAULT 0x00000000

#undef INTERFACE
#define INTERFACE IDebugClient
DECLARE_INTERFACE_(IDebugClient, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.
    
    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        IN PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        IN ULONG Flags,
        IN PCSTR Options,
        IN PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        IN PCSTR RemoteOptions,
        OUT PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        IN ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        IN ULONG64 Server,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        IN ULONG64 Server,
        IN PCSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        IN ULONG64 Server,
        IN ULONG SystemId,
        IN ULONG Flags,
        OUT OPTIONAL PSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG64 Server,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 Server,
        IN PSTR CommandLine,
        IN ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        IN ULONG64 Server,
        IN OPTIONAL PSTR CommandLine,
        IN ULONG CreateFlags,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        IN PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        IN ULONG Flags,
        IN ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        IN PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Machine,
        IN ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        OUT PULONG Code
        ) PURE;
        
    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        IN ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        IN PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        OUT PDEBUG_CLIENT* Client
        ) PURE;
    
    STDMETHOD(GetInputCallbacks)(
        THIS_
        OUT PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        IN PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;
    
    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        OUT PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        IN PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        IN ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        IN ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        OUT PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        IN ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        IN OPTIONAL PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        OUT PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        IN PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;
};

// Per-dump-format control flags.
#define DEBUG_FORMAT_DEFAULT 0x00000000

#define DEBUG_FORMAT_USER_SMALL_FULL_MEMORY 0x00000001
#define DEBUG_FORMAT_USER_SMALL_HANDLE_DATA 0x00000002

//
// Dump information file types.
//

// Single file containing packed page file information.
#define DEBUG_DUMP_FILE_PAGE_FILE_DUMP 0x00000000

#undef INTERFACE
#define INTERFACE IDebugClient2
DECLARE_INTERFACE_(IDebugClient2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugClient.
    
    // The following set of methods start
    // the different kinds of debuggees.

    // Begins a debug session using the kernel
    // debugging protocol.  This method selects
    // the protocol as the debuggee communication
    // mechanism but does not initiate the communication
    // itself.
    STDMETHOD(AttachKernel)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PCSTR ConnectOptions
        ) PURE;
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG OptionsSize
        ) PURE;
    // Updates the connection options for a live
    // kernel connection.  This can only be used
    // to modify parameters for the connection, not
    // to switch to a completely different kind of
    // connection.
    // This method is reentrant.
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        IN PCSTR Options
        ) PURE;

    // Starts a process server for remote
    // user-mode process control.
    // The local process server is server zero.
    STDMETHOD(StartProcessServer)(
        THIS_
        IN ULONG Flags,
        IN PCSTR Options,
        IN PVOID Reserved
        ) PURE;
    STDMETHOD(ConnectProcessServer)(
        THIS_
        IN PCSTR RemoteOptions,
        OUT PULONG64 Server
        ) PURE;
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        IN ULONG64 Server
        ) PURE;

    // Enumerates and describes processes
    // accessible through the given process server.
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        IN ULONG64 Server,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        ) PURE;
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        IN ULONG64 Server,
        IN PCSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        IN ULONG64 Server,
        IN ULONG SystemId,
        IN ULONG Flags,
        OUT OPTIONAL PSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        ) PURE;

    // Attaches to a running user-mode process.
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG64 Server,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Creates a new user-mode process for debugging.
    // CreateFlags are as given to Win32s CreateProcess.
    // One of DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    // must be specified.
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 Server,
        IN PSTR CommandLine,
        IN ULONG CreateFlags
        ) PURE;
    // Creates or attaches to a user-mode process, or both.
    // If CommandLine is NULL this method operates as
    // AttachProcess does.  If ProcessId is zero it
    // operates as CreateProcess does.  If CommandLine is
    // non-NULL and ProcessId is non-zero the method first
    // starts a process with the given information but
    // in a suspended state.  The engine then attaches to
    // the indicated process.  Once the attach is successful
    // the suspended process is resumed.  This provides
    // synchronization between the new process and the
    // attachment.
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        IN ULONG64 Server,
        IN OPTIONAL PSTR CommandLine,
        IN ULONG CreateFlags,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        ) PURE;
    // Gets and sets process control flags.
    STDMETHOD(GetProcessOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    // Opens any kind of user- or kernel-mode dump file
    // and begins a debug session with the information
    // contained within it.
    STDMETHOD(OpenDumpFile)(
        THIS_
        IN PCSTR DumpFile
        ) PURE;
    // Writes a dump file from the current session information.
    // The kind of dump file written is determined by the
    // kind of session and the type qualifier given.
    // For example, if the current session is a kernel
    // debug session (DEBUG_CLASS_KERNEL) and the qualifier
    // is DEBUG_DUMP_SMALL a small kernel dump will be written.
    STDMETHOD(WriteDumpFile)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier
        ) PURE;

    // Indicates that a remote client is ready to
    // begin participating in the current session.
    // HistoryLimit gives a character limit on
    // the amount of output history to be sent.
    STDMETHOD(ConnectSession)(
        THIS_
        IN ULONG Flags,
        IN ULONG HistoryLimit
        ) PURE;
    // Indicates that the engine should start accepting
    // remote connections. Options specifies connection types
    // and their parameters.  Supported strings are:
    //    npipe:Pipe=<Pipe name>
    //    tcp:Port=<IP port>
    STDMETHOD(StartServer)(
        THIS_
        IN PCSTR Options
        ) PURE;
    // List the servers running on the given machine.
    // Uses the line prefix.
    STDMETHOD(OutputServers)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Machine,
        IN ULONG Flags
        ) PURE;

    // Attempts to terminate all processes in the debuggers list.
    STDMETHOD(TerminateProcesses)(
        THIS
        ) PURE;
    // Attempts to detach from all processes in the debuggers list.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachProcesses)(
        THIS
        ) PURE;
    // Stops the current debug session.  If a process
    // was created or attached an active EndSession can
    // terminate or detach from it.
    // If a kernel connection was opened it will be closed but the
    // target machine is otherwise unaffected.
    STDMETHOD(EndSession)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // If a process was started and ran to completion
    // this method can be used to retrieve its exit code.
    STDMETHOD(GetExitCode)(
        THIS_
        OUT PULONG Code
        ) PURE;
        
    // Client event callbacks are called on the thread
    // of the client.  In order to give thread
    // execution to the engine for callbacks all
    // client threads should call DispatchCallbacks
    // when they are idle.  Callbacks are only
    // received when a thread calls DispatchCallbacks
    // or WaitForEvent.  WaitForEvent can only be
    // called by the thread that started the debug
    // session so all other client threads should
    // call DispatchCallbacks when possible.
    // DispatchCallbacks returns when ExitDispatch is used
    // to interrupt dispatch or when the timeout expires.
    // DispatchCallbacks dispatches callbacks for all
    // clients associated with the thread calling
    // DispatchCallbacks.
    // DispatchCallbacks returns S_FALSE when the
    // timeout expires.
    STDMETHOD(DispatchCallbacks)(
        THIS_
        IN ULONG Timeout
        ) PURE;
    // ExitDispatch can be used to interrupt callback
    // dispatch when a client thread is needed by the
    // client.  This method is reentrant and can
    // be called from any thread.
    STDMETHOD(ExitDispatch)(
        THIS_
        IN PDEBUG_CLIENT Client
        ) PURE;

    // Clients are specific to the thread that
    // created them.  Calls from other threads
    // fail immediately.  The CreateClient method
    // is a notable exception; it allows creation
    // of a new client for a new thread.
    STDMETHOD(CreateClient)(
        THIS_
        OUT PDEBUG_CLIENT* Client
        ) PURE;
    
    STDMETHOD(GetInputCallbacks)(
        THIS_
        OUT PDEBUG_INPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetInputCallbacks)(
        THIS_
        IN PDEBUG_INPUT_CALLBACKS Callbacks
        ) PURE;
    
    // Output callback interfaces are described separately.
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        OUT PDEBUG_OUTPUT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        IN PDEBUG_OUTPUT_CALLBACKS Callbacks
        ) PURE;
    // Output flags provide control over
    // the distribution of output among clients.
    // Output masks select which output streams
    // should be sent to the output callbacks.
    // Only Output calls with a mask that
    // contains one of the output mask bits
    // will be sent to the output callbacks.
    // These methods are reentrant.
    // If such access is not synchronized
    // disruptions in output may occur.
    STDMETHOD(GetOutputMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOutputMask)(
        THIS_
        IN ULONG Mask
        ) PURE;
    // These methods allow access to another clients
    // output mask.  They are necessary for changing
    // a clients output mask when it is
    // waiting for events.  These methods are reentrant
    // and can be called from any thread.
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        IN ULONG Mask
        ) PURE;
    // Control the width of an output line for
    // commands which produce formatted output.
    // This setting is just a suggestion.
    STDMETHOD(GetOutputWidth)(
        THIS_
        OUT PULONG Columns
        ) PURE;
    STDMETHOD(SetOutputWidth)(
        THIS_
        IN ULONG Columns
        ) PURE;
    // Some of the engines output commands produce
    // multiple lines of output.  A prefix can be
    // set that the engine will automatically output
    // for each line in that case, allowing a caller
    // to control indentation or identifying marks.
    // This is not a general setting for any output
    // with a newline in it.  Methods which use
    // the line prefix are marked in their documentation.
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PrefixSize
        ) PURE;
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        IN OPTIONAL PCSTR Prefix
        ) PURE;

    // Returns a string describing the machine
    // and user this client represents.  The
    // specific content of the string varies
    // with operating system.  If the client is
    // remotely connected some network information
    // may also be present.
    STDMETHOD(GetIdentity)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG IdentitySize
        ) PURE;
    // Format is a printf-like format string
    // with one %s where the identity string should go.
    STDMETHOD(OutputIdentity)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN PCSTR Format
        ) PURE;

    // Event callbacks allow a client to
    // receive notification about changes
    // during the debug session.
    STDMETHOD(GetEventCallbacks)(
        THIS_
        OUT PDEBUG_EVENT_CALLBACKS* Callbacks
        ) PURE;
    STDMETHOD(SetEventCallbacks)(
        THIS_
        IN PDEBUG_EVENT_CALLBACKS Callbacks
        ) PURE;

    // The engine sometimes merges compatible callback
    // requests to reduce callback overhead.  This is
    // most noticeable with output as small pieces of
    // output are collected into larger groups to
    // reduce the overall number of output callback calls.
    // A client can use this method to force all pending
    // callbacks to be delivered.  This is rarely necessary.
    STDMETHOD(FlushCallbacks)(
        THIS
        ) PURE;

    // IDebugClient2.

    // Functions similarly to WriteDumpFile with
    // the addition of the ability to specify
    // per-dump-format write control flags.
    // Comment is not supported in all formats.
    STDMETHOD(WriteDumpFile2)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier,
        IN ULONG FormatFlags,
        IN OPTIONAL PCSTR Comment
        ) PURE;
    // Registers additional files of supporting information
    // for a dump file open.  This method must be called
    // before OpenDumpFile is called.
    // The files registered may be opened at the time
    // this method is called but generally will not
    // be used until OpenDumpFile is called.
    STDMETHOD(AddDumpInformationFile)(
        THIS_
        IN PCSTR InfoFile,
        IN ULONG Type
        ) PURE;

    // Requests that the remote process server shut down.
    STDMETHOD(EndProcessServer)(
        THIS_
        IN ULONG64 Server
        ) PURE;
    // Waits for a started process server to
    // exit.  Allows an application running a
    // process server to monitor the process
    // server so that it can tell when a remote
    // client has asked for it to exit.
    // Returns S_OK if the process server has
    // shut down and S_FALSE for a timeout.
    STDMETHOD(WaitForProcessServerEnd)(
        THIS_
        IN ULONG Timeout
        ) PURE;

    // Returns S_OK if the system is configured
    // to allow kernel debugging.
    STDMETHOD(IsKernelDebuggerEnabled)(
        THIS
        ) PURE;

    // Attempts to terminate the current process.
    // Exit process events for the process may be generated.
    STDMETHOD(TerminateCurrentProcess)(
        THIS
        ) PURE;
    // Attempts to detach from the current process.
    // This requires OS support for debugger detach.
    STDMETHOD(DetachCurrentProcess)(
        THIS
        ) PURE;
    // Removes the process from the debuggers process
    // list without making any other changes.  The process
    // will still be marked as being debugged and will
    // not run.  This allows a debugger to be shut down
    // and a new debugger attached without taking the
    // process out of the debugged state.
    // This is only supported on some system versions.
    STDMETHOD(AbandonCurrentProcess)(
        THIS
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugControl.
//
//----------------------------------------------------------------------------

// Execution status codes used for waiting,
// for returning current status and for
// event method return values.
#define DEBUG_STATUS_NO_CHANGE      0
#define DEBUG_STATUS_GO             1
#define DEBUG_STATUS_GO_HANDLED     2
#define DEBUG_STATUS_GO_NOT_HANDLED 3
#define DEBUG_STATUS_STEP_OVER      4
#define DEBUG_STATUS_STEP_INTO      5
#define DEBUG_STATUS_BREAK          6
#define DEBUG_STATUS_NO_DEBUGGEE    7
#define DEBUG_STATUS_STEP_BRANCH    8
#define DEBUG_STATUS_IGNORE_EVENT   9

#define DEBUG_STATUS_MASK           0xf

// This bit is added in DEBUG_CES_EXECUTION_STATUS
// notifications when the engines execution status
// is changing due to operations performed during
// a wait, such as making synchronous callbacks.  If
// the bit is not set the execution status is changing
// due to a wait being satisfied.
#define DEBUG_STATUS_INSIDE_WAIT 0x100000000

// Output control flags.
// Output generated by methods called by this
// client will be sent only to this clients
// output callbacks.
#define DEBUG_OUTCTL_THIS_CLIENT       0x00000000
// Output will be sent to all clients.
#define DEBUG_OUTCTL_ALL_CLIENTS       0x00000001
// Output will be sent to all clients except
// the client generating the output.
#define DEBUG_OUTCTL_ALL_OTHER_CLIENTS 0x00000002
// Output will be discarded immediately and will not
// be logged or sent to callbacks.
#define DEBUG_OUTCTL_IGNORE            0x00000003
// Output will be logged but not sent to callbacks.
#define DEBUG_OUTCTL_LOG_ONLY          0x00000004
// All send control bits.
#define DEBUG_OUTCTL_SEND_MASK         0x00000007
// Do not place output from this client in
// the global log file.
#define DEBUG_OUTCTL_NOT_LOGGED        0x00000008
// Send output to clients regardless of whether the
// mask allows it or not.
#define DEBUG_OUTCTL_OVERRIDE_MASK     0x00000010

// Special value which means leave the output settings
// unchanged.
#define DEBUG_OUTCTL_AMBIENT           0xffffffff

// Interrupt types.
// Force a break in if the debuggee is running.
#define DEBUG_INTERRUPT_ACTIVE  0
// Notify but do not force a break in.
#define DEBUG_INTERRUPT_PASSIVE 1
// Try and get the current engine operation to
// complete so that the engine will be available
// again.  If no wait is active this is the same
// as a passive interrupt.  If a wait is active
// this will try to cause the wait to fail without
// breaking in to the debuggee.  There is
// no guarantee that issuing an exit interrupt
// will cause the engine to become available
// as not all operations are arbitrarily
// interruptible.
#define DEBUG_INTERRUPT_EXIT    2

// OutputCurrentState flags.  These flags
// allow a particular type of information
// to be displayed but do not guarantee
// that it will be displayed.  Other global
// settings may override these flags or
// the particular state may not be available.
// For example, source line information may
// not be present so source line information
// may not be displayed.
#define DEBUG_CURRENT_DEFAULT     0x0000000f
#define DEBUG_CURRENT_SYMBOL      0x00000001
#define DEBUG_CURRENT_DISASM      0x00000002
#define DEBUG_CURRENT_REGISTERS   0x00000004
#define DEBUG_CURRENT_SOURCE_LINE 0x00000008

// Disassemble flags.
// Compute the effective address from current register
// information and display it.
#define DEBUG_DISASM_EFFECTIVE_ADDRESS 0x00000001
// If the current disassembly offset has an exact
// symbol match output the symbol.
#define DEBUG_DISASM_MATCHING_SYMBOLS  0x00000002

// Code interpretation levels for stepping
// and other operations.
#define DEBUG_LEVEL_SOURCE   0
#define DEBUG_LEVEL_ASSEMBLY 1

// Engine control flags.
#define DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION      0x00000001
#define DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS   0x00000002
// If neither allow nor disallow is specified
// the engine will pick one based on what kind
// of debugging is going on.
#define DEBUG_ENGOPT_ALLOW_NETWORK_PATHS         0x00000004
#define DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS      0x00000008
#define DEBUG_ENGOPT_NETWORK_PATHS               (0x00000004 | 0x00000008)
// Ignore loader-generated first-chance exceptions.
#define DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS    0x00000010
// Break in on a debuggees initial event.  In user-mode
// this will break at the initial system breakpoint
// for every created process.  In kernel-mode it
// will attempt break in on the target at the first
// WaitForEvent.
#define DEBUG_ENGOPT_INITIAL_BREAK               0x00000020
// Break in on the first module load for a debuggee.
#define DEBUG_ENGOPT_INITIAL_MODULE_BREAK        0x00000040
// Break in on a debuggees final event.  In user-mode
// this will break on process exit for every process.
// In kernel-mode it currently does nothing.
#define DEBUG_ENGOPT_FINAL_BREAK                 0x00000080
// By default Execute will repeat the last command
// if it is given an empty string.  The flags to
// Execute can override this behavior for a single
// command or this engine option can be used to
// change the default globally.
#define DEBUG_ENGOPT_NO_EXECUTE_REPEAT           0x00000100
// Disable places in the engine that have fallback
// code when presented with incomplete information.
//   1. Fails minidump module loads unless matching
//      executables can be mapped.
#define DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION 0x00000200
// Allow the debugger to manipulate page protections
// in order to insert code breakpoints on pages that
// do not have write access.  This option is not on
// by default as it allows breakpoints to be set
// in potentially hazardous memory areas.
#define DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS 0x00000400
// When using a software (bp/bu) breakpoint in code
// that will be executed by multiple threads it is
// possible for breakpoint management to cause the
// breakpoint to be missed or for spurious single-step
// exceptions to be generated.  This flag suspends
// all but the active thread when doing breakpoint
// management and thereby avoids multithreading
// problems.  Care must be taken when using it, though,
// as the suspension of threads can cause deadlocks
// if the suspended threads are holding resources that
// the active thread needs.  Additionally, there
// are still rare situations where problems may
// occur, but setting this flag corrects nearly
// all multithreading issues with software breakpoints.
// Thread-restricted stepping and execution supersedes
// this flags effect.
// This flag is ignored in kernel sessions as there
// is no way to restrict processor execution.
#define DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS     0x00000800
// Disallows executing shell commands through the
// engine with .shell (!!).
#define DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS     0x00001000
#define DEBUG_ENGOPT_ALL                         0x00001FFF

// General unspecified ID constant.
#define DEBUG_ANY_ID 0xffffffff

typedef struct _DEBUG_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[6];
    BOOL    Virtual;
    ULONG   FrameNumber;
} DEBUG_STACK_FRAME, *PDEBUG_STACK_FRAME;

// OutputStackTrace flags.
// Display a small number of arguments for each call.
// These may or may not be the actual arguments depending
// on the architecture, particular function and
// point during the execution of the function.
// If the current code level is assembly arguments
// are dumped as hex values.  If the code level is
// source the engine attempts to provide symbolic
// argument information.
#define DEBUG_STACK_ARGUMENTS               0x00000001
// Displays information about the functions
// frame such as __stdcall arguments, FPO
// information and whatever else is available.
#define DEBUG_STACK_FUNCTION_INFO           0x00000002
// Displays source line information for each
// frame of the stack trace.
#define DEBUG_STACK_SOURCE_LINE             0x00000004
// Show return, previous frame and other relevant address
// values for each frame.
#define DEBUG_STACK_FRAME_ADDRESSES         0x00000008
// Show column names.
#define DEBUG_STACK_COLUMN_NAMES            0x00000010
// Show non-volatile register context for each
// frame.  This is only meaningful for some platforms.
#define DEBUG_STACK_NONVOLATILE_REGISTERS   0x00000020
// Show frame numbers
#define DEBUG_STACK_FRAME_NUMBERS           0x00000040
// Show parameters with type name
#define DEBUG_STACK_PARAMETERS              0x00000080
// Show just return address in stack frame addresses
#define DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY 0x00000100

// Classes of debuggee.  Each class
// has different qualifiers for specific
// kinds of debuggees.
#define DEBUG_CLASS_UNINITIALIZED 0
#define DEBUG_CLASS_KERNEL        1
#define DEBUG_CLASS_USER_WINDOWS  2

// Generic dump types.  These can be used
// with either user or kernel sessions.
// Session-type-specific aliases are also
// provided.
#define DEBUG_DUMP_SMALL   1024
#define DEBUG_DUMP_DEFAULT 1025
#define DEBUG_DUMP_FULL    1026

// Specific types of kernel debuggees.
#define DEBUG_KERNEL_CONNECTION  0
#define DEBUG_KERNEL_LOCAL       1
#define DEBUG_KERNEL_EXDI_DRIVER 2
#define DEBUG_KERNEL_SMALL_DUMP  DEBUG_DUMP_SMALL
#define DEBUG_KERNEL_DUMP        DEBUG_DUMP_DEFAULT
#define DEBUG_KERNEL_FULL_DUMP   DEBUG_DUMP_FULL

// Specific types of Windows user debuggees.
#define DEBUG_USER_WINDOWS_PROCESS        0
#define DEBUG_USER_WINDOWS_PROCESS_SERVER 1
#define DEBUG_USER_WINDOWS_SMALL_DUMP     DEBUG_DUMP_SMALL
#define DEBUG_USER_WINDOWS_DUMP           DEBUG_DUMP_DEFAULT

// Extension flags.
#define DEBUG_EXTENSION_AT_ENGINE 0x00000000

// Execute and ExecuteCommandFile flags.
// These flags only apply to the command
// text itself; output from the executed
// command is controlled by the output
// control parameter.
// Default execution.  Command is logged
// but not output.
#define DEBUG_EXECUTE_DEFAULT    0x00000000
// Echo commands during execution.  In
// ExecuteCommandFile also echoes the prompt
// for each line of the file.
#define DEBUG_EXECUTE_ECHO       0x00000001
// Do not log or output commands during execution.
// Overridden by DEBUG_EXECUTE_ECHO.
#define DEBUG_EXECUTE_NOT_LOGGED 0x00000002
// If this flag is not set an empty string
// to Execute will repeat the last Execute
// string.
#define DEBUG_EXECUTE_NO_REPEAT  0x00000004

// Specific event filter types.  Some event
// filters have optional arguments to further
// qualify their operation.
#define DEBUG_FILTER_CREATE_THREAD       0x00000000
#define DEBUG_FILTER_EXIT_THREAD         0x00000001
#define DEBUG_FILTER_CREATE_PROCESS      0x00000002
#define DEBUG_FILTER_EXIT_PROCESS        0x00000003
// Argument is the name of a module to break on.
#define DEBUG_FILTER_LOAD_MODULE         0x00000004
// Argument is the base address of a specific module to break on.
#define DEBUG_FILTER_UNLOAD_MODULE       0x00000005
#define DEBUG_FILTER_SYSTEM_ERROR        0x00000006
// Initial breakpoint and initial module load are one-shot
// events that are triggered at the appropriate points in
// the beginning of a session.  Their commands are executed
// and then further processing is controlled by the normal
// exception and load module filters.
#define DEBUG_FILTER_INITIAL_BREAKPOINT  0x00000007
#define DEBUG_FILTER_INITIAL_MODULE_LOAD 0x00000008
// The debug output filter allows the debugger to stop
// when output is produced so that the code causing
// output can be tracked down or synchronized with.
// This filter is not supported for live dual-machine
// kernel debugging.
#define DEBUG_FILTER_DEBUGGEE_OUTPUT     0x00000009

// Event filter execution options.
// Break in always.
#define DEBUG_FILTER_BREAK               0x00000000
// Break in on second-chance exceptions.  For events
// that are not exceptions this is the same as BREAK.
#define DEBUG_FILTER_SECOND_CHANCE_BREAK 0x00000001
// Output a message about the event but continue.
#define DEBUG_FILTER_OUTPUT              0x00000002
// Continue the event.
#define DEBUG_FILTER_IGNORE              0x00000003
// Used to remove general exception filters.
#define DEBUG_FILTER_REMOVE              0x00000004

// Event filter continuation options.  These options are
// only used when DEBUG_STATUS_GO is used to continue
// execution.  If a specific go status such as
// DEBUG_STATUS_GO_NOT_HANDLED is used it controls
// the continuation.
#define DEBUG_FILTER_GO_HANDLED          0x00000000
#define DEBUG_FILTER_GO_NOT_HANDLED      0x00000001

// Specific event filter settings.
typedef struct _DEBUG_SPECIFIC_FILTER_PARAMETERS
{
    ULONG ExecutionOption;
    ULONG ContinueOption;
    ULONG TextSize;
    ULONG CommandSize;
    // If ArgumentSize is zero this filter does
    // not have an argument.  An empty argument for
    // a filter which does have an argument will take
    // one byte for the terminator.
    ULONG ArgumentSize;
} DEBUG_SPECIFIC_FILTER_PARAMETERS, *PDEBUG_SPECIFIC_FILTER_PARAMETERS;

// Exception event filter settings.
typedef struct _DEBUG_EXCEPTION_FILTER_PARAMETERS
{
    ULONG ExecutionOption;
    ULONG ContinueOption;
    ULONG TextSize;
    ULONG CommandSize;
    ULONG SecondCommandSize;
    ULONG ExceptionCode;
} DEBUG_EXCEPTION_FILTER_PARAMETERS, *PDEBUG_EXCEPTION_FILTER_PARAMETERS;

// Wait flags.
#define DEBUG_WAIT_DEFAULT 0x00000000

// Last event information structures.
typedef struct _DEBUG_LAST_EVENT_INFO_BREAKPOINT
{
    ULONG Id;
} DEBUG_LAST_EVENT_INFO_BREAKPOINT, *PDEBUG_LAST_EVENT_INFO_BREAKPOINT;

typedef struct _DEBUG_LAST_EVENT_INFO_EXCEPTION
{
    EXCEPTION_RECORD64 ExceptionRecord;
    ULONG FirstChance;
} DEBUG_LAST_EVENT_INFO_EXCEPTION, *PDEBUG_LAST_EVENT_INFO_EXCEPTION;

typedef struct _DEBUG_LAST_EVENT_INFO_EXIT_THREAD
{
    ULONG ExitCode;
} DEBUG_LAST_EVENT_INFO_EXIT_THREAD, *PDEBUG_LAST_EVENT_INFO_EXIT_THREAD;

typedef struct _DEBUG_LAST_EVENT_INFO_EXIT_PROCESS
{
    ULONG ExitCode;
} DEBUG_LAST_EVENT_INFO_EXIT_PROCESS, *PDEBUG_LAST_EVENT_INFO_EXIT_PROCESS;

typedef struct _DEBUG_LAST_EVENT_INFO_LOAD_MODULE
{
    ULONG64 Base;
} DEBUG_LAST_EVENT_INFO_LOAD_MODULE, *PDEBUG_LAST_EVENT_INFO_LOAD_MODULE;

typedef struct _DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE
{
    ULONG64 Base;
} DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE, *PDEBUG_LAST_EVENT_INFO_UNLOAD_MODULE;

typedef struct _DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR
{
    ULONG Error;
    ULONG Level;
} DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR, *PDEBUG_LAST_EVENT_INFO_SYSTEM_ERROR;

// DEBUG_VALUE types.
#define DEBUG_VALUE_INVALID      0
#define DEBUG_VALUE_INT8         1
#define DEBUG_VALUE_INT16        2
#define DEBUG_VALUE_INT32        3
#define DEBUG_VALUE_INT64        4
#define DEBUG_VALUE_FLOAT32      5
#define DEBUG_VALUE_FLOAT64      6
#define DEBUG_VALUE_FLOAT80      7
#define DEBUG_VALUE_FLOAT82      8
#define DEBUG_VALUE_FLOAT128     9
#define DEBUG_VALUE_VECTOR64     10
#define DEBUG_VALUE_VECTOR128    11
// Count of type indices.
#define DEBUG_VALUE_TYPES        12

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif
#endif

// Force the compiler to align DEBUG_VALUE.Type on a four-byte
// boundary so that it comes out to 32 bytes total.
#include <pshpack4.h>

typedef struct _DEBUG_VALUE
{
    union
    {
        UCHAR I8;
        USHORT I16;
        ULONG I32;
        struct
        {
            // Extra NAT indicator for IA64
            // integer registers.  NAT will
            // always be false for other CPUs.
            ULONG64 I64;
            BOOL Nat;
        };
        float F32;
        double F64;
        UCHAR F80Bytes[10];
        UCHAR F82Bytes[11];
        UCHAR F128Bytes[16];
        // Vector interpretations.  The actual number
        // of valid elements depends on the vector length.
        UCHAR VI8[16];
        USHORT VI16[8];
        ULONG VI32[4];
        ULONG64 VI64[2];
        float VF32[4];
        double VF64[2];
        struct
        {
            ULONG LowPart;
            ULONG HighPart;
        } I64Parts32;
        struct
        {
            ULONG64 LowPart;
            LONG64 HighPart;
        } F128Parts64;
        // Allows raw byte access to content.  Array
        // can be indexed for as much data as Type
        // describes.  This array also serves to pad
        // the structure out to 32 bytes and reserves
        // space for future members.
        UCHAR RawBytes[28];
    };
    ULONG Type;
} DEBUG_VALUE, *PDEBUG_VALUE;

#include <poppack.h>

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif
#endif
#endif

#undef INTERFACE
#define INTERFACE IDebugControl
DECLARE_INTERFACE_(IDebugControl, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugControl.
    
    // Checks for a user interrupt, such a Ctrl-C
    // or stop button.
    // This method is reentrant.
    STDMETHOD(GetInterrupt)(
        THIS
        ) PURE;
    // Registers a user interrupt.
    // This method is reentrant.
    STDMETHOD(SetInterrupt)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // Interrupting a user-mode process requires
    // access to some system resources that the
    // process may hold itself, preventing the
    // interrupt from occurring.  The engine
    // will time-out pending interrupt requests
    // and simulate an interrupt if necessary.
    // These methods control the interrupt timeout.
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        OUT PULONG Seconds
        ) PURE;
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        IN ULONG Seconds
        ) PURE;

    STDMETHOD(GetLogFile)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT PBOOL Append
        ) PURE;
    // Opens a log file which collects all
    // output.  Output from every client except
    // those that explicitly disable logging
    // goes into the log.
    // Opening a log file closes any log file
    // already open.
    STDMETHOD(OpenLogFile)(
        THIS_
        IN PCSTR File,
        IN BOOL Append
        ) PURE;
    STDMETHOD(CloseLogFile)(
        THIS
        ) PURE;
    // Controls what output is logged.
    STDMETHOD(GetLogMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetLogMask)(
        THIS_
        IN ULONG Mask
        ) PURE;
            
    // Input requests input from all clients.
    // The first input that is returned is used
    // to satisfy the call.  Other returned
    // input is discarded.
    STDMETHOD(Input)(
        THIS_
        OUT PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG InputSize
        ) PURE;
    // This method is used by clients to return
    // input when it is available.  It will
    // return S_OK if the input is used to
    // satisfy an Input call and S_FALSE if
    // the input is ignored.
    // This method is reentrant.
    STDMETHOD(ReturnInput)(
        THIS_
        IN PCSTR Buffer
        ) PURE;
    
    // Sends output through clients
    // output callbacks if the mask is allowed
    // by the current output control mask and
    // according to the output distribution
    // settings.
    STDMETHODV(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputVaList)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        ) PURE;
    // The following methods allow direct control
    // over the distribution of the given output
    // for situations where something other than
    // the default is desired.  These methods require
    // extra work in the engine so they should
    // only be used when necessary.
    STDMETHODV(ControlledOutput)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        ) PURE;
            
    // Displays the standard command-line prompt
    // followed by the given output.  If Format
    // is NULL no additional output is produced.
    // Output is produced under the
    // DEBUG_OUTPUT_PROMPT mask.
    // This method only outputs the prompt; it
    // does not get input.
    STDMETHODV(OutputPrompt)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputPromptVaList)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        IN va_list Args
        ) PURE;
    // Gets the text that would be displayed by OutputPrompt.
    STDMETHOD(GetPromptText)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        ) PURE;
    // Outputs information about the current
    // debuggee state such as a register
    // summary, disassembly at the current PC,
    // closest symbol and others.
    // Uses the line prefix.
    STDMETHOD(OutputCurrentState)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        ) PURE;
        
    // Outputs the debugger and extension version
    // information.  This method is reentrant.
    // Uses the line prefix.
    STDMETHOD(OutputVersionInformation)(
        THIS_
        IN ULONG OutputControl
        ) PURE;

    // In user-mode debugging sessions the
    // engine will set an event when
    // exceptions are continued.  This can
    // be used to synchronize other processes
    // with the debuggers handling of events.
    // For example, this is used to support
    // the e argument to ntsd.
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        IN ULONG64 Handle
        ) PURE;

    STDMETHOD(Assemble)(
        THIS_
        IN ULONG64 Offset,
        IN PCSTR Instr,
        OUT PULONG64 EndOffset
        ) PURE;
    STDMETHOD(Disassemble)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DisassemblySize,
        OUT PULONG64 EndOffset
        ) PURE;
    // Returns the value of the effective address
    // computed for the last Disassemble, if there
    // was one.
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Uses the line prefix if necessary.
    STDMETHOD(OutputDisassembly)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT PULONG64 EndOffset
        ) PURE;
    // Produces multiple lines of disassembly output.
    // There will be PreviousLines of disassembly before
    // the given offset if a valid disassembly exists.
    // In all, there will be TotalLines of output produced.
    // The first and last line offsets are returned
    // specially and all lines offsets can be retrieved
    // through LineOffsets.  LineOffsets will contain
    // offsets for each line where disassembly started.
    // When disassembly of a single instruction takes
    // multiple lines the initial offset will be followed
    // by DEBUG_INVALID_OFFSET.
    // Uses the line prefix.
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG PreviousLines,
        IN ULONG TotalLines,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PULONG OffsetLine,
        OUT OPTIONAL PULONG64 StartOffset,
        OUT OPTIONAL PULONG64 EndOffset,
        OUT OPTIONAL /* size_is(TotalLines) */ PULONG64 LineOffsets
        ) PURE;
    // Returns the offset of the start of
    // the instruction thats the given
    // delta away from the instruction
    // at the initial offset.
    // This routine does not check for
    // validity of the instruction or
    // the memory containing it.
    STDMETHOD(GetNearInstruction)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT PULONG64 NearOffset
        ) PURE;

    // Offsets can be passed in as zero to use the current
    // thread state.
    STDMETHOD(GetStackTrace)(
        THIS_
        IN ULONG64 FrameOffset,
        IN ULONG64 StackOffset,
        IN ULONG64 InstructionOffset,
        OUT /* size_is(FramesSize) */ PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        OUT OPTIONAL PULONG FramesFilled
        ) PURE;
    // Does a simple stack trace to determine
    // what the current return address is.
    STDMETHOD(GetReturnOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // If Frames is NULL OutputStackTrace will
    // use GetStackTrace to get FramesSize frames
    // and then output them.  The current register
    // values for frame, stack and instruction offsets
    // are used.
    // Uses the line prefix.
    STDMETHOD(OutputStackTrace)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL /* size_is(FramesSize) */ PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        IN ULONG Flags
        ) PURE;
    
    // Returns information about the debuggee such
    // as user vs. kernel, dump vs. live, etc.
    STDMETHOD(GetDebuggeeType)(
        THIS_
        OUT PULONG Class,
        OUT PULONG Qualifier
        ) PURE;
    // Returns the type of physical processors in
    // the machine.
    // Returns one of the IMAGE_FILE_MACHINE values.
    STDMETHOD(GetActualProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    // Returns the type of processor used in the
    // current processor context.
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    // Query all the possible processor types that
    // may be encountered during this debug session.
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PULONG Types
        ) PURE;
    // Get the number of actual processors in
    // the machine.
    STDMETHOD(GetNumberProcessors)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // PlatformId is one of the VER_PLATFORM values.
    // Major and minor are as given in the NT
    // kernel debugger protocol.
    // ServicePackString and ServicePackNumber indicate the
    // system service pack level.  ServicePackNumber is not
    // available in some sessions where the service pack level
    // is only expressed as a string.  The service pack information
    // will be empty if the system does not have a service pack
    // applied.
    // The build string is string information identifying the
    // particular build of the system.  The build string is
    // empty if the system has no particular identifying
    // information.
    STDMETHOD(GetSystemVersion)(
        THIS_
        OUT PULONG PlatformId,
        OUT PULONG Major,
        OUT PULONG Minor,
        OUT OPTIONAL PSTR ServicePackString,
        IN ULONG ServicePackStringSize,
        OUT OPTIONAL PULONG ServicePackStringUsed,
        OUT PULONG ServicePackNumber,
        OUT OPTIONAL PSTR BuildString,
        IN ULONG BuildStringSize,
        OUT OPTIONAL PULONG BuildStringUsed
        ) PURE;
    // Returns the page size for the currently executing
    // processor context.  The page size may vary between
    // processor types.
    STDMETHOD(GetPageSize)(
        THIS_
        OUT PULONG Size
        ) PURE;
    // Returns S_OK if the current processor context uses
    // 64-bit addresses, otherwise S_FALSE.
    STDMETHOD(IsPointer64Bit)(
        THIS
        ) PURE;
    // Reads the bugcheck data area and returns the
    // current contents.  This method only works
    // in kernel debugging sessions.
    STDMETHOD(ReadBugCheckData)(
        THIS_
        OUT PULONG Code,
        OUT PULONG64 Arg1,
        OUT PULONG64 Arg2,
        OUT PULONG64 Arg3,
        OUT PULONG64 Arg4
        ) PURE;

    // Query all the processor types supported by
    // the engine.  This is a complete list and is
    // not related to the machine running the engine
    // or the debuggee.
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PULONG Types
        ) PURE;
    // Returns a full, descriptive name and an
    // abbreviated name for a processor type.
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        IN ULONG Type,
        OUT OPTIONAL PSTR FullNameBuffer,
        IN ULONG FullNameBufferSize,
        OUT OPTIONAL PULONG FullNameSize,
        OUT OPTIONAL PSTR AbbrevNameBuffer,
        IN ULONG AbbrevNameBufferSize,
        OUT OPTIONAL PULONG AbbrevNameSize
        ) PURE;
                
    // Gets and sets the type of processor to
    // use when doing things like setting
    // breakpoints, accessing registers,
    // getting stack traces and so on.
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        IN ULONG Type
        ) PURE;

    // Returns information about whether and how
    // the debuggee is running.  Status will
    // be GO if the debuggee is running and
    // BREAK if it isnt.
    // If no debuggee exists the status is
    // NO_DEBUGGEE.
    // This method is reentrant.
    STDMETHOD(GetExecutionStatus)(
        THIS_
        OUT PULONG Status
        ) PURE;
    // Changes the execution status of the
    // engine from stopped to running.
    // Status must be one of the go or step
    // status values.
    STDMETHOD(SetExecutionStatus)(
        THIS_
        IN ULONG Status
        ) PURE;
        
    // Controls what code interpretation level the debugger
    // runs at.  The debugger checks the code level when
    // deciding whether to step by a source line or
    // assembly instruction along with other related operations.
    STDMETHOD(GetCodeLevel)(
        THIS_
        OUT PULONG Level
        ) PURE;
    STDMETHOD(SetCodeLevel)(
        THIS_
        IN ULONG Level
        ) PURE;

    // Gets and sets engine control flags.
    // These methods are reentrant.
    STDMETHOD(GetEngineOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    // Gets and sets control values for
    // handling system error events.
    // If the system error level is less
    // than or equal to the given levels
    // the error may be displayed and
    // the default break for the event
    // may be set.
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        OUT PULONG OutputLevel,
        OUT PULONG BreakLevel
        ) PURE;
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        IN ULONG OutputLevel,
        IN ULONG BreakLevel
        ) PURE;
    
    // The command processor supports simple
    // string replacement macros in Evaluate and
    // Execute.  There are currently ten macro
    // slots available.  Slots 0-9 map to
    // the command invocations $u0-$u9.
    STDMETHOD(GetTextMacro)(
        THIS_
        IN ULONG Slot,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MacroSize
        ) PURE;
    STDMETHOD(SetTextMacro)(
        THIS_
        IN ULONG Slot,
        IN PCSTR Macro
        ) PURE;
    
    // Controls the default number radix used
    // in expressions and commands.
    STDMETHOD(GetRadix)(
        THIS_
        OUT PULONG Radix
        ) PURE;
    STDMETHOD(SetRadix)(
        THIS_
        IN ULONG Radix
        ) PURE;

    // Evaluates the given expression string and
    // returns the resulting value.
    // If DesiredType is DEBUG_VALUE_INVALID then
    // the natural type is used.
    // RemainderIndex, if provided, is set to the index
    // of the first character in the input string that was
    // not used when evaluating the expression.
    STDMETHOD(Evaluate)(
        THIS_
        IN PCSTR Expression,
        IN ULONG DesiredType,
        OUT PDEBUG_VALUE Value,
        OUT OPTIONAL PULONG RemainderIndex
        ) PURE;
    // Attempts to convert the input value to a value
    // of the requested type in the output value.
    // Conversions can fail if no conversion exists.
    // Successful conversions may be lossy.
    STDMETHOD(CoerceValue)(
        THIS_
        IN PDEBUG_VALUE In,
        IN ULONG OutType,
        OUT PDEBUG_VALUE Out
        ) PURE;
    STDMETHOD(CoerceValues)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_VALUE In,
        IN /* size_is(Count) */ PULONG OutTypes,
        OUT /* size_is(Count) */ PDEBUG_VALUE Out
        ) PURE;
    
    // Executes the given command string.
    // If the string has multiple commands
    // Execute will not return until all
    // of them have been executed.  If this
    // requires waiting for the debuggee to
    // execute an internal wait will be done
    // so Execute can take an arbitrary amount
    // of time.
    STDMETHOD(Execute)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Command,
        IN ULONG Flags
        ) PURE;
    // Executes the given command file by
    // reading a line at a time and processing
    // it with Execute.
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR CommandFile,
        IN ULONG Flags
        ) PURE;
        
    // Breakpoint interfaces are described
    // elsewhere in this section.
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // It is possible for this retrieval function to
    // fail even with an index within the number of
    // existing breakpoints if the breakpoint is
    // a private breakpoint.
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        IN ULONG Index,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    STDMETHOD(GetBreakpointById)(
        THIS_
        IN ULONG Id,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // If Ids is non-NULL the Count breakpoints
    // referred to in the Ids array are returned,
    // otherwise breakpoints from index Start to
    // Start + Count  1 are returned.
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
    // Breakpoints are created empty and disabled.
    // When their parameters have been set they
    // should be enabled by setting the ENABLE flag.
    // If DesiredId is DEBUG_ANY_ID then the
    // engine picks an unused ID.  If DesiredId
    // is any other number the engine attempts
    // to use the given ID for the breakpoint.
    // If another breakpoint exists with that ID
    // the call will fail.
    STDMETHOD(AddBreakpoint)(
        THIS_
        IN ULONG Type,
        IN ULONG DesiredId,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // Breakpoint interface is invalid after this call.
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Control and use extension DLLs.
    STDMETHOD(AddExtension)(
        THIS_
        IN PCSTR Path,
        IN ULONG Flags,
        OUT PULONG64 Handle
        ) PURE;
    STDMETHOD(RemoveExtension)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    STDMETHOD(GetExtensionByPath)(
        THIS_
        IN PCSTR Path,
        OUT PULONG64 Handle
        ) PURE;
    // If Handle is zero the extension
    // chain is walked searching for the
    // function.
    STDMETHOD(CallExtension)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR Function,
        IN OPTIONAL PCSTR Arguments
        ) PURE;
    // GetExtensionFunction works like
    // GetProcAddress on extension DLLs
    // to allow raw function-call-level
    // interaction with extension DLLs.
    // Such functions do not need to
    // follow the standard extension prototype
    // if they are not going to be called
    // through the text extension interface.
    // _EFN_ is automatically prepended to
    // the name string given.
    // This function cannot be called remotely.
    STDMETHOD(GetExtensionFunction)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR FuncName,
        OUT FARPROC* Function
        ) PURE;
    // These methods return alternate
    // extension interfaces in order to allow
    // interface-style extension DLLs to mix in
    // older extension calls.
    // Structure sizes must be initialized before
    // the call.
    // These methods cannot be called remotely.
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS32 Api
        ) PURE;
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS64 Api
        ) PURE;

    // The engine provides a simple mechanism
    // to filter common events.  Arbitrarily complicated
    // filtering can be done by registering event callbacks
    // but simple event filtering only requires
    // setting the options of one of the predefined
    // event filters.
    // Simple event filters are either for specific
    // events and therefore have an enumerant or
    // they are for an exception and are based on
    // the exceptions code.  Exception filters
    // are further divided into exceptions specially
    // handled by the engine, which is a fixed set,
    // and arbitrary exceptions.
    // All three groups of filters are indexed together
    // with the specific filters first, then the specific
    // exception filters and finally the arbitrary
    // exception filters.
    // The first specific exception is the default
    // exception.  If an exception event occurs for
    // an exception without settings the default
    // exception settings are used.
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        OUT PULONG SpecificEvents,
        OUT PULONG SpecificExceptions,
        OUT PULONG ArbitraryExceptions
        ) PURE;
    // Some filters have descriptive text associated with them.
    STDMETHOD(GetEventFilterText)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        ) PURE;
    // All filters support executing a command when the
    // event occurs.
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        ) PURE;
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    // Some specific filters have arguments to further
    // qualify their operation.
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ArgumentSize
        ) PURE;
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        IN PCSTR Argument
        ) PURE;
    // If Codes is non-NULL Start is ignored.
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Codes,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // The codes in the parameter data control the application
    // of the parameter data.  If a code is not already in
    // the set of filters it is added.  If the ExecutionOption
    // for a code is REMOVE then the filter is removed.
    // Specific exception filters cannot be removed.
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // Exception filters support an additional command for
    // second-chance events.
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        ) PURE;

    // Yields processing to the engine until
    // an event occurs.  This method may
    // only be called by the thread that started
    // the debug session.
    // When an event occurs the engine carries
    // out all event processing such as calling
    // callbacks.
    // If the callbacks indicate that execution should
    // break the wait will return, otherwise it
    // goes back to waiting for a new event.
    // If the timeout expires, S_FALSE is returned.
    // The timeout is not currently supported for
    // kernel debugging.
    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Flags,
        IN ULONG Timeout
        ) PURE;

    // Retrieves information about the last event that occurred.
    // EventType is one of the event callback mask bits.
    // ExtraInformation contains additional event-specific
    // information.  Not all events have additional information.
    STDMETHOD(GetLastEventInformation)(
        THIS_
        OUT PULONG Type,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT OPTIONAL PVOID ExtraInformation,
        IN ULONG ExtraInformationSize,
        OUT OPTIONAL PULONG ExtraInformationUsed,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG DescriptionUsed
        ) PURE;
};

// OutputTextReplacements flags.
#define DEBUG_OUT_TEXT_REPL_DEFAULT 0x00000000

#undef INTERFACE
#define INTERFACE IDebugControl2
DECLARE_INTERFACE_(IDebugControl2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugControl.
    
    // Checks for a user interrupt, such a Ctrl-C
    // or stop button.
    // This method is reentrant.
    STDMETHOD(GetInterrupt)(
        THIS
        ) PURE;
    // Registers a user interrupt.
    // This method is reentrant.
    STDMETHOD(SetInterrupt)(
        THIS_
        IN ULONG Flags
        ) PURE;
    // Interrupting a user-mode process requires
    // access to some system resources that the
    // process may hold itself, preventing the
    // interrupt from occurring.  The engine
    // will time-out pending interrupt requests
    // and simulate an interrupt if necessary.
    // These methods control the interrupt timeout.
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        OUT PULONG Seconds
        ) PURE;
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        IN ULONG Seconds
        ) PURE;

    STDMETHOD(GetLogFile)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT PBOOL Append
        ) PURE;
    // Opens a log file which collects all
    // output.  Output from every client except
    // those that explicitly disable logging
    // goes into the log.
    // Opening a log file closes any log file
    // already open.
    STDMETHOD(OpenLogFile)(
        THIS_
        IN PCSTR File,
        IN BOOL Append
        ) PURE;
    STDMETHOD(CloseLogFile)(
        THIS
        ) PURE;
    // Controls what output is logged.
    STDMETHOD(GetLogMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;
    STDMETHOD(SetLogMask)(
        THIS_
        IN ULONG Mask
        ) PURE;
            
    // Input requests input from all clients.
    // The first input that is returned is used
    // to satisfy the call.  Other returned
    // input is discarded.
    STDMETHOD(Input)(
        THIS_
        OUT PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG InputSize
        ) PURE;
    // This method is used by clients to return
    // input when it is available.  It will
    // return S_OK if the input is used to
    // satisfy an Input call and S_FALSE if
    // the input is ignored.
    // This method is reentrant.
    STDMETHOD(ReturnInput)(
        THIS_
        IN PCSTR Buffer
        ) PURE;
    
    // Sends output through clients
    // output callbacks if the mask is allowed
    // by the current output control mask and
    // according to the output distribution
    // settings.
    STDMETHODV(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputVaList)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        ) PURE;
    // The following methods allow direct control
    // over the distribution of the given output
    // for situations where something other than
    // the default is desired.  These methods require
    // extra work in the engine so they should
    // only be used when necessary.
    STDMETHODV(ControlledOutput)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        ) PURE;
            
    // Displays the standard command-line prompt
    // followed by the given output.  If Format
    // is NULL no additional output is produced.
    // Output is produced under the
    // DEBUG_OUTPUT_PROMPT mask.
    // This method only outputs the prompt; it
    // does not get input.
    STDMETHODV(OutputPrompt)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        ...
        ) PURE;
    STDMETHOD(OutputPromptVaList)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        IN va_list Args
        ) PURE;
    // Gets the text that would be displayed by OutputPrompt.
    STDMETHOD(GetPromptText)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        ) PURE;
    // Outputs information about the current
    // debuggee state such as a register
    // summary, disassembly at the current PC,
    // closest symbol and others.
    // Uses the line prefix.
    STDMETHOD(OutputCurrentState)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        ) PURE;
        
    // Outputs the debugger and extension version
    // information.  This method is reentrant.
    // Uses the line prefix.
    STDMETHOD(OutputVersionInformation)(
        THIS_
        IN ULONG OutputControl
        ) PURE;

    // In user-mode debugging sessions the
    // engine will set an event when
    // exceptions are continued.  This can
    // be used to synchronize other processes
    // with the debuggers handling of events.
    // For example, this is used to support
    // the e argument to ntsd.
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        IN ULONG64 Handle
        ) PURE;

    STDMETHOD(Assemble)(
        THIS_
        IN ULONG64 Offset,
        IN PCSTR Instr,
        OUT PULONG64 EndOffset
        ) PURE;
    STDMETHOD(Disassemble)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DisassemblySize,
        OUT PULONG64 EndOffset
        ) PURE;
    // Returns the value of the effective address
    // computed for the last Disassemble, if there
    // was one.
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Uses the line prefix if necessary.
    STDMETHOD(OutputDisassembly)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT PULONG64 EndOffset
        ) PURE;
    // Produces multiple lines of disassembly output.
    // There will be PreviousLines of disassembly before
    // the given offset if a valid disassembly exists.
    // In all, there will be TotalLines of output produced.
    // The first and last line offsets are returned
    // specially and all lines offsets can be retrieved
    // through LineOffsets.  LineOffsets will contain
    // offsets for each line where disassembly started.
    // When disassembly of a single instruction takes
    // multiple lines the initial offset will be followed
    // by DEBUG_INVALID_OFFSET.
    // Uses the line prefix.
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG PreviousLines,
        IN ULONG TotalLines,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PULONG OffsetLine,
        OUT OPTIONAL PULONG64 StartOffset,
        OUT OPTIONAL PULONG64 EndOffset,
        OUT OPTIONAL /* size_is(TotalLines) */ PULONG64 LineOffsets
        ) PURE;
    // Returns the offset of the start of
    // the instruction thats the given
    // delta away from the instruction
    // at the initial offset.
    // This routine does not check for
    // validity of the instruction or
    // the memory containing it.
    STDMETHOD(GetNearInstruction)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT PULONG64 NearOffset
        ) PURE;

    // Offsets can be passed in as zero to use the current
    // thread state.
    STDMETHOD(GetStackTrace)(
        THIS_
        IN ULONG64 FrameOffset,
        IN ULONG64 StackOffset,
        IN ULONG64 InstructionOffset,
        OUT /* size_is(FramesSize) */ PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        OUT OPTIONAL PULONG FramesFilled
        ) PURE;
    // Does a simple stack trace to determine
    // what the current return address is.
    STDMETHOD(GetReturnOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // If Frames is NULL OutputStackTrace will
    // use GetStackTrace to get FramesSize frames
    // and then output them.  The current register
    // values for frame, stack and instruction offsets
    // are used.
    // Uses the line prefix.
    STDMETHOD(OutputStackTrace)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL /* size_is(FramesSize) */ PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        IN ULONG Flags
        ) PURE;
    
    // Returns information about the debuggee such
    // as user vs. kernel, dump vs. live, etc.
    STDMETHOD(GetDebuggeeType)(
        THIS_
        OUT PULONG Class,
        OUT PULONG Qualifier
        ) PURE;
    // Returns the type of physical processors in
    // the machine.
    // Returns one of the IMAGE_FILE_MACHINE values.
    STDMETHOD(GetActualProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    // Returns the type of processor used in the
    // current processor context.
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    // Query all the possible processor types that
    // may be encountered during this debug session.
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PULONG Types
        ) PURE;
    // Get the number of actual processors in
    // the machine.
    STDMETHOD(GetNumberProcessors)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // PlatformId is one of the VER_PLATFORM values.
    // Major and minor are as given in the NT
    // kernel debugger protocol.
    // ServicePackString and ServicePackNumber indicate the
    // system service pack level.  ServicePackNumber is not
    // available in some sessions where the service pack level
    // is only expressed as a string.  The service pack information
    // will be empty if the system does not have a service pack
    // applied.
    // The build string is string information identifying the
    // particular build of the system.  The build string is
    // empty if the system has no particular identifying
    // information.
    STDMETHOD(GetSystemVersion)(
        THIS_
        OUT PULONG PlatformId,
        OUT PULONG Major,
        OUT PULONG Minor,
        OUT OPTIONAL PSTR ServicePackString,
        IN ULONG ServicePackStringSize,
        OUT OPTIONAL PULONG ServicePackStringUsed,
        OUT PULONG ServicePackNumber,
        OUT OPTIONAL PSTR BuildString,
        IN ULONG BuildStringSize,
        OUT OPTIONAL PULONG BuildStringUsed
        ) PURE;
    // Returns the page size for the currently executing
    // processor context.  The page size may vary between
    // processor types.
    STDMETHOD(GetPageSize)(
        THIS_
        OUT PULONG Size
        ) PURE;
    // Returns S_OK if the current processor context uses
    // 64-bit addresses, otherwise S_FALSE.
    STDMETHOD(IsPointer64Bit)(
        THIS
        ) PURE;
    // Reads the bugcheck data area and returns the
    // current contents.  This method only works
    // in kernel debugging sessions.
    STDMETHOD(ReadBugCheckData)(
        THIS_
        OUT PULONG Code,
        OUT PULONG64 Arg1,
        OUT PULONG64 Arg2,
        OUT PULONG64 Arg3,
        OUT PULONG64 Arg4
        ) PURE;

    // Query all the processor types supported by
    // the engine.  This is a complete list and is
    // not related to the machine running the engine
    // or the debuggee.
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PULONG Types
        ) PURE;
    // Returns a full, descriptive name and an
    // abbreviated name for a processor type.
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        IN ULONG Type,
        OUT OPTIONAL PSTR FullNameBuffer,
        IN ULONG FullNameBufferSize,
        OUT OPTIONAL PULONG FullNameSize,
        OUT OPTIONAL PSTR AbbrevNameBuffer,
        IN ULONG AbbrevNameBufferSize,
        OUT OPTIONAL PULONG AbbrevNameSize
        ) PURE;
                
    // Gets and sets the type of processor to
    // use when doing things like setting
    // breakpoints, accessing registers,
    // getting stack traces and so on.
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        OUT PULONG Type
        ) PURE;
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        IN ULONG Type
        ) PURE;

    // Returns information about whether and how
    // the debuggee is running.  Status will
    // be GO if the debuggee is running and
    // BREAK if it isnt.
    // If no debuggee exists the status is
    // NO_DEBUGGEE.
    // This method is reentrant.
    STDMETHOD(GetExecutionStatus)(
        THIS_
        OUT PULONG Status
        ) PURE;
    // Changes the execution status of the
    // engine from stopped to running.
    // Status must be one of the go or step
    // status values.
    STDMETHOD(SetExecutionStatus)(
        THIS_
        IN ULONG Status
        ) PURE;
        
    // Controls what code interpretation level the debugger
    // runs at.  The debugger checks the code level when
    // deciding whether to step by a source line or
    // assembly instruction along with other related operations.
    STDMETHOD(GetCodeLevel)(
        THIS_
        OUT PULONG Level
        ) PURE;
    STDMETHOD(SetCodeLevel)(
        THIS_
        IN ULONG Level
        ) PURE;

    // Gets and sets engine control flags.
    // These methods are reentrant.
    STDMETHOD(GetEngineOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetEngineOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    // Gets and sets control values for
    // handling system error events.
    // If the system error level is less
    // than or equal to the given levels
    // the error may be displayed and
    // the default break for the event
    // may be set.
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        OUT PULONG OutputLevel,
        OUT PULONG BreakLevel
        ) PURE;
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        IN ULONG OutputLevel,
        IN ULONG BreakLevel
        ) PURE;
    
    // The command processor supports simple
    // string replacement macros in Evaluate and
    // Execute.  There are currently ten macro
    // slots available.  Slots 0-9 map to
    // the command invocations $u0-$u9.
    STDMETHOD(GetTextMacro)(
        THIS_
        IN ULONG Slot,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MacroSize
        ) PURE;
    STDMETHOD(SetTextMacro)(
        THIS_
        IN ULONG Slot,
        IN PCSTR Macro
        ) PURE;
    
    // Controls the default number radix used
    // in expressions and commands.
    STDMETHOD(GetRadix)(
        THIS_
        OUT PULONG Radix
        ) PURE;
    STDMETHOD(SetRadix)(
        THIS_
        IN ULONG Radix
        ) PURE;

    // Evaluates the given expression string and
    // returns the resulting value.
    // If DesiredType is DEBUG_VALUE_INVALID then
    // the natural type is used.
    // RemainderIndex, if provided, is set to the index
    // of the first character in the input string that was
    // not used when evaluating the expression.
    STDMETHOD(Evaluate)(
        THIS_
        IN PCSTR Expression,
        IN ULONG DesiredType,
        OUT PDEBUG_VALUE Value,
        OUT OPTIONAL PULONG RemainderIndex
        ) PURE;
    // Attempts to convert the input value to a value
    // of the requested type in the output value.
    // Conversions can fail if no conversion exists.
    // Successful conversions may be lossy.
    STDMETHOD(CoerceValue)(
        THIS_
        IN PDEBUG_VALUE In,
        IN ULONG OutType,
        OUT PDEBUG_VALUE Out
        ) PURE;
    STDMETHOD(CoerceValues)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_VALUE In,
        IN /* size_is(Count) */ PULONG OutTypes,
        OUT /* size_is(Count) */ PDEBUG_VALUE Out
        ) PURE;
    
    // Executes the given command string.
    // If the string has multiple commands
    // Execute will not return until all
    // of them have been executed.  If this
    // requires waiting for the debuggee to
    // execute an internal wait will be done
    // so Execute can take an arbitrary amount
    // of time.
    STDMETHOD(Execute)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Command,
        IN ULONG Flags
        ) PURE;
    // Executes the given command file by
    // reading a line at a time and processing
    // it with Execute.
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR CommandFile,
        IN ULONG Flags
        ) PURE;
        
    // Breakpoint interfaces are described
    // elsewhere in this section.
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // It is possible for this retrieval function to
    // fail even with an index within the number of
    // existing breakpoints if the breakpoint is
    // a private breakpoint.
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        IN ULONG Index,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    STDMETHOD(GetBreakpointById)(
        THIS_
        IN ULONG Id,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // If Ids is non-NULL the Count breakpoints
    // referred to in the Ids array are returned,
    // otherwise breakpoints from index Start to
    // Start + Count  1 are returned.
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_BREAKPOINT_PARAMETERS Params
        ) PURE;
    // Breakpoints are created empty and disabled.
    // When their parameters have been set they
    // should be enabled by setting the ENABLE flag.
    // If DesiredId is DEBUG_ANY_ID then the
    // engine picks an unused ID.  If DesiredId
    // is any other number the engine attempts
    // to use the given ID for the breakpoint.
    // If another breakpoint exists with that ID
    // the call will fail.
    STDMETHOD(AddBreakpoint)(
        THIS_
        IN ULONG Type,
        IN ULONG DesiredId,
        OUT PDEBUG_BREAKPOINT* Bp
        ) PURE;
    // Breakpoint interface is invalid after this call.
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Control and use extension DLLs.
    STDMETHOD(AddExtension)(
        THIS_
        IN PCSTR Path,
        IN ULONG Flags,
        OUT PULONG64 Handle
        ) PURE;
    STDMETHOD(RemoveExtension)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    STDMETHOD(GetExtensionByPath)(
        THIS_
        IN PCSTR Path,
        OUT PULONG64 Handle
        ) PURE;
    // If Handle is zero the extension
    // chain is walked searching for the
    // function.
    STDMETHOD(CallExtension)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR Function,
        IN OPTIONAL PCSTR Arguments
        ) PURE;
    // GetExtensionFunction works like
    // GetProcAddress on extension DLLs
    // to allow raw function-call-level
    // interaction with extension DLLs.
    // Such functions do not need to
    // follow the standard extension prototype
    // if they are not going to be called
    // through the text extension interface.
    // This function cannot be called remotely.
    STDMETHOD(GetExtensionFunction)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR FuncName,
        OUT FARPROC* Function
        ) PURE;
    // These methods return alternate
    // extension interfaces in order to allow
    // interface-style extension DLLs to mix in
    // older extension calls.
    // Structure sizes must be initialized before
    // the call.
    // These methods cannot be called remotely.
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS32 Api
        ) PURE;
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS64 Api
        ) PURE;

    // The engine provides a simple mechanism
    // to filter common events.  Arbitrarily complicated
    // filtering can be done by registering event callbacks
    // but simple event filtering only requires
    // setting the options of one of the predefined
    // event filters.
    // Simple event filters are either for specific
    // events and therefore have an enumerant or
    // they are for an exception and are based on
    // the exceptions code.  Exception filters
    // are further divided into exceptions specially
    // handled by the engine, which is a fixed set,
    // and arbitrary exceptions.
    // All three groups of filters are indexed together
    // with the specific filters first, then the specific
    // exception filters and finally the arbitrary
    // exception filters.
    // The first specific exception is the default
    // exception.  If an exception event occurs for
    // an exception without settings the default
    // exception settings are used.
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        OUT PULONG SpecificEvents,
        OUT PULONG SpecificExceptions,
        OUT PULONG ArbitraryExceptions
        ) PURE;
    // Some filters have descriptive text associated with them.
    STDMETHOD(GetEventFilterText)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        ) PURE;
    // All filters support executing a command when the
    // event occurs.
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        ) PURE;
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        ) PURE;
    // Some specific filters have arguments to further
    // qualify their operation.
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ArgumentSize
        ) PURE;
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        IN PCSTR Argument
        ) PURE;
    // If Codes is non-NULL Start is ignored.
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Codes,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // The codes in the parameter data control the application
    // of the parameter data.  If a code is not already in
    // the set of filters it is added.  If the ExecutionOption
    // for a code is REMOVE then the filter is removed.
    // Specific exception filters cannot be removed.
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        ) PURE;
    // Exception filters support an additional command for
    // second-chance events.
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        ) PURE;
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        ) PURE;

    // Yields processing to the engine until
    // an event occurs.  This method may
    // only be called by the thread that started
    // the debug session.
    // When an event occurs the engine carries
    // out all event processing such as calling
    // callbacks.
    // If the callbacks indicate that execution should
    // break the wait will return, otherwise it
    // goes back to waiting for a new event.
    // If the timeout expires, S_FALSE is returned.
    // The timeout is not currently supported for
    // kernel debugging.
    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Flags,
        IN ULONG Timeout
        ) PURE;

    // Retrieves information about the last event that occurred.
    // EventType is one of the event callback mask bits.
    // ExtraInformation contains additional event-specific
    // information.  Not all events have additional information.
    STDMETHOD(GetLastEventInformation)(
        THIS_
        OUT PULONG Type,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT OPTIONAL PVOID ExtraInformation,
        IN ULONG ExtraInformationSize,
        OUT OPTIONAL PULONG ExtraInformationUsed,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG DescriptionUsed
        ) PURE;

    // IDebugControl2.

    STDMETHOD(GetCurrentTimeDate)(
        THIS_
        OUT PULONG TimeDate
        ) PURE;
    // Retrieves the number of seconds since the
    // machine started running.
    STDMETHOD(GetCurrentSystemUpTime)(
        THIS_
        OUT PULONG UpTime
        ) PURE;

    // If the current session is a dump session,
    // retrieves any extended format information.
    STDMETHOD(GetDumpFormatFlags)(
        THIS_
        OUT PULONG FormatFlags
        ) PURE;

    // The debugger has been enhanced to allow
    // arbitrary text replacements in addition
    // to the simple $u0-$u9 text macros.
    // Text replacement takes a given source
    // text in commands and converts it to the
    // given destination text.  Replacements
    // are named by their source text so that
    // only one replacement for a source text
    // string can exist.
    STDMETHOD(GetNumberTextReplacements)(
        THIS_
        OUT PULONG NumRepl
        ) PURE;
    // If SrcText is non-NULL the replacement
    // is looked up by source text, otherwise
    // Index is used to get the Nth replacement.
    STDMETHOD(GetTextReplacement)(
        THIS_
        IN OPTIONAL PCSTR SrcText,
        IN ULONG Index,
        OUT OPTIONAL PSTR SrcBuffer,
        IN ULONG SrcBufferSize,
        OUT OPTIONAL PULONG SrcSize,
        OUT OPTIONAL PSTR DstBuffer,
        IN ULONG DstBufferSize,
        OUT OPTIONAL PULONG DstSize
        ) PURE;
    // Setting the destination text to
    // NULL removes the alias.
    STDMETHOD(SetTextReplacement)(
        THIS_
        IN PCSTR SrcText,
        IN OPTIONAL PCSTR DstText
        ) PURE;
    STDMETHOD(RemoveTextReplacements)(
        THIS
        ) PURE;
    // Outputs the complete list of current
    // replacements.
    STDMETHOD(OutputTextReplacements)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugDataSpaces.
//
//----------------------------------------------------------------------------

// Data space indices for callbacks and other methods.
#define DEBUG_DATA_SPACE_VIRTUAL       0
#define DEBUG_DATA_SPACE_PHYSICAL      1
#define DEBUG_DATA_SPACE_CONTROL       2
#define DEBUG_DATA_SPACE_IO            3
#define DEBUG_DATA_SPACE_MSR           4
#define DEBUG_DATA_SPACE_BUS_DATA      5
#define DEBUG_DATA_SPACE_DEBUGGER_DATA 6
// Count of data spaces.
#define DEBUG_DATA_SPACE_COUNT         7

// Indices for ReadDebuggerData interface
#define DEBUG_DATA_KernBase                              24
#define DEBUG_DATA_BreakpointWithStatusAddr              32
#define DEBUG_DATA_SavedContextAddr                      40
#define DEBUG_DATA_KiCallUserModeAddr                    56
#define DEBUG_DATA_KeUserCallbackDispatcherAddr          64
#define DEBUG_DATA_PsLoadedModuleListAddr                72
#define DEBUG_DATA_PsActiveProcessHeadAddr               80
#define DEBUG_DATA_PspCidTableAddr                       88
#define DEBUG_DATA_ExpSystemResourcesListAddr            96
#define DEBUG_DATA_ExpPagedPoolDescriptorAddr           104
#define DEBUG_DATA_ExpNumberOfPagedPoolsAddr            112
#define DEBUG_DATA_KeTimeIncrementAddr                  120
#define DEBUG_DATA_KeBugCheckCallbackListHeadAddr       128
#define DEBUG_DATA_KiBugcheckDataAddr                   136
#define DEBUG_DATA_IopErrorLogListHeadAddr              144
#define DEBUG_DATA_ObpRootDirectoryObjectAddr           152
#define DEBUG_DATA_ObpTypeObjectTypeAddr                160
#define DEBUG_DATA_MmSystemCacheStartAddr               168
#define DEBUG_DATA_MmSystemCacheEndAddr                 176
#define DEBUG_DATA_MmSystemCacheWsAddr                  184
#define DEBUG_DATA_MmPfnDatabaseAddr                    192
#define DEBUG_DATA_MmSystemPtesStartAddr                200
#define DEBUG_DATA_MmSystemPtesEndAddr                  208
#define DEBUG_DATA_MmSubsectionBaseAddr                 216
#define DEBUG_DATA_MmNumberOfPagingFilesAddr            224
#define DEBUG_DATA_MmLowestPhysicalPageAddr             232
#define DEBUG_DATA_MmHighestPhysicalPageAddr            240
#define DEBUG_DATA_MmNumberOfPhysicalPagesAddr          248
#define DEBUG_DATA_MmMaximumNonPagedPoolInBytesAddr     256
#define DEBUG_DATA_MmNonPagedSystemStartAddr            264
#define DEBUG_DATA_MmNonPagedPoolStartAddr              272
#define DEBUG_DATA_MmNonPagedPoolEndAddr                280
#define DEBUG_DATA_MmPagedPoolStartAddr                 288
#define DEBUG_DATA_MmPagedPoolEndAddr                   296
#define DEBUG_DATA_MmPagedPoolInformationAddr           304
#define DEBUG_DATA_MmPageSize                           312
#define DEBUG_DATA_MmSizeOfPagedPoolInBytesAddr         320
#define DEBUG_DATA_MmTotalCommitLimitAddr               328
#define DEBUG_DATA_MmTotalCommittedPagesAddr            336
#define DEBUG_DATA_MmSharedCommitAddr                   344
#define DEBUG_DATA_MmDriverCommitAddr                   352
#define DEBUG_DATA_MmProcessCommitAddr                  360
#define DEBUG_DATA_MmPagedPoolCommitAddr                368
#define DEBUG_DATA_MmExtendedCommitAddr                 376
#define DEBUG_DATA_MmZeroedPageListHeadAddr             384
#define DEBUG_DATA_MmFreePageListHeadAddr               392
#define DEBUG_DATA_MmStandbyPageListHeadAddr            400
#define DEBUG_DATA_MmModifiedPageListHeadAddr           408
#define DEBUG_DATA_MmModifiedNoWritePageListHeadAddr    416
#define DEBUG_DATA_MmAvailablePagesAddr                 424
#define DEBUG_DATA_MmResidentAvailablePagesAddr         432
#define DEBUG_DATA_PoolTrackTableAddr                   440
#define DEBUG_DATA_NonPagedPoolDescriptorAddr           448
#define DEBUG_DATA_MmHighestUserAddressAddr             456
#define DEBUG_DATA_MmSystemRangeStartAddr               464
#define DEBUG_DATA_MmUserProbeAddressAddr               472
#define DEBUG_DATA_KdPrintCircularBufferAddr            480
#define DEBUG_DATA_KdPrintCircularBufferEndAddr         488
#define DEBUG_DATA_KdPrintWritePointerAddr              496
#define DEBUG_DATA_KdPrintRolloverCountAddr             504
#define DEBUG_DATA_MmLoadedUserImageListAddr            512
#define DEBUG_DATA_NtBuildLabAddr                       520
#define DEBUG_DATA_KiNormalSystemCall                   528
#define DEBUG_DATA_KiProcessorBlockAddr                 536
#define DEBUG_DATA_MmUnloadedDriversAddr                544
#define DEBUG_DATA_MmLastUnloadedDriverAddr             552
#define DEBUG_DATA_MmTriageActionTakenAddr              560
#define DEBUG_DATA_MmSpecialPoolTagAddr                 568
#define DEBUG_DATA_KernelVerifierAddr                   576
#define DEBUG_DATA_MmVerifierDataAddr                   584
#define DEBUG_DATA_MmAllocatedNonPagedPoolAddr          592
#define DEBUG_DATA_MmPeakCommitmentAddr                 600
#define DEBUG_DATA_MmTotalCommitLimitMaximumAddr        608
#define DEBUG_DATA_CmNtCSDVersionAddr                   616
#define DEBUG_DATA_MmPhysicalMemoryBlockAddr            624

#define DEBUG_DATA_PaeEnabled                        100000
#define DEBUG_DATA_SharedUserData                    100008

//
// Processor information structures.
//

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_ALPHA
{
    ULONG Type;
    ULONG Revision;
} DEBUG_PROCESSOR_IDENTIFICATION_ALPHA, *PDEBUG_PROCESSOR_IDENTIFICATION_ALPHA;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_AMD64
{
    ULONG Family;
    ULONG Model;
    ULONG Stepping;
    CHAR  VendorString[16];
} DEBUG_PROCESSOR_IDENTIFICATION_AMD64, *PDEBUG_PROCESSOR_IDENTIFICATION_AMD64;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_IA64
{
    ULONG Model;
    ULONG Revision;
    ULONG Family;
    ULONG ArchRev;
    CHAR  VendorString[16];
} DEBUG_PROCESSOR_IDENTIFICATION_IA64, *PDEBUG_PROCESSOR_IDENTIFICATION_IA64;

typedef struct _DEBUG_PROCESSOR_IDENTIFICATION_X86
{
    ULONG Family;
    ULONG Model;
    ULONG Stepping;
    CHAR  VendorString[16];
} DEBUG_PROCESSOR_IDENTIFICATION_X86, *PDEBUG_PROCESSOR_IDENTIFICATION_X86;

typedef union _DEBUG_PROCESSOR_IDENTIFICATION_ALL
{
    DEBUG_PROCESSOR_IDENTIFICATION_ALPHA Alpha;
    DEBUG_PROCESSOR_IDENTIFICATION_AMD64 Amd64;
    DEBUG_PROCESSOR_IDENTIFICATION_IA64  Ia64;
    DEBUG_PROCESSOR_IDENTIFICATION_X86   X86;
} DEBUG_PROCESSOR_IDENTIFICATION_ALL, *PDEBUG_PROCESSOR_IDENTIFICATION_ALL;

// Indices for ReadProcessorSystemData.
#define DEBUG_DATA_KPCR_OFFSET                          0
#define DEBUG_DATA_KPRCB_OFFSET                         1
#define DEBUG_DATA_KTHREAD_OFFSET                       2
#define DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET      3
#define DEBUG_DATA_PROCESSOR_IDENTIFICATION             4

#undef INTERFACE
#define INTERFACE IDebugDataSpaces
DECLARE_INTERFACE_(IDebugDataSpaces, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugDataSpaces.
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    // SearchVirtual searches the given virtual
    // address range for the given pattern.  PatternSize
    // gives the byte length of the pattern and PatternGranularity
    // controls the granularity of comparisons during
    // the search.
    // For example, a DWORD-granular search would
    // use a pattern granularity of four to search by DWORD
    // increments.
    STDMETHOD(SearchVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        ) PURE;
    // These methods are identical to Read/WriteVirtual
    // except that they avoid the kernel virtual memory
    // cache entirely and are therefore useful for reading
    // virtual memory which is inherently volatile, such
    // as memory-mapped device areas, without contaminating
    // or invalidating the cache.
    // In user-mode they are the same as Read/WriteVirtual.
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    // The following two methods are convenience
    // methods for accessing pointer values.
    // They automatically convert between native pointers
    // and canonical 64-bit values as necessary.
    // These routines stop at the first failure.
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        OUT /* size_is(Count) */ PULONG64 Ptrs
        ) PURE;
    STDMETHOD(WritePointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        IN /* size_is(Count) */ PULONG64 Ptrs
        ) PURE;
    // All non-virtual data spaces are only
    // available when kernel debugging.
    STDMETHOD(ReadPhysical)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WritePhysical)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadMsr)(
        THIS_
        IN ULONG Msr,
        OUT PULONG64 Value
        ) PURE;
    STDMETHOD(WriteMsr)(
        THIS_
        IN ULONG Msr,
        IN ULONG64 Value
        ) PURE;
    STDMETHOD(ReadBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(CheckLowMemory)(
        THIS
        ) PURE;
    STDMETHOD(ReadDebuggerData)(
        THIS_
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        IN ULONG Processor,
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;
};

//
// Handle data types and structures.
//

#define DEBUG_HANDLE_DATA_TYPE_BASIC        0
#define DEBUG_HANDLE_DATA_TYPE_TYPE_NAME    1
#define DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME  2
#define DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT 3

typedef struct _DEBUG_HANDLE_DATA_BASIC
{
    ULONG TypeNameSize;
    ULONG ObjectNameSize;
    ULONG Attributes;
    ULONG GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
} DEBUG_HANDLE_DATA_BASIC, *PDEBUG_HANDLE_DATA_BASIC;

#undef INTERFACE
#define INTERFACE IDebugDataSpaces2
DECLARE_INTERFACE_(IDebugDataSpaces2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugDataSpaces.
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    // SearchVirtual searches the given virtual
    // address range for the given pattern.  PatternSize
    // gives the byte length of the pattern and PatternGranularity
    // controls the granularity of comparisons during
    // the search.
    // For example, a DWORD-granular search would
    // use a pattern granularity of four to search by DWORD
    // increments.
    STDMETHOD(SearchVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        ) PURE;
    // These methods are identical to Read/WriteVirtual
    // except that they avoid the kernel virtual memory
    // cache entirely and are therefore useful for reading
    // virtual memory which is inherently volatile, such
    // as memory-mapped device areas, without contaminating
    // or invalidating the cache.
    // In user-mode they are the same as Read/WriteVirtual.
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    // The following two methods are convenience
    // methods for accessing pointer values.
    // They automatically convert between native pointers
    // and canonical 64-bit values as necessary.
    // These routines stop at the first failure.
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        OUT /* size_is(Count) */ PULONG64 Ptrs
        ) PURE;
    STDMETHOD(WritePointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        IN /* size_is(Count) */ PULONG64 Ptrs
        ) PURE;
    // All non-virtual data spaces are only
    // available when kernel debugging.
    STDMETHOD(ReadPhysical)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WritePhysical)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(ReadMsr)(
        THIS_
        IN ULONG Msr,
        OUT PULONG64 Value
        ) PURE;
    STDMETHOD(WriteMsr)(
        THIS_
        IN ULONG Msr,
        IN ULONG64 Value
        ) PURE;
    STDMETHOD(ReadBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(CheckLowMemory)(
        THIS
        ) PURE;
    STDMETHOD(ReadDebuggerData)(
        THIS_
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        IN ULONG Processor,
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;

    // IDebugDataSpaces2.

    STDMETHOD(VirtualToPhysical)(
        THIS_
        IN ULONG64 Virtual,
        OUT PULONG64 Physical
        ) PURE;
    // Returns the physical addresses for the
    // N levels of the systems paging structures.
    // Level zero is the starting base physical
    // address for virtual translations.
    // Levels one-(N-1) will point to the appropriate
    // paging descriptor for the virtual address at
    // the given level of the paging hierarchy.  The
    // exact number of levels depends on many factors.
    // The last level will be the fully translated
    // physical address, matching what VirtualToPhysical
    // returns.  If the address can only be partially
    // translated S_FALSE is returned.
    STDMETHOD(GetVirtualTranslationPhysicalOffsets)(
        THIS_
        IN ULONG64 Virtual,
        OUT OPTIONAL /* size_is(OffsetsSize) */ PULONG64 Offsets,
        IN ULONG OffsetsSize,
        OUT OPTIONAL PULONG Levels
        ) PURE;

    // System handle data is accessible in certain
    // debug sessions.  The particular data available
    // varies from session to session and platform
    // to platform.
    STDMETHOD(ReadHandleData)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;

    // Fills memory with the given pattern.
    // The fill stops at the first non-writable byte.
    STDMETHOD(FillVirtual)(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT OPTIONAL PULONG Filled
        ) PURE;
    STDMETHOD(FillPhysical)(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT OPTIONAL PULONG Filled
        ) PURE;

    // Queries virtual memory mapping information given
    // an address similarly to the Win32 API VirtualQuery.
    // MEMORY_BASIC_INFORMATION64 is defined in crash.h.
    // This method currently only works for user-mode sessions.
    STDMETHOD(QueryVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PMEMORY_BASIC_INFORMATION64 Info
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugEventCallbacks.
//
//----------------------------------------------------------------------------

// Interest mask bits.
#define DEBUG_EVENT_BREAKPOINT              0x00000001
#define DEBUG_EVENT_EXCEPTION               0x00000002
#define DEBUG_EVENT_CREATE_THREAD           0x00000004
#define DEBUG_EVENT_EXIT_THREAD             0x00000008
#define DEBUG_EVENT_CREATE_PROCESS          0x00000010
#define DEBUG_EVENT_EXIT_PROCESS            0x00000020
#define DEBUG_EVENT_LOAD_MODULE             0x00000040
#define DEBUG_EVENT_UNLOAD_MODULE           0x00000080
#define DEBUG_EVENT_SYSTEM_ERROR            0x00000100
#define DEBUG_EVENT_SESSION_STATUS          0x00000200
#define DEBUG_EVENT_CHANGE_DEBUGGEE_STATE   0x00000400
#define DEBUG_EVENT_CHANGE_ENGINE_STATE     0x00000800
#define DEBUG_EVENT_CHANGE_SYMBOL_STATE     0x00001000

// SessionStatus flags.
// A debuggee has been discovered for the session.
#define DEBUG_SESSION_ACTIVE                       0x00000000
// The session has been ended by EndSession.
#define DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE 0x00000001
#define DEBUG_SESSION_END_SESSION_ACTIVE_DETACH    0x00000002
#define DEBUG_SESSION_END_SESSION_PASSIVE          0x00000003
// The debuggee has run to completion.  User-mode only.
#define DEBUG_SESSION_END                          0x00000004
// The target machine has rebooted.  Kernel-mode only.
#define DEBUG_SESSION_REBOOT                       0x00000005
// The target machine has hibernated.  Kernel-mode only.
#define DEBUG_SESSION_HIBERNATE                    0x00000006
// The engine was unable to continue the session.
#define DEBUG_SESSION_FAILURE                      0x00000007

// ChangeDebuggeeState flags.
// The debuggees state has changed generally, such
// as when the debuggee has been executing.
// Argument is zero.
#define DEBUG_CDS_ALL       0xffffffff
// Registers have changed.  If only a single register
// changed, argument is the index of the register.
// Otherwise it is DEBUG_ANY_ID.
#define DEBUG_CDS_REGISTERS 0x00000001
// Data spaces have changed.  If only a single
// space was affected, argument is the data
// space.  Otherwise it is DEBUG_ANY_ID.
#define DEBUG_CDS_DATA      0x00000002

// ChangeEngineState flags.
// The engine state has changed generally.
// Argument is zero.
#define DEBUG_CES_ALL                 0xffffffff
// Current thread changed.  This may imply a change
// of process also.  Argument is the ID of the new
// current thread.
#define DEBUG_CES_CURRENT_THREAD      0x00000001
// Effective processor changed.  Argument is the
// new processor type.
#define DEBUG_CES_EFFECTIVE_PROCESSOR 0x00000002
// Breakpoints changed.  If only a single breakpoint
// changed, argument is the ID of the breakpoint.
// Otherwise it is DEBUG_ANY_ID.
#define DEBUG_CES_BREAKPOINTS         0x00000004
// Code interpretation level changed.  Argument is
// the new level.
#define DEBUG_CES_CODE_LEVEL          0x00000008
// Execution status changed.  Argument is the new
// execution status.
#define DEBUG_CES_EXECUTION_STATUS    0x00000010
// Engine options have changed.  Argument is the new
// options value.
#define DEBUG_CES_ENGINE_OPTIONS      0x00000020
// Log file information has changed.  Argument
// is TRUE if a log file was opened and FALSE if
// a log file was closed.
#define DEBUG_CES_LOG_FILE            0x00000040
// Default number radix has changed.  Argument
// is the new radix.
#define DEBUG_CES_RADIX               0x00000080
// Event filters changed.  If only a single filter
// changed the argument is the filter's index,
// otherwise it is DEBUG_ANY_ID.
#define DEBUG_CES_EVENT_FILTERS       0x00000100
// Process options have changed.  Argument is the new
// options value.
#define DEBUG_CES_PROCESS_OPTIONS     0x00000200
// Extensions have been added or removed.
#define DEBUG_CES_EXTENSIONS          0x00000400

// ChangeSymbolState flags.
// Symbol state has changed generally, such
// as after reload operations.  Argument is zero.
#define DEBUG_CSS_ALL            0xffffffff
// Modules have been loaded.  If only a
// single module changed, argument is the
// base address of the module.  Otherwise
// it is zero.
#define DEBUG_CSS_LOADS          0x00000001
// Modules have been unloaded.  If only a
// single module changed, argument is the
// base address of the module.  Otherwise
// it is zero.
#define DEBUG_CSS_UNLOADS        0x00000002
// Current symbol scope changed.
#define DEBUG_CSS_SCOPE          0x00000004
// Paths have changed.
#define DEBUG_CSS_PATHS          0x00000008
// Symbol options have changed.  Argument is the new
// options value.
#define DEBUG_CSS_SYMBOL_OPTIONS 0x00000010
// Type options have changed.  Argument is the new
// options value.
#define DEBUG_CSS_TYPE_OPTIONS   0x00000020

#undef INTERFACE
#define INTERFACE IDebugEventCallbacks
DECLARE_INTERFACE_(IDebugEventCallbacks, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugEventCallbacks.
    
    // The engine calls GetInterestMask once when
    // the event callbacks are set for a client.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        ) PURE;

    // A breakpoint event is generated when
    // a breakpoint exception is received and
    // it can be mapped to an existing breakpoint.
    // The callback method is given a reference
    // to the breakpoint and should release it when
    // it is done with it.
    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        ) PURE;

    // Exceptions include breaks which cannot
    // be mapped to an existing breakpoint
    // instance.
    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        ) PURE;

    // Any of these values can be zero if they
    // cannot be provided by the engine.
    // Currently the kernel does not return thread
    // or process change events.
    STDMETHOD(CreateThread)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG64 DataOffset,
        IN ULONG64 StartOffset
        ) PURE;
    STDMETHOD(ExitThread)(
        THIS_
        IN ULONG ExitCode
        ) PURE;

    // Any of these values can be zero if they
    // cannot be provided by the engine.
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        ) PURE;
    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        ) PURE;

    // Any of these values may be zero.
    STDMETHOD(LoadModule)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp
        ) PURE;
    STDMETHOD(UnloadModule)(
        THIS_
        IN PCSTR ImageBaseName,
        IN ULONG64 BaseOffset
        ) PURE;

    STDMETHOD(SystemError)(
        THIS_
        IN ULONG Error,
        IN ULONG Level
        ) PURE;

    // Session status is synchronous like the other
    // wait callbacks but it is called as the state
    // of the session is changing rather than at
    // specific events so its return value does not
    // influence waiting.  Implementations should just
    // return DEBUG_STATUS_NO_CHANGE.
    // Also, because some of the status
    // notifications are very early or very
    // late in the session lifetime there may not be
    // current processes or threads when the notification
    // is generated.
    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        ) PURE;

    // The following callbacks are informational
    // callbacks notifying the provider about
    // changes in debug state.  The return value
    // of these callbacks is ignored.  Implementations
    // can not call back into the engine.
    
    // Debuggee state, such as registers or data spaces,
    // has changed.
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        ) PURE;
    // Engine state has changed.
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        ) PURE;
    // Symbol state has changed.
    STDMETHOD(ChangeSymbolState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugInputCallbacks.
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugInputCallbacks
DECLARE_INTERFACE_(IDebugInputCallbacks, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugInputCallbacks.
    
    // A call to the StartInput method is a request for
    // a line of input from any client.  The returned input
    // should always be zero-terminated.  The buffer size
    // provided is only a guideline.  A client can return
    // more if necessary and the engine will truncate it
    // before returning from IDebugControl::Input.
    // The return value is ignored.
    STDMETHOD(StartInput)(
        THIS_
        IN ULONG BufferSize
        ) PURE;
    // The return value is ignored.
    STDMETHOD(EndInput)(
        THIS
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugOutputCallbacks.
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugOutputCallbacks
DECLARE_INTERFACE_(IDebugOutputCallbacks, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugOutputCallbacks.
    
    // This method is only called if the supplied mask
    // is allowed by the clients output control.
    // The return value is ignored.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugRegisters.
//
//----------------------------------------------------------------------------

#define DEBUG_REGISTER_SUB_REGISTER 0x00000001

#define DEBUG_REGISTERS_DEFAULT 0x00000000
#define DEBUG_REGISTERS_INT32   0x00000001
#define DEBUG_REGISTERS_INT64   0x00000002
#define DEBUG_REGISTERS_FLOAT   0x00000004
#define DEBUG_REGISTERS_ALL     0x00000007

typedef struct _DEBUG_REGISTER_DESCRIPTION
{
    // DEBUG_VALUE type.
    ULONG Type;
    ULONG Flags;

    // If this is a subregister the full
    // registers description index is
    // given in SubregMaster.  The length, mask
    // and shift describe how the subregisters
    // bits fit into the full register.
    ULONG SubregMaster;
    ULONG SubregLength;
    ULONG64 SubregMask;
    ULONG SubregShift;

    ULONG Reserved0;
} DEBUG_REGISTER_DESCRIPTION, *PDEBUG_REGISTER_DESCRIPTION;

#undef INTERFACE
#define INTERFACE IDebugRegisters
DECLARE_INTERFACE_(IDebugRegisters, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugRegisters.
    STDMETHOD(GetNumberRegisters)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetDescription)(
        THIS_
        IN ULONG Register,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PDEBUG_REGISTER_DESCRIPTION Desc
        ) PURE;
    STDMETHOD(GetIndexByName)(
        THIS_
        IN PCSTR Name,
        OUT PULONG Index
        ) PURE;

    STDMETHOD(GetValue)(
        THIS_
        IN ULONG Register,
        OUT PDEBUG_VALUE Value
        ) PURE;
    // SetValue makes a best effort at coercing
    // the given value into the given registers
    // value type.  If the given value is larger
    // than the register can hold the least
    // significant bits will be dropped.  Float
    // to int and int to float will be done
    // if necessary.  Subregister bits will be
    // inserted into the master register.
    STDMETHOD(SetValue)(
        THIS_
        IN ULONG Register,
        IN PDEBUG_VALUE Value
        ) PURE;
    // Gets Count register values.  If Indices is
    // non-NULL it must contain Count register
    // indices which control the registers affected.
    // If Indices is NULL the registers from Start
    // to Start + Count  1 are retrieved.
    STDMETHOD(GetValues)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Indices,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_VALUE Values
        ) PURE;
    STDMETHOD(SetValues)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Indices,
        IN ULONG Start,
        IN /* size_is(Count) */ PDEBUG_VALUE Values
        ) PURE;
        
    // Outputs a group of registers in a well-formatted
    // way thats specific to the platforms register set.
    // Uses the line prefix.
    STDMETHOD(OutputRegisters)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        ) PURE;

    // Abstracted pieces of processor information.
    // The mapping of these values to architectural
    // registers is architecture-specific and their
    // interpretation and existence may vary.  They
    // are intended to be directly compatible with
    // calls which take this information, such as
    // stack walking.
    STDMETHOD(GetInstructionOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(GetStackOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(GetFrameOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugSymbolGroup
//
//----------------------------------------------------------------------------

// OutputSymbols flags.
// Default output contains <Name>**NAME**<Offset>**OFF**<Value>**VALUE**
// per symbol.
#define DEBUG_OUTPUT_SYMBOLS_DEFAULT    0x00000000
#define DEBUG_OUTPUT_SYMBOLS_NO_NAMES   0x00000001
#define DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS 0x00000002
#define DEBUG_OUTPUT_SYMBOLS_NO_VALUES  0x00000004
#define DEBUG_OUTPUT_SYMBOLS_NO_TYPES   0x00000010

#define DEBUG_OUTPUT_NAME_END           "**NAME**"
#define DEBUG_OUTPUT_OFFSET_END         "**OFF**"
#define DEBUG_OUTPUT_VALUE_END          "**VALUE**"
#define DEBUG_OUTPUT_TYPE_END           "**TYPE**"

// DEBUG_SYMBOL_PARAMETERS flags.
// Cumulative expansion level, takes four bits.
#define DEBUG_SYMBOL_EXPANSION_LEVEL_MASK 0x0000000f
// Symbols subelements follow.
#define DEBUG_SYMBOL_EXPANDED             0x00000010
// Symbols value is read-only.
#define DEBUG_SYMBOL_READ_ONLY            0x00000020
// Symbol subelements are array elements.
#define DEBUG_SYMBOL_IS_ARRAY             0x00000040
// Symbol is a float value.
#define DEBUG_SYMBOL_IS_FLOAT             0x00000080
// Symbol is a scope argument.
#define DEBUG_SYMBOL_IS_ARGUMENT          0x00000100
// Symbol is a scope argument.
#define DEBUG_SYMBOL_IS_LOCAL             0x00000200

typedef struct _DEBUG_SYMBOL_PARAMETERS
{
    ULONG64 Module;
    ULONG TypeId;
    // ParentSymbol may be DEBUG_ANY_ID when unknown.
    ULONG ParentSymbol;
    // A subelement of a symbol can be a field, such
    // as in structs, unions or classes; or an array
    // element count for arrays.
    ULONG SubElements;
    ULONG Flags;
    ULONG64 Reserved;
} DEBUG_SYMBOL_PARAMETERS, *PDEBUG_SYMBOL_PARAMETERS;

#undef INTERFACE
#define INTERFACE IDebugSymbolGroup
DECLARE_INTERFACE_(IDebugSymbolGroup, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbolGroup.
    STDMETHOD(GetNumberSymbols)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(AddSymbol)(
        THIS_
        IN PCSTR Name,
        OUT PULONG Index
        ) PURE;
    STDMETHOD(RemoveSymbolByName)(
        THIS_
        IN PCSTR Name
        ) PURE;
    STDMETHOD(RemoveSymbolByIndex)(
        THIS_
        IN ULONG Index
        ) PURE;
    STDMETHOD(GetSymbolName)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;
    STDMETHOD(GetSymbolParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SYMBOL_PARAMETERS Params
        ) PURE;
    STDMETHOD(ExpandSymbol)(
        THIS_
        IN ULONG Index,
        IN BOOL Expand
        ) PURE;
    // Uses the line prefix.
    STDMETHOD(OutputSymbols)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN ULONG Start,
        IN ULONG Count
        ) PURE;
    STDMETHOD(WriteSymbol)(
        THIS_
        IN ULONG Index,
        IN PCSTR Value
        ) PURE;
    STDMETHOD(OutputAsType)(
        THIS_
        IN ULONG Index,
        IN PCSTR Type
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugSymbols.
//
//----------------------------------------------------------------------------

//
// Information about a module.
//

// Flags.
#define DEBUG_MODULE_LOADED   0x00000000
#define DEBUG_MODULE_UNLOADED 0x00000001

// Symbol types.
#define DEBUG_SYMTYPE_NONE     0
#define DEBUG_SYMTYPE_COFF     1
#define DEBUG_SYMTYPE_CODEVIEW 2
#define DEBUG_SYMTYPE_PDB      3
#define DEBUG_SYMTYPE_EXPORT   4
#define DEBUG_SYMTYPE_DEFERRED 5
#define DEBUG_SYMTYPE_SYM      6
#define DEBUG_SYMTYPE_DIA      7

typedef struct _DEBUG_MODULE_PARAMETERS
{
    ULONG64 Base;
    ULONG Size;
    ULONG TimeDateStamp;
    ULONG Checksum;
    ULONG Flags;
    ULONG SymbolType;
    ULONG ImageNameSize;
    ULONG ModuleNameSize;
    ULONG LoadedImageNameSize;
    ULONG SymbolFileNameSize;
    ULONG MappedImageNameSize;
    ULONG64 Reserved[2];
} DEBUG_MODULE_PARAMETERS, *PDEBUG_MODULE_PARAMETERS;

// Scope arguments are function arguments
// and thus only change when the scope
// crosses functions.
#define DEBUG_SCOPE_GROUP_ARGUMENTS 0x00000001
// Scope locals are locals declared in a particular
// scope and are only defined within that scope.
#define DEBUG_SCOPE_GROUP_LOCALS    0x00000002
// All symbols in the scope.
#define DEBUG_SCOPE_GROUP_ALL       0x00000003

// Typed data output control flags.
#define DEBUG_OUTTYPE_DEFAULT              0x00000000
#define DEBUG_OUTTYPE_NO_INDENT            0x00000001
#define DEBUG_OUTTYPE_NO_OFFSET            0x00000002
#define DEBUG_OUTTYPE_VERBOSE              0x00000004
#define DEBUG_OUTTYPE_COMPACT_OUTPUT       0x00000008
#define DEBUG_OUTTYPE_RECURSION_LEVEL(Max) (((Max) & 0xf) << 4)
#define DEBUG_OUTTYPE_ADDRESS_OF_FIELD     0x00010000
#define DEBUG_OUTTYPE_ADDRESS_AT_END       0x00020000
#define DEBUG_OUTTYPE_BLOCK_RECURSE        0x00200000

// FindSourceFile flags.
#define DEBUG_FIND_SOURCE_DEFAULT    0x00000000
// Returns fully-qualified paths only.  If this
// is not set the path returned may be relative.
#define DEBUG_FIND_SOURCE_FULL_PATH  0x00000001
// Scans all the path elements for a match and
// returns the one that has the most similarity
// between the given file and the matching element.
#define DEBUG_FIND_SOURCE_BEST_MATCH 0x00000002

// A special value marking an offset that should not
// be treated as a valid offset.  This is only used
// in special situations where it is unlikely that
// this value would be a valid offset.
#define DEBUG_INVALID_OFFSET ((ULONG64)-1)

#undef INTERFACE
#define INTERFACE IDebugSymbols
DECLARE_INTERFACE_(IDebugSymbols, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbols.

    // Controls the symbol options used during
    // symbol operations.
    // Uses the same flags as dbghelps SymSetOptions.
    STDMETHOD(GetSymbolOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    STDMETHOD(GetNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
    // A symbol name may not be unique, particularly
    // when overloaded functions exist which all
    // have the same name.  If GetOffsetByName
    // finds multiple matches for the name it
    // can return any one of them.  In that
    // case it will return S_FALSE to indicate
    // that ambiguity was arbitrarily resolved.
    // A caller can then use SearchSymbols to
    // find all of the matches if it wishes to
    // perform different disambiguation.
    STDMETHOD(GetOffsetByName)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Offset
        ) PURE;
    // GetNearNameByOffset returns symbols
    // located near the symbol closest to
    // to the offset, such as the previous
    // or next symbol.  If Delta is zero it
    // operates identically to GetNameByOffset.
    // If Delta is nonzero and such a symbol
    // does not exist an error is returned.
    // The next symbol, if one exists, will
    // always have a higher offset than the
    // input offset so the displacement is
    // always negative.  The situation is
    // reversed for the previous symbol.
    STDMETHOD(GetNearNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
            
    STDMETHOD(GetLineByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PULONG Line,
        OUT OPTIONAL PSTR FileBuffer,
        IN ULONG FileBufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
    STDMETHOD(GetOffsetByLine)(
        THIS_
        IN ULONG Line,
        IN PCSTR File,
        OUT PULONG64 Offset
        ) PURE;

    // Enumerates the engines list of modules
    // loaded for the current process.  This may
    // or may not match the system module list
    // for the process.  Reload can be used to
    // synchronize the engines list with the system
    // if necessary.
    // Some sessions also track recently unloaded
    // code modules for help in analyzing failures
    // where an attempt is made to call unloaded code.
    // These modules are indexed after the loaded
    // modules.
    STDMETHOD(GetNumberModules)(
        THIS_
        OUT PULONG Loaded,
        OUT PULONG Unloaded
        ) PURE;
    STDMETHOD(GetModuleByIndex)(
        THIS_
        IN ULONG Index,
        OUT PULONG64 Base
        ) PURE;
    // The module name may not be unique.
    // This method returns the first match.
    STDMETHOD(GetModuleByModuleName)(
        THIS_
        IN PCSTR Name,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        ) PURE;
    // Offset can be any offset within
    // the module extent.  Extents may
    // not be unique when including unloaded
    // drivers.  This method returns the
    // first match.
    STDMETHOD(GetModuleByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        ) PURE;
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    STDMETHOD(GetModuleNames)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR ImageNameBuffer,
        IN ULONG ImageNameBufferSize,
        OUT OPTIONAL PULONG ImageNameSize,
        OUT OPTIONAL PSTR ModuleNameBuffer,
        IN ULONG ModuleNameBufferSize,
        OUT OPTIONAL PULONG ModuleNameSize,
        OUT OPTIONAL PSTR LoadedImageNameBuffer,
        IN ULONG LoadedImageNameBufferSize,
        OUT OPTIONAL PULONG LoadedImageNameSize
        ) PURE;
    STDMETHOD(GetModuleParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG64 Bases,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_MODULE_PARAMETERS Params
        ) PURE;
    // Looks up the module from a <Module>!<Symbol>
    // string.
    STDMETHOD(GetSymbolModule)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Base
        ) PURE;

    // Returns the string name of a type.
    STDMETHOD(GetTypeName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;
    // Returns the ID for a type name.
    STDMETHOD(GetTypeId)(
        THIS_
        IN ULONG64 Module,
        IN PCSTR Name,
        OUT PULONG TypeId
        ) PURE;
    STDMETHOD(GetTypeSize)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PULONG Size
        ) PURE;
    // Given a type which can contain members
    // this method returns the offset of a
    // particular member within the type.
    // TypeId should give the container type ID
    // and Field gives the dot-separated path
    // to the field of interest.
    STDMETHOD(GetFieldOffset)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PCSTR Field,
        OUT PULONG Offset
        ) PURE;

    STDMETHOD(GetSymbolTypeId)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        ) PURE;
    // As with GetOffsetByName a symbol's
    // name may be ambiguous.  GetOffsetTypeId
    // returns the type for the symbol closest
    // to the given offset and can be used
    // to avoid ambiguity.
    STDMETHOD(GetOffsetTypeId)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        ) PURE;

    // Helpers for virtual and physical data
    // which combine creation of a location with
    // the actual operation.
    STDMETHOD(ReadTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataVirtual)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        ) PURE;
    STDMETHOD(ReadTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataPhysical)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        ) PURE;
            
    // Function arguments and scope block symbols
    // can be retrieved relative to currently
    // executing code.  A caller can provide just
    // a code offset for scoping purposes and look
    // up names or the caller can provide a full frame
    // and look up actual values.  The values for
    // scoped symbols are best-guess and may or may not
    // be accurate depending on program optimizations,
    // the machine architecture, the current point
    // in the programs execution and so on.
    // A caller can also provide a complete register
    // context for setting a scope to a previous
    // machine state such as a context saved for
    // an exception.  Usually this isnt necessary
    // and the current register context is used.
    STDMETHOD(GetScope)(
        THIS_
        OUT OPTIONAL PULONG64 InstructionOffset,
        OUT OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        OUT OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        ) PURE;
    // If ScopeFrame or ScopeContext is non-NULL then
    // InstructionOffset is ignored.
    // If ScopeContext is NULL the current
    // register context is used.
    // If the scope identified by the given
    // information is the same as before
    // SetScope returns S_OK.  If the scope
    // information changes, such as when the
    // scope moves between functions or scope
    // blocks, SetScope returns S_FALSE.
    STDMETHOD(SetScope)(
        THIS_
        IN ULONG64 InstructionOffset,
        IN OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        IN OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        ) PURE;
    // ResetScope clears the scope information
    // for situations where scoped symbols
    // mask global symbols or when resetting
    // from explicit information to the current
    // information.
    STDMETHOD(ResetScope)(
        THIS
        ) PURE;
    // A scope symbol is tied to its particular
    // scope and only is meaningful within the scope.
    // The returned group can be updated by passing it back
    // into the method for lower-cost
    // incremental updates when stepping.
    STDMETHOD(GetScopeSymbolGroup)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PDEBUG_SYMBOL_GROUP Update,
        OUT PDEBUG_SYMBOL_GROUP* Symbols
        ) PURE;

    // Create a new symbol group.
    STDMETHOD(CreateSymbolGroup)(
        THIS_
        OUT PDEBUG_SYMBOL_GROUP* Group
        ) PURE;

    // StartSymbolMatch matches symbol names
    // against the given pattern using simple
    // regular expressions.  The search results
    // are iterated through using GetNextSymbolMatch.
    // When the caller is done examining results
    // the match should be freed via EndSymbolMatch.
    // If the match pattern contains a module name
    // the search is restricted to a single module.
    // Pattern matching is only done on symbol names,
    // not module names.
    // All active symbol match handles are invalidated
    // when the set of loaded symbols changes.
    STDMETHOD(StartSymbolMatch)(
        THIS_
        IN PCSTR Pattern,
        OUT PULONG64 Handle
        ) PURE;
    // If Buffer is NULL the match does not
    // advance.
    STDMETHOD(GetNextSymbolMatch)(
        THIS_
        IN ULONG64 Handle,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MatchSize,
        OUT OPTIONAL PULONG64 Offset
        ) PURE;
    STDMETHOD(EndSymbolMatch)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    
    STDMETHOD(Reload)(
        THIS_
        IN PCSTR Module
        ) PURE;

    STDMETHOD(GetSymbolPath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    STDMETHOD(SetSymbolPath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendSymbolPath)(
        THIS_
        IN PCSTR Addition
        ) PURE;
    
    // Manipulate the path for executable images.
    // Some dump files need to load executable images
    // in order to resolve dump information.  This
    // path controls where the engine looks for
    // images.
    STDMETHOD(GetImagePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    STDMETHOD(SetImagePath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendImagePath)(
        THIS_
        IN PCSTR Addition
        ) PURE;

    // Path routines for source file location
    // methods.
    STDMETHOD(GetSourcePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    // Gets the nth part of the source path.
    STDMETHOD(GetSourcePathElement)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ElementSize
        ) PURE;
    STDMETHOD(SetSourcePath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendSourcePath)(
        THIS_
        IN PCSTR Addition
        ) PURE;
    // Uses the given file path and the source path
    // information to try and locate an existing file.
    // The given file path is merged with elements
    // of the source path and checked for existence.
    // If a match is found the element used is returned.
    // A starting element can be specified to restrict
    // the search to a subset of the path elements;
    // this can be useful when checking for multiple
    // matches along the source path.
    // The returned element can be 1, indicating
    // the file was found directly and not on the path.
    STDMETHOD(FindSourceFile)(
        THIS_
        IN ULONG StartElement,
        IN PCSTR File,
        IN ULONG Flags,
        OUT OPTIONAL PULONG FoundElement,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FoundSize
        ) PURE;
    // Retrieves all the line offset information
    // for a particular source file.  Buffer is
    // first intialized to DEBUG_INVALID_OFFSET for
    // every entry.  Then for each piece of line
    // symbol information Buffer[Line] set to
    // Lines offset.  This produces a per-line
    // map of the offsets for the lines of the
    // given file.  Line numbers are decremented
    // for the map so Buffer[0] contains the offset
    // for line number 1.
    // If there is no line information at all for
    // the given file the method fails rather
    // than returning a map of invalid offsets.
    STDMETHOD(GetSourceFileLineOffsets)(
        THIS_
        IN PCSTR File,
        OUT OPTIONAL /* size_is(BufferLines) */ PULONG64 Buffer,
        IN ULONG BufferLines,
        OUT OPTIONAL PULONG FileLines
        ) PURE;
};

//
// GetModuleNameString strings.
//

#define DEBUG_MODNAME_IMAGE        0x00000000
#define DEBUG_MODNAME_MODULE       0x00000001
#define DEBUG_MODNAME_LOADED_IMAGE 0x00000002
#define DEBUG_MODNAME_SYMBOL_FILE  0x00000003
#define DEBUG_MODNAME_MAPPED_IMAGE 0x00000004

//
// Type options, used with Get/SetTypeOptions.
//

// Display PUSHORT and USHORT arrays in UNICODE
#define DEBUG_TYPEOPTS_UNICODE_DISPLAY 0x00000001

#undef INTERFACE
#define INTERFACE IDebugSymbols2
DECLARE_INTERFACE_(IDebugSymbols2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSymbols.

    // Controls the symbol options used during
    // symbol operations.
    // Uses the same flags as dbghelps SymSetOptions.
    STDMETHOD(GetSymbolOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetSymbolOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    
    STDMETHOD(GetNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
    // A symbol name may not be unique, particularly
    // when overloaded functions exist which all
    // have the same name.  If GetOffsetByName
    // finds multiple matches for the name it
    // can return any one of them.  In that
    // case it will return S_FALSE to indicate
    // that ambiguity was arbitrarily resolved.
    // A caller can then use SearchSymbols to
    // find all of the matches if it wishes to
    // perform different disambiguation.
    STDMETHOD(GetOffsetByName)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Offset
        ) PURE;
    // GetNearNameByOffset returns symbols
    // located near the symbol closest to
    // to the offset, such as the previous
    // or next symbol.  If Delta is zero it
    // operates identically to GetNameByOffset.
    // If Delta is nonzero and such a symbol
    // does not exist an error is returned.
    // The next symbol, if one exists, will
    // always have a higher offset than the
    // input offset so the displacement is
    // always negative.  The situation is
    // reversed for the previous symbol.
    STDMETHOD(GetNearNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
            
    STDMETHOD(GetLineByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PULONG Line,
        OUT OPTIONAL PSTR FileBuffer,
        IN ULONG FileBufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT OPTIONAL PULONG64 Displacement
        ) PURE;
    STDMETHOD(GetOffsetByLine)(
        THIS_
        IN ULONG Line,
        IN PCSTR File,
        OUT PULONG64 Offset
        ) PURE;

    // Enumerates the engines list of modules
    // loaded for the current process.  This may
    // or may not match the system module list
    // for the process.  Reload can be used to
    // synchronize the engines list with the system
    // if necessary.
    // Some sessions also track recently unloaded
    // code modules for help in analyzing failures
    // where an attempt is made to call unloaded code.
    // These modules are indexed after the loaded
    // modules.
    STDMETHOD(GetNumberModules)(
        THIS_
        OUT PULONG Loaded,
        OUT PULONG Unloaded
        ) PURE;
    STDMETHOD(GetModuleByIndex)(
        THIS_
        IN ULONG Index,
        OUT PULONG64 Base
        ) PURE;
    // The module name may not be unique.
    // This method returns the first match.
    STDMETHOD(GetModuleByModuleName)(
        THIS_
        IN PCSTR Name,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        ) PURE;
    // Offset can be any offset within
    // the module extent.  Extents may
    // not be unique when including unloaded
    // drivers.  This method returns the
    // first match.
    STDMETHOD(GetModuleByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        ) PURE;
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    STDMETHOD(GetModuleNames)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR ImageNameBuffer,
        IN ULONG ImageNameBufferSize,
        OUT OPTIONAL PULONG ImageNameSize,
        OUT OPTIONAL PSTR ModuleNameBuffer,
        IN ULONG ModuleNameBufferSize,
        OUT OPTIONAL PULONG ModuleNameSize,
        OUT OPTIONAL PSTR LoadedImageNameBuffer,
        IN ULONG LoadedImageNameBufferSize,
        OUT OPTIONAL PULONG LoadedImageNameSize
        ) PURE;
    STDMETHOD(GetModuleParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG64 Bases,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_MODULE_PARAMETERS Params
        ) PURE;
    // Looks up the module from a <Module>!<Symbol>
    // string.
    STDMETHOD(GetSymbolModule)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Base
        ) PURE;

    // Returns the string name of a type.
    STDMETHOD(GetTypeName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;
    // Returns the ID for a type name.
    STDMETHOD(GetTypeId)(
        THIS_
        IN ULONG64 Module,
        IN PCSTR Name,
        OUT PULONG TypeId
        ) PURE;
    STDMETHOD(GetTypeSize)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PULONG Size
        ) PURE;
    // Given a type which can contain members
    // this method returns the offset of a
    // particular member within the type.
    // TypeId should give the container type ID
    // and Field gives the dot-separated path
    // to the field of interest.
    STDMETHOD(GetFieldOffset)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PCSTR Field,
        OUT PULONG Offset
        ) PURE;

    STDMETHOD(GetSymbolTypeId)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        ) PURE;
    // As with GetOffsetByName a symbol's
    // name may be ambiguous.  GetOffsetTypeId
    // returns the type for the symbol closest
    // to the given offset and can be used
    // to avoid ambiguity.
    STDMETHOD(GetOffsetTypeId)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        ) PURE;

    // Helpers for virtual and physical data
    // which combine creation of a location with
    // the actual operation.
    STDMETHOD(ReadTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataVirtual)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        ) PURE;
    STDMETHOD(ReadTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(OutputTypedDataPhysical)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        ) PURE;
            
    // Function arguments and scope block symbols
    // can be retrieved relative to currently
    // executing code.  A caller can provide just
    // a code offset for scoping purposes and look
    // up names or the caller can provide a full frame
    // and look up actual values.  The values for
    // scoped symbols are best-guess and may or may not
    // be accurate depending on program optimizations,
    // the machine architecture, the current point
    // in the programs execution and so on.
    // A caller can also provide a complete register
    // context for setting a scope to a previous
    // machine state such as a context saved for
    // an exception.  Usually this isnt necessary
    // and the current register context is used.
    STDMETHOD(GetScope)(
        THIS_
        OUT OPTIONAL PULONG64 InstructionOffset,
        OUT OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        OUT OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        ) PURE;
    // If ScopeFrame or ScopeContext is non-NULL then
    // InstructionOffset is ignored.
    // If ScopeContext is NULL the current
    // register context is used.
    // If the scope identified by the given
    // information is the same as before
    // SetScope returns S_OK.  If the scope
    // information changes, such as when the
    // scope moves between functions or scope
    // blocks, SetScope returns S_FALSE.
    STDMETHOD(SetScope)(
        THIS_
        IN ULONG64 InstructionOffset,
        IN OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        IN OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        ) PURE;
    // ResetScope clears the scope information
    // for situations where scoped symbols
    // mask global symbols or when resetting
    // from explicit information to the current
    // information.
    STDMETHOD(ResetScope)(
        THIS
        ) PURE;
    // A scope symbol is tied to its particular
    // scope and only is meaningful within the scope.
    // The returned group can be updated by passing it back
    // into the method for lower-cost
    // incremental updates when stepping.
    STDMETHOD(GetScopeSymbolGroup)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PDEBUG_SYMBOL_GROUP Update,
        OUT PDEBUG_SYMBOL_GROUP* Symbols
        ) PURE;

    // Create a new symbol group.
    STDMETHOD(CreateSymbolGroup)(
        THIS_
        OUT PDEBUG_SYMBOL_GROUP* Group
        ) PURE;

    // StartSymbolMatch matches symbol names
    // against the given pattern using simple
    // regular expressions.  The search results
    // are iterated through using GetNextSymbolMatch.
    // When the caller is done examining results
    // the match should be freed via EndSymbolMatch.
    // If the match pattern contains a module name
    // the search is restricted to a single module.
    // Pattern matching is only done on symbol names,
    // not module names.
    // All active symbol match handles are invalidated
    // when the set of loaded symbols changes.
    STDMETHOD(StartSymbolMatch)(
        THIS_
        IN PCSTR Pattern,
        OUT PULONG64 Handle
        ) PURE;
    // If Buffer is NULL the match does not
    // advance.
    STDMETHOD(GetNextSymbolMatch)(
        THIS_
        IN ULONG64 Handle,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MatchSize,
        OUT OPTIONAL PULONG64 Offset
        ) PURE;
    STDMETHOD(EndSymbolMatch)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    
    STDMETHOD(Reload)(
        THIS_
        IN PCSTR Module
        ) PURE;

    STDMETHOD(GetSymbolPath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    STDMETHOD(SetSymbolPath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendSymbolPath)(
        THIS_
        IN PCSTR Addition
        ) PURE;
    
    // Manipulate the path for executable images.
    // Some dump files need to load executable images
    // in order to resolve dump information.  This
    // path controls where the engine looks for
    // images.
    STDMETHOD(GetImagePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    STDMETHOD(SetImagePath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendImagePath)(
        THIS_
        IN PCSTR Addition
        ) PURE;

    // Path routines for source file location
    // methods.
    STDMETHOD(GetSourcePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        ) PURE;
    // Gets the nth part of the source path.
    STDMETHOD(GetSourcePathElement)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ElementSize
        ) PURE;
    STDMETHOD(SetSourcePath)(
        THIS_
        IN PCSTR Path
        ) PURE;
    STDMETHOD(AppendSourcePath)(
        THIS_
        IN PCSTR Addition
        ) PURE;
    // Uses the given file path and the source path
    // information to try and locate an existing file.
    // The given file path is merged with elements
    // of the source path and checked for existence.
    // If a match is found the element used is returned.
    // A starting element can be specified to restrict
    // the search to a subset of the path elements;
    // this can be useful when checking for multiple
    // matches along the source path.
    // The returned element can be 1, indicating
    // the file was found directly and not on the path.
    STDMETHOD(FindSourceFile)(
        THIS_
        IN ULONG StartElement,
        IN PCSTR File,
        IN ULONG Flags,
        OUT OPTIONAL PULONG FoundElement,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FoundSize
        ) PURE;
    // Retrieves all the line offset information
    // for a particular source file.  Buffer is
    // first intialized to DEBUG_INVALID_OFFSET for
    // every entry.  Then for each piece of line
    // symbol information Buffer[Line] set to
    // Lines offset.  This produces a per-line
    // map of the offsets for the lines of the
    // given file.  Line numbers are decremented
    // for the map so Buffer[0] contains the offset
    // for line number 1.
    // If there is no line information at all for
    // the given file the method fails rather
    // than returning a map of invalid offsets.
    STDMETHOD(GetSourceFileLineOffsets)(
        THIS_
        IN PCSTR File,
        OUT OPTIONAL /* size_is(BufferLines) */ PULONG64 Buffer,
        IN ULONG BufferLines,
        OUT OPTIONAL PULONG FileLines
        ) PURE;

    // IDebugSymbols2.

    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    // Item is specified as in VerQueryValue.
    // Module version information is only
    // available for loaded modules and may
    // not be available in all debug sessions.
    STDMETHOD(GetModuleVersionInformation)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        IN PCSTR Item,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG VerInfoSize
        ) PURE;
    // Retrieves any available module name string
    // such as module name or symbol file name.
    // If Index is DEBUG_ANY_ID the base address
    // is used to look up the module instead.
    // If symbols are deferred an error will
    // be returned.
    // E_NOINTERFACE may be returned, indicating
    // no information exists.
    STDMETHOD(GetModuleNameString)(
        THIS_
        IN ULONG Which,
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;

    // Returns the string name of a constant type.
    STDMETHOD(GetConstantName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG64 Value,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;
    
    // Gets name of a field in a struct
    // FieldNumber is 0 based index of field in a struct
    // Method fails with E_INVALIDARG if FieldNumber is
    // too high for the struct fields
    STDMETHOD(GetFieldName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG FieldIndex,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        ) PURE;

    // Control options for typed values.
    STDMETHOD(GetTypeOptions)(
        THIS_
        OUT PULONG Options
        ) PURE;
    STDMETHOD(AddTypeOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(RemoveTypeOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetTypeOptions)(
        THIS_
        IN ULONG Options
        ) PURE;
};

//----------------------------------------------------------------------------
//
// IDebugSystemObjects
//
//----------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDebugSystemObjects
DECLARE_INTERFACE_(IDebugSystemObjects, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSystemObjects.
    
    // In user mode debugging the debugger
    // tracks all threads and processes and
    // enumerates them through the following
    // methods.  When enumerating threads
    // the threads are enumerated for the current
    // process.
    // Kernel mode debugging currently is
    // limited to enumerating only the threads
    // assigned to processors, not all of
    // the threads in the system.  Process
    // enumeration is limited to a single
    // virtual process representing kernel space.
    
    // Returns the ID of the thread on which
    // the last event occurred.
    STDMETHOD(GetEventThread)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetEventProcess)(
        THIS_
        OUT PULONG Id
        ) PURE;
    
    // Controls implicit thread used by the
    // debug engine.  The debuggers current
    // thread is just a piece of data held
    // by the debugger for calls which use
    // thread-specific information.  In those
    // calls the debuggers current thread is used.
    // The debuggers current thread is not related
    // to any system thread attribute.
    // IDs for threads are small integer IDs
    // maintained by the engine.  They are not
    // related to system thread IDs.
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        IN ULONG Id
        ) PURE;
    // The current process is the process
    // that owns the current thread.
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    // Setting the current process automatically
    // sets the current thread to the thread that
    // was last current in that process.
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        IN ULONG Id
        ) PURE;

    // Gets the number of threads in the current process.
    STDMETHOD(GetNumberThreads)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // Gets thread count information for all processes
    // and the largest number of threads in a single process.
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        OUT PULONG Total,
        OUT PULONG LargestProcess
        ) PURE;
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        ) PURE;
    // Gets the debugger ID for the thread
    // currently running on the given
    // processor.  Only works in kernel
    // debugging.
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        IN ULONG Processor,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // system data structure.  When kernel debugging
    // this is the offset of the KTHREAD.
    // When user debugging it is the offset
    // of the current TEB.
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread data structure.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // TEB.  In user mode this is equivalent to
    // the threads data offset.
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given TEB.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the system unique ID for the current thread.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        OUT PULONG SysId
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread ID.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        IN ULONG SysId,
        OUT PULONG Id
        ) PURE;
    // Returns the handle of the current thread.
    // In kernel mode the value returned is the
    // index of the processor the thread is
    // executing on plus one.
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    // Looks up a debugger thread ID for the given handle.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        ) PURE;
    
    // Currently kernel mode sessions will only have
    // a single process representing kernel space.
    STDMETHOD(GetNumberProcesses)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        ) PURE;
    // Returns the offset of the current processs
    // system data structure.  When kernel debugging
    // this is the offset of the KPROCESS of
    // the process that owns the current thread.
    // When user debugging it is the offset
    // of the current PEB.
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process data structure.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current processs
    // PEB.  In user mode this is equivalent to
    // the processs data offset.
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given PEB.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the system unique ID for the current process.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        OUT PULONG SysId
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process ID.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_                                      
        IN ULONG SysId,
        OUT PULONG Id
        ) PURE;
    // Returns the handle of the current process.
    // In kernel mode this is the kernel processs
    // artificial handle used for symbol operations
    // and so can only be used with dbghelp APIs.
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    // Looks up a debugger process ID for the given handle.
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        ) PURE;
    // Retrieve the name of the executable loaded
    // in the process.  This may fail if no executable
    // was identified.
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExeSize
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IDebugSystemObjects2
DECLARE_INTERFACE_(IDebugSystemObjects2, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IDebugSystemObjects.
    
    // In user mode debugging the debugger
    // tracks all threads and processes and
    // enumerates them through the following
    // methods.  When enumerating threads
    // the threads are enumerated for the current
    // process.
    // Kernel mode debugging currently is
    // limited to enumerating only the threads
    // assigned to processors, not all of
    // the threads in the system.  Process
    // enumeration is limited to a single
    // virtual process representing kernel space.
    
    // Returns the ID of the thread on which
    // the last event occurred.
    STDMETHOD(GetEventThread)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetEventProcess)(
        THIS_
        OUT PULONG Id
        ) PURE;
    
    // Controls implicit thread used by the
    // debug engine.  The debuggers current
    // thread is just a piece of data held
    // by the debugger for calls which use
    // thread-specific information.  In those
    // calls the debuggers current thread is used.
    // The debuggers current thread is not related
    // to any system thread attribute.
    // IDs for threads are small integer IDs
    // maintained by the engine.  They are not
    // related to system thread IDs.
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        IN ULONG Id
        ) PURE;
    // The current process is the process
    // that owns the current thread.
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        OUT PULONG Id
        ) PURE;
    // Setting the current process automatically
    // sets the current thread to the thread that
    // was last current in that process.
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        IN ULONG Id
        ) PURE;

    // Gets the number of threads in the current process.
    STDMETHOD(GetNumberThreads)(
        THIS_
        OUT PULONG Number
        ) PURE;
    // Gets thread count information for all processes
    // and the largest number of threads in a single process.
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        OUT PULONG Total,
        OUT PULONG LargestProcess
        ) PURE;
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        ) PURE;
    // Gets the debugger ID for the thread
    // currently running on the given
    // processor.  Only works in kernel
    // debugging.
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        IN ULONG Processor,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // system data structure.  When kernel debugging
    // this is the offset of the KTHREAD.
    // When user debugging it is the offset
    // of the current TEB.
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread data structure.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current threads
    // TEB.  In user mode this is equivalent to
    // the threads data offset.
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger thread ID for the given TEB.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the system unique ID for the current thread.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        OUT PULONG SysId
        ) PURE;
    // Looks up a debugger thread ID for the given
    // system thread ID.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        IN ULONG SysId,
        OUT PULONG Id
        ) PURE;
    // Returns the handle of the current thread.
    // In kernel mode the value returned is the
    // index of the processor the thread is
    // executing on plus one.
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    // Looks up a debugger thread ID for the given handle.
    // Currently when kernel debugging this will fail
    // if the thread is not executing on a processor.
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        ) PURE;
    
    // Currently kernel mode sessions will only have
    // a single process representing kernel space.
    STDMETHOD(GetNumberProcesses)(
        THIS_
        OUT PULONG Number
        ) PURE;
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        ) PURE;
    // Returns the offset of the current processs
    // system data structure.  When kernel debugging
    // this is the offset of the KPROCESS of
    // the process that owns the current thread.
    // When user debugging it is the offset
    // of the current PEB.
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process data structure.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the offset of the current processs
    // PEB.  In user mode this is equivalent to
    // the processs data offset.
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    // Looks up a debugger process ID for the given PEB.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        ) PURE;
    // Returns the system unique ID for the current process.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        OUT PULONG SysId
        ) PURE;
    // Looks up a debugger process ID for the given
    // system process ID.
    // Not currently supported when kernel debugging.
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_                                      
        IN ULONG SysId,
        OUT PULONG Id
        ) PURE;
    // Returns the handle of the current process.
    // In kernel mode this is the kernel processs
    // artificial handle used for symbol operations
    // and so can only be used with dbghelp APIs.
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        OUT PULONG64 Handle
        ) PURE;
    // Looks up a debugger process ID for the given handle.
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        ) PURE;
    // Retrieve the name of the executable loaded
    // in the process.  This may fail if no executable
    // was identified.
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExeSize
        ) PURE;

    // IDebugSystemObjects2.

    // Return the number of seconds that the current
    // process has been running.
    STDMETHOD(GetCurrentProcessUpTime)(
        THIS_
        OUT PULONG UpTime
        ) PURE;

    // During kernel sessions the debugger retrieves
    // some information from the system thread and process
    // running on the current processor.  For example,
    // the debugger will retrieve virtual memory translation
    // information for when the debugger needs to
    // carry out its own virtual to physical translations.
    // Occasionally it can be interesting to perform
    // similar operations but on a process which isnt
    // currently running.  The follow methods allow a caller
    // to override the data offsets used by the debugger
    // so that other system threads and processes can
    // be used instead.  These values are defaulted to
    // the thread and process running on the current
    // processor each time the debuggee executes or
    // the current processor changes.
    // The thread and process settings are independent so
    // it is possible to refer to a thread in a process
    // other than the current process and vice versa.
    // Setting an offset of zero will reload the
    // default value.
    STDMETHOD(GetImplicitThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitThreadDataOffset)(
        THIS_
        IN ULONG64 Offset
        ) PURE;
    STDMETHOD(GetImplicitProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(SetImplicitProcessDataOffset)(
        THIS_
        IN ULONG64 Offset
        ) PURE;
};

//----------------------------------------------------------------------------
//
// Extension callbacks.
//
//----------------------------------------------------------------------------

// Returns a version with the major version in
// the high word and the minor version in the low word.
#define DEBUG_EXTENSION_VERSION(Major, Minor) \
    ((((Major) & 0xffff) << 16) | ((Minor) & 0xffff))

// Initialization routine.  Called once when the extension DLL
// is loaded.  Returns a version and returns flags detailing
// overall qualities of the extension DLL.
// A session may or may not be active at the time the DLL
// is loaded so initialization routines should not expect
// to be able to query session information.
typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_INITIALIZE)
    (OUT PULONG Version, OUT PULONG Flags);
// Exit routine.  Called once just before the extension DLL is
// unloaded.  As with initialization, a session may or
// may not be active at the time of the call.
typedef void (CALLBACK* PDEBUG_EXTENSION_UNINITIALIZE)
    (void);

// A debuggee has been discovered for the session.  It
// is not necessarily halted.
#define DEBUG_NOTIFY_SESSION_ACTIVE       0x00000000
// The session no longer has a debuggee.
#define DEBUG_NOTIFY_SESSION_INACTIVE     0x00000001
// The debuggee is halted and accessible.
#define DEBUG_NOTIFY_SESSION_ACCESSIBLE   0x00000002
// The debuggee is running or inaccessible.
#define DEBUG_NOTIFY_SESSION_INACCESSIBLE 0x00000003

typedef void (CALLBACK* PDEBUG_EXTENSION_NOTIFY)
    (IN ULONG Notify, IN ULONG64 Argument);

// A PDEBUG_EXTENSION_CALL function can return this code
// to indicate that it was unable to handle the request
// and that the search for an extension function should
// continue down the extension DLL chain.
// Taken from STATUS_VALIDATE_CONTINUE

#define DEBUG_EXTENSION_CONTINUE_SEARCH \
    HRESULT_FROM_NT(0xC0000271L)

// Every routine in an extension DLL has the following prototype.
// The extension may be called from multiple clients so it
// should not cache the client value between calls.
typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_CALL)
    (IN PDEBUG_CLIENT Client, IN OPTIONAL PCSTR Args);

//----------------------------------------------------------------------------
//
// Extension functions.
//
// Extension functions differ from extension callbacks in that
// they are arbitrary functions exported from an extension DLL
// for other code callers instead of for human invocation from
// debugger commands.  Extension function pointers are retrieved
// for an extension DLL with IDebugControl::GetExtensionFunction.
//
// Extension function names must begin with _EFN_.  Other than that
// they can have any name and prototype.  Extension functions
// must be public exports of their extension DLL.  They should
// have a typedef for their function pointer prototype in an
// extension header so that callers have a header file to include
// with a type that allows a correctly-formed invocation of the
// extension function.
//
// The engine does not perform any validation of calls to
// extension functions.  Once the extension function pointer
// is retrieved with GetExtensionFunction all calls go
// directly between the caller and the extension function and
// are not mediated by the engine.
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
};

//----------------------------------------------------------------------------
//
// C++ implementation helper classes.
//
//----------------------------------------------------------------------------

#ifndef DEBUG_NO_IMPLEMENTATION

//
// DebugBaseEventCallbacks provides a do-nothing base implementation
// of IDebugEventCallbacks.  A program can derive their own
// event callbacks class from DebugBaseEventCallbacks and implement
// only the methods they are interested in.  Programs must be
// careful to implement GetInterestMask appropriately.
//
class DebugBaseEventCallbacks : public IDebugEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        )
    {
        *Interface = NULL;

#if _MSC_VER >= 1100
        if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
            IsEqualIID(InterfaceId, __uuidof(IDebugEventCallbacks)))
#else
        if (IsEqualIID(InterfaceId, IID_IUnknown) ||
            IsEqualIID(InterfaceId, IID_IDebugEventCallbacks))
#endif
        {
            *Interface = (IDebugEventCallbacks *)this;
            AddRef();
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }

    // IDebugEventCallbacks.
    
    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        )
    {
        UNREFERENCED_PARAMETER(Bp);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        )
    {
        UNREFERENCED_PARAMETER(Exception);
        UNREFERENCED_PARAMETER(FirstChance);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(CreateThread)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG64 DataOffset,
        IN ULONG64 StartOffset
        )
    {
        UNREFERENCED_PARAMETER(Handle);
        UNREFERENCED_PARAMETER(DataOffset);
        UNREFERENCED_PARAMETER(StartOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ExitThread)(
        THIS_
        IN ULONG ExitCode
        )
    {
        UNREFERENCED_PARAMETER(ExitCode);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        )
    {
        UNREFERENCED_PARAMETER(ImageFileHandle);
        UNREFERENCED_PARAMETER(Handle);
        UNREFERENCED_PARAMETER(BaseOffset);
        UNREFERENCED_PARAMETER(ModuleSize);
        UNREFERENCED_PARAMETER(ModuleName);
        UNREFERENCED_PARAMETER(ImageName);
        UNREFERENCED_PARAMETER(CheckSum);
        UNREFERENCED_PARAMETER(TimeDateStamp);
        UNREFERENCED_PARAMETER(InitialThreadHandle);
        UNREFERENCED_PARAMETER(ThreadDataOffset);
        UNREFERENCED_PARAMETER(StartOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        )
    {
        UNREFERENCED_PARAMETER(ExitCode);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(LoadModule)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp
        )
    {
        UNREFERENCED_PARAMETER(ImageFileHandle);
        UNREFERENCED_PARAMETER(BaseOffset);
        UNREFERENCED_PARAMETER(ModuleSize);
        UNREFERENCED_PARAMETER(ModuleName);
        UNREFERENCED_PARAMETER(ImageName);
        UNREFERENCED_PARAMETER(CheckSum);
        UNREFERENCED_PARAMETER(TimeDateStamp);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(UnloadModule)(
        THIS_
        IN PCSTR ImageBaseName,
        IN ULONG64 BaseOffset
        )
    {
        UNREFERENCED_PARAMETER(ImageBaseName);
        UNREFERENCED_PARAMETER(BaseOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(SystemError)(
        THIS_
        IN ULONG Error,
        IN ULONG Level
        )
    {
        UNREFERENCED_PARAMETER(Error);
        UNREFERENCED_PARAMETER(Level);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        )
    {
        UNREFERENCED_PARAMETER(Status);
        return DEBUG_STATUS_NO_CHANGE;
    }
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
    STDMETHOD(ChangeSymbolState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        UNREFERENCED_PARAMETER(Flags);
        UNREFERENCED_PARAMETER(Argument);
        return S_OK;
    }
};

#endif // #ifndef DEBUG_NO_IMPLEMENTATION

#endif // #ifdef __cplusplus

#endif // #ifndef __DBGENG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\inc\wdbgexts.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    wdbgexts.h

Abstract:

    This file contains the necessary prototypes and data types for a user
    to write a debugger extension DLL.  This header file is also included
    by the NT debuggers (WINDBG & KD).

    This header file must be included after "windows.h" and "dbghelp.h".

    Please see the NT DDK documentation for specific information about
    how to write your own debugger extension DLL.

Environment:

    Win32 only.

Revision History:

--*/

#ifndef _WDBGEXTS_
#define _WDBGEXTS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(WDBGAPI)
#define WDBGAPI __stdcall
#endif

#if !defined(WDBGAPIV)
#define WDBGAPIV __cdecl
#endif

#ifndef _WINDEF_
typedef CONST void *LPCVOID;
#endif

#ifndef _ULONGLONG_
typedef unsigned __int64 ULONGLONG;
typedef ULONGLONG *PULONGLONG;
#endif


typedef
VOID
(WDBGAPIV*PWINDBG_OUTPUT_ROUTINE)(
    PCSTR lpFormat,
    ...
    );

typedef
ULONG_PTR
(WDBGAPI*PWINDBG_GET_EXPRESSION)(
    PCSTR lpExpression
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_EXPRESSION32)(
    PCSTR lpExpression
    );

typedef
ULONG64
(WDBGAPI*PWINDBG_GET_EXPRESSION64)(
    PCSTR lpExpression
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL)(
    PVOID      offset,
    PCHAR      pchBuffer,
    ULONG_PTR *pDisplacement
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL32)(
    ULONG      offset,
    PCHAR      pchBuffer,
    PULONG     pDisplacement
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL64)(
    ULONG64    offset,
    PCHAR      pchBuffer,
    PULONG64   pDisplacement
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM)(
    ULONG_PTR *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM32)(
    ULONG     *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM64)(
    ULONG64   *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_CONTROL_C)(
    VOID
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE)(
    ULONG_PTR  offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE32)(
    ULONG      offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE64)(
    ULONG64    offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE)(
    ULONG_PTR  offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32)(
    ULONG      offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64)(
    ULONG64    offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_SET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_IOCTL_ROUTINE)(
    USHORT   IoctlType,
    PVOID    lpvData,
    ULONG    cbSize
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_READ_PHYSICAL_MEMORY)(
    ULONGLONG        address,
    PVOID            buffer,
    ULONG            count,
    PULONG           bytesread
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY)(
    ULONGLONG        address,
    PVOID            buffer,
    ULONG            length,
    PULONG           byteswritten
    );


typedef struct _EXTSTACKTRACE {
    ULONG       FramePointer;
    ULONG       ProgramCounter;
    ULONG       ReturnAddress;
    ULONG       Args[4];
} EXTSTACKTRACE, *PEXTSTACKTRACE;

typedef struct _EXTSTACKTRACE32 {
    ULONG       FramePointer;
    ULONG       ProgramCounter;
    ULONG       ReturnAddress;
    ULONG       Args[4];
} EXTSTACKTRACE32, *PEXTSTACKTRACE32;

typedef struct _EXTSTACKTRACE64 {
    ULONG64     FramePointer;
    ULONG64     ProgramCounter;
    ULONG64     ReturnAddress;
    ULONG64     Args[4];
} EXTSTACKTRACE64, *PEXTSTACKTRACE64;


typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE)(
    ULONG             FramePointer,
    ULONG             StackPointer,
    ULONG             ProgramCounter,
    PEXTSTACKTRACE    StackFrames,
    ULONG             Frames
    );

typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE32)(
    ULONG             FramePointer,
    ULONG             StackPointer,
    ULONG             ProgramCounter,
    PEXTSTACKTRACE32  StackFrames,
    ULONG             Frames
    );

typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE64)(
    ULONG64           FramePointer,
    ULONG64           StackPointer,
    ULONG64           ProgramCounter,
    PEXTSTACKTRACE64  StackFrames,
    ULONG             Frames
    );

typedef struct _WINDBG_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE    lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE   lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE             lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS, *PWINDBG_EXTENSION_APIS;

typedef struct _WINDBG_EXTENSION_APIS32 {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION32               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL32                   lpGetSymbolRoutine;
    PWINDBG_DISASM32                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE32  lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE32           lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS32, *PWINDBG_EXTENSION_APIS32;

typedef struct _WINDBG_EXTENSION_APIS64 {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION64               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL64                   lpGetSymbolRoutine;
    PWINDBG_DISASM64                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE64  lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64 lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE64           lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS64, *PWINDBG_EXTENSION_APIS64;


typedef struct _WINDBG_OLD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
} WINDBG_OLD_EXTENSION_APIS, *PWINDBG_OLD_EXTENSION_APIS;

typedef struct _WINDBG_OLDKD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION32               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL32                   lpGetSymbolRoutine;
    PWINDBG_DISASM32                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE32  lpReadVirtualMemRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteVirtualMemRoutine;
    PWINDBG_OLDKD_READ_PHYSICAL_MEMORY     lpReadPhysicalMemRoutine;
    PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY    lpWritePhysicalMemRoutine;
} WINDBG_OLDKD_EXTENSION_APIS, *PWINDBG_OLDKD_EXTENSION_APIS;

typedef
VOID
(WDBGAPI*PWINDBG_OLD_EXTENSION_ROUTINE)(
    ULONG                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE32)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE64)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG64                 dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_OLDKD_EXTENSION_ROUTINE)(
    ULONG                        dwCurrentPc,
    PWINDBG_OLDKD_EXTENSION_APIS lpExtensionApis,
    PCSTR                        lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT)(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT32)(
    PWINDBG_EXTENSION_APIS32 lpExtensionApis,
    USHORT                   MajorVersion,
    USHORT                   MinorVersion
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT64)(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT                   MajorVersion,
    USHORT                   MinorVersion
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_VERSION)(
    VOID
    );

#define EXT_API_VERSION_NUMBER   5
#define EXT_API_VERSION_NUMBER32 5
#define EXT_API_VERSION_NUMBER64 6

typedef struct EXT_API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} EXT_API_VERSION, *LPEXT_API_VERSION;

typedef
LPEXT_API_VERSION
(WDBGAPI*PWINDBG_EXTENSION_API_VERSION)(
    VOID
    );

#define IG_KD_CONTEXT                  1
#define IG_READ_CONTROL_SPACE          2
#define IG_WRITE_CONTROL_SPACE         3
#define IG_READ_IO_SPACE               4
#define IG_WRITE_IO_SPACE              5
#define IG_READ_PHYSICAL               6
#define IG_WRITE_PHYSICAL              7
#define IG_READ_IO_SPACE_EX            8
#define IG_WRITE_IO_SPACE_EX           9
#define IG_KSTACK_HELP                10   // obsolete
#define IG_SET_THREAD                 11
#define IG_READ_MSR                   12
#define IG_WRITE_MSR                  13
#define IG_GET_DEBUGGER_DATA          14
#define IG_GET_KERNEL_VERSION         15
#define IG_RELOAD_SYMBOLS             16
#define IG_GET_SET_SYMPATH            17
#define IG_GET_EXCEPTION_RECORD       18
#define IG_IS_PTR64                   19
#define IG_GET_BUS_DATA               20
#define IG_SET_BUS_DATA               21
#define IG_DUMP_SYMBOL_INFO           22
#define IG_LOWMEM_CHECK               23
#define IG_SEARCH_MEMORY              24
#define IG_GET_CURRENT_THREAD         25
#define IG_GET_CURRENT_PROCESS        26
#define IG_GET_TYPE_SIZE              27
#define IG_GET_CURRENT_PROCESS_HANDLE 28
#define IG_GET_INPUT_LINE             29
#define IG_GET_EXPRESSION_EX          30
#define IG_TRANSLATE_VIRTUAL_TO_PHYSICAL 31
#define IG_GET_CACHE_SIZE             32

#define IG_GET_TEB_ADDRESS           128
#define IG_GET_PEB_ADDRESS           129

typedef struct _PROCESSORINFO {
    USHORT      Processor;                // current processor
    USHORT      NumberProcessors;         // total number of processors
} PROCESSORINFO, *PPROCESSORINFO;

typedef struct _READCONTROLSPACE {
    USHORT      Processor;
    ULONG       Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE, *PREADCONTROLSPACE;

typedef struct _READCONTROLSPACE32 {
    USHORT      Processor;
    ULONG       Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE32, *PREADCONTROLSPACE32;

typedef struct _READCONTROLSPACE64 {
    USHORT      Processor;
    ULONG64     Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE64, *PREADCONTROLSPACE64;

typedef struct _IOSPACE {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE, *PIOSPACE;

typedef struct _IOSPACE32 {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE32, *PIOSPACE32;

typedef struct _IOSPACE64 {
    ULONG64     Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE64, *PIOSPACE64;

typedef struct _IOSPACE_EX {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX, *PIOSPACE_EX;

typedef struct _IOSPACE_EX32 {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX32, *PIOSPACE_EX32;

typedef struct _IOSPACE_EX64 {
    ULONG64     Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX64, *PIOSPACE_EX64;

typedef struct _GETSETBUSDATA {
    ULONG       BusDataType;
    ULONG       BusNumber;
    ULONG       SlotNumber;
    PVOID       Buffer;
    ULONG       Offset;
    ULONG       Length;
} BUSDATA, *PBUSDATA;

typedef struct _SEARCHMEMORY {
    ULONG64 SearchAddress;
    ULONG64 SearchLength;
    ULONG64 FoundAddress;
    ULONG   PatternLength;
    PVOID   Pattern;
} SEARCHMEMORY, *PSEARCHMEMORY;

typedef struct _PHYSICAL {
    ULONGLONG              Address;
    ULONG                  BufLen;
    UCHAR                  Buf[1];
} PHYSICAL, *PPHYSICAL;

typedef struct _READ_WRITE_MSR {
    ULONG       Msr;
    LONGLONG    Value;
} READ_WRITE_MSR, *PREAD_WRITE_MSR;

typedef struct _GET_SET_SYMPATH {
    PCSTR       Args;       // args to !reload command
    PSTR        Result;     // returns new path
    int         Length;     // Length of result buffer
} GET_SET_SYMPATH, *PGET_SET_SYMPATH;

typedef struct _GET_TEB_ADDRESS {
    ULONGLONG   Address;
} GET_TEB_ADDRESS, *PGET_TEB_ADDRESS;

typedef struct _GET_PEB_ADDRESS {
    ULONG64     CurrentThread;
    ULONGLONG   Address;
} GET_PEB_ADDRESS, *PGET_PEB_ADDRESS;

typedef struct _GET_CURRENT_THREAD_ADDRESS {
    ULONG       Processor;
    ULONG64     Address;
} GET_CURRENT_THREAD_ADDRESS, *PGET_CURRENT_THREAD_ADDRESS;

typedef struct _GET_CURRENT_PROCESS_ADDRESS {
    ULONG       Processor;
    ULONG64     CurrentThread;
    ULONG64     Address;
} GET_CURRENT_PROCESS_ADDRESS, *PGET_CURRENT_PROCESS_ADDRESS;

typedef struct _GET_INPUT_LINE {
    PCSTR       Prompt;
    PSTR        Buffer;
    ULONG       BufferSize;
    ULONG       InputSize;
} GET_INPUT_LINE, *PGET_INPUT_LINE;

typedef struct _GET_EXPRESSION_EX {
    PCSTR       Expression;
    PCSTR       Remainder;
    ULONG64     Value;
} GET_EXPRESSION_EX, *PGET_EXPRESSION_EX;

typedef struct _TRANSLATE_VIRTUAL_TO_PHYSICAL {
    ULONG64     Virtual;
    ULONG64     Physical;
} TRANSLATE_VIRTUAL_TO_PHYSICAL, *PTRANSLATE_VIRTUAL_TO_PHYSICAL;

//
// If DBGKD_VERS_FLAG_DATA is set in Flags, info should be retrieved from
// the KDDEBUGGER_DATA block rather than from the DBGKD_GET_VERSION
// packet.  The data will remain in the version packet for a while to
// reduce compatibility problems.
//

#define DBGKD_VERS_FLAG_MP      0x0001      // kernel is MP built
#define DBGKD_VERS_FLAG_DATA    0x0002      // DebuggerDataList is valid
#define DBGKD_VERS_FLAG_PTR64   0x0004      // native pointers are 64 bits
#define DBGKD_VERS_FLAG_NOMM    0x0008      // No MM - don't decode PTEs
#define DBGKD_VERS_FLAG_HSS     0x0010      // hardware stepping support

#define KDBG_TAG    'GBDK'


// **********************************************************************
// DO NOT CHANGE THESE 32 BIT STRUCTURES!
// ONLY MAKE CHAGES TO THE 64 BIT VERSION BELOW!!
// **********************************************************************

//
// The following structure has changed in more than pointer size.
//
// This is the version packet for pre-NT5 Beta 2 systems.
// For now, it is also still used on x86
//
typedef struct _DBGKD_GET_VERSION32 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    ULONG   KernBase;
    ULONG   PsLoadedModuleList;

    USHORT  MachineType;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // Address of the kernel callout routine.
    //

    ULONG   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG   KeUserCallbackDispatcher;   // address in ntdll

    //
    // DbgBreakPointWithStatus is a function which takes a ULONG argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG   BreakpointWithStatus;       // address of breakpoint

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //

    ULONG   DebuggerDataList;

} DBGKD_GET_VERSION32, *PDBGKD_GET_VERSION32;


//
// This is the debugger data packet for pre NT5 Beta 2 systems.
// For now, it is still used on x86
//

typedef struct _DBGKD_DEBUG_DATA_HEADER32 {

    LIST_ENTRY32 List;
    ULONG           OwnerTag;
    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER32, *PDBGKD_DEBUG_DATA_HEADER32;

typedef struct _KDDEBUGGER_DATA32 {

    DBGKD_DEBUG_DATA_HEADER32 Header;
    ULONG   KernBase;
    ULONG   BreakpointWithStatus;       // address of breakpoint
    ULONG   SavedContext;
    USHORT  ThCallbackStack;            // offset in thread data
    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer
    USHORT  PaeEnabled:1;
    ULONG   KiCallUserMode;             // kernel routine
    ULONG   KeUserCallbackDispatcher;   // address in ntdll

    ULONG   PsLoadedModuleList;
    ULONG   PsActiveProcessHead;
    ULONG   PspCidTable;

    ULONG   ExpSystemResourcesList;
    ULONG   ExpPagedPoolDescriptor;
    ULONG   ExpNumberOfPagedPools;

    ULONG   KeTimeIncrement;
    ULONG   KeBugCheckCallbackListHead;
    ULONG   KiBugcheckData;

    ULONG   IopErrorLogListHead;

    ULONG   ObpRootDirectoryObject;
    ULONG   ObpTypeObjectType;

    ULONG   MmSystemCacheStart;
    ULONG   MmSystemCacheEnd;
    ULONG   MmSystemCacheWs;

    ULONG   MmPfnDatabase;
    ULONG   MmSystemPtesStart;
    ULONG   MmSystemPtesEnd;
    ULONG   MmSubsectionBase;
    ULONG   MmNumberOfPagingFiles;

    ULONG   MmLowestPhysicalPage;
    ULONG   MmHighestPhysicalPage;
    ULONG   MmNumberOfPhysicalPages;

    ULONG   MmMaximumNonPagedPoolInBytes;
    ULONG   MmNonPagedSystemStart;
    ULONG   MmNonPagedPoolStart;
    ULONG   MmNonPagedPoolEnd;

    ULONG   MmPagedPoolStart;
    ULONG   MmPagedPoolEnd;
    ULONG   MmPagedPoolInformation;
    ULONG   MmPageSize;

    ULONG   MmSizeOfPagedPoolInBytes;

    ULONG   MmTotalCommitLimit;
    ULONG   MmTotalCommittedPages;
    ULONG   MmSharedCommit;
    ULONG   MmDriverCommit;
    ULONG   MmProcessCommit;
    ULONG   MmPagedPoolCommit;
    ULONG   MmExtendedCommit;

    ULONG   MmZeroedPageListHead;
    ULONG   MmFreePageListHead;
    ULONG   MmStandbyPageListHead;
    ULONG   MmModifiedPageListHead;
    ULONG   MmModifiedNoWritePageListHead;
    ULONG   MmAvailablePages;
    ULONG   MmResidentAvailablePages;

    ULONG   PoolTrackTable;
    ULONG   NonPagedPoolDescriptor;

    ULONG   MmHighestUserAddress;
    ULONG   MmSystemRangeStart;
    ULONG   MmUserProbeAddress;

    ULONG   KdPrintCircularBuffer;
    ULONG   KdPrintCircularBufferEnd;
    ULONG   KdPrintWritePointer;
    ULONG   KdPrintRolloverCount;

    ULONG   MmLoadedUserImageList;

} KDDEBUGGER_DATA32, *PKDDEBUGGER_DATA32;

// **********************************************************************
//
// DO NOT CHANGE KDDEBUGGER_DATA32!!
// ONLY MAKE CHANGES TO KDDEBUGGER_DATA64!!!
//
// **********************************************************************


enum
{
    DBGKD_SIMULATION_NONE,
    DBGKD_SIMULATION_EXDI
};

typedef struct _DBGKD_GET_VERSION64 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    USHORT  MachineType;

    //
    // Protocol command support descriptions.
    // These allow the debugger to automatically
    // adapt to different levels of command support
    // in different kernels.
    //

    // One beyond highest packet type understood, zero based.
    UCHAR   MaxPacketType;
    // One beyond highest state change understood, zero based.
    UCHAR   MaxStateChange;
    // One beyond highest state manipulate message understood, zero based.
    UCHAR   MaxManipulate;

    // Kind of execution environment the kernel is running in,
    // such as a real machine or a simulator.  Written back
    // by the simulation if one exists.
    UCHAR   Simulation;

    USHORT  Unused[1];

    ULONG64 KernBase;
    ULONG64 PsLoadedModuleList;

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //
    // There will always be an entry for the debugger.
    //

    ULONG64 DebuggerDataList;

} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64;


//
// This structure is used by the debugger for all targets
// It is the same size as DBGKD_DATA_HEADER on all systems
//
typedef struct _DBGKD_DEBUG_DATA_HEADER64 {

    //
    // Link to other blocks
    //

    LIST_ENTRY64 List;

    //
    // This is a unique tag to identify the owner of the block.
    // If your component only uses one pool tag, use it for this, too.
    //

    ULONG           OwnerTag;

    //
    // This must be initialized to the size of the data block,
    // including this structure.
    //

    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;


//
// This structure is the same size on all systems.  The only field
// which must be translated by the debugger is Header.List.
//

//
// DO NOT ADD OR REMOVE FIELDS FROM THE MIDDLE OF THIS STRUCTURE!!!
//
// If you remove a field, replace it with an "unused" placeholder.
// Do not reuse fields until there has been enough time for old debuggers
// and extensions to age out.
//
typedef struct _KDDEBUGGER_DATA64 {

    DBGKD_DEBUG_DATA_HEADER64 Header;

    //
    // Base address of kernel image
    //

    ULONG64   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG64   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic in KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG64   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // pad to a quad boundary
    //
    USHORT  PaeEnabled:1;

    //
    // Address of the kernel callout routine.
    //

    ULONG64   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG64   KeUserCallbackDispatcher;   // address in ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG64   PsLoadedModuleList;
    ULONG64   PsActiveProcessHead;
    ULONG64   PspCidTable;

    ULONG64   ExpSystemResourcesList;
    ULONG64   ExpPagedPoolDescriptor;
    ULONG64   ExpNumberOfPagedPools;

    ULONG64   KeTimeIncrement;
    ULONG64   KeBugCheckCallbackListHead;
    ULONG64   KiBugcheckData;

    ULONG64   IopErrorLogListHead;

    ULONG64   ObpRootDirectoryObject;
    ULONG64   ObpTypeObjectType;

    ULONG64   MmSystemCacheStart;
    ULONG64   MmSystemCacheEnd;
    ULONG64   MmSystemCacheWs;

    ULONG64   MmPfnDatabase;
    ULONG64   MmSystemPtesStart;
    ULONG64   MmSystemPtesEnd;
    ULONG64   MmSubsectionBase;
    ULONG64   MmNumberOfPagingFiles;

    ULONG64   MmLowestPhysicalPage;
    ULONG64   MmHighestPhysicalPage;
    ULONG64   MmNumberOfPhysicalPages;

    ULONG64   MmMaximumNonPagedPoolInBytes;
    ULONG64   MmNonPagedSystemStart;
    ULONG64   MmNonPagedPoolStart;
    ULONG64   MmNonPagedPoolEnd;

    ULONG64   MmPagedPoolStart;
    ULONG64   MmPagedPoolEnd;
    ULONG64   MmPagedPoolInformation;
    ULONG64   MmPageSize;

    ULONG64   MmSizeOfPagedPoolInBytes;

    ULONG64   MmTotalCommitLimit;
    ULONG64   MmTotalCommittedPages;
    ULONG64   MmSharedCommit;
    ULONG64   MmDriverCommit;
    ULONG64   MmProcessCommit;
    ULONG64   MmPagedPoolCommit;
    ULONG64   MmExtendedCommit;

    ULONG64   MmZeroedPageListHead;
    ULONG64   MmFreePageListHead;
    ULONG64   MmStandbyPageListHead;
    ULONG64   MmModifiedPageListHead;
    ULONG64   MmModifiedNoWritePageListHead;
    ULONG64   MmAvailablePages;
    ULONG64   MmResidentAvailablePages;

    ULONG64   PoolTrackTable;
    ULONG64   NonPagedPoolDescriptor;

    ULONG64   MmHighestUserAddress;
    ULONG64   MmSystemRangeStart;
    ULONG64   MmUserProbeAddress;

    ULONG64   KdPrintCircularBuffer;
    ULONG64   KdPrintCircularBufferEnd;
    ULONG64   KdPrintWritePointer;
    ULONG64   KdPrintRolloverCount;

    ULONG64   MmLoadedUserImageList;

    // NT 5.1 Addition

    ULONG64   NtBuildLab;
    ULONG64   KiNormalSystemCall;

    // NT 5.0 QFE addition

    ULONG64   KiProcessorBlock;
    ULONG64   MmUnloadedDrivers;
    ULONG64   MmLastUnloadedDriver;
    ULONG64   MmTriageActionTaken;
    ULONG64   MmSpecialPoolTag;
    ULONG64   KernelVerifier;
    ULONG64   MmVerifierData;
    ULONG64   MmAllocatedNonPagedPool;
    ULONG64   MmPeakCommitment;
    ULONG64   MmTotalCommitLimitMaximum;
    ULONG64   CmNtCSDVersion;

    // NT 5.1 Addition

    ULONG64   MmPhysicalMemoryBlock;
    ULONG64   MmSessionBase;
    ULONG64   MmSessionSize;
    ULONG64   MmSystemParentTablePage;

} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;



/************************************

   Type Dump Ioctl

*************************************/


//
// Fields are not indented if this is set
//
#define DBG_DUMP_NO_INDENT                0x00000001
//
// Offsets are not printed if this is set
//
#define DBG_DUMP_NO_OFFSET                0x00000002
//
// Verbose output
//
#define DBG_DUMP_VERBOSE                  0x00000004
//
// Callback is done for each of fields
//
#define DBG_DUMP_CALL_FOR_EACH            0x00000008
//
// A list of type is dumped, listLink should have info about next element pointer
//
#define DBG_DUMP_LIST                     0x00000020
//
// Nothing is printed if this is set (only callbacks and data copies done)
//
#define DBG_DUMP_NO_PRINT                 0x00000040
//
// Ioctl returns the size as usual, but will not do field prints/callbacks if this is set
//
#define DBG_DUMP_GET_SIZE_ONLY            0x00000080
//
// Specifies how much deep into structs we can go
//
#define DBG_DUMP_RECUR_LEVEL(l)           ((l & 0xf) << 8)
//
// No newlines are printed after each field
//
#define DBG_DUMP_COMPACT_OUT              0x00002000
//
// An array of type is dumped, number of elements can be specified in listLink->size
//
#define DBG_DUMP_ARRAY                    0x00008000
//
// The specified addr value is actually the address of field listLink->fName
//
#define DBG_DUMP_ADDRESS_OF_FIELD         0x00010000

//
// The specified addr value is actually the adress at the end of type
//
#define DBG_DUMP_ADDRESS_AT_END           0x00020000

//
// This could be used to copy only the primitive types like ULONG, PVOID etc.
//    - will not work with structures/unions
//
#define DBG_DUMP_COPY_TYPE_DATA           0x00040000
//
// Flag to allow read directly from physical memory
//
#define DBG_DUMP_READ_PHYSICAL            0x00080000
//
// This causes a function type to be dumped in format function(arg1, arg2, ...)
//
#define DBG_DUMP_FUNCTION_FORMAT          0x00100000
//
// This recurses on a struct but doesn't expand pointers
//
#define DBG_DUMP_BLOCK_RECURSE            0x00200000

//
// Obsolete defs
//
#define DBG_RETURN_TYPE                   0
#define DBG_RETURN_SUBTYPES               0
#define DBG_RETURN_TYPE_VALUES            0

//
// Dump and callback optons for fields - Options used in FIELD_INFO.fOptions
//

//
// Callback is done before printing the field if this is set
//
#define DBG_DUMP_FIELD_CALL_BEFORE_PRINT  0x00000001
//
// No callback is done
//
#define DBG_DUMP_FIELD_NO_CALLBACK_REQ    0x00000002
//
// Subfields of the fields are processesed
//
#define DBG_DUMP_FIELD_RECUR_ON_THIS      0x00000004
//
// fName must match completely for the field to be dumped instead just a prefix
//  match by default
//
#define DBG_DUMP_FIELD_FULL_NAME          0x00000008
//
// This causes array elements of an array field to be printed
//
#define DBG_DUMP_FIELD_ARRAY              0x00000010
//
// The data of the field is copied into fieldCallBack
//
#define DBG_DUMP_FIELD_COPY_FIELD_DATA    0x00000020
//
// In callback or when Ioctl returns, the FIELD_INFO.address has the address of field.
//  If no address is supplied for the type, it contains total offset of the field.
//
#define DBG_DUMP_FIELD_RETURN_ADDRESS     0x00001000
//
// Return the offset and size in bits instead of bytes is case of Bitfield
//
#define DBG_DUMP_FIELD_SIZE_IN_BITS       0x00002000
//
// Nothing is printed  for field if this is set (only callbacks and data copies done)
//
#define DBG_DUMP_FIELD_NO_PRINT           0x00004000
//
// If the field is a pointer, it is dumped as a string, ANSI, WCHAR, MULTI or GUID
// depending on following options
//
#define DBG_DUMP_FIELD_DEFAULT_STRING     0x00010000
#define DBG_DUMP_FIELD_WCHAR_STRING       0x00020000
#define DBG_DUMP_FIELD_MULTI_STRING       0x00040000
#define DBG_DUMP_FIELD_GUID_STRING        0x00080000


//
// Error status returned on TYPE DUMP Ioctl failure
//
#define MEMORY_READ_ERROR            0x01
#define SYMBOL_TYPE_INDEX_NOT_FOUND  0x02
#define SYMBOL_TYPE_INFO_NOT_FOUND   0x03
#define FIELDS_DID_NOT_MATCH         0x04
#define NULL_SYM_DUMP_PARAM          0x05
#define NULL_FIELD_NAME              0x06
#define INCORRECT_VERSION_INFO       0x07
#define EXIT_ON_CONTROLC             0x08
#define CANNOT_ALLOCATE_MEMORY       0x09
#define INSUFFICIENT_SPACE_TO_COPY   0x0a


//////////////////////////////////////////////////////////////////////////*/

typedef
ULONG
(WDBGAPI*PSYM_DUMP_FIELD_CALLBACK)(
    struct _FIELD_INFO *pField,
    PVOID UserContext
    );

typedef struct _FIELD_INFO {
   PUCHAR  fName;          // Name of the field
   PUCHAR  printName;      // Name to be printed at dump
   ULONG   size;           // Size of the field
   ULONG   fOptions;       // Dump Options for the field
   ULONG64 address;        // address of the field
   PVOID   fieldCallBack;  // Return info or callBack routine for the field
} FIELD_INFO, *PFIELD_INFO;

typedef struct _SYM_DUMP_PARAM {
   ULONG               size;          // size of this struct
   PUCHAR              sName;         // type name
   ULONG               Options;       // Dump options
   ULONG64             addr;          // Address to take data for type
   PFIELD_INFO         listLink;      // fName here would be used to do list dump
   PVOID               Context;       // Usercontext passed to CallbackRoutine
   PSYM_DUMP_FIELD_CALLBACK CallbackRoutine;
                                      // Routine called back
   ULONG               nFields;       // # elements in Fields
   PFIELD_INFO         Fields;        // Used to return information about field
} SYM_DUMP_PARAM, *PSYM_DUMP_PARAM;

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif


#ifndef NOEXTAPI

#if   defined(KDEXT_64BIT)
#define WINDBG_EXTENSION_APIS WINDBG_EXTENSION_APIS64
#define PWINDBG_EXTENSION_APIS PWINDBG_EXTENSION_APIS64
#define DECLARE_API(s) DECLARE_API64(s)
#elif defined(KDEXT_32BIT)
#define WINDBG_EXTENSION_APIS WINDBG_EXTENSION_APIS32
#define PWINDBG_EXTENSION_APIS PWINDBG_EXTENSION_APIS32
#define DECLARE_API(s) DECLARE_API32(s)
#else
#define DECLARE_API(s)                             \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG                  dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )
#endif

#define DECLARE_API32(s)                           \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG                  dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )

#define DECLARE_API64(s)                           \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG64                dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )


extern WINDBG_EXTENSION_APIS   ExtensionApis;


#define dprintf          (ExtensionApis.lpOutputRoutine)
#define GetExpression    (ExtensionApis.lpGetExpressionRoutine)
#define CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
#define GetContext       (ExtensionApis.lpGetThreadContextRoutine)
#define SetContext       (ExtensionApis.lpSetThreadContextRoutine)
#define Ioctl            (ExtensionApis.lpIoctlRoutine)
#define Disasm           (ExtensionApis.lpDisasmRoutine)
#define GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
#define ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
#define WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
#define StackTrace       (ExtensionApis.lpStackTraceRoutine)


#define GetKdContext(ppi) \
    Ioctl( IG_KD_CONTEXT, (PVOID)ppi, sizeof(*ppi) )


//
// BOOL
// GetDebuggerData(
//     ULONG Tag,
//     PVOID Buf,
//     ULONG Size
//     )
//

#define GetDebuggerData(TAG, BUF, SIZE)                             \
      ( (((PDBGKD_DEBUG_DATA_HEADER64)(BUF))->OwnerTag = (TAG)),      \
        (((PDBGKD_DEBUG_DATA_HEADER64)(BUF))->Size = (SIZE)),         \
        Ioctl( IG_GET_DEBUGGER_DATA, (PVOID)(BUF), (SIZE) ) )

// Check if LocalAlloc is prototyped
//#ifdef _WINBASE_

__inline VOID
ReadPhysical(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizer
    )
{
    PPHYSICAL phy;
    *sizer = 0;
    phy = (PPHYSICAL)LocalAlloc(LPTR,  sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        Ioctl( IG_READ_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
        *sizer = phy->BufLen;
        CopyMemory( buf, phy->Buf, *sizer );
        LocalFree( phy );
    }
}

__inline VOID
WritePhysical(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizew
    )
{
    PPHYSICAL phy;
    *sizew = 0;
    phy = (PPHYSICAL)LocalAlloc(LPTR, sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        CopyMemory( phy->Buf, buf, size );
        Ioctl( IG_WRITE_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
        *sizew = phy->BufLen;
        LocalFree( phy );
    }
}

__inline VOID
ReadMsr(
    ULONG       MsrReg,
    ULONGLONG   *MsrValue
    )
{
    READ_WRITE_MSR msr;

    msr.Msr = MsrReg;
    Ioctl( IG_READ_MSR, (PVOID)&msr, sizeof(msr) );

    *MsrValue = msr.Value;
}

__inline VOID
WriteMsr(
    ULONG       MsrReg,
    ULONGLONG   MsrValue
    )
{
    READ_WRITE_MSR msr;

    msr.Msr = MsrReg;
    msr.Value = MsrValue;
    Ioctl( IG_WRITE_MSR, (PVOID)&msr, sizeof(msr) );
}

__inline VOID
SetThreadForOperation(
    ULONG_PTR * Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)Thread, sizeof(PULONG));
}

__inline VOID
SetThreadForOperation32(
    ULONG Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)LongToPtr(Thread), sizeof(ULONG));
}

__inline VOID
SetThreadForOperation64(
    PULONG64 Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)Thread, sizeof(ULONG64));
}


__inline VOID
ReadControlSpace(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE prc;
    prc = (PREADCONTROLSPACE)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

__inline VOID
ReadControlSpace32(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE32 prc;
    prc = (PREADCONTROLSPACE32)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

#define ReadTypedControlSpace32( _Proc, _Addr, _Buf )  \
     ReadControlSpace64( (USHORT)(_Proc), (ULONG)(_Addr), (PVOID)&(_Buf), (ULONG)sizeof(_Buf) )

__inline VOID
ReadControlSpace64(
    USHORT  processor,
    ULONG64 address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE64 prc;
    prc = (PREADCONTROLSPACE64)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

#define ReadTypedControlSpace64( _Proc, _Addr, _Buf )  \
     ReadControlSpace64( (USHORT)(_Proc), (ULONG64)(_Addr), (PVOID)&(_Buf), (ULONG)sizeof(_Buf) )

__inline VOID
WriteControlSpace(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE64 prc;
    prc = (PREADCONTROLSPACE64)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        CopyMemory( prc->Buf, buf, size );
        Ioctl( IG_WRITE_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        LocalFree( prc );
    }
}

// #endif //  _WINBASE_

__inline VOID
ReadIoSpace(
    ULONG   address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
ReadIoSpace32(
    ULONG   address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE32 is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
ReadIoSpace64(
    ULONG64 address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE64 is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
WriteIoSpace(
    ULONG   address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpace32(
    ULONG   address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpace64(
    ULONG64 address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx(
    ULONG   address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx32(
    ULONG   address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx64(
    ULONG64 address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx(
    ULONG   address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx32(
    ULONG   address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx64(
    ULONG64 address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReloadSymbols(
    IN PSTR Arg OPTIONAL
    )
/*++

Routine Description:

    Calls the debugger to reload symbols.

Arguments:

    Args - Supplies the tail of a !reload command string.

        !reload [flags] [module[=address]]
        flags:   /n  do not load from usermode list
                 /u  unload symbols, no reload
                 /v  verbose

        A value of NULL is equivalent to an empty string

Return Value:

    None

--*/
{
    Ioctl(IG_RELOAD_SYMBOLS, (PVOID)Arg, Arg?((ULONG)strlen(Arg)+1):0);
}

__inline VOID
GetSetSympath(
    IN PSTR Arg,
    OUT PSTR Result OPTIONAL,
    IN int Length
    )
/*++

Routine Description:

    Calls the debugger to set or retrieve symbol search path.

Arguments:

    Arg - Supplies new search path.  If Arg is NULL or string is empty,
            the search path is not changed and the current setting is
            returned in Result.  When the symbol search path is changed,
            a call to ReloadSymbols is made implicitly.

    Result - OPTIONAL Returns the symbol search path setting.

    Length - Supplies the size of the buffer supplied by Result.

Return Value:

    None

--*/
{
    GET_SET_SYMPATH gss;
    gss.Args = Arg;
    gss.Result = Result;
    gss.Length = Length;
    Ioctl(IG_GET_SET_SYMPATH, (PVOID)&gss, sizeof(gss));
}

#if   defined(KDEXT_64BIT)

__inline
ULONG
IsPtr64(
    void
    )
{
    static ULONG flag = (ULONG)-1;
    ULONG dw;
    if (flag == (ULONG)-1) {
        if (Ioctl(IG_IS_PTR64, &dw, sizeof(dw))) {
            flag = ((dw != 0) ? 1 : 0);
        } else {
            flag = 0;
        }
    }
    return flag;
}

__inline
ULONG
ReadListEntry(
    ULONG64 Address,
    PLIST_ENTRY64 List
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (ReadMemory(Address, (PVOID)List, sizeof(*List), &cb) && cb == sizeof(*List));
    } else {
        LIST_ENTRY32 List32;
        ULONG Status;
        Status = ReadMemory(Address,
                            (PVOID)&List32,
                            sizeof(List32),
                            &cb);
        if (Status && cb == sizeof(List32)) {
            List->Flink = (ULONG64)(LONG64)(LONG)List32.Flink;
            List->Blink = (ULONG64)(LONG64)(LONG)List32.Blink;
            return 1;
        }
        return 0;
    }
}

__inline
ULONG
ReadPointer(
    ULONG64 Address,
    PULONG64 Pointer
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (ReadMemory(Address, (PVOID)Pointer, sizeof(*Pointer), &cb) && cb == sizeof(*Pointer));
    } else {
        ULONG Pointer32;
        ULONG Status;
        Status = ReadMemory(Address,
                            (PVOID)&Pointer32,
                            sizeof(Pointer32),
                            &cb);
        if (Status && cb == sizeof(Pointer32)) {
            *Pointer = (ULONG64)(LONG64)(LONG)Pointer32;
            return 1;
        }
        return 0;
    }
}

__inline
ULONG
WritePointer(
    ULONG64 Address,
    ULONG64 Pointer
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (WriteMemory(Address, &Pointer, sizeof(Pointer), &cb) && cb == sizeof(Pointer));
    } else {
        ULONG Pointer32 = (ULONG)Pointer;
        ULONG Status;
        Status = WriteMemory(Address,
                             &Pointer32,
                             sizeof(Pointer32),
                             &cb);
        return (Status && cb == sizeof(Pointer32)) ? 1 : 0;
    }
}

/**
   This does Ioctl call for type info and returns size of the type on success.

 **/
__inline
ULONG
GetTypeSize (
   IN LPCSTR    Type
   )
{
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT | DBG_DUMP_GET_SIZE_ONLY, 0,
      NULL, NULL, NULL, 0, NULL
   };

   return Ioctl( IG_GET_TYPE_SIZE, &Sym, Sym.size );
}

/**
    GetFieldData

   Copies the value of the specified field into pOutValue assuming TypeAddress
   points to start of the type in debugee.

   If the Field is NULL and the size of Type is <= 8 Whole type value is read into
   pOutValue. This is to allow to read in primitive types suchas ULONG, PVOID etc.

   If address is zero this considers Type a global variable.

   It raises an exception if OutSize is less than size to be copied.

   Returns 0 on success, errorvalue (defined with SYM_DUMP_PARAM) otherwise.

 **/
__inline
ULONG
GetFieldData (
    IN  ULONG64 TypeAddress,
    IN  LPCSTR  Type,
    IN  LPCSTR  Field,
    IN  ULONG   OutSize,
    OUT PVOID   pOutValue
   )
{
   FIELD_INFO flds = {(PUCHAR)Field, NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS, 0, pOutValue};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT, TypeAddress,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG RetVal;

   if (!Field) {
       Sym.nFields =0; Sym.Options |= DBG_DUMP_COPY_TYPE_DATA;
       Sym.Context = pOutValue;
   }

   ZeroMemory(pOutValue, OutSize);
   RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

   if (OutSize < ((Field == NULL) ? 8 : flds.size)) {
       // Fail
       dprintf("Not enough space to read %s-%s\n", Type, Field);
       RaiseException(EXCEPTION_ACCESS_VIOLATION, 0, 0, NULL);
       return 0;
   }
   return RetVal;
}

//
// Typecast the buffer where value is to be read
//
#define GetFieldValue(Addr, Type, Field, OutValue)         \
     GetFieldData(Addr, Type, Field, sizeof(OutValue), (PVOID) &(OutValue))

//
// Used to read in value of a short (<= 8 bytes) fields
//
__inline
ULONG64
GetShortField (
    IN  ULONG64 TypeAddress,
    IN  LPCSTR  Name,
    IN  USHORT  StoreAddress
   )
{
    static ULONG64 SavedAddress;
    static PUCHAR  SavedName;
    static ULONG   ReadPhysical;
    FIELD_INFO flds = {(PUCHAR) Name, NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM), SavedName, DBG_DUMP_NO_PRINT | ((StoreAddress & 2) ? DBG_DUMP_READ_PHYSICAL : 0),
       SavedAddress, NULL, NULL, NULL, 1, &flds
    };
      

    if (StoreAddress) {
        Sym.sName = (PUCHAR) Name;
        Sym.nFields = 0;
        SavedName = (PUCHAR) Name;
        Sym.addr = SavedAddress = TypeAddress;
        ReadPhysical = (StoreAddress & 2);
        return SavedAddress ? Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size ) : MEMORY_READ_ERROR; // zero on success
    } else {
        Sym.Options |= ReadPhysical ? DBG_DUMP_READ_PHYSICAL : 0;
    }

    if (!Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size )) {
        return flds.address;
    }
    return 0;
}

//
// Stores the address and type name for future reads
//
#define InitTypeRead(Addr, Type)  GetShortField(Addr, #Type, 1)

//
// Stores the address and type name for future reads
//
#define InitTypeReadPhysical(Addr, Type)  GetShortField(Addr, #Type, 3)
//
// Returns the field's value as ULONG64 if size of field is <= sizeof (ULONG64)
//
#define ReadField(Field)          GetShortField(0, #Field, 0)

//
// Read in a pointer value
//
__inline
ULONG
ReadPtr(
    ULONG64 Addr,
    PULONG64 pPointer
    )
{
    return GetFieldData(Addr, "PVOID", NULL, sizeof(ULONG64), (PVOID) pPointer);
}

/*
 * ListType
 *
 *  Routine ListType gives a callback on each element in the list of Type.
 *
 *   Type  :  Name of the type to be listed
 *
 *   NextPointer : Name of field which gives address of next element in list
 *
 *   Context, CallbackRoutine :
 *            Context and the callback routine. The address field in PFIELD_INFO
 *            parameter of callback contains the address of next Type element in list.
 *
 *   Address, ListByFieldAddress :
 *      if ListByFieldAddress is 0, Adress is the address of first element of Type List.
 *
 *   Lists by LIST_ENTRY are also handled implicitly (by Ioctl). If the NextPointer
 *   is a pointer to LIST_ENTRY type, the type address is properly calculated by
 *   subtracting the offsets.
 *
 *      If ListByFieldAddress is 1, the Address is considered to be the address of field
 *   "NextPointer" of the first Type element and first element address is derived
 *   from it.
 *
 */

__inline
ULONG
ListType (
    IN LPCSTR  Type,
    IN ULONG64 Address,
    IN USHORT  ListByFieldAddress,
    IN LPCSTR  NextPointer,
    IN PVOID   Context,
    IN PSYM_DUMP_FIELD_CALLBACK CallbackRoutine
    )
{
    FIELD_INFO flds = {(PUCHAR)NextPointer, NULL, 0, 0, 0, NULL};
    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM), (PUCHAR) Type, DBG_DUMP_NO_PRINT | DBG_DUMP_LIST, Address,
       &flds, Context, CallbackRoutine, 0, NULL
    };

    if (ListByFieldAddress==1) {
        //
        // Address is the address of "NextPointer"
        //
        Sym.Options |= DBG_DUMP_ADDRESS_OF_FIELD;
    }

    return Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
}


/**

   Routine to get offset of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.

 **/

__inline
ULONG
GetFieldOffset (
   IN LPCSTR     Type,
   IN LPCSTR     Field,
   OUT PULONG   pOffset
   )
{
   FIELD_INFO flds = {
       (PUCHAR)Field,
       (PUCHAR)"",
       0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0,
       NULL};

   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM),
      (PUCHAR)Type,
      DBG_DUMP_NO_PRINT,
      0,
      NULL,
      NULL,
      NULL,
      1,
      &flds
   };

   ULONG Err;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   return Err;
}


#endif // defined(KDEXT_64BIT)

__inline VOID
 GetCurrentProcessHandle(
    PHANDLE hp
    )
{
    Ioctl(IG_GET_CURRENT_PROCESS_HANDLE, hp, sizeof(HANDLE));
}

__inline VOID
 GetTebAddress(
    PULONGLONG Address
    )
{
    GET_TEB_ADDRESS gpt;
    gpt.Address = 0;
    Ioctl(IG_GET_TEB_ADDRESS, (PVOID)&gpt, sizeof(gpt));
    *Address = gpt.Address;
}

__inline VOID
 GetPebAddress(
    ULONG64 CurrentThread,
    PULONGLONG Address
    )
{
    GET_PEB_ADDRESS gpt;
    gpt.CurrentThread = CurrentThread;
    gpt.Address = 0;
    Ioctl(IG_GET_PEB_ADDRESS, (PVOID)&gpt, sizeof(gpt));
    *Address = gpt.Address;
}

__inline VOID
 GetCurrentThreadAddr(
    DWORD    Processor,
    PULONG64  Address
    )
{
    GET_CURRENT_THREAD_ADDRESS ct;
    ct.Processor = Processor;
    Ioctl(IG_GET_CURRENT_THREAD, (PVOID)&ct, sizeof(ct));
    *Address = ct.Address;
}

__inline VOID
 GetCurrentProcessAddr(
    DWORD    Processor,
    ULONG64  CurrentThread,
    PULONG64 Address
    )
{
    GET_CURRENT_PROCESS_ADDRESS cp;
    cp.Processor = Processor;
    cp.CurrentThread = CurrentThread;
    Ioctl(IG_GET_CURRENT_PROCESS, (PVOID)&cp, sizeof(cp));
    *Address = cp.Address;
}

__inline VOID
SearchMemory(
    ULONG64  SearchAddress,
    ULONG64  SearchLength,
    ULONG    PatternLength,
    PVOID    Pattern,
    PULONG64 FoundAddress
    )
{
    SEARCHMEMORY sm;
    sm.SearchAddress = SearchAddress;
    sm.SearchLength  = SearchLength;
    sm.FoundAddress  = 0;
    sm.PatternLength = PatternLength;
    sm.Pattern       = Pattern;
    Ioctl(IG_SEARCH_MEMORY, (PVOID)&sm, sizeof(sm));
    *FoundAddress = sm.FoundAddress;
}

__inline ULONG
GetInputLine(
    PCSTR Prompt,
    PSTR Buffer,
    ULONG BufferSize
    )
{
    GET_INPUT_LINE InLine;
    InLine.Prompt = Prompt;
    InLine.Buffer = Buffer;
    InLine.BufferSize = BufferSize;
    if (Ioctl(IG_GET_INPUT_LINE, (PVOID)&InLine, sizeof(InLine)))
    {
        return InLine.InputSize;
    }
    else
    {
        return 0;
    }
}

__inline BOOL
GetExpressionEx(
    PCSTR Expression,
    ULONG64* Value,
    PCSTR* Remainder
    )
{
    GET_EXPRESSION_EX Expr;
    Expr.Expression = Expression;
    if (Ioctl(IG_GET_EXPRESSION_EX, (PVOID)&Expr, sizeof(Expr)))
    {
        *Value = Expr.Value;

        if (Remainder != NULL)
        {
            *Remainder = Expr.Remainder;
        }

        return TRUE;
    }

    return FALSE;
}

__inline BOOL
TranslateVirtualToPhysical(
    ULONG64 Virtual,
    ULONG64* Physical
    )
{
    TRANSLATE_VIRTUAL_TO_PHYSICAL VToP;
    VToP.Virtual = Virtual;
    if (Ioctl(IG_TRANSLATE_VIRTUAL_TO_PHYSICAL, (PVOID)&VToP, sizeof(VToP)))
    {
        *Physical = VToP.Physical;
        return TRUE;
    }

    return FALSE;
}

__inline BOOL
GetDebuggerCacheSize(
    OUT PULONG64 CacheSize
    )
{
    return Ioctl(IG_GET_CACHE_SIZE, (PVOID) CacheSize, sizeof(ULONG64));
}

#endif


#ifdef __cplusplus
}
#endif

#endif // _WDBGEXTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\sos\inc\dbghelp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++ BUILD Version: 0001     Increment this if a change has global effects

Module Name:

    dbghelp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#ifndef _DBGHELP_
#define _DBGHELP_

#if _MSC_VER > 1020
#pragma once
#endif


// As a general principal always call the 64 bit version
// of every API, if a choice exists.  The 64 bit version
// works great on 32 bit platforms, and is forward
// compatible to 64 bit platforms.

#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#define DBHLP_DEPRECIATED
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#define DBHLP_DEPRECIATED DECLSPEC_DEPRECATED
#endif
#define DBHLPAPI IMAGEAPI

#define IMAGE_SEPARATION (64*1024)

typedef struct _LOADED_IMAGE {
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;



HANDLE
IMAGEAPI
FindDebugInfoFile (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath
    );

typedef BOOL
(CALLBACK *PFIND_DEBUG_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindDebugInfoFileEx (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    );

typedef BOOL
(CALLBACK *PFINDFILEINPATHCALLBACK)(
    PSTR  filename,
    PVOID context
    );

BOOL
IMAGEAPI
SymFindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath,
    PFINDFILEINPATHCALLBACK callback,
    PVOID  context
    );

HANDLE
IMAGEAPI
FindExecutableImage(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath
    );

typedef BOOL
(CALLBACK *PFIND_EXE_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindExecutableImageEx(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData
    );

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader (
    IN PVOID Base
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundHeader OPTIONAL
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    );

PVOID
IMAGEAPI
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection
    );

// Symbol server exports

typedef BOOL (*PSYMBOLSERVERPROC)(LPCSTR, LPCSTR, PVOID, DWORD, DWORD, LPSTR);
typedef BOOL (*PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (*PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (*PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK *PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR (*PSYMBOLSERVERGETOPTIONSPROC)();

#define SSRVOPT_CALLBACK    0x01
#define SSRVOPT_DWORD       0x02
#define SSRVOPT_DWORDPTR    0x04
#define SSRVOPT_GUIDPTR     0x08
#define SSRVOPT_OLDGUIDPTR  0x10
#define SSRVOPT_UNATTENDED  0x20
#define SSRVOPT_NOCOPY      0x40
#define SSRVOPT_PARENTWIN   0x80
#define SSRVOPT_RESET    ((ULONG_PTR)-1)

#define SSRVACTION_TRACE 1


#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION {
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    PSTR FileName,
    PSTR SymbolPath,
    DWORD ImageBase
    );

BOOL
IMAGEAPI
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    );

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer
    );

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    PCSTR DirPath
    );

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
                                                                                                   //  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    PCSTR   DecoratedName,         // Name to undecorate
    PSTR    UnDecoratedName,       // If NULL, it will be allocated
    DWORD    UndecoratedLength,     // The maximym length
    DWORD    Flags                  // See above.
    );


//
// these values are used for synthesized file types
// that can be passed in as image headers instead of
// the standard ones from ntimage.h
//

#define DBHHEADER_DEBUGDIRS     0x1

typedef struct _DBGHELP_MODLOAD_DATA {
    DWORD   ssize;                  // size of this struct
    DWORD   ssig;                   // signature identifying the passed data
    PVOID   data;                   // pointer to passed data
    DWORD   size;                   // size of passed data
    DWORD   flags;                  // options
} MODLOAD_DATA, *PMODLOAD_DATA;

//
// StackWalking API
//

typedef enum {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64 {
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS {
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    LPADDRESS a32,
    LPADDRESS64 a64
    )
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    LPADDRESS64 a64,
    LPADDRESS a32
    )
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64 {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    DWORD64  Reserved[8];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    DWORD  Reserved[8];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    PKDHELP p32,
    PKDHELP64 p64
    )
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
}
#endif

typedef struct _tagSTACKFRAME64 {
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME {
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE64)(
    HANDLE      hProcess,
    DWORD64     qwBaseAddress,
    PVOID       lpBuffer,
    DWORD       nSize,
    LPDWORD     lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

typedef
DWORD64
(__stdcall *PGET_MODULE_BASE_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 Address
    );

typedef
DWORD64
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE64)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    );

BOOL
IMAGEAPI
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE)(
    HANDLE  hProcess,
    DWORD   lpBaseAddress,
    PVOID   lpBuffer,
    DWORD   nSize,
    PDWORD  lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef
DWORD
(__stdcall *PGET_MODULE_BASE_ROUTINE)(
    HANDLE  hProcess,
    DWORD   Address
    );

typedef
DWORD
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS lpaddr
    );

BOOL
IMAGEAPI
StackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

#endif


#define API_VERSION_NUMBER 9

typedef struct API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    );

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    LPAPI_VERSION AppVersion
    );

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    HMODULE Module
    );

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64)(
    PSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64W)(
    PWSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK64)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK)(
    HANDLE  hProcess,
    DWORD   AddrBase,
    PVOID   UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK64)(
    HANDLE  hProcess,
    ULONG64 AddrBase,
    ULONG64 UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK)(
    PSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACKW)(
    PWSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    PVOID   CallbackData,
    PVOID   UserContext
    );

#endif


//
// symbol flags
//

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
 #define SYMF_USER_GENERATED   0x00000004
#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
//
// symbol type enumeration
//
typedef enum {
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64                     Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#else
typedef struct _IMAGEHLP_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD                       Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;
#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULE64W {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD64                     Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD                       Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;
#endif

//
// source file structure
//

typedef struct _SOURCEFILE {
    DWORD64                     ModBase;                // base address of loaded module
    PCHAR                       FileName;               // full filename of source
} SOURCEFILE, *PSOURCEFILE;

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_EVENT                               0x00000010
#define CBA_DEBUG_INFO                          0x10000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY {
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD    *bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

enum {
    sevInfo = 0,
    sevProblem,
    sevAttn,
    sevFatal,
    sevMax  // unused
};

typedef struct _IMAGEHLP_CBA_EVENT {
    DWORD severity;                                     // values from sevInfo to sevFatal
    DWORD code;                                         // numerical code IDs the error
    PCHAR desc;                                         // may contain a text description of the error
    PVOID object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENT, *PIMAGEHLP_CBA_EVENT;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64          Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL            Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif

// If dbghelp ever needs to display graphical UI, it will use this as the parent window.

BOOL
SymSetParentWindow(
    HWND hwnd
    );

//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE         0x00000001
#define SYMOPT_UNDNAME                  0x00000002
#define SYMOPT_DEFERRED_LOADS           0x00000004
#define SYMOPT_NO_CPP                   0x00000008
#define SYMOPT_LOAD_LINES               0x00000010
#define SYMOPT_OMAP_FIND_NEAREST        0x00000020
#define SYMOPT_LOAD_ANYTHING            0x00000040
#define SYMOPT_IGNORE_CVREC             0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS     0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS     0x00000200
#define SYMOPT_EXACT_SYMBOLS            0x00000400
#define SYMOPT_INCLUDE_32BIT_MODULES    0x00002000

#define SYMOPT_DEBUG                    0x80000000

DWORD
IMAGEAPI
SymSetOptions(
    IN DWORD   SymOptions
    );

DWORD
IMAGEAPI
SymGetOptions(
    VOID
    );

BOOL
IMAGEAPI
SymCleanup(
    IN HANDLE hProcess
    );

BOOL
IMAGEAPI
SymMatchString(
    IN LPSTR string,
    IN LPSTR expression,
    IN BOOL  fCase
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSOURCFILES_CALLBACK)(
    PSOURCEFILE pSourceFile,
    PVOID       UserContext
    );

BOOL
IMAGEAPI
SymEnumSourceFiles(
    IN HANDLE  hProcess,
    IN ULONG64 ModBase,
    IN LPSTR   Mask,
    IN PSYM_ENUMSOURCFILES_CALLBACK cbSrcFiles,
    IN PVOID   UserContext
    );

BOOL
IMAGEAPI
SymEnumerateModules64(
    IN HANDLE                       hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64  EnumModulesCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    IN HANDLE                     hProcess,
    IN PSYM_ENUMMODULES_CALLBACK  EnumModulesCallback,
    IN PVOID                      UserContext
    );
#endif

BOOL
IMAGEAPI
SymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
BOOL
IMAGEAPI
SymEnumerateSymbols(
    IN HANDLE                     hProcess,
    IN DWORD                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN DWORD                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    );
#endif

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    IN HANDLE                         hProcess,
    IN PENUMLOADED_MODULES_CALLBACK   EnumLoadedModulesCallback,
    IN PVOID                          UserContext
    );
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    );
#endif

BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULE64      ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULEW64     ModuleInfo
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE  ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW  ModuleInfo
    );
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    );
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     PSTR                 ModuleName,
    IN     PSTR                 FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    IN     HANDLE             hProcess,
    IN     PSTR               ModuleName,
    IN     PSTR               FileName,
    IN     DWORD              dwLineNumber,
       OUT PLONG              plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymMatchFileName(
    IN  PSTR  FileName,
    IN  PSTR  Match,
    OUT PSTR *FileNameStop,
    OUT PSTR *MatchStop
    );

BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    );

BOOL
IMAGEAPI
SymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT PSTR            SearchPath,
    IN  DWORD           SearchPathLength
    );

BOOL
IMAGEAPI
SymSetSearchPath(
    IN HANDLE           hProcess,
    IN PSTR             SearchPath
    );

DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll
    );

#define SLMFLAG_VIRTUAL 0x1

DWORD64
IMAGEAPI
SymLoadModuleEx(
    IN  HANDLE         hProcess,
    IN  HANDLE         hFile,
    IN  PSTR           ImageName,
    IN  PSTR           ModuleName,
    IN  DWORD64        BaseOfDll,
    IN  DWORD          DllSize,
    IN  PMODLOAD_DATA  Data,
    IN  DWORD          Flags
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnloadModule64(
    IN  HANDLE          hProcess,
    IN  DWORD64         BaseOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    IN  HANDLE          hProcess,
    IN  DWORD           BaseOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64 sym,               // Symbol to undecorate
    OUT PSTR               UnDecName,         // Buffer to store undecorated name in
    IN  DWORD              UnDecNameLength    // Size of the buffer
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT PSTR             UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    );
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    IN HANDLE                      hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    IN PVOID                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    );
#endif


typedef struct _IMAGEHLP_SYMBOL_SRC {
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO { // AKA TYPTYP
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000

typedef struct _SYMBOL_INFO {
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Reserved2;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


ULONG
IMAGEAPI
SymSetContext(
    HANDLE hProcess,
    PIMAGEHLP_STACK_FRAME StackFrame,
    PIMAGEHLP_CONTEXT Context
    );

BOOL
IMAGEAPI
SymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    IN OUT PSYMBOL_INFO     Symbol
    );

// While SymFromName will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    );

typedef BOOL
(CALLBACK *PSYM_ENUMERATESYMBOLS_CALLBACK)(
    PSYMBOL_INFO  pSymInfo,
    ULONG         SymbolSize,
    PVOID         UserContext
    );

BOOL
IMAGEAPI
SymEnumSymbols(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Mask,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO {
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
    TI_GET_THISADJUST,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS {
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    );

BOOL
IMAGEAPI
SymEnumTypes(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymGetTypeFromName(
    IN  HANDLE              hProcess,
    IN  ULONG64             BaseOfDll,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    );

BOOL
IMAGEAPI
SymAddSymbol(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Name,
    IN DWORD64                      Address,
    IN DWORD                        Size,
    IN DWORD                        Flags
    );

BOOL
IMAGEAPI
SymDeleteSymbol(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Name,
    IN DWORD64                      Address,
    IN DWORD                        Flags
    );

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI *PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    DWORD       DataType,
    PVOID*      Data,
    LPDWORD     DataLength,
    PVOID       UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDump(
    IN LPSTR                              FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    IN LPWSTR                             FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

// -----------------------------------------------------------------
// The following 4 legacy APIs are fully supported, but newer
// ones are recommended.  SymFromName and SymFromAddr provide
// much more detailed info on the returned symbol.

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PDWORD64            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

// While following two APIs will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  PSTR                Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif


// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath
    );

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    DWORD  one,
    DWORD  two,
    DWORD  three,
    LPSTR  FilePath
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );


#include <pshpack4.h>

#pragma warning(disable:4200) // Zero length array


#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64 {
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64 {
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER {
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to 
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY {
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING {
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE {

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
// 
    
typedef struct _MINIDUMP_SYSTEM_INFO {

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //
    
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    USHORT Reserved0;              // Reserved for future use. Must be zero.

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //
    
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //
    
    RVA CSDVersionRva;

    ULONG32 Reserved1;             // Reserved for future use.

    //
    // CPU information is obtained from one of two places.
    //
    //  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
    //     instruction. You must use the X86 portion of the union for X86
    //     computers.
    //
    //  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
    //     IsProcessorFeatureSupported().
    //
    
    union _CPU_INFORMATION {

        //
        // X86 platforms use CPUID function to obtain processor information.
        //
        
        struct {

            //
            // CPUID Subfunction 0, register EAX (VendorId [0]),
            // EBX (VendorId [1]) and ECX (VendorId [2]).
            //
            
            ULONG32 VendorId [ 3 ];
            
            //
            // CPUID Subfunction 1, register EAX
            //
            
            ULONG32 VersionInformation;

            //
            // CPUID Subfunction 1, register EDX
            //
            
            ULONG32 FeatureInformation;
            

            //
            // CPUID, Subfunction 80000001, register EBX. This will only
            // be obtained if the vendor id is "AuthenticAMD".
            //
            
            ULONG32 AMDExtendedCpuFeatures;
    
        } X86CpuInfo;

        //
        // Non-x86 platforms use processor feature flags.
        //
        
        struct {

            ULONG64 ProcessorFeatures [ 2 ];
            
        } OtherCpuInfo;
        
    } Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;

typedef union _CPU_INFORMATION CPU_INFORMATION, *PCPU_INFORMATION;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this 
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT (sizeof ( ((PPROCESS_INFORMATION)0)->dwThreadId ) == 4);

typedef struct _MINIDUMP_THREAD {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION  {
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM {
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;   


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST {
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST {
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST {
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;


//
// Support for capturing system handle state at the time of the dump.
//

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR {
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD {
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM {
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION {
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE {
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK {
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS {
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK {
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord; 
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK {
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS {
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_CALLBACK_INPUT {
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union {
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT {
    union {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;

        
//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//

typedef enum _MINIDUMP_TYPE {
    MiniDumpNormal         = 0x0000,
    MiniDumpWithDataSegs   = 0x0001,
    MiniDumpWithFullMemory = 0x0002,
    MiniDumpWithHandleData = 0x0004,
    MiniDumpFilterMemory   = 0x0008,
    MiniDumpScanMemory     = 0x0010,
} MINIDUMP_TYPE;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI * MINIDUMP_CALLBACK_ROUTINE) (
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    );

typedef struct _MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID BaseOfDump,
    IN ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * StreamPointer, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

#include <poppack.h>

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\disasm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "strike.h"
#include "eestructs.h"
#include "util.h"
#include "disasm.h"
#ifndef UNDER_CE
#include <dbghelp.h>
#endif

PVOID
GenOpenMapping(
    PCSTR FilePath,
    PULONG Size
    )
{
    HANDLE hFile;
    HANDLE hMappedFile;
    PVOID MappedFile;


    hFile = CreateFileA(
                FilePath,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
#if 0
    if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE ) {

        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED) {

            // We're on an OS that doesn't support Unicode
            // file operations.  Convert to ANSI and see if
            // that helps.
            
            CHAR FilePathA [ MAX_PATH + 10 ];

            if (WideCharToMultiByte (CP_ACP,
                                     0,
                                     FilePath,
                                     -1,
                                     FilePathA,
                                     sizeof (FilePathA),
                                     0,
                                     0
                                     ) > 0) {

                hFile = CreateFileA(FilePathA,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL
                                    );
            }
        }

        if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE ) {
            return NULL;
        }
    }
#endif

    *Size = GetFileSize(hFile, NULL);
    if (*Size == -1) {
        CloseHandle( hFile );
        return FALSE;
    }
    
    hMappedFile = CreateFileMapping (
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if ( !hMappedFile ) {
        CloseHandle ( hFile );
        return FALSE;
    }

    MappedFile = MapViewOfFile (
                        hMappedFile,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );

    CloseHandle (hMappedFile);
    CloseHandle (hFile);

    return MappedFile;
}

char* PrintOneLine (char *begin, char *limit)
{
    if (begin == NULL || begin >= limit) {
        return NULL;
    }
    char line[128];
    size_t length;
    char *end;
    while (1) {
        length = strlen (begin);
        end = strstr (begin, "\r\xa");
        if (end == NULL) {
            ExtOut ("%s", begin);
            end = begin+length+1;
            if (end >= limit) {
                return NULL;
            }
        }
        else {
            end += 2;
            length = end-begin;
            while (length) {
                size_t n = length;
                if (n > 127) {
                    n = 127;
                }
                strncpy (line, begin, n);
                line[n] = '\0';
                ExtOut ("%s", line);
                begin += n;
                length -= n;
            }
            return end;
        }
    }
}

void UnassemblyUnmanaged(DWORD_PTR IP)
{
    char            filename[MAX_PATH+1];
    char            line[256];
    int             lcount          = 10;

    ReloadSymbolWithLineInfo();

    ULONG linenum;
    ULONG64 Displacement;
    BOOL fLineAvailable;
    ULONG64 vIP;
    
    fLineAvailable = SUCCEEDED (g_ExtSymbols->GetLineByOffset (IP, &linenum,
                                                               filename,
                                                               MAX_PATH+1,
                                                               NULL,
                                                               &Displacement));
    ULONG FileLines = 0;
    ULONG64* Buffer = NULL;
    ToDestroyCxxArray<ULONG64> des0(&Buffer);

    if (fLineAvailable)
    {
        g_ExtSymbols->GetSourceFileLineOffsets (filename, NULL, 0, &FileLines);
        if (FileLines == 0xFFFFFFFF || FileLines == 0)
            fLineAvailable = FALSE;
    }

    if (fLineAvailable)
    {
        Buffer = new ULONG64[FileLines];
        if (Buffer == NULL)
            fLineAvailable = FALSE;
    }
    
    if (!fLineAvailable)
    {
        vIP = IP;
        // There is no line info.  Just disasm the code.
        while (lcount-- > 0)
        {
            if (IsInterrupt())
                return;
            g_ExtControl->Disassemble (vIP, 0, line, 256, NULL, &vIP);
            ExtOut (line);
        }
        return;
    }

    g_ExtSymbols->GetSourceFileLineOffsets (filename, Buffer, FileLines, NULL);
    
    int beginLine = 0;
    int endLine = 0;
    int lastLine;
    linenum --;
    for (lastLine = linenum; lastLine >= 0; lastLine --) {
        if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
            g_ExtSymbols->GetNameByOffset(Buffer[lastLine],NULL,0,NULL,&Displacement);
            if (Displacement == 0) {
                beginLine = lastLine;
                break;
            }
        }
    }
    if (lastLine < 0) {
        int n = lcount / 2;
        lastLine = linenum-1;
        beginLine = lastLine;
        while (lastLine >= 0) {
            if (IsInterrupt())
                return;
            if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
                beginLine = lastLine;
                n --;
                if (n == 0) {
                    break;
                }
            }
            lastLine --;
        }
    }
    while (beginLine > 0 && Buffer[beginLine-1] == DEBUG_INVALID_OFFSET) {
        beginLine --;
    }
    int endOfFunc = 0;
    for (lastLine = linenum+1; (ULONG)lastLine < FileLines; lastLine ++) {
        if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
            g_ExtSymbols->GetNameByOffset(Buffer[lastLine],NULL,0,NULL,&Displacement);
            if (Displacement == 0) {
                endLine = lastLine;
                break;
            }
            endOfFunc = lastLine;
        }
    }
    if ((ULONG)lastLine == FileLines) {
        int n = lcount / 2;
        lastLine = linenum+1;
        endLine = lastLine;
        while ((ULONG)lastLine < FileLines) {
            if (IsInterrupt())
                return;
            if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
                endLine = lastLine;
                n --;
                if (n == 0) {
                    break;
                }
            }
            lastLine ++;
        }
    }

    PVOID MappedBase = NULL;
    ULONG MappedSize = 0;

    class ToUnmap
    {
        PVOID *m_Base;
    public:
        ToUnmap (PVOID *base)
        :m_Base(base)
        {}
        ~ToUnmap ()
        {
            if (*m_Base) {
                UnmapViewOfFile (*m_Base);
                *m_Base = NULL;
            }
        }
    };
    ToUnmap toUnmap(&MappedBase);

#define MAX_SOURCE_PATH 1024
    char Found[MAX_SOURCE_PATH];
    char *pFile;
    if (g_ExtSymbols->FindSourceFile(0, filename,
                       DEBUG_FIND_SOURCE_BEST_MATCH |
                       DEBUG_FIND_SOURCE_FULL_PATH,
                       NULL, Found, sizeof(Found), NULL) != S_OK)
    {
        pFile = filename;
    }
    else
    {
        MappedBase = GenOpenMapping ( Found, &MappedSize );
        pFile = Found;
    }
    
    lastLine = beginLine;
    char *pFileCh = (char*)MappedBase;
    if (MappedBase) {
        ExtOut ("%s\n", pFile);
        int n = beginLine;
        while (n > 0) {
            while (!(pFileCh[0] == '\r' && pFileCh[1] == 0xa)) {
                pFileCh ++;
            }
            pFileCh += 2;
            n --;
        }
    }
    
    char filename1[MAX_PATH+1];
    for (lastLine = beginLine; lastLine < endLine; lastLine ++) {
        if (IsInterrupt())
            return;
        if (MappedBase) {
            ExtOut ("%4d ", lastLine+1);
            pFileCh = PrintOneLine (pFileCh, (char*)MappedBase+MappedSize);
        }
        if (Buffer[lastLine] != DEBUG_INVALID_OFFSET) {
            if (MappedBase == 0) {
                ExtOut (">>> %s:%d\n", pFile, lastLine+1);
            }
            vIP = Buffer[lastLine];
            ULONG64 vNextLineIP;
            int i;
            for (i = lastLine + 1; (ULONG)i < FileLines && Buffer[i] == DEBUG_INVALID_OFFSET; i ++) {
                ;
            }
            if ((ULONG)i == FileLines) {
                vNextLineIP = 0;
            }
            else
                vNextLineIP = Buffer[i];
            while (1) {
                if (IsInterrupt())
                    return;
                g_ExtControl->Disassemble (vIP, 0, line, 256, NULL, &vIP);
                ExtOut (line);
                if (vIP > vNextLineIP || vNextLineIP - vIP > 40) {
                    if (FAILED (g_ExtSymbols->GetLineByOffset (vIP, &linenum,
                                                               filename1,
                                                               MAX_PATH+1,
                                                               NULL,
                                                               &Displacement))) {
                        if (lastLine != endOfFunc) {
                            break;
                        }
                        if (strstr (line, "ret") || strstr (line, "jmp")) {
                            break;
                        }
                    }

                    if (linenum != (ULONG)lastLine+1 || strcmp (filename, filename1)) {
                        break;
                    }
                }
                else if (vIP == vNextLineIP) {
                    break;
                }
            }
        }
    }
        
}


void DisasmAndClean (DWORD_PTR &IP, char *line, ULONG length)
{
    ULONG64 vIP = IP;
    g_ExtControl->Disassemble (vIP, 0, line, length, NULL, &vIP);
    IP = (DWORD_PTR)vIP;
    // remove the ending '\n'
    char *ptr = strrchr (line, '\n');
    if (ptr != NULL)
        ptr[0] = '\0';
}

// If byref, move to pass the byref prefix
BOOL IsByRef (char *& ptr)
{
    BOOL bByRef = FALSE;
    if (ptr[0] == '[')
    {
        bByRef = TRUE;
        ptr ++;
    }
    else if (!strncmp (ptr, "dword ptr [", 11))
    {
        bByRef = TRUE;
        ptr += 11;
    }
    return bByRef;
}

BOOL IsTermSep (char ch)
{
    return (ch == '\0' || isspace (ch) || ch == ',' || ch == '\n');
}

// Find next term. A term is seperated by space or ,
void NextTerm (char *& ptr)
{
    // If we have a byref, skip to ']'
    if (IsByRef (ptr))
    {
        while (ptr[0] != ']' && ptr[0] != '\0')
            ptr ++;
        if (ptr[0] == ']')
            ptr ++;
    }
    
    while (!IsTermSep (ptr[0]))
        ptr ++;
    while (IsTermSep(ptr[0]) && (*ptr != '\0'))
        ptr ++;
}

// only handle pure value, or memory address
INT_PTR GetValueFromExpr(char *ptr, INT_PTR &value)
{
    BOOL bNegative = FALSE;
    value = 0;
    char *myPtr = ptr;
    BOOL bByRef = IsByRef (myPtr);

    if (myPtr[0] == '-')
    {
        myPtr ++;
        bNegative = TRUE;
    }
    if (!strncmp (myPtr, "0x", 2) || isxdigit (myPtr[0]))
    {
        char *endptr;
        value = strtoul(myPtr, &endptr, 16);
        if ((IsTermSep (endptr[0]) && !bByRef)
            || (endptr[0] == ']' && bByRef))
        {
            if (bNegative)
                value = -value;
            ptr = endptr;
            if (bByRef)
            {
                ptr += 1;
                SafeReadMemory (value, &value, 4, NULL);
            }
            return ptr - myPtr;
        }
    }

    // handle mscorlib+0xed310 (6e24d310)
    if (!bByRef)
    {
        ptr = myPtr;
        while (ptr[0] != ' ' && ptr[0] != '+' && ptr[0] != '\0')
            ptr ++;
        if (ptr[0] == '+')
        {
            NextTerm (ptr);
            if (ptr[0] == '(')
            {
                ptr ++;
                char *endptr;
                value = strtoul(ptr, &endptr, 16);
                if (endptr[0] == ')')
                {
                    ptr ++;
                    return ptr - myPtr;
                }
            }
        }
    }
    if (bByRef)
    {
        // handle dword [mscorlib+0x2bd788 (02ead788)]
        ptr = myPtr;
        while (ptr[0] != '(' && ptr[0] != '\0')
            ptr ++;
        if (ptr[0] == '(')
        {
            ptr ++;
            char *endptr;
            value = strtoul(ptr, &endptr, 16);
            if (endptr[0] == ')' && endptr[1] == ']')
            {
                ptr = endptr + 2;
                SafeReadMemory (value, &value, 4, NULL);
                return ptr - myPtr;
            }
        }
    }
    return 0;
}

struct HelperFuncEntry
{
    char *name;
    size_t addr;
    size_t begin;
    size_t end;
    HelperFuncEntry ()
    : name(NULL), addr(0), begin(0), end(0)
    {}
};

class HelperFuncTable
{
public:
    HelperFuncTable ()
    : table (NULL), nEntry(0)
    {}
    ~HelperFuncTable ()
    {
        for (size_t i = 0; i < nEntry; i ++) {
            if (table[i].name) {
                free ((LPVOID)table[i].name);
            }
        }
        if (table) {
            delete [] table;
        }
    }
    const char *HelperFuncName (size_t IP);
private:
    HelperFuncEntry *table;
    size_t nEntry;

    void Init();
    void SetupAddr();
};

void HelperFuncTable::Init()
{
    if (nEntry == 0) {
        ULONG length = Get1DArrayLength ("hlpFuncTable");
        if (length == 0) {
            return;
        }
        DWORD_PTR hlpAddr = GetValueFromExpression("MSCOREE!hlpFuncTable");
        if (hlpAddr == 0) {
            return;
        }
        size_t entrySize = VMHELPDEF::size();
        size_t bufferSize = length*entrySize;
        size_t *buffer = new size_t[bufferSize/sizeof(size_t)];
        if (buffer == NULL) {
            return;
        }
        ToDestroyCxxArray<size_t> des(&buffer);
        if (g_ExtData->ReadVirtual(hlpAddr,buffer,bufferSize,NULL) != S_OK) {
            return;
        }

        EEFLAVOR flavor = GetEEFlavor ();
        ULONG modIndex;
        g_ExtSymbols->GetModuleByOffset(moduleInfo[flavor].baseAddr,0,&modIndex,NULL);
        DEBUG_MODULE_PARAMETERS Params;
        g_ExtSymbols->GetModuleParameters(1,NULL,modIndex,&Params);
        
        size_t index = VMHELPDEF::GetFieldOffset("pfnHelper")/sizeof(size_t);
        size_t *pt = buffer + entrySize/sizeof(size_t);   // skip the first one
        size_t count = 0;
        size_t i;
        for (i = 1; i < length; i ++) {
            if (pt[index] < Params.Base || pt[index] > Params.Base + Params.Size) {
                count ++;
            }
            pt += entrySize/sizeof(size_t);
        }
        nEntry = count;
        table = new HelperFuncEntry[count];
        count = 0;
        pt = buffer + entrySize/sizeof(size_t);
        for (i = 1; i < length; i ++) {
            if (pt[index] < Params.Base || pt[index] > Params.Base + Params.Size) {
                table[count].addr = hlpAddr + i*entrySize + index*sizeof(size_t);
                table[count].begin = pt[index];
                NameForEnumValue ("CorInfoHelpFunc", i, &table[count].name);
                count ++;
            }
            pt += entrySize/sizeof(size_t);
        }
    }

    SetupAddr();
}

void HelperFuncTable::SetupAddr()
{
    //if (!IsDebuggeeInNewState()) {
    //    return;
    //}
    for (size_t i = 0; i < nEntry; i ++) {
        if (table[i].addr == 0) {
            g_ExtData->ReadVirtual(table[i].addr, &table[i].begin,sizeof(table[i].begin),NULL);
        }
    }
}

const char *HelperFuncTable::HelperFuncName (size_t IP)
{
    Init();
    for (size_t i = 0; i < nEntry; i ++) {
        if (table[i].begin == IP) {
            const char *pt = table[i].name;
            if (pt) {
                pt += sizeof("CORINFO_HELP_")-1;
            }
            return pt;
        }
    }
    return NULL;
}

static HelperFuncTable s_HelperFuncTable;

const char * HelperFuncName (size_t IP)
{
    return s_HelperFuncTable.HelperFuncName(IP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\strike\exts.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "exts.h"

#define VER_PRODUCTVERSION_W        (0x0100)

/