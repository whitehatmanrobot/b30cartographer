TOM(hr)  (((hr) >> 29) & 0x1)

// Macro to get custom facility and code
//
#define CUSTOM_FACILITY_MASK 0x07FF0000
#define CUSTOM_FACILITY(hr) ((hr & CUSTOM_FACILITY_MASK) >> 16)
#define CUSTOM_FACILITY_CODE(hr) (hr & 0x00000FFF)

// Custom facility codes
//
#define FACILITY_BASE                          0x080
#define FACILITY_MSM                           (FACILITY_BASE +  1)
#define FACILITY_AUDIOMSP                      (FACILITY_BASE +  2)
#define FACILITY_VIDEOMSP                      (FACILITY_BASE +  3)
#define FACILITY_FILEIOMSP                     (FACILITY_BASE +  4)
#define FACILITY_CALLCONTROL                   (FACILITY_BASE +  5)
#define FACILITY_SESSIONMANAGER                (FACILITY_BASE +  6)
#define FACILITY_RTPCHANMAN                    (FACILITY_BASE +  7)
#define FACILITY_RTPMSP                        (FACILITY_BASE +  8)
#define FACILITY_RTPRTCPCONTROL                (FACILITY_BASE +  9)
#define FACILITY_WINSOCK                       (FACILITY_BASE + 10)
#define FACILITY_TESTMSP                       (FACILITY_BASE + 11)
#define FACILITY_MSM_SESSION_CLASSES           (FACILITY_BASE + 12)
#define FACILITY_SCRIPTING                     (FACILITY_BASE + 13)
#define FACILITY_Q931                          (FACILITY_BASE + 14)
#define FACILITY_WSCB                          (FACILITY_BASE + 15)
#define FACILITY_DRWS                          (FACILITY_BASE + 16)
#define FACILITY_ISDM                          (FACILITY_BASE + 17)
#define FACILITY_AUTOREG                       (FACILITY_BASE + 18)
#define FACILITY_CAPREG                        (FACILITY_BASE + 19)
#define FACILITY_H245WS                        (FACILITY_BASE + 20)
#define FACILITY_H245                          (FACILITY_BASE + 21)
#define FACILITY_ARSCLIENT                     (FACILITY_BASE + 22)
#define FACILITY_PPM                           (FACILITY_BASE + 23)
#define FACILITY_STRMSP                        (FACILITY_BASE + 24)
#define FACILITY_STRMAN                        (FACILITY_BASE + 25) 
#define FACILITY_MIXERMSP                      (FACILITY_BASE + 26) 
#define FACILITY_GKI                           (FACILITY_BASE + 27)
#define FACILITY_GKIREGISTRATION               (FACILITY_BASE + 28)
#define FACILITY_GKIADMISSION                  (FACILITY_BASE + 29)
#define FACILITY_CALLINCOMPLETE                (FACILITY_BASE + 30)
#define FACILITY_CALLSUMMARY                   (FACILITY_BASE + 31)
#define FACILITY_GKIUNREGREQ                   (FACILITY_BASE + 32)

#define FACILITY_WINSOCK2                      FACILITY_WINSOCK

// Macros to support custom error reporting
//
#define MAKE_MSM_ERROR(error)                  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MSM, (error))
#define MAKE_AUDIOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUDIOMSP, (error))
#define MAKE_AUDIOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUDIOMSP, (error))
#define MAKE_VIDEOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_VIDEOMSP, (error))
#define MAKE_FILEIOMSP_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_FILEIOMSP,(error))
#define MAKE_RTPCHANMAN_ERROR(error)           MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_RTPCHANNELMANAGER, (error))
#define MAKE_RTPMSP_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_RTPMSP, (error))
#define MAKE_WINSOCK_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_WINSOCK, (error))
#define MAKE_TESTMSP_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_TESTMSP, (error))
#define MAKE_MSM_SESSION_CLASSES_ERROR(error)  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MSM_SESSION_CLASSES, (error))
#define MAKE_SCRIPTING_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_SCRIPTING,(error))
#define MAKE_Q931_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_Q931, (error))
#define MAKE_WSCB_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_WSCB, (error))
#define MAKE_DRWS_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_DRWS, (error))
#define MAKE_ISDM_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_ISDM, (error))
#define MAKE_AUTOREG_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUTOREG, (error))
#define MAKE_CAPREG_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_CAPREG, (error))
#define MAKE_H245WS_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245WS, (error))
#define MAKE_H245_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245, (error))
#define MAKE_ARSCLIENT_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_ARSCLIENT, (error))
#define MAKE_PPM_ERROR(error)                  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_PPM, (error))
#define MAKE_STRMSP_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_STRMSP, (error))
#define MAKE_STRMAN_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_STRMAN, (error))
#define MAKE_MIXERMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MIXERMSP, (error))


// Error defines for MSM
//
//
#define ERROR_BASE_ID                          0x8000
#define ERROR_LOCAL_BASE_ID                    0xA000

//
// MessageId: ERROR_UNKNOWN
//
// MessageText:
//
//  An unkown error has occured in the system
//
#define ERROR_UNKNOWN					(ERROR_BASE_ID +  0)


//
// MessageId: ERROR_INVALID_BUFFER
//
// MessageText:
//
//  An invalid buffer handle was encountered.
//
#define ERROR_INVALID_BUFFER			(ERROR_BASE_ID +  1)


//
// MessageId: ERROR_INVALID_BUFFER_SIZE
//
// MessageText:
//
//  An invalid buffer size was encountered.
//
#define ERROR_INVALID_BUFFER_SIZE		(ERROR_BASE_ID +  2)


//
// MessageId: ERROR_INVALID_CALL_ORDER
//
// MessageText:
//
//  A bad call sequence was encountered.
//
#define ERROR_INVALID_CALL_ORDER		(ERROR_BASE_ID +  3)


//
// MessageId: ERROR_INVALID_CONFIG_SETTING
//
// MessageText:
//
//  A specified configuration parameter was invalid
//
#define ERROR_INVALID_CONFIG_SETTING	(ERROR_BASE_ID +  4)


//
// MessageId: ERROR_INVALID_LINK
//
// MessageText:
//
//  An invalid link handle was encountered.
//
#define ERROR_INVALID_LINK				(ERROR_BASE_ID +  5)


//
// MessageId: ERROR_INVALID_PORT
//
// MessageText:
//
//  An invalid port handle was encountered.
//
#define ERROR_INVALID_PORT				(ERROR_BASE_ID +  6)


//
// MessageId: ERROR_INVALID_SERVICE
//
// MessageText:
//
//  An invalid service handle was encountered.
//
#define ERROR_INVALID_SERVICE			(ERROR_BASE_ID +  7)


//
// MessageId: ERROR_INVALID_SERVICE_DLL
//
// MessageText:
//
//  The specified service DLL does not support required interface
//
#define ERROR_INVALID_SERVICE_DLL		(ERROR_BASE_ID +  8)


//
// MessageId: ERROR_INVALID_SERIVCE_ID
//
// MessageText:
//
//  The specified service was not located in the registry
//
#define ERROR_INVALID_SERVICE_ID		(ERROR_BASE_ID +  9)


//
// MessageId: ERROR_INVALID_SESSION
//
// MessageText:
//
//  An invalid session handle was encountered.
//
#define ERROR_INVALID_SESSION			(ERROR_BASE_ID + 10)


//
// MessageId: ERROR_INVALID_SYNC
//
// MessageText:
//
//  An invalid sync handle was encountered.
//
#define ERROR_INVALID_SYNC				(ERROR_BASE_ID + 11)

//
// MessageId: ERROR_INVALID_VERSION
//
// MessageText:
//
//  An invalid version of an object or structure was detected.
//
#define ERROR_INVALID_VERSION			(ERROR_BASE_ID + 12)

//
// MessageId: ERROR_BUFFER_LIMIT
//
// MessageText:
//
//  No buffers are available for performing this operation.
//
#define ERROR_BUFFER_LIMIT				(ERROR_BASE_ID + 13)

//
// MessageId: ERROR_INVALID_SKEY
//
// MessageText:
//
//  An invalid status key was encountered.
//
#define ERROR_INVALID_SKEY				(ERROR_BASE_ID + 14)

//
// MessageId: ERROR_INVALID_SVALUE
//
// MessageText:
//
//  An invalid status value was encountered.
//
#define ERROR_INVALID_SVALUE			(ERROR_BASE_ID + 15)



#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // APIMSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\auformats.h ===
#ifndef _AUFORMATS_H
#define _AUFORMATS_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define WAVE_FORMAT_INTELG723 0x0400
#define WAVE_FORMAT_MSG723 0x0042	  /*  Microsoft Corporation  */
#define WAVE_FORMAT_LH_CELP 0x0070
#define WAVE_FORMAT_LH_SB8	   0x0071
#define WAVE_FORMAT_LH_SB12 0x0072
#define WAVE_FORMAT_LH_SB16 0x0073
#define WAVE_FORMAT_MSRT24 0x0082     /*  Microsoft RT24  */
#define WAVE_FORMAT_VOXWARE		0x0062


#define ACMDM_LH_DATA_PACKAGING		(ACMDM_USER + 1)


// lParam1 when sending ACMDM_LH_DATA_PACKAGING
enum
{
	LH_PACKET_DATA_NULL,	// uninitialized
	LH_PACKET_DATA_FRAMED,	// always aligned on frame boundary
	LH_PACKET_DATA_ANYTHING // do not assume alignment
};

#include <poppack.h> /* End byte packing */


#pragma pack(1)  // byte packing
typedef struct msg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} MSG723WAVEFORMAT;

typedef struct intelg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} INTELG723WAVEFORMAT;

typedef struct tagVOXACM_WAVEFORMATEX 
{
	WAVEFORMATEX	wfx;
	DWORD           dwCodecId;
	DWORD			dwMode;
	char			szKey[72];
} VOXACM_WAVEFORMATEX, *PVOXACM_WAVEFORMATEX, FAR *LPVOXACM_WAVEFORMATEX;


#pragma pack()


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\bestintf.h ===
#ifndef _BESTINTF
#define _BESTINTF

#include <iphlpapi.h>
#include <winsock2.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

DWORD NMINTERNAL NMGetBestInterface ( SOCKADDR_IN* srem, SOCKADDR_IN* sloc );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _BESTINTF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\avcommon.h ===
#ifndef _AVCOMMON_H_
#define _AVCOMMON_H_

// READ BELOW - DO NOT MODIFY THIS FILE FOR UI PURPOSES



/*
	This file contains text string definitions that are not to be modified
	between release versions.

	These strings and definitions are identifiers for PDUs and other packets
	that get put on the wire.  It's important that these version numbers
	remain constant, even between release versions of NetMeeting.
	Otherwise, interopability and/or compatibility with past/future releases
	may get broken.

	If you are browsing this header file in at attempt to change an 
	"about box", DLL version string, or other UI resource, go away.
	
*/


#define H323_COMPANYNAME_STR      "Microsoft"


// current version
#define H323_PRODUCTNAME_STR	"Microsoft\256 NetMeeting\256"


// older builds and releases of NetMeeting may use this definition
#define H323_OLD_PRODUCTNAME_STR	"Microsoft\256 NetMeeting(TM)"


// current version number, change as approprate
#define H323_PRODUCTRELEASE_STR      "3.0"


// past version numbers - so many variations!
#define H323_20_PRODUCTRELEASE_STR    "Version 2.0"
#define H323_21_PRODUCTRELEASE_STR    "Version 2.1"
#define H323_211_PRODUCTRELEASE_STR    "2.11"

// uggh, there was a version of NetMeeting 2.1 (NM 2.1 SP1) that claimed to be 2.11
#define H323_21_SP1_PRODUCTRELEASE_STR    "Version 2.11"

#define H323_30_PRODUCTRELEASE_STR    "3.0"

// TAPI 3.0 version number
#define H323_TAPI30_PRODUCTRELEASE_STR    "Version 3.0"


// used in sub-string searches to identify NetMeeting clients
#define H323_PRODUCTNAME_SHORT_STR	"NetMeeting"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\clinkid.h ===
/*
 * CLSID for CConfLink object and IID for IConferenceLink interface
 *
 * ChrisPi 9-12-95
 *
 */

#ifndef _CLINKID_H_
#define _CLINKID_H_

/* {30E7F2A0-EC4C-11ce-8865-00805F742EF6} */
DEFINE_GUID(CLSID_ConfLink, 
0x30e7f2a0, 0xec4c, 0x11ce, 0x88, 0x65, 0x0, 0x80, 0x5f, 0x74, 0x2e, 0xf6);

DEFINE_GUID(IID_IConferenceLink, 
0x30e7f2b0, 0xec4c, 0x11ce, 0x88, 0x65, 0x0, 0x80, 0x5f, 0x74, 0x2e, 0xf6);

#endif /* _CLINKID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\capflags.h ===
#ifndef __capflags_h__
#define __capflags_h__

const UINT CAPFLAG_DATA =					0x00000001;
const UINT CAPFLAG_SEND_AUDIO  =			0x00000002;
const UINT CAPFLAG_RECV_AUDIO =				0x00000004;
const UINT CAPFLAG_SEND_VIDEO =				0x00000008;
const UINT CAPFLAG_RECV_VIDEO =				0x00000010;
const UINT CAPFLAG_H323_CC =                0x00000020;

const UINT CAPFLAG_DATA_IN_USE =			0x00010000;
const UINT CAPFLAG_AUDIO_IN_USE =			0x00020000;
const UINT CAPFLAG_VIDEO_IN_USE =			0x00040000;
const UINT CAPFLAG_H323_IN_USE =			0x00080000;

#define CAPFLAGS_AUDIO          (CAPFLAG_SEND_AUDIO | CAPFLAG_RECV_AUDIO)

#define CAPFLAGS_VIDEO          (CAPFLAG_SEND_VIDEO | CAPFLAG_RECV_VIDEO)

#define CAPFLAGS_AV_STREAMS     (CAPFLAGS_AUDIO | CAPFLAGS_VIDEO)

#define CAPFLAGS_AV_ALL         (CAPFLAG_H323_CC | CAPFLAGS_AV_STREAMS)

#define CAPFLAGS_ALL            (CAPFLAG_DATA | CAPFLAGS_AV_ALL)


#endif // __capflags_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\cnotifid.h ===
/*
 * CLSID for CConfNotify object and IID for IConfNotify interface
 *
 * ChrisPi 10-3-95
 *
 */

#ifndef _CNOTIFID_H_
#define _CNOTIFID_H_

// {49C6C2C0-FD8A-11ce-8865-00805F742EF6}
DEFINE_GUID(CLSID_ConfNotify, 
0x49c6c2c0, 0xfd8a, 0x11ce, 0x88, 0x65, 0x0, 0x80, 0x5f, 0x74, 0x2e, 0xf6);

DEFINE_GUID(IID_IConfNotify, 
0x49c6c2d0, 0xfd8a, 0x11ce, 0x88, 0x65, 0x0, 0x80, 0x5f, 0x74, 0x2e, 0xf6);

#endif /* _CNOTIFID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\clink.h ===
/*
 * IConferenceLink interface definition
 *
 * ChrisPi 9-12-95
 *
 * ChrisPi: Added RemoteConfName and CallFlags members 5-15-96
 *
 * Based on IUniformResourceLocator interface by DavidDi
 *
 */

#ifndef _CLINK_H_
#define _CLINK_H_

typedef enum icl_invokecommand_flags
{
	ICL_INVOKECOMMAND_FL_ALLOW_UI			= 0x0001,
	ICL_INVOKECOMMAND_FL_USE_DEFAULT_VERB	= 0x0002,

	ALL_ICL_INVOKECOMMAND_FLAGS	= (	ICL_INVOKECOMMAND_FL_ALLOW_UI |
									ICL_INVOKECOMMAND_FL_USE_DEFAULT_VERB)
}
ICL_INVOKECOMMAND_FLAGS;

typedef struct clinvokecommandinfo
{
   DWORD dwcbSize;
   DWORD dwFlags;
   HWND hwndParent;
   PCSTR pcszVerb;
}
CLINVOKECOMMANDINFO;
typedef CLINVOKECOMMANDINFO *PCLINVOKECOMMANDINFO;
typedef const CLINVOKECOMMANDINFO CCLINVOKECOMMANDINFO;
typedef const CLINVOKECOMMANDINFO *PCCLINVOKECOMMANDINFO;

#undef  INTERFACE
#define INTERFACE IConferenceLink

DECLARE_INTERFACE_(IConferenceLink, IUnknown)
{
	/* IUnknown methods */

	STDMETHOD(QueryInterface)(	THIS_
								REFIID riid,
								PVOID *ppvObject) PURE;

	STDMETHOD_(ULONG, AddRef)(THIS) PURE;

	STDMETHOD_(ULONG, Release)(THIS) PURE;

	/* IConferenceLink methods */

	STDMETHOD(SetName)(	THIS_
						PCSTR pcszName) PURE;

	STDMETHOD(GetName)(	THIS_
						PSTR *ppszName) PURE;

	STDMETHOD(SetAddress)(	THIS_
							PCSTR pcszAddress) PURE;

	STDMETHOD(GetAddress)(	THIS_
							PSTR *ppszAddress) PURE;

	STDMETHOD(SetRemoteConfName)(	THIS_
									PCSTR pcszRemoteConfName) PURE;

	STDMETHOD(GetRemoteConfName)(	THIS_
									PSTR *ppszRemoteConfName) PURE;

	STDMETHOD(SetTransport)(THIS_
							DWORD dwTransport) PURE;

	STDMETHOD(GetTransport)(THIS_
							DWORD *pdwTransport) PURE;

	STDMETHOD(SetCallFlags)(THIS_
							DWORD dwCallFlags) PURE;

	STDMETHOD(GetCallFlags)(THIS_
							DWORD *pdwCallFlags) PURE;

	STDMETHOD(InvokeCommand)(	THIS_
								PCLINVOKECOMMANDINFO pclici) PURE;
};

typedef IConferenceLink *PIConferenceLink;
typedef const IConferenceLink CIConferenceLink;
typedef const IConferenceLink *PCIConferenceLink;

#endif /* _CLINK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\avutil.h ===
/* File: avUtil.h (was debug.h + runtime.h)

         Used by NAC.dll and H323CC.dll, and QOS.LIB
 */

#ifndef _AVUTIL_H
#define _AVUTIL_H

#include <nmutil.h>
#include <pshpack8.h> /* Assume 8 byte packing throughout */




/***********************************************************************
 *
 *	Registry access easy-wrapper functions prototypes
 *
 ***********************************************************************/
UINT NMINTERNAL RegistryGetInt(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey, INT dwDefault,
  LPCTSTR lpszFile);
DWORD NMINTERNAL RegistryGetString(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszDefault, LPTSTR lpszReturnBuffer, DWORD cchReturnBuffer,
  LPCTSTR lpszFile);
BOOL NMINTERNAL RegistrySetString(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszString, LPCTSTR lpszFile);
BOOL NMINTERNAL RegistrySetInt(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  DWORD i, LPCTSTR lpszFile);
DWORD NMINTERNAL RegistryGetBinData(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPVOID lpvDefault, DWORD cchDefault, LPVOID lpvReturnBuffer, DWORD cchReturnBuffer,
  LPCTSTR lpszFile);
BOOL NMINTERNAL RegistrySetBinData(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPVOID lpvBinData, DWORD cchBinData, LPCTSTR lpszFile);



/**********************************************************************
 *
 *	Debug Macros
 **********************************************************************/

/*
 *	Debug message types
 */
#define AVERROR				0
#define AVTRACE				1
#define AVTRACEMEM			2
#define AVTESTTRACE			3



//****** Retail
//	MACRO: RETAILMSG(message-to-print)
//	PURPOSE: Prints a message to the debug output
//	NOTE: available in all builds, depends on the registry flag
#define RETAILMSG(x)	 RetailPrintfTrace x
VOID WINAPI RetailPrintfTrace(LPCSTR lpszFormat, ...);

//****** Test and Debug
// in test and debug build, doesnt depent on the registry flag
#if defined(TEST) || defined(DEBUG)
#define TESTMSG(x)		 TestPrintfTrace x
void __cdecl TestPrintfTrace(LPCSTR lpszFormat, ...);
#define ERRORMSG(x)		ERROR_OUT(x)
#else
#define ERRORMSG(x)
#define TESTMSG(x)	
#endif

//****** Debug only
#if defined(DEBUG)

//	MACRO: DebugTrap(void)
//	PURPOSE: Executes a debug break (like 'int 3' on x86)
#define DebugTrap	DebugTrapFn()
#define DEBUGCHK(e)  if(!(e)) DebugTrap

/*
 *  MACRO: DebugPrintError(LPCSTR)
 *
 *  PURPOSE: Prints an error string to the debug output terminal
 *
 *  PARAMETERS:
 *    lpszFormat - a printf-style format
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    This macro calls the generic debug print macro, specifying
 *    that this is an error message
 *
 */

#define DebugPrintError(x)	ERROR_OUT(x)


/*
 *  MACRO: DebugPrintErrorFileLine(DWORD, LPSTR)
 *
 *  PURPOSE: Pretty print an error to the debugging output.
 *
 *  PARAMETERS:
 *    dwError - Actual error code
 *    pszPrefix  - String to prepend to the printed message.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    It will take the error, turn it into a human
 *    readable string, prepend pszPrefix (so you
 *    can tag your errors), append __FILE__ and __LINE__
 *    and print it to the debugging output.
 *
 *    This macro is just a wrapper around OutputDebugLineErrorFileLine
 *    that is necessary to get proper values for __FILE__ and __LINE__.
 *
 */

#define DebugPrintErrorFileLine(dwError, pszPrefix) \
	DebugPrintFileLine(dwError, pszPrefix,\
		__FILE__, __LINE__)

/*
 *  MACRO: DebugPrintTraceFileLine(DWORD, LPSTR)
 *
 *  PURPOSE: Pretty print a trace message to the debugging output.
 *
 *  PARAMETERS:
 *    dwParam- A paramter to trace
 *    pszPrefix  - String to prepend to the printed message.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    Takes a parameter, prepend pszPrefix (so you
 *    can tag your traces), append __FILE__ and __LINE__
 *    and print it to the debugging output.
 *
 *    This macro is just a wrapper around OutputDebugLineErrorFileLine
 *    that is necessary to get proper values for __FILE__ and __LINE__.
 *
 */

#define DebugPrintTraceFileLine(dwParam, pszPrefix) \
	DebugPrintFileLine(dwParam, pszPrefix,\
		__FILE__, __LINE__)

void DebugPrintFileLine(
    DWORD dwError, LPSTR szPrefix, 
    LPSTR szFileName, DWORD nLineNumber);


VOID NMINTERNAL DebugTrapFn(void);

#else	// not DEBUG 

#define DEBUGMSG(z,s)
#define DebugTrap
#define DebugPrintError(x)
#define DebugPrintTrace(x)
#define DebugPrintTraceFileLine(dwParam, pszPrefix)
#define DEBUGCHK(e)

#endif

#define GETMASK(hDbgZone) \
		((hDbgZone) ? (((PZONEINFO)(hDbgZone))->ulZoneMask) : (0))
	
#include <poppack.h> /* End byte packing */

#endif	//#ifndef _AVUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\bstring.h ===
/*
 * BSTRING.H
 *
 * Defines a BSTRING C++ class that allows us to wrap the OLE BSTR (Basic
 * String) type, primarily to simplify the creation and freeing of these
 * objects.  This is intended to be a lightweight wrapper with minimal
 * overhead.
 *
 * If no input string is specified to the constructor or if the allocation
 * of the BSTR fails, then the <m_bstr> member is set to NULL.
 *
 * Note: The BSTRING class is not intended to allow managing multiple BSTR 
 * strings with a single object.
 *
 * Usage scenarios:
 *
 * 1) Create a BSTR from an existing string, have it automatically freed
 *    when done.
 *
 *		// Allocate BSTR using SysAllocString()
 *		BSTRING bstrComputerName(lpstrComputerName);
 *
 *		...
 *
 *		// Automatic, lightweight cast to BSTR
 *		SomeFunctionThatTakesABSTR(bstrComputerName);
 *
 *		...
 *
 *		// SysFreeString() gets called automatically when the scope of
 *		// bstrComputerName ends.
 *
 * 2) Create a null BSTRING object, pass it to a function that returns an
 *	  allocated BSTR, then have it automatically freed when done.
 *
 *		// Create null BSTRING
 *		BSTRING bstrReturnedComputerName;
 *
 *		...
 *
 *		// Call a function that returns an allocated BSTR.
 *		SomeFunctionThatReturnsABSTR(bstrReturnedComputerName.GetLPBSTR());
 *
 *		...
 *
 *		// SysFreeString() gets called automatically when the scope of
 *		// bstrReturnedComputerName ends.
 *		
 * Author:
 *		dannygl, 29 Oct 96
 */

#if !defined(_BSTRING_H_)
#define _BSTRING_H_

#include <oleauto.h>
#include <confdbg.h>

class BSTRING
{
private:
	BSTR m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#if !defined(UNICODE)
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // !defined(UNICODE)

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}

	// Get a BSTR pointer.
	//
	// This member function is intended for passing this object to
	// functions that allocate a BSTR, return a pointer to this BSTR,
	// and expect the caller to free the BSTR when done.  The BSTR is
	// freed when the BSTRING destructor gets called.
	inline LPBSTR GetLPBSTR(void);
};


BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		// SysAllocString returns NULL on failure
		m_bstr = SysAllocString(lpcwString);

		ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	// This function is intended to be used to set the BSTR value for
	// objects that are initialized to NULL.  It should not be called
	// on objects which already have a non-NULL BSTR.
	ASSERT(NULL == m_bstr);

	return &m_bstr;
}

#endif // !defined(_BSTRING_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\cnotify.h ===
/*
 * IConfNotify interface definition
 *
 * ChrisPi 9-29-95
 *
 */

#ifndef _CNOTIFY_H_
#define _CNOTIFY_H_

#undef  INTERFACE
#define INTERFACE IConfNotify

DECLARE_INTERFACE_(IConfNotify, IUnknown)
{
	/* IUnknown methods */

	STDMETHOD(QueryInterface)(	THIS_
								REFIID riid,
								PVOID *ppvObject) PURE;

	STDMETHOD_(ULONG, AddRef)(THIS) PURE;

	STDMETHOD_(ULONG, Release)(THIS) PURE;

	/* IConfNotify methods */

	STDMETHOD(OnConf_Ended)(THIS_
							DWORD dwCode) PURE;


	STDMETHOD(OnEnum_Rejected)(	THIS_
								DWORD dwCode) PURE;

	STDMETHOD(OnEnum_Failed)(	THIS_
								DWORD dwCode) PURE;


	STDMETHOD(OnJoin_InvalidPassword)(	THIS_
										DWORD dwCode) PURE;

	STDMETHOD(OnJoin_InvalidConference)(THIS_
										DWORD dwCode) PURE;

	STDMETHOD(OnJoin_Rejected)(	THIS_
								DWORD dwCode) PURE;

	STDMETHOD(OnJoin_Failed)(	THIS_
								DWORD dwCode) PURE;


	STDMETHOD(OnUser_Added)(	THIS_
								DWORD dwUserID) PURE;

	STDMETHOD(OnUser_Removed)(	THIS_
								DWORD dwUserID) PURE;

	STDMETHOD(OnTAPI_Status)(	THIS_
								LPCTSTR pcszStatus) PURE;

};

typedef IConfNotify *PIConfNotify;
typedef const IConfNotify CIConfNotify;
typedef const IConfNotify *PCIConfNotify;

#endif /* _CNOTIFY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\cnotify.hpp ===
/*
 * CNotify.hpp - CConfNotify class definition
 *
 * Created: ChrisPi 10-3-95
 *
 */

#ifndef _CNOTIFY_HPP_
#define _CNOTIFY_HPP_

class CConfNotify :
		public RefCount,
		public IConfNotify
{
private:

	// private members

public:
	CConfNotify(OBJECTDESTROYEDPROC);
	~CConfNotify(void);

	// IConfNotify methods

	HRESULT STDMETHODCALLTYPE OnConf_Ended(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnEnum_Rejected(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnEnum_Failed(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnJoin_InvalidPassword(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnJoin_InvalidConference(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnJoin_Rejected(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnJoin_Failed(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnUser_Added(DWORD dwUserID);
	HRESULT STDMETHODCALLTYPE OnUser_Removed(DWORD dwUserID);
	HRESULT STDMETHODCALLTYPE OnTAPI_Status(LPCTSTR pcszStatus);

	// IUnknown methods

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
	ULONG   STDMETHODCALLTYPE AddRef(void);
	ULONG   STDMETHODCALLTYPE Release(void);

	// other methods

	// friends

#ifdef DEBUG

	friend BOOL IsValidPCCConfNotify(const CConfNotify *pcConfNotify);

#endif
};

DECLARE_STANDARD_TYPES(CConfNotify);

#endif // _CNOTIFY_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\codecs.h ===
/*
 -  CODECS.H
 -
 *	Microsoft NetMeeting
 *	Installable codecs
 *	Header file
 *
 *  @doc  EXTERNAL
 *
 *	@topic NetMeeting Installable Codecs Programmer's Reference | NetMeeting supports
 *		adding arbitrary audio and video codec formats for use with NetMeeting, 
 *		as well as enumerating, prioritizing or removing these formats.
 *
 */

#include <pshpack8.h> /* Assume 8 byte packing throughout */
#include "appavcap.h"

/*
 *	Constants
 */

// hresult codes, facility IC = 0x301
#define IC_E_CAPS_INSTANTIATION_FAILURE		0x83010001	// could not instantiate a required caps object
#define IC_E_CAPS_INITIALIZATION_FAILURE	0x83010002	// could not initialize a required bject
#define IC_E_NO_FORMATS						0x83010003	// no formats available
#define IC_E_NO_SUCH_FORMAT					0x83010005	// no matching AC</VCM format was found
#define IC_E_INTERNAL_ERROR					0x83010006	// the Network Audio/Video Controller
														// reported a system error

/*
 *	Macros
 */

/*
 *	Data Structures
 */

/*
 *	Functions
 */

/*
 *	Interfaces
 */

#ifndef DECLARE_INTERFACE_PTR
#ifdef __cplusplus
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	interface iface; typedef iface FAR * piface
#else
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	typedef interface iface iface, FAR * piface
#endif
#endif /* DECLARE_INTERFACE_PTR */


#define IUNKNOWN_METHODS(IPURE)										\
    STDMETHOD (QueryInterface)                                      \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;				\
    STDMETHOD_(ULONG,AddRef)  (THIS) IPURE;							\
    STDMETHOD_(ULONG,Release) (THIS) IPURE;							\

#define IINSTALLAUDIOCODECS_METHODS(IPURE)							\
	STDMETHOD(AddACMFormat)											\
		(THIS_ LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo) IPURE;	\
	STDMETHOD (RemoveACMFormat)										\
		(THIS_ LPWAVEFORMATEX lpwfx) IPURE;	\
	STDMETHOD (ReorderFormats)										\
		(THIS_ PAUDCAP_INFO_LIST pAudCapInfoList) IPURE;			\
	STDMETHOD (EnumFormats)											\
		(THIS_ PAUDCAP_INFO_LIST *ppAudCapInfoList) IPURE;	\
	STDMETHOD (FreeBuffer) (THIS_ LPVOID lpBuffer) IPURE;			\

#define IINSTALLVIDEOCODECS_METHODS(IPURE)							\
	STDMETHOD(AddVCMFormat)											\
		(THIS_ PVIDCAP_INFO pVidCapInfo) IPURE;	\
	STDMETHOD (RemoveVCMFormat)										\
		(THIS_ PVIDCAP_INFO pVidCapInfo) IPURE;	\
	STDMETHOD (ReorderFormats)										\
		(THIS_ PVIDCAP_INFO_LIST pVidCapInfoList) IPURE;			\
	STDMETHOD (EnumFormats)											\
		(THIS_ PVIDCAP_INFO_LIST *ppVidCapInfoList) IPURE;	\
	STDMETHOD (FreeBuffer) (THIS_ LPVOID lpBuffer) IPURE;			\

// IInstallAudioCodecs
#undef       INTERFACE
#define      INTERFACE  IInstallAudioCodecs
DECLARE_INTERFACE_(IInstallAudioCodecs, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
	IINSTALLAUDIOCODECS_METHODS(PURE)
};
DECLARE_INTERFACE_PTR(IInstallAudioCodecs, LPINSTALLAUDIOCODECS);

// IInstallVideooCodecs
#undef       INTERFACE
#define      INTERFACE  IInstallVideoCodecs
DECLARE_INTERFACE_(IInstallVideoCodecs, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
	IINSTALLVIDEOCODECS_METHODS(PURE)
};
DECLARE_INTERFACE_PTR(IInstallVideoCodecs, LPINSTALLVIDEOCODECS);

// IInstallAudioCodecs
#undef       INTERFACE
#define      INTERFACE  IInstallCodecs
DECLARE_INTERFACE_(IInstallCodecs, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
};
DECLARE_INTERFACE_PTR(IInstallCodecs, LPINSTALLCODECS);

EXTERN_C HRESULT WINAPI CreateInstallCodecs (
								IUnknown *punkOuter,
								REFIID riid,
								void **ppv);

typedef HRESULT (WINAPI *PFNCREATEINSTALLCODECS)
				(IUnknown *punkOuter, REFIID riid, void **ppv);


// {8ED14CC0-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(CLSID_InstallCodecs, 0x8ed14cc0, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {8ED14CC1-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(IID_IInstallCodecs, 0x8ed14cc1, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {8ED14CC2-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(IID_IInstallAudioCodecs, 0x8ed14cc2, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {8ED14CC3-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(IID_IInstallVideoCodecs, 0x8ed14cc3, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);

#include <poppack.h> /* End byte packing */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\common.h ===
/*
 -  common.h
 -
 *      Microsoft Internet Phone
 *              Definitions that are common across the product
 *
 *              Revision History:
 *
 *              When            Who                                     What
 *              --------        ------------------  ---------------------------------------
 *              11.20.95        Yoram Yaacovi           Created
 */

#ifndef _COMMON_H
#define _COMMON_H
#include <windows.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

/*
 *      DLL names
 */
#define NACDLL                  TEXT("nac.dll")
#define H323DLL			TEXT("h323cc.dll")

/*
 *      Registry section
 *		
 *		Under HKEY_CURRENT_USER
 */
#define szRegInternetPhone			TEXT("Software\\Microsoft\\Internet Audio")
#define szRegInternetPhoneUI		TEXT("UI")
#define szRegInternetPhoneUIProperties	TEXT("UI\\Properties")
#define szRegInternetPhoneDebug		TEXT("Debug")
#define szRegInternetPhoneCodec		TEXT("Codec")
#define szRegInternetPhoneVideoCodec	TEXT("VideoCodec")
#define szRegInternetPhoneDataPump	TEXT("DataPump")
#define szRegInternetPhoneACMEncodings	TEXT("ACMEncodings")
#define szRegInternetPhoneVCMEncodings	TEXT("VCMEncodings")
#define szRegInternetPhoneCustomEncodings TEXT("CustomACMEncodings")
#define szRegInternetPhoneCustomVideoEncodings TEXT("CustomVCMEncodings")
#define szRegInternetPhoneNac		TEXT("NacObject")
#define szRegInternetPhoneHelp		TEXT("Help")
#define szRegInternetPhoneOutputFile	TEXT("RecordToFile")
#define szRegInternetPhoneInputFile	TEXT("PlayFromFile")

/*
 *      Network section
 */
typedef short PORT;
// Following is our assigned port number for the lightweight call control
// protocol, infamously known as MSICCPP, or Microsoft Internet Call Control
// Protocol.
//----------
//From: 	iana@ISI.EDU[SMTP:iana@ISI.EDU]
//Sent: 	Friday, July 12, 1996 11:35 AM
//To: 	Max Morris
//Cc: 	iana@ISI.EDU
//Subject:  Re: request for port number: MSICCPP
//Max,
//
//We have assigned port number 1731 to MSICCPP, with you as the point of
//contact.
//
//Joyce
#define MSICCPP_PORT 1731

//#define HARDCODED_PORT 11010
#define HARDCODED_PORT MSICCPP_PORT
#define H323_PORT 1720 	// well known H.323 listen port

//
//  H.221 identification codes used by call control and nonstandard capability exchange
//
#define USA_H221_COUNTRY_CODE 0xB5
#define USA_H221_COUNTRY_EXTENSION 0x00
#define MICROSOFT_H_221_MFG_CODE 0x534C  //("first" byte 0x53, "second" byte 0x4C)


// some standard RTP payload types
#define RTP_PAYLOAD_H261	31
#define RTP_PAYLOAD_H263	34
#define RTP_PAYLOAD_G723	 4
#define RTP_PAYLOAD_GSM610	3
#define RTP_PAYLOAD_G721	2
#define RTP_PAYLOAD_G711_MULAW	0
#define RTP_PAYLOAD_G711_ALAW	8
#define RTP_PAYLOAD_PCM8	10
#define RTP_PAYLOAD_PCM16	11


//Common Bandwidth declarations
// !!! The QoS will decrease these numbers by the LeaveUnused value.
// This value is currently hardcoded to be 30% 
#define BW_144KBS_BITS				14400	// QoS 30% markdown leads to a max bw usage of  10080 bits/second
#define BW_288KBS_BITS				28800	// QoS 30% markdown leads to a max bw usage of  20160 bits/second
#define BW_ISDN_BITS 				85000	// QoS 30% markdown leads to a max bw usage of  59500 bits/second

// LAN BANDWIDTH for slow pentiums
#define BW_SLOWLAN_BITS				621700	// QoS 30% markdown leads to a max bw usage of 435190 bits/second

// Pentiums faster than 400mhz can have this LAN setting
#define BW_FASTLAN_BITS				825000	// QoS 30% markdown leads to a max bw usage of 577500 bits/second



// For use as dimension for variable size arrays
#define VARIABLE_DIM				1


/*
 *      Interface pointers
 */

#ifndef DECLARE_INTERFACE_PTR
#ifdef __cplusplus
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	struct iface; typedef iface FAR * piface
#else
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	typedef struct iface iface, FAR * piface
#endif
#endif /* DECLARE_INTERFACE_PTR */

/*
 *      Custom Interface types
 */
DECLARE_INTERFACE_PTR(IH323Endpoint,       PH323_ENDPOINT);
DECLARE_INTERFACE_PTR(IH323CallControl,       LPH323CALLCONTROL);
DECLARE_INTERFACE_PTR(ICommChannel,       LPCOMMCHANNEL);

// connection request callback returns CREQ_RESPONSETYPE
typedef enum
{
	CRR_ACCEPT,
	CRR_BUSY,
	CRR_REJECT,
	CRR_SECURITY_DENIED,
	CRR_ASYNC,
	CRR_ERROR
}CREQ_RESPONSETYPE;

typedef struct _application_call_setup_data
{
    DWORD dwDataSize;
    LPVOID lpData;
}APP_CALL_SETUP_DATA, *P_APP_CALL_SETUP_DATA;

typedef  CREQ_RESPONSETYPE (__stdcall *CNOTIFYPROC)(IH323Endpoint *pIEndpoint,
   P_APP_CALL_SETUP_DATA pAppData);

#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif  //#ifndef _COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\compddk.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
 *
 *  Compddk.h - include file for implementing installable compressors
 *
 *  Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.
 *
 **********************************************************************
 *
 * To register FOURCC's for codec types please obtain a
 * copy of the Multimedia Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 *
*/

#ifndef _INC_COMPDDK
#define _INC_COMPDDK	50	/* version number */

#ifndef RC_INVOKED
#ifndef _WIN32
#pragma pack(1)         /* Assume byte packing throughout */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32

#define ICVERSION       0x0104

DECLARE_HANDLE(HIC);     /* Handle to a Installable Compressor */

//
// this code in biCompression means the DIB must be accesed via
// 48 bit pointers! using *ONLY* the selector given.
//
#define BI_1632  0x32333631     // '1632'

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#ifndef ICERR_OK
#define ICERR_OK                0L
#define ICERR_DONTDRAW          1L
#define ICERR_NEWPALETTE        2L
#define ICERR_GOTOKEYFRAME	3L
#define ICERR_STOPDRAWING 	4L

#define ICERR_UNSUPPORTED      -1L
#define ICERR_BADFORMAT        -2L
#define ICERR_MEMORY           -3L
#define ICERR_INTERNAL         -4L
#define ICERR_BADFLAGS         -5L
#define ICERR_BADPARAM         -6L
#define ICERR_BADSIZE          -7L
#define ICERR_BADHANDLE        -8L
#define ICERR_CANTUPDATE       -9L
#define ICERR_ABORT	       -10L
#define ICERR_ERROR            -100L
#define ICERR_BADBITDEPTH      -200L
#define ICERR_BADIMAGESIZE     -201L

#define ICERR_CUSTOM           -400L    // errors less than ICERR_CUSTOM...
#endif

/* Values for dwFlags of ICOpen() */
#ifndef ICMODE_COMPRESS
#define ICMODE_COMPRESS		1
#define ICMODE_DECOMPRESS	2
#define ICMODE_FASTDECOMPRESS   3
#define ICMODE_QUERY            4
#define ICMODE_FASTCOMPRESS     5
#define ICMODE_DRAW             8
#endif
#ifndef _WIN32					// ;Internal
#define ICMODE_INTERNALF_FUNCTION32	0x8000	// ;Internal
#define ICMODE_INTERNALF_MASK		0x8000	// ;Internal
#endif						// ;Internal

/* Flags for AVI file index */
#define AVIIF_LIST	0x00000001L
#define AVIIF_TWOCC	0x00000002L
#define AVIIF_KEYFRAME	0x00000010L

/* quality flags */
#define ICQUALITY_LOW       0
#define ICQUALITY_HIGH      10000
#define ICQUALITY_DEFAULT   -1

/************************************************************************
************************************************************************/

#define ICM_USER          (DRV_USER+0x0000)

#define ICM_RESERVED      ICM_RESERVED_LOW
#define ICM_RESERVED_LOW  (DRV_USER+0x1000)
#define ICM_RESERVED_HIGH (DRV_USER+0x2000)

/************************************************************************

    messages.

************************************************************************/

#define ICM_GETSTATE                (ICM_RESERVED+0)    // Get compressor state
#define ICM_SETSTATE                (ICM_RESERVED+1)    // Set compressor state
#define ICM_GETINFO                 (ICM_RESERVED+2)    // Query info about the compressor

#define ICM_CONFIGURE               (ICM_RESERVED+10)   // show the configure dialog
#define ICM_ABOUT                   (ICM_RESERVED+11)   // show the about box

#define ICM_GETERRORTEXT            (ICM_RESERVED+12)   // get error text TBD ;Internal
#define ICM_GETFORMATNAME	    (ICM_RESERVED+20)	// get a name for a format ;Internal
#define ICM_ENUMFORMATS		    (ICM_RESERVED+21)	// cycle through formats ;Internal

#define ICM_GETDEFAULTQUALITY       (ICM_RESERVED+30)   // get the default value for quality
#define ICM_GETQUALITY              (ICM_RESERVED+31)   // get the current value for quality
#define ICM_SETQUALITY              (ICM_RESERVED+32)   // set the default value for quality

#define ICM_SET			    (ICM_RESERVED+40)	// Tell the driver something
#define ICM_GET			    (ICM_RESERVED+41)	// Ask the driver something

// Constants for ICM_SET:
#define ICM_FRAMERATE       mmioFOURCC('F','r','m','R')
#define ICM_KEYFRAMERATE    mmioFOURCC('K','e','y','R')

/************************************************************************

    ICM specific messages.

************************************************************************/

#define ICM_COMPRESS_GET_FORMAT     (ICM_USER+4)    // get compress format or size
#define ICM_COMPRESS_GET_SIZE       (ICM_USER+5)    // get output size
#define ICM_COMPRESS_QUERY          (ICM_USER+6)    // query support for compress
#define ICM_COMPRESS_BEGIN          (ICM_USER+7)    // begin a series of compress calls.
#define ICM_COMPRESS                (ICM_USER+8)    // compress a frame
#define ICM_COMPRESS_END            (ICM_USER+9)    // end of a series of compress calls.

#define ICM_DECOMPRESS_GET_FORMAT   (ICM_USER+10)   // get decompress format or size
#define ICM_DECOMPRESS_QUERY        (ICM_USER+11)   // query support for dempress
#define ICM_DECOMPRESS_BEGIN        (ICM_USER+12)   // start a series of decompress calls
#define ICM_DECOMPRESS              (ICM_USER+13)   // decompress a frame
#define ICM_DECOMPRESS_END          (ICM_USER+14)   // end a series of decompress calls
#define ICM_DECOMPRESS_SET_PALETTE  (ICM_USER+29)   // fill in the DIB color table
#define ICM_DECOMPRESS_GET_PALETTE  (ICM_USER+30)   // fill in the DIB color table

#define ICM_DRAW_QUERY              (ICM_USER+31)   // query support for dempress
#define ICM_DRAW_BEGIN              (ICM_USER+15)   // start a series of draw calls
#define ICM_DRAW_GET_PALETTE        (ICM_USER+16)   // get the palette needed for drawing
#define ICM_DRAW_UPDATE             (ICM_USER+17)   // update screen with current frame ;Internal
#define ICM_DRAW_START              (ICM_USER+18)   // start decompress clock
#define ICM_DRAW_STOP               (ICM_USER+19)   // stop decompress clock
#define ICM_DRAW_BITS               (ICM_USER+20)   // decompress a frame to screen ;Internal
#define ICM_DRAW_END                (ICM_USER+21)   // end a series of draw calls
#define ICM_DRAW_GETTIME            (ICM_USER+32)   // get value of decompress clock
#define ICM_DRAW                    (ICM_USER+33)   // generalized "render" message
#define ICM_DRAW_WINDOW             (ICM_USER+34)   // drawing window has moved or hidden
#define ICM_DRAW_SETTIME            (ICM_USER+35)   // set correct value for decompress clock
#define ICM_DRAW_REALIZE            (ICM_USER+36)   // realize palette for drawing
#define ICM_DRAW_FLUSH	            (ICM_USER+37)   // clear out buffered frames
#define ICM_DRAW_RENDERBUFFER       (ICM_USER+38)   // draw undrawn things in queue

#define ICM_DRAW_START_PLAY         (ICM_USER+39)   // start of a play
#define ICM_DRAW_STOP_PLAY          (ICM_USER+40)   // end of a play

#define ICM_DRAW_SUGGESTFORMAT      (ICM_USER+50)   // Like ICGetDisplayFormat
#define ICM_DRAW_CHANGEPALETTE      (ICM_USER+51)   // for animating palette

#define ICM_DRAW_IDLE               (ICM_USER+52)   // send each frame time ;Internal

#define ICM_GETBUFFERSWANTED        (ICM_USER+41)   // ask about prebuffering

#define ICM_GETDEFAULTKEYFRAMERATE  (ICM_USER+42)   // get the default value for key frames


#define ICM_DECOMPRESSEX_BEGIN      (ICM_USER+60)   // start a series of decompress calls
#define ICM_DECOMPRESSEX_QUERY      (ICM_USER+61)   // start a series of decompress calls
#define ICM_DECOMPRESSEX            (ICM_USER+62)   // decompress a frame
#define ICM_DECOMPRESSEX_END        (ICM_USER+63)   // end a series of decompress calls

#define ICM_COMPRESS_FRAMES_INFO    (ICM_USER+70)   // tell about compress to come
#define ICM_COMPRESS_FRAMES         (ICM_USER+71)   // compress a bunch of frames ;Internal
#define ICM_SET_STATUS_PROC	        (ICM_USER+72)   // set status callback

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwSize;         // sizeof(ICOPEN)
    DWORD               fccType;        // 'vidc'
    DWORD               fccHandler;     //
    DWORD               dwVersion;      // version of compman opening you
    DWORD               dwFlags;        // LOWORD is type specific
    LRESULT             dwError;        // error return.
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} ICOPEN;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD   dwSize;                 // sizeof(ICINFO)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
// end_vfw32
#ifdef _WIN32
// begin_vfw32
    //
    // under Win32, the driver always returns UNICODE strings.
    //
    WCHAR   szName[16];             // short name
    WCHAR   szDescription[128];     // long name
    WCHAR   szDriver[128];          // driver that contains compressor
// end_vfw32
#else
    char    szName[16];             // short name
    char    szDescription[128];     // long name
    char    szDriver[128];          // driver that contains compressor
#endif
// begin_vfw32
}   ICINFO;

/* Flags for the <dwFlags> field of the <ICINFO> structure. */
#define VIDCF_QUALITY        0x0001  // supports quality
#define VIDCF_CRUNCH         0x0002  // supports crunching to a frame size
#define VIDCF_TEMPORAL       0x0004  // supports inter-frame compress
#define VIDCF_COMPRESSFRAMES 0x0008  // wants the compress all frames message
#define VIDCF_DRAW           0x0010  // supports drawing
#define VIDCF_FASTTEMPORALC  0x0020  // does not need prev frame on compress
#define VIDCF_FASTTEMPORALD  0x0080  // does not need prev frame on decompress
//#define VIDCF_QUALITYTIME    0x0040  // supports temporal quality

//#define VIDCF_FASTTEMPORAL   (VIDCF_FASTTEMPORALC|VIDCF_FASTTEMPORALD)

/************************************************************************
************************************************************************/

#define ICCOMPRESS_KEYFRAME	0x00000001L

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPVOID              lpOutput;       // output data

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPVOID              lpInput;        // frame data to compress

    LPDWORD             lpckid;         // ckid for data in AVI file
    LPDWORD             lpdwFlags;      // flags in the AVI index.
    LONG                lFrameNum;      // frame number of seq.
    DWORD               dwFrameSize;    // reqested size in bytes. (if non zero)

    DWORD               dwQuality;      // quality

    // these are new fields
    LPBITMAPINFOHEADER  lpbiPrev;       // format of previous frame
    LPVOID              lpPrev;         // previous frame

} ICCOMPRESS;

/************************************************************************
************************************************************************/

#define ICCOMPRESSFRAMES_PADDING	0x00000001

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPARAM              lOutput;        // output identifier

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPARAM              lInput;         // input identifier

    LONG                lStartFrame;    // start frame
    LONG                lFrameCount;    // # of frames

    LONG                lQuality;       // quality
    LONG                lDataRate;      // data rate
    LONG                lKeyRate;       // key frame rate

    DWORD		dwRate;		// frame rate, as always
    DWORD		dwScale;

    DWORD		dwOverheadPerFrame;
    DWORD		dwReserved2;

    LONG (CALLBACK *GetData)(LPARAM lInput, LONG lFrame, LPVOID lpBits, LONG len);
    LONG (CALLBACK *PutData)(LPARAM lOutput, LONG lFrame, LPVOID lpBits, LONG len);
} ICCOMPRESSFRAMES;

typedef struct {
    DWORD		dwFlags;
    LPARAM		lParam;

    // messages for Status callback
    #define ICSTATUS_START	    0
    #define ICSTATUS_STATUS	    1	    // l == % done
    #define ICSTATUS_END	    2
    #define ICSTATUS_ERROR	    3	    // l == error string (LPSTR)
    #define ICSTATUS_YIELD	    4
    // return nonzero means abort operation in progress

    LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l);
} ICSETSTATUSPROC;

/************************************************************************
************************************************************************/

#define ICDECOMPRESS_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDECOMPRESS_UPDATE       0x40000000L   // don't draw just update screen
#define ICDECOMPRESS_PREROLL      0x20000000L   // this frame is before real start
#define ICDECOMPRESS_NULLFRAME    0x10000000L   // repeat last frame
#define ICDECOMPRESS_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)

    LPBITMAPINFOHEADER  lpbiInput;  // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    LPVOID              lpInput;    // compressed data

    LPBITMAPINFOHEADER  lpbiOutput; // DIB to decompress to
    LPVOID              lpOutput;
    DWORD		ckid;	    // ckid from AVI file
} ICDECOMPRESS;

typedef struct {
    //
    // same as ICM_DECOMPRESS
    //
    DWORD               dwFlags;

    LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
    LPVOID              lpSrc;      // compressed data

    LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
    LPVOID              lpDst;      // output data

    //
    // new for ICM_DECOMPRESSEX
    //
    int                 xDst;       // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    int                 xSrc;       // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

} ICDECOMPRESSEX;

/************************************************************************
************************************************************************/

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND
#define ICDRAW_ANIMATE	    0x00000008L	  // expect palette animation
#define ICDRAW_CONTINUE	    0x00000010L	  // draw is a continuation of previous draw
#define ICDRAW_MEMORYDC	    0x00000020L	  // DC is offscreen, by the way
#define ICDRAW_UPDATING	    0x00000040L	  // We're updating, as opposed to playing
#define ICDRAW_RENDER       0x00000080L   // used to render data not draw it
#define ICDRAW_BUFFER       0x00000100L   // please buffer this data offscreen, we will need to update it

typedef struct {
    DWORD               dwFlags;        // flags

    HPALETTE            hpal;           // palette to draw with
    HWND                hwnd;           // window to draw to
    HDC                 hdc;            // HDC to draw to

    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    LPBITMAPINFOHEADER  lpbi;           // format of frame to draw

    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

    DWORD               dwRate;         // frames/second = (dwRate/dwScale)
    DWORD               dwScale;

} ICDRAWBEGIN;

/************************************************************************
************************************************************************/

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen
#define ICDRAW_PREROLL	    0x20000000L	  // this frame is before real start
#define ICDRAW_NULLFRAME    0x10000000L	  // repeat last frame
#define ICDRAW_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;        // flags
    LPVOID		lpFormat;       // format of frame to decompress
    LPVOID              lpData;         // frame data to decompress
    DWORD               cbData;
    LONG                lTime;          // time in drawbegin units (see dwRate and dwScale)
} ICDRAW;

typedef struct {
    LPBITMAPINFOHEADER	lpbiIn;		// format to be drawn
    LPBITMAPINFOHEADER	lpbiSuggest;	// location for suggested format (or NULL to get size)
    int			dxSrc;		// source extent or 0
    int			dySrc;
    int			dxDst;		// dest extent or 0
    int			dyDst;
    HIC			hicDecompressor;// decompressor you can talk to
} ICDRAWSUGGEST;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)
    int                 iStart;     // first palette to change
    int                 iLen;       // count of entries to change.
    LPPALETTEENTRY      lppe;       // palette
} ICPALETTE;

// end_vfw32

#ifndef RC_INVOKED
#ifndef _WIN32
#pragma pack()          /* Revert to default packing */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_COMPDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\confdir.h ===
/***********************************************************************
//    ConfDir.h
//
//	  Conferencing directory functions
//
//	  Chris Pirich (chrispi) : Created 9-7-95
*/

#ifndef _CONFDIR_H_
#define _CONFDIR_H_

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

UINT GetConferencingDir(LPTSTR szDir, int cBufSize);
UINT GetFavoritesDir(LPTSTR szDir, int cBufSize);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _CONFDIR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\confcli.h ===
// This is the header file that defines the interface to ConfCli.dll
//
//	Created:	ChrisPi	8-29-95
//

#ifndef _CONFCLI_H_
#define _CONFCLI_H_


#include <tchar.h> // for _TEXT()

// Functions:
BOOL WINAPI ConfInitialize();
typedef BOOL (WINAPI *CONFINITIALIZEPROC) ();
#define CONFINITIALIZENAME	("ConfInitialize")

int WINAPI ConfSendMessage(UINT uMsg, LPBYTE lpData, DWORD cbData);
typedef int (WINAPI *CONFSENDMESSAGEPROC) (UINT uMsg, LPBYTE lpData, DWORD cbData);
#define CONFSENDMESSAGENAME	("ConfSendMessage")

#define CONFCLIDLLNAME	(_TEXT("msconf.dll"))

#ifdef __cplusplus
extern "C" 
{
#endif
void WINAPI NewMediaPhone(HWND hwndParent, HINSTANCE hinst,
							PSTR pszCmdLine, int nShowCmd);
typedef VOID (WINAPI *NEWMEDIAPHONEPROC)(HWND, HINSTANCE, PSTR, int);
#define NEWMEDIAPHONENAME	("NewMediaPhone")
#ifdef __cplusplus
}
#endif /* __cplusplus */

// Structs:
#define MAX_DIALINFO_STRING 128

struct DIALINFO
{
	DWORD	dwDialFlags;
	CHAR	szWABKey[MAX_DIALINFO_STRING];
	CHAR	szName[MAX_DIALINFO_STRING];
	CHAR	szAddress[MAX_DIALINFO_STRING];
	CHAR    szConference[MAX_DIALINFO_STRING];
	DWORD	dwTransport;
};

#endif /* _CONFCLI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\confguid.h ===
//****************************************************************************
//
//  File:       confguid.h
//  Content:    This file contains the class GUID for Microsoft Conferencing.
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

// {19FF8A00-9447-11cf-8796-444553540000}

DEFINE_GUID(CLSID_ConferenceManager, 
0x19ff8a00, 0x9447, 0x11cf, 0x87, 0x96, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

#define H221USACode1    0xb5
#define H221USACode2    0x00
#define H221MFGCode1    0x53
#define H221MFGCode2    0x4c
#define H221GUIDID      0x01

#define H221GUIDKEY0    H221USACode1
#define H221GUIDKEY1    H221USACode2
#define H221GUIDKEY2    H221MFGCode1
#define H221GUIDKEY3    H221MFGCode2
#define H221GUIDKEY4    H221GUIDID

#define CB_H221_GUIDKEY    (5 + sizeof(GUID))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\confevt.h ===
#ifndef _CONFEVT_H_
#define _CONFEVT_H_

// CRPlaceCall Flags:
// Media types:
#define CRPCF_DATA			0x00000001
#define CRPCF_AUDIO			0x00000002
#define CRPCF_VIDEO			0x00000004
#define CRPCF_H323CC        0x00000008


// Data conferencing flags:
#define CRPCF_T120			0x00010000
#define CRPCF_JOIN			0x00020000
#define CRPCF_NO_UI         0x00100000 // Do not display messages (called by API)
#define CRPCF_HOST          0x00200000 // Enter "Host Mode"
#define CRPCF_SECURE        0x00400000 // Make a secure call

#define CRPCF_DEFAULT		CRPCF_DATA |\
							CRPCF_AUDIO|\
							CRPCF_VIDEO|\
                            CRPCF_H323CC |\
							CRPCF_T120

#endif // ! _CONFEVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\confdbg.h ===
// confdbg.h -  Conferencing Debug Functions and Macros

/*
	The main macros are:

	ASSERT - display error if parameter evalulates to FALSE.
		e.g. ASSERT(x == y);

	ERROR_OUT - always print this error.  Messagebox is optional.
		e.g. ERROR_OUT(("Unable to FooBar!  Err=%d", dwErr));

	WARNING_OUT - warning message, not an error (App must call InitDebugModule)
		e.g. WARNING_OUT(("FooBar is not available. Using %s", szAlt));

	TRACE_OUT - debug message (App must call InitDebugModule)
		e.g. TRACE_OUT(("dwFoo=%d, dwBar=%d", dwFoo, dwBar));

	DBGMSG - debug message for a specific zone
		e.g. DBGMSG(ghZoneFoo, ZONE_BAR, ("Setting dwFoo=%d", dwFoo));


Important Functions:
	VOID DbgInit(HDBGZONE * phDbgZone, PTCHAR * psz, UINT cZone);
	VOID DbgDeInit(HDBGZONE * phDbgZone);
	VOID WINAPI DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap);
	PSTR WINAPI DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...);

	Note: The strings in these functions, in particular the module and
	zone names, are always ANSI strings, even in Unicode components.  The
	input strings to DBGINIT should not be wrapped in TEXT macros.
*/

#ifndef _CONFDBG_H_
#define _CONFDBG_H_

#include <nmutil.h>
#include <stock.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <pshpack8.h> /* Assume 8 byte packing throughout */

// deal with including "debug.h" before and after
#ifdef DEBUGMSG
#undef DEBUGMSG
#endif
#define _DEBUG_H

// MFC also defines this - use our version
#ifdef ASSERT
#undef ASSERT
#endif

#ifdef DEBUG
#ifndef NM_DEBUG
#define NM_DEBUG
#endif
#endif /* DEBUG */



// Special NetMeeting Debug definitions
#ifdef NM_DEBUG


//////////////////////////////////////
//Debug Zones

#define MAXNUM_OF_MODULES			64
#define MAXSIZE_OF_MODULENAME		32
#define MAXNUM_OF_ZONES				16
#define MAXSIZE_OF_ZONENAME			32

#define ZONEINFO_SIGN				0x12490000


// Zone information for a module
typedef struct _ZoneInfo
{
	ULONG	ulSignature;
	ULONG	ulRefCnt;
	ULONG	ulZoneMask; //the zone mask
	BOOL	bInUse;
	CHAR	pszModule[MAXSIZE_OF_MODULENAME];	//name against which the zones are registered
	CHAR	szZoneNames[MAXNUM_OF_ZONES][MAXSIZE_OF_ZONENAME]; //names of the zones
	CHAR	szFile[MAX_PATH];	                // output file, specific to this module
}ZONEINFO,*PZONEINFO;

// DBGZONEPARAM replaced by ZONEINFO
#define DBGZONEINFO ZONEINFO
#define PDBGZONEINFO PZONEINFO
	
typedef PVOID HDBGZONE;

// size of the memory mapped file
#define CBMMFDBG (sizeof(ZONEINFO) * MAXNUM_OF_MODULES + sizeof(NMDBG))

// General information at end of memory-mapped file (after all zone data)
typedef struct _NmDbg {
	BOOL  fOutputDebugString;  // OutputDebugString is enabled
	BOOL  fWinOutput;          // Window Output is enabled
	HWND  hwndCtrl;            // Window that handles output
	UINT  msgDisplay;          // Message to post to hwndCtrl
	BOOL  fFileOutput;         // File Output is enabled
	CHAR  szFile[MAX_PATH];    // File name for output
	UINT  uShowTime;           // Format date/time (see DBG_FMTTIME_*)
	BOOL  fShowThreadId;       // Dump ThreadId with each message
	BOOL  fShowModule;         // Dump Module:Zone with each message
} NMDBG;
typedef NMDBG * PNMDBG;

#define DBG_FMTTIME_NONE 0     // Do not format the time
#define DBG_FMTTIME_TICK 1     // Old format (tick count)
#define DBG_FMTTIME_FULL 2     // Full Year/Month/Day Hour:Min:Sec.ms
#define DBG_FMTTIME_DAY  3     // Hour:Minute:Second.ms

extern BOOL      WINAPI     NmDbgRegisterCtl(HWND hwnd, UINT uDisplayMsg);
extern BOOL      WINAPI     NmDbgDeregisterCtl(HWND hwnd);
extern BOOL      WINAPI     NmDbgSetLoggingOptions(HWND hwnd, UINT uOptions);
extern void      WINAPI     NmDbgFlushFileLog();
extern BOOL      WINAPI     NmDbgGetAllZoneParams(PDBGZONEINFO *plpZoneParam, UINT * puCnt);
extern BOOL      WINAPI     NmDbgFreeZoneParams(PDBGZONEINFO pZoneParam);

extern HDBGZONE  WINAPI     NmDbgCreateZone(LPSTR pszName);
extern VOID      WINAPI     NmDbgDeleteZone(LPSTR pszName, HDBGZONE hDbgZone);
extern BOOL      WINAPI     NmDbgSetZone(HDBGZONE hDbgZone,PDBGZONEINFO pZoneParam);
extern PNMDBG    WINAPI     GetPNmDbg(void);
extern VOID      WINAPI     NmDbgSetZoneFileName(HDBGZONE hDbgZone, LPCSTR pszFile);

extern PZONEINFO NMINTERNAL FindZoneForModule(LPCSTR pszModule);
extern PZONEINFO NMINTERNAL AllocZoneForModule(LPCSTR pszModule);
extern PZONEINFO NMINTERNAL MapDebugZoneArea(void);
extern VOID      NMINTERNAL UnMapDebugZoneArea(void);

extern VOID      NMINTERNAL InitDbgZone(void);
extern VOID      NMINTERNAL DeInitDbgZone(void);
extern VOID      NMINTERNAL SetDbgFlags(void);



// Special reserved strings
#define SZ_DBG_MAPPED_ZONE TEXT("_NmDebugZoneMap")
#define SZ_DBG_FILE_MUTEX  TEXT("_NmDbgFileMutex")
#define SZ_DBG_ZONE_MUTEX  TEXT("_NmDbgZoneMutex")


#define GETZONEMASK(z)  ((z) ? (((PZONEINFO)(z))->ulZoneMask) : 0 )
#define IS_ZONE_ENABLED(z, f) ((((PZONEINFO)(z))->ulZoneMask) & (f))

// Macro to check if zone is enabled:  h = ghZone,  i = zone index
#define F_ZONE_ENABLED(h, i)  ((NULL != h) && IS_ZONE_ENABLED(h, (1 << i)))


// Standard Zones
#define ZONE_WARNING           0
#define ZONE_TRACE             1
#define ZONE_FUNCTION          2

#define ZONE_WARNING_FLAG   0x01
#define ZONE_TRACE_FLAG     0x02
#define ZONE_FUNCTION_FLAG  0x04


////////////////////////////////////////////
// Functions
VOID WINAPI     DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap);
PSTR WINAPI     DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...);
PSTR WINAPI     DbgZVPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat, va_list ap);

VOID NMINTERNAL DbgInitEx(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZone, long ulZoneDefault);
VOID NMINTERNAL DbgDeInit(HDBGZONE * phDbgZone);

INLINE VOID DbgInit(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZones)
{
	DbgInitEx(phDbgZone, psz, cZones, 0);
}

PSTR PszPrintf(PCSTR pszFormat,...);

#endif /* NM_DEBUG */


////////////////////////////////////////////
// Main Macros
#ifdef DEBUG
#define DBGINIT(phZone, psz)  DbgInit(phZone, psz, (sizeof(psz)/sizeof(PCHAR))-1)
#define DBGDEINIT(phZone)     DbgDeInit(phZone)

#define ASSERT(exp)     (!(exp) ? ERROR_OUT(("ASSERT failed on %s line %u:\n\r"#exp, __FILE__, __LINE__)) : 0)


VOID WINAPI DbgZPrintError(PSTR pszFormat,...);
VOID WINAPI DbgZPrintWarning(PSTR pszFormat,...);
VOID WINAPI DbgZPrintTrace(PSTR pszFormat,...);
VOID WINAPI DbgZPrintFunction(PSTR pszFormat,...);

#define ERROR_OUT(s)   DbgZPrintError s
#define WARNING_OUT(s) DbgZPrintWarning s
#define TRACE_OUT(s)   DbgZPrintTrace s

#define DBGENTRY(s)        DbgZPrintFunction("Enter " #s);
#define DBGEXIT(s)         DbgZPrintFunction("Exit  " #s);
#define DBGEXIT_HR(s,hr)   DbgZPrintFunction("Exit  " #s "  (result=%s)", GetHRESULTString(hr));
#define DBGEXIT_BOOL(s,f)  DbgZPrintFunction("Exit  " #s "  (result=%s)", GetBOOLString(f));
#define DBGEXIT_INT(s,i)   DbgZPrintFunction("Exit  " #s "  (result=%s)", GetINTString(i));
#define DBGEXIT_ULONG(s,u) DbgZPrintFunction("Exit  " #s "  (result=%s)", GetULONGString((ULONG)u));


#define DBGMSG(z, i, s)                                             \
   {                                                                \
      if ((NULL != z) && (((PZONEINFO)(z))->ulZoneMask & (1<<i)) )  \
      {                                                             \
         LocalFree(DbgZPrintf(z, i, PszPrintf s));                  \
      }                                                             \
   }
// e.g. DBGMSG(ghZone, ZONE_FOO, ("bar=%d", dwBar))

#else
#define DBGINIT(phZone, psz)
#define DBGDEINIT(phZone)
#define ASSERT(exp)

#define ERROR_OUT(s)
#define WARNING_OUT(s)
#define TRACE_OUT(s)

#define DBGENTRY(s)
#define DBGEXIT(s)
#define DBGEXIT_HR(s,hr)
#define DBGEXIT_BOOL(s,f)
#define DBGEXIT_INT(s,i)
#define DBGEXIT_ULONG(s,u)

#ifndef DBGMSG
#define DBGMSG(z, f, s)
#endif

#endif /* DEBUG */


#include <poppack.h> /* End byte packing */

#ifdef __cplusplus
}
#endif

#endif /* _CONFDBG_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\confreg.h ===
#ifndef _CONFREG_H_
#define _CONFREG_H_

#include <nmutil.h>

// General Reg Keys
#define REGVAL_WINDOW_XPOS		TEXT("WindowX")
#define REGVAL_WINDOW_YPOS		TEXT("WindowY")
#define REGVAL_WINDOW_WIDTH		TEXT("WindowWidth")
#define REGVAL_WINDOW_HEIGHT	TEXT("WindowHeight")



	// This is all that is left of Restricted ULS... we always
	// log in as BUSINESS uls type from now on....
#define RESTRICTED_ULS_BUSINESS 2

// Registry path of conference settings under HKEY_LOCAL_MACHINE or
// HKEY_CURRENT_USER.

#define	CONFERENCING_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing")

// Value for disabling pluggable UI
#define REGVAL_DISABLE_PLUGGABLE_UI     TEXT("NoMUI")

// Value for forcing the wizard to run
#define REGVAL_WIZARD_VERSION_UI	TEXT("WizardUI")
#define REGVAL_WIZARD_VERSION_NOUI	TEXT("WizardNoUI")

#define REGVAL_GK_SERVER        TEXT("Gatekeeper")
#define REGVAL_GK_ALIAS         TEXT("GatekeeperAlias")

// Gatekeeper uses phonenum or e-mail to place calls?
#define REGVAL_GK_METHOD			TEXT("GateKeeperAddressing")
#define GK_LOGON_USING_PHONENUM				1
#define GK_LOGON_USING_ACCOUNT				2
#define GK_LOGON_USING_BOTH					3

// Direct is all non-gatekeeper modes ( ils, uls, gateway, machine name, etc. )	
#define REGVAL_CALLING_MODE		TEXT("CallingMethod")
#define CALLING_MODE_DIRECT				0
#define CALLING_MODE_GATEKEEPER			1

// Key and value for finding IE's default search page
#define IE_MAIN_KEY				TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main")
#define REGVAL_IE_SEARCH_PAGE	TEXT("Search Page")
#define REGVAL_IE_START_PAGE    TEXT("Start Page")

#define REGVAL_IE_CLIENTS_MAIL  TEXT("SOFTWARE\\Clients\\mail")
#define REGVAL_IE_CLIENTS_NEWS  TEXT("SOFTWARE\\Clients\\news")

// The shell folders key is useful for finding the Favorites
// folder.  It is stored under HKEY_CURRENT_USER.
#define SHELL_FOLDERS_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")

// The TCPIP Params key possibly contains the local hostname.
// It is stored under HKEY_LOCAL_MACHINE (Win95 only).
#define TCPIP_PARAMS_W95_KEY TEXT("System\\CurrentControlSet\\Services\\VxD\\MSTCP")
#define TCPIP_PARAMS_NT_KEY TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters")

// Hostname contains the TCP/IP hostname - if it is not present,
// then use GetComputerName()
#define	REGVAL_TCPIP_HOSTNAME	TEXT("Hostname")

// The shell open key for http (present if we can ShellExecute() http URL's).
// It is stored under HKEY_LOCAL_MACHINE.
#define CLASSES_HTTP_KEY TEXT("SOFTWARE\\Classes\\http\\shell\\open\\command")

// The shell open key for mailto (present if we can ShellExecute() mailto URL's).
// It is stored under HKEY_LOCAL_MACHINE.
#define CLASSES_MAILTO_KEY TEXT("SOFTWARE\\Classes\\mailto\\shell\\open\\command")

// The Windows CurrentVersion key is used for obtaining the name that was
// was specified while installing Windows.  It is stored under HKEY_LOCAL_MACHINE:
#define WINDOWS_CUR_VER_KEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")

// This is the string value that contains the registered owner name.
// It is stored in the WINDOW_CUR_VER_KEY
#define REGVAL_REGISTERED_OWNER				TEXT("RegisteredOwner")

// 1: join conference without prompt 0: don't
#define	REGVAL_AUTO_ACCEPT					TEXT("AutoAccept")
#define	AUTO_ACCEPT_DEFAULT					0

// n: set comm port wait seconds
#define	REGVAL_N_WAITSECS					TEXT("nWaitSeconds")
#define	N_WAITSECS_DEFAULT					60

// DCB default structure
#define REGVAL_DCB							TEXT("DCB")

// Taskbar icon settings, one of								(HKCU)
#define	REGVAL_TASKBAR_ICON		TEXT("Taskbar Icon")
#define	TASKBARICON_NEVER	    0
#define	TASKBARICON_ALWAYS	    1
#define	TASKBARICON_DEFAULT	    TASKBARICON_ALWAYS

// Controls if node controller is always running 1:yes 0:no		(HKCU)
#define	REGVAL_CONF_ALWAYS_RUNNING			TEXT("Run Always")
#define	ALWAYS_RUNNING_DEFAULT				0

// The Run key is used for forcing windows to run our program in the background
// at startup.  It is stored under HKEY_CURRENT_USER
#define WINDOWS_RUN_KEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run")

// This is the name of the string value that we place under the Run key
#define REGVAL_RUN_TASKNAME					TEXT("Microsoft NetMeeting")


/////////// File Transfer registry keys and values (HKCU) /////////////

#define	FILEXFER_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\File Transfer")

// Path for transferred files
#define	REGVAL_FILEXFER_PATH				TEXT("Receive Directory")

// File Transfer Mode (flags)
#define	REGVAL_FILEXFER_MODE				TEXT("FileXferMode")
#define	FT_MODE_ALLOW_T127                  0x01  /* Allow T.127                 */
#define	FT_MODE_T127                        0x04  /* T.127 is loaded (runtime)   */
#define	FT_MODE_SEND                        0x10  /* Allow sending files         */
#define	FT_MODE_RECEIVE                     0x20  /* Allow receiving             */
#define	FT_MODE_DLL                       0x0100  /* FT loads as DLL (set at runtime) */
#define	FT_MODE_FORCE_DLL                 0x0200  /* Force FT_MODE_DLL setting (debug-only) */
#define	FT_MODE_DEFAULT                     (FT_MODE_ALLOW_T127 | FT_MODE_SEND | FT_MODE_RECEIVE)

// After a file is transferred, display a message, etc.
#define	REGVAL_FILEXFER_OPTIONS             TEXT("FileXferOptions")
#define	FT_SHOW_FOLDER                       0x01 /* Show receive folder */
#define	FT_SHOW_MSG_REC                      0x02 /* Show message after receiving */
#define	FT_SHOW_MSG_SENT                     0x04 /* Show message after sending   */
#define	FT_AUTOSTART                         0x10 /* Always start the File Transfer app */
#define	FT_OPTIONS_DEFAULT                   (FT_SHOW_MSG_SENT | FT_SHOW_MSG_REC)

// MBFT (T.127) Timing values
#define REGVAL_FILEXFER_DISBAND             TEXT("Disband")   // 5000
#define REGVAL_FILEXFER_CH_RESPONSE         TEXT("Response")  // 60000
#define REGVAL_FILEXFER_ENDACK              TEXT("EndAck")    // 60000


/////////// 


// 0: logon a ULS server, 1: don't (stored under CONFERENCING_KEY, HKCU)
#define	REGVAL_DONT_LOGON_ULS				TEXT("DontUseULS")
#define	DONT_LOGON_ULS_DEFAULT				1

// installation directory
#define	REGVAL_INSTALL_DIR					TEXT("InstallationDirectory")

// node controller executable name
#define	REGVAL_NC_NAME						TEXT("NodeControllerName")

// speed dial directory
#define	REGVAL_SPEED_DIAL_FOLDER			TEXT("SpeedDialFolder")

// If call security is whatever and available, then these are changeable
#define REGVAL_SECURITY_INCOMING_REQUIRED   TEXT("RequireSecureIncomingCalls")
#define DEFAULT_SECURITY_INCOMING_REQUIRED  0
#define REGVAL_SECURITY_OUTGOING_PREFERRED  TEXT("PreferSecureOutgoingCalls")
#define DEFAULT_SECURITY_OUTGOING_PREFERRED 0


// 0: Use the NetMeeting default cert, 1: don't
#define REGVAL_SECURITY_AUTHENTICATION      TEXT("SecureAuthentication")
#define DEFAULT_SECURITY_AUTHENTICATION     0   

#define REGVAL_CERT_ID						TEXT("NmCertID")

////////// Home Page related values (HKLM) ////////////////////////////

// NOTE: Default stored as IDS_DEFAULT_WEB_PAGE in confroom.rc
#define	REGVAL_HOME_PAGE				TEXT("NetMeeting Home Page")

/////////// User Location Service related keys and values ////////////
////
//// BUGBUG: merge with defs in audio src tree
////
//// All values here are stored under HKEY_CURRENT_USER
////

#define	ISAPI_KEY                   TEXT("Software\\Microsoft\\User Location Service")
#define	REGKEY_USERDETAILS          TEXT("Client")
#define	ISAPI_CLIENT_KEY            TEXT("Software\\Microsoft\\User Location Service\\Client")

#define	REGVAL_SERVERNAME			TEXT("Server Name")
#define REGVAL_ULS_NAME				TEXT("User Name")
#define REGVAL_ULS_FIRST_NAME		TEXT("First Name")
#define REGVAL_ULS_LAST_NAME		TEXT("Last Name")
#define REGVAL_ULS_RES_NAME			TEXT("Resolve Name")
#define REGVAL_ULS_EMAIL_NAME		TEXT("Email Name")
#define REGVAL_ULS_LOCATION_NAME	TEXT("Location")
#define REGVAL_ULS_PHONENUM_NAME	TEXT("Phonenum")
#define REGVAL_ULS_GK_ACCOUNT		TEXT("Account")
#define REGVAL_ULS_COMMENTS_NAME	TEXT("Comments")
#define REGVAL_ULS_DONT_PUBLISH		TEXT("Don't Publish")
#define REGVAL_ULS_DONT_PUBLISH_DEFAULT	0

#define MAX_DCL_NAME_LEN             48 /* REGVAL_ULS_NAME can't be larger than this */

// The following values and keys are per user,
// i.e. under HKEY_CURRENT_USER

/////////// Audio related keys and values ///////////////////////////

#define	AUDIO_KEY	TEXT("SOFTWARE\\Microsoft\\Conferencing\\Audio Control")

#define REGVAL_CODECCHOICE	TEXT("Codec Choice")
//DWORD one of:
#define CODECCHOICE_AUTO			1
#define CODECCHOICE_MANUAL		2

// DWORD One of:
#define	CODECPOWER_MOST			1
#define	CODECPOWER_MODERATE		2
#define	CODECPOWER_SOME			3
#define	CODECPOWER_LEAST		4

#define	REGVAL_FULLDUPLEX	TEXT("Full Duplex")
// DWORD One of:
#define	FULLDUPLEX_ENABLED		1
#define	FULLDUPLEX_DISABLED		0

#define	REGVAL_AUTOGAIN			TEXT("Auto Gain Control")
// DWORD One of:
#define	AUTOGAIN_ENABLED				1
#define	AUTOGAIN_DISABLED			0


#define REGVAL_AUTOMIX		TEXT("Auto Mix")
// DWORD One of:
#define	AUTOMIX_ENABLED	1
#define	AUTOMIX_DISABLED	0

#define REGVAL_DIRECTSOUND	TEXT("Direct Sound")

#define DSOUND_USER_ENABLED  0x0001
#define DSOUND_USER_DISABLED 0x0000


#define	REGVAL_SOUNDCARDCAPS	TEXT("Sound Card Capabilities")
// DWORD a mask of values specified in oprah\h\audiowiz.h

#define REGVAL_WAVEINDEVICEID	TEXT("WaveIn Device ID")
#define REGVAL_WAVEOUTDEVICEID	TEXT("WaveOut Device ID")

#define REGVAL_WAVEINDEVICENAME		TEXT("WaveIn Device Name")
#define REGVAL_WAVEOUTDEVICENAME	TEXT("WaveOut Device Name")

#define REGVAL_SPKMUTE	TEXT("SpeakerMute")
#define REGVAL_RECMUTE	TEXT("RecordMute")


#define REGVAL_TYPICALBANDWIDTH		TEXT("Typical BandWidth")
#define BW_144KBS				1
#define BW_288KBS				2
#define BW_ISDN 				3
#define BW_MOREKBS				4
#define BW_DEFAULT				BW_288KBS




//this is actually the last volume used by conf
#define REGVAL_CALIBRATEDVOL		TEXT("Calibrated Volume")
//at calibration both the lastcalibratedvol and calibrated volume are set to the same
//value
#define REGVAL_LASTCALIBRATEDVOL	TEXT("Last Calibrated Volume")

#define REGVAL_AUTODET_SILENCE	TEXT("Automatic Silence Detection")

#define REGVAL_SPEAKERVOL	TEXT("Speaker Volume")

#define	REGVAL_MICROPHONE_SENSITIVITY	TEXT("Microphone Sensitivity")
#define	MIN_MICROPHONE_SENSITIVITY	0
#define	MAX_MICROPHONE_SENSITIVITY	20
#define	DEFAULT_MICROPHONE_SENSITIVITY	14

#define	REGVAL_MICROPHONE_AUTO			TEXT("Automatic Mic Sensitivity")
#define	MICROPHONE_AUTO_YES				1
#define	MICROPHONE_AUTO_NO				0
#define DEFAULT_MICROPHONE_AUTO			MICROPHONE_AUTO_YES

#define DEFAULT_USE_PROXY				0
#define REGVAL_USE_PROXY				TEXT("Enable Proxy")
#define REGVAL_PROXY					TEXT("Proxy")

#define DEFAULT_USE_H323_GATEWAY		0
#define REGVAL_USE_H323_GATEWAY			TEXT("Enable H.323 Gateway")
#define REGVAL_H323_GATEWAY				TEXT("H.323 Gateway")

#define DEFAULT_POL_NO_WEBDIR			0
#define REGVAL_POL_NO_WEBDIR			TEXT("NoWebDirectory")
#define REGVAL_WEBDIR_URL				TEXT("webDirectory URL")
#define REGVAL_WEBDIR_ILS				TEXT("webDirectory ILS")
#define REGVAL_WEBDIR_DISPLAY_NAME		TEXT("webDirectory Name")

#define REGVAL_POL_NOCHANGECALLMODE     TEXT("NoChangingCallMode")
#define DEFAULT_POL_NOCHANGECALLMODE    0

// from common.h (HKCU)
#define INTERNET_AUDIO_KEY              TEXT("Software\\Microsoft\\Internet Audio")
#define REGVAL_ACMH323ENCODINGS         TEXT("ACMH323Encodings")

// from common.h (HKLM)
#define NACOBJECT_KEY                       TEXT("Software\\Microsoft\\Internet Audio\\NacObject")
#define REGVAL_DISABLE_WINSOCK2             TEXT("DisableWinsock2")


/////////// Video related keys and values ///////////////////////////

#define	VIDEO_KEY	        TEXT("SOFTWARE\\Microsoft\\Conferencing\\Video Control")
#define	VIDEO_LOCAL_KEY	    TEXT("SOFTWARE\\Microsoft\\Conferencing\\Video Control\\Local")
#define	VIDEO_REMOTE_KEY	TEXT("SOFTWARE\\Microsoft\\Conferencing\\Video Control\\Remote")

#define REGVAL_CAPTUREDEVICEID	TEXT("Capture Device ID")
#define REGVAL_CAPTUREDEVICENAME		TEXT("Capture Device Name")
#define	REGVAL_CAPTURECARDCAPS	TEXT("Capture Card Capabilities")

#define REGVAL_VIDEO_ALLOW_SEND             TEXT("AllowSend")
#define REGVAL_VIDEO_ALLOW_RECEIVE          TEXT("AllowReceive")
#define VIDEO_ALLOW_SEND_DEFAULT            1
#define VIDEO_ALLOW_RECEIVE_DEFAULT         1

#define REGVAL_VIDEO_DOCK_EDGE              TEXT("DockEdge")

#define	REGVAL_VIDEO_WINDOW_INIT            TEXT("WindowOnInit")
#define	REGVAL_VIDEO_WINDOW_CONNECT         TEXT("WindowOnConnect")
#define	REGVAL_VIDEO_WINDOW_DISCONNECT      TEXT("WindowOnDisconnect")
//DWORD one of:
#define VIDEO_WINDOW_NOP            0   // Leave window in current state
#define VIDEO_WINDOW_HIDE           1   // Hide window
#define VIDEO_WINDOW_SHOW           2   // Show window
#define VIDEO_WINDOW_PROMPT         3   // Prompt to show/hide window
#define VIDEO_WINDOW_PREV           4   // Restore previous window state

#define VIDEO_LOCAL_INIT_DEFAULT            VIDEO_WINDOW_NOP
#define VIDEO_REMOTE_INIT_DEFAULT           VIDEO_WINDOW_NOP

#define VIDEO_LOCAL_CONNECT_DEFAULT         VIDEO_WINDOW_NOP
#define VIDEO_REMOTE_CONNECT_DEFAULT        VIDEO_WINDOW_NOP

#define VIDEO_LOCAL_DISCONNECT_DEFAULT      VIDEO_WINDOW_NOP
#define VIDEO_REMOTE_DISCONNECT_DEFAULT     VIDEO_WINDOW_NOP

#define	REGVAL_VIDEO_XFER_INIT              TEXT("XferOnInit")
#define	REGVAL_VIDEO_XFER_CONNECT           TEXT("XferOnConnect")
#define	REGVAL_VIDEO_XFER_DISCONNECT        TEXT("XferOnDisconnect")
#define	REGVAL_VIDEO_XFER_SHOW              TEXT("XferOnShow")
#define	REGVAL_VIDEO_XFER_HIDE              TEXT("XferOnHide")
//DWORD one of:
#define VIDEO_XFER_NOP              0   // Leave transfer in current state
#define VIDEO_XFER_STOP             1   // Stop transfer
#define VIDEO_XFER_START            2   // Start transfer
#define VIDEO_XFER_PROMPT           3   // Prompt to start/stop transfer
#define VIDEO_XFER_PREV             4   // Previous state

#define	VIDEO_SEND_INIT_DEFAULT             VIDEO_XFER_STOP
#define	VIDEO_RECEIVE_INIT_DEFAULT          VIDEO_XFER_STOP

#define	VIDEO_SEND_CONNECT_DEFAULT          VIDEO_XFER_NOP
#define	VIDEO_RECEIVE_CONNECT_DEFAULT       VIDEO_XFER_START

#define	VIDEO_SEND_DISCONNECT_DEFAULT       VIDEO_XFER_NOP
#define	VIDEO_RECEIVE_DISCONNECT_DEFAULT    VIDEO_XFER_STOP

#define	VIDEO_SEND_SHOW_DEFAULT             VIDEO_XFER_PROMPT
#define	VIDEO_RECEIVE_SHOW_DEFAULT          VIDEO_XFER_PREV

#define	VIDEO_SEND_HIDE_DEFAULT             VIDEO_XFER_PROMPT
#define	VIDEO_RECEIVE_HIDE_DEFAULT          VIDEO_XFER_STOP

#define REGVAL_VIDEO_XPOS           REGVAL_WINDOW_XPOS
#define REGVAL_VIDEO_YPOS           REGVAL_WINDOW_YPOS

//------------------------------------------------------- 
// SIC
// Notice that the height and width reg keys are reversed
// ( that is the WindowHeight registry value actuall holds the
// video window's width )....
// It has always been like this but because it would screw
// up upgrade installations if we "fixed" it, we are going
// to keep it like this.... 
#define REGVAL_VIDEO_WIDTH          REGVAL_WINDOW_HEIGHT
#define REGVAL_VIDEO_HEIGHT         REGVAL_WINDOW_WIDTH

#define REGVAL_VIDEO_DOCKED_XPOS    TEXT("DockedX")
#define REGVAL_VIDEO_DOCKED_YPOS    TEXT("DockedY")

#define REGVAL_VIDEO_TOPMOST        TEXT("TopMost")
#define VIDEO_TOPMOST_DEFAULT       1

#define REGVAL_VIDEO_ZOOM           TEXT("Zoom")
#define VIDEO_ZOOM_DEFAULT          100

#define REGVAL_VIDEO_MIRROR         TEXT("Mirror")
#define VIDEO_MIRROR_DEFAULT        TRUE

#define REGVAL_VIDEO_VISIBLE            TEXT("Visible")
#define VIDEO_LOCAL_VISIBLE_DEFAULT     0
#define VIDEO_REMOTE_VISIBLE_DEFAULT    0

#define REGVAL_VIDEO_FRAME_SIZE         TEXT("FrameSize")

#define REGVAL_VIDEO_AUDIO_SYNC         TEXT("AVSync")
#define VIDEO_AUDIO_SYNC_DEFAULT        1

/////////// QoS-related keys and values (HKLM, CONFERENCING_KEY) /////////
#define QOS_KEY					CONFERENCING_KEY TEXT("\\QoS")
#define	REGKEY_QOS_RESOURCES	QOS_KEY TEXT("\\Resources") 

/////////// Tools menu related registry keys and values /////////////

#define	TOOLS_MENU_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Tools") // (HKLM)

/////////// MRU related registry keys and values /////////////

#define	MRU_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI\\Calls")
#define	DIR_MRU_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI\\Directory")

// Most recently used list count
#define REGVAL_MRU_COUNT					TEXT("Count")

// MRU list prefixes (name and transport)
#define REGVAL_NAME_MRU_PREFIX				TEXT("Name")
#define REGVAL_TRANSPORT_MRU_PREFIX			TEXT("Transport")
#define REGVAL_CALL_FLAGS_MRU_PREFIX		TEXT("Flags")

// MRU list for the "Place A Call" dialog
#define DLGCALL_MRU_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI\\CallMRU")
#define REGVAL_DLGCALL_DEFDIR               TEXT("DefDir")
#define REGVAL_DLGCALL_POSITION             TEXT("Pos")
#define REGVAL_DLGCALL_NAME_MRU_PREFIX      TEXT("Name")
#define REGVAL_DLGCALL_ADDR_MRU_PREFIX      TEXT("Addr")
#define REGVAL_DLGCALL_TYPE_MRU_PREFIX      TEXT("Type")

/////////// UI related registry keys and values /////////////

#define	UI_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI")

// Window size/position
#define REGVAL_MP_WINDOW_X					REGVAL_WINDOW_XPOS
#define DEFAULT_MP_WINDOW_X					10
#define REGVAL_MP_WINDOW_Y					REGVAL_WINDOW_YPOS
#define DEFAULT_MP_WINDOW_Y					3
#define REGVAL_MP_WINDOW_WIDTH				REGVAL_WINDOW_WIDTH
#define DEFAULT_MP_WINDOW_WIDTH				638 // IDS_WINDOW_WIDTH fallback
#define REGVAL_MP_WINDOW_HEIGHT				REGVAL_WINDOW_HEIGHT // actually window bottom
#define DEFAULT_MP_WINDOW_HEIGHT			500 // max of SVGA: 800x600 (was 640x480)
#define DEFAULT_MP_WINDOW_HEIGHT_LAN        574 // allows for larger video windows
#define REGVAL_MP_WINDOW_MAXIMIZED			TEXT("WindowMax")    // actually window right
#define DEFAULT_MP_WINDOW_MAXIMIZED			0
#define REGVAL_MP_WINDOW_STATE				TEXT("WindowState")    // Normal, Compact, Data-Only
#define DEFAULT_MP_WINDOW_STATE				0

#define REGVAL_COLUMN_WIDTHS				TEXT("ColumnWidths")
#define REGVAL_COLUMN_ORDER					TEXT("ColumnOrder")
#define REGVAL_DIR_FILTER					TEXT("DirFilter")
#define REGVAL_DIR_COLUMN_WIDTHS			TEXT("DirColumnWidths")
#define REGVAL_DIR_COLUMN_ORDER				TEXT("DirColumnOrder")
#define REGVAL_DIR_SORT_ASCENDING			TEXT("DirSortAscending")
#define REGVAL_DIR_SORT_COLUMN				TEXT("DirSortColumn")

#define REGVAL_ENABLE_DIRECTORY_INITIALREFRESH	TEXT("DirInitialRefresh")
#define DEFAULT_ENABLE_DIRECTORY_INITIALREFRESH	1
#define REGVAL_ENABLE_DIRECTORY_AUTOREFRESH	    TEXT("DirAutoRefresh")
#define DEFAULT_ENABLE_DIRECTORY_AUTOREFRESH	0
#define REGVAL_DIRECTORY_REFRESH_INTERVAL		TEXT("DirRefreshInterval")
#define DEFAULT_DIRECTORY_REFRESH_INTERVAL	    5 // minutes

#define REGVAL_CACHE_DIRECTORY              TEXT("DirCache")
#define DEFAULT_CACHE_DIRECTORY             1
#define REGVAL_CACHE_DIRECTORY_EXPIRATION   TEXT("DirExpire")
#define DEFAULT_CACHE_DIRECTORY_EXPIRATION  30 // minutes

#define REGVAL_RING_TIMEOUT                 TEXT("CallTimeout")
#define DEFAULT_RING_TIMEOUT                20 // seconds

// Window element visibility
#define REGVAL_SHOW_TOOLBAR                 TEXT("Toolbar")
#define DEFAULT_SHOW_TOOLBAR                1
#define REGVAL_SHOW_STATUSBAR               TEXT("StatusBar")
#define DEFAULT_SHOW_STATUSBAR              1

#define REGVAL_SHOW_SECUREDETAILS			TEXT("SecurityDetails")
#define DEFAULT_SHOW_SECUREDETAILS			0




// Don't show me dialog settings (all default to FALSE)
#define REGVAL_DS_DO_NOT_DISTURB_WARNING			TEXT("DS Do Not Disturb Warning")
#define REGVAL_DS_MACHINE_NAME_WARNING				TEXT("DS Machine Name Warning")

/////////// GUID related registry keys and values /////////////

#define	GUID_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Applications")
#define T120_APPLET_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\T.120 Applets")
#define T120_NONSTD_KEY TEXT("NonStd Key")
#define T120_STD_KEY    TEXT("Object Key")

// startup values
#define REGVAL_GUID_APPNAME                 TEXT("Path")
#define REGVAL_GUID_CMDLINE                 TEXT("CmdLine")
#define REGVAL_GUID_CURRDIR                 TEXT("Directory")

// environment variables (not registry items)
#define ENV_NODEID                          TEXT("_node_id")
#define ENV_CONFID                          TEXT("_conf_id")


// GUID for Roster information
// {6CAA8570-CAE5-11cf-8FA5-00805F742EF6}
#define GUID_ROSTINFO {0x6caa8570,0xcae5,0x11cf,{0x8f,0xa5,0x00,0x80,0x5f,0x74,0x2e,0xf6}}

// GUID for Version information, passed across T120 as User Data.
// {E0A07F00-C9D7-11cf-A4ED-00AA003B1816}
#define GUID_VERSION  {0xe0a07f00,0xc9d7,0x11cf,{0xa4,0xed,0x00,0xaa,0x00,0x3b,0x18,0x16}}

// GUID for capabilities, passed across T120 as User Data.
// {5E8BA590-8C59-11d0-8DD6-0000F803A446}
#define GUID_CAPS     {0x5e8ba590,0x8c59,0x11d0,{0x8d,0xd6,0x00,0x00,0xf8,0x03,0xa4,0x46}}

// GUID for Security information
// {DF7284F0-B933-11d1-8754-0000F8757125}
#define GUID_SECURITY { 0xdf7284f0, 0xb933, 0x11d1, { 0x87, 0x54, 0x0, 0x0, 0xf8, 0x75, 0x71, 0x25 } }

// GUID for H.323 terminal label 
// {16D7DA06-FF2C-11d1-B32D-00C04FD919C9}
#define GUID_TERMLABEL { 0x16d7da06, 0xff2c, 0x11d1, {0xb3, 0x2d, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9 } }

// GUID for meeting settings
// {44B67307-D4EC-11d2-8BE4-00C04FD8EE32}
#define GUID_MTGSETTINGS { 0x44b67307, 0xd4ec, 0x11d2, { 0x8b, 0xe4, 0x0, 0xc0, 0x4f, 0xd8, 0xee, 0x32 } }

// GUID for Unigue Node Id
// {74423881-CC84-11d2-B4E3-00A0C90D0660}
#define GUID_NODEID { 0x74423881, 0xcc84, 0x11d2, { 0xb4, 0xe3, 0x0, 0xa0, 0xc9, 0xd, 0x6, 0x60 } }

// NetMeeting versions
#define DWVERSION_NM_1    (0x04000000 | 1133)  // 1.0 Final
#define DWVERSION_NM_2b2  (0x04000000 | 1266)  // 2.0 Beta 2
#define DWVERSION_NM_2b4  (0x04000000 | 1333)  // 2.0 Beta 4
#define DWVERSION_NM_2b5  (0x04000000 | 1349)  // 2.0 RC 1
#define DWVERSION_NM_2rc2 (0x04000000 | 1366)  // 2.0 RC 2
#define DWVERSION_NM_2    (0x04000000 | 1368)  // 2.0 Final
#define DWVERSION_NM_2q1  (0x04000000 | 1372)  // 2.0 QFE
#define DWVERSION_NM_3a1  (0x04030000 | 2000)  // 2.1 Alpha 1
#define DWVERSION_NM_3b1  (0x04030000 | 2064)  // 2.1 Beta 1
#define DWVERSION_NM_3b2  (0x04030000 | 2099)  // 2.1 Beta 2
#define DWVERSION_NM_3rc  (0x04030000 | 2135)  // 2.1 Final
#define DWVERSION_NM_3sp1 (0x04030000 | 2203)  // 2.1 Service Pack 1
#define DWVERSION_NM_3o9b1 (0x04030000 | 2408) // 2.11 Office Beta 1 and IE5 Beta 1
#define DWVERSION_NM_3ntb2 (0x04030000 | 2412) // 2.11 NT Beta 2
#define DWVERSION_NM_3max  (0x0403ffff)		   // 2.X max version

#define DWVERSION_NM_4a1  (0x04040000 | 2200)  // 3.0 Alpha 1
#define DWVERSION_NM_4    VER_PRODUCTVERSION_DW
#define DWVERSION_NM_CURRENT    DWVERSION_NM_4

#define DWVERSION_MASK     0x00FF0000  // mask for product version number


/////////// Policy related registry keys and values /////////////

#define	POLICIES_KEY TEXT("SOFTWARE\\Policies\\Microsoft\\Conferencing")

// The following are the policy values that can be set by the policy editor
// If any of these are set to 1, the feature is disabled.  If they are not
// present or they are set to 0, the feature is enabled.

#define REGVAL_AUTOCONF_USE				    TEXT("Use AutoConfig")
#define DEFAULT_AUTOCONF_USE				0
#define REGVAL_AUTOCONF_CONFIGFILE			TEXT("ConfigFile")
#define REGVAL_AUTOCONF_TIMEOUT				TEXT("Timeout")
#define DEFAULT_AUTOCONF_TIMEOUT			10000


#define	REGVAL_POL_NO_FILETRANSFER_SEND		TEXT("NoSendingFiles")
#define	DEFAULT_POL_NO_FILETRANSFER_SEND	0
#define	REGVAL_POL_NO_FILETRANSFER_RECEIVE	TEXT("NoReceivingFiles")
#define	DEFAULT_POL_NO_FILETRANSFER_RECEIVE	0
#define REGVAL_POL_MAX_SENDFILESIZE			TEXT("MaxFileSendSize")
#define	DEFAULT_POL_MAX_FILE_SIZE			0

#define REGVAL_POL_NO_CHAT			        TEXT("NoChat")
#define	DEFAULT_POL_NO_CHAT		            0
#define REGVAL_POL_NO_OLDWHITEBOARD         TEXT("NoOldWhiteBoard")
#define	DEFAULT_POL_NO_OLDWHITEBOARD        0
#define REGVAL_POL_NO_NEWWHITEBOARD         TEXT("NoNewWhiteBoard")
#define DEFAULT_POL_NO_NEWWHITEBOARD        0

#define	REGVAL_POL_NO_APP_SHARING			TEXT("NoAppSharing")
#define	DEFAULT_POL_NO_APP_SHARING			0
#define REGVAL_POL_NO_SHARING               TEXT("NoSharing")
#define DEFAULT_POL_NO_SHARING              0
#define REGVAL_POL_NO_DESKTOP_SHARING       TEXT("NoSharingDesktop")
#define DEFAULT_POL_NO_DESKTOP_SHARING      0
#define	REGVAL_POL_NO_MSDOS_SHARING			TEXT("NoSharingDosWindows")
#define	DEFAULT_POL_NO_MSDOS_SHARING		0
#define	REGVAL_POL_NO_EXPLORER_SHARING		TEXT("NoSharingExplorer")
#define	DEFAULT_POL_NO_EXPLORER_SHARING		0
#define REGVAL_POL_NO_TRUECOLOR_SHARING     TEXT("NoTrueColorSharing")
#define DEFAULT_POL_NO_TRUECOLOR_SHARING    0
#define	REGVAL_POL_NO_ALLOW_CONTROL		    TEXT("NoAllowControl")
#define	DEFAULT_POL_NO_ALLOW_CONTROL		0

#define	REGVAL_POL_NO_AUDIO					TEXT("NoAudio")
#define	DEFAULT_POL_NO_AUDIO				0
#define REGVAL_POL_NO_ADVAUDIO				TEXT("NoAdvancedAudio")
#define	DEFAULT_POL_NO_ADVAUDIO				0
#define REGVAL_POL_NO_FULLDUPLEX			TEXT("NoFullDuplex")
#define	DEFAULT_POL_NO_FULLDUPLEX			0
#define REGVAL_POL_NOCHANGE_DIRECTSOUND     TEXT("NoChangeDirectSound")
#define DEFAULT_POL_NOCHANGE_DIRECTSOUND    0
#define REGVAL_POL_NO_VIDEO_SEND			TEXT("NoSendingVideo")
#define	DEFAULT_POL_NO_VIDEO_SEND			0
#define REGVAL_POL_NO_VIDEO_RECEIVE			TEXT("NoReceivingVideo")
#define	DEFAULT_POL_NO_VIDEO_RECEIVE		0
#define REGVAL_POL_MAX_BANDWIDTH			TEXT("MaximumBandwidth")
#define DEFAULT_POL_MAX_BANDWIDTH			0

#define	REGVAL_POL_NO_GENERALPAGE			TEXT("NoGeneralPage")
#define	DEFAULT_POL_NO_GENERALPAGE			0
#define REGVAL_POL_NO_SECURITYPAGE			TEXT("NoSecurityPage")
#define DEFAULT_POL_NO_SECURITYPAGE			0
#define	REGVAL_POL_NO_AUDIOPAGE				TEXT("NoAudioPage")
#define	DEFAULT_POL_NO_AUDIOPAGE			0
#define REGVAL_POL_NO_VIDEOPAGE             TEXT("NoVideoPage")
#define	DEFAULT_POL_NO_VIDEOPAGE			0
#define REGVAL_POL_NO_ADVANCEDCALLING       TEXT("NoAdvancedCalling")
#define DEFAULT_POL_NO_ADVANCEDCALLING      0

#define REGVAL_POL_NO_DIRECTORY_SERVICES	TEXT("NoDirectoryServices")
#define	DEFAULT_POL_NO_DIRECTORY_SERVICES	0
#define REGVAL_POL_NO_AUTOACCEPTCALLS       TEXT("NoAutoAcceptCalls")
#define	DEFAULT_POL_NO_AUTOACCEPTCALLS      0
#define REGVAL_POL_PERSIST_AUTOACCEPTCALLS  TEXT("PersistAutoAcceptCalls")
#define	DEFAULT_POL_PERSIST_AUTOACCEPTCALLS 0
#define REGVAL_POL_INTRANET_SUPPORT_URL     TEXT("IntranetSupportURL")
#define REGVAL_POL_INTRANET_WEBDIR_URL      TEXT("IntranetWebDirURL")
#define REGVAL_POL_INTRANET_WEBDIR_NAME     TEXT("IntranetWebDirName")
#define REGVAL_POL_INTRANET_WEBDIR_SERVER   TEXT("IntranetWebDirServer")
#define REGVAL_POL_SHOW_FIRST_TIME_URL		TEXT("ShowFirstTimeURL")
#define DEFAULT_POL_SHOW_FIRST_TIME_URL		0
#define REGVAL_POL_NO_ADDING_NEW_ULS        TEXT("NoAddingDirectoryServers")
#define DEFAULT_POL_NO_ADDING_NEW_ULS       0

// Before a file is transferred, we need to check its size in case it exceeds the limit.
// This is the default size limit (0 is "no limit").
#define REGVAL_POL_NO_RDS					TEXT("NoRDS")
#define DEFAULT_POL_NO_RDS					0
#define REGVAL_POL_NO_RDS_WIN9X             TEXT("NoRDSWin9x")
#define DEFAULT_POL_NO_RDS_WIN9X            0



// MCU cleartext password keys.
#define REGVAL_VALIDATE_USER				TEXT("PasswordValidation")
#define REGKEY_CONFERENCES					TEXT("Conferences")
#define REGVAL_PASSWORD						TEXT("Password")

// CALL SECURITY
#define REGVAL_POL_SECURITY             TEXT("CallSecurity")
#define STANDARD_POL_SECURITY           0
#define REQUIRED_POL_SECURITY           1
#define DISABLED_POL_SECURITY           2
#define DEFAULT_POL_SECURITY            STANDARD_POL_SECURITY

#define REGVAL_POL_NO_INCOMPLETE_CERTS		TEXT("NoIncompleteCerts")
#define DEFAULT_POL_NO_INCOMPLETE_CERTS		0
#define REGVAL_POL_ISSUER					TEXT("CertificateIssuer")

/////////// Logging related registry keys and values /////////////

#define	LOG_INCOMING_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Log\\Incoming")
#define	LOG_OUTGOING_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Log\\Outgoing")

// Name of file in which to store log data
#define	REGVAL_LOG_FILE                     TEXT("File")

// Number of days before deleting log entry
#define	REGVAL_LOG_EXPIRE                   TEXT("Expire")
#define	DEFAULT_LOG_EXPIRE                  0

// Maximum number of log entries to maintain
#define REGVAL_LOG_MAX_ENTRIES				TEXT("Max Entries")
#define DEFAULT_LOG_MAX_ENTRIES				100


///////////// Debug only registry settings //////////////

// Flag to determine whether to display debug output window
#define REGVAL_SHOW_DEBUG_OUTPUT			TEXT("ShowDebugOutput")


// Debug-only key
#define DEBUG_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Debug")

#define REGVAL_DBG_OUTPUT                    TEXT("OutputDebugString")
#define DEFAULT_DBG_OUTPUT                    1
#define REGVAL_DBG_WIN_OUTPUT                TEXT("Window Output")
#define DEFAULT_DBG_NO_WIN                    0
#define REGVAL_DBG_FILE_OUTPUT               TEXT("File Output")
#define DEFAULT_DBG_NO_FILE                   0
#define REGVAL_DBG_FILE                      TEXT("File")
#define DEFAULT_DBG_FILENAME                 TEXT("nmDbg.txt")

#define REGVAL_RETAIL_LOG                    TEXT("RetailLog")
#define RETAIL_LOG_FILENAME                  TEXT("nmLog.txt")

#define REGVAL_DBG_SPEWFLAGS                 TEXT("SpewFlags")
#define DEFAULT_DBG_SPEWFLAGS                 0

#define REGVAL_DBG_SHOW_TIME                 TEXT("Show Time")
#define REGVAL_DBG_SHOW_THREADID             TEXT("Show ThreadId")
#define REGVAL_DBG_SHOW_MODULE               TEXT("Show Module")

#define REGVAL_DBG_RTL                       TEXT("RTL")
#define DEFAULT_DBG_RTL                      0

#define REGVAL_DBG_DISPLAY_FPS               TEXT("DisplayFps")
#define REGVAL_DBG_DISPLAY_VIEWSTATUS        TEXT("ViewStatus")

#define REGVAL_DBG_FAKE_CALLTO               TEXT("CallTo")
#define DEFAULT_DBG_FAKE_CALLTO              0

#define REGVAL_DBG_CALLTOP                   TEXT("CallTop")
#define DEFAULT_DBG_CALLTOP                  1


#define ZONES_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Debug\\Zones")


/////////// Whiteboard related registry keys and values /////////////

#define	WHITEBOARD_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Whiteboard")
#define	NEW_WHITEBOARD_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Whiteboard 3.0")

//Whiteboard values are defined in oprah\dcg32\wb32\wwbopts.hpp

////////////// Chat related registry keys and values ////////////////

#define	CHAT_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Chat")

////////////// Remote control service related keys and values ////////////////

#define WIN95_SERVICE_KEY					TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define REMOTECONTROL_KEY					TEXT("SOFTWARE\\Microsoft\\Conferencing\\Mcpt")
#define WINNT_WINLOGON_KEY                                      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define WIN95_WINLOGON_KEY                                      TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Winlogon")
#define DESKTOP_KEY                                             TEXT("Control Panel\\Desktop")
#define REMOTE_REG_RUNSERVICE				TEXT("Fpx")
#define DEFAULT_REMOTE_RUNSERVICE			0
#define REMOTE_REG_ACTIVATESERVICE			TEXT("Plc")
#define DEFAULT_REMOTE_ACTIVATESERVICE		0
#define REMOTE_REG_NOEXIT                   TEXT("Nx")
#define DEFAULT_REMOTE_NOEXIT              0

#define REMOTE_REG_PASSWORD					TEXT("FieldPos")

#define REGVAL_SCREENSAVER_GRACEPERIOD                          TEXT("ScreenSaverGracePeriod")
#define REGVAL_WINNT_SCPW                                       TEXT("ScreenSaverIsSecure")
#define REGVAL_WIN95_SCPW                                       TEXT("ScreenSaveUsePassword")

/////////// NT display driver registry keys and values (HKLM) /////////////

#define NM_NT_DISPLAY_DRIVER_KEY	TEXT("System\\CurrentControlSet\\Services\\mnmdd")
#define REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED	TEXT("Start")
// Note: The below values are from KB article Q103000
#define NT_DRIVER_START_BOOT		0x0
#define NT_DRIVER_START_SYSTEM		0x1
#define NT_DRIVER_START_AUTOLOAD	0x2
#define NT_DRIVER_START_ONDEMAND	0x3
#define NT_DRIVER_START_DISABLED	0x4

/////////// NT service pack version registry keys and values (HKLM) /////////////
#define NT_WINDOWS_SYSTEM_INFO_KEY	TEXT("System\\CurrentControlSet\\Control\\Windows")
#define REGVAL_NT_CSD_VERSION		TEXT("CSDVersion")


/////////// System Information registry keys and values (HKLM) /////////////
#define WINDOWS_KEY            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define WINDOWS_NT_KEY         TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")
#define REGVAL_REGISTERED_USER TEXT("RegisteredOwner")
#define	REGVAL_REGISTERED_ORG  TEXT("RegisteredOrganization")

#endif  // ! _CONFREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\confwiz.h ===
// This is the header file for conference wizards in conf.exe
//
//	Created:	ClausGi	8-30-95
//


// Data structure for NewConnectorWizard call

typedef struct _NewConnectorWizardStruct {

	// The following path describes the folder that the wizard
	// is invoked in. This is used to determine where the speed-dial
	// object is created.

	char szPathOfInvocation[MAX_PATH];

} NCW, FAR * LPNCW;


// Functions:
BOOL WINAPI NewConferenceWizard ( HINSTANCE hInst, HWND hWnd );
BOOL WINAPI NewConnectorWizard ( HINSTANCE hInst, HWND hWnd, LPNCW lpncw );

/* Constants - BUGBUG move this to wizglob.h */

#define	NUM_PAGES	4
#define	_MAX_TEXT	512

// BUGBUG review all of these
#define	MAX_CONF_PASSWORD	12
#define	MAX_CONF_NAME		256
#define	MAX_SERVER_NAME		256
#define	MAX_WAB_TAG			256

#define	CONF_TYPE_PRIVATE	0
#define	CONF_TYPE_JOINABLE	1


/* Data Structures private to the wizard code */

typedef struct _ConfInfo {
	char szConfName[MAX_CONF_NAME+1];
	char szPwd[MAX_CONF_PASSWORD+1];
	WORD wConfType;
	WORD cMembers;
	HWND hwndMemberList;
	DWORD dwDuration;
	// Addl info TBD;
} CI, FAR * LPCI;

typedef struct _ConnectInfo {
	char szTargetName[MAX_WAB_TAG];
	char szAddress[MAX_PATH]; // BUGBUG proper limit needed
	DWORD dwAddrType;
	int idPreferredTransport;
	BOOL fSingleAddress;
	// Addl info TBD;
} CN, FAR * LPCN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\cpappletnotify.h ===
#ifndef __CPAppletNotify_h__
#define __CPAppletNotify_h__

#include "CPnmctl1.h"


#endif // __CPAppletNotify_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\cpnmctl1.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxyINmAppletNotify
template <class T>
class CProxyINmAppletNotify : public IConnectionPointImpl<T, &IID_INmAppletNotify, CComDynamicUnkArray>
{
public:

//INmAppletNotify
public:
	HRESULT Fire_OnStateChanged(
		int State)
	{
		T* pT = (T*)this;
		pT->Lock();
		HRESULT ret;
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				INmAppletNotify* pINmAppletNotify = reinterpret_cast<INmAppletNotify*>(*pp);
				ret = pINmAppletNotify->OnStateChanged(State);
			}
			pp++;
		}
		pT->Unlock();
		return ret;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\custring.h ===
#ifndef _CUSTRING_H_
#define _CUSTRING_H_

#include <nmutil.h>

// Simple universal string class, where string can be converted 
// back and forth between Ansi and Unicode string and buffers
// allocated are destroyed in string class destructor.

class CUSTRING
{
public:
	CUSTRING(PCWSTR wszText = NULL);
	CUSTRING(PCSTR szText);
	~CUSTRING();
	operator PWSTR();
	operator PSTR();
	inline void GiveString(PCWSTR wszText);
	inline void GiveString(PCSTR szText);
	inline void AssignString(PCWSTR wszText);
	inline void AssignString(PCSTR szText);
protected:
	PWSTR	wszData;
	PSTR	szData;
	BOOL	bUnicodeNew;
	BOOL	bAnsiNew;
};


inline void CUSTRING::GiveString(PCWSTR wszText)
{
	ASSERT(!wszData);
	wszData = (PWSTR)wszText;
	bUnicodeNew = TRUE;
}

inline void CUSTRING::GiveString(PCSTR szText)
{
	ASSERT(!szData);
	szData = (PSTR)szText;
	bAnsiNew = TRUE;
}

inline void CUSTRING::AssignString(PCWSTR wszText)
{
	ASSERT(!wszData);
	wszData = (PWSTR)wszText;
}

inline void CUSTRING::AssignString(PCSTR szText)
{
	ASSERT(!szData);
	szData = (PSTR)szText;
}

#endif // ndef CUSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\dcap.h ===
//  DCAP.H
//
//  Created 31-Jul-96 [JonT]

#ifndef _DCAP_H
#define _DCAP_H

#pragma pack(1)         /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// API defines. These allow optimized DLL import code generation
#ifdef __DCAP_BUILD__
#define DCAPI WINAPI
#else
#define DCAPI __declspec(dllimport) __stdcall
#endif

// Equates
#define MAX_CAPDEV_NAME                 MAX_PATH
#define MAX_CAPDEV_DESCRIPTION          MAX_PATH
#define MAX_CAPDEV_VERSION              80
#define MIN_STREAMING_CAPTURE_BUFFERS   2

// Equates for "InitializeStreaming" flags
#define STREAMING_PREFER_STREAMING      0x0
#define STREAMING_PREFER_FRAME_GRAB     0x1

// CaptureDeviceDialog flags
#define CAPDEV_DIALOG_QUERY     1       // Queries if the dialog exists
#define CAPDEV_DIALOG_IMAGE     0       // (default and mutually exclusive with
#define CAPDEV_DIALOG_SOURCE    2       //  CAPDEV_DIALOG_SOURCE)

// Errors
#define DCAP_ERRORBIT           0x20000000
#define ERROR_DCAP_DEVICE_IN_USE        (DCAP_ERRORBIT | 0x0001)
#define ERROR_DCAP_BAD_INSTALL          (DCAP_ERRORBIT | 0x0002)
#define ERROR_DCAP_NONSPECIFIC          (DCAP_ERRORBIT | 0x0003)
#define ERROR_DCAP_NO_DRIVER_SUPPORT    (DCAP_ERRORBIT | 0x0004)
#define ERROR_DCAP_NOT_WHILE_STREAMING  (DCAP_ERRORBIT | 0x0005)
#define ERROR_DCAP_FORMAT_NOT_SUPPORTED (DCAP_ERRORBIT | 0x0006)
#define ERROR_DCAP_BAD_FRAMERATE        (DCAP_ERRORBIT | 0x0007)
#define ERROR_DCAP_BAD_PARAM            (DCAP_ERRORBIT | 0x0008)
#define ERROR_DCAP_DIALOG_FORMAT        (DCAP_ERRORBIT | 0x0009)   // can't reset format changes caused by dialog
#define ERROR_DCAP_DIALOG_STREAM        (DCAP_ERRORBIT | 0x000A)   // can't re-establish stream after dialog

// Structures

#ifndef __DCAP_BUILD__
typedef HANDLE HCAPDEV;
typedef HANDLE HFRAMEBUF;
#endif

typedef struct _FINDCAPTUREDEVICE
{
    DWORD dwSize;
    int nDeviceIndex;
    char szDeviceName[MAX_CAPDEV_NAME];
    char szDeviceDescription[MAX_CAPDEV_DESCRIPTION];
    char szDeviceVersion[MAX_CAPDEV_VERSION];
} FINDCAPTUREDEVICE;

typedef struct _CAPSTREAM
{
    DWORD dwSize;
    int nFPSx100;
    int ncCapBuffers;
    HANDLE hevWait;
} CAPSTREAM;

typedef struct _CAPTUREPALETTE
{
    WORD wVersion;
    WORD wcEntries;
    PALETTEENTRY pe[256];
} CAPTUREPALETTE, FAR* LPCAPTUREPALETTE;

typedef struct _CAPFRAMEINFO
{
    LPSTR lpData;
    DWORD dwcbData;
    DWORD dwTimestamp;
    DWORD dwFlags;
} CAPFRAMEINFO;

// Prototypes

int DCAPI       GetNumCaptureDevices();
BOOL DCAPI      FindFirstCaptureDevice(IN OUT FINDCAPTUREDEVICE* lpfcd, char* szDeviceDescription);
BOOL DCAPI      FindFirstCaptureDeviceByIndex(IN OUT FINDCAPTUREDEVICE* lpfcd, int nDeviceIndex);
BOOL DCAPI      FindNextCaptureDevice(IN OUT FINDCAPTUREDEVICE* lpfcd);
HCAPDEV DCAPI   OpenCaptureDevice(int nDeviceIndex);
BOOL DCAPI      CloseCaptureDevice(HCAPDEV hcd);
DWORD DCAPI     GetCaptureDeviceFormatHeaderSize(HCAPDEV hcd);
BOOL DCAPI      GetCaptureDeviceFormat(HCAPDEV hcd, OUT LPBITMAPINFOHEADER lpbmih);
BOOL DCAPI      SetCaptureDeviceFormat(HCAPDEV hcd, IN LPBITMAPINFOHEADER lpbmih,
                                       IN LONG srcwidth, IN LONG srcheight);
BOOL DCAPI      GetCaptureDevicePalette(HCAPDEV hcd, OUT CAPTUREPALETTE* lpcp);
BOOL DCAPI      InitializeStreaming(HCAPDEV hcd, IN OUT CAPSTREAM* lpcs, IN DWORD flags);
BOOL DCAPI      SetStreamFrameRate(HCAPDEV hcd, IN int nFPSx100);
BOOL DCAPI      UninitializeStreaming(HCAPDEV hcd);
BOOL DCAPI      StartStreaming(HCAPDEV hcd);
BOOL DCAPI      StopStreaming(HCAPDEV hcd);
LPSTR DCAPI     GetNextReadyBuffer(HCAPDEV hcd, OUT CAPFRAMEINFO* lpcfi);
BOOL DCAPI      PutBufferIntoStream(HCAPDEV hcd, IN BYTE* lpBits);
BOOL DCAPI      CaptureDeviceDialog(HCAPDEV hcd, HWND hwndParent, DWORD dwFlags,
                                    IN LPBITMAPINFOHEADER lpbmih);
LPBYTE DCAPI    CaptureFrame(HCAPDEV hcd, IN HFRAMEBUF hbuf);
HFRAMEBUF DCAPI AllocFrameBuffer(HCAPDEV hcd);
VOID DCAPI      FreeFrameBuffer(HCAPDEV hcd, IN HFRAMEBUF hbuf);

LPBYTE DCAPI    GetFrameBufferPtr(HCAPDEV hcd, IN HFRAMEBUF hbuf);

DWORD DCAPI     DCAPGetThreadExecutionTimeService(HANDLE R0ThreadID );
HANDLE DCAPI     DCAPGetR0ThreadHandle(void);


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#pragma pack()          /* Revert to default packing */

#endif // #ifndef _DCAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\evtlog.h ===
#ifndef __EVENTLOG_H__
#define __EVENTLOG_H__

#ifdef __cplusplus 
extern "C" {
#endif

void AddToMessageLog(WORD wType, WORD wCategory, DWORD dwEvtId, LPTSTR lpszMsg);

#ifdef __cplusplus
}
#endif

#endif __EVENTLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\endsesn.h ===
#ifndef _ENDSESN_H_
#define _ENDSESN_H_

#include <tchar.h>

static const TCHAR NM_ENDSESSION_MSG_NAME[] = _TEXT("NetMeeting_EndSession");
static const UINT g_cuEndSessionMsgTimeout = 0x7FFFFFFF; // milliseconds
static const UINT g_cuEndSessionAbort = 0xF0F0;

// used in conf.exe, defined in conf.cpp
extern UINT g_uEndSessionMsg;

#endif // _ENDSESN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\dllutil.h ===
// File: dllutil.h

#ifndef _DLLUTIL_H_
#define _DLLUTIL_H_

#include <shlwapi.h>  // for DLLVERSIONINFO

typedef struct tagApiFcn   // function pointer to API mapping
{
	PVOID * ppfn;
	LPSTR   szApiName;
} APIFCN;
typedef APIFCN * PAPIFCN;

#ifdef __cplusplus
extern "C"  
#endif
BOOL FCheckDllVersionVersion(LPCTSTR pszDll, DWORD dwMajor, DWORD dwMinor);

#ifdef __cplusplus
extern "C"  
#endif
HRESULT HrGetDllVersion(LPCTSTR lpszDllName, DLLVERSIONINFO * pDvi);

#ifdef __cplusplus
extern "C"  
#endif
HRESULT HrInitLpfn(APIFCN *pProcList, int cProcs, HINSTANCE* phLib, LPCTSTR pszDllName);

#ifdef __cplusplus
extern "C"  
#endif
HINSTANCE  NmLoadLibrary(LPCTSTR pszModule, BOOL bSystemDLL);

#endif /* _DLLUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\datguids.h ===
/*
 *  	File: datguids.h
 *
 *      Defines media type for T120 data for QOS purposes
 *
 *		Revision History:
 *
 *		11/22/96	clausgi created
 */

// {9442E580-4457-11d0-A787-00A0C91BBEE1}
DEFINE_GUID(MEDIA_TYPE_T120DATA,
0x9442e580, 0x4457, 0x11d0, 0xa7, 0x87, 0x0, 0xa0, 0xc9, 0x1b, 0xbe, 0xe1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\cstring.hpp ===
#ifndef _CSTRING_HPP_
#define _CSTRING_HPP_

#include <nmutil.h>

// These two header files contain definitions that used to be in this file.
// To allow source files which include this file to continue to work 
// unmodified, we include them here.
#include <strutil.h>
#include <custring.h>

#define REMAFXAPI
#define REMAFX_DATADEF
#define REMAFX_DATA
#define REMAFX_CDECL
#define REM_AFX_INLINE inline

// BUGBUG - How are these used?
#ifndef PUBLIC_CODE
#define PUBLIC_CODE
#define PUBLIC_DATA
#define PRIVATE_CODE             PUBLIC_CODE
#define PRIVATE_DATA             PUBLIC_DATA
#endif


struct CSTRINGData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CSTRING
{
public:
// Constructors
	CSTRING();
	CSTRING(const CSTRING& stringSrc);
	CSTRING(TCHAR ch, int nRepeat = 1);
	CSTRING(LPCSTR lpsz);
	CSTRING(LPCWSTR lpsz);
	CSTRING(LPCTSTR lpch, int nLength);
	CSTRING(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CSTRING& operator=(const CSTRING& stringSrc);
	const CSTRING& operator=(TCHAR ch);
#ifdef _UNICODE
	const CSTRING& operator=(char ch);
	const CSTRING& operator=(LPCSTR lpsz);
#else
	const CSTRING& operator=(LPCWSTR lpsz);
#endif
	const CSTRING& operator=(const unsigned char* psz);
	const CSTRING& operator=(LPCTSTR lpsz);

	// string concatenation
	const CSTRING& operator+=(const CSTRING& string);
	const CSTRING& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CSTRING& operator+=(char ch);
#endif
	const CSTRING& operator+=(LPCTSTR lpsz);

	friend CSTRING REMAFXAPI operator+(const CSTRING& string1,
			const CSTRING& string2);
	friend CSTRING REMAFXAPI operator+(const CSTRING& string, TCHAR ch);
	friend CSTRING REMAFXAPI operator+(TCHAR ch, const CSTRING& string);
#ifdef _UNICODE
	friend CSTRING REMAFXAPI operator+(const CSTRING& string, char ch);
	friend CSTRING REMAFXAPI operator+(char ch, const CSTRING& string);
#endif
	friend CSTRING REMAFXAPI operator+(const CSTRING& string, LPCTSTR lpsz);
	friend CSTRING REMAFXAPI operator+(LPCTSTR lpsz, const CSTRING& string);

	void Append (LPCTSTR lpszSrcData, int nSrcLen);

	// string comparison
	int Compare(LPCTSTR lpsz) const;		// straight character
	int CompareNoCase(LPCTSTR lpsz) const;	// ignore case
	BOOL FEqual (const CSTRING& s2) const;	// length-sensitive comparison
	int Collate(LPCTSTR lpsz) const;		// NLS aware

	// simple sub-string extraction
	CSTRING Mid(int nFirst, int nCount) const;
	CSTRING Mid(int nFirst) const;
	CSTRING Left(int nCount) const;
	CSTRING Right(int nCount) const;

	CSTRING SpanIncluding(LPCTSTR lpszCharSet) const;
	CSTRING SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr

	// simple formatting
	void REMAFX_CDECL Format(LPCTSTR lpszFormat, ...);
	void REMAFX_CDECL Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	void REMAFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
	void REMAFX_CDECL FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(HINSTANCE hInstance, UINT nID);	// load from string resource
													// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToUnicode();
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _AFX_NO_BSTR_SUPPORT
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CSTRING();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CSTRINGData* GetData() const;
	void Init();
	void AllocCopy(CSTRING& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CSTRINGData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// conversion helpers
int REMAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int REMAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern REMAFX_DATA TCHAR AFXChNil;
const CSTRING& REMAFXAPI AFXGetEmptyString();
#define AFXEmptyString AFXGetEmptyString()

// inlines
REM_AFX_INLINE CSTRINGData* CSTRING::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CSTRINGData*)m_pchData)-1; }
REM_AFX_INLINE void CSTRING::Init()
	{ m_pchData = AFXEmptyString.m_pchData; }
REM_AFX_INLINE CSTRING::CSTRING(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
REM_AFX_INLINE const CSTRING& CSTRING::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
REM_AFX_INLINE const CSTRING& CSTRING::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
REM_AFX_INLINE const CSTRING& CSTRING::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
REM_AFX_INLINE CSTRING REMAFXAPI operator+(const CSTRING& string, char ch)
	{ return string + (TCHAR)ch; }
REM_AFX_INLINE CSTRING REMAFXAPI operator+(char ch, const CSTRING& string)
	{ return (TCHAR)ch + string; }
#endif

REM_AFX_INLINE int CSTRING::GetLength() const
	{ return GetData()->nDataLength; }
REM_AFX_INLINE int CSTRING::GetAllocLength() const
	{ return GetData()->nAllocLength; }
REM_AFX_INLINE BOOL CSTRING::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
REM_AFX_INLINE CSTRING::operator LPCTSTR() const
	{ return m_pchData; }
REM_AFX_INLINE int PASCAL CSTRING::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }
REM_AFX_INLINE void CSTRING::Append (LPCTSTR lpszSrcData, int nSrcLen)
	{ ConcatInPlace(nSrcLen, lpszSrcData); }

REM_AFX_INLINE BOOL REMAFXAPI operator==(const CSTRING& s1, const CSTRING& s2)
	{ return s1.FEqual(s2); }
REM_AFX_INLINE BOOL REMAFXAPI operator==(const CSTRING& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
REM_AFX_INLINE BOOL REMAFXAPI operator==(LPCTSTR s1, const CSTRING& s2)
	{ return s2.Compare(s1) == 0; }
REM_AFX_INLINE BOOL REMAFXAPI operator!=(const CSTRING& s1, const CSTRING& s2)
	{ return s1.FEqual(s2) == FALSE; }
REM_AFX_INLINE BOOL REMAFXAPI operator!=(const CSTRING& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
REM_AFX_INLINE BOOL REMAFXAPI operator!=(LPCTSTR s1, const CSTRING& s2)
	{ return s2.Compare(s1) != 0; }

// Commented out for Unicode because Win95 doesn't support lstrcmpW
#ifndef UNICODE
REM_AFX_INLINE int CSTRING::Compare(LPCTSTR lpsz) const
	{ return lstrcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
#endif // UNICODE

#endif // ndef CSTRING_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\fnobjs.h ===
#ifndef __FnObjs_h__
#define __FnObjs_h__


class IsEqLPTSTR
{
private:

	LPCTSTR m_pcsz;

public:
	IsEqLPTSTR( LPCTSTR pcsz ) : m_pcsz( pcsz ) { ; }
    bool operator() ( LPCTSTR pcsz ) 
	{
		return ( 0 == lstrcmp( pcsz, m_pcsz ) );
    }

};


template< class T > 
class IsEq
{

	const T& m_rT;
public:
	IsEq( const T& rT ) : m_rT( rT ) { ; }

    bool operator() ( const T& rT ) 
	{
		return rT == m_rT;
    }
};


#endif // __FnObjs_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\fsmenu.h ===
#ifndef _FSMENU_H
#define _FSMENU_H
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

typedef enum
{
	FMF_NONE	 	= 0x0000,
	FMF_NOEMPTYITEM		= 0x0001,
        FMF_INCLUDEFOLDERS      = 0x0002,
        FMF_NOPROGRAMS      	= 0x0004,
        FMF_FILESMASK      	= 0x0007,
        FMF_LARGEICONS      	= 0x0008,
        FMF_NOBREAK      	= 0x0010,
        FMF_NOABORT      	= 0x0020,
} FMFLAGS;

#define FMAI_SEPARATOR		0x00000001

typedef void (CALLBACK *PFNFMCALLBACK)(LPITEMIDLIST, LPITEMIDLIST);

WINSHELLAPI UINT 	WINAPI FileMenu_ReplaceUsingPidl(HMENU hmenu, UINT idNewItems,  LPITEMIDLIST pidl, UINT fMenuFilter, PFNFMCALLBACK pfncb);
WINSHELLAPI BOOL 	WINAPI FileMenu_InitMenuPopup(HMENU hmenu);
WINSHELLAPI LRESULT WINAPI FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT FAR *lpdi);
WINSHELLAPI LRESULT WINAPI FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR *lpmi);
WINSHELLAPI UINT 	WINAPI FileMenu_DeleteAllItems(HMENU hmenu);
WINSHELLAPI LRESULT WINAPI FileMenu_HandleMenuChar(HMENU hmenu, char ch);
WINSHELLAPI BOOL 	WINAPI FileMenu_GetLastSelectedItemPidls(HMENU hmenu, LPITEMIDLIST *ppidlFolder, LPITEMIDLIST *ppidlItem);
WINSHELLAPI HMENU 	WINAPI FileMenu_FindSubMenuByPidl(HMENU hmenu, LPITEMIDLIST pidl);
WINSHELLAPI UINT 	WINAPI FileMenu_InsertUsingPidl(HMENU hmenu, UINT idNewItems,  LPITEMIDLIST pidl, FMFLAGS fmf, UINT fMenuFilter, PFNFMCALLBACK pfncb);
WINSHELLAPI void 	WINAPI FileMenu_Invalidate(HMENU hmenu);
WINSHELLAPI HMENU   WINAPI FileMenu_Create(COLORREF clr, int cxBmpGap, HBITMAP hbmp, int cySel, FMFLAGS fmf);
WINSHELLAPI BOOL    WINAPI FileMenu_AppendItem(HMENU hmenu, LPSTR psz, UINT id, int iImage, HMENU hmenuSub, UINT cyItem);
WINSHELLAPI BOOL    WINAPI FileMenu_TrackPopupMenuEx(HMENU hmenu, UINT Flags, int x, int y, HWND hwndOwner, LPTPMPARAMS lpTpm);
WINSHELLAPI BOOL 	WINAPI FileMenu_DeleteItemByCmd(HMENU hmenu, UINT id);
WINSHELLAPI void 	WINAPI FileMenu_Destroy(HMENU hmenu);
WINSHELLAPI BOOL 	WINAPI FileMenu_EnableItemByCmd(HMENU hmenu, UINT id, BOOL fEnable);
WINSHELLAPI BOOL 	WINAPI FileMenu_DeleteSeparator(HMENU hmenu);
WINSHELLAPI BOOL 	WINAPI FileMenu_DeleteMenuItemByFirstID(HMENU hmenu, UINT id);
WINSHELLAPI DWORD 	WINAPI FileMenu_GetItemExtent(HMENU hmenu, UINT iItem);
WINSHELLAPI BOOL 	WINAPI FileMenu_DeleteItemByIndex(HMENU hmenu, UINT iItem);
WINSHELLAPI void 	WINAPI FileMenu_AbortInitMenu(void);

#endif //_FSMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\debspew.h ===
/*
 * debspew.h - Debug macros and their retail translations.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _DEBSPEW_H_
#define _DEBSPEW_H_
#include <nmutil.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <tchar.h>
#include <limits.h>
#include <shlobj.h>

#include "stock.h"
#include "olestock.h"

#ifdef DEBUG
#include "inifile.h"
#include "resstr.h"
#endif /* DEBUG */

#include "valid.h"
#include "olevalid.h"


#define DATA_SEG_READ_ONLY       ".text"
#define DATA_SEG_PER_INSTANCE    ".data"
#define DATA_SEG_SHARED          ".shared"


/* parameter validation macros */

/*
 * call as:
 *
 * bPTwinOK = IS_VALID_READ_PTR(ptwin, CTWIN);
 *
 * bHTwinOK = IS_VALID_HANDLE(htwin, TWIN);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (ERROR_OUT(("invalid %s read pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (ERROR_OUT(("invalid %s write pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTR_A(ptr, type) \
   (IsBadStringPtrA((ptr), (UINT)-1) ? \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTR_W(ptr, type) \
   (IsBadStringPtrW((ptr), (UINT)-1) ? \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#if defined(UNICODE)
#define IS_VALID_STRING_PTR IS_VALID_STRING_PTR_W
#else // defined(UNICODE)
#define IS_VALID_STRING_PTR IS_VALID_STRING_PTR_A
#endif // defined(UNICODE)


#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (ERROR_OUT(("invalid %s code pointer - %#08lx", (PCSTR)#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (IsBadReadPtr((ptr), len) ? \
    (ERROR_OUT(("invalid %s read pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (IsBadWritePtr((ptr), len) ? \
    (ERROR_OUT(("invalid %s write pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (ERROR_OUT(("invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags))))), FALSE) : \
    TRUE)

#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTR(ptr, type) \
   (! IsBadStringPtr((ptr), (UINT)-1))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (! IsBadReadPtr((ptr), len))

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (! IsBadWritePtr((ptr), len))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#endif

/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (ERROR_OUT(("invalid H" #type " - %#08lx", (hnd))), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, C##iface)



#ifdef DEBUG

#define CALLTRACE_OUT(s) DbgZPrintFunction s

#define DebugEntry(szFunctionName) \
   (CALLTRACE_OUT((#szFunctionName "() entered.")), \
    StackEnter())

#define DebugExit(szFunctionName, szResult) \
   (StackLeave(), \
    CALLTRACE_OUT(("%s() exiting, returning %s.", #szFunctionName, szResult)))

#define DebugExitBOOL(szFunctionName, bool) \
   DebugExit(szFunctionName, GetBOOLString(bool))

#define DebugExitCOMPARISONRESULT(szFunctionName, cr) \
   DebugExit(szFunctionName, GetCOMPARISONRESULTString(cr))

#define DebugExitDWORD(szFunctionName, dw) \
   DebugExitULONG(szFunctionName, dw)

#define DebugExitHRESULT(szFunctionName, hr) \
   DebugExit(szFunctionName, GetHRESULTString(hr))

#define DebugExitINT(szFunctionName, n) \
   DebugExit(szFunctionName, GetINTString(n))

#define DebugExitINT_PTR(szFunctionName, n) \
   DebugExit(szFunctionName, GetINT_PTRString(n))

#define DebugExitULONG(szFunctionName, ul) \
   DebugExit(szFunctionName, GetULONGString(ul))

#define DebugExitVOID(szFunctionName) \
   (StackLeave(), \
    CALLTRACE_OUT(("%s() exiting.", #szFunctionName)))

#define DebugExitPVOID(szFunctionName, ptr) \
   DebugExit(szFunctionName, GetPVOIDString(ptr))

#else

#define DebugEntry(szFunctionName)
#define DebugExit(szFunctionName, szResult)
#define DebugExitBOOL(szFunctionName, bool)
#define DebugExitCOMPARISONRESULT(szFunctionName, cr)
#define DebugExitDWORD(szFunctionName, dw)
#define DebugExitHRESULT(szFunctionName, hr)
#define DebugExitINT(szFunctionName, n)
#define DebugExitINT_PTR(szFunctionName, n)
#define DebugExitULONG(szFunctionName, ul)
#define DebugExitVOID(szFunctionName)
#define DebugExitPVOID(szFunctionName, ptr)

#endif


/* Types
 ********/

/* g_dwSpewFlags flags */

typedef enum _spewflags
{
   SPEW_FL_SPEW_PREFIX        = 0x0001,

   SPEW_FL_SPEW_LOCATION      = 0x0002,

   ALL_SPEW_FLAGS             = (SPEW_FL_SPEW_PREFIX |
                                 SPEW_FL_SPEW_LOCATION)
}
SPEWFLAGS;

/* g_uSpewSev values */

typedef enum _spewsev
{
   SPEW_TRACE,

   SPEW_CALLTRACE,

   SPEW_WARNING,

   SPEW_ERROR,

   SPEW_FATAL
}
SPEWSEV;


/* Prototypes
 *************/

/* debspew.c */

#ifdef DEBUG

extern BOOL             SetDebugModuleIniSwitches(void);
extern BOOL  NMINTERNAL InitDebugModule(PCSTR);
extern void  NMINTERNAL ExitDebugModule(void);
extern void  NMINTERNAL StackEnter(void);
extern void  NMINTERNAL StackLeave(void);
extern ULONG_PTR NMINTERNAL GetStackDepth(void);
extern void             SpewOut(PCSTR pcszFormat, ...);
extern DWORD NMINTERNAL GetDebugOutputFlags(VOID);
extern VOID  NMINTERNAL SetDebugOutputFlags(DWORD dw);

#else // DEBUG

#define SetDebugModuleIniSwitches()
#define InitDebugModule(str)
#define ExitDebugModule()
#define StackEnter()
#define StackLeave()
#define GetStackDepth()
//#define SpewOut(fmt, ...)
#define GetDebugOutputFlags()
#define SetDebugOutputFlags(dw)

#endif // DEBUG


/* Global Variables
 *******************/

#ifdef DEBUG

/* dbg.cpp */
extern HDBGZONE ghDbgZone;

/* debspew.c */

extern DWORD g_dwSpewFlags;
extern UINT g_uSpewSev;
extern UINT g_uSpewLine;
extern PCSTR g_pcszSpewFile;
extern WINDOWPLACEMENT g_wpSpew;

/* defined by client */

extern PCSTR g_pcszSpewModule;

#endif



/*
 * EVAL() may only be used as a logical expression.
 *
 * E.g.,
 *
 * if (EVAL(exp))
 *    bResult = TRUE;
 */

#ifdef DEBUG

#define EVAL(exp) \
   ((exp) || \
    (ERROR_OUT(("evaluation failed '%s'", (PCSTR)#exp)), 0))

#else

#define EVAL(exp) \
   ((exp) != 0)

#endif   /* DEBUG */


#ifdef __cplusplus
}
#endif /* __cplusplus */



#endif /* _DEBSPEW_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\gencontainers.h ===
// File: GenContainers.h

#ifndef _GENCONTAINERS_H_
#define _GENCONTAINERS_H_

#include "GenWindow.h"

// A bordered window class. A BorderWindow will layout its children on the 8
// points of the compas plus the center. The creator should set the m_uParts
// member to a bitmask of flags saying which parts are actually used. Then the
// children will be layed out in those parts, in the order of the Parts enum
class // DECLSPEC_UUID("")
CBorderWindow : public CGenWindow
{
public:
	// Which parts of the border window are filled with children. The order of
	// the children in the window is the same as the order of these contants
	enum Parts
	{
		TopLeft     = 0x0001,
		Top         = 0x0002,
		TopRight    = 0x0004,
		Left        = 0x0008,
		Center      = 0x0010,
		Right       = 0x0020,
		BottomLeft  = 0x0040,
		Bottom      = 0x0080,
		BottomRight = 0x0100,
	} ;
	enum { NumParts = 9 } ;

	// BUGBUG georgep: We should probably use setters and getters for all of
	// these, so we can force a relayout

	// The horizontal gap between components
	int m_hGap;
	// The vertical gap between components
	int m_vGap;

	// One of the Alignment enum
	UINT m_uParts : 9;

	// Default constructor; inits a few intrinsics
	CBorderWindow();

	// Create the window
	BOOL Create(
		HWND hWndParent	// The parent of the toolbar window
		);

#if FALSE
	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CBorderWindow) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CGenWindow::QueryInterface(riid, ppv));
	}
#endif // FALSE

	virtual void GetDesiredSize(SIZE *ppt);

	virtual void Layout();

protected:
	virtual ~CBorderWindow() {}

	// Forward WM_COMMAND messages to the parent window
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	virtual void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
	UINT CBorderWindow::GetDesiredSize(
		HWND hwnds[CBorderWindow::NumParts],
		SIZE sizes[CBorderWindow::NumParts],
		int rows[3],
		int cols[3],
		SIZE *psize);
} ;

// A toolbar window class. A toolbar window will layout its children generally
// from left-to-right or top-to-bottom, with margins around and gaps between
// children, filling the window if specified. See the definitions for the
// public fields.
class DECLSPEC_UUID("{0BFB8454-ACA4-11d2-9C97-00C04FB17782}")
CToolbar : public CGenWindow
{
public:
	// Where to align the children in the direction perpendicular to the flow:
	// in a horizontal toolbar, TopLeft will mean Top,and BottomRight will
	// mean Bottom
	enum Alignment
	{
		TopLeft = 0,
		Center,
		BottomRight,
		Fill,
	} ;

	// BUGBUG georgep: We should probably use setters and getters for all of
	// these, so we can force a relayout

	// The maximum gap between components
	int m_gap;
	// The left and right margin
	int m_hMargin;
	// The top and bottom margin
	int m_vMargin;
	// Start index of right-aligned children; they will still get layed out
	// left to right
	UINT m_uRightIndex;

	// One of the Alignment enum
	// HACKHACK georgep: I need to use an extra bit, or C++ gets confused by
	// the top bit (thinks it's signed)
	Alignment m_nAlignment : 3;
	// Vertical layout if TRUE
	BOOL m_bVertical : 1;
	// If TRUE, the child before m_uRightIndex will fill the center are of the
	// toolbar
	BOOL m_bHasCenterChild : 1;
	// HACKHACK georgep: Layout in reverse order if TRUE; this lets me fix
	// weird tabbing order problems
	BOOL m_bReverseOrder : 1;
	// Set this if you don't want the gaps calculated in the desired size
	BOOL m_bMinDesiredSize : 1;

	// Default constructor; inits a few intrinsics
	CToolbar();

	// Create the toolbar window
	BOOL Create(
		HWND hWndParent,	// The parent of the toolbar window
		DWORD dwExStyle=0	// The extended style of the toolbar window
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CToolbar) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CGenWindow::QueryInterface(riid, ppv));
	}

	IGenWindow* FindControl(int nID);

	virtual void GetDesiredSize(SIZE *ppt);

	virtual void Layout();

protected:
	virtual ~CToolbar() {}

	// Forward WM_COMMAND messages to the parent window
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	virtual void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
	void AdjustPos(POINT *pPos, SIZE *pSize, UINT width);

	// Get the first child to layout
	HWND GetFirstKid();
	// Get the next child to layout
	HWND GetNextKid(
		HWND hwndCurrent	// The current child
		);
} ;

// Just makes the first child fill the client area
class CFillWindow : public CGenWindow
{
public:
	// Just makes the first child fill the client area
	virtual void Layout();

	virtual void GetDesiredSize(SIZE *psize);

	// Get the info necessary for displaying a tooltip
	virtual void GetSharedTooltipInfo(TOOLINFO *pti);

protected:
	HWND GetChild() { return(GetTopWindow(GetWindow())); }
} ;


// Maybe someday I will add a label for this, and multiple border types
class CEdgedWindow : public CGenWindow
{
private:
	enum { s_nBorder = 2 };
	int GetBorderWidth() { return(s_nBorder); }

public:
	// BUGBUG georgep: We should probably use setters and getters for all of
	// these, so we can force a relayout

	// The left and right margin
	int m_hMargin;
	// The top and bottom margin
	int m_vMargin;

	CEdgedWindow();
	~CEdgedWindow();

	BOOL Create(HWND hwndParent);

	// Just makes the first child fill the client area - the border
	virtual void Layout();

	virtual void GetDesiredSize(SIZE *psize);

	void SetHeader(CGenWindow *pHeader);
	CGenWindow *GetHeader() { return(m_pHeader); }

private:
	CGenWindow *m_pHeader;

	// Get the content window
	HWND GetContentWindow();

	void OnPaint(HWND hwnd);

protected:
	LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
} ;

class CLayeredView : public CGenWindow
{
public:
	enum LayoutStyle
	{
		Center = 0,
		Fill,
		NumStyles
	} ;

	// I should make accessor methods for this
	// The layout style for the window
	LayoutStyle m_lStyle;

	CLayeredView() : m_lStyle(Center) {}

	BOOL Create(
		HWND hwndParent,	// The parent of this window
		DWORD dwExStyle=WS_EX_CONTROLPARENT	// The extended style
		);

	virtual void GetDesiredSize(SIZE *psize);

	virtual void Layout();
} ;

class DECLSPEC_UUID("{5D573806-CD09-11d2-9CA9-00C04FB17782}")
CFrame : public CFillWindow
{
public:
	BOOL Create(
		HWND hWndOwner,			// Window owner
		LPCTSTR szWindowName,	// Window name
		DWORD dwStyle,			// Window style
		DWORD dwEXStyle,		// Extended window style
		int x,					// Window pos: x
		int y,					// Window pos: y
		int nWidth,				// Window size: width
		int nHeight,			// Window size: height
		HINSTANCE hInst,		// The hInstance to create the window on
		HICON hIcon=NULL,		// The icon for the window
		HMENU hmMain=NULL,		// Window menu
		LPCTSTR szClassName=NULL	// The class name to use
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CFrame) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CFillWindow::QueryInterface(riid, ppv));
	}

	virtual void OnDesiredSizeChanged();

	BOOL SetForeground();

	// Update the size immediately
	void Resize();

	void MoveEnsureVisible(int x, int y);

protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
	// Handle messages
	void OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange);
	BOOL OnQueryNewPalette(HWND hwnd);

	// Delayed resizing when the desired size changes
	static void Resize(CGenWindow *pThis, WPARAM wParam);

	// Select and realize the proper palette
	BOOL SelAndRealizePalette(BOOL bBackground);
} ;

#endif // _GENCONTAINERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\gencontrols.h ===
// File: EditText.h

#ifndef _EDITTEXT_H_
#define _EDITTEXT_H_

#include "GenWindow.h"

#include "GenContainers.h"

class CEditText;

interface IEditTextChange : IUnknown
{
	virtual void OnTextChange(CEditText *pEdit) = 0;
	virtual void OnFocusChange(CEditText *pEdit, BOOL bSet) = 0;
} ;

// An edit control class that supports using different foreground and
// background colors
class DECLSPEC_UUID("{FD827E00-ACA3-11d2-9C97-00C04FB17782}")
CEditText : public CFillWindow
{
public:
	// Default constructor; inits a few intrinsics
	CEditText();

	// Creates the edit control
	BOOL Create(
		HWND hWndParent,				// Parent of the edit control
		DWORD dwStyle=0,				// Edit control style
		DWORD dwExStyle=0,				// Extended window style
		LPCTSTR szTitle=TEXT(""),		// Initial text for the edit control
		IEditTextChange *pNotify=NULL	// Object to notify of changes
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CEditText) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CFillWindow::QueryInterface(riid, ppv));
	}

	void GetDesiredSize(SIZE *ppt);

	// Sets the foreground and background colors and brush to use for painting
	// Set the brush to NULL to indicate using default colors
	void SetColors(HBRUSH hbrBack, COLORREF back, COLORREF fore);

	// Sets the font to use in the edit control
	void SetFont(HFONT hf);

	// Sets the text for the control
	void SetText(
		LPCTSTR szText	// The text to set
		);

	// Gets the text for the control; returns the total text length
	int GetText(
		LPTSTR szText,	// Where to put the text
		int nLen		// The length of the buffer
		);

protected:
	virtual ~CEditText();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	// The actual edit control
	HWND m_edit;
	// The background brush
	HBRUSH m_hbrBack;
	// The background color
	COLORREF m_crBack;
	// The foreground color
	COLORREF m_crFore;
	// The font to use
	HFONT m_hfText;
	// The object ot notify of changes
	IEditTextChange *m_pNotify;

	// I may turn this into a GetWindow call later
	inline HWND GetEdit()
	{
		return(m_edit);
	}

	// Needed to change the edit control colors
	HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type);

	// Notification of events on the edit control
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

	// To clean stuff up
	void OnNCDestroy(HWND hwnd);
} ;

class CButton;

interface IButtonChange : IUnknown
{
	virtual void OnClick(CButton *pButton) = 0;
} ;

class DECLSPEC_UUID("{C3AEA4CA-CAB3-11d2-9CA7-00C04FB17782}")
CButton : public CFillWindow
{
public:
	CButton();
	~CButton();

	BOOL Create(
		HWND hWndParent,	// The parent window
		INT_PTR nId,			// The ID of the button for WM_COMMAND messages
		LPCTSTR szTitle,	// The string to display
		DWORD dwStyle=BS_PUSHBUTTON,	// The Win32 button style
		IButtonChange *pNotify=NULL		// Click notifications
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CButton) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CFillWindow::QueryInterface(riid, ppv));
	}

	// Get/set the icon displayed with this button
	void SetIcon(
		HICON hIcon	// The icon to use for this button
		);
	HICON GetIcon();
	// Get/set the bitmap displayed with this button
	void SetBitmap(
		HBITMAP hBitmap	// The bitmap to use for this button
		);
	HBITMAP GetBitmap();

	// Get/set the checked state of the button
	void SetChecked(
		BOOL bCheck	// TRUE if the button should be checked
		);
	BOOL IsChecked();

	virtual void GetDesiredSize(SIZE *psize);

protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	// Notify handler for clicks
	IButtonChange *m_pNotify;
	// Store away the icon size to avoid creating many bitmaps
	SIZE m_sizeIcon;

	// Change the HWND and forward to the parent
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
} ;

// A button class that uses bitmaps for its different states. Currently only
// pressed and normal are supported
class DECLSPEC_UUID("{E1813EDA-ACA3-11d2-9C97-00C04FB17782}")
CBitmapButton : public CButton
{
public:
	// The order of the bitmaps for the states of the button
	enum StateBitmaps
	{
		Normal = 0,
		Pressed,
		Hot,
		Disabled,
		NumStates
	} ;

	// Default constructor; inits a few intrinsics
	CBitmapButton();

	// Creates the button, using the bitmaps specified
	BOOL Create(
		HWND hWndParent,	// The parent of the button
		int nId,			// The ID for WM_COMMAND messages
		HBITMAP hbStates,	// The 2D array of bitmaps for the states of the button,
							// vertically in the order specified in the StateBitmaps enum
							// and horizontally in the custom states order
		UINT nInputStates=NumStates,	// The number of input states (Normal, Pressed, Hot, Disabled)
		UINT nCustomStates=1,			// The number of custom states
		IButtonChange *pNotify=NULL	// The click handler
		);

	// Creates the button, using the bitmaps specified
	BOOL Create(
		HWND hWndParent,	// The parent of the button
		int nId,			// The ID for WM_COMMAND messages
		HINSTANCE hInst,	// The instance to load the bitmap from
		int nIdBitmap,		// The ID of the bitmap to use
		BOOL bTranslateColors=TRUE,		// Use system background colors
		UINT nInputStates=NumStates,	// The number of input states (Normal, Pressed, Hot, Disabled)
		UINT nCustomStates=1,			// The number of custom states
		IButtonChange *pNotify=NULL	// The click handler
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CBitmapButton) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CButton::QueryInterface(riid, ppv));
	}

	void GetDesiredSize(SIZE *ppt);

	// Change the current custom state
	void SetCustomState(UINT nCustomState);

	// Return the current custom state
	UINT GetCustomState() const { return(m_nCustomState); }

	// Change to flashing mode
	void SetFlashing(int nSeconds);

	// Is in flashing mode
	UINT IsFlashing() const { return(NoFlash != m_nFlashState); }

	static void GetBitmapSizes(HBITMAP parts[], SIZE sizes[], int nParts);

	static void LoadBitmaps(
		HINSTANCE hInst,	// The instance to load the bitmap from
		const int ids[],	// Array of bitmap ID's
		HBITMAP bms[],		// Array of HBITMAP's for storing the result
		int nBmps,			// Number of entries in the arrays
		BOOL bTranslateColors=TRUE // Use system background colors
		);

protected:
	virtual ~CBitmapButton();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	virtual void SetHot(BOOL bHot);

	virtual BOOL IsHot() { return(m_bHot != FALSE); }

	void SchedulePaint()
	{
		InvalidateRect(GetChild(), NULL, FALSE);
	}

private:
	enum FlashState
	{
		NoFlash = 0,
		ForceHot,
		ForceNormal,
	} ;

	// The number of custom states
	UINT m_nCustomStates;
	// The current custom state
	UINT m_nCustomState;
	// The bitmaps for the states of the button, in the order specified in the
	// StateBitmaps enum.
	HBITMAP m_hbStates;
	// The time to stop flashing
	DWORD m_endFlashing;
	// The number of input states; one of StateBitmaps enum
	// HACKHACK georgep: Need to change the number of bits if more states
	UINT m_nInputStates : 4;
	// The Hot flag
	BOOL m_bHot : 1;
	// The current flash state; one of FlashState enum
	// HACKHACK georgep: Need an extra bit since C++ thinks this is signed
	FlashState m_nFlashState : 3;

	// Specialized drawing
	void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem);
	// Change the HWND and forward to the parent
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
	// Set the Hot control
	BOOL OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg);
	// Handles the flashing button
	void OnTimer(HWND hwnd, UINT id);
} ;

class CComboBox;

interface IComboBoxChange : IUnknown
{
	virtual void OnTextChange(CComboBox *pCombo) = 0;
	virtual void OnFocusChange(CComboBox *pCombo, BOOL bSet) = 0;
	virtual void OnSelectionChange(CComboBox *pCombo) = 0;
} ;

// An edit control class that supports using different foreground and
// background colors
class DECLSPEC_UUID("{B4B10DBA-B22F-11d2-9C98-00C04FB17782}")
CComboBox : public CFillWindow
{
public:
	// Default constructor; inits a few intrinsics
	CComboBox();

	operator HWND (void){ return( m_combo ); }

	// Creates the edit control
	BOOL Create(
		HWND hWndParent,				// Parent of the edit control
		UINT height,					// The height of the combo (with drop-down)
		DWORD dwStyle=0,				// Edit control style
		LPCTSTR szTitle=TEXT(""),		// Initial text for the edit control
		IComboBoxChange *pNotify=NULL	// Object to notify of changes
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CComboBox) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CFillWindow::QueryInterface(riid, ppv));
	}

	void GetDesiredSize(SIZE *ppt);

	// Sets the foreground and background colors and brush to use for painting
	// Set the brush to NULL to indicate using default colors
	void SetColors(HBRUSH hbrBack, COLORREF back, COLORREF fore);

	// Sets the font to use in the edit control
	void SetFont(HFONT hf);

	// Sets the text for the control
	void SetText(
		LPCTSTR szText	// The text to set
		);

	// Gets the text for the control; returns the total text length
	int GetText(
		LPTSTR szText,	// Where to put the text
		int nLen		// The length of the buffer
		);

	// Returns the number of items in the list
	int GetNumItems();

	// Returns the index of the currently selected item
	int GetSelectedIndex();

	// Sets the index of the currently selected item
	void SetSelectedIndex(int index);

	// Adds text to the list; returns the index of the added string
	int AddText(
		LPCTSTR pszText,	// The string to add
		LPARAM lUserData=0	// User data to associate with the string
		);

	// Gets the text for the list item; returns the total text length
	// The string is emptied if there is not enough room for the text
	int GetText(
		UINT index,		// The index of the string to get
		LPTSTR pszText,	// The string buffer to fill
		int nLen		// User data to associate with the string
		);

	// Gets the user data for the list item
	LPARAM GetUserData(
		int index	// The index of the user data to get
		);

	// Removes an item from the list
	void RemoveItem(
		UINT index	// The index of the item to remove
		);

	virtual void Layout();

protected:
	virtual ~CComboBox();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	// Get the info necessary for displaying a tooltip
	virtual void GetSharedTooltipInfo(TOOLINFO *pti);

private:
	// The actual ComboBox control
	HWND m_combo;
	// The background brush
	HBRUSH m_hbrBack;
	// The background color
	COLORREF m_crBack;
	// The foreground color
	COLORREF m_crFore;
	// The font to use
	HFONT m_hfText;
	// The object ot notify of changes
	IComboBoxChange *m_pNotify;

	// I may turn this into a GetWindow call later
	inline HWND GetComboBox()
	{
		return(m_combo);
	}

	// I may turn this into a GetWindow call later
	inline HWND GetEdit()
	{
		// return(reinterpret_cast<HWND>(SendMessage(GetCombo(), CBEM_GETEDITCONTROL, 0, 0));
		return(GetComboBox());
	}

	// Needed to change the edit control colors
	HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type);

	// Notification of events on the edit control
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

	// To clean stuff up
	void OnNCDestroy(HWND hwnd);
} ;

class CSeparator : public CGenWindow
{
public:	
	
	// The Separator style
	enum Styles
	{
		Normal = 0,
		Blank,
		NumStates
	} ;

	CSeparator();

	BOOL Create(
		HWND hwndParent, UINT  iStyle = Normal
		);

	virtual void GetDesiredSize(SIZE *ppt);

	void SetDesiredSize(SIZE *psize);

	// Put the single child in the middle
	virtual void Layout();

private:
	// The desired size for the control; defaults to (2,2)
	SIZE m_desSize;
	UINT m_iStyle : 4;

	inline void OnPaint(HWND hwnd);

protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
} ;

#endif // _EDITTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\html.h ===
/*
 *  html.h
 *
 *      Constants and Macros for html file generation and parsing
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *					Sunita				Created/defined macros to write and parse html
 */

#ifndef _HTML_H
#define _HTML_H

//include for common token defns 
#include "nameres.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

//html file manipulation macros
#define HTMLTOKENBEGINCHAR		TOKENBEGINCHAR
#define HTMLTOKENENDCHAR		TOKENENDCHAR
#define HTMLHEADERSTARTSTR		HEADSTARTSTR
#define HTMLHEADERENDSTR		HEADENDSTR
#define HTMLSIGNSTARTSTR		"HTML"
#define HTMLSIGNENDSTR			"/HTML"
#define HTMLBODYSTARTSTR		"BODY"
#define HTMLBODYENDSTR			"/BODY"
#define HTMLAHREFSTARTSTR		"A HREF = "
#define HTMLAHREFENDSTR			"/A"
#define HTMLTITLESTARTSTR		"TITLE"
#define HTMLTITLEENDSTR			"/TITLE"
#define HTMLCONTENTTYPESTR		"Content-Type: text/html\r\n\n\n"

//token types in the ipa file format
#define HTMLTOKEN_INVALID		0
#define HTMLTOKEN_UNKNOWN		1
#define	HTMLTOKEN_SIGNSTART		2
#define HTMLTOKEN_SIGNEND		3
#define HTMLTOKEN_HEADSTART		4
#define HTMLTOKEN_HEADEND		5
#define HTMLTOKEN_BODYSTART		6
#define HTMLTOKEN_BODYEND		7
#define HTMLTOKEN_AHREFSTART	8
#define HTMLTOKEN_AHREFEND		9
#define HTMLTOKEN_TITLESTART	10
#define HTMLTOKEN_TITLEEND		11

//write macros
//note all macros taken LPSTR - it is the responsibility of the calling
//code to do any appropriate string conversions.
#define WRITEHTMLSIGNATURESTART(lpBuf)									\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLSIGNSTARTSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLSIGNATUREEND(lpBuf)									\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLSIGNENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLHEADERSTART(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLHEADERSTARTSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLHEADEREND(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLHEADERENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLTITLESTART(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLTITLESTARTSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLTITLE(lpBuf,lpszTitle)									\
	wsprintf((LPSTR)(lpBuf), "%s\r\n", lpszTitle)

#define WRITEHTMLTITLEEND(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLTITLEENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLBODYSTART(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLBODYSTARTSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLBODYEND(lpBuf)											\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLBODYENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLSIGNATURE(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLSIGNATURESTR,HTMLTOKENENDCHAR)

#define WRITEHTMLREF(lpBuf,lpszUrl,lpszDisplayName)						\
	wsprintf((LPSTR)(lpBuf), "%c%s\"%s\"%c%s%c%s%c\r\n", 				\
		HTMLTOKENBEGINCHAR,(LPSTR)HTMLAHREFSTARTSTR,					\
		(LPSTR)lpszUrl,HTMLTOKENENDCHAR,								\
		(LPSTR)lpszDisplayName,HTMLTOKENBEGINCHAR,						\
		(LPSTR)HTMLAHREFENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLREFCRLF(lpBuf,lpszUrl,lpszDisplayName)					\
	wsprintf((LPSTR)(lpBuf), "%c%s\"%s\"%c%s%c%s%c<BR>\r\n", 			\
		HTMLTOKENBEGINCHAR,(LPSTR)HTMLAHREFSTARTSTR,					\
		(LPSTR)lpszUrl,HTMLTOKENENDCHAR,								\
		(LPSTR)lpszDisplayName,HTMLTOKENBEGINCHAR,						\
		(LPSTR)HTMLAHREFENDSTR,HTMLTOKENENDCHAR)

//token identification macros
#define ISBUFOURHTMLTOKEN(lpBuf,dwBufSize,lpszToken)					\
	((strlen((LPSTR)lpszToken) == dwBufSize) ?							\
		!(memcmp((LPBYTE)lpBuf,(LPBYTE)lpszToken,dwBufSize)) : 0 )

#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif	//#ifndef _HTML_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\help_ids.h ===
/*
	Microsoft Corp. (C) Copyright 1995-1996
	Developed under contract by Numbers & Co.
----------------------------------------------------------------------------

		name:	Oprah Context Help Ids
	
		file:	help_ids.h

	comments:	This header contains all of the current Oprah context 
				help ids in #define form. These are intended to be used in 
				a DWORD array to associate them with Oprah internal 
				controls. Each Oprah component can make an array using just 
				the subset of these ids that it needs. The id values are 
				arbitrary except that I tried to allow a range of 20 for each 
				logical area (also arbitrary).

				For dialog boxes, the array is handed to WinHelp as shown in 
				the example below.
				------------------------

The following example shows how to implement context-sensitive help in a dialog box.
  
LRESULT CALLBACK EditDlgProc(HWND hwndDlg, UINT uMsg, WPARAM	wParam, 
	LPARAM lParam) 
{ 
 
// Create an array of control identifiers and context identifiers. 
 
static DWORD aIds[] = { 
	ID_SAVE,   IDH_SAVE, 
	ID_DELETE, IDH_DELETE, 
	ID_COPY,   IDH_COPY, 
	ID_PASTE,  IDH_PASTE, 
	0,0 
}; 
 
switch (uMsg) { 
	case WM_HELP: 
		WinHelp(((LPHELPINFO) lParam)->hItemHandle, "helpfile.hlp", 
			HELP_WM_HELP, (DWORD) (LPSTR) aIds); 
		break; 
 
	case WM_CONTEXTMENU: 
		WinHelp((HWND) wParam, "helpfile.hlp", HELP_CONTEXTMENU, 
			(DWORD) (LPVOID) aIds); 
		break; 
	. 
	. // process other messages here 
	. 
	} 
 
return FALSE; 
 
} 


WM_HELP is generated by pressing F1. WM_CONTEXTMENU is generated by right clicking.


(This example is an except from:
	Win32 Programmer's Reference
		Overviews
			Window Management
				Help
					Using Help
						Providing Help in a Dialog Box
 )

----------------------------------------------------------------------------
	Microsoft Corp. (C) Copyright 1995-1996
	Developed under contract by Numbers & Co.
 */




/* For the options dialog (confcp.dll) */

// For the General tab
#define IDH_GENERAL_GENERAL 					26100
#define IDH_GENERAL_SHOW_ON_TASKBAR 			26000
#define IDH_GENERAL_FRIENDS_TAB 				26101
#define IDH_GENERAL_CHECK_DEFAULT				26102
#define IDH_GENERAL_SHOW_ICA_ON_TASKBAR 		26200

#define IDH_GENERAL_AUTO_ACCEPT 				26004

#define IDH_GENERAL_FT_GROUP					26103
#define IDH_GENERAL_FT_DIRECTORY				26009
#define IDH_GENERAL_FT_BROWSE					26010
#define IDH_GENERAL_FT_VIEWFILES				26104

// For the protocols tab
#define IDH_PROTOCOLS_LIST						26020
#define IDH_PROTOCOLS_PROPERTIES				26021
#define IDH_PROTOCOLS_DESCRIPTION				26022

// For the video tab
#define IDH_VIDEO_CAMERA						26105
#define IDH_VIDEO_CAPTURE                       26082
#define IDH_VIDEO_SOURCE						26074
#define IDH_VIDEO_FORMAT						26075
#define IDH_VIDEO_MIRROR						26083

#define IDH_VIDEO_SQCIF 						26076
#define IDH_VIDEO_QCIF							26077
#define IDH_VIDEO_CIF							26078

#define IDH_VIDEO_QUALITY						26079

#define IDH_VIDEO_SEND_RECEIVE					26106
#define IDH_VIDEO_AUTO_SEND 					26080
#define IDH_VIDEO_AUTO_RECEIVE					26081

// For the audio tab
#define IDH_AUDIO_GENERAL						26107
#define IDH_AUDIO_FULL_DUPLEX					26030
#define IDH_AUDIO_AUTO_GAIN 					26031
#define IDH_AUDIO_TUNING_WIZARD 				26032

#define IDH_AUDIO_SET_COMPRESSION				26033
#define IDH_AUDIO_CONNECTION_SPEED				26034
#define IDH_AUDIO_MANUAL_CODEC_SETTINGS 		26035
#define IDH_AUDIO_ADVANCED_CODEC_SETTINGS		26036

#define IDH_AUDIO_MIC_SENSITIVITY				26108
#define IDH_AUDIO_AUTO_SENSITIVITY				26037
#define IDH_AUDIO_MANUAL_SENSITIVITY			26038

#define IDH_AUDIO_GATEWAY						26109
#define IDH_AUDIO_USEGATEWAY					26039
#define IDH_AUDIO_H323_GATEWAY					26043
#define IDH_SERVERS_DIRECT_CALL					26048
#define IDH_SERVERS_USE_GATEKEEPER				26045
#define IDH_SERVERS_GATEKEEPER_NAME				26046
#define IDH_SERVERS_GATEKEEPER_PHONENO			26047
#define IDH_SERVERS_GATEKEEPER_EMAIL			26049


// For the My Information tab
#define IDH_MYINFO_MYINFO                       26110
#define IDH_MYINFO_FIRSTNAME					26111
#define IDH_MYINFO_LASTNAME 					26112
#define IDH_MYINFO_EMAIL						26113
#define IDH_MYINFO_LOCATION						26114
#define IDH_MYINFO_PHONENUM						26115
#define IDH_MYINFO_COMMENTS 					26116

#define IDH_MYINFO_CATEGORIZE_GROUP				26300
#define IDH_MYINFO_PERSONAL_RADIO				26301
#define IDH_MYINFO_BUSINESS_RADIO				26302
#define IDH_MYINFO_ADULT_RADIO					26304

#define IDH_MYINFO_PUBLISH						26041
#define IDH_MYINFO_ULS_SERVER					26042
#define IDH_MYINFO_DIRECTORY_AT_START			26044
#define IDH_DIRECTORY_DIRECTORY 				26117
#define IDH_ADVCALL_USE_ACCOUNT					26122
#define IDH_ADVCALL_ACCOUNT_NO					26003
#define IDH_MYINFO_PHONE						26115
#define IDH_CALLING_ADVANCED					26123
#define IDH_CALLING_BANDWIDTH					26130
#define IDH_ADVCALL_USE_PROXY					26200
#define IDH_ADVCALL_PROXY_NAME					26121
#define IDH_ADVCALL_ADD_DIRECTORY				26101
#define IDH_ADVCALL_DISPLAY_NAME				26102
#define IDH_ADVCALL_SERVER						26103
#define IDH_ADVCALL_URL							26403

#define IDH_FRIENDS_ADDFRIENDS					26120
#define IDH_FRIENDS_ADD_NEVER					26121
#define IDH_FRIENDS_ADD_ASKME					26122
#define IDH_FRIENDS_ADD_AUTO					26123
#define IDH_FRIENDS_GENERAL 					26124
#define IDH_FRIENDS_REFRESH_AT_START			26125
#define IDH_FRIENDS_REFRESH 					26126
#define IDH_FRIENDS_REFRESH_INTERVAL			26127
#define IDH_FRIENDS_REFRESH_WARNING 			26128
#define IDH_FRIENDS_REFRESH_COUNT				26129

////////////////////////////////////////////////////
// For the Modem properties dialog

#define IDH_MODEMPROP_AUTOANSWER				26050
#define IDH_MODEMPROP_NRINGS					26051
#define IDH_MODEMPROP_LOCATION					26052
#define IDH_MODEMPROP_DIALPROP					26053
#define IDH_MODEMPROP_USEMODEM					26054
#define IDH_MODEMPROP_MODEMPROP 				26055

////////////////////////////////////////////////////
// For the Advanced compression settings dialog

#define IDH_ADVCOMP_CODECS                      26060
#define IDH_ADVCOMP_UP                          26061
#define IDH_ADVCOMP_DOWN                        26062
#define IDH_ADVCOMP_DEFAULTS                    26063

#define IDH_AUDIO_AUTOMIXER                     26138
#define IDH_AUDIO_DIRECTSOUND                   26139


// Security Tab
#define IDH_SECURITY_SECURITY                   26400
#define IDH_SECURITY_INCOMING                   26401
#define IDH_SECURITY_OUTGOING                   26402

#define IDH_SECURITY_CERTIFICATE                26404
#define IDH_SECURITY_CHANGE_CERTIFICATE         26405
#define IDH_SECURITY_CERTIFICATE_PRIVACY        26406
#define IDH_SECURITY_CERTIFICATE_PRIV_AUTH      26409

#define IDH_SECURITY_CERTIFICATE_LIST           26410   // BUGBUG LAURABU - From MargeM

#define IDH_SECURITY_CHANGE_PASSWORD            26407
#define IDH_SECURITY_RUN_REMOTE                 26408


/* Whiteboard - Page Sorter */			
#define IDH_CONF_PAGESORT_MAIN                  27000
#define IDH_CLOSE                               27001
#define IDH_CONF_PAGESORT_GOTO                  27002
#define IDH_CONF_PAGESORT_DEL                   27003
#define IDH_CONF_PAGESORT_BEFORE                27004
#define IDH_CONF_PAGESORT_AFTER                 27005

/* Chat - Message Format */ 			
#define IDH_CHAT_FORMAT_MESSAGE                 28000
#define IDH_CHAT_FORMAT_HEADER                  28001
#define IDH_CHAT_RECEIVE_MSG					28002
#define IDH_CHAT_RECEIVE_PRIV					28003
#define IDH_CHAT_SENT_MSG						28004
#define IDH_CHAT_SENT_PRIV						28005
#define IDH_CHAT_FONT							28006
#define IDH_CHAT_FONTS_LABEL                    28007	
#define IDH_CHAT_NAME                           28008
#define IDH_CHAT_DATE                           28009
#define IDH_CHAT_TIME                           28010



/* IDH_OK */							
/* IDH_CANCEL */						

/* conf.exe help id's */
/* (most are in confroom\messages\usa\resource.hm) */
#define IDH_SHADOW_REMOTE_DETACHED              29000
#define IDH_SHADOW_LOCAL_DETACHED               29001


/* New Call (9/5/97)*/
#define IDH_ADV_PASSWORD                        29002

/* Com Port Properties (9/5/97) */
#define IDH_PROTO_TIME                          29003
#define IDH_PROTO_PORT                          29004
#define IDH_PROTO_PROP                          29005

/* Host a Meeting */
#define IDH_HOST_GENERAL                        27000
#define IDH_HOST_SETTINGS                       29008
#define IDH_HOST_NAME                           29006
#define IDH_HOST_PASSWORD                       29007
#define IDH_HOST_SECURE                         29201
#define IDH_HOST_ACCEPT_PEOPLE                  26202
#define IDH_HOST_TOOLS                          26208
#define IDH_HOST_AUDIO                          26203
#define IDH_HOST_CHAT                           26204
#define IDH_HOST_INVITE_PEOPLE                  26205
#define IDH_HOST_SHARE                          26207
#define IDH_HOST_VIDEO                          26209
#define IDH_HOST_WHITEBD                        26210
#define IDH_HOST_XFER                           26211

/* Place a Call (3/6/98)  */
#define IDH_PLACECALL_SECURITY_CHKBX			29009
#define IDH_PLACECALL_NAME                      29010
#define IDH_PLACECALL_INFOSTORE                 29011
#define IDH_PLACECALL_LIST                      29012
#define IDH_PLACECALL_DIRECT                    29013
#define IDH_PLACECALL_CALL                      29014

#define IDH_PLACECALL_TO						29016
#define IDH_PLACECALL_TO_TEXT					29017
#define IDH_PLACECALL_USING						29018
#define IDH_ADV_NORMAL_HINT						29019

/* NM/Office Info (3/20/98)  */
#define IDH_INFO_CATEGORY                       29015

/* WDM Device Source Dialog (9/03/98)  */
#define IDH_DEVICE_SETTINGS                     29020
#define IDH_CAMERA_CONTROLS                     29021

/* Choose Conference Dialog (3/11/99)  */
#define IDH_MCU_CONF_MAIN                       27000
#define IDH_MCU_CONF_NAME                       29022
#define IDH_MCU_CONF_LIST                       29023

#define IDH_PLACECALL_SEARCH_DIR				29025
#define IDH_FINDSOMEONE_REFRESH					29024
#define IDH_FINDSOMEONE_BROWSER					29026
#define IDH_FINDSOMEONE_HELP					29027
#define IDH_FINDSOMEONE_DELETE_ILS				29028


/* Create SpeedDial Dialog (3/15/99)  */
#define IDH_STATIC_SPEED_DIAL_INSTRUCTIONS      26011
#define IDH_CSD_ADDRESS_EDIT                    0x80a30424
#define IDH_CSD_CALL_USING_COMBO                0x80a30423
#define IDH_CSD_CREATE_GROUPBOX                 0x80a3047f
#define IDH_CSD_SAVE_DESKTOP_RADIO              0x80a3040b
#define IDH_CSD_SD_INFO_GROUP                   0x80a30480
#define IDH_CSD_SPEEDDIAL_LIST_RADIO            0x80a3040d
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\ias.h ===
#ifndef _IAS_H_
#define _IAS_H_



// GetShareableApps()
typedef struct
{
    HWND        hwnd;
    BOOL        fShared;
}
IAS_HWND;


typedef struct
{
    ULONG       cShared;
    ULONG       cEntries;
    IAS_HWND    aEntries[1];
}
IAS_HWND_ARRAY;


typedef UINT IAS_GCC_ID;



// GetPersonStatus()

#define IAS_SHARING_NOTHING             0x0000
#define IAS_SHARING_APPLICATIONS        0x0001
#define IAS_SHARING_DESKTOP             0x0002

typedef enum
{
    IAS_VERSION_20 = 1,
    IAS_VERSION_30
}
IAS_VERSION;

typedef struct
{
    UINT                cbSize;

    BOOL                InShare;            // Participating in share
    IAS_VERSION         Version;            // AS protocol version
    UINT                AreSharing;         // What person is sharing (IAS_SHARING_)
    BOOL                Controllable;       // Is person controllable
    BOOL                IsPaused;           // If controlled, is control paused currently
    IAS_GCC_ID          InControlOfPending; // Whom we are waiting to control
    IAS_GCC_ID          InControlOf;        // Whom is controlled by person
    IAS_GCC_ID          ControlledByPending;// Whom we are waiting to be controlled by
    IAS_GCC_ID          ControlledBy;       // Who is controlling person
}
IAS_PERSON_STATUS;




// GetWindowStatus

typedef enum
{
    IAS_SHARE_DEFAULT = 0,
    IAS_SHARE_BYPROCESS,
    IAS_SHARE_BYTHREAD,
    IAS_SHARE_BYWINDOW
}
IAS_SHARE_TYPE;



// lonchanc
// In general, S_OK means success, E_*** means failure
// For boolean values, S_OK means TRUE, S_FALSE means FALSE, and E_*** means failure.

#undef  INTERFACE
#define INTERFACE IAppSharing

// lonchanc: the idea of this IAppSharing is per call interface
DECLARE_INTERFACE_(IAppSharing, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_  REFIID, void **) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    //
    // INFORMATION
    //
    STDMETHOD_(BOOL, IsSharingAvailable)(THIS) PURE;
    STDMETHOD_(BOOL, CanShareNow)(THIS) PURE;
    STDMETHOD_(BOOL, IsInShare)(THIS) PURE;
    STDMETHOD_(BOOL, IsSharing)(THIS) PURE;
    STDMETHOD_(BOOL, IsWindowShareable)(THIS_ HWND hwnd) PURE;
    STDMETHOD_(BOOL, IsWindowShared)(THIS_ HWND hwnd) PURE;
    STDMETHOD_(BOOL, CanAllowControl)(THIS) PURE;
    STDMETHOD_(BOOL, IsControllable)(THIS) PURE;
    STDMETHOD(GetPersonStatus)(THIS_ IAS_GCC_ID Person, IAS_PERSON_STATUS *pStatus) PURE;

    //
    // SHARING
    //
    STDMETHOD(LaunchHostUI)(THIS) PURE;
	STDMETHOD(GetShareableApps)(THIS_ IAS_HWND_ARRAY **ppHwnds) PURE;
    STDMETHOD(FreeShareableApps)(THIS_  IAS_HWND_ARRAY * pHwnds) PURE;
	STDMETHOD(Share)(THIS_  HWND hwnd, IAS_SHARE_TYPE how) PURE;
	STDMETHOD(Unshare)(THIS_  HWND hwnd) PURE;

    //
    // CONTROL
    //

    // On host
    STDMETHOD(AllowControl)(THIS_ BOOL fAllowed) PURE;

    // From person controlling to person controlled
    STDMETHOD(TakeControl)(THIS_ IAS_GCC_ID PersonOf) PURE;
    STDMETHOD(CancelTakeControl)(THIS_ IAS_GCC_ID PersonOf) PURE;
    STDMETHOD(ReleaseControl)(THIS_ IAS_GCC_ID PersonOf) PURE;
    STDMETHOD(PassControl)(THIS_ IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo) PURE;

    // From person controlled
    STDMETHOD(GiveControl)(THIS_ IAS_GCC_ID PersonTo) PURE;
    STDMETHOD(CancelGiveControl)(THIS_ IAS_GCC_ID PersonTo) PURE;
    STDMETHOD(RevokeControl)(THIS_ IAS_GCC_ID PersonFrom) PURE;

    STDMETHOD(PauseControl)(IAS_GCC_ID PersonInControl) PURE;
    STDMETHOD(UnpauseControl)(IAS_GCC_ID PersonInControl) PURE;
};



// IAppSharingNotify interface
DECLARE_INTERFACE_(IAppSharingNotify, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID, void**) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    STDMETHOD(OnReadyToShare)(THIS_ BOOL fReady) PURE;
    STDMETHOD(OnShareStarted)(THIS) PURE;
    STDMETHOD(OnSharingStarted)(THIS) PURE;
    STDMETHOD(OnShareEnded)(THIS) PURE;
    STDMETHOD(OnPersonJoined)(THIS_ IAS_GCC_ID gccID) PURE;
    STDMETHOD(OnPersonLeft)(THIS_ IAS_GCC_ID gccID) PURE;

    STDMETHOD(OnStartInControl)(THIS_ IAS_GCC_ID gccOf) PURE;
    STDMETHOD(OnStopInControl)(THIS_ IAS_GCC_ID gccOf) PURE;
    STDMETHOD(OnPausedInControl)(THIS_ IAS_GCC_ID gccInControlOf) PURE;
    STDMETHOD(OnUnpausedInControl)(THIS_ IAS_GCC_ID gccInControlOf) PURE;

    STDMETHOD(OnControllable)(THIS_ BOOL fControllable) PURE;
    STDMETHOD(OnStartControlled)(THIS_ IAS_GCC_ID gccBy) PURE;
    STDMETHOD(OnStopControlled)(THIS_ IAS_GCC_ID gccBy) PURE;
    STDMETHOD(OnPausedControlled)(THIS_ IAS_GCC_ID gccControlledBy) PURE;
    STDMETHOD(OnUnpausedControlled)(THIS_ IAS_GCC_ID gccControlledBy) PURE;
};


//
// AS flags:
//
#define     AS_SERVICE          0x0001          // Is this service context?
#define     AS_UNATTENDED       0x0002          // Is this unattended (no end user)?

HRESULT WINAPI CreateASObject(IAppSharingNotify * pNotify, UINT flags, IAppSharing** ppAS);

#endif // _IAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\genwindow.h ===
// File: GenWindow.h

#ifndef _GenWINDOW_H_
#define _GenWINDOW_H_

#include "Referenc.h"

// Minimal interface for windows to talk to each other
interface DECLSPEC_UUID("{9B677AA6-ACA3-11d2-9C97-00C04FB17782}")
IGenWindow : public IUnknown
{
public:
	// Retrieve the desired size of a window so parents can layout their
	// children in an abstract manner
	virtual void GetDesiredSize(
		SIZE *psize	// The returned desired size
		) = 0;

	// Method to call when the desired size for a GenWindow changes
	virtual void OnDesiredSizeChanged() = 0;

	// Get the background brush to use
	virtual HBRUSH GetBackgroundBrush() = 0;

	// Get the palette the app is using
	virtual HPALETTE GetPalette() = 0;

	// Get the LPARAM of user data
	virtual LPARAM GetUserData() = 0;

	// Sends the registered c_msgFromHandle message to the hwnd. The hwnd
	// should return an IGenWindow* from that message
	static IGenWindow *FromHandle(
		HWND hwnd	// The hwnd to get the IGenWindow* from
		);

protected:
	// Registered message for retrieving the IGenWindow*
	static const DWORD c_msgFromHandle;
} ;

// Generic window class. Override the ProcessMessage method to add your own
// functionality
class DECLSPEC_UUID("{CEEA6922-ACA3-11d2-9C97-00C04FB17782}")
CGenWindow : REFCOUNT, public IGenWindow
{
public:
	typedef void (*InvokeProc)(CGenWindow *pWin, WPARAM wParam);

	// Default constructor; inits a few intrinsics
	CGenWindow();

	// Create the window, analagous to Win32's CreateWindowEx. Only the
	// class name is missing, since CGenWindow works only for its own window
	// class
	BOOL Create(
		HWND hWndParent,		// Window parent
		LPCTSTR szWindowName,	// Window name
		DWORD dwStyle,			// Window style
		DWORD dwEXStyle,		// Extended window style
		int x,					// Window pos: x
		int y,					// Window pos: y
		int nWidth,				// Window size: width
		int nHeight,			// Window size: height
		HINSTANCE hInst,		// The hInstance to create the window on
		HMENU hmMain=NULL,		// Window menu
		LPCTSTR szClassName=NULL	// The class name to use
		);

	// Create a child window, analagous to Win32's CreateWindowEx. The class
	// name is missing, since CGenWindow works only for its own window class.
	// Size and pos are also missing since most children will get layed out by
	// their parent.
	BOOL Create(
		HWND hWndParent,		// Window parent
		INT_PTR nId=0,				// ID of the child window
		LPCTSTR szWindowName=TEXT(""),	// Window name
		DWORD dwStyle=0,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		DWORD dwEXStyle=WS_EX_CONTROLPARENT	// Extended window style
		);

	// Return the HWND
	inline HWND GetWindow()
	{
		return(m_hwnd);
	}

	// Override if you want to layout your window in a specific way when it
	// resizes.
	// Making this public so it can be forced on a window.
	virtual void Layout()
	{
	}

	// begin IGenWindow interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID iid, LPVOID *pObj);
	virtual ULONG STDMETHODCALLTYPE AddRef(void) { return(REFCOUNT::AddRef()); }
	virtual ULONG STDMETHODCALLTYPE Release(void) { return(REFCOUNT::Release()); }

	virtual void GetDesiredSize(SIZE *ppt);

	// Forward the notification to the parent
	virtual void OnDesiredSizeChanged();

	// Get the background brush to use; use parent's by default
	virtual HBRUSH GetBackgroundBrush();

	// Get the palette the app is using
	virtual HPALETTE GetPalette();

	// Get the LPARAM of user data
	virtual LPARAM GetUserData();

	// end IGenWindow interface

	void SetUserData(LPARAM lUserData) { m_lUserData = lUserData; }

	// Set the global Hot control
	static void SetHotControl(CGenWindow *pHot);

	// Do a layout on this window at some time soon
	void ScheduleLayout();

	// Invoke on a posted message
	BOOL AsyncInvoke(InvokeProc proc, WPARAM wParam);

	// Set the tooltip for this window
	void SetTooltip(LPCTSTR pszTip);
	// Set the text of this window for accessibilty
	void SetWindowtext(LPCTSTR pszTip);
	// Remove the tooltip for this window
	void RemoveTooltip();

	// Get the standard palette for drawing
	static HPALETTE GetStandardPalette();
	// Delete the standard palette for drawing
	static void DeleteStandardPalette();

	// Get the standard palette for drawing
	static HBRUSH GetStandardBrush();
	// Delete the standard palette for drawing
	static void DeleteStandardBrush();

protected:
	// Virtual destructor so clients can provide specific destruction code
	// This is protected to indicate that only Release should call it, not
	// creators of this object. I'd rather make it private, but then extenders
	// would not work.
	virtual ~CGenWindow();

	// The virtual window procedure. Override this to add specific behavior.
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	// Set this control to be hot
	virtual void SetHot(BOOL bHot);
	// Is this control currently hot
	virtual BOOL IsHot();

	// Get the info necessary for displaying a tooltip
	virtual void GetSharedTooltipInfo(TOOLINFO *pti);

private:
	// The current hot control
	static CGenWindow *g_pCurHot;
	// The standard palette
	static HPALETTE g_hPal;
	// Whether we actually need a palette or not
	static BOOL g_bNeedPalette;
	// The standard background brush
	static HBRUSH g_hBrush;
	// The single list of tooltip windows
	static class CTopWindowArray *g_pTopArray;

	// Stuff nobody should ever do
	CGenWindow(const CGenWindow& rhs);
	CGenWindow& operator=(const CGenWindow& rhs);

	// The window class name
	static const LPCTSTR c_szGenWindowClass;

	// Initalizes the window class
	static BOOL InitWindowClass(LPCTSTR szClassName, HINSTANCE hThis);
	// The real window procedure that sets up the "this" pointer and calls
	// ProcessMessage
	static LRESULT CALLBACK RealWindowProc(
		HWND hWnd, 
		UINT message, 
		WPARAM wParam, 
		LPARAM lParam
		);
	// WM_NCCREATE handler. Stores away the "this" pointer.
	static BOOL OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);

	// The hwnd associated with this object
	HWND m_hwnd;

	// A single LPARAM so no need to extend just to add a little data
	LPARAM m_lUserData;

	// WM_SIZE handler. Calls the Layout function.
	void OnSize(HWND hwnd, UINT state, int cx, int cy);
	// WM_ERASEBKGND handler. Clears the window.
	BOOL OnEraseBkgnd(HWND hwnd, HDC hdc);
	// WM_MOUSEMOVE handler; sets the Hot control
	void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
	// clears the Hot tracking
	void OnMouseLeave();
	// Tells the parent to layout
	void OnShowWindow(HWND hwnd, BOOL fShow, int fnStatus);

	// Returns TRUE if the TT exists
	BOOL InitToolInfo(TOOLINFO *pti, LPTSTR pszText=NULL);
} ;

#endif // _GENWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\iacapapi.h ===
/*
 *  	File: iacapapi.h
 *
 *      Network audio application capability interface. Provides
 * 		APIs for enumerating, prioritizing, and enabling/disabling
 *		codecs independently for send/receive.
 *
 *		Revision History:
 *
 *		06/06/96	mikev	created
 *		02/05/97	yoramy	moved most of what was here to appavcap.h
 */


#ifndef _IACAPAPI_H
#define _IACAPAPI_H

#include "appavcap.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifndef DECLARE_INTERFACE_PTR
#ifdef __cplusplus
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	interface iface; typedef iface FAR * piface
#else
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	typedef interface iface iface, FAR * piface
#endif
#endif /* DECLARE_INTERFACE_PTR */


//Interface declarations:
//
// IAppAudioCap, IAppVidCap and IDualPubCap
//
//


//This is the interface to the Audio Class

#undef INTERFACE
#define INTERFACE IAppAudioCap
DECLARE_INTERFACE( IAppAudioCap )
{
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD (GetNumFormats) (THIS_ UINT *puNumFmtOut) PURE;
    STDMETHOD (ApplyAppFormatPrefs) (THIS_ PBASIC_AUDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs) PURE;
    STDMETHOD (EnumFormats) (THIS_ PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut) PURE;
    STDMETHOD (EnumCommonFormats) (THIS_ PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps) PURE;
	STDMETHOD (GetBasicAudcapInfo) (THIS_ AUDIO_FORMAT_ID Id,
		PBASIC_AUDCAP_INFO pFormatPrefsBuf) PURE;		
	STDMETHOD (AddACMFormat) (THIS_ LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo) PURE;
	STDMETHOD (RemoveACMFormat) (THIS_ LPWAVEFORMATEX lpwfx) PURE;
	STDMETHOD_ (LPVOID, GetFormatDetails) (THIS_ AUDIO_FORMAT_ID Id) PURE;

};

DECLARE_INTERFACE_PTR(IAppAudioCap,  LPAPPCAPPIF);
HRESULT WINAPI CreateAppCapInterface(LPAPPCAPPIF *ppAppCap);

#define CREATEIAPPCAPNAME	(_TEXT("CreateAppCapInterface"))
typedef HRESULT (WINAPI *CREATEIAPPCAPPROC) (LPAPPCAPPIF *ppAppCap);

//This is the interface to the Video Class
#undef INTERFACE
#define INTERFACE IAppVidCap
DECLARE_INTERFACE( IAppVidCap )
{
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD (GetNumFormats) (THIS_ UINT *puNumFmtOut) PURE;
    STDMETHOD (ApplyAppFormatPrefs) (THIS_ PBASIC_VIDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs) PURE;
    STDMETHOD (EnumFormats) (THIS_ PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut) PURE;
    STDMETHOD (EnumCommonFormats) (THIS_ PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps) PURE;		
	STDMETHOD (GetBasicVidcapInfo) (THIS_ VIDEO_FORMAT_ID Id,
		PBASIC_VIDCAP_INFO pFormatPrefsBuf) PURE;		
	STDMETHOD (AddVCMFormat) (THIS_ PVIDEOFORMATEX lpvfx, PVIDCAP_INFO pVidCapInfo) PURE;
	STDMETHOD (RemoveVCMFormat) (THIS_ PVIDEOFORMATEX lpvfx) PURE;
	STDMETHOD_ (PVIDEOFORMATEX, GetVidcapDetails) (THIS_ VIDEO_FORMAT_ID Id) PURE;
	STDMETHOD (GetPreferredFormatId) (THIS_ VIDEO_FORMAT_ID *pId) PURE;		
	STDMETHOD (SetDeviceID)(THIS_ DWORD dwDeviceID) PURE;			
	
};

DECLARE_INTERFACE_PTR(IAppVidCap,  LPAPPVIDCAPPIF);
HRESULT WINAPI CreateAppVidCapInterface(LPAPPVIDCAPPIF *ppAppVidCap);

#define CREATEIAPPVIDCAPNAME	(_TEXT("CreateAppVidCapInterface"))
typedef HRESULT (WINAPI *CREATEIAPPVIDCAPPROC) (LPAPPVIDCAPPIF *ppAppVidCap);



//This is the app's interface to the CapsCtl Class

#undef INTERFACE
#define INTERFACE IDualPubCap
DECLARE_INTERFACE( IDualPubCap )
{
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
	STDMETHOD_(BOOL, Init())=0;
	STDMETHOD(ReInitialize())=0;
};


DECLARE_INTERFACE_PTR(IDualPubCap, LPCAPSIF);
HRESULT WINAPI CreateCapsInterface(LPCAPSIF *ppAppCap);

#define CREATEICAPSNAME	(_TEXT("CreateCapsInterface"))
typedef HRESULT (WINAPI *CREATEICAPSPROC) (LPCAPSIF *ppCapsIF);



#include <poppack.h> /* End byte packing */


#endif	//#ifndef _IACAPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\icaapi.h ===
/*============================================================================*\

                 INTEL Corporation Proprietary Information

      This listing is supplied under the terms of a license agreement
      with INTEL Corporation and may not be copied nor disclosed except
      in accordance with the terms of that agreement.

                 Copyright (c) 1996 Intel Corporation.
                           All rights reserved.

\*============================================================================*/

/*****************************************************************************\

    SUMMARY: Intel Connection Advisor DLL export API

    HISTORY:
		Original E. Rogers, January 1997

$Header:   L:\proj\sturgeon\src\ica\vcs\icaapi.h_v   1.11   07 Feb 1997 14:29:28   RKAR  $

\*****************************************************************************/

#ifndef _ICA_API_H_
#define _ICA_API_H_

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#define SZ_ICADLL TEXT("MSICA.DLL")
#define SZ_ICAHELP TEXT("MSICA.HLP")
															  
#ifndef DllExport
//! #define DllExport	__declspec( dllexport )
#define DllExport
#endif	// DllExport

// Registry definitions (needed by conf.exe)
#define REGKEY_ICA           TEXT("Software\\Microsoft\\Conferencing\\ICA")
#define REGVAL_ICA_IN_TRAY   TEXT("UseTrayIcon")
#define REGVAL_ICA_POPUP     TEXT("PopupOnError")
#define REGVAL_ICA_TOPMOST   TEXT("StayOnTop")

// Panel identifiers
#define GENERAL_PANEL		"ICA_GENERAL_PANEL"			// Localization OK
#define MS_AUDIO_PANEL		"NM2.0_H323_AUDIO"			// Localization OK
#define MS_VIDEO_PANEL		"NM2.0_H323_VIDEO"			// Localization OK
#define VP20_H323_AUDIO_PANEL	"VPHONE2.0_H323_AUDIO"	// Localization OK
#define VP20_H323_VIDEO_PANEL	"VPHONE2.0_H323_VIDEO"	// Localization OK
#define VP20_H323_DETAILS_PANEL	"VPHONE2.0_H323_DETAILS"// Localization OK
#define VP20_H324_AUDIO_PANEL	"VPHONE2.0_H324_AUDIO"	// Localization OK
#define VP20_H324_VIDEO_PANEL	"VPHONE2.0_H324_VIDEO"	// Localization OK
#define VP20_H324_DETAILS_PANEL	"VPHONE2.0_H324_DETAILS"// Localization OK

// ICA data types - used by ICA_OpenStatistic in the dwType param
#define DWORD_TYPE		0


// Statistic info structure
typedef struct
{
	UINT	cbSize;
	DWORD	dwMaxValue;
	DWORD	dwMinValue;
	DWORD	dwWarnLevel;
	DWORD	dwUpdateFrequency;
} ICA_STATISTIC_INFO, *PICA_STATISTIC_INFO;


// Function typedefs
typedef HRESULT (WINAPI *PFnICA_Start)( char*, char*, HWND* );
typedef HRESULT (WINAPI *PFnICA_Stop)( VOID );
typedef HRESULT (WINAPI *PFnICA_DisplayPanel)( char*, char*, char*, VOID*, HANDLE* );
typedef HRESULT (WINAPI *PFnICA_RemovePanel)( HANDLE );
typedef HRESULT (WINAPI *PFnICA_OpenStatistic)( char*, DWORD, HANDLE* );
typedef HRESULT (WINAPI *PFnICA_SetStatistic)( HANDLE, BYTE*, DWORD );
typedef HRESULT (WINAPI *PFnICA_SetStatisticInfo)( HANDLE, ICA_STATISTIC_INFO* );
typedef HRESULT (WINAPI *PFnICA_SetWarningEvent)( HANDLE, HANDLE );
typedef HRESULT (WINAPI *PFnICA_GetStatistic)( HANDLE, BYTE*, DWORD*, DWORD* );
typedef HRESULT (WINAPI *PFnICA_GetWarningState)( HANDLE, BOOL* );
typedef HRESULT (WINAPI *PFnICA_EnumStatistic)( DWORD, char*, DWORD, HANDLE* );
typedef HRESULT (WINAPI *PFnICA_ResetStatistic)( HANDLE );
typedef HRESULT (WINAPI *PFnICA_CloseStatistic)( HANDLE );
typedef HRESULT (WINAPI *PFnICA_SetOptions) ( UINT );
typedef HRESULT (WINAPI *PFnICA_GetOptions) ( DWORD*);


///////////////////////// ICA API functions ///////////////////////////////////

// General functions
HRESULT WINAPI ICA_Start( char* pszDisplayName, char* pszRRCMLibrary, HWND* phWnd );
HRESULT WINAPI ICA_Stop( VOID );

// Panel functions
HRESULT WINAPI ICA_DisplayPanel( char* pszModuleName, char* pszName,
								 char* pszHelpFile, VOID* pReserved, HANDLE* phPanel );
HRESULT WINAPI ICA_RemovePanel( HANDLE hPanel );

// Data functions
HRESULT WINAPI ICA_OpenStatistic( char* pszName, DWORD dwType, HANDLE* phStat );
HRESULT WINAPI ICA_SetStatistic( HANDLE hStat, BYTE* pData, DWORD dwDataSize );
HRESULT WINAPI ICA_SetStatisticInfo( HANDLE hStat, ICA_STATISTIC_INFO* pStatInfo );
HRESULT WINAPI ICA_SetWarningEvent( HANDLE hStat, HANDLE hEvent );
HRESULT WINAPI ICA_GetStatistic( HANDLE hStat, BYTE* pBuffer, DWORD* pdwBufSize,
								    DWORD* pdwTimeStamp );
HRESULT WINAPI ICA_GetWarningState( HANDLE hStat, BOOL* bInWarningState );
HRESULT WINAPI ICA_EnumStatistic( DWORD dwIndex, char* pszName, DWORD dwNameSize,
									 HANDLE* phStat );
HRESULT WINAPI ICA_ResetStatistic( HANDLE hStat );
HRESULT WINAPI ICA_CloseStatistic( HANDLE hStat );

#define ICA_OPTION_DUPLEX_MASK     0x00000001
#define ICA_OPTION_TRAY_MASK       0x00000002
HRESULT WINAPI ICA_GetOptions( DWORD* dwOptionValue );

// ICA Flags to ICA_SetOptions
#define ICA_SHOW_TRAY_ICON         0x00000001
#define ICA_DONT_SHOW_TRAY_ICON	   0x00000002
#define ICA_SET_HALF_DUPLEX        0x00000004
#define ICA_SET_FULL_DUPLEX        0x00000008
HRESULT WINAPI ICA_SetOptions( UINT fOptionFlag );

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // _ICA_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\icomchan.h ===
/*
 *  	File: icomchan.h
 *
 *      Network media channel interface definitions 
 *
 *		Revision History:
 *
 *		10/09/96	mikev	created
 */
 

#ifndef _ICOMCHAN_H
#define _ICOMCHAN_H

#include "incommon.h"
#include "iprop.h"

//
// 	status code definitions for channel events passed upward 
//  to IH323ConfAdvise::ChannelEvent();
//
#define CHANNEL_OPEN		0x00000001	
#define CHANNEL_ACTIVE		0x00000002	// started streaming

#define CHANNEL_REJECTED	 	0x00000003	
#define CHANNEL_NO_CAPABILITY	0x00000004	// remote end is not capable of supporting
											// the media type of this channel
#define CHANNEL_CLOSED		    0x00000005
#define CHANNEL_OPEN_ERROR		0x00000007

#define CHANNEL_VIDEO_TS_TRADEOFF 	0x00000008
#define CHANNEL_REMOTE_PAUSE_ON     0x00000009
#define CHANNEL_REMOTE_PAUSE_OFF    0x0000000A

//
//	ICommChannel
//

#undef INTERFACE
#define INTERFACE ICommChannel
DECLARE_INTERFACE(ICommChannel)
{
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
	STDMETHOD(GetProperty)(THIS_ DWORD prop, PVOID pBuf, LPUINT pcbBuf) PURE;
	STDMETHOD(SetProperty)(THIS_ DWORD prop, PVOID pBuf, UINT cbBuf) PURE;
	STDMETHOD(IsChannelOpen)(THIS_ BOOL *pbOpen) PURE;
	STDMETHOD(Open)(THIS_ DWORD dwLocalFormatID, IH323Endpoint *pConnection) PURE;
 	STDMETHOD(Close)(THIS) PURE;
    STDMETHOD(SetAdviseInterface)(THIS_ interface IH323ConfAdvise *pH323ConfAdvise) PURE;
	STDMETHOD(EnableOpen)(THIS_ BOOL bEnable)PURE;
	STDMETHOD(GetMediaType)(THIS_ LPGUID pGuid)PURE; 
    STDMETHOD_(BOOL, IsSendChannel) (THIS) PURE;
    STDMETHOD_(IMediaChannel *, GetMediaChannel) (THIS) PURE;
   	STDMETHOD(Preview)(THIS_ MEDIA_FORMAT_ID idLocalFormat, 
   	    IMediaChannel * pMediaChannel)PURE;
   	STDMETHOD(PauseNetworkStream)(THIS_ BOOL fPause)PURE;
    STDMETHOD_(BOOL, IsNetworkStreamPaused)(THIS) PURE;
    STDMETHOD_(BOOL, IsRemotePaused)(THIS) PURE;
    STDMETHOD_(MEDIA_FORMAT_ID, GetConfiguredFormatID) (THIS) PURE;    
   	STDMETHOD(GetRemoteAddress)(THIS_ PSOCKADDR_IN pAddrOutput) PURE;
};

#undef INTERFACE
#define INTERFACE IStreamSignal
DECLARE_INTERFACE(IStreamSignal)
{
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(PictureUpdateRequest)(THIS)PURE;
    STDMETHOD(GetVersionInfo)(THIS_  
        PCC_VENDORINFO* ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo) PURE;
};

// 
// IVideoDevice
// 

#undef INTERFACE
#define INTERFACE IVideoDevice
DECLARE_INTERFACE(IVideoDevice)
{
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	// Capture Device related methods
	STDMETHOD(GetNumCapDev)(THIS) PURE;
	STDMETHOD(GetMaxCapDevNameLen)(THIS) PURE;
	STDMETHOD(EnumCapDev)(THIS_ DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev) PURE;
	STDMETHOD(GetCurrCapDevID)(THIS) PURE;
	STDMETHOD(SetCurrCapDevID)(THIS_ int nCapDevID) PURE;
	
};


#endif	//#ifndef _ICOMCHAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\icounter.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sun Apr 19 17:22:14 1998
 */
/* Compiler settings for icounter.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __icounter_h__
#define __icounter_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICounter_FWD_DEFINED__
#define __ICounter_FWD_DEFINED__
typedef interface ICounter ICounter;
#endif 	/* __ICounter_FWD_DEFINED__ */


#ifndef __IReport_FWD_DEFINED__
#define __IReport_FWD_DEFINED__
typedef interface IReport IReport;
#endif 	/* __IReport_FWD_DEFINED__ */


#ifndef __ICounterMgr_FWD_DEFINED__
#define __ICounterMgr_FWD_DEFINED__
typedef interface ICounterMgr ICounterMgr;
#endif 	/* __ICounterMgr_FWD_DEFINED__ */


#ifndef __Counter_FWD_DEFINED__
#define __Counter_FWD_DEFINED__

#ifdef __cplusplus
typedef class Counter Counter;
#else
typedef struct Counter Counter;
#endif /* __cplusplus */

#endif 	/* __Counter_FWD_DEFINED__ */


#ifndef __Report_FWD_DEFINED__
#define __Report_FWD_DEFINED__

#ifdef __cplusplus
typedef class Report Report;
#else
typedef struct Report Report;
#endif /* __cplusplus */

#endif 	/* __Report_FWD_DEFINED__ */


#ifndef __CounterMgr_FWD_DEFINED__
#define __CounterMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterMgr CounterMgr;
#else
typedef struct CounterMgr CounterMgr;
#endif /* __cplusplus */

#endif 	/* __CounterMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "nmstat.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICounter_INTERFACE_DEFINED__
#define __ICounter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICounter
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICounter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7BC77801-3830-11d0-B143-00C04FC2A118")
    ICounter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ int nValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitMax( 
            /* [in] */ int nMaxValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartStatistics( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopStatistics( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadStatistics( 
            /* [out] */ COUNTERSTAT __RPC_FAR *lpcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearStatistics( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICounter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICounter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ICounter __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            ICounter __RPC_FAR * This,
            /* [in] */ int nValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitMax )( 
            ICounter __RPC_FAR * This,
            /* [in] */ int nMaxValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            ICounter __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartStatistics )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopStatistics )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadStatistics )( 
            ICounter __RPC_FAR * This,
            /* [out] */ COUNTERSTAT __RPC_FAR *lpcs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearStatistics )( 
            ICounter __RPC_FAR * This);
        
        END_INTERFACE
    } ICounterVtbl;

    interface ICounter
    {
        CONST_VTBL struct ICounterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICounter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICounter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICounter_Initialize(This,szName,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,szName,dwFlags)

#define ICounter_Update(This,nValue)	\
    (This)->lpVtbl -> Update(This,nValue)

#define ICounter_InitMax(This,nMaxValue)	\
    (This)->lpVtbl -> InitMax(This,nMaxValue)

#define ICounter_GetValue(This,dwFlags,pnValue)	\
    (This)->lpVtbl -> GetValue(This,dwFlags,pnValue)

#define ICounter_StartStatistics(This)	\
    (This)->lpVtbl -> StartStatistics(This)

#define ICounter_StopStatistics(This)	\
    (This)->lpVtbl -> StopStatistics(This)

#define ICounter_ReadStatistics(This,lpcs)	\
    (This)->lpVtbl -> ReadStatistics(This,lpcs)

#define ICounter_ClearStatistics(This)	\
    (This)->lpVtbl -> ClearStatistics(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICounter_Initialize_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICounter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_Update_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ int nValue);


void __RPC_STUB ICounter_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_InitMax_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ int nMaxValue);


void __RPC_STUB ICounter_InitMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_GetValue_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ int __RPC_FAR *pnValue);


void __RPC_STUB ICounter_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_StartStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_StartStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_StopStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_StopStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_ReadStatistics_Proxy( 
    ICounter __RPC_FAR * This,
    /* [out] */ COUNTERSTAT __RPC_FAR *lpcs);


void __RPC_STUB ICounter_ReadStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_ClearStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_ClearStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICounter_INTERFACE_DEFINED__ */


#ifndef __IReport_INTERFACE_DEFINED__
#define __IReport_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReport
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7BC77802-3830-11d0-B143-00C04FC2A118")
    IReport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ int nValue,
            /* [in] */ DWORD dwIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEntry( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IReport __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            IReport __RPC_FAR * This,
            /* [in] */ int nValue,
            /* [in] */ DWORD dwIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEntry )( 
            IReport __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IReport __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue);
        
        END_INTERFACE
    } IReportVtbl;

    interface IReport
    {
        CONST_VTBL struct IReportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReport_Initialize(This,szName,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,szName,dwFlags)

#define IReport_Update(This,nValue,dwIndex)	\
    (This)->lpVtbl -> Update(This,nValue,dwIndex)

#define IReport_CreateEntry(This,szName,dwIndex)	\
    (This)->lpVtbl -> CreateEntry(This,szName,dwIndex)

#define IReport_GetValue(This,dwFlags,pnValue)	\
    (This)->lpVtbl -> GetValue(This,dwFlags,pnValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReport_Initialize_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IReport_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_Update_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ int nValue,
    /* [in] */ DWORD dwIndex);


void __RPC_STUB IReport_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_CreateEntry_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwIndex);


void __RPC_STUB IReport_CreateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_GetValue_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ int __RPC_FAR *pnValue);


void __RPC_STUB IReport_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReport_INTERFACE_DEFINED__ */


#ifndef __ICounterMgr_INTERFACE_DEFINED__
#define __ICounterMgr_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICounterMgr
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICounterMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9CB7FE5B-3444-11D0-B143-00C04FC2A118")
    ICounterMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateCounter( 
            /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirstC( 
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextC( 
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReport( 
            /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirstR( 
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextR( 
            /* [out] */ FINDREPORT __RPC_FAR *lpfr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICounterMgr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICounterMgr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateCounter )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstC )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextC )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateReport )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstR )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextR )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr);
        
        END_INTERFACE
    } ICounterMgrVtbl;

    interface ICounterMgr
    {
        CONST_VTBL struct ICounterMgrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounterMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICounterMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICounterMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICounterMgr_CreateCounter(This,lplpCounter)	\
    (This)->lpVtbl -> CreateCounter(This,lplpCounter)

#define ICounterMgr_FindFirstC(This,szName,lpfc)	\
    (This)->lpVtbl -> FindFirstC(This,szName,lpfc)

#define ICounterMgr_FindNextC(This,lpfc)	\
    (This)->lpVtbl -> FindNextC(This,lpfc)

#define ICounterMgr_CreateReport(This,lplpReport)	\
    (This)->lpVtbl -> CreateReport(This,lplpReport)

#define ICounterMgr_FindFirstR(This,szName,lpfr)	\
    (This)->lpVtbl -> FindFirstR(This,szName,lpfr)

#define ICounterMgr_FindNextR(This,lpfr)	\
    (This)->lpVtbl -> FindNextR(This,lpfr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICounterMgr_CreateCounter_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter);


void __RPC_STUB ICounterMgr_CreateCounter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindFirstC_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);


void __RPC_STUB ICounterMgr_FindFirstC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindNextC_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);


void __RPC_STUB ICounterMgr_FindNextC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_CreateReport_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport);


void __RPC_STUB ICounterMgr_CreateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindFirstR_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [out] */ FINDREPORT __RPC_FAR *lpfr);


void __RPC_STUB ICounterMgr_FindFirstR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindNextR_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ FINDREPORT __RPC_FAR *lpfr);


void __RPC_STUB ICounterMgr_FindNextR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICounterMgr_INTERFACE_DEFINED__ */



#ifndef __Counter_LIBRARY_DEFINED__
#define __Counter_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: Counter
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_Counter;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Counter;

class DECLSPEC_UUID("9CB7FE5F-3444-11D0-B143-00C04FC2A118")
Counter;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Report;

class DECLSPEC_UUID("9CB7FE5E-3444-11D0-B143-00C04FC2A118")
Report;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CounterMgr;

class DECLSPEC_UUID("65DDC229-38FE-11d0-B143-00C04FC2A118")
CounterMgr;
#endif
#endif /* __Counter_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\ih323cc.h ===
/*
 *  	File: ih323cc.h
 *
 *      Microsoft H323 call control interface header file
 *
 *		Revision History:
 *
 *		04/15/96	mikev	created (as inac.h)
 *      
 */

#ifndef _IH323CC_H
#define _IH323CC_H

#include "appavcap.h"
#include "imstream.h"
#include "ividrdr.h"
#include "common.h"
#include "iconnect.h"
#include "iras.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */
 
typedef WORD H323_TERMINAL_LABEL;   // instead of struct, ensure that this data 
                                    // type is as packed as possible w/zero ambiguity
#define McuNumberFromTl(tl) HIBYTE(tl)  // macros to access terminal label fields
#define TerminalNumberFromTl(tl) LOBYTE(tl)
#define TlFromMcuNumberAndTerminalNumber(mn, tn) MAKEWORD(mn,tn)

//
//	IH323CallControl  
//

#undef INTERFACE
#define INTERFACE IH323CallControl
DECLARE_INTERFACE_( IH323CallControl, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(Initialize) (THIS_ PORT *lpPort) PURE;
   	STDMETHOD(SetMaxPPBandwidth)(UINT Bandwidth) PURE;
    STDMETHOD(RegisterConnectionNotify) (THIS_ CNOTIFYPROC pConnectRequestHandler) PURE;
    STDMETHOD(DeregisterConnectionNotify) (THIS_ CNOTIFYPROC pConnectRequestHandler) PURE;
    STDMETHOD(GetNumConnections) (THIS_ ULONG *lp) PURE;
    STDMETHOD(GetConnectionArray)(THIS_ IH323Endpoint **lppArray, UINT uSize) PURE;
    STDMETHOD(CreateConnection) (THIS_ IH323Endpoint **lppConnection, GUID PIDofProtocolType) PURE;
   	STDMETHOD(SetUserDisplayName)(THIS_ LPWSTR lpwName) PURE;

	STDMETHOD(CreateLocalCommChannel)(THIS_ ICommChannel** ppCommChan, LPGUID lpMID,
		IMediaChannel* pMediaChannel) PURE;
	STDMETHOD(SetUserAliasNames)(THIS_ P_H323ALIASLIST pAliases) PURE;
	STDMETHOD(EnableGatekeeper)(THIS_ BOOL bEnable, 
	    PSOCKADDR_IN pGKAddr, 
	    P_H323ALIASLIST pAliases,
	    RASNOTIFYPROC pRasNotifyProc) PURE;
};


#undef INTERFACE
#define INTERFACE IH323ConfAdvise
DECLARE_INTERFACE_( IH323ConfAdvise, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD (CallEvent) (THIS_ IH323Endpoint * lpConnection, DWORD dwStatus) PURE;
    STDMETHOD (ChannelEvent) (THIS_ ICommChannel *pIChannel, 
        IH323Endpoint * lpConnection,	DWORD dwStatus ) PURE;
    STDMETHOD(GetMediaChannel)(THIS_ GUID *pmediaID, BOOL bSendDirection, IMediaChannel **ppI) PURE;	
};


// call this to create the top-level call control object
#define SZ_FNCREATEH323CC     "CreateH323CC"

typedef HRESULT (WINAPI *CREATEH323CC)(IH323CallControl **, BOOL fCallControl, UINT caps);

#include <poppack.h> /* End byte packing */
#endif	//#ifndef _IH323CC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\iconnect.h ===
/*
 *  	File: iconnect.h
 *
 *      Network audio connection interface header file. 
 *
 *		Revision History:
 *
 *		04/15/96	mikev	created
 */
 

#ifndef _ICONNECT_H
#define _ICONNECT_H

#include "icomchan.h"
#include "apierror.h"

// RES_PAIR contains an instance of a matching set of local and remote
// capability IDs.  
typedef struct res_pair
{
	MEDIA_FORMAT_ID idLocal;		// locally unique ID 
	MEDIA_FORMAT_ID idRemote;		// remote's ID 
	MEDIA_FORMAT_ID idPublicLocal;	// the public ID that corresponds to the (private) idLocal
}RES_PAIR, *PRES_PAIR;

typedef enum {
    AT_H323_ID =1,  // unicode string (typically user name or full email address)
    AT_H323_E164,   // unicode E164
    AT_INVALID      // this always goes last. it marks the end of valid values
}ALIAS_ADDR_TYPE;

typedef struct
{
    ALIAS_ADDR_TYPE         aType;
    WORD                    wDataLength;   // UNICODE character count
    LPWSTR                  lpwData;       // UNICODE data.
} H323ALIASNAME, *P_H323ALIASNAME;

typedef struct
{
    WORD                    wCount;     // # of entries in array of H323ALIASNAME
    P_H323ALIASNAME         pItems;     // points to array of H323ALIASNAME
} H323ALIASLIST, *P_H323ALIASLIST;


typedef enum {
	CLS_Idle,
	CLS_Connecting,
	CLS_Inuse,
	CLS_Listening,
	CLS_Disconnecting,
	CLS_Alerting
}ConnectStateType;

//
// 	call progress codes 
//

#define CONNECTION_CONNECTED 			0x00000001	// connected at network level
#define CONNECTION_RECEIVED_DISCONNECT 	0x00000002	// other end disconnected
#define CONNECTION_CAPABILITIES_READY 	0x00000003	// capabilities have been exchanged

#define CONNECTION_PROCEEDING			0x00000005  // "ringing" 

#define CONNECTION_READY				0x00000006  // start talking!
#define CONNECTION_REJECTED				0x00000007	// received a rejection
#define CONNECTION_DISCONNECTED			0x00000008	// this end is now disconnected

#define CONNECTION_BUSY					0x00000012 // busy signal
#define CONNECTION_ERROR				0x00000013



//
// 	Call completion summary codes ("Reason") for disconnecting or being rejected. 
//  This is a "first error" code.  It is assigned its value at the first detectable 
// 	event which is known to terminate a call.  
//
// The IConfAdvise implementation bears the responsibility for preserving the
// summary codes.  Control channel implementations (IControlChannel) supply the 
// best known summary code for each event, regardless of prior events.  
//

#define CCR_INVALID_REASON		0	// 	this indicates that no reason has been assigned

#define CCR_UNKNOWN				MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 1)
#define CCR_LOCAL_DISCONNECT	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 2)
#define CCR_REMOTE_DISCONNECT	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 3)
#define CCR_REMOTE_REJECTED		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 4)
#define CCR_REMOTE_BUSY			MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 5)
#define CCR_LOCAL_PROTOCOL_ERROR	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 6)
#define CCR_REMOTE_PROTOCOL_ERROR	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 7)
#define CCR_INCOMPATIBLE_VERSION	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 8)
#define CCR_LOCAL_SYSTEM_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 9)
#define CCR_REMOTE_SYSTEM_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 10)
#define CCR_LOCAL_MEDIA_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 11)
#define CCR_REMOTE_MEDIA_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 12)
#define CCR_LOCAL_REJECT			MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 13)
#define CCR_LOCAL_BUSY				MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 14)
#define CCR_INCOMPATIBLE_CAPS		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 15)	// no capabilities in common
#define CCR_NO_ANSWER_TIMEOUT		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 16)
#define CCR_GK_NO_RESOURCES			MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 17)
#define CCR_LOCAL_SECURITY_DENIED	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 18)
#define CCR_REMOTE_SECURITY_DENIED	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 19)



//
//	IH323Endpoint
//

#undef INTERFACE
#define INTERFACE IH323Endpoint
DECLARE_INTERFACE( IH323Endpoint )
{
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(SetAdviseInterface)(THIS_ IH323ConfAdvise *pH323ConfAdvise) PURE;
    STDMETHOD(ClearAdviseInterface)(THIS) PURE;
    STDMETHOD(PlaceCall)(THIS_ BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData) PURE;	
    STDMETHOD(Disconnect)(THIS) PURE;
    STDMETHOD(GetState)(THIS_ ConnectStateType *pState) PURE;
    STDMETHOD(GetRemoteUserName)(THIS_ LPWSTR lpwszName, UINT uSize) PURE;
    STDMETHOD(GetRemoteUserAddr)(THIS_ PSOCKADDR_IN psinUser) PURE;
    STDMETHOD(AcceptRejectConnection)(THIS_ CREQ_RESPONSETYPE Response) PURE;
    STDMETHOD_(HRESULT, GetSummaryCode)(THIS) PURE;
 	STDMETHOD(CreateCommChannel)(THIS_ LPGUID pMediaGuid, ICommChannel **ppICommChannel,
    	BOOL fSend) PURE; 
    	
	STDMETHOD (ResolveFormats)(THIS_ LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput) PURE;
    	
    STDMETHOD(GetVersionInfo)(THIS_
		PCC_VENDORINFO *ppLocalVendorInfo,
		PCC_VENDORINFO *ppRemoteVendorInfo) PURE;
};


#endif	//#ifndef _ICONNECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\imbft.h ===
// File: iMbft.h
//
// Interface to Multipoint Binary File Transfer


#ifndef _IMBFT_H_
#define _IMBFT_H_

#include <t120type.h>

const unsigned int _iMBFT_MAX_APP_KEY        = 64;     //Max characters in lpszAppKey parameter passed to MBFTInitialize
const unsigned int _iMBFT_MAX_FILE_NAME      = MAX_PATH;     //Max characters in filename


typedef UINT MBFTFILEHANDLE;
typedef UINT MBFTEVENTHANDLE;

typedef enum
{
    iMBFT_OK = 0,
    iMBFT_FIRST_ERROR = 0x100,
    iMBFT_NOT_INITIALIZED,
    iMBFT_ALREADY_INITIALIZED,
    iMBFT_INVALID_SESSION_ID,
    iMBFT_INVALID_ATTACHMENT_HANDLE,
    iMBFT_NO_MORE_RECIPIENTS,
    iMBFT_NO_MORE_FILES,
    iMBFT_INVALID_EVENT_HANDLE,
    iMBFT_INVALID_FILE_HANDLE,
    iMBFT_INSUFFICIENT_DISK_SPACE,
    iMBFT_FILE_NOT_FOUND,
    iMBFT_FILE_IO_ERROR,
    iMBFT_MEMORY_ALLOCATION_ERROR,
    iMBFT_ASN1_ENCODING_ERROR,
    iMBFT_RECIPIENT_NOT_FOUND,
    iMBFT_SENDER_ABORTED,
    iMBFT_RECEIVER_ABORTED,
    iMBFT_MULT_RECEIVER_ABORTED,
    iMBFT_RECEIVER_REJECTED,
    iMBFT_INVALID_PARAMETERS,
    iMBFT_COMPRESSION_ERROR,
    iMBFT_DECOMPRESSION_ERROR,
    iMBFT_INVALID_PATH,
    iMBFT_FILE_ACCESS_DENIED,
    iMBFT_FILE_HARD_IO_ERROR,
    iMBFT_FILE_SHARING_VIOLATION,
    iMBFT_DIRECTORY_FULL_ERROR,
    iMBFT_TOO_MANY_OPEN_FILES,
    iMBFT_OPERATION_IN_PROGRESS,
    iMBFT_INSUFFICIENT_PRIVILEGE,
    iMBFT_CONDUCTOR_ABORTED,
    iMBFT_PACKET_SIZE_ERROR,
    iMBFT_UNKNOWN_ERROR,
    iMBFT_TIMEOUT_ERROR
} MBFT_ERROR_CODE;

// Return codes  (Should be in imsconf2.idl)

#define FT_ERR_FAC 0xF000
#define FT_E(e)    (0x81000000UL | FT_ERR_FAC | (ULONG) (e))

enum
{
	NM_E_FT_NO_RECIPIENTS =                FT_E(0x01FF),
	NM_E_FT_CANCELED =                     FT_E(0x01FE),
	NM_E_FT_MULT_CANCELED =                FT_E(0x01FD),
	NM_E_FT_RECDIR =                       FT_E(0x01FC),
	NM_E_FT_REJECTED =                     FT_E(0x01FB)
};

#define HRESULT_FROM_IMBFT(iMbftError)     FT_E(iMbftError)



// This matches "ErrorType" in T.MBFT spec
typedef enum
{
    MBFT_INFORMATIVE_ERROR = 0,         // Information only
    MBFT_TRANSIENT_ERROR,               // Current transfer failed, retry might work
    MBFT_PERMANENT_ERROR                // Error occurs consistently
} MBFT_ERROR_TYPES;


typedef struct _T_MBFT_PEER_INFO
{
    T120NodeID      NodeID;                 // MCS userID of GCC on peer's node
    T120UserID      MBFTPeerID;             // MCS userID of peer app
    T120SessionID   MBFTSessionID;          // Session ID
    BOOL            bIsProShareApp;         // ProShare MBFT peer
    char            szAppKey[_iMBFT_MAX_APP_KEY];   // see MBFTInitialize
} MBFT_PEER_INFO;

typedef struct _T_MBFT_SEND_FILE_INFO
{
    char            * lpszFilePath;          //Canonical path to file to be sent, upto [_iMBFT_MAX_PATH] bytes
    MBFTFILEHANDLE  hFile;                  // unique identifier for file (filled in on return)
    ULONG           lFileSize;              // File size in bytes
    time_t          FileDateTime;
} MBFT_SEND_FILE_INFO;

typedef struct _T_MBFT_RECEIVE_FILE_INFO
{
    char            szFileName[_iMBFT_MAX_FILE_NAME];  // Just the File name
    MBFTFILEHANDLE  hFile;                  // unique identifier for file
    ULONG           lFileSize;              // File size in bytes
    time_t          FileDateTime;
} MBFT_RECEIVE_FILE_INFO;

typedef struct  _T_MBFT_FILE_OFFER
{
    MBFTEVENTHANDLE hEvent;
    T120UserID      SenderID;           // MCS ID of sender-to-be
	T120NodeID      NodeID;
    ULONG           uNumFiles;          // Number of files offered
    BOOL            bIsBroadcastEvent;
    MBFT_RECEIVE_FILE_INFO  FAR * lpFileInfoList;   // Array of structs with file info
} MBFT_FILE_OFFER;

typedef struct  _T_MBFT_FILE_PROGRESS
{
    MBFTEVENTHANDLE hEvent;
    MBFTFILEHANDLE  hFile;
    ULONG           lFileSize;
    ULONG           lBytesTransmitted;
    BOOL            bIsBroadcastEvent;
} MBFT_FILE_PROGRESS;

typedef struct  _T_MBFT_EVENT_ERROR
{
    MBFTEVENTHANDLE hEvent;
    BOOL            bIsLocalError;      // If error in local MBFT provider
    T120UserID      UserID;             // MCS ID of peer who reported error
    MBFTFILEHANDLE  hFile;              // File associated with error
    BOOL            bIsBroadcastEvent;
    MBFT_ERROR_TYPES eErrorType;        // Severity of error
    MBFT_ERROR_CODE eErrorCode;
} MBFT_EVENT_ERROR;


#undef  INTERFACE
#define INTERFACE IMbftEvents
DECLARE_INTERFACE(IMbftEvents)
{
	STDMETHOD(OnInitializeComplete)(    THIS) PURE;

	STDMETHOD(OnPeerAdded)(             THIS_
										MBFT_PEER_INFO *pInfo) PURE;
	STDMETHOD(OnPeerRemoved)(           THIS_
										MBFT_PEER_INFO *pInfo) PURE;
	STDMETHOD(OnFileOffer)(             THIS_
										MBFT_FILE_OFFER *pOffer) PURE;
	STDMETHOD(OnFileProgress)(          THIS_
										MBFT_FILE_PROGRESS *pProgress) PURE;
	STDMETHOD(OnFileEnd)(               THIS_
										MBFTFILEHANDLE hFile) PURE;
	STDMETHOD(OnFileError)(             THIS_
										MBFT_EVENT_ERROR *pEvent) PURE;
	STDMETHOD(OnFileEventEnd)(          THIS_
										MBFTEVENTHANDLE hEvent) PURE;
	STDMETHOD(OnSessionEnd)(            THIS) PURE;
};

#undef  INTERFACE
#define INTERFACE IMbftControl
DECLARE_INTERFACE(IMbftControl)
{
	STDMETHOD_(void, ReleaseInterface)( THIS) PURE;
	STDMETHOD_(void, Update)(           THIS) PURE;
	STDMETHOD_(void, CancelFt)(         THIS_
										MBFTEVENTHANDLE hEvent,
										MBFTFILEHANDLE  hFile) PURE;
	STDMETHOD(AcceptFileOffer)(         THIS_
										MBFT_FILE_OFFER *pOffer,
										LPCSTR pszRecDir,
										LPCSTR pszFileName) PURE;
	STDMETHOD_(void, RejectFileOffer)(  THIS_
	                                    MBFT_FILE_OFFER *pOffer) PURE;
	STDMETHOD(SendFile)(                THIS_
	                                    LPCSTR pszFileName,
	                                    T120NodeID nidReceiver,
	                                    MBFTEVENTHANDLE *phEvent,
	                                    MBFTFILEHANDLE *phFile) PURE;
};

typedef HRESULT (WINAPI * PFNCREATEMBFTOBJECT) (IMbftControl**, IMbftEvents *);

HRESULT WINAPI FT_CreateInterface(IMbftControl **ppMbft, IMbftEvents *pEvents);


#endif /* _IMBFT_H */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\ilsguid.h ===
//****************************************************************************
//
//  File:       ilsguid.h
//  Content:    This file contains the class GUID for Internet Location Services.
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

// {A4AD47C0-20EA-11d0-8796-444553540000}
//
DEFINE_GUID(CLSID_InternetLocationServices, 
0xa4ad47c0, 0x20ea, 0x11d0, 0x87, 0x96, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\inifile.h ===
/*
 * inifile.h - Initialization file processing module description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _INIFILE_H_
#define _INIFILE_H_

/* Types
 ********/

#ifdef DEBUG

/* .ini switch types */

typedef enum _iniswitchtype
{
   IST_BOOL,
   IST_DEC_INT,
   IST_UNS_DEC_INT,
   IST_BIN
}
INISWITCHTYPE;
DECLARE_STANDARD_TYPES(INISWITCHTYPE);

/* boolean .ini switch */

typedef struct _booliniswitch
{
   INISWITCHTYPE istype;      /* must be IST_BOOL */

   PCSTR pcszKeyName;

   PDWORD pdwParentFlags;

   DWORD dwFlag;
}
BOOLINISWITCH;
DECLARE_STANDARD_TYPES(BOOLINISWITCH);

/* decimal integer .ini switch */

typedef struct _decintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_DEC_INT */

   PCSTR pcszKeyName;

   PINT pnValue;
}
DECINTINISWITCH;
DECLARE_STANDARD_TYPES(DECINTINISWITCH);

/* unsigned decimal integer .ini switch */

typedef struct _unsdecintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_UNS_DEC_INT */

   PCSTR pcszKeyName;

   PUINT puValue;
}
UNSDECINTINISWITCH;
DECLARE_STANDARD_TYPES(UNSDECINTINISWITCH);

/* binary (hex data) .ini switch */

typedef struct _bininiswitch
{
   INISWITCHTYPE istype;      /* must be IST_BIN */

   PCSTR pcszKeyName;

   DWORD dwSize;

   PVOID pb;
}
BININISWITCH;
DECLARE_STANDARD_TYPES(BININISWITCH);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* defined by client */

extern PCSTR g_pcszIniFile;
extern PCSTR g_pcszIniSection;

#endif


/* Prototypes
 *************/

#ifdef DEBUG

/* inifile.c */

extern BOOL SetIniSwitches(const PCVOID *, UINT);
extern BOOL WriteIniData(const PCVOID *);
extern BOOL WriteIniSwitches(const PCVOID *, UINT);

#endif

#endif /* _INIFILE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\imstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medistrm.h

Abstract:
	Contains constants and class declarations for the abstract MediaStream object. A MediaStream
	represents a single unidirectional stream, such as a received Video channel.
	
--*/
#ifndef _IMSTREAM_H_
#define _IMSTREAM_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

class IStreamEventNotify
{
public:
	virtual HRESULT __stdcall EventNotification(UINT uDirection, UINT uMediaType, UINT uEventCode, UINT uSubCode)=0;
};


DECLARE_INTERFACE_(IMediaChannel, IUnknown)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetProperty)(THIS_ DWORD dwProp, PVOID pBuf, LPUINT pcbBuf) PURE;
	STDMETHOD(SetProperty)(THIS_ DWORD dwProp, PVOID pBuf, UINT cbBuf) PURE;
	STDMETHOD(Configure)(THIS_ BYTE *pFormat, UINT cbFormat,
				   BYTE *pChannelParams, UINT cbParams,
				   IUnknown *pUnknown) PURE;
	STDMETHOD(SetNetworkInterface)(THIS_ IUnknown *pUnknown) PURE;
	STDMETHOD(Start)(THIS ) PURE;
	STDMETHOD(Stop)(THIS) PURE;
	STDMETHOD_(DWORD, GetState)(THIS) PURE;
	STDMETHOD(SetMaxBitrate) (THIS_ UINT uMaxBitrate) PURE;
};

class IAudioChannel : public IMediaChannel
{
public:
	virtual HRESULT __stdcall GetSignalLevel(UINT *pLevel)=0;
};


class IVideoChannel : public IMediaChannel
{
public:
	virtual HRESULT __stdcall SetTemporalSpatialTradeOff(DWORD dwVal)=0;
	virtual HRESULT __stdcall GetTemporalSpatialTradeOff(DWORD *pdwVal)=0;
	virtual HRESULT __stdcall SendKeyFrame(void) = 0;
	virtual HRESULT __stdcall ShowDeviceDialog(DWORD dwFlags)=0;
	virtual HRESULT __stdcall GetDeviceDialog(DWORD *pdwFlags)=0;
};


// return values for GetState
#define MSSTATE_UNCONFIGURED    0
#define MSSTATE_CONFIGURED              1
#define MSSTATE_STARTED                 2

// flag values for CreateMediaChannel()
typedef enum 
{
	MCF_SEND = 1,
	MCF_RECV = 2,
	MCF_AUDIO = 4,
	MCF_VIDEO = 8,
	MCF_DEFAULT_DEVICE = 16
} MC_FLAGS;

#undef INTERFACE
#define INTERFACE IMediaChannelBuilder
DECLARE_INTERFACE_( IMediaChannelBuilder, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;     
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Initialize) (THIS_ HWND hWnd, HINSTANCE hInst) PURE;
    STDMETHOD(CreateMediaChannel) (THIS_ UINT flags, IMediaChannel **ppI) PURE;  
	STDMETHOD(SetStreamEventObj) (THIS_ IStreamEventNotify *pNotify) PURE;
};


class IMixer : public IUnknown
{
public:
	virtual BOOL __stdcall SetVolume(DWORD dwVolume)=0;
	virtual BOOL __stdcall CanSetVolume()=0;
	virtual BOOL __stdcall SetMainVolume(DWORD dwVolume)=0;
	virtual BOOL __stdcall SetSubVolume(DWORD dwVolume)=0;
	virtual BOOL __stdcall SetAGC(BOOL fOn)=0;
	virtual BOOL __stdcall GetMainVolume(LPDWORD pdwVolume)=0;
	virtual BOOL __stdcall GetSubVolume(LPDWORD pdwVolume)=0;
	virtual BOOL __stdcall GetAGC(BOOL *pfOn)=0;
	virtual BOOL __stdcall EnableMicrophone()=0;
	virtual BOOL __stdcall UnMuteVolume()=0;
};

class IAudioDevice : public IUnknown
{
public: 
	virtual HRESULT __stdcall GetRecordID(UINT *puWaveDevID)=0;
	virtual HRESULT __stdcall SetRecordID(UINT uWaveDevID)=0;
	virtual HRESULT __stdcall GetPlaybackID(UINT *puWaveDevID)=0;
	virtual HRESULT __stdcall SetPlaybackID(UINT uWaveDevID)=0;
	virtual HRESULT __stdcall GetDuplex(BOOL *pbFullDuplex)=0;
	virtual HRESULT __stdcall SetDuplex(BOOL bFullDuplex)=0;
	virtual HRESULT __stdcall GetSilenceLevel(UINT *puLevel)=0;
	virtual HRESULT __stdcall SetSilenceLevel(UINT uLevel)=0;
	virtual HRESULT __stdcall GetAutoMix(BOOL *pbAutoMix)=0;
	virtual HRESULT __stdcall SetAutoMix(BOOL bAutoMix)=0;
	virtual HRESULT __stdcall GetDirectSound(BOOL *pbDS)=0;
	virtual HRESULT __stdcall SetDirectSound(BOOL bDS)=0;
	virtual HRESULT __stdcall GetMixer(HWND hwnd, BOOL bPlayback, IMixer **ppMixer)=0;
};


enum STREAM_EVENTS
{
	STREAM_EVENT_DEVICE_FAILURE=1001,
	STREAM_EVENT_DEVICE_OPEN,
	STREAM_EVENT_DEVICE_CLOSE
};


// hiword of GetSignalLevel contains may these status bits
#define SIGNAL_STATUS_TRANSMIT  0x01  // data is being received/sent
#define SIGNAL_STATUS_JAMMED    0x02  // wave dev failed to open


typedef HRESULT (WINAPI *CREATE_SP)(IMediaChannelBuilder **);



#define DTMF_STAR	10
#define DTMF_POUND	11
#define DTMF_A	12
#define DTMF_B	13
#define DTMF_C	14
#define DTMF_D	15

class IDTMFSend : public IUnknown
{
public:
	virtual HRESULT __stdcall AddDigit(int nDigit) = 0;
	virtual HRESULT __stdcall ResetDTMF() = 0;
};


#include <poppack.h> /* End byte packing */


#endif // _MEDISTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\indeopal.h ===
// Indeo Palette

typedef struct Palette_tag
{
	WORD Version;
	WORD NumberOfEntries;
	PALETTEENTRY aEntries[256];
} LOGPALETTE_NM;

static const LOGPALETTE_NM gcLogPaletteIndeo =
{
  0x300,
	256,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
      0,  39+ 15,       0,  PC_NOCOLLAPSE,
      0,  39+ 24,       0,  PC_NOCOLLAPSE,
      0,  39+ 33,       0,  PC_NOCOLLAPSE,
      0,  39+ 42,       0,  PC_NOCOLLAPSE,
-44+ 51,  39+ 51,       0,  PC_NOCOLLAPSE,
-44+ 60,  39+ 60, -55+ 60,  PC_NOCOLLAPSE,
-44+ 69,  39+ 69, -55+ 69,  PC_NOCOLLAPSE,
-44+ 78,  39+ 78, -55+ 78,  PC_NOCOLLAPSE,
-44+ 87,  39+ 87, -55+ 87,  PC_NOCOLLAPSE,
-44+ 96,  39+ 96, -55+ 96,  PC_NOCOLLAPSE,
-44+105,  39+105, -55+105,  PC_NOCOLLAPSE,
-44+114,  39+114, -55+114,  PC_NOCOLLAPSE,
-44+123,  39+123, -55+123,  PC_NOCOLLAPSE,
-44+132,  39+132, -55+132,  PC_NOCOLLAPSE,
-44+141,  39+141, -55+141,  PC_NOCOLLAPSE,
-44+150,  39+150, -55+150,  PC_NOCOLLAPSE,
-44+159,  39+159, -55+159,  PC_NOCOLLAPSE,
-44+168,  39+168, -55+168,  PC_NOCOLLAPSE,
-44+177,  39+177, -55+177,  PC_NOCOLLAPSE,
-44+186,  39+186, -55+186,  PC_NOCOLLAPSE,
-44+195,  39+195, -55+195,  PC_NOCOLLAPSE,
-44+204,  39+204, -55+204,  PC_NOCOLLAPSE,
-44+213,  39+213, -55+213,  PC_NOCOLLAPSE,
-44+222,     255, -55+222,  PC_NOCOLLAPSE,
-44+231,     255, -55+231,  PC_NOCOLLAPSE,
-44+240,     255, -55+240,  PC_NOCOLLAPSE,

      0,  26+ 15,   0+ 15,  PC_NOCOLLAPSE,
      0,  26+ 24,   0+ 24,  PC_NOCOLLAPSE,
      0,  26+ 33,   0+ 33,  PC_NOCOLLAPSE,
      0,  26+ 42,   0+ 42,  PC_NOCOLLAPSE,
-44+ 51,  26+ 51,   0+ 51,  PC_NOCOLLAPSE,
-44+ 60,  26+ 60,   0+ 60,  PC_NOCOLLAPSE,
-44+ 69,  26+ 69,   0+ 69,  PC_NOCOLLAPSE,
-44+ 78,  26+ 78,   0+ 78,  PC_NOCOLLAPSE,
-44+ 87,  26+ 87,   0+ 87,  PC_NOCOLLAPSE,
-44+ 96,  26+ 96,   0+ 96,  PC_NOCOLLAPSE,
-44+105,  26+105,   0+105,  PC_NOCOLLAPSE,
-44+114,  26+114,   0+114,  PC_NOCOLLAPSE,
-44+123,  26+123,   0+123,  PC_NOCOLLAPSE,
-44+132,  26+132,   0+132,  PC_NOCOLLAPSE,
-44+141,  26+141,   0+141,  PC_NOCOLLAPSE,
-44+150,  26+150,   0+150,  PC_NOCOLLAPSE,
-44+159,  26+159,   0+159,  PC_NOCOLLAPSE,
-44+168,  26+168,   0+168,  PC_NOCOLLAPSE,
-44+177,  26+177,   0+177,  PC_NOCOLLAPSE,
-44+186,  26+186,   0+186,  PC_NOCOLLAPSE,
-44+195,  26+195,   0+195,  PC_NOCOLLAPSE,
-44+204,  26+204,   0+204,  PC_NOCOLLAPSE,
-44+213,  26+213,   0+213,  PC_NOCOLLAPSE,
-44+222,  26+222,   0+222,  PC_NOCOLLAPSE,
-44+231,     255,   0+231,  PC_NOCOLLAPSE,
-44+240,     255,   0+240,  PC_NOCOLLAPSE,

      0,  14+ 15,  55+ 15,  PC_NOCOLLAPSE,
      0,  14+ 24,  55+ 24,  PC_NOCOLLAPSE,
      0,  14+ 33,  55+ 33,  PC_NOCOLLAPSE,
      0,  14+ 42,  55+ 42,  PC_NOCOLLAPSE,
-44+ 51,  14+ 51,  55+ 51,  PC_NOCOLLAPSE,
-44+ 60,  14+ 60,  55+ 60,  PC_NOCOLLAPSE,
-44+ 69,  14+ 69,  55+ 69,  PC_NOCOLLAPSE,
-44+ 78,  14+ 78,  55+ 78,  PC_NOCOLLAPSE,
-44+ 87,  14+ 87,  55+ 87,  PC_NOCOLLAPSE,
-44+ 96,  14+ 96,  55+ 96,  PC_NOCOLLAPSE,
-44+105,  14+105,  55+105,  PC_NOCOLLAPSE,
-44+114,  14+114,  55+114,  PC_NOCOLLAPSE,
-44+123,  14+123,  55+123,  PC_NOCOLLAPSE,
-44+132,  14+132,  55+132,  PC_NOCOLLAPSE,

// Replace this entry with a more ie-logo-friendly color 
// -44+141,  14+141,  55+141,  PC_NOCOLLAPSE,
     51,     153,     255,  PC_NOCOLLAPSE,

-44+150,  14+150,  55+150,  PC_NOCOLLAPSE,
-44+159,  14+159,  55+159,  PC_NOCOLLAPSE,
-44+168,  14+168,  55+168,  PC_NOCOLLAPSE,
-44+177,  14+177,  55+177,  PC_NOCOLLAPSE,
-44+186,  14+186,  55+186,  PC_NOCOLLAPSE,
-44+195,  14+195,  55+195,  PC_NOCOLLAPSE,
-44+204,  14+204,     255,  PC_NOCOLLAPSE,
-44+213,  14+213,     255,  PC_NOCOLLAPSE,
-44+222,     255,     255,  PC_NOCOLLAPSE,
-44+231,     255,     255,  PC_NOCOLLAPSE,
-44+240,     255,     255,  PC_NOCOLLAPSE,

  0+ 15,  13+ 15,       0,  PC_NOCOLLAPSE,
  0+ 24,  13+ 24,       0,  PC_NOCOLLAPSE,
  0+ 33,  13+ 33,       0,  PC_NOCOLLAPSE,
  0+ 42,  13+ 42,       0,  PC_NOCOLLAPSE,
  0+ 51,  13+ 51,       0,  PC_NOCOLLAPSE,
  0+ 60,  13+ 60, -55+ 60,  PC_NOCOLLAPSE,
  0+ 69,  13+ 69, -55+ 69,  PC_NOCOLLAPSE,
  0+ 78,  13+ 78, -55+ 78,  PC_NOCOLLAPSE,
  0+ 87,  13+ 87, -55+ 87,  PC_NOCOLLAPSE,
  0+ 96,  13+ 96, -55+ 96,  PC_NOCOLLAPSE,
  0+105,  13+105, -55+105,  PC_NOCOLLAPSE,
  0+114,  13+114, -55+114,  PC_NOCOLLAPSE,
  0+123,  13+123, -55+123,  PC_NOCOLLAPSE,
  0+132,  13+132, -55+132,  PC_NOCOLLAPSE,
  0+141,  13+141, -55+141,  PC_NOCOLLAPSE,
  0+150,  13+150, -55+150,  PC_NOCOLLAPSE,
  0+159,  13+159, -55+159,  PC_NOCOLLAPSE,
  0+168,  13+168, -55+168,  PC_NOCOLLAPSE,
  0+177,  13+177, -55+177,  PC_NOCOLLAPSE,
  0+186,  13+186, -55+186,  PC_NOCOLLAPSE,
  0+195,  13+195, -55+195,  PC_NOCOLLAPSE,
  0+204,  13+204, -55+204,  PC_NOCOLLAPSE,
  0+213,  13+213, -55+213,  PC_NOCOLLAPSE,
  0+222,  13+222, -55+222,  PC_NOCOLLAPSE,
  0+231,  13+231, -55+231,  PC_NOCOLLAPSE,
  0+240,  13+242, -55+240,  PC_NOCOLLAPSE,

  0+ 15,   0+ 15,   0+ 15,  PC_NOCOLLAPSE,
  0+ 24,   0+ 24,   0+ 24,  PC_NOCOLLAPSE,
  0+ 33,   0+ 33,   0+ 33,  PC_NOCOLLAPSE,
  0+ 42,   0+ 42,   0+ 42,  PC_NOCOLLAPSE,
  0+ 51,   0+ 51,   0+ 51,  PC_NOCOLLAPSE,
  0+ 60,   0+ 60,   0+ 60,  PC_NOCOLLAPSE,
  0+ 69,   0+ 69,   0+ 69,  PC_NOCOLLAPSE,
  0+ 78,   0+ 78,   0+ 78,  PC_NOCOLLAPSE,
  0+ 87,   0+ 87,   0+ 87,  PC_NOCOLLAPSE,
  0+ 96,   0+ 96,   0+ 96,  PC_NOCOLLAPSE,
  0+105,   0+105,   0+105,  PC_NOCOLLAPSE,
  0+114,   0+114,   0+114,  PC_NOCOLLAPSE,
  0+123,   0+123,   0+123,  PC_NOCOLLAPSE,
  0+132,   0+132,   0+132,  PC_NOCOLLAPSE,
  0+141,   0+141,   0+141,  PC_NOCOLLAPSE,
  0+150,   0+150,   0+150,  PC_NOCOLLAPSE,
  0+159,   0+159,   0+159,  PC_NOCOLLAPSE,
  0+168,   0+168,   0+168,  PC_NOCOLLAPSE,
  0+177,   0+177,   0+177,  PC_NOCOLLAPSE,
  0+186,   0+186,   0+186,  PC_NOCOLLAPSE,
  0+195,   0+195,   0+195,  PC_NOCOLLAPSE,
  0+204,   0+204,   0+204,  PC_NOCOLLAPSE,
  0+213,   0+213,   0+213,  PC_NOCOLLAPSE,
  0+222,   0+222,   0+222,  PC_NOCOLLAPSE,
  0+231,   0+231,   0+231,  PC_NOCOLLAPSE,
  0+240,   0+240,   0+240,  PC_NOCOLLAPSE,

  0+ 15, -13+ 15,  55+ 15,  PC_NOCOLLAPSE,
  0+ 24, -13+ 24,  55+ 24,  PC_NOCOLLAPSE,
  0+ 33, -13+ 33,  55+ 33,  PC_NOCOLLAPSE,
  0+ 42, -13+ 42,  55+ 42,  PC_NOCOLLAPSE,
  0+ 51, -13+ 51,  55+ 51,  PC_NOCOLLAPSE,
  0+ 60, -13+ 60,  55+ 60,  PC_NOCOLLAPSE,
  0+ 69, -13+ 69,  55+ 69,  PC_NOCOLLAPSE,
  0+ 78, -13+ 78,  55+ 78,  PC_NOCOLLAPSE,
  0+ 87, -13+ 87,  55+ 87,  PC_NOCOLLAPSE,
  0+ 96, -13+ 96,  55+ 96,  PC_NOCOLLAPSE,
  0+105, -13+105,  55+105,  PC_NOCOLLAPSE,
  0+114, -13+114,  55+114,  PC_NOCOLLAPSE,
  0+123, -13+123,  55+123,  PC_NOCOLLAPSE,
  0+132, -13+132,  55+132,  PC_NOCOLLAPSE,
  0+141, -13+141,  55+141,  PC_NOCOLLAPSE,
  0+150, -13+150,  55+150,  PC_NOCOLLAPSE,
  0+159, -13+159,  55+159,  PC_NOCOLLAPSE,
  0+168, -13+168,  55+168,  PC_NOCOLLAPSE,
  0+177, -13+177,  55+177,  PC_NOCOLLAPSE,
  0+186, -13+186,  55+186,  PC_NOCOLLAPSE,
  0+195, -13+195,  55+195,  PC_NOCOLLAPSE,
  0+204, -13+204,     255,  PC_NOCOLLAPSE,
  0+213, -13+213,     255,  PC_NOCOLLAPSE,
  0+222, -13+222,     255,  PC_NOCOLLAPSE,
  0+231, -13+231,     255,  PC_NOCOLLAPSE,
  0+240, -13+240,     255,  PC_NOCOLLAPSE,

 44+ 15, -14+ 15,       0,  PC_NOCOLLAPSE,
 44+ 24, -14+ 24,       0,  PC_NOCOLLAPSE,
 44+ 33, -14+ 33,       0,  PC_NOCOLLAPSE,
 44+ 42, -14+ 42,       0,  PC_NOCOLLAPSE,
 44+ 51, -14+ 51,       0,  PC_NOCOLLAPSE,
 44+ 60, -14+ 60, -55+ 60,  PC_NOCOLLAPSE,
 44+ 69, -14+ 69, -55+ 69,  PC_NOCOLLAPSE,
 44+ 78, -14+ 78, -55+ 78,  PC_NOCOLLAPSE,
 44+ 87, -14+ 87, -55+ 87,  PC_NOCOLLAPSE,
 44+ 96, -14+ 96, -55+ 96,  PC_NOCOLLAPSE,
 44+105, -14+105, -55+105,  PC_NOCOLLAPSE,
 44+114, -14+114, -55+114,  PC_NOCOLLAPSE,
 44+123, -14+123, -55+123,  PC_NOCOLLAPSE,
 44+132, -14+132, -55+132,  PC_NOCOLLAPSE,
 44+141, -14+141, -55+141,  PC_NOCOLLAPSE,
 44+150, -14+150, -55+150,  PC_NOCOLLAPSE,
 44+159, -14+159, -55+159,  PC_NOCOLLAPSE,
 44+168, -14+168, -55+168,  PC_NOCOLLAPSE,
 44+177, -14+177, -55+177,  PC_NOCOLLAPSE,
 44+186, -14+186, -55+186,  PC_NOCOLLAPSE,
 44+195, -14+195, -55+195,  PC_NOCOLLAPSE,
 44+204, -14+204, -55+204,  PC_NOCOLLAPSE,
    255, -14+213, -55+213,  PC_NOCOLLAPSE,
    255, -14+222, -55+222,  PC_NOCOLLAPSE,
    255, -14+231, -55+231,  PC_NOCOLLAPSE,
    255, -14+242, -55+240,  PC_NOCOLLAPSE,

 44+ 15,       0,   0+ 15,  PC_NOCOLLAPSE,
 44+ 24,       0,   0+ 24,  PC_NOCOLLAPSE,
 44+ 33, -26+ 33,   0+ 33,  PC_NOCOLLAPSE,
 44+ 42, -26+ 42,   0+ 42,  PC_NOCOLLAPSE,
 44+ 51, -26+ 51,   0+ 51,  PC_NOCOLLAPSE,
 44+ 60, -26+ 60,   0+ 60,  PC_NOCOLLAPSE,
 44+ 69, -26+ 69,   0+ 69,  PC_NOCOLLAPSE,
 44+ 78, -26+ 78,   0+ 78,  PC_NOCOLLAPSE,
 44+ 87, -26+ 87,   0+ 87,  PC_NOCOLLAPSE,
 44+ 96, -26+ 96,   0+ 96,  PC_NOCOLLAPSE,
 44+105, -26+105,   0+105,  PC_NOCOLLAPSE,
 44+114, -26+114,   0+114,  PC_NOCOLLAPSE,
 44+123, -26+123,   0+123,  PC_NOCOLLAPSE,
 44+132, -26+132,   0+132,  PC_NOCOLLAPSE,
 44+141, -26+141,   0+141,  PC_NOCOLLAPSE,
 44+150, -26+150,   0+150,  PC_NOCOLLAPSE,
 44+159, -26+159,   0+159,  PC_NOCOLLAPSE,
 44+168, -26+168,   0+168,  PC_NOCOLLAPSE,
 44+177, -26+177,   0+177,  PC_NOCOLLAPSE,
 44+186, -26+186,   0+186,  PC_NOCOLLAPSE,
 44+195, -26+195,   0+195,  PC_NOCOLLAPSE,
 44+204, -26+204,   0+204,  PC_NOCOLLAPSE,
    255, -26+213,   0+213,  PC_NOCOLLAPSE,
    255, -26+222,   0+222,  PC_NOCOLLAPSE,
    255, -26+231,   0+231,  PC_NOCOLLAPSE,
    255, -26+240,   0+240,  PC_NOCOLLAPSE,

 44+ 15,       0,  55+ 15,  PC_NOCOLLAPSE,
 44+ 24,       0,  55+ 24,  PC_NOCOLLAPSE,
 44+ 33,       0,  55+ 33,  PC_NOCOLLAPSE,
 44+ 42, -39+ 42,  55+ 42,  PC_NOCOLLAPSE,
 44+ 51, -39+ 51,  55+ 51,  PC_NOCOLLAPSE,
 44+ 60, -39+ 60,  55+ 60,  PC_NOCOLLAPSE,
 44+ 69, -39+ 69,  55+ 69,  PC_NOCOLLAPSE,
 44+ 78, -39+ 78,  55+ 78,  PC_NOCOLLAPSE,
 44+ 87, -39+ 87,  55+ 87,  PC_NOCOLLAPSE,
 44+ 96, -39+ 96,  55+ 96,  PC_NOCOLLAPSE,
 44+105, -39+105,  55+105,  PC_NOCOLLAPSE,
 44+114, -39+114,  55+114,  PC_NOCOLLAPSE,
 44+123, -39+123,  55+123,  PC_NOCOLLAPSE,
 44+132, -39+132,  55+132,  PC_NOCOLLAPSE,
 44+141, -39+141,  55+141,  PC_NOCOLLAPSE,
 44+150, -39+150,  55+150,  PC_NOCOLLAPSE,
 44+159, -39+159,  55+159,  PC_NOCOLLAPSE,
 44+168, -39+168,  55+168,  PC_NOCOLLAPSE,
 44+177, -39+177,  55+177,  PC_NOCOLLAPSE,
 44+186, -39+186,  55+186,  PC_NOCOLLAPSE,
 44+195, -39+195,  55+195,  PC_NOCOLLAPSE,
 44+204, -39+204,     255,  PC_NOCOLLAPSE,
    255, -39+213,     255,  PC_NOCOLLAPSE,
    255, -39+222,     255,  PC_NOCOLLAPSE,
    255, -39+231,     255,  PC_NOCOLLAPSE,
    255, -39+240,     255,  PC_NOCOLLAPSE,

   0x81, 0x81, 0x83, PC_NOCOLLAPSE, 
   0x81, 0x81, 0x84, PC_NOCOLLAPSE,

	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	255,     255,     255,              0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\inodecnt.h ===
#ifndef _INODECNT_H_
#define _INODECNT_H_

typedef void * REQUEST_HANDLE;
typedef REQUEST_HANDLE * PREQUEST_HANDLE;
typedef void * ROSTER_DATA_HANDLE;

typedef struct T120PRODUCTVERSION
{
    DWORD           dwVersion;
    DWORD           dwExpirationDate; // (year<<16)+(month<<8)+day
    DWORD           dwInformation;
    DWORD           dwEarliestPossibleVersion;
    DWORD           dwMaxDifference;
    DWORD           dwReserved;
} T120PRODUCTVERSION, * PT120PRODUCTVERSION;

typedef struct USERDATAINFO
{
    UINT  cbData;
    PVOID pData;
    GUID* pGUID;
} USERDATAINFO, * PUSERDATAINFO;

typedef struct NC_ROSTER_NODE_ENTRY
{
    PWSTR               pwszNodeName;
    UINT                uNodeID;
    UINT                uSuperiorNodeID;
    BOOL                fMCU;
    ROSTER_DATA_HANDLE  hUserData;
} NC_ROSTER_NODE_ENTRY, * PNC_ROSTER_NODE_ENTRY;

typedef struct NC_ROSTER
{
    UINT                    uNumNodes;
    PWSTR                   pwszConferenceName;
    UINT_PTR                uConferenceID;
    UINT                    uLocalNodeID;
    NC_ROSTER_NODE_ENTRY    nodes[1];
} NC_ROSTER, * PNC_ROSTER;



#undef  INTERFACE
#define INTERFACE IDataConference

DECLARE_INTERFACE(IDataConference)
{
    STDMETHOD_(void, ReleaseInterface)( THIS ) PURE;

    STDMETHOD_(UINT_PTR, GetConferenceID) ( THIS ) PURE;

    STDMETHOD(Leave)                  ( THIS ) PURE;

    STDMETHOD(EjectUser)              ( THIS_
                                        UINT                uNodeID) PURE;

    STDMETHOD(Invite)                 ( THIS_
                                        LPCSTR              pcszAddress,
                                        USERDATAINFO        aUserDataInfoEntries[],
                                        UINT                cUserDataEntries,
                                        PREQUEST_HANDLE     phRequest) PURE;

    STDMETHOD(InviteResponse)         ( THIS_
                                        BOOL                fResponse) PURE;

    STDMETHOD(JoinResponse)           ( THIS_
                                        BOOL                fResponse) PURE;

    STDMETHOD(LaunchGuid)             ( THIS_
                                        const GUID*         pcGUID,
                                        UINT                auNodeIDs[],
                                        UINT                cNodes) PURE;

    STDMETHOD(SetUserData)(             THIS_
                                        const GUID*         pcGUID,
                                        UINT                cbData,
                                        LPVOID              pvData) PURE;
    STDMETHOD_(BOOL, IsSecure) ( THIS_) PURE;

    STDMETHOD(UpdateUserData)         ( THIS ) PURE;

    STDMETHOD(GetLocalAddressList)    ( THIS_
                                        LPWSTR              pwszBuffer,
                                        UINT                cchBuffer) PURE;
    STDMETHOD(CancelInvite)           ( THIS_
                                        REQUEST_HANDLE      hRequest) PURE;
    STDMETHOD(SetSecurity)              ( THIS_
                                          BOOL                fSecure) PURE;

    STDMETHOD(GetCred)                ( THIS_
                                        PBYTE*              ppbCred,
                                        DWORD*              pcbCred) PURE;

    STDMETHOD_(UINT, GetParentNodeID) ( THIS ) PURE;
};

typedef IDataConference * CONF_HANDLE;
typedef CONF_HANDLE     * PCONF_HANDLE;



#undef  INTERFACE
#define INTERFACE INodeControllerEvents

DECLARE_INTERFACE(INodeControllerEvents)
{
    STDMETHOD(OnConferenceStarted)(     THIS_
                                        CONF_HANDLE         hConference,
                                        HRESULT             hResult) PURE;
    STDMETHOD(OnConferenceEnded)(       THIS_
                                        CONF_HANDLE         hConference) PURE;
    STDMETHOD(OnRosterChanged)(         THIS_
                                        CONF_HANDLE         hConference,
                                        PNC_ROSTER          pRoster) PURE;
    STDMETHOD(OnIncomingInviteRequest)( THIS_
                                        CONF_HANDLE         hConference,
                                        PCWSTR              pcwszNodeName,
                                        PT120PRODUCTVERSION pRequestorVersion,
                                        PUSERDATAINFO       pUserDataInfoEntries,
                                        UINT                cUserDataEntries,
                                        BOOL                fSecure) PURE;
    STDMETHOD(OnIncomingJoinRequest)(   THIS_
                                        CONF_HANDLE         hConference,
                                        PCWSTR              pcwszNodeName,
                                        PT120PRODUCTVERSION pRequestorVersion,
                                        PUSERDATAINFO       pUserDataInfoEntries,
                                        UINT                cUserDataEntries) PURE;
    STDMETHOD(OnQueryRemoteResult)(     THIS_
                                        PVOID               pvCallerContext,
                                        HRESULT             hResult,
                                        BOOL                fMCU,
                                        PWSTR*              ppwszConferenceNames,
                                        PT120PRODUCTVERSION pVersion,
                                        PWSTR*              ppwszConfDescriptors) PURE;
    STDMETHOD(OnInviteResult)(          THIS_
                                        CONF_HANDLE         hConference,
                                        REQUEST_HANDLE      hRequest,
                                        UINT                uNodeID,
                                        HRESULT             hResult,
                                        PT120PRODUCTVERSION pVersion) PURE;
    STDMETHOD(OnUpdateUserData)(        THIS_
                                        CONF_HANDLE         hConference) PURE;
};



#undef  INTERFACE
#define INTERFACE INodeController

DECLARE_INTERFACE(INodeController)
{
    STDMETHOD_(void, ReleaseInterface)( THIS_) PURE;

    STDMETHOD(CheckVersion)(            THIS_
                                        PT120PRODUCTVERSION pRemoteVersion) PURE;

    STDMETHOD(QueryRemote)(             THIS_
                                        LPVOID              pCallerContext,
                                        LPCSTR              pcszAddress,
                                        BOOL                fSecure,
                                        BOOL                fIsConferenceActive) PURE;

    STDMETHOD(CancelQueryRemote)(       THIS_
                                        LPVOID              pCallerContext) PURE;

    STDMETHOD(CreateConference)(        THIS_
                                        LPCWSTR             pcwszConferenceName,
                                        LPCWSTR             pcwszPassword,
                                        PBYTE               pbHashedPassword,
                                        DWORD               cbHashedPassword,
                                        BOOL                fSecure,
                                        PCONF_HANDLE        phConference) PURE;

    STDMETHOD(JoinConference)(          THIS_
                                        LPCWSTR             pcwszConferenceName,
                                        LPCWSTR             pcwszPassword,
                                        LPCSTR              pcszAddress,
                                        BOOL                fSecure,
                                        PUSERDATAINFO       pUserDataInfoEntries,
                                        UINT                cUserDataEntries,
                                        PCONF_HANDLE        phConference) PURE;

    STDMETHOD(GetUserData)(             THIS_
                                        ROSTER_DATA_HANDLE  hUserData,
                                        const GUID*         pcGUID,
                                        PUINT               pcbData,
                                        LPVOID*             ppvData) PURE;
    STDMETHOD_(UINT, GetPluggableConnID) (THIS_
                                         LPCSTR pcszNodeAddress) PURE;
};


HRESULT WINAPI T120_CreateNodeController(INodeController **, INodeControllerEvents *);
BOOL WINAPI T120_GetSecurityInfoFromGCCID(DWORD dwGCCID, PBYTE pInfo, PDWORD pcbInfo);
DWORD WINAPI T120_TprtSecCtrl(DWORD dwCode, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

//
// Return codes
//

#define NC_ERR_FAC 0xfe00
#define NC_E(e)    (0x81000000UL | NC_ERR_FAC | (ULONG) (e))

enum UI_RC_ERRORS
{
    UI_RC_ALREADY_IN_CONFERENCE =                NC_E(0x01),
    UI_RC_CONFERENCE_ALREADY_EXISTS,
    UI_RC_INVALID_PASSWORD,
    UI_RC_NO_CONFERENCE_NAME,
    UI_RC_T120_FAILURE,
    UI_RC_UNKNOWN_CONFERENCE,
    UI_RC_BAD_TRANSPORT_NAME,
    UI_RC_USER_REJECTED,

    LAST_RC_GCC_MAPPED_ERROR = UI_RC_USER_REJECTED,

    UI_RC_T120_ALREADY_INITIALIZED,
    UI_RC_BAD_ADDRESS,
    UI_RC_NO_ADDRESS,
    UI_RC_NO_SUCH_CONFERENCE,
    UI_RC_CONFERENCE_CREATE_FAILED,
    UI_RC_BAD_PARAMETER,
    UI_RC_OUT_OF_MEMORY,
    UI_RC_CALL_GOING_DOWN,
    UI_RC_CALL_FAILED,
    UI_NO_SUCH_CONFERENCE,
    UI_RC_CONFERENCE_GOING_DOWN,
    UI_RC_INVALID_REQUEST,
    UI_RC_USER_DISCONNECTED,
    UI_RC_EXITING_CORE_UI,
    UI_RC_NO_NODE_NAME,
    UI_RC_INVALID_TRANSPORT_SETTINGS,
    UI_RC_REGISTER_CPI_FAILURE,
    UI_RC_CMP_FAILURE,
    UI_RC_TRANSPORT_DISABLED,
    UI_RC_TRANSPORT_FAILED,
    UI_RC_NOT_SUPPORTED,
    UI_RC_NOT_SUPPORTED_IN_BACKLEVEL,
    UI_RC_CONFERENCE_NOT_READY,
    UI_RC_NO_SUCH_USER_DATA,
    UI_RC_INTERNAL_ERROR,
    UI_RC_VERSION_REMOTE_INCOMPATIBLE,
    UI_RC_VERSION_LOCAL_INCOMPATIBLE,
    UI_RC_VERSION_REMOTE_EXPIRED,
    UI_RC_VERSION_LOCAL_UPGRADE_RECOMMENDED,
    UI_RC_VERSION_REMOTE_UPGRADE_RECOMMENDED,
    UI_RC_VERSION_REMOTE_OLDER,
    UI_RC_VERSION_REMOTE_NEWER,
    UI_RC_BACKLEVEL_LOADED,
    UI_RC_NULL_MODEM_CONNECTION,
    UI_RC_CANCELED,
    UI_RC_T120_REMOTE_NO_SECURITY,
    UI_RC_T120_REMOTE_DOWNLEVEL_SECURITY,
    UI_RC_T120_REMOTE_REQUIRE_SECURITY,
    UI_RC_T120_SECURITY_FAILED,
	UI_RC_T120_AUTHENTICATION_FAILED,
    UI_RC_NO_WINSOCK,

    //
    // Internal return codes
    //
    UI_RC_START_PRIMARY =                  NC_E(0x81),
    UI_RC_START_ALTERNATE =                NC_E(0x82)
};

#endif // _INODECNT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\incommon.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/incommon.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1996 Intel Corporation.
 *
 *      $Revision:   1.41  $
 *      $Date:   12 Feb 1997 09:34:42  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:    INCOMMON.H
 *
 *      Abstract:        commonly used structures
 *
 *
 *      Notes:
 *
 ***************************************************************************/
#ifndef INCOMMON_H
#define INCOMMON_H

#pragma pack(push,8)

#define CC_INVALID_HANDLE                    0

// CCRC_CALL_REJECTED reason codes (includes cause values)
#define CC_REJECT_NO_BANDWIDTH              1
#define CC_REJECT_GATEKEEPER_RESOURCES      2
#define CC_REJECT_UNREACHABLE_DESTINATION   3
#define CC_REJECT_DESTINATION_REJECTION     4
#define CC_REJECT_INVALID_REVISION          5
#define CC_REJECT_NO_PERMISSION             6
#define CC_REJECT_UNREACHABLE_GATEKEEPER    7
#define CC_REJECT_GATEWAY_RESOURCES         8
#define CC_REJECT_BAD_FORMAT_ADDRESS        9
#define CC_REJECT_ADAPTIVE_BUSY             10
#define CC_REJECT_IN_CONF                   11
#define CC_REJECT_ROUTE_TO_GATEKEEPER       12
#define CC_REJECT_CALL_FORWARDED            13
#define CC_REJECT_ROUTE_TO_MC               14
#define CC_REJECT_UNDEFINED_REASON          15
#define CC_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
#define CC_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
#define CC_REJECT_USER_BUSY                 18    // User is busy with another call
#define CC_REJECT_NO_ANSWER                 19    // Callee does not answer
#define CC_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
#define CC_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
#define CC_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
#define CC_REJECT_TIMER_EXPIRED             23    // Own timer expired
#define CC_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
#define CC_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call
#define CC_REJECT_SECURITY_DENIED           26    // Security is not compatible

// Q931 call types
#define CC_CALLTYPE_UNKNOWN                 0
#define CC_CALLTYPE_PT_PT                   1
#define CC_CALLTYPE_1_N                     2
#define CC_CALLTYPE_N_1                     3
#define CC_CALLTYPE_N_N                     4

// alias contants
#define CC_ALIAS_MAX_H323_ID                256
#define CC_ALIAS_MAX_H323_PHONE             128

// unicode character mask contants
#define CC_ALIAS_H323_PHONE_CHARS           L"0123456789#*,"
#define CC_ODOTTO_CHARS                     L".0123456789"


// alias type codes
#define CC_ALIAS_H323_ID                    1    // Return call information.
#define CC_ALIAS_H323_PHONE                 2    // H323 Phone Number.

// default port id's
#define CC_H323_GATE_DISC    1718 // Gatekeeper IP Discovery Port
#define CC_H323_GATE_STAT    1719 // Gatekeeper UDP Reg. and Status Port
#define CC_H323_HOST_CALL    1720 // Endpoint TCP Call Signalling Por

// Call creation goals
#define CC_GOAL_UNKNOWN                     0
#define CC_GOAL_CREATE                      1
#define CC_GOAL_JOIN                        2
#define CC_GOAL_INVITE                      3

// H245 non-standard message types
#define CC_H245_MESSAGE_REQUEST             0
#define CC_H245_MESSAGE_RESPONSE            1
#define CC_H245_MESSAGE_COMMAND             2
#define CC_H245_MESSAGE_INDICATION          3

// Call Control handle typedefs
typedef DWORD_PTR    CC_HLISTEN, *PCC_HLISTEN;
typedef DWORD_PTR    CC_HCONFERENCE, *PCC_HCONFERENCE;
typedef DWORD_PTR    CC_HCALL, *PCC_HCALL;
typedef DWORD_PTR    CC_HCHANNEL, *PCC_HCHANNEL;

// IP address in domain name format
typedef struct
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[255];     // UNICODE zstring
} CC_IP_DomainName_t;

// IP address in conventional dot notation
typedef struct
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[16];      // UNICODE zstring
} CC_IP_Dot_t;

// IP address in binary format
typedef struct
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    DWORD        dwAddr;         // binary address (host byte order)
} CC_IP_Binary_t;

typedef enum
{
    CC_IP_DOMAIN_NAME,
    CC_IP_DOT,
    CC_IP_BINARY
} CC_ADDRTYPE;

typedef struct _ADDR
{
    CC_ADDRTYPE nAddrType;
    BOOL        bMulticast;
    union
    {
        CC_IP_DomainName_t   IP_DomainName;
        CC_IP_Dot_t          IP_Dot;
        CC_IP_Binary_t       IP_Binary;
    } Addr;
} CC_ADDR, *PCC_ADDR;

typedef struct
{
    BYTE *pOctetString;
    WORD wOctetStringLength;
} CC_OCTETSTRING, *PCC_OCTETSTRING;

typedef struct
{
    CC_OCTETSTRING          sData;            // pointer to Octet data.
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
} CC_NONSTANDARDDATA, *PCC_NONSTANDARDDATA;

#define CC_MAX_PRODUCT_LENGTH 256
#define CC_MAX_VERSION_LENGTH 256
#define CC_MAX_DISPLAY_LENGTH 82

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    PCC_OCTETSTRING         pProductNumber;
    PCC_OCTETSTRING         pVersionNumber;
} CC_VENDORINFO, *PCC_VENDORINFO;

typedef struct
{
    PCC_VENDORINFO          pVendorInfo;
    BOOL                    bIsTerminal;
    BOOL                    bIsGateway;    // for now, the H323 capability will be hard-coded.
} CC_ENDPOINTTYPE, *PCC_ENDPOINTTYPE;

typedef struct
{
    WORD                    wType;
    WORD                    wPrefixLength;
    LPWSTR                  pPrefix;
    WORD                    wDataLength;   // UNICODE character count
    LPWSTR                  pData;         // UNICODE data.
} CC_ALIASITEM, *PCC_ALIASITEM;

typedef struct
{
    WORD                    wCount;
    PCC_ALIASITEM           pItems;
} CC_ALIASNAMES, *PCC_ALIASNAMES;

typedef struct _CONFERENCE_ID
{
    BYTE                    buffer[16];  // This is OCTET data, not ASCII.
} CC_CONFERENCEID, *PCC_CONFERENCEID;

#pragma pack(pop)

#endif    INCOMMON_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\iprop.h ===
//  IPROP.H
//
//      IProperty interface.
//
//      A simple property mechanism to query and set properties on media objects.
//
//  Created 12-Oct-96 [JonT]

#ifndef _IPROPERTY_H
#define _IPROPERTY_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

DECLARE_INTERFACE_(IProperty, IUnknown)
//DECLARE_INTERFACE(IProperty)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetProperty)(THIS_ DWORD dwProp, PVOID pBuf, LPUINT pcbBuf) PURE;
	STDMETHOD(SetProperty)(THIS_ DWORD dwProp, PVOID pBuf, UINT cbBuf) PURE;
};

typedef IProperty *LPIProperty;

// Currently defined properties
#define PROP_NET_SEND_STATS         4	// RTP_STATS
#define PROP_NET_RECV_STATS         5	// RTP_STATS
#define PROP_RTP_PAYLOAD	        6	// (dword) RTP payload type
#define PROP_VOLUME	                7	
#define PROP_SILENCE_LEVEL	        8	// (dword)
#define PROP_DURATION	            9	// (dword) avg. pkt duration in ms
#define PROP_SILENCE_DURATION	    10	// (dword) silence duration before recording stops, in ms
#define PROP_WAVE_DEVICE_TYPE	    11	// (dword) play,rec, full duplex capability
#define PROP_DUPLEX_TYPE	        12	// (dword) current mode
#define PROP_AUDIO_SPP	            13	// (dword)
#define PROP_AUDIO_SPS	            14	// (dword)
#define PROP_VOICE_SWITCH	        15	// (dword) auto or manual voice switching
#define PROP_AUDIO_STRENGTH	        16	// (dword) send audio strength
#define PROP_RECV_AUDIO_STRENGTH	17	// (dword) recv audio strength
#define PROP_RECORD_ON	            18	// (dword) enable or disable record
#define PROP_PLAY_ON	            19	// (dword) enable or disable playback
#define PROP_RECORD_DEVICE	        20	// (dword) device id of waveIn
#define PROP_PLAYBACK_DEVICE	    21	// (dword) device id of waveOut
#define PROP_VIDEO_CAPTURE_AVAILABLE 22	// (bool)
#define PROP_VIDEO_CAPTURE_DIALOGS_AVAILABLE 23 // (dword) CAPTURE_DIALOG_SOURCE and/or CAPTURE_DIALOG_FORMAT
#define PROP_VIDEO_CAPTURE_DIALOG   24	// (dword) CAPTURE_DIALOG_SOURCE or CAPTURE_DIALOG_FORMAT
#define PROP_VIDEO_FRAME_RATE       25	// (dword) FRAMERATE_LOW or FRAMERATE_HIGH
#define PROP_VIDEO_SIZE_AVAIL       26	// (dword) FRAME_CIF, FRAME_QCIF, FRAME_SQCIF
#define PROP_VIDEO_SIZE             27	// (dword) FRAME_CIF, FRAME_QCIF, FRAME_SQCIF
#define PROP_VIDEO_PREVIEW_ON		28	// (bool) enable/disable video preview
#define PROP_VIDEO_POSTPROCESSING_SUPPORTED		29	// (bool) used to query the datapump: TRUE is returned if codec supports post-processing
#define PROP_VIDEO_BRIGHTNESS		30	// (dword) sets the brightness of the video data displayed in the Remote window
#define PROP_VIDEO_CONTRAST			31	// (dword) sets the contrast of the video data displayed in the Remote window
#define PROP_VIDEO_SATURATION		32	// (dword) sets the saturation of the video data displayed in the Remote window
#define PROP_VIDEO_IMAGE_QUALITY	33	// (dword) a number between 100 (low quality) and 10000 (high quality)
#define PROP_VIDEO_RESET_BRIGHTNESS	34	// (dword) restores the default brightness of the video data displayed in the Remote window
#define PROP_VIDEO_RESET_CONTRAST	35	// (dword) restores the default contrast of the video data displayed in the Remote window
#define PROP_VIDEO_RESET_SATURATION	36	// (dword) restores the default saturation of the video data displayed in the Remote window
#define PROP_VIDEO_RESET_IMAGE_QUALITY	37	// (dword) a number between 100 (low quality) and 10000 (high quality)
#define PROP_VIDEO_AUDIO_SYNC		38	// (bool) enable A/V sync
#define PROP_MAX_PP_BITRATE			39	// (dword) max point-to-point bitrate of current connection

#define PROP_CHANNEL_ENABLED		41	// (bool) independently enable send/receive on a channel
#define PROP_LOCAL_FORMAT_ID		42	// (dword) unique ID of local compression format
#define PROP_REMOTE_FORMAT_ID		43  // (dword) unique ID of remote compression format
#define PROP_TS_TRADEOFF			44  // (dword) value of temporal/spatial tradeoff (video quality)
#define PROP_REMOTE_TS_CAPABLE		45	// (bool) temporal/spatial tradeoff is remotely controllable
#define PROP_TS_TRADEOFF_IND		46	// (dword) internally set by control channel only

#define PROP_PAUSE_SEND				50	// (bool) disables packet transmission, when read, indicates the current state of the network stream
#define PROP_PAUSE_RECV				51	// (bool) disables packet reception, when read, indicates the current state of the network stream

#define PROP_REMOTE_PAUSED			52	// (bool, read-only) channel is paused at remote end
#define PROP_VIDEO_PREVIEW_STANDBY	54	// (bool) stop preview but leave capture device open
#define PROP_LOCAL_PAUSE_SEND   	55	// (bool) disables packet transmission, sticky local state
#define PROP_LOCAL_PAUSE_RECV   	56	// (bool) disables packet reception, sticky local state

#define PROP_CAPTURE_DEVICE	        57	// (dword) device id of capture device
#define PROP_AUDIO_JAMMED	58 // (bool) TRUE if the audio device is
                              // failing to open or if another application
                              // owns the audio device
#define PROP_AUDIO_AUTOMIX	59  // (bool) enable self-adjusting mixer

// Equates used by properties

#define CAPTURE_DIALOG_SOURCE       1
#define CAPTURE_DIALOG_FORMAT       2
#define FRAMERATE_LOW               1
#define FRAMERATE_HIGH              2
#define FRAME_SQCIF                 1
#define FRAME_QCIF                  2
#define FRAME_CIF                   4
#define VOICE_SWITCH_AUTO			1
#define VOICE_SWITCH_MIC_ON			2
#define VOICE_SWITCH_MIC_OFF		4
#define DUPLEX_TYPE_FULL			1
#define DUPLEX_TYPE_HALF			0



#include <poppack.h> /* End byte packing */

#endif //_IPROPERTY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\intlutil.h ===
// File: intl.h

#ifndef _INTL_H_
#define _INTL_H_

#ifdef __cplusplus
extern "C" {
#endif
// This needs to be loaded by the only code that is not C++ (app sharing)
HINSTANCE NMINTERNAL LoadNmRes(LPCTSTR pszFileFormat);
#ifdef __cplusplus
}
#endif

#endif /* _INTL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\iras.h ===
/*
 *  	File: iras.h
 *
 *      Gatekeeper status interface header file
 *
 *		Revision History:
 *
 *		08/28/98	mikev	created 
 *      
 */

#ifndef _IRAS_H
#define _IRAS_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

// RAS event codes
#define RAS_REG_TIMEOUT     0  // GK did not respond
#define RAS_REG_CONFIRM     1  // received RCF (registration confirmed)
#define RAS_UNREG_CONFIRM   2  // received UCF (unregistration confirmed) 
#define RAS_REJECTED        3  // received RRJ (registration rejected)
#define RAS_UNREG_REQ       4  // received URQ 
                                        // (unregistration request - means that  
                                        // gatekeeper booted the endpoint off)

// Note that if RRJ or URQ is received, no calls can be placed until 
// successfully registering.

// reason codes for RRJ.  Note that these map to the ASN.1 defined reason
// values in H.225. But the ASN.1 headers aren't exposed to the world.
// It would cause build nightmares to do so. The headers are generated by the 
// ASN.1 compiler from ASN.1 source that is sometimes updated. Sometimes
// duplicate names in the source result in name decoration in the generated headers
// and that causes compilation errors in anything that references what changed.

// fortunately, the code deep in the stack that actually propagates these upward 
// IS exposed to both headers, and has compile-time tests for equality.  If 
// these don't match the real codes, that code will not compile

#define RRJ_DISCOVERY_REQ       1  // discovery required 
#define RRJ_INVALID_REVISION    2
#define RRJ_INVALID_CALL_ADDR   3
#define RRJ_INVALID_RAS_ADDR    4
#define RRJ_DUPLICATE_ALIAS     5
#define RRJ_INVALID_TERMINAL_TYPE   6
#define RRJ_UNDEFINED           7
#define RRJ_TRANSPORT_NOT_SUPPORTED 8
#define RRJ_TRANSPORT_QOS_NOT_SUPPORTED 9
#define RRJ_RESOURCE_UNAVAILABLE    10
#define RRJ_INVALID_ALIAS       11
#define RRJ_SECURITY_DENIAL     12

// reason codes for GK initiated Unregistration Request

#define URQ_REREG_REQUIRED  1  // GK wants another registration
#define URQ_TTL_EXPIRED     2  // TimeToLive expired
#define URQ_SECURITY_DENIAL 3
#define URQ_UNDEFINED       4 

// reason codes for Admission Reject (ARJ)

#define ARJ_CALLEE_NOT_REGISTERED    1
#define ARJ_INVALID_PERMISSION       2
#define ARJ_REQUEST_DENIED           3
#define ARJ_UNDEFINED                4
#define ARJ_CALLER_NOT_REGISTERED    5
#define ARJ_ROUTE_TO_GK              6
#define ARJ_INVALID_ENDPOINT_ID      7
#define ARJ_RESOURCE_UNAVAILABLE     8
#define ARJ_SECURTY_DENIAL           9
#define ARJ_QOS_CONTROL_NOT_SUPPORTED 10
#define ARJ_INCOMPLETE_ADDRESS       11
#define MAX_ARJ_H225_REASON          ARJ_INCOMPLETE_ADDRESS
// The following is not a real H.225 reason code for ARJ.   
// It is generated internally when there is an ARJ timeout
#define ARJ_TIMEOUT MAX_ARJ_H225_REASON+1

typedef  VOID (__stdcall *RASNOTIFYPROC)(DWORD dwRasEvent, HRESULT hReason);
   

#include <poppack.h> /* End byte packing */
#endif	//#ifndef _IRAS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\ividrdr.h ===
//  IVIDRDR.H
//
//      IVideoRender interface.
//
//      Used by videoconferencing UI to drive frame viewing.
//
//  Created 12-Oct-96 [JonT]

#ifndef _IVIDEORENDER_H
#define _IVIDEORENDER_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define FRAME_RECEIVE   1
#define FRAME_SEND      2       // Preview frame

typedef struct _FRAMECONTEXT
{
    LPBITMAPINFO lpbmi;
    void* lpData;
    DWORD_PTR dwReserved;
	LPRECT lpClipRect;
} FRAMECONTEXT, *LPFRAMECONTEXT;


typedef void (CALLBACK *LPFNFRAMEREADY) (DWORD_PTR);

DECLARE_INTERFACE_(IVideoRender, IUnknown)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;
	
	// IVideoRender methods
	STDMETHOD (Init)(THIS_ DWORD_PTR dwUser, LPFNFRAMEREADY pfCallback) PURE;
	STDMETHOD (Done)(THIS) PURE;
	STDMETHOD (GetFrame)(THIS_ FRAMECONTEXT* pfc) PURE;
	STDMETHOD (ReleaseFrame)(THIS_ FRAMECONTEXT *pfc) PURE;

};
#if(0)
// This is  no longer used anywhere
// outside of NAC.DLL, and is almost obsolete
//DECLARE_INTERFACE_(IMediaProp, IUnknown)
DECLARE_INTERFACE_(IVideoRenderOld, IUnknown)
{

	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(Init)(THIS_ DWORD dwFlags, HANDLE hEvent) PURE;
    STDMETHOD(Done)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetFrame)(THIS_ DWORD dwFlags, FRAMECONTEXT* pFrameContext) PURE;
    STDMETHOD(ReleaseFrame)(THIS_ DWORD dwFlags, FRAMECONTEXT* pFrameContext) PURE;
};

typedef IVideoRenderOld *LPIVideoRender;
#endif

#include <poppack.h> /* End byte packing */

#endif //_IVIDEORENDER_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\mappedfile.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
//
// This header contains classes used to manage the memory mapped file for this DLL
//

#ifdef __cplusplus

class CScopeMutex
{
public:
    CScopeMutex()
        : m_hMutex(0)
        {};
    ~CScopeMutex() { MutexRelease(); }
    BOOL Create(LPCTSTR szMutex, unsigned long ulWait)
    {
	    m_hMutex = CreateMutex( NULL, FALSE, szMutex );
        if (m_hMutex)
        {
    	    WaitForSingleObject(m_hMutex, ulWait);
			return TRUE;
        }
        return FALSE;
    }
    void Release()
    {
        MutexRelease();
    }

private:
    HANDLE m_hMutex;

    inline void MutexRelease()
    {
        if (m_hMutex)
        {
	        ReleaseMutex(m_hMutex);
	        CloseHandle(m_hMutex);
            m_hMutex = 0;
        }
    }
};

class CMemMappedFile 
{
public:
    CMemMappedFile()     
        : m_hMappedFile(0)
        , m_pvMappedAddr(0)
        , m_fFirstOpen(FALSE)
        {};
    ~CMemMappedFile() { Close(); }
    BOOL Open(LPCTSTR szName, unsigned long ulMemSize);
    BOOL AccessMem(void **ppvMappedAddr);
    void Close();
    BOOL FirstOpen() { return m_fFirstOpen; }

private:
    HANDLE m_hMappedFile;
    void *m_pvMappedAddr;
    BOOL m_fFirstOpen;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\isdmapi.h ===
#ifndef _ISDMAPI_H_
#define _ISDMAPI_H_

/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/isdmapi.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.12  $
 *	$Date:   Aug 15 1996 14:23:36  $
 *	$Author:   dmgorlic  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#include "apierror.h"

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport

typedef DWORD	HSTATSESSION,	*LPHSTATSESSION;

#define MAX_SESSNAME_LENGTH		25 
#define MAX_MODNAME_LENGTH		20
#define MAX_SESSIDENT_LENGTH	256 //consistant with max cName length
#define MAX_STATNAME_LENGTH		256
//stat item string name
typedef char STATNAME[MAX_STATNAME_LENGTH], *LPSTATNAME;
//session string name
typedef char SESSIONNAME[MAX_SESSNAME_LENGTH], *LPSESSIONNAME;
//module name
typedef char MODULENAME[MAX_MODNAME_LENGTH], *LPMODULENAME;
//identifier length
typedef char SESSIONIDENT[MAX_SESSIDENT_LENGTH], *LPSESSIONIDENT;


typedef struct STATSTRUCT
{
	DWORD		dwStructSize;				// size of the structure
	STATNAME	szStatName;					// string name of the stat item
	DWORD		dwToken;					// session unique id of the stat item
	DWORD		dwValue;					// value(data) of the stat item
	DWORD		dwLow;						// low value for range of value
	DWORD		dwHigh;						// hi value for range of value
	DWORD		dwLastUpdate;				// time stamp of last update
} STAT, *LPSTAT;

// Typedefs for ISDM application entry points to ensure stricter checking
// when functions are called via pointers
//
typedef HRESULT		(*ISD_REGISTER_SESSION)		(LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_CREATESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_UNREGISTERSESSION)	(HSTATSESSION);
typedef HRESULT		(*ISD_DELETESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_UPDATESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_GETFIRSTSESSION)		(LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_GETNEXTSESSION)		(HSTATSESSION, LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_GETNUMSESSIONS)		(WORD *);
typedef HRESULT		(*ISD_GETFIRSTSTAT)			(HSTATSESSION, LPSTAT);
typedef HRESULT		(*ISD_GETNEXTSTAT)			(HSTATSESSION, LPSTAT, LPSTAT);
typedef HRESULT		(*ISD_GETNUMSTATS)			(HSTATSESSION, WORD *);
typedef HRESULT		(*ISD_GETSESSIONSTATS)		(HSTATSESSION, LPSTAT, WORD);

typedef struct _ISDMAPI
{
	ISD_REGISTER_SESSION	ISD_RegisterSession;
	ISD_CREATESTAT			ISD_CreateStat;
	ISD_UNREGISTERSESSION	ISD_UnregisterSession;
	ISD_DELETESTAT			ISD_DeleteStat;
	ISD_UPDATESTAT			ISD_UpdateStat;
	ISD_GETFIRSTSESSION		ISD_GetFirstSession;
	ISD_GETNEXTSESSION		ISD_GetNextSession;
	ISD_GETNUMSESSIONS		ISD_GetNumSessions;
	ISD_GETFIRSTSTAT		ISD_GetFirstStat;
	ISD_GETNEXTSTAT			ISD_GetNextStat;
	ISD_GETNUMSTATS			ISD_GetNumStats;
	ISD_GETSESSIONSTATS		ISD_GetSessionStats;
}
ISDMAPI, *LPISDMAPI;

//HRESULT error defines
#define ISDM_ERROR_BASE             ERROR_LOCAL_BASE_ID

#define ERROR_HIT_MAX_SESSIONS      ISDM_ERROR_BASE + 1
#define ERROR_HIT_MAX_STATS         ISDM_ERROR_BASE + 2
#define ERROR_ACCESSING_SESSION     ISDM_ERROR_BASE + 3
#define ERROR_SESSION_EXISTS        ISDM_ERROR_BASE + 4
#define ERROR_INVALID_SESS_HANDLE   ISDM_ERROR_BASE + 5
#define ERROR_INVALID_STAT_HANDLE   ISDM_ERROR_BASE + 6
#define ERROR_NO_SESSIONS           ISDM_ERROR_BASE + 7
#define ERROR_NO_STATS              ISDM_ERROR_BASE + 8
#define ERROR_SESSION_NOT_FOUND     ISDM_ERROR_BASE + 9
#define ERROR_MUTEX_WAIT_FAIL       ISDM_ERROR_BASE + 10
#define ERROR_TOKEN_NOT_UNIQUE      ISDM_ERROR_BASE + 11
#define ERROR_NO_FREE_SESSIONS      ISDM_ERROR_BASE + 12
#define ERROR_SESSION_GET_FAIL      ISDM_ERROR_BASE + 13
#define ERROR_BAD_STAT_ARRAY        ISDM_ERROR_BASE + 14
#define ERROR_BAD_STAT_TOKEN        ISDM_ERROR_BASE + 15
#define ERROR_BAD_SESSION_NAME      ISDM_ERROR_BASE + 16
#define ERROR_NO_FREE_STATS         ISDM_ERROR_BASE + 17
#define ERROR_BAD_MODULE_NAME       ISDM_ERROR_BASE + 18

//token defines
//RRCM
#define RRCM_LOCAL_STREAM				1
#define RRCM_REMOTE_STREAM				2

#define ISDM_TOKEN_BASE 0x0000

#define ISDM_CC_CODEC					ISDM_TOKEN_BASE + 1
#define ISDM_CC_REMOTE					ISDM_TOKEN_BASE + 2
#define ISDM_CC_LOCAL					ISDM_TOKEN_BASE + 3

#define ISDM_RRCM_BASE 0x1000

#define ISDM_SSRC						ISDM_RRCM_BASE + 1
#define ISDM_NUM_PCKT_SENT				ISDM_RRCM_BASE + 2
#define ISDM_NUM_BYTES_SENT				ISDM_RRCM_BASE + 3
#define ISDM_FRACTION_LOST				ISDM_RRCM_BASE + 4
#define ISDM_CUM_NUM_PCKT_LOST			ISDM_RRCM_BASE + 5
#define ISDM_XTEND_HIGHEST_SEQ_NUM		ISDM_RRCM_BASE + 6
#define ISDM_INTERARRIVAL_JITTER		ISDM_RRCM_BASE + 7
#define ISDM_LAST_SR					ISDM_RRCM_BASE + 8
#define ISDM_DLSR						ISDM_RRCM_BASE + 9
#define ISDM_NUM_BYTES_RCVD				ISDM_RRCM_BASE + 10
#define ISDM_NUM_PCKT_RCVD				ISDM_RRCM_BASE + 11
#define ISDM_NTP_FRAC					ISDM_RRCM_BASE + 12
#define ISDM_NTP_SEC					ISDM_RRCM_BASE + 13
#define ISDM_WHO_AM_I					ISDM_RRCM_BASE + 14
#define ISDM_FDBK_FRACTION_LOST			ISDM_RRCM_BASE + 15
#define ISDM_FDBK_CUM_NUM_PCKT_LOST		ISDM_RRCM_BASE + 16
#define ISDM_FDBK_LAST_SR				ISDM_RRCM_BASE + 17
#define ISDM_FDBK_DLSR					ISDM_RRCM_BASE + 18
#define ISDM_FDBK_INTERARRIVAL_JITTER	ISDM_RRCM_BASE + 19


//
//Supplier calls 
//

//registration call
//This call is made whenever a new session is desired. The session name passed in must be unique
//across all sessions.
extern DllExport HRESULT ISD_RegisterSession
(
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phSession			// return; handle to new session
);

//stat creation call
//add 1+ stat item(s) to a session. 
extern DllExport HRESULT ISD_CreateStat
(
	HSTATSESSION		hSession,			// handle to session
	LPSTAT				pStatArray,		// array of structs holding new stats to create
	WORD				wNumItems			// size of array(number of new stats)
);

//unregistration call
//deletes a session and all associated stat structs
extern DllExport HRESULT ISD_UnregisterSession
(
	HSTATSESSION		hSession			// handle of session to remove
);

//stat deletion call
//delete 1+ stat item(s) from a session
extern DllExport HRESULT ISD_DeleteStat
(
	HSTATSESSION		hSession,			// handle to session
	LPSTAT				pStatArray,			// array of structs
	WORD				wNumItems			// size of array(number of stats to remove)
);

//set stat data call
extern DllExport HRESULT ISD_UpdateStat
(
	HSTATSESSION		hSession,			// handle of session with stat item(s)
	LPSTAT				pStatArray,			// array of structs holding items to update
	WORD				wNumItems			// size of array(number of stats to update)
);

//
//Consumer calls 
//

//query calls
//session query
extern DllExport HRESULT ISD_GetFirstSession
(
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phSession			// return; the session handle or null if empty list
);

//GetNext uses hCurSession to determine the next item..returned in phNextSession
extern DllExport HRESULT ISD_GetNextSession
(
	HSTATSESSION		hCurSession,		// the current session handle
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phNextSession		// return; the session handle or null if at the end
);

extern DllExport HRESULT ISD_GetNumSessions
(
	WORD				*wNumSessions		// return; number of sessions
);

//stat query..retreive structs for the first time(get unique ids..initial values..etc)
extern DllExport HRESULT ISD_GetFirstStat
(
	HSTATSESSION		hSession,			// handle to session containing stat
	LPSTAT				pStat				// return; filled struct for first stat item
);

//pCurrentStat and pNextStat can be identical for saving memory.
extern DllExport HRESULT ISD_GetNextStat
(
	HSTATSESSION		hSession,			// handle to session containing stat
	LPSTAT				pCurrentStat,		// pointer to current stat item(for determining next)
	LPSTAT				pNextStat			// return; filled struct for next stat item
);

extern DllExport HRESULT ISD_GetNumStats
(
	HSTATSESSION		hSession,			// what session we are interested in
	WORD				*wNumStats			// return; number of stats in session
);

//stat retreival 
extern DllExport HRESULT ISD_GetSessionStats
(
	HSTATSESSION		hSession,		// what session we are interested in
	LPSTAT				pStatArray,	// return; array of structs holding items 
	WORD				wNumStats		// return; number of items in session
);

//void			StorePartofStat(LPSTAT pStat,LPCSTR szName,LPBYTE pValue,DWORD dwType);

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // ISDTAT.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\isdmapi2.h ===
#ifndef __ISDMAPI2_H__
#define __ISDMAPI2_H__

/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/isdmapi2.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.10  $
 *	$Date:   08 Oct 1996 17:29:42  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport


//reserved key define for backwards compatability with old API
//all ISDM1 data falls under this key
#define BACKCOMP_KEY	"BackCompatability"
//value type defines
#define DWORD_VALUE			2
#define STRING_VALUE		3
#define BINARY_VALUE		4

//handle prefix bit codes(these get appended to the actual memmap offset to generate a handle)
#define	KEYBITCODE		0x6900
#define VALUEBITCODE	0xAB00
#define ROOTBITCODE		0x1234

//in case we want multiple roots, this can expand
#define ROOT_MAIN	0x0000

//this is the main root keys handle define
#define MAIN_ROOT_KEY MAKELONG(ROOT_MAIN,ROOTBITCODE)

//typedefs for each kind of handle
typedef DWORD KEY_HANDLE,*LPKEY_HANDLE;
typedef DWORD VALUE_HANDLE,*LPVALUE_HANDLE;
typedef DWORD EVENT_HANDLE,*LPEVENT_HANDLE;

//this structure is an internal status structure
//my test app accesses this for debug. You should never need this.
typedef struct INFODATASTRUCT
{
	UINT			uBindCount;
	UINT			uNumKeys;
	UINT			uMaxKeys;
	UINT			uNumValues;
	UINT			uMaxValues;
	UINT			uNumTableEntries;
	UINT			uMaxTableEntries;
	UINT			uNumEvents;
	UINT			uMaxEvents;
	DWORD			dwBytesFree;
	DWORD			dwMaxChars;
} INFO_DATA, *LPINFO_DATA;

//function typedefs
//supplier
typedef HRESULT (*ISD_CREATEKEY)		(KEY_HANDLE, LPCSTR, LPKEY_HANDLE);
typedef HRESULT (*ISD_CREATEVALUE)		(KEY_HANDLE, LPCSTR, DWORD,CONST BYTE *,DWORD,LPVALUE_HANDLE);
typedef HRESULT (*ISD_SETVALUE)			(KEY_HANDLE, VALUE_HANDLE, LPCSTR, DWORD, CONST BYTE *, DWORD);
//consumer
typedef HRESULT (*ISD_OPENKEY)			(KEY_HANDLE, LPCSTR, LPKEY_HANDLE);
typedef HRESULT (*ISD_OPENVALUE)		(KEY_HANDLE, LPCSTR, LPVALUE_HANDLE);
typedef HRESULT (*ISD_ENUMKEY)			(KEY_HANDLE, DWORD, LPSTR, LPDWORD, LPKEY_HANDLE);
typedef HRESULT (*ISD_ENUMVALUE)		(KEY_HANDLE, DWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD, LPDWORD, LPVALUE_HANDLE);
typedef HRESULT (*ISD_QUERYINFOKEY)		(KEY_HANDLE, LPSTR, LPDWORD, LPDWORD, LPDWORD);
typedef HRESULT (*ISD_QUERYINFOVALUE)	(VALUE_HANDLE, LPSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD, LPDWORD, LPKEY_HANDLE);
typedef HRESULT (*ISD_NOTIFYCHANGEVALUE)	(VALUE_HANDLE, HANDLE);
//used by either
typedef HRESULT (*ISD_DELETEKEY)		(KEY_HANDLE);
typedef HRESULT	(*ISD_DELETEVALUE)		(KEY_HANDLE, VALUE_HANDLE, LPCSTR);
typedef BOOL	(*ISD_GETSTRUCTDATA)	(LPINFO_DATA);
typedef BOOL	(*ISD_ISVALIDKEYHANDLE)	(KEY_HANDLE);
typedef BOOL	(*ISD_ISVALIDVALUEHANDLE)	(VALUE_HANDLE);
typedef HRESULT (*ISD_COMPACTMEMORY)	();

//structure for ISDM entry points
typedef struct _ISDM2API
{
	ISD_CREATEKEY			ISD_CreateKey;
	ISD_CREATEVALUE			ISD_CreateValue;
	ISD_SETVALUE			ISD_SetValue;
	ISD_OPENKEY				ISD_OpenKey;
	ISD_OPENVALUE			ISD_OpenValue;
	ISD_ENUMKEY				ISD_EnumKey;
	ISD_ENUMVALUE			ISD_EnumValue;
	ISD_QUERYINFOKEY		ISD_QueryInfoKey;
	ISD_QUERYINFOVALUE		ISD_QueryInfoValue;
	ISD_NOTIFYCHANGEVALUE	ISD_NotifyChangeValue;
	ISD_DELETEKEY			ISD_DeleteKey;
	ISD_DELETEVALUE			ISD_DeleteValue;
	ISD_GETSTRUCTDATA		ISD_GetStructData;
	ISD_ISVALIDKEYHANDLE	ISD_IsValidKeyHandle;
	ISD_ISVALIDVALUEHANDLE	ISD_IsValidValueHandle;
	ISD_COMPACTMEMORY		ISD_CompactMemory;
}
ISDM2API, *LPISDM2API;

//HRESULT error defines
#define ISDM_ERROR_BASEB 0x8000

#define ERROR_INVALID_KEY_HANDLE		ISDM_ERROR_BASEB + 1
#define ERROR_MORE_DATA_AVAILABLE		ISDM_ERROR_BASEB + 2
#define ERROR_INVALID_STRING_POINTER	ISDM_ERROR_BASEB + 3
#define ERROR_KEY_NOT_FOUND				ISDM_ERROR_BASEB + 4
#define ERROR_VALUE_NOT_FOUND			ISDM_ERROR_BASEB + 5
#define ERROR_NO_MORE_SESSIONS			ISDM_ERROR_BASEB + 6
#define ERROR_INVALID_VALUE_HANDLE		ISDM_ERROR_BASEB + 7
#define ERROR_FAILED_TO_GET_MEM_KEY		ISDM_ERROR_BASEB + 8
#define ERROR_NO_PARENT					ISDM_ERROR_BASEB + 9
#define ERROR_NO_PREV_SIBLING			ISDM_ERROR_BASEB + 10
#define ERROR_NO_NEXT_SIBLING			ISDM_ERROR_BASEB + 11
#define ERROR_NO_CHILD					ISDM_ERROR_BASEB + 12
#define ERROR_INVALID_VALUE_TYPE		ISDM_ERROR_BASEB + 13
#define ERROR_MALLOC_FAILURE			ISDM_ERROR_BASEB + 14
#define ERROR_CREATE_KEY_FAILURE		ISDM_ERROR_BASEB + 15
#define ERROR_NULL_PARAM				ISDM_ERROR_BASEB + 16
#define ERROR_VALUE_EXISTS				ISDM_ERROR_BASEB + 17
#define ERROR_FAILED_TO_GET_MEM_VALUE	ISDM_ERROR_BASEB + 18
#define ERROR_NO_MORE_STR_SPACE			ISDM_ERROR_BASEB + 19
#define ERROR_KEY_EXISTS				ISDM_ERROR_BASEB + 20
#define ERROR_NO_MORE_KEY_SPACE			ISDM_ERROR_BASEB + 21
#define ERROR_NO_MORE_VALUE_SPACE		ISDM_ERROR_BASEB + 22
#define ERROR_INVALID_PARAM				ISDM_ERROR_BASEB + 23
#define ERROR_ROOT_DELETE				ISDM_ERROR_BASEB + 24
#define ERROR_NULL_STRING_TABLE_ENTRY	ISDM_ERROR_BASEB + 25
#define ERROR_NO_MORE_TABLE_ENTRIES		ISDM_ERROR_BASEB + 26
#define ERROR_ISDM_UNKNOWN				ISDM_ERROR_BASEB + 27
#define ERROR_NOT_IMPLEMENTED			ISDM_ERROR_BASEB + 28
#define ERROR_MALLOC_FAILED				ISDM_ERROR_BASEB + 29
#define ERROR_FAILED_TO_GET_MEM_TABLE	ISDM_ERROR_BASEB + 30
#define ERROR_SEMAPHORE_WAIT_FAIL		ISDM_ERROR_BASEB + 31
#define ERROR_NO_MORE_EVENTS			ISDM_ERROR_BASEB + 32
#define ERROR_INVALID_EVENT				ISDM_ERROR_BASEB + 33
#define ERROR_INVALID_EVENT_HANDLE		ISDM_ERROR_BASEB + 34
#define ERROR_EVENT_NONEXISTANT			ISDM_ERROR_BASEB + 35
#define ERROR_VALUE_DOES_NOT_EXIST		ISDM_ERROR_BASEB + 36
#define ERROR_BUFFER_TOO_SMALL			ISDM_ERROR_BASEB + 37

//token defines..these may just disappear
//RRCM
#define RRCM_LOCAL_STREAM				1
#define RRCM_REMOTE_STREAM				2
#define ISDM_RRCM_BASE 0x1000

#define ISDM_SSRC						ISDM_RRCM_BASE + 1
#define ISDM_NUM_PCKT_SENT				ISDM_RRCM_BASE + 2
#define ISDM_NUM_BYTES_SENT				ISDM_RRCM_BASE + 3
#define ISDM_FRACTION_LOST				ISDM_RRCM_BASE + 4
#define ISDM_CUM_NUM_PCKT_LOST			ISDM_RRCM_BASE + 5
#define ISDM_XTEND_HIGHEST_SEQ_NUM		ISDM_RRCM_BASE + 6
#define ISDM_INTERARRIVAL_JITTER		ISDM_RRCM_BASE + 7
#define ISDM_LAST_SR					ISDM_RRCM_BASE + 8
#define ISDM_DLSR						ISDM_RRCM_BASE + 9
#define ISDM_NUM_BYTES_RCVD				ISDM_RRCM_BASE + 10
#define ISDM_NUM_PCKT_RCVD				ISDM_RRCM_BASE + 11
#define ISDM_NTP_FRAC					ISDM_RRCM_BASE + 12
#define ISDM_NTP_SEC					ISDM_RRCM_BASE + 13
#define ISDM_WHO_AM_I					ISDM_RRCM_BASE + 14

//
//Supplier API
//

//NOTE: always refer to the Win32 Registry equivalent call for more information on the functionality of the call
 
//The create key call is similar to the RegCreateKeyEx call from Win32 in functionality
//NOTE: This call will create the new key or simply return the handle of the key if it already
//exists
extern DllExport HRESULT ISD_CreateKey
(
	KEY_HANDLE hParentKey,	//The key from which to create the new key(can be MAIN_ROOT_KEY)
	LPCSTR lpSubKey,		//the subkey to create.(see RegCreateKeyEx for details)
	LPKEY_HANDLE lphReturnKey//the handle of the newly created key
);

//The create value call is not part of the Win32 reg calls. It is here for symmetry in my API
//I prefer to use CreateValue then SetValue for my values, you can simply use SetValue and ignore
//CreateValue if you wish. The reason the registry has no such call is because they don't have
//a notion of a handle to a value. I felt it was very useful to have direct handles to the values for
//subsequent supplier or consumer calls.
//NOTE: If the type is STRING, you need to include the null terminator for the string in the size(cbData).
extern DllExport HRESULT ISD_CreateValue
(
	KEY_HANDLE hKey,				//handle to the key that will own the new value
	LPCSTR lpName,					//string ID of the value to be create
	DWORD dwType,					//type of value to create(DWORD,STRING,BINARY)
	CONST BYTE *lpData,				//pointer to value data	
	DWORD cbData,					//size of the value data buffer
	LPVALUE_HANDLE lphReturnValue	//return handle to the newly created value
);

//SetValue is similar to the Win32 RegSetValueEx call
//Note: If you have the value handle, you don't need to pass the key handle or lpName
//NOTE: If the type is STRING, you need to include the null terminator for the string in the size(cbData).
DllExport HRESULT ISD_SetValue
(
	KEY_HANDLE hKey,		//handle of valid key(can be NULL if hValue is known)
	VALUE_HANDLE hValue,	//handle of value to set(can be NULL)
	LPCSTR lpName,			//address of value name of value to set(can be NULL if hkey is null)
	DWORD dwType,			//flag for value type 
	CONST BYTE *lpData,		//address of value data 
	DWORD cbData 			//size of value data 
);

//
//Consumer API
//

//The OpenKey call is similar to the Win32 RegOpenKeyEx call
DllExport HRESULT ISD_OpenKey
(
	KEY_HANDLE hKey,				//handle of a valid key(can be MAIN_ROOT_KEY)
	LPCSTR lpSubKey,				//name of subkey to open
	LPKEY_HANDLE lphReturnKey		//handle of the opened key
);

//The OpenValue call is new to ISDM because the registry doesn't have a concept of value handles
DllExport HRESULT ISD_OpenValue
(
	KEY_HANDLE hKey,				//handle of a valid key(can NOT be MAIN_ROOT_KEY)
	LPCSTR lpValueName,				//Name of value to open
	LPVALUE_HANDLE lphReturnValue	//handle of the opened value
);


//The EnumKey call is similar to the Win32 RegEnumKey call
//NOTES:
//	If lpName is null the size of the name is returned into lpcbName and NOERROR is returned
DllExport HRESULT ISD_EnumKey
(
	KEY_HANDLE hKey,				//key to enumerate
	DWORD dwIndex,					//index of subkey to enumerate
	LPSTR lpName,					//address of buffer for subkey name(can be NULL)
	LPDWORD lpcbName,				//address for size of subkey buffer (acts like the RegEnumKeyEx version of this param)
	LPKEY_HANDLE lphReturnKey		//handle of subkey(can be NULL) 
);

//The EnumValue call is similar to the Win32 RegEnumValue call
DllExport HRESULT ISD_EnumValue
(
	KEY_HANDLE hKey,				//handle of key where value resides
	DWORD dwIndex,					//index of value to enum
	LPSTR lpName,					//address of buffer for value name(can be NULL)
	LPDWORD lpcbName,				//address for size of value name buffer(can be NULL only if lpName is NULL)
	LPDWORD lpType,					//address for type of value(can be NULL if you don't care about type)
	LPBYTE lpData,					//address of buffer to receive the value data(can be NULL)
	LPDWORD lpcbData,				//address of size of buffer to receive the value data(can be NULL only if lpData is NULL)
	LPDWORD lpTimeStamp,			//address for timestamp on value(when last updated)(can be NULL)
	LPVALUE_HANDLE lphReturnValue	//address for handle of value(can be NULL)
);

//The QueryKeyInfo call is similar to the RegQueryInfoKey
DllExport HRESULT ISD_QueryInfoKey
(
	KEY_HANDLE hKey,				//handle of a valid key(can be MAIN_ROOT_KEY)
	LPSTR lpKeyName,			    //buffer to receive the name of the key(can be NULL)
	LPDWORD lpcbKeyName,			//address of size of name buffer(can be null only if lpKeyName is NULL)
	LPDWORD lpcNumKeys,				//address for number of direct children of the key(can be NULL)
	LPDWORD lpcNumValues			//address for number of values under the key(can be NULL)
);

//The QueryValueInfo call is NOT similar to the Win32 RegQueryValueEx call
//you must supply a value handle, the Win32 call doesn't have a notion of such a thing
//You can get the handle with subsequent calls to EnumKey
//This is my consumer call to retrieve statistical data
//NOTES:
//		If lpData is NULL and lpcbData is not, the function will return NOERROR with
//		lpcbData containing the buffer size needed for the value
//		If lpName is NULL and lpcbName is not, the function will return NOERROR with
//		lpcbName containing the buffer size needed for the value
DllExport HRESULT ISD_QueryInfoValue
(
	VALUE_HANDLE hValue,		//handle of value to query 
	LPSTR lpName,				//buffer to receive the name of the value(can be NULL)
	LPDWORD lpcbName,			//size of the name buffer(can only be NULL if lpName is NULL)
	LPDWORD lpValueType,		//address to receive the value type
	LPBYTE lpData,				//buffer to receive the value data(can be NULL)
	LPDWORD lpcbData,			//size of the value data buffer(can only be NULL if lpData is NULL)
	LPDWORD lpTime,				//address for timestamp on value(when last updated)(can be NULL)
	LPKEY_HANDLE lphParentKey	//return handle of the key that owns the value(can be NULL) 
);

//NotifyChangeValue is somewhat similar to the Win32 RegNotifyChangeValue call
//I limit you to async notification and also to value notification(no key level notify..yet)
DllExport HRESULT ISD_NotifyChangeValue
(
	VALUE_HANDLE hValue,	//handle of the value to trigger an event from
	HANDLE hEvent			//handle to the event you want triggered when value changes
);

//
//shared API
//

//The DeleteKey call is similar to RegDeleteKey
DllExport HRESULT ISD_DeleteKey
(
	KEY_HANDLE hKey					//handle of key to delete
);

//The DeleteValue call is similar to the RegDeleteValue call
//NOTE: You must supply either hValue or lpValueName. If you have the hValue, use it 
//and pass NULL for the value name.
DllExport HRESULT ISD_DeleteValue
(
	KEY_HANDLE hKey,				//handle of key that owns the value..if you have the value handle..pass NULL
	VALUE_HANDLE hValue,			//handle of value to delete(if known)..if known..pass NULL for key handle and name value
	LPCSTR lpValueName				//buffer holding name of value to delete(if known) pass NULL when hValue is known
);

//The GetStructData call is for retrieving structural info on ISDM itself. This is exposed so
//my test app can check the data structs. You should not need to call this.
DllExport BOOL ISD_GetStructData
(
	LPINFO_DATA pInfo				//structure holding ISDM structural info
);

//
//Handle validation calls
//
//use these anytime you want to check the validity of a handle to an ISDM object
DllExport BOOL ISD_IsValidKeyHandle
(
	KEY_HANDLE		hKey	//handle to key
);

DllExport BOOL ISD_IsValidValueHandle
(
	VALUE_HANDLE	hValue	//handle to value
);

//CompactMemory is my garbage collection function for ISDM. It is exported for
//test purposes with my browser app. You don't ever need to call this.
DllExport HRESULT ISD_CompactMemory
(
);

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // __ISDMAPI2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\isrg.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/include/rcs/isrg.h $
  $Revision:   1.4  $
      $Date:   01 Oct 1996 11:14:54  $
    $Author:   EHOWARDX  $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.

****************************************************************************/

#ifndef ISRG_H
#define ISRG_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// Use for Win16
//#define DllExport
//#define DllImport
//#define DLL_EXPORT	_export

// Use for Win32
#define DllExport		__declspec( dllexport )
#define DllImport		__declspec( dllimport )
#define DLL_EXPORT

#if defined(ISRDBG32_C)
#define ISR_DLL      DllExport
#else
#define ISR_DLL      DllImport
#endif

//
//	directions
//		Pick a number (mod 100) and create a base for the next
//		100 entries.  Do it this way so that your numbers can
//		be easily moved.  The string assigned to the base you select
//		will be displayed as the filter string in a list box when
//		viewing.  After defining your constants go to isrdsp.rc
//		and assign strings to them.  You will need to build the
//		isrdsp.exe but not the isrdbg.dll.  You only need to
//		inlude this h file and import the functions from this
//		file into your def file.  Happy debugging.


//------------------------------------------------------------------------------
#define kModSNameSize		16
#define kModLNameSize		32

//------------------------------------------------------------------------------
// defines for tISRModule.Flags
#define kCaptureOn			0x01

//------------------------------------------------------------------------------
typedef struct _tISRModule
{
	WORD	Flags;
	BYTE	CaptureFilter;
	BYTE	DisplayFilter;
	char	zSName[kModSNameSize];	// Short name of user registered debug module
	char	zLName[kModLNameSize];	// Long name of user registered debug module
} tISRModule, FAR *ptISRModule;

//------------------------------------------------------------------------------
#define kModuleBufSize		((DWORD) (16*1024L))
#define kMaxModules			((UINT) (kModuleBufSize/sizeof(tISRModule)))


//------------------------------------------------------------------------------
typedef struct _tISRItem
{
	WORD	hISRInst;		// Our handle to registered modules
	BYTE	DbgLevel;		// Caller determined debug level
	BYTE	Flags;
	UINT	IP;				// Callers Instruction Ptr address
	DWORD_PTR Param1;
	DWORD	Param2;
} tISRItem, FAR *ptISRItem;

//------------------------------------------------------------------------------
#define kISRBufSize			((DWORD) (128*1024L))
#define kMaxISRItems		((UINT) (kISRBufSize/sizeof(tISRItem)))
#define kMaxStrTab			((UINT) (256*1024L))


//------------------------------------------------------------------------------
// defines for tISRItem.Flags
#define kParam1IsStr		0x01
#define kParam1IsRes		0x02
#define kParam1IsNum		0x04		// Use only if passed two numbers.


//------------------------------------------------------------------------------
// Supported DbgMsg state values.
//------------------------------------------------------------------------------
#define ISR_DBG 				0
#define ISR_ERR 				1

#define kISRCritical		0x01	// Progammer errors that should never happen
#define kISRError			0x02	// Errors that need to be fixed
#define kISRWarning			0x04	// The user could have problems if not corrected
#define kISRNotify			0x08	// Status, events, settings...
#define kISRTrace			0x10	// Trace info that will not overrun the system
#define kISRTemp			0x20	// Trace info that may be reproduced in heavy loops
#define kISRReserved1		0x40	// Future use
#define kISRReserved2		0x80	// Future use
#define kISRDefault			kISRReserved2	// Historical use only

#define TT_CRITICAL			kISRCritical
#define TT_ERROR			kISRError
#define TT_WARNING			kISRWarning
#define TT_NOTIFY			kISRNotify
#define TT_TRACE			kISRTrace
#define TT_TEMP				kISRTemp


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you want to output at interrupt time.
// The ISR_Hook*() functions are the same as their counterparts.  The only
// difference is that these functions need the Instruction Pointer passed
// in.  If you are using an intermediate library to encapsulate the debug
// functions then you must be responsible for pulling the IP off the stack.

// Register the module and get a handle for making debug calls.  If a debug
// call is made with an invalid handle then the results are not defined.
// It is possible to drop the debug event or to place the event into the
// compatibility module.  If no more module handles are available then
// the handle returned will be the compatibility handle.
ISR_DLL void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR zShortName, LPSTR zLongName);


// Allow two strings to be concatenated togeter.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);

// Allow two strings to be concatenated togeter.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);


// WARNING: Call at task time only.  Not reentrant.
ISR_DLL void FAR cdecl DLL_EXPORT
TTDbgMsg
(
	WORD		hISRInst,	// Module's ISRDBG handle.
	BYTE		DbgLevel,	// Appropriate ISRDBG level.
	LPCSTR		zMsgFmt,	// Output format string (like printf).
	... 					// Optional parameter list.
);


// Old functions for compatibility only.
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr);

ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId);

ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num);

// WARNING: Call at task time only.  Not reentrant.
ISR_DLL void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	);


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you need to know the state of isrdbg.dll.
// isrdsp.exe needs to do this to display the data at task time.

ISR_DLL void WINAPI DLL_EXPORT
ISR_ClearItems (void);

ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void);

ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumModules (void);

ISR_DLL ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem);

ISR_DLL ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst);

ISR_DLL int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter);


//------------------------------------------------------------------------------
//	The caller of ISR debug functions can call these Macros and then the
//	retail release will just drop all of the debug statement code.
//------------------------------------------------------------------------------
#if (DEBUG >= 1) || (_DEBUG >= 1)
#define ISRDEBUGINFO	1
extern WORD	ghISRInst;
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)	ISR_RegisterModule(pghISRInst, ShortName, LongName)
#define ISRNOTIFY(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRNotify, Str, Num)
#define ISRCRITICAL(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRCritical, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRError, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRWarning, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTrace, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTemp, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved1, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved2, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRNotify, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRCritical, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRError, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRWarning, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTrace, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTemp, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved1, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved2, Str, Str2)

#define TTDBG			TTDbgMsg

#else

#define ISRNOTIFY(ghISRInst, Str, Num)
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)
#define ISRCRITICAL(ghISRInst, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)

#define ghISRInst		0
#define TTDBG			1 ? (void)0 : TTDbgMsg

#endif


//------------------------------------------------------------------------------
// Local Functions

// Local function but thunk needs to get to it
ISR_DLL void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	);

// Local function but thunk needs to get to it
ISR_DLL void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	);


//------------------------------------------------------------------------------
// do not use a base of 0.  Reserved for system use.
#define ID_SysBase			0
#define ID_SysStr			(ID_SysBase + 1)
#define ID_SysSInt			(ID_SysBase + 2)
#define ID_SysUInt			(ID_SysBase + 3)
#define ID_SysDWord			(ID_SysBase + 4)
#define ID_SysLong			(ID_SysBase + 5)
#define ID_SysHex			(ID_SysBase + 6)


//------------------------------------------------------------------------------
// IsrDbg.dll
#define ID_IsrDbgBase		100
#define ID_IsrDbgLibMain	(ID_IsrDbgBase + 1)
#define ID_IsrDbgWep		(ID_IsrDbgBase + 2)
#define ID_IsrDbgReentrant	(ID_IsrDbgBase + 3)


//------------------------------------------------------------------------------
// IsrDsp.exe
#define ID_IsrDspBase		200
#define ID_IsrDspInit		(ID_IsrDspBase + 1)
#define ID_IsrDspExit		(ID_IsrDspBase + 2)


//------------------------------------------------------------------------------
// stMem.dll
#define ID_stMemBase		300
#define ID_stMemLibMain		(ID_stMemBase + 1)
#define ID_stMemWep			(ID_stMemBase + 2)
#define ID_stMemPreAlloc	(ID_stMemBase + 3)
#define ID_stMemPageLock	(ID_stMemBase + 4)
#define ID_stMemNoPageLock	(ID_stMemBase + 5)
#define ID_stMemAlloc		(ID_stMemBase + 6)
#define ID_stMemTotMem		(ID_stMemBase + 7)
#define ID_stMemstFree		(ID_stMemBase + 8)


//-------------------------------------------------------------------------------
// DLM.dll

// Errors
#define ID_DLMErrorBase		400
#define ID_DLMEnqError      (ID_DLMErrorBase + 1)
#define ID_DLMDeqError      (ID_DLMErrorBase + 2)
#define ID_DLMFreeError     (ID_DLMErrorBase + 3)
#define ID_DLMChanError     (ID_DLMErrorBase + 4)
#define ID_DLMChanNIUErr    (ID_DLMErrorBase + 5)
#define ID_DLMChanNumErr    (ID_DLMErrorBase + 6)
#define ID_DLMInConnErr     (ID_DLMErrorBase + 7)
#define ID_DLMInSessErr     (ID_DLMErrorBase + 8)
#define ID_DLMSessNIU       (ID_DLMErrorBase + 9)
#define ID_DLMSessNO        (ID_DLMErrorBase + 10)
#define ID_DLMConnNIU       (ID_DLMErrorBase + 11)
#define ID_DLMConnNO        (ID_DLMErrorBase + 12)
#define ID_DLMIDErr         (ID_DLMErrorBase + 13)
#define ID_DLMConnErr       (ID_DLMErrorBase + 14)
#define ID_DLMSessErr       (ID_DLMErrorBase + 15)
#define ID_DLMSessNF        (ID_DLMErrorBase + 16)
#define ID_DLMNoFreeConn    (ID_DLMErrorBase + 17)
#define ID_DLMConnCloseErr  (ID_DLMErrorBase + 18)
#define ID_DLMConnNF        (ID_DLMErrorBase + 19)
#define ID_DLMConnNC        (ID_DLMErrorBase + 20)
#define ID_DLMMDMError      (ID_DLMErrorBase + 21)
#define ID_DLMNoSess        (ID_DLMErrorBase + 22)
#define ID_DLMInvalidSess   (ID_DLMErrorBase + 23)
#define ID_DLMEventErr      (ID_DLMErrorBase + 24)
#define ID_DLMNoConn        (ID_DLMErrorBase + 25)
#define ID_DLMChanCloseErr  (ID_DLMErrorBase + 26)
#define ID_DLMInvalidConn   (ID_DLMErrorBase + 27)
#define ID_DLMCorruptQueue  (ID_DLMErrorBase + 28)
#define ID_DLMInvChanID     (ID_DLMErrorBase + 29)
#define ID_DLMChanInUse     (ID_DLMErrorBase + 30)
#define ID_DLMInvalidChan   (ID_DLMErrorBase + 31)
#define ID_DLMNoBufHdr      (ID_DLMErrorBase + 32)
#define ID_DLMEnqueueErr    (ID_DLMErrorBase + 33)
#define ID_DLMNMBufInProg   (ID_DLMErrorBase + 34)
#define ID_DLMNoBuffer      (ID_DLMErrorBase + 35)
#define ID_DLMEnterDumping  (ID_DLMErrorBase + 36)
#define ID_DLMSizeError     (ID_DLMErrorBase + 37)
#define ID_DLMNoBuf         (ID_DLMErrorBase + 38)
#define ID_DLMInitAlready   (ID_DLMErrorBase + 39)
#define ID_DLMGDLError      (ID_DLMErrorBase + 40)
#define ID_DLMNoEntryPoint  (ID_DLMErrorBase + 41)
#define ID_DLMNoEvent       (ID_DLMErrorBase + 42)
#define ID_DLMNoPackets     (ID_DLMErrorBase + 43)

// Debug level 1 messages
#define ID_DLMDebug1Base         500
#define ID_DLMCloseAllEntered    (ID_DLMDebug1Base + 1)
#define ID_DLMEstabHEntered      (ID_DLMDebug1Base + 2)
#define ID_DLMEstabHExit         (ID_DLMDebug1Base + 3)
#define ID_DLMReqHEntered        (ID_DLMDebug1Base + 4)
#define ID_DLMReqHAlloc          (ID_DLMDebug1Base + 5)
#define ID_DLMReqHExit           (ID_DLMDebug1Base + 6)
#define ID_DLMRejHEntered        (ID_DLMDebug1Base + 7)
#define ID_DLMRejHExit           (ID_DLMDebug1Base + 8)
#define ID_DLMCNoteHEntered      (ID_DLMDebug1Base + 9)
#define ID_DLMCNoteHExit         (ID_DLMDebug1Base + 10)
#define ID_DLMCComHEntered       (ID_DLMDebug1Base + 11)
#define ID_DLMCComHExit          (ID_DLMDebug1Base + 12)
#define ID_DLMSessCloseHEntered  (ID_DLMDebug1Base + 13)
#define ID_DLMSessCloseHExit     (ID_DLMDebug1Base + 14)
#define ID_DLMSessHEntered       (ID_DLMDebug1Base + 15)
#define ID_DLMSessHExit          (ID_DLMDebug1Base + 16)
#define ID_DLMBegSessEntered     (ID_DLMDebug1Base + 17)
#define ID_DLMBegSessExit        (ID_DLMDebug1Base + 18)
#define ID_DLMEndSessEntered     (ID_DLMDebug1Base + 19)
#define ID_DLMEndSessExit        (ID_DLMDebug1Base + 20)
#define ID_DLMListenEntered      (ID_DLMDebug1Base + 21)
#define ID_DLMListenExit         (ID_DLMDebug1Base + 22)
#define ID_DLMDoCloseEntered     (ID_DLMDebug1Base + 23)
#define ID_DLMDoCloseExit        (ID_DLMDebug1Base + 24)
#define ID_DLMMakeConnEntered    (ID_DLMDebug1Base + 25)
#define ID_DLMMakeConnExit       (ID_DLMDebug1Base + 26)
#define ID_DLMRejEntered         (ID_DLMDebug1Base + 27)
#define ID_DLMRejExit            (ID_DLMDebug1Base + 28)
#define ID_DLMAccEntered         (ID_DLMDebug1Base + 29)
#define ID_DLMAccExit            (ID_DLMDebug1Base + 30)
#define ID_DLMCloseConnEntered   (ID_DLMDebug1Base + 31)
#define ID_DLMCloseConnExit      (ID_DLMDebug1Base + 32)
#define ID_DLMTryEntered         (ID_DLMDebug1Base + 33)
#define ID_DLMTryExit            (ID_DLMDebug1Base + 34)
#define ID_DLMOpenEntered        (ID_DLMDebug1Base + 35)
#define ID_DLMOpenExit           (ID_DLMDebug1Base + 36)
#define ID_DLMSendEntered        (ID_DLMDebug1Base + 37)
#define ID_DLMSendExit           (ID_DLMDebug1Base + 38)
#define ID_DLMSendComEntered     (ID_DLMDebug1Base + 39)
#define ID_DLMSendComExit        (ID_DLMDebug1Base + 40)
#define ID_DLMPostEntered        (ID_DLMDebug1Base + 41)
#define ID_DLMPostExit           (ID_DLMDebug1Base + 42)
#define ID_DLMNewMsgEntered      (ID_DLMDebug1Base + 43)
#define ID_DLMNewMsgExit         (ID_DLMDebug1Base + 44)
#define ID_DLMContMsgEntered     (ID_DLMDebug1Base + 45)
#define ID_DLMContMsgExit        (ID_DLMDebug1Base + 46)
#define ID_DLMRecEntered         (ID_DLMDebug1Base + 47)
#define ID_DLMRecExit            (ID_DLMDebug1Base + 48)
#define ID_DLMCloseEntered       (ID_DLMDebug1Base + 49)
#define ID_DLMCloseExit          (ID_DLMDebug1Base + 50)
#define ID_DLMGetCharEntered     (ID_DLMDebug1Base + 51)
#define ID_DLMGetCharExit        (ID_DLMDebug1Base + 52)
#define ID_DLMInitEntered        (ID_DLMDebug1Base + 53)
#define ID_DLMInitExit           (ID_DLMDebug1Base + 54)
#define ID_DLMDeInitEntered      (ID_DLMDebug1Base + 55)
#define ID_DLMDeInitExit         (ID_DLMDebug1Base + 56)
#define ID_DLMCloseAllExit       (ID_DLMDebug1Base + 57)
#define ID_DLMEnqEntered         (ID_DLMDebug1Base + 58)
#define ID_DLMEnqExit            (ID_DLMDebug1Base + 59)
#define ID_DLMDeqEntered         (ID_DLMDebug1Base + 60)
#define ID_DLMDeqExit            (ID_DLMDebug1Base + 61)
#define ID_DLMEnqPEntered        (ID_DLMDebug1Base + 62)
#define ID_DLMEnqPExit           (ID_DLMDebug1Base + 63)


// Debug level 2 messages
#define ID_DLMDebug2Base         600
#define ID_DLMCallback           (ID_DLMDebug2Base + 1)
#define ID_DLMConnection         (ID_DLMDebug2Base + 2)
#define ID_DLMBuffer             (ID_DLMDebug2Base + 3)
#define ID_DLMSize               (ID_DLMDebug2Base + 4)
#define ID_DLMRemaining          (ID_DLMDebug2Base + 5)
#define ID_DLMReceived           (ID_DLMDebug2Base + 6)
#define ID_DLMToken              (ID_DLMDebug2Base + 7)
#define ID_DLMOChannel           (ID_DLMDebug2Base + 8)
#define ID_DLMRChannel           (ID_DLMDebug2Base + 9)
#define ID_DLMStatus             (ID_DLMDebug2Base + 10)
#define ID_DLMEndSessClosing     (ID_DLMDebug2Base + 11)
#define ID_DLMBufferSize         (ID_DLMDebug2Base + 12)
#define ID_DLMLinkPacket         (ID_DLMDebug2Base + 13)
#define ID_DLMChannel            (ID_DLMDebug2Base + 14)
#define ID_DLMInDumping          (ID_DLMDebug2Base + 15)
#define ID_DLMByteCount          (ID_DLMDebug2Base + 16)
#define ID_DLMDeqNoBuf           (ID_DLMDebug2Base + 17)
#define ID_DLMEnqPSkip           (ID_DLMDebug2Base + 18)


//------------------------------------------------------------------------------
// MDM -> mdmnbios.dll

#define ID_mdmBase				700
#define ID_mdmLibMain			(ID_mdmBase + 1)
#define ID_mdmWep				(ID_mdmBase + 2)
#define ID_mdmBadhSesUser		(ID_mdmBase + 3)
#define ID_mdmBadhConUser		(ID_mdmBase + 4)
#define ID_mdmBadhSesFree		(ID_mdmBase + 5)
#define ID_mdmBadhConFree		(ID_mdmBase + 6)
#define ID_mdmBadhSesInt		(ID_mdmBase + 7)
#define ID_mdmBadhConInt		(ID_mdmBase + 8)
#define ID_mdmNoMorehSes		(ID_mdmBase + 9)
#define ID_mdmNoMorehCon		(ID_mdmBase + 10)
#define ID_mdmWepConFree		(ID_mdmBase + 11)
#define ID_mdmActiveCon			(ID_mdmBase + 12)
#define ID_mdmBBegSes			(ID_mdmBase + 13)
#define ID_mdmEBegSes			(ID_mdmBase + 14)
#define ID_mdmBEndSes			(ID_mdmBase + 15)
#define ID_mdmEEndSes			(ID_mdmBase + 16)
#define ID_mdmBListen			(ID_mdmBase + 17)
#define ID_mdmEListen			(ID_mdmBase + 18)
#define ID_mdmBMakeCon			(ID_mdmBase + 19)
#define ID_mdmEMakeCon			(ID_mdmBase + 20)
#define ID_mdmBAcceptCon		(ID_mdmBase + 21)
#define ID_mdmEAcceptCon		(ID_mdmBase + 22)
#define ID_mdmBRejectCon		(ID_mdmBase + 23)
#define ID_mdmERejectCon		(ID_mdmBase + 24)
#define ID_mdmBCloseCon			(ID_mdmBase + 25)
#define ID_mdmECloseCon			(ID_mdmBase + 26)
#define ID_mdmErrNetBios		(ID_mdmBase + 27)
#define ID_mdmNoSendNcb			(ID_mdmBase + 28)
#define ID_mdmNoFreeSndNcbSlot	(ID_mdmBase + 29)
#define ID_mdmInvalidConState	(ID_mdmBase + 30)
#define ID_mdmInvalidParams		(ID_mdmBase + 31)
#define ID_mdmToManyListens		(ID_mdmBase + 32)
#define ID_mdmKillTheListen		(ID_mdmBase + 33)
#define ID_mdmBListenCB			(ID_mdmBase + 34)
#define ID_mdmEListenCB			(ID_mdmBase + 35)
#define ID_mdmBConnectCB		(ID_mdmBase + 36)
#define ID_mdmEConnectCB		(ID_mdmBase + 37)
#define ID_mdmBCloseCB			(ID_mdmBase + 38)
#define ID_mdmECloseCB			(ID_mdmBase + 39)
#define ID_mdmBSndCB			(ID_mdmBase + 40)
#define ID_mdmESndCB			(ID_mdmBase + 41)
#define ID_mdmBRcvCB			(ID_mdmBase + 42)
#define ID_mdmERcvCB			(ID_mdmBase + 43)


//---------------------------------------------------------------------------------
// MDM -> MDM Teleos

// Errors
#define ID_MDMTEBASE               1000
#define ID_MDMTEDeqUnackNoHead     (ID_MDMTEBASE + 1)
#define ID_MDMTEDeqUnackNoNext     (ID_MDMTEBASE + 2)
#define ID_MDMTEDeqUnackNoPrev     (ID_MDMTEBASE + 3)
#define ID_MDMTEDeqArrNoTail       (ID_MDMTEBASE + 4)
#define ID_MDMTENullTCB            (ID_MDMTEBASE + 5)
#define ID_MDMTETCBRet             (ID_MDMTEBASE + 6)
#define ID_MDMTEWinSize            (ID_MDMTEBASE + 7)
#define ID_MDMTENoLinkPacket       (ID_MDMTEBASE + 8)
#define ID_MDMTETooLarge           (ID_MDMTEBASE + 9)
#define ID_MDMTELPNotFound         (ID_MDMTEBASE + 10)
#define ID_MDMTENoTCB              (ID_MDMTEBASE + 11)
#define ID_MDMTEInitAlready        (ID_MDMTEBASE + 12)
#define ID_MDMTETCBInitFail        (ID_MDMTEBASE + 13)
#define ID_MDMTELSNErr             (ID_MDMTEBASE + 14)
#define ID_MDMTESizeError          (ID_MDMTEBASE + 15)
#define ID_MDMTEReceived           (ID_MDMTEBASE + 16)
#define ID_MDMTEExpected           (ID_MDMTEBASE + 17)
#define ID_MDMTECorruptQ           (ID_MDMTEBASE + 18)
#define ID_MDMTENoInit             (ID_MDMTEBASE + 19)
#define ID_MDMTEAbanPack           (ID_MDMTEBASE + 20)
#define ID_MDMTESeqNum             (ID_MDMTEBASE + 21)
#define ID_MDMTESipPend            (ID_MDMTEBASE + 22)
#define ID_MDMTENoConn             (ID_MDMTEBASE + 23)
#define ID_MDMTEInvalidID          (ID_MDMTEBASE + 24)
#define ID_MDMTENoSess             (ID_MDMTEBASE + 25)
#define ID_MDMTENoLPM              (ID_MDMTEBASE + 26)
#define ID_MDMTESessID             (ID_MDMTEBASE + 27)
#define ID_MDMTESessNIU            (ID_MDMTEBASE + 28)
#define ID_MDMTESize               (ID_MDMTEBASE + 29)
#define ID_MDMTEState              (ID_MDMTEBASE + 30)
#define ID_MDMTEConnID             (ID_MDMTEBASE + 31)
#define ID_MDMTEConnNIU            (ID_MDMTEBASE + 32)
#define ID_MDMTETinyPacket         (ID_MDMTEBASE + 33)
#define ID_MDMTEPacketOOS          (ID_MDMTEBASE + 34)
#define ID_MDMTEECBNotFound        (ID_MDMTEBASE + 35)

// Trace Information
#define ID_MDMTTBASE               1100
#define ID_MDMTTB1CEnter         (ID_MDMTTBASE + 1)
#define ID_MDMTTB1CExit          (ID_MDMTTBASE + 2)
#define ID_MDMTTSB1Enter         (ID_MDMTTBASE + 3)
#define ID_MDMTTSB1Exit          (ID_MDMTTBASE + 4)
#define ID_MDMTTB2CEnter         (ID_MDMTTBASE + 5)
#define ID_MDMTTB2CExit          (ID_MDMTTBASE + 6)
#define ID_MDMTTSB2Enter         (ID_MDMTTBASE + 7)
#define ID_MDMTTSB2Exit          (ID_MDMTTBASE + 8)
#define ID_MDMTTSendEnter        (ID_MDMTTBASE + 9)
#define ID_MDMTTSendExit         (ID_MDMTTBASE + 10)
#define ID_MDMTTInitEnter        (ID_MDMTTBASE + 11)
#define ID_MDMTTInitExit         (ID_MDMTTBASE + 12)
#define ID_MDMTTDeInitEnter      (ID_MDMTTBASE + 13)
#define ID_MDMTTDeInitExit       (ID_MDMTTBASE + 14)
#define ID_MDMTTLB1Enter         (ID_MDMTTBASE + 15)
#define ID_MDMTTLB1Exit          (ID_MDMTTBASE + 16)
#define ID_MDMTTLB2Enter         (ID_MDMTTBASE + 17)
#define ID_MDMTTLB2Exit          (ID_MDMTTBASE + 18)
#define ID_MDMTTNBSEnter         (ID_MDMTTBASE + 19)
#define ID_MDMTTNBSExit          (ID_MDMTTBASE + 20)
#define ID_MDMTTRecEnter         (ID_MDMTTBASE + 21)
#define ID_MDMTTRecExit          (ID_MDMTTBASE + 22)
#define ID_MDMTTCTSEnter         (ID_MDMTTBASE + 23)
#define ID_MDMTTCTSExit          (ID_MDMTTBASE + 24)
#define ID_MDMTTGCEnter          (ID_MDMTTBASE + 25)
#define ID_MDMTTGCExit           (ID_MDMTTBASE + 26)
#define ID_MDMTTBegSessEnter     (ID_MDMTTBASE + 27)
#define ID_MDMTTBegSessExit      (ID_MDMTTBASE + 28)
#define ID_MDMTTEndSessEnter     (ID_MDMTTBASE + 29)
#define ID_MDMTTEndSessExit      (ID_MDMTTBASE + 30)
#define ID_MDMTTMakeConEnter     (ID_MDMTTBASE + 31)
#define ID_MDMTTMakeConExit      (ID_MDMTTBASE + 32)
#define ID_MDMTTCloseConEnter    (ID_MDMTTBASE + 33)
#define ID_MDMTTCloseConExit     (ID_MDMTTBASE + 34)
#define ID_MDMTTListEnter        (ID_MDMTTBASE + 35)
#define ID_MDMTTListExit         (ID_MDMTTBASE + 36)
#define ID_MDMTTAccEnter         (ID_MDMTTBASE + 37)
#define ID_MDMTTAccExit          (ID_MDMTTBASE + 38)
#define ID_MDMTTRejEnter         (ID_MDMTTBASE + 39)
#define ID_MDMTTRejExit          (ID_MDMTTBASE + 40)
#define ID_MDMTTRecLookEnter     (ID_MDMTTBASE + 41)
#define ID_MDMTTRecLookExit      (ID_MDMTTBASE + 42)

// Comment Information
#define ID_MDMTCBASE               1200
#define ID_MDMTCSeqNum             (ID_MDMTCBASE + 1)
#define ID_MDMTCFound              (ID_MDMTCBASE + 2)
#define ID_MDMTCWaiting            (ID_MDMTCBASE + 3)
#define ID_MDMTCCTSFail            (ID_MDMTCBASE + 4)
#define ID_MDMTCCTSPass            (ID_MDMTCBASE + 5)
#define ID_MDMTCCTSize             (ID_MDMTCBASE + 6)
#define ID_MDMTCCTSOut             (ID_MDMTCBASE + 7)
#define ID_MDMTCTCB                (ID_MDMTCBASE + 8)
#define ID_MDMTCECBPMAddr          (ID_MDMTCBASE + 9)
#define ID_MDMTCECBRMAddr          (ID_MDMTCBASE + 10)

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif	// h file included already

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\mediacap.h ===
#ifndef _MEDIACAP_H
#define _MEDIACAP_H

#ifdef __cplusplus

#define RTP_DYNAMIC_MIN 96	// use value in the range of "dynamic" payload type
#define RTP_DYNAMIC_MAX 127
#define IsDynamicPayload(p) ((p >= RTP_DYNAMIC_MIN) && (p <= RTP_DYNAMIC_MAX))


#define CAP_CHUNK_SIZE 8	// allocate AUDCAP_DETAILS and VIDCAP_DETAILS in chunks of this size
#define MAX_CAPS_PRESORT 64

typedef struct
{
	WORD  wDataRate;	// (channel param) Data rate - must be one of the data rates
						// received in the exchanged capabilities. or within the
						//specified range. Note that this is redundant
						// in the case of exchanging a WAVEFORMATEX
	WORD wFrameSizeMax; 	// (capability)
	WORD wFrameSizeMin;		// (capability)
	WORD wFrameSize;		// (channel open param) Record - playback frame size
	WORD wFramesPerPkt;		// (channel open param) Number of frames in an audio packet
	WORD wFramesPerPktMax;	// (capability)
	WORD wFramesPerPktMin;	// (capability)
	BYTE UseSilenceDet; // If silence detection is to be used/is available (both)
	BYTE UsePostFilter;	// If post-filtering is to be used	(channel open param. (both?))

}NSC_CHANNEL_PARAMETERS, *PNSC_CHANNEL_PARAMETERS;

typedef struct
{
	NSC_CHANNEL_PARAMETERS ns_params;
	BYTE	RTP_Payload;
}AUDIO_CHANNEL_PARAMETERS, *PAUDIO_CHANNEL_PARAMETERS;


typedef enum
{
	NSC_ACMABBREV = 1,
	NSC_ACM_WAVEFORMATEX,
	// NSC_MS_ACTIVE_MOVIE
} NSC_CAP_TYPE;

typedef struct
{
	DWORD dwFormatTag;		// ACM format tag  + padding
	DWORD dwSamplesPerSec;	// samples per second
	DWORD dwBitsPerSample;	// bits per sample plus padding
}NSC_AUDIO_ACM_ABBREVIATED; //ACM_TAG_CAPS, *LP_ACM_TAG_CAPS;

// DON't ever allocate an array of these because of WAVEFORMATEX Extra Bytes
typedef struct {
	NSC_CAP_TYPE cap_type;
	NSC_CHANNEL_PARAMETERS cap_params;
	union {
		WAVEFORMATEX wfx;
		NSC_AUDIO_ACM_ABBREVIATED acm_brief;
	}cap_data;
}NSC_AUDIO_CAPABILITY, *PNSC_AUDIO_CAPABILITY;

typedef struct
{
	UINT maxBitRate;
	USHORT maxBPP;
	USHORT MPI;
}NSC_CHANNEL_VIDEO_PARAMETERS, *PNSC_CHANNEL_VIDEO_PARAMETERS;

typedef struct
{
	NSC_CHANNEL_VIDEO_PARAMETERS ns_params;
	BYTE	RTP_Payload;
	BOOL	TS_Tradeoff;
}VIDEO_CHANNEL_PARAMETERS, *PVIDEO_CHANNEL_PARAMETERS;


typedef enum
{
	NSC_VCMABBREV = 1,
	NSC_VCM_VIDEOFORMATEX,
	// NSC_MS_ACTIVE_MOVIE
} NSC_CVP_TYPE;

typedef struct
{
	DWORD dwFormatTag;		// VCM format tag  + padding
	DWORD dwSamplesPerSec;	// samples per second
	DWORD dwBitsPerSample;	// bits per sample plus padding
}NSC_VIDEO_VCM_ABBREVIATED; //VCM_TAG_CAPS, *LP_VCM_TAG_CAPS;



// DON't ever allocate an array of these because of VIDEOFORMATEX Extra Bytes
typedef struct {
	NSC_CVP_TYPE cvp_type;
	NSC_CHANNEL_VIDEO_PARAMETERS cvp_params;
	union {
		VIDEOFORMATEX vfx;
		NSC_VIDEO_VCM_ABBREVIATED vcm_brief;
	}cvp_data;
}NSC_VIDEO_CAPABILITY, *PNSC_VIDEO_CAPABILITY;



// IH323MediaCap  is exposed by the media-specific capability object
// This interface is used primarily by the simultaneous capability object.
// (i.e. the thing that combines all capabilities)
class IH323MediaCap
{
	public:
	STDMETHOD(QueryInterface(REFIID riid, LPVOID FAR * ppvObj))=0;
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;

	STDMETHOD_(BOOL, Init())=0;
	STDMETHOD_(BOOL, ReInit())=0;
	STDMETHOD_(VOID, FlushRemoteCaps())=0;
	STDMETHOD(AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList))=0;
	// H.245 parameter grabbing functions
	// Get public version of channel parameters for a specific decode capability
	STDMETHOD(GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, MEDIA_FORMAT_ID id))=0;
	// Get local and remote channel parameters for a specific encode capability
	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize, LPVOID pLocalParams,
			UINT uLocalSize,MEDIA_FORMAT_ID idRemote,MEDIA_FORMAT_ID idLocal))=0;
 	// get local version of channel parameters for a specific decode capability
	STDMETHOD(GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		MEDIA_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize))=0;
	STDMETHOD( CreateCapList(LPVOID *ppCapBuf))=0;
	STDMETHOD( DeleteCapList(LPVOID pCapBuf))=0;

	STDMETHOD( ResolveEncodeFormat(MEDIA_FORMAT_ID *pIDEncodeOut,MEDIA_FORMAT_ID * pIDRemoteDecode))=0;


	STDMETHOD_(UINT, GetNumCaps())=0;				
	STDMETHOD_(UINT, GetNumCaps(BOOL bRXCaps))=0;
	STDMETHOD_(BOOL, IsHostForCapID(MEDIA_FORMAT_ID CapID))=0;
	STDMETHOD_(BOOL, IsCapabilityRecognized(PCC_TERMCAP pCCThisCap))=0;
	STDMETHOD_(MEDIA_FORMAT_ID, AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap))=0;

	STDMETHOD(SetCapIDBase(UINT uNewBase))=0;
	STDMETHOD_(UINT, GetCapIDBase())=0;
		STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID))=0;
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability))=0;

	// The following is an interim solution, definitely must revisit this for the next release.
 	// The data pump requires access to local parameters that results from capability
 	// negotiation. In the absence of a separate interface that the data pump can use,
 	// the following are stuck onto this interface.
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize))=0;
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize))=0;

	STDMETHOD (IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend))=0;
	STDMETHOD_(BOOL, IsFormatPublic(MEDIA_FORMAT_ID FormatID))=0;
	STDMETHOD_(MEDIA_FORMAT_ID, GetPublicID(MEDIA_FORMAT_ID FormatID))=0;
	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting))=0;
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting))=0;
	STDMETHOD (SetAudioPacketDuration( UINT durationInMs))=0;
	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote))=0;
};
typedef IH323MediaCap *LPIH323MediaCap;

#endif //__cplusplus


#endif // _MEDIACAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\lst.h ===
#ifndef __lst_h__
#define __lst_h__

#ifndef ASSERT
    #define ASSERT( x ) 
#endif // #ifndef ASSERT

#include <functional>


// lst bidirectional linked-list template class
// Here are some examples of the usage:
//
//    lst< int > MyList;
//
//    for( int i = 0; i < 10; i++ ) {        
//        MyList . push_front( i );
//    }
//
//   
//    lst< int > TestList;
//    TestList . insert( TestList . begin(), MyList . begin(), MyList . end() ); 
//
//    const lst< int > cList = MyList;
//
//    lst< int >::const_iterator I = cList . begin();
//    while( I != cList . end() ) {
//        int Num = *I;
//        I++;
//    }
//
//
//  the const_iterator is used to iterate through a const List
// 
//  

template< class T, class Operator_Eq = std::equal_to<T> >
class lst {

private: // Data types and typedefs

    typedef T value_type;
    typedef value_type* pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef lst< value_type > self;
	Operator_Eq _FnEq;

    class node {
    public:
      node( node* pP, node* pN, const_reference t ) : pNext( pN ), pPrev( pP ), data( t ) { ; }
      node( void ) : pNext( NULL ), pPrev( NULL ) { ; }
      node* pNext;
      node* pPrev;
      value_type data;
    };            

public:
        // iterator class for iterating through the list
    class iterator {
    friend lst;        
    private:
        typedef iterator self;
        node* pNode;

        iterator( node* pN ) : pNode( pN ) { ; }

    public:
        iterator( void ) : pNode( NULL ) { ; }
        ~iterator( void ) { ; }

        iterator( self& r ) { *this = r; }
        
        iterator& operator=( iterator& r ) { pNode = r . pNode; return *this; }
        bool operator==( const self& r ) const { return pNode == r . pNode; }
        operator!=( const self& r ) const { return pNode != r . pNode; }
        reference operator*() { return pNode -> data; }
        self& operator++() { 
            pNode = pNode -> pNext;
            return *this;
        }
        
        self operator++( int ) { 
            self tmp = *this;
            ++*this;
            return tmp;
        }
        
        self& operator--() { 
            pNode = pNode -> pPrev;
            return *this;
        }
        
        self operator--(int) { 
            self tmp = *this;
            --*this;
            return tmp;
        }

    };

        // const_iterator class for iterating through a const list
    class const_iterator {
    friend lst;        

    private:

        typedef const_iterator self;
        const node* pNode;
        const_iterator( const node* pN ) : pNode( pN ) { ; }

    public:
        const_iterator( void ) : pNode( NULL ) { ; }
        ~const_iterator( void ) { ; }

        const_iterator( const self& r ) { *this = r; }
        
        const_iterator& operator=( const const_iterator& r ) { pNode = r . pNode; return *this;}
        bool operator==( const self& r ) const { return pNode == r . pNode; }
        operator!=( const self& r ) const { return pNode != r . pNode; }
        const_reference operator*() const { return pNode -> data; }

        self& operator++() { 
            pNode = pNode -> pNext;
            return *this;
        }
        
        self operator++( int ) { 
            self tmp = *this;
            ++*this;
            return tmp;
        }
        
        self& operator--() { 
            pNode = pNode -> pPrev;
            return *this;
        }
        
        self operator--(int) { 
            self tmp = *this;
            --*this;
            return tmp;
        }

    };


    // Data
    node*   m_pNode;
    size_t  m_nItems;

public: 
        // construction / destruction
    lst( void ) {
      empty_initialize();
    };

    lst( const self& rList ) { empty_initialize(); *this = rList; }
    ~lst( void ) { clear(); delete m_pNode; m_pNode = NULL; }

    bool operator==( const self& rList ) const {
        if( size() != rList . size() ) { return false; }

        self::const_iterator IThis = begin();
        self::const_iterator IThat = rList . begin();

        while( IThis != end() ) {
            if( !_FnEq( *IThis, *IThat ) ) {
                return false;
            }
            ++IThat;
            ++IThis;
         }

         return true;
    }        
    
        // Member Fns
    self& operator=( const self& rList ) {
        clear();
        insert( begin(), rList . begin(), rList . end() );
        return *this;
    }

    void empty_initialize( void ) {
      m_pNode = new node;
      m_pNode -> pNext = m_pNode;
      m_pNode -> pPrev = m_pNode;
      m_nItems = 0;
    }

    void clear( void ) {
      node* pCur = m_pNode -> pNext;
      while( pCur != m_pNode ) {
        node* pTmp = pCur;
        pCur = pCur -> pNext;
        --m_nItems;
        delete pTmp;
        pTmp = NULL;
      }
      m_pNode -> pNext = m_pNode;
      m_pNode -> pPrev = m_pNode;

    }

        // Return the size of the list
    size_t size( void ) const             { return m_nItems; }
    bool empty( void ) const              { return 0 == size(); }

        // Return an iterator to the position after the last element in the list
        // N.B. ---- Don't dereference end()!!!!!!
        // N.B. ---- end()++ is undefined!!!!!!
    iterator end( void )                  { return iterator( m_pNode ); }
    const_iterator end( void ) const      { return const_iterator( m_pNode ); }

        // Return an iterator to the position of the first element of the list
        // You may dereference begin()
    iterator begin( void )                { return iterator( m_pNode -> pNext ); }
    const_iterator begin( void ) const    { return const_iterator( m_pNode -> pNext ); }

        // Returns a reference to the first element in the list
    reference front( void )               { return *begin(); }
    const_reference front( void ) const   { return *begin(); }

        // Returns a reference to the last element in the list
    reference back( void )                { return *(--end()); }
    const_reference back( void ) const    { return *(--end()); }
    
        // add an object to the front of the list
    void push_front( const_reference x )  { insert(begin(), x); }

        // add an object to the end of the list
    void push_back( const_reference x )   { insert(end(), x); }

        // Insert an item before the item that position points to
    void insert( iterator position, const_reference r ) {
      node* pTmp = new node( position . pNode -> pPrev, position . pNode, r );
      ( position . pNode -> pPrev ) -> pNext = pTmp;
      position . pNode -> pPrev = pTmp;
      ++m_nItems;
    }

        // Insert items first through last to the list at position position
    void insert( iterator position, iterator first, iterator last ) {
        for ( ; first != last; ++first) {
            insert(position, *first);
        }
    }

        // Insert items first through last to the list at position position
    void insert( iterator position, const_iterator first, const_iterator last ) {
        for ( ; first != last; ++first) {
            insert(position, *first);
        }
    }

        // Pop the first element from the list
    void pop_front( void )              { erase(begin()); }
    

        // Pop the last element from the list
    void pop_back( void ) {
        iterator tmp = end();
        erase(--tmp);
    }

    
        // erase the item at position pos in the list
    void erase( iterator pos ) {
        ASSERT( pos != end() );
        ( pos . pNode -> pPrev ) -> pNext = pos . pNode -> pNext;
        ( pos . pNode -> pNext ) -> pPrev = pos . pNode -> pPrev;
        --m_nItems;
        delete pos . pNode;
        pos . pNode = NULL;
        
    }

       // erase the items in the range first through last
    void erase( iterator first, iterator last ) {
        while (first != last) erase(first++);
    }

  
    const_iterator find( const_reference x ) const {
        return find( begin(), end(), x );
    }

    iterator find( const_reference x ) {
        return find( begin(), end(), x );
    }

    iterator find( iterator first, iterator last, const_reference x ) {
        while( first != last ) {
            if( _FnEq(*first, x) ) {
                return first;
            }
            first++;
        }
        return end();
    }

    const_iterator find( const_iterator first, const_iterator last, const_reference x ) const {
        while( first != last ) {
            if( _FnEq(*first, x) ) {
                return first;
            }
            first++;
        }
        return end();
    }

};

template< class T, class F >
typename lst< T >::iterator find( lst< T >& rLst, F& f ) {
    lst< T >::iterator I = rLst . begin();
    while( rLst . end() != I ) {
        if( f( *I ) ) {
            return I;
        }
        ++I;
    }
    return I;
}

template< class T, class F >
void for_each( lst< T >& rLst, F& f ) {
    lst< T >::iterator I = rLst . begin();
    while( rLst . end() != I ) {
        f( *I );
        ++I;
    }
}

#endif //__lst_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\mlzdbg.h ===
#ifndef _Multi_Level_Zone_Debug_H_
#define _Multi_Level_Zone_Debug_H_

#include <confdbg.h>
#include <debspew.h>

#define ZONE_FLAG(z)    (1 << (z))

#if defined(_DEBUG) && defined(MULTI_LEVEL_ZONES)

#define DEFAULT_ZONES       "Warning",    "Trace",     "Function",
#define BASE_ZONE_INDEX     (ZONE_FUNCTION + 1)


#undef TRACE_OUT
#define TRACE_OUT(s)        MLZ_TraceZoneEnabled(MLZ_FILE_ZONE) ? (MLZ_TraceOut s) : 0

#undef WARNING_OUT
#define WARNING_OUT(s)      MLZ_WarningOut s

#undef DebugEntry
#define DebugEntry(fn)          MLZ_EntryOut(MLZ_FILE_ZONE, #fn)

#undef DebugExitVOID
#define DebugExitVOID(fn)       MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_VOID,    (DWORD) 0)

#undef DebugExitBOOL
#define DebugExitBOOL(fn,f)     MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_BOOL,    (DWORD) f)

#undef DebugExitDWORD
#define DebugExitDWORD(fn,dw)   MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_DWORD,   (DWORD) dw)

#undef DebugExitHRESULT
#define DebugExitHRESULT(fn,hr) MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_HRESULT, (DWORD) hr)

#undef DebugExitINT
#define DebugExitINT(fn,n)      MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_INT,     (DWORD) n)

#undef DebugExitULONG
#define DebugExitULONG(fn,ul)   MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_ULONG,   (DWORD) ul)

#undef DebugExitPTR
#define DebugExitPTR(fn,lp)     MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_PTR,   (DWORD_PTR) lp)


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef enum
{
    RCTYPE_VOID     = 0,
    RCTYPE_BOOL     = 1,
    RCTYPE_DWORD    = 2,
    RCTYPE_HRESULT  = 3,
    RCTYPE_INT      = 4,
    RCTYPE_ULONG    = 5,
    RCTYPE_PTR      = 6
}
    RCTYPE;

void WINAPI  MLZ_DbgInit(PSTR *apszZones, UINT cZones);
void WINAPI  MLZ_DbgDeInit(void);
void WINAPIV MLZ_WarningOut(PSTR pszFormat, ...);
BOOL WINAPI  MLZ_TraceZoneEnabled(int iZone);
void WINAPIV MLZ_TraceOut(PSTR pszFormat, ...);
void WINAPI  MLZ_EntryOut(int iZone, PSTR pszFunName);
void WINAPI  MLZ_ExitOut(int iZone, PSTR pszFunName, RCTYPE eRetCodeType, DWORD_PTR dwRetCode);

#ifdef __cplusplus
}
#endif // __cplusplus

#else
#define DebugExitPTR(fn,lp)

#endif // _DEBUG && MULTI_ZONE_OUT

#endif // _Multi_Level_Zone_Debug_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\mperror.h ===
/*
 -  mperror.h
 -
 *      Microsoft Internet Phone
 *		Common error codes
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.20.95	Yoram Yaacovi		Created
 *		11.30.95	Lon-Chan Chu		Added MAKE_AVC_ERROR and MAKE_AVC_WARNING.
 *		12.02.95	Lon-Chan Chu		Added datapump error codes.
 */

#ifndef _AVC_ERROR_H_
#define _AVC_ERROR_H_

#include <winerror.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/*
 *	Macros
 */
#define HR_SUCCEEDED(_hr)		SUCCEEDED((SCODE)(_hr))
#define HR_FAILED(_hr)			FAILED((SCODE)(_hr))
#define MakeResult(_s)			ResultFromScode(_s)

/*
 *	Error codes
 *
 *	error codes for hResults are in winerror.h
 */
#define hrSuccess               0


//
//	Common macros
//

#define AVC_FACILITY			0x100		// facility code for audio/video communications
#define MAKE_AVC_ERROR(z,e)		MAKE_HRESULT(1,AVC_FACILITY,(((z)&0xF000)|(e)))
#define MAKE_AVC_WARNING(z,w)	MAKE_HRESULT(0,AVC_FACILITY,(((z)&0xF000)|(w)))

#define AVC_APP_ZONE			0x0000		// ui and application
#define AVC_DP_ZONE				0x1000		// datapump
#define AVC_NAC_ZONE			0x2000		// nac
#define AVC_CONN_ZONE			0x3000		// conn
#define AVC_NRES_ZONE			0x4000		// name resolution
#define AVC_UI_ZONE			0x5000		// ui
#define AVC_CAP_ZONE			0x6000
#define AVC_CCO_ZONE			0x7000
#define AVC_CADV_ZONE			0x8000
#define AVC_PC_ZONE				0x9000
#define AVC_CHAN_ZONE				0xA000

#define AVC_WIN32_ZONE			0xF000		// Win32 error code

#define Win32ErrToHR(e)			MAKE_AVC_ERROR (AVC_WIN32_ZONE, e)
#define GetLastHR()				Win32ErrToHR (GetLastError ())

//
//	NAC return codes
//
#define H323CC_E_INVALID_PARAM 		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0000)
#define H323CC_E_INSUFFICIENT_MEMORY 	MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0001)
#define H323CC_E_MORE_CONNECTIONS		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0004)
#define H323CC_E_NOACTIVELINE			MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0005)
#define H323CC_E_INIT_FAILURE			MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0006)
#define H323CC_E_CREATE_FAILURE		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0007)
#define H323CC_E_DATAPUMP_ERROR		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0008)
#define H323CC_E_REGISTRY_ERROR		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0009)
#define H323CC_E_NO_AUDIOHW			MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x000A)
#define H323CC_E_NETWORK_ERROR			MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x000B)
#define H323CC_E_NOT_INITIALIZED		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x000C)
#define H323CC_E_CONNECTION_NOT_FOUND	MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x000D)

//
// IConfAdvise interface error codes
//
#define CADV_E_INVALID_PARAM 	MAKE_AVC_ERROR(AVC_CADV_ZONE, 0x0000)
#define CADV_E_NOT_INITIALIZED 	MAKE_AVC_ERROR(AVC_CADV_ZONE, 0x0001)
#define CADV_E_NOT_SUPPORTED 	MAKE_AVC_ERROR(AVC_CADV_ZONE, 0x0002)

//
// connection object error codes
//

#define CONN_E_INVALID_PARAM  	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0000)
#define CONN_E_NOT_IDLE  		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0001)
#define CONN_E_BAD_ADDRESS		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0002)
#define CONN_E_CONNECT_FAILED	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0003)
#define CONN_E_INIT_FAILED		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0004)
#define CONN_E_OUT_OF_MEMORY	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0005)
#define CONN_E_MANDATORY_CHAN_OPEN_FAILED 	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0006)
#define CONN_E_SYSTEM_ERROR		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0007)
#define CONN_E_NOT_INITIALIZED		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0008)
#define CONN_E_ALREADY_INITIALIZED	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0009)
#define CONN_E_GK_NOT_REGISTERED	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x000A)

//
// control channel object error codes
//

#define CCO_E_INVALID_PARAM  	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0000)
#define CCO_E_NOT_IDLE  		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0001)
#define CCO_E_BAD_ADDRESS		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0002)
#define CCO_E_CONNECT_FAILED	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0003)
#define CCO_E_INIT_FAILED		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0004)
#define CCO_E_OUT_OF_MEMORY		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0005)
#define CCO_E_MANDATORY_CHAN_OPEN_FAILED 	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0006)
#define CCO_E_NODEFAULT_CHANNEL 	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0007)
#define CCO_E_INVALID_CAPABILITY  	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0008)
#define CCO_E_UNSUPPORTED_MEDIA_TYPE  	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0009)
#define CCO_E_SYSTEM_ERROR	 	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x000a)
#define CCO_E_NOT_LISTENING		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x000b)
#define CCO_E_NOT_SUPPORTED		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x000c)
//
//	channel (ICommChannel) error codes
//

#define CHAN_E_INVALID_PARAM  	MAKE_AVC_ERROR(AVC_CHAN_ZONE, 0x0000)
#define CHAN_E_NOT_OPEN  	    MAKE_AVC_ERROR(AVC_CHAN_ZONE, 0x0001)

//
// capability object error codes
//
#define AUDCAPS_W_MORE_FORMATS	MAKE_AVC_WARNING(AVC_CAP_ZONE,0x0001)
#define CAPS_W_NO_MORE_FORMATS  MAKE_AVC_WARNING(AVC_CAP_ZONE,0x0002)

#define CAPS_E_NOCAPS		        MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0001)
#define CAPS_E_NOMATCH		        MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0002)
#define CAPS_E_NOMEM			    MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0003)
#define CAPS_E_NOT_SUPPORTED        MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0005)
#define CAPS_E_BUFFER_TOO_SMALL	    MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0006)
#define	CAPS_E_SYSTEM_ERROR		    MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0007)
#define CAPS_E_INVALID_PARAM		MAKE_AVC_ERROR(AVC_CAP_ZONE,0x000F)

//
// datapump error codes
//

#define DPR_SUCCESS					0
#define DPR_INVALID_PARAMETER		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1)
#define DPR_INVALID_PROP_ID			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2)
#define DPR_INVALID_PROP_VAL		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3)
#define DPR_INVALID_PLATFORM		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x4)
#define DPR_CANT_PREPARE_HEADER		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x5)
#define DPR_CANT_UNPREPARE_HEADER	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x6)
#define DPR_CANT_GET_BUF_SIZE		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x7)
#define DPR_IMPOSSIBLE_SET_PROP		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x8)
#define DPR_CANT_ADD_BUFFER			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x9)
#define DPR_CANT_WRITE_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0xA)
#define DPR_CANT_OPEN_CODEC			MAKE_AVC_ERROR (AVC_DP_ZONE, 0xB)
#define DPR_CANT_OPEN_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0xC)
#define DPR_CANT_SET_VOLUME			MAKE_AVC_ERROR (AVC_DP_ZONE, 0xD)
#define DPR_CANT_INITIALIZE_AGAIN	MAKE_AVC_ERROR (AVC_DP_ZONE, 0xE)
#define DPR_OUT_OF_MEMORY			MAKE_AVC_ERROR (AVC_DP_ZONE, 0xF)
#define DPR_OUT_OF_SEQUENCE			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x10)
#define DPR_CONVERSION_FAILED		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x11)
#define DPR_CANT_CREATE_EVENT		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x12)
#define DPR_NET_SEND_ERROR			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x13)
#define DPR_NET_RECV_ERROR			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x14)
#define DPR_LATE_PACKET				MAKE_AVC_ERROR (AVC_DP_ZONE, 0x15)
#define DPR_DUPLICATE_PACKET		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x16)
#define DPR_CANT_START_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x17)
#define DPR_CANT_STOP_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x18)
#define DPR_INVALID_MEDIA_TYPE		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1A)
#define DPR_NOT_INITIALIZED			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1B)
#define DPR_NOT_CONFIGURED			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1C)
#define DPR_INVALID_FORMAT			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1D)
#define DPR_NO_PLAY_CAP				MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1E)
#define DPR_NO_RECORD_CAP			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1F)
#define DPR_CANT_RESET_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2B)
#define DPR_INVALID_HANDLE			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2C)
#define DPR_CANT_CLOSE_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2D)
#define DPR_CANT_INIT_RX_STREAM		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2E)
#define DPR_CANT_INIT_TX_STREAM		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2F)
#define DPR_NOT_YET_IMPLEMENTED		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x30)
#define DPR_PROPERTY_NOT_AVAILABLE	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x31)
#define DPR_CANT_INTERPOLATE		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x32)
#define DPR_CANT_WRITE_VIDEO_DEV	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x33)
#define DPR_CANT_OPEN_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x34)
#define DPR_CANT_CLOSE_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x35)
#define DPR_CANT_START_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x36)
#define DPR_CANT_STOP_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x37)
#define DPR_CANT_RESET_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x38)
#define DPR_CANT_PAUSE_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x39)
#define DPR_CANT_RESTART_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3A)
#define DPR_CANT_INIT_RXV_STREAM	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3B)
#define DPR_CANT_INIT_TXV_STREAM	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3C)
#define DPR_CANT_REGISTER_WND_CLASS	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3D)
#define DPR_CANT_CREATE_WINDOW		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3E)

// Datapump warning
#define DPR_NO_PACKET_READY         MAKE_AVC_WARNING (AVC_DP_ZONE, 0x1)
#define DPR_IO_PENDING              MAKE_AVC_WARNING (AVC_DP_ZONE, 0x2)

//name resolution errors
#define NMRES_E_INVALIDARG			MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0001)
#define NMRES_E_OUTOFMEMORY			MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0002)
#define NMRES_E_INETAPIFAILED		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0003)
#define NMRES_E_SERVERUNKNOWN		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0004)
#define NMRES_E_SERVNOTINITIALIZED  MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0005)
#define NMRES_E_SOCKCALLFAILED		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0006)
#define NMRES_E_IPAFILEPARSEFAILED  MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0007)
#define NMRES_E_UNEXPECTEDIPAREPLY	MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0008)
#define NMRES_E_IPALINEPARSEFAILED  MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0009)
#define NMRES_E_IPAQUERYFAILED		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000A)
#define NMRES_E_HTMLFILEPARSEFAILED	MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000B)
#define NMRES_E_IPARESULTCONVFAILED MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000C)
#define NMRES_E_DLGERROR			MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000D)
#define NMRES_E_NOUSERDETAILS		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000E)
#define NMRES_E_INETOPENURLFAILED	MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000F)


//name resolution warnings
#define NMRES_W_HTMLFILEIMPERFECT	MAKE_AVC_WARNING(AVC_NRES_ZONE,0x0001)

//
// Codec Performance error codes
//
#define PERFCODEC_SUCCESS					0
#define PERFCODEC_INVALID_PARAMETER			MAKE_AVC_ERROR(AVC_PC_ZONE,0x0001)
#define PERFCODEC_OUT_OF_MEMORY				MAKE_AVC_ERROR(AVC_PC_ZONE,0x0002)
#define PERFCODEC_CANT_OPEN_CODEC			MAKE_AVC_ERROR(AVC_PC_ZONE,0x0003)
#define PERFCODEC_CANT_GET_BUF_SIZE			MAKE_AVC_ERROR(AVC_PC_ZONE,0x0004)
#define PERFCODEC_CANT_PREPARE_HEADER		MAKE_AVC_ERROR(AVC_PC_ZONE,0x0005)
#define PERFCODEC_CANT_CONVERT				MAKE_AVC_ERROR(AVC_PC_ZONE,0x0006)
#define PERFCODEC_CANT_UNPREPARE_HEADER		MAKE_AVC_ERROR(AVC_PC_ZONE,0x0007)
#define PERFCODEC_CANT_CLOSE_CODEC			MAKE_AVC_ERROR(AVC_PC_ZONE,0x0008)
#define PERFCODEC_CREATE_FAILED				MAKE_AVC_ERROR(AVC_PC_ZONE,0x0009)
#define PERFCODEC_DELETE_FAILED				MAKE_AVC_ERROR(AVC_PC_ZONE,0x000A)

#include <poppack.h> /* End byte packing */

#endif // _AVC_ERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\memtrack.h ===
//
// MEMTRACK.H
// Standard NetMeeting memory leak tracking.
//
// In retail:
//      new/MemAlloc    become      LocalAlloc()
//      MemReAlloc      becomes     LocalReAlloc()
//      delete/MemFree  become      LocalFree()
//
// In debug:
//      allocations are tracked, with module/file/line number
//      leaked blocks are spewed when the module unloads
//
// 
// USAGE:
// (1) Include this header and link to NMUTIL
// (2) If your component requires zero-initialized memory, define 
//      _MEM_ZEROINIT (for both debug and retail) in your SOURCES file
// (3) In your DllMain, on DLL_PROCESS_ATTACH call DBG_INIT_MEMORY_TRACKING,
//     and on DLL_PROCESS_DETACH call DBG_CHECK_MEMORY_TRACKING
// (4) In DEBUG, you can make a call to DbgMemTrackDumpCurrent() to dump
//      the currently allocated memory list from code.
//


#ifndef _MEMTRACK_H
#define _MEMTRACK_H

#ifdef __cplusplus
extern "C" {
#endif

//
// MEMORY ALLOCATIONS/TRACKING
//
//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef DEBUG


#undef assert
#define assert(x)           ASSERT(x)


void    WINAPI DbgMemTrackDumpCurrent(void);
void    WINAPI DbgMemTrackFinalCheck(void);

LPVOID  WINAPI DbgMemAlloc(UINT cbSize, LPVOID caller, LPSTR pszFileName, UINT nLineNumber);
void    WINAPI DbgMemFree(LPVOID ptr);
LPVOID  WINAPI DbgMemReAlloc(LPVOID ptr, UINT cbSize, UINT uFlags, LPSTR pszFileName, UINT nLineNumber);


#define DBG_CHECK_MEMORY_TRACKING(hInst)     DbgMemTrackFinalCheck()  
 
#define MemAlloc(cbSize)            DbgMemAlloc(cbSize, NULL, __FILE__, __LINE__)

#ifdef _MEM_ZEROINIT
#define MemReAlloc(pObj, cbSize)    DbgMemReAlloc((pObj), (cbSize), LMEM_MOVEABLE | LMEM_ZEROINIT, __FILE__, __LINE__)
#else
#define MemReAlloc(pObj, cbSize)    DbgMemReAlloc((pObj), (cbSize), LMEM_MOVEABLE, __FILE__, __LINE__)
#endif //_MEM_ZEROINIT

#define MemFree(pObj)               DbgMemFree(pObj)

void    WINAPI DbgSaveFileLine(LPSTR pszFileName, UINT nLineNumber);
#define DBG_SAVE_FILE_LINE          DbgSaveFileLine(__FILE__, __LINE__);


// RETAIL
#else

#define DBG_CHECK_MEMORY_TRACKING(hInst)   

#ifdef _MEM_ZEROINIT
#define MemAlloc(cbSize)            LocalAlloc(LPTR, (cbSize))
#define MemReAlloc(pObj, cbSize)    LocalReAlloc((pObj), (cbSize), LMEM_MOVEABLE | LMEM_ZEROINIT)
#else
#define MemAlloc(cbSize)            LocalAlloc(LMEM_FIXED, (cbSize))
#define MemReAlloc(pObj, cbSize)    LocalReAlloc((pObj), (cbSize), LMEM_MOVEABLE)
#endif // _MEM_ZEROINIT

#define MemFree(pObj)               LocalFree(pObj)

#define DBG_SAVE_FILE_LINE

#endif // DEBUG


void WINAPI DbgInitMemTrack(HINSTANCE hDllInst, BOOL fZeroOut);
#ifdef _MEM_ZEROINIT
#define DBG_INIT_MEMORY_TRACKING(hInst)     DbgInitMemTrack(hInst, TRUE)
#else
#define DBG_INIT_MEMORY_TRACKING(hInst)     DbgInitMemTrack(hInst, FALSE)
#endif //_MEM_ZEROINIT



#define MEMALLOC(cb)                MemAlloc(cb)
#define MEMREALLOC(p, cb)           MemReAlloc(p, cb)
#define MEMFREE(p)                  MemFree(p)


#ifdef __cplusplus
}
#endif




#endif // #ifndef _MEMTRACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\mscnfapi.h ===
/*****************************************************************/ 
/**						 Microsoft Windows						**/
/**				Copyright (C) Microsoft Corp., 1995				**/
/*****************************************************************/ 

/*
 * mscnfapi.h
 *
 * This header file contains definitions for the Windows Conferencing API.
 */

#ifndef _MSCNFAPI_
#define _MSCNFAPI_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Registry key and value names.
 *
 * Under HKEY_LOCAL_MACHINE\<REGSTR_PATH_CONFERENCING>, the value
 * <REGSTR_VAL_APIPROVIDER> is a string value naming the DLL which
 * provides the Windows Conferencing API.  If this value is present,
 * the conferencing software is installed, and the application should
 * use LoadLibrary to load the specified DLL.  If the key or value is
 * not present, conferencing software is not installed and the
 * application should hide or disable any conferencing-related features.
 */

#define REGSTR_PATH_CONFERENCING	"Software\\Microsoft\\Conferencing"
#define REGSTR_VAL_APIPROVIDER		"API Provider"

/*
 * Error code definitions.
 */

typedef unsigned int CONFERR;

#define CONF_SUCCESS			ERROR_SUCCESS
#define CONF_MOREDATA			ERROR_MORE_DATA
#define CONF_INVALIDPARAM		ERROR_INVALID_PARAMETER
#define CONF_OOM				ERROR_NOT_ENOUGH_MEMORY
#define CONF_USERCANCELED		ERROR_CANCELLED
#define CONF_NOTSUPPORTED		ERROR_NOT_SUPPORTED
#define CONF_PERMISSIONDENIED	ERROR_ACCESS_DENIED

#define CONF_CUSTOM_ERROR_BASE	3000
#define CONF_APPCANCELLED		(CONF_CUSTOM_ERROR_BASE + 0)
#define CONF_ALREADYSHARED		(CONF_CUSTOM_ERROR_BASE + 1)
#define CONF_ALREADYUNSHARED	(CONF_CUSTOM_ERROR_BASE + 2)

/*
 * All conference management and application sharing APIs should be loaded
 * from the API provider DLL via GetProcAddress, by name.  The following
 * type definitions are provided to declare function pointers that will be
 * returned by GetProcAddress.
 */

/*
 * Conference Management APIs
 */

typedef HANDLE HCONFERENCE;

typedef CONFERR (WINAPI *pfnConferenceStart)(HWND hwndParent, HCONFERENCE *phConference, LPVOID pCallAddress);
typedef CONFERR (WINAPI *pfnConferenceEnumerate)(HCONFERENCE *pHandleArray, UINT *pcHandles);
typedef CONFERR (WINAPI *pfnConferenceGet)(HWND hwndParent, HCONFERENCE *pHandle);
typedef CONFERR (WINAPI *pfnConferenceGetGCCID)(HCONFERENCE hConference, WORD *pID);
typedef CONFERR (WINAPI *pfnConferenceGetName)(HCONFERENCE hConference, LPSTR pName, UINT *pcbName);
typedef CONFERR (WINAPI *pfnConferenceStop)(HWND hwndParent, HCONFERENCE hConference);

#define WM_CONFERENCESTATUS		0x0060

/*
 * Application Sharing APIs
 */

typedef BOOL (WINAPI *pfnIsWindowShared)(HWND hWnd, LPVOID pReserved);
typedef CONFERR (WINAPI *pfnShareWindow)(HWND hWnd, BOOL fShare, LPVOID pReserved);

#define WM_SHARINGSTATUS		0x0061

#define CONFN_SHAREQUERY			0
#define CONFN_SHARED				1
#define CONFN_SHARESTOPPED			2
#define CONFN_SHARESTOPQUERY		3
#define CONFN_CONFERENCESTART		4
#define CONFN_CONFERENCESTOPQUERY	5
#define CONFN_CONFERENCESTOPPED		6
#define CONFN_CONFERENCESTOPABORTED	7

#ifdef __cplusplus
};	/* extern "C" */
#endif

#endif	/* _MSCNFAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\mtgset.h ===
//
// MTGSET.H
// Meeting Setting definitions and structures
//
// Copyright (c) Microsoft Copr., 1999-
//

#ifndef _MTGSET_H
#define _MTGSET_H


extern GUID g_csguidMeetingSettings;


//
// Remote permission flags NM 3.0
//
#define NM_PERMIT_OUTGOINGCALLS     0x00000001
#define NM_PERMIT_INCOMINGCALLS     0x00000002
#define NM_PERMIT_SENDAUDIO         0x00000004
#define NM_PERMIT_SENDVIDEO         0x00000008
#define NM_PERMIT_SENDFILES         0x00000010
#define NM_PERMIT_STARTCHAT         0x00000020
#define NM_PERMIT_STARTOLDWB        0x00000040  // WILL BE OBSOLETE IN A WHILE
#define NM_PERMIT_USEOLDWBATALL     0x00000080  // "", for RDS
#define NM_PERMIT_STARTWB           0x00000100
#define NM_PERMIT_SHARE             0x00000200
#define NM_PERMIT_STARTOTHERTOOLS   0x00000400

#define NM_PERMIT_ALL               0x000007FF

// This is the structure of the GUID_MTGSETTINGS data
typedef DWORD   NM30_MTG_PERMISSIONS;
                                  
#endif // ndef _MTGSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nacguids.h ===
/*
 *  	File: nacguids.h
 *
 *      Defines protocol IDs, media types, capability object IDs used by 
 * 		NAC.DLL
 *
 *		Revision History:
 *
 *		09/18/96	mikev	created
 */

// {D2E97230-0C18-11d0-AD53-00AA004A80A3}
DEFINE_GUID(OID_CAP_ACM_TO_H323, 		// h323 capability resolver
0xd2e97230, 0xc18, 0x11d0, 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {D2E97231-0C18-11d0-AD53-00AA004A80A3}
DEFINE_GUID(OID_CAP_ACM_TO_MSIA, 		// MSICCP capability resolver
0xd2e97231, 0xc18, 0x11d0, 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {A4209190-14B4-11d0-AD55-00AA004A80A3}
DEFINE_GUID(PID_H323, 					// H.323 protocol ID
0xa4209190, 0x14b4, 0x11d0, 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {8C85D5E0-22E2-11d0-AD58-00AA004A80A3}
DEFINE_GUID(MEDIA_TYPE_H323VIDEO, 		// media type Video
0x8c85d5e0, 0x22e2, 0x11d0, 0xad, 0x58, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {8C85D5E1-22E2-11d0-AD58-00AA004A80A3}
DEFINE_GUID(MEDIA_TYPE_H323AUDIO, 		// media type Audio
0x8c85d5e1, 0x22e2, 0x11d0, 0xad, 0x58, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {97ADE24E-E0EA-11d0-B2DD-00C04FD919C9}
DEFINE_GUID(MEDIA_TYPE_H323_T120, 		// T120 channel in H.323 session
0x97ade24e, 0xe0ea, 0x11d0, 0xb2, 0xdd, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);


//
// 	Interface ID's. 
//

// {FCD77356-EF58-11d1-B32B-00C04FD919C9}
DEFINE_GUID(IID_IH323CC, 
0xfcd77356, 0xef58, 0x11d1, 0xb3, 0x2b, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D94-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_INac, 
0x8ad05d94, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D95-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IPhoneConnection, 
0x8ad05d95, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D96-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_ICommChannel, 
0x8ad05d96, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D97-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IAppAudioCap, 
0x8ad05d97, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D98-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IAppVidCap, 
0x8ad05d98, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D99-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IDualPubCap, 
0x8ad05d99, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D9A-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IVideoRender, 
0x8ad05d9a, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {4F354BB4-8443-11d0-B2B0-00C04FD919C9}
DEFINE_GUID(IID_ICtrlCommChannel, 
0x4f354bb4, 0x8443, 0x11d0, 0xb2, 0xb0, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {0230C3D4-8E75-11d0-B2B2-00C04FD919C9}
DEFINE_GUID(IID_IConfAdvise, 
0x230c3d4, 0x8e75, 0x11d0, 0xb2, 0xb2, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {50E94A04-6C42-11d1-B311-00C04FD919C9}
DEFINE_GUID(IID_IH323ConfAdvise, 
0x50e94a04, 0x6c42, 0x11d1, 0xb3, 0x11, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {50E94A05-6C42-11d1-B311-00C04FD919C9}
DEFINE_GUID(IID_IMediaChannelBuilder, 
0x50e94a05, 0x6c42, 0x11d1, 0xb3, 0x11, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

DEFINE_GUID(IID_IMediaChannel,
0x06f87f70, 0x793e, 0x11d0, 0x8e, 0xf0, 0x0, 0xa0, 0xc9, 0x05, 0x41, 0xf4);

DEFINE_GUID(IID_IAudioChannel,
0xd92d5d30, 0xe78e, 0x11d1, 0xa9, 0x76, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);

DEFINE_GUID(IID_IVideoChannel,
0x138889f0, 0xee9d, 0x11d1, 0xa9, 0x7d, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);


// {11A5FA28-C8C6-11d1-B320-00C04FD919C9}
DEFINE_GUID(IID_IH323MediaCap, 
0x11a5fa28, 0xc8c6, 0x11d1, 0xb3, 0x20, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {C3DD8828-1A97-11d2-B331-00C04FD919C9}
DEFINE_GUID(IID_IStreamSignal, 
0xc3dd8828, 0x1a97, 0x11d2, 0xb3, 0x31, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);


// The naming convention is not followed for the following because the interface
// name (IProperty) will probably collide with something else.  This interface is
// a specific pseudo property interface that has very specific media control 
// properties. 
// {8AD05D9B-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IAudioPseudoProperty, 
0x8ad05d9b, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

DEFINE_GUID(IID_IVideoDevice,
0xe040ad20, 0xf5a2, 0x11d1, 0xa9, 0x7f, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);

// e9604a60-f691-11d1-a97f-00c04fd91a6f 
DEFINE_GUID(IID_IAudioDevice,
0xe9604a60, 0xf691, 0x11d1, 0xa9, 0x7f, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);


DEFINE_GUID(IID_IMixer,
0x142e1ff0, 0xf692, 0x11d1, 0xa9, 0x7f, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);


DEFINE_GUID(IID_IDTMFSend,
0x2e29f4c0, 0x93f4, 0x11d2, 0xa9, 0xbe, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmappletdispid.h ===
#ifndef __NmAppletDispID_h__
#define __NmAppletDispID_h__

#define DISPID_ONSTATECHANGED 1



#endif // __NmAppletDispID_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\netmeetingcp.h ===
#ifndef _NETMEETINGCP_H_
#define _NETMEETINGCP_H_
#include <NmDispid.h>
template <class T>
class CProxy_INetMeetingEvents : public IConnectionPointImpl<T, &DIID__INetMeetingEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_ConferenceStarted()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(DISPID_ConferenceStarted, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_ConferenceEnded()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(DISPID_ConferenceEnded, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmappletimpl.h ===
#ifndef __NmAppletImpl_h__
#define __NmAppletImpl_h__


#define DECLARE_NMAPPLET_CAPS(dwCaps)\
    static DWORD _GetNmAppletCaps()\
    {\
        return dwCaps;\
    }

#define DECLARE_NMAPPLET_FILE_OPEN_FILTER(idStringResourceFilter, idStringResourceExt) \
    static HRESULT _GetNmAppletFileOpenFilter( LPTSTR szFilter, int cchMaxFilter, LPTSTR szExtension, int cchMaxExtension )\
    {	HRESULT hr = S_OK;\
		DBGENTRY(_GetNmAppletFileOpenFilter);\
		if( SUCCEEDED( hr = NmCtlLoadString( idStringResourceFilter, szFilter, cchMaxFilter ) ) )\
		{\
			hr = NmCtlLoadString( idStringResourceExt, szExtension, cchMaxExtension );\
		}\
		DBGEXIT_HR(_GetNmAppletFileOpenFilter,hr);\
        return hr;\
    }

template <class T>
class ATL_NO_VTABLE INmAppletImpl
{
// YOU MUST ONLY PUT DATA MEMBERS OR HELPER FNS AT THE END OF THE CLASS
// THE VTABLE FOR INmAgendaItemView MUST BE AT THE BEGINNING OF THE CLASS!!!!

public:
    INmAppletImpl( void )
    : m_bInsertFileMenuIntoEditGroup( false )
     { 
        DBGENTRY(INmAppletImpl::INmAppletImpl);
        DBGEXIT(INmAppletImpl::INmAppletImpl);
     }
    ~INmAppletImpl( void ) 
    { 
        DBGENTRY(INmAppletImpl::~INmAppletImpl);
        DBGEXIT(INmAppletImpl::~INmAppletImpl);
    }

public:

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(INmAppletImpl)


        // The INmApplet Interface...
    STDMETHOD(get_NmAppletCaps)( OUT DWORD* pdwCaps )
    {
        DBGENTRY(INmAppletImpl::get_NmAppletCaps)
        HRESULT hr = S_OK;

        ASSERT( pdwCaps != NULL );

        *pdwCaps = T::_GetNmAppletCaps();

        DBGEXIT_HR(INmAppletImpl::get_NmAppletCaps ,hr)
        return hr;
    }

    STDMETHOD(SaveDialog)( /*[in, out, retval]*/ LPTSTR lpszFile, /*[in]*/ DWORD dwFlags, /*[out]*/ LPWORD pnFileOffset )
    {
        DBGENTRY(INmAppletImpl::SaveDialog)
        HRESULT hr = S_OK;

        T* pT = static_cast<T*>(this);
   
        TCHAR szFilter[MAX_PATH];
		TCHAR szDefExt[MAX_PATH];
        
        if( SUCCEEDED ( hr = T::_GetNmAppletFileOpenFilter( szFilter, CCHMAX( szFilter ), szDefExt, CCHMAX( szDefExt ) ) ) )
        {
            ConvertSzCh(szFilter);

            OPENFILENAME ofn;
            ClearStruct( &ofn );
            ofn.lStructSize = sizeof( OPENFILENAME );
            ofn.hwndOwner = pT->m_hWnd;
            ofn.lpstrFilter = szFilter;
			ofn.lpstrFile = lpszFile;
            ofn.nMaxFile = MAX_PATH;
			ofn.lpstrDefExt = szDefExt;
            ofn.Flags = dwFlags;
            if( !GetSaveFileName( &ofn ) )
			{
				hr = E_FAIL;
			}
			else
			{
				*pnFileOffset = ofn.nFileOffset;
			}
        }

        DBGEXIT_HR(INmAppletImpl::SaveDialog,hr)
        return hr;
    }


    STDMETHOD(OpenDialog)()
    {
        DBGENTRY(INmAppletImpl::OpenDialog)

        HRESULT hr = E_NOTIMPL;

        DBGEXIT_HR(INmAppletImpl::OpenDialog,hr)
        return hr;
    }


    STDMETHOD(GetIconBitmaps)( IN int cxBitmap, IN int cyBitmap,
                               OUT int*	   pcStates,
							   OUT HBITMAP** pphBitmapIcon,
							   OUT HBITMAP** pphBitmapIconHot,
							   OUT HBITMAP** pphBitmapIconDisabled
							  )

    {
        DBGENTRY(INmAppletImpl::GetIconBitmaps)

        HRESULT hr = E_NOTIMPL;

        DBGEXIT_HR(INmAppletImpl::GetIconBitmaps,hr)
        return hr;
    }

    STDMETHOD(GetIconLabel)( OUT BSTR* pLabel )
    {

        DBGENTRY(INmAppletImpl::GetIconLabel)

        HRESULT hr = E_NOTIMPL;

        DBGEXIT_HR(INmAppletImpl::GetIconLabel,hr)
        return hr;
    }

    STDMETHOD(OnContainerActivating)( IN BOOL bAppActivating )
    {
        DBGENTRY(INmAppletImpl::OnContainerActivating)

        HRESULT hr = S_OK;

        DBGEXIT_HR(INmAppletImpl::OnContainerActivating,hr)
        return hr;
    }

    STDMETHOD(SetFocus)()
    {
        DBGENTRY(INmAppletImpl::SetFocus)

        HRESULT hr = S_OK;

        DBGEXIT_HR(INmAppletImpl::SetFocus,hr)
        return hr;
    }

    STDMETHOD(SetClientSite)( IN INmAppletClientSite* pClientSite )
    {
        DBGENTRY(INmAppletImpl::SetClientSite);
        HRESULT hr = S_OK;

        m_spContianerAppletSite = pClientSite;

        DBGEXIT_HR(INmAppletImpl::SetClientSite,hr);
        return hr;
    }

	STDMETHOD(ShiftFocus)( IN HWND hWndCur, BOOL bForward )
	{
        DBGENTRY(INmAppletImpl::ShiftFocus);
        HRESULT hr = S_OK;

        DBGEXIT_HR(INmAppletImpl::ShiftFocus,hr);
        return hr;
	}

	STDMETHOD(IsChild)( IN HWND hWnd )
	{
        DBGENTRY(INmAppletImpl::IsChild);

        HRESULT hr = S_FALSE;

        DBGEXIT_HR(INmAppletImpl::IsChild,hr);
        return hr;
	}

	STDMETHOD(QueryEndSession)( OUT BOOL* pbCancelTermination )
	{
		DBGENTRY(INmAppletImpl::QueryEndSession);
		HRESULT hr = S_OK;
		if( pbCancelTermination )
		{
			*pbCancelTermination = FALSE;
		}
		else
		{
			hr = E_POINTER;
		}

		DBGEXIT_HR(INmAppletImpl::QueryEndSession,hr);
		return hr;
	}

	STDMETHOD(OnMenuSelect)( IN DWORD wParam, IN DWORD lParam )
	{
		DBGENTRY(INmAppletImpl::OnMenuSelect);
		HRESULT hr = S_OK;

		DBGEXIT_HR(INmAppletImpl::OnMenuSelect,hr);
		return hr;
	}

	STDMETHOD(OnCommand)( IN DWORD wParam, IN DWORD lParam )
	{
		DBGENTRY(INmAppletImpl::OnCommand);
		HRESULT hr = S_OK;

		DBGEXIT_HR(INmAppletImpl::OnCommand,hr);
		return hr;
	}

	STDMETHOD(OnGetMinMax)( IN DWORD lParam )
	{
		DBGENTRY(INmAppletImpl::OnGetMinMax);
		HRESULT hr = S_OK;

		DBGEXIT_HR(INmAppletImpl::OnGetMinMax,hr);
		return hr;
	}


    static DWORD _GetNmAppletCaps() { return 0; }

protected:
    // PUT data members here
    bool m_bInsertFileMenuIntoEditGroup;
    CComPtr<INmAppletClientSite> m_spContianerAppletSite;
};


static HRESULT _MoveMenuToSharedMenu( HMENU hMenu, HMENU hMenuShared, int MenuBarIndex, int InsertionIndex )
{
    DBGENTRY(MoveMenuToSharedMenu);
    HRESULT hr = S_OK;

    if( IsMenu( hMenu ) && IsMenu( hMenuShared ) )
    {
        TCHAR szMenuItem[ MAX_PATH ] = TEXT("");
        int cbMenuItem = 0;
    
        MENUITEMINFO mii;
        ClearStruct( &mii );
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_DATA | MIIM_SUBMENU | MIIM_TYPE;
        mii.fType = MFT_STRING;

        cbMenuItem = GetMenuString( hMenu, MenuBarIndex, szMenuItem, MAX_PATH, MF_BYPOSITION );
        if( 0 != cbMenuItem )
        {
            mii.cch = 1 + cbMenuItem;
            mii.dwTypeData = szMenuItem;
            mii.hSubMenu = GetSubMenu( hMenu, MenuBarIndex );
            
            RemoveMenu( hMenu, MenuBarIndex, MF_BYPOSITION );

            if( 0 == InsertMenuItem( hMenuShared, InsertionIndex, TRUE, &mii ) )
            {
                ERROR_OUT(("InsertMenuItem failed"));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            ERROR_OUT(("GetMenuString failed"));
            hr = E_FAIL;
        }
    }
    else
    {
        ERROR_OUT(("Passed a bad menu handle"));
        hr = E_HANDLE;
    }

    DBGEXIT_HR( MoveMenuToSharedMenu, hr );
    return hr;
}

inline STDMETHODIMP NmApplet_UIActivate(LONG iVerb, 
                                        const RECT* prcPosRect,
                                        CComControlBase* pThis,
                                        HMENU* phMenuShared, 
                                        DWORD dwMenuResourceID,
                                        int nEditGroupMenuBarItems,
                                        int nObjectGroupMenuBarItems,
                                        int nHelpGroupMenuBarItems
                                )
{
    
    DBGENTRY(Applet_UIActivate);
    HRESULT hr = S_OK;

    bool bPreviouslyActiveUI = pThis->m_bUIActive;
        // CComControlBase::InPlaceActivawe may change the state of m_bUIActive
        // which would indicate that we are UI activating for the first time...
    hr = pThis->InPlaceActivate( iVerb, NULL );

    if( SUCCEEDED( hr ) && (!bPreviouslyActiveUI) && pThis->m_bUIActive )
    {
        OLEINPLACEFRAMEINFO frameInfo;
	    RECT rcPos, rcClip;
	    CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	    CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
        ClearStruct(&frameInfo);
	    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	    
	    CComPtr<IOleInPlaceObject> pIPO;
	    pThis->ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	    _ASSERTE(pIPO != NULL);
	    if (prcPosRect != NULL)
        {
		    pIPO->SetObjectRects(prcPosRect, prcPosRect);
        }


        if( pThis->m_spInPlaceSite )
        {
    	    hr = pThis->m_spInPlaceSite->GetWindowContext(&spInPlaceFrame, &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
            if( spInPlaceFrame )
            {

                // Create the shared menu...
                *phMenuShared = ::CreateMenu();        
                if( NULL != *phMenuShared )
                {

                    OLEMENUGROUPWIDTHS mgw;
                    ClearStruct( &mgw );
        
                    if( SUCCEEDED( hr = spInPlaceFrame->InsertMenus(*phMenuShared, &mgw) ) )
                    {
                        HMENU hMenu = LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE( dwMenuResourceID ) );
                        if( hMenu )
                        {
                            int InsertionIndex, i;

                             // Edit Group                                
                            InsertionIndex = mgw.width[0];
                            for( i = 0; i < nEditGroupMenuBarItems; i++ )
                            {
                                _MoveMenuToSharedMenu( hMenu, *phMenuShared, 0, InsertionIndex + i );
                            }
                            mgw.width[1] = nEditGroupMenuBarItems;

                            // Object Group   
							
                            InsertionIndex = mgw.width[0] + mgw.width[1] + mgw.width[2];
                            for( i = 0; i < nObjectGroupMenuBarItems; i++ )
                            {
                                _MoveMenuToSharedMenu( hMenu, *phMenuShared, 0, InsertionIndex + i );
                            }
                            mgw.width[3] = nObjectGroupMenuBarItems; // Object Group
							

                            // Help Group
							
                            InsertionIndex = mgw.width[0] + mgw.width[1] + mgw.width[2] + mgw.width[3] + mgw.width[4];
                            for( i = 0; i < nHelpGroupMenuBarItems; i++ )
                            {
                                _MoveMenuToSharedMenu( hMenu, *phMenuShared, 0, InsertionIndex + i );
                            }
                            mgw.width[5] = nHelpGroupMenuBarItems; // Help Group
							

                            HOLEMENU hOLEMENU = OleCreateMenuDescriptor( *phMenuShared, &mgw );
                            if( hOLEMENU )
                            {
                                hr = spInPlaceFrame->SetMenu( *phMenuShared, hOLEMENU, pThis->m_hWndCD );
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }

                            DestroyMenu(hMenu);

                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                    }
                    else
                    {
                        DestroyMenu( *phMenuShared );
                        *phMenuShared = NULL;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERROR_OUT(("Could not create menu..."));
                }
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    
    DBGEXIT_HR(Applet_UIActivate,hr);

    return hr;

}




#endif // __NmAppletImpl_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nameres.h ===
//
// This is the header file for simple conference name resolution
//
//	Created:	ClausGi	11-02-95
//

#ifndef _NAME_RES_H
#define _NAME_RES_H

// These are provisional

#define NAMETYPE_UNKNOWN	0
#define	NAMETYPE_IP			1
#define	NAMETYPE_PSTN		2
#define	NAMETYPE_IPX		3
#define NAMETYPE_NDS		4
#define	NAMETYPE_ULS		5
#define NAMETYPE_NETBIOS	6
#define NAMETYPE_COMM		7
#define NAMETYPE_H323GTWY	8
#define NAMETYPE_RAS		9
#define NAMETYPE_ALIAS_ID   10
#define NAMETYPE_ALIAS_E164 11
#define	NAMETYPE_CALLTO		12

#define	NAMETYPE_DEFAULT	NAMETYPE_IP

#define	NUM_NAMETYPES		8

#define	MAX_UNRESOLVED_NAME	255
#define	MAX_RESOLVED_NAME	255
#define	MAX_DISPLAY_NAME	255

// These must correspond to above BUGBUG localize?
// These should not be used - check "Display Name" in the registry
//
// These are obsolete and not being used
#define	NAMESTRING_UNKNOWN	"Unknown"
#define	NAMESTRING_IP		"Network (IP)"
#define	NAMESTRING_PSTN		"Telephone Number"
#define	NAMESTRING_IPX		"Network (IPX)"
#define	NAMESTRING_NDS		"Network (NDS)"
#define	NAMESTRING_ISP		"Internet Name"
#define NAMESTRING_NETBIOS	"Network (NETBIOS)"

// Name resolution return codes:

#define	RN_SUCCESS				0	// valid return
#define	RN_FAIL					1	// general error return
#define	RN_NAMERES_NOT_INIT		2	// name service not initialized
#define	RN_XPORT_DISABLED		3	// requested transport disabled
#define	RN_XPORT_NOTFUNC		4	// requested transport not functioning
#define	RN_TOO_AMBIGUOUS		5	// the unknown name type was too ambiguous
#define	RN_POOR_MATCH			6	// best syntax match not good enough
#define	RN_NO_SYNTAX_MATCH		7	// didn't match syntax for any active xport
#define	RN_ERROR				8	// internal ("unexpected") error
#define	RN_LOOPBACK				9	// address is identified as own
#define	RN_PENDING				10	// return of async request
#define	RN_INVALID_PARAMETER	11	// error in function parameters
#define RN_NAMERES_BUSY			12	// Timed out on a mutex
#define RN_ASYNC				13	// Name resolution is async
#define RN_SERVER_SERVICE				14	// Specially designated for ULS (ILS_E_SERVER_SERVICE)

// Name resolution callstruct dwFlags fields

#define	RNF_ASYNC			0x00000001	// Specifies async resolution
#define	RNF_CANCEL			0x00000002	// Cancels all async resolution ops
#define	RNF_FIRSTMATCH		0x00000004

typedef DWORD (WINAPI * PRN_CALLBACK)(LPBYTE pRN_CS); //BUGBUG type

typedef struct tag_ResolveNameCallstruct {
			DWORD	IN	dwFlags;
			DWORD	IN OUT	dwAsyncId;
			DWORD	OUT dwAsyncError;
			PRN_CALLBACK pCallback;
			DWORD	IN OUT	dwNameType;
			TCHAR	IN	szName[MAX_UNRESOLVED_NAME+1];
			TCHAR	OUT	szResolvedName[MAX_RESOLVED_NAME+1];
			TCHAR	OUT	szDisplayName[MAX_DISPLAY_NAME+1];
} RN_CS, * PRN_CS;

// Functions:

extern DWORD WINAPI ResolveName2 (
			IN OUT PRN_CS	pRN_CS );

extern DWORD WINAPI ResolveName ( 
			IN LPCSTR szName,
			IN OUT LPDWORD lpdwNameType,
			OUT LPBYTE lpResult,
			IN OUT LPDWORD lpdwResult,
			OUT LPSTR lpszDisplayName,
			IN OUT LPDWORD lpdwDisplayName,
			OUT LPUINT puAsyncRequest);

extern BOOL InitializeNameServices(VOID);

extern VOID DeInitializeNameServices(VOID);

extern BOOL IsNameServiceInitialized(DWORD dwNameType);

#endif	//#ifndef _NAME_RES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __NM_ASN1_H__
#define __NM_ASN1_H__

#include <msper.h>

#endif // __NM_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nameserv.h ===
/*
 -  nameres.h
 -
 *      Microsoft Internet Phone user interface
 *		Name Resolution exported header
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.25.95	Yoram Yaacovi		Created
 *					Sunita				Added name service functions and ipa macros
 */

#ifndef _NAMERES_H
#define _NAMERES_H

#ifdef __cplusplus
extern "C" {
#endif

//definitions
//external
#define BY_HOST_NAME				1
#define	BY_USER_NAME				2

#define MPNS_PROMPT					0x0001
#define MPNS_SHOWDIR				0x0002
#define MPNS_RETURNHTML				0x0004
#define MPNS_GETADDR				0x0008
#define MPNS_SAVE					0x0010
#define MPNS_GETDETAILS				0x0020
#define MPNS_ALLOWSAVE				0x0040

//internal
#define MAXSERVERNAMELEN			256
#define MAXIPAFILESIZE				4096
#define MAXSERVERDLLNAMELEN			256
#define MAXIPALINELEN				512
#define MAXREGISTEREDNAMELEN		256
#define MAXIPAACTIONLEN				16
#define MAXIPAPAIRSPERLINE			3
#define MAXIPARESULTLEN				64
#define MAXSEARCHEXPLEN				256
#define MAXDIRECTORYLEN				1000
#define MAX_IP_ADDRESS_STRING_SIZE	16
#define LITTLE_STRING_BUFFER_SIZE	8
#define	MAXUSERINFOSIZE				MAXREGISTEREDNAMELEN

// version defines.

#define CURRENT_CLIENT_VERSION		"0001"

// keep-alive periods.

#define CLIENT_KEEP_ALIVE_PERIOD	20000	// 20 seconds.
#define SERVER_KEEP_ALIVE_PERIOD	30000	// 30 seconds.
#define LOWER_TIME_LIMIT			1000	// 1 second.
#define UPPER_TIME_LIMIT			900000	// 15 minutes.
	
//for now we just call in char
#ifdef UNICODE
typedef TCHAR	REGISTEREDNAME[MAXREGISTEREDNAMELEN];
#else
typedef char	REGISTEREDNAME[MAXREGISTEREDNAMELEN*2];
#endif //!UNICODE

#ifdef UNICODE
typedef struct USERDETAILS{
	REGISTEREDNAME	szRegName;
	TCHAR			szFullName[MAXUSERINFOSIZE];
	TCHAR			szLocation[MAXUSERINFOSIZE];
	TCHAR			szHostName[MAXUSERINFOSIZE];
	TCHAR			szEmailName[MAXUSERINFOSIZE];
	TCHAR			szHomePage[MAXUSERINFOSIZE];
	TCHAR			szComments[MAXUSERINFOSIZE];
}USERDETAILS, *PUSERDETAILS;
#else
typedef struct USERDETAILS{
	REGISTEREDNAME	szRegName;
	char			szFullName[MAXUSERINFOSIZE*2];
	char			szLocation[MAXUSERINFOSIZE*2];
	char			szHostName[MAXUSERINFOSIZE*2];
	char			szEmailName[MAXUSERINFOSIZE*2];
	char			szHomePage[MAXUSERINFOSIZE*2];
	char			szComments[MAXUSERINFOSIZE*2];
}USERDETAILS, *PUSERDETAILS;
#endif

typedef struct _CALLEE_ID
{
	REGISTEREDNAME	strCalleeName;
	TCHAR			strIPAddress[MAX_IP_ADDRESS_STRING_SIZE + 1];
	TCHAR			strPort[LITTLE_STRING_BUFFER_SIZE + 1];
	TCHAR			strAppName[MAX_PATH + 1];
	TCHAR			strGUID[LITTLE_STRING_BUFFER_SIZE + 1];
}CALLEE_ID;
typedef CALLEE_ID *PCALLEE_ID;

//typedef REGISTEREDNAME *PREGISTEREDNAME,*LPREGISTEREDNAME;

typedef struct _SEARCHCRITERIA{
	WORD	cbStruct;		//size of the struct

}SEARCHCRITERIA;

typedef SEARCHCRITERIA *pSEARCHCRITERIA,*LPSEARCHCRITERIA;


#pragma warning (disable : 4200)
typedef struct _NAMEDIR{
	DWORD				cbStruct;		//size of the struct
	DWORD				dwNumEntries;	//number of entries in the directory
	REGISTEREDNAME		RegNames[];		//pointer to an array of registerednames
}NAMEDIR,*PNAMEDIR,*LPNAMEDIR;
#pragma warning (default : 4200)


typedef DWORD	HNSSESSION;

#define TOKENBEGINCHAR		'<'
#define TOKENENDCHAR		'>'
#define HEADSTARTSTR		"HEAD"
#define HEADENDSTR			"/HEAD"
#define URL_SPACE_CHARACTER	'.'

//exported functions

typedef HNSSESSION (WINAPI *NAMESERVICEINITIALIZE)(HWND,LPTSTR);
typedef BOOL (WINAPI *NAMESERVICEDEINITIALIZE)(HNSSESSION);
typedef BOOL (WINAPI *NAMESERVICEREGISTER)(HNSSESSION, HWND,LPTSTR);
typedef BOOL (WINAPI *NAMESERVICEUNREGISTER)(HNSSESSION,LPTSTR);
typedef BOOL (WINAPI *NAMESERVICERESOLVE)(HNSSESSION, LPTSTR, DWORD, CALLEE_ID *);
typedef BOOL (WINAPI *NAMESERVICEGETDIRECTORY)(HNSSESSION, HWND, LPSEARCHCRITERIA,
											   DWORD, LPNAMEDIR *,LPTSTR, PCALLEE_ID);
typedef BOOL (WINAPI *NAMESERVICELOGON)(HNSSESSION, LPTSTR, LPTSTR, LPTSTR,
										LPTSTR, LPTSTR, LPTSTR, LPTSTR, 
										LPTSTR, LPTSTR);
typedef BOOL (WINAPI *NAMESERVICELOGOFF)(HNSSESSION, LPTSTR);
typedef BOOL (WINAPI *CALLEEIDFROMIPABUF)(LPBYTE, DWORD, PCALLEE_ID);
typedef void (WINAPI *NAMESERVICEFREEMEM)(LPVOID);
typedef BOOL (WINAPI *NAMESERVICEUSERDETAILS)(HWND, DWORD, PUSERDETAILS);

//exported function prototypes

extern BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID);
extern HNSSESSION WINAPI NameServiceInitialize(HWND, LPTSTR);
extern BOOL WINAPI NameServiceDeinitialize(HNSSESSION);
extern BOOL WINAPI NameServiceRegister(HNSSESSION, HWND, LPTSTR);
extern BOOL WINAPI NameServiceUnregister(HNSSESSION, LPTSTR);
extern BOOL WINAPI NameServiceLogon(HNSSESSION, LPTSTR, LPTSTR, LPTSTR, LPTSTR,
									LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);
extern BOOL WINAPI NameServiceLogoff(HNSSESSION, LPTSTR);
extern BOOL WINAPI NameServiceResolve(HNSSESSION, LPTSTR, DWORD, CALLEE_ID *);
extern BOOL WINAPI NameServiceGetDirectory(HNSSESSION, HWND, LPSEARCHCRITERIA, 
									DWORD, LPNAMEDIR *, LPTSTR, PCALLEE_ID);
extern BOOL WINAPI NameServiceUserDetails(HWND, DWORD, PUSERDETAILS);
extern BOOL WINAPI CalleeIdFromIpaBuf(LPBYTE, DWORD, PCALLEE_ID);
extern void WINAPI NameServiceFreeMem(LPVOID);

#ifdef __cplusplus
}
#endif


#endif	//#ifndef _NAMERES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmctl1dispid.h ===
#ifndef __NmCtl1DispId_h__
#define __NmCtl1DispId_h__

#define DISPID_BASE                                 100
#define DISPID_PROPERTY_TYPE                        (1 + DISPID_BASE)
#define DISPID_PROPERTY_NAME                        (2 + DISPID_BASE)
#define DISPID_PROPERTY_URL                         (3 + DISPID_BASE)
#define DISPID_PROPERTY_DESCRIPTION                 (4 + DISPID_BASE)
#define DISPID_PROPERTY_RESOLUTION                  (5 + DISPID_BASE)
#define DISPID_PROPERTY_ISRESOLVED                  (6 + DISPID_BASE)
#define DISPID_PROPERTY_PRESENTOR                   (7 + DISPID_BASE)
#define DISPID_PROPERTY_CALLTO_PARTICIPANT_NAME     (8 + DISPID_BASE)
#define DISPID_PROPERTY_WBFILE_NAME                 (9 + DISPID_BASE)
#define DISPID_PROPERTY_SENDFILE_NAME               (10 + DISPID_BASE)
#define DISPID_PROPERTY_CHATMSG_DESTINATION         (11 + DISPID_BASE)
#define DISPID_PROPERTY_CHATMSG_TEXT                (12 + DISPID_BASE)
#define DISPID_PROPERTY_ACTIONTYPE                  (14 + DISPID_BASE)    
#define DISPID_PROPERTY_ASSIGNEDTO                  (15 + DISPID_BASE)    
#define DISPID_PROPERTY_FILENAME                    (16 + DISPID_BASE)    
#define DISPID_PROPERTY_CHILDREN                    (17 + DISPID_BASE)


#endif // __NmCtl1DispId_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmapptyp.h ===
#if ! defined(_NM_APPLET_TYPE_H_) && ! defined(__iapplet_h__)
#define _NM_APPLET_TYPE_H_

//
// GCC/MCS Base Types
//

typedef USHORT          AppletSessionID;
typedef USHORT          AppletChannelID;
typedef AppletChannelID AppletUserID;
typedef AppletUserID    AppletNodeID;
typedef USHORT          AppletTokenID;
typedef USHORT          AppletEntityID;

typedef ULONG_PTR        AppletConfID;

typedef UINT            AppletRequestTag;


//
// GCC Registry
//

typedef enum tagAppletRegistryCommand
{
    APPLET_REGISTER_CHANNEL  = 0,
    APPLET_ASSIGN_TOKEN      = 1,
    APPLET_SET_PARAMETER     = 2,
    APPLET_RETRIEVE_ENTRY    = 3,
    APPLET_DELETE_ENTRY      = 4,
    APPLET_ALLOCATE_HANDLE   = 5,
    APPLET_MONITOR           = 6, // nyi in SDK
}
    AppletRegistryCommand;


typedef enum tagAppletRegistryItemType
{
    APPLET_REGISTRY_CHANNEL_ID  = 1,
    APPLET_REGISTRY_TOKEN_ID    = 2,
    APPLET_REGISTRY_PARAMETER   = 3,
    APPLET_REGISTRY_NONE        = 4,
}
    AppletRegistryItemType;


typedef enum tagAppletModificationRights
{
    APPLET_OWNER_RIGHTS                     = 0,
    APPLET_SESSION_RIGHTS                   = 1,
    APPLET_PUBLIC_RIGHTS                    = 2,
    APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED = 3,
}
    AppletModificationRights;


//
// MCS Channel
//

typedef enum tagAppletChannelCommand
{
    APPLET_JOIN_CHANNEL         = 0,
    APPLET_LEAVE_CHANNEL        = 1,
    APPLET_CONVENE_CHANNEL      = 2,
    APPLET_DISBAND_CHANNEL      = 3,
    APPLET_ADMIT_CHANNEL        = 4,
    APPLET_EXPEL_CHANNEL        = 5,	// indication only
}
    AppletChannelCommand;


typedef enum tagAppletChannelType
{
    APPLET_STATIC_CHANNEL               = 0,
    APPLET_DYNAMIC_MULTICAST_CHANNEL    = 1,
    APPLET_DYNAMIC_PRIVATE_CHANNEL      = 2,
    APPLET_DYNAMIC_USER_ID_CHANNEL      = 3,
    APPLET_NO_CHANNEL_TYPE_SPECIFIED    = 4
}
    AppletChannelType;


//
// MCS Token
//

typedef enum tagAppletTokenCommand
{
    APPLET_GRAB_TOKEN          = 0,
    APPLET_INHIBIT_TOKEN       = 1,
    APPLET_GIVE_TOKEN          = 2,
    APPLET_PLEASE_TOKEN        = 3,
    APPLET_RELEASE_TOKEN       = 4,
    APPLET_TEST_TOKEN          = 5,
    APPLET_GIVE_TOKEN_RESPONSE = 6,
}
    AppletTokenCommand;


typedef enum tagAppletTokenStatus
{
    APPLET_TOKEN_NOT_IN_USE         = 0,
    APPLET_TOKEN_SELF_GRABBED       = 1,
    APPLET_TOKEN_OTHER_GRABBED      = 2,
    APPLET_TOKEN_SELF_INHIBITED     = 3,
    APPLET_TOKEN_OTHER_INHIBITED    = 4,
    APPLET_TOKEN_SELF_RECIPIENT     = 5,
    APPLET_TOKEN_SELF_GIVING        = 6,
    APPLET_TOKEN_OTHER_GIVING       = 7,
}
    AppletTokenStatus;


//
// GCC Capability
//

typedef enum tagAppletCapabilityType
{
    APPLET_UNKNOWN_CAP_TYPE             = 0, // for non-collapsing caps
    APPLET_LOGICAL_CAPABILITY           = 1,
    APPLET_UNSIGNED_MINIMUM_CAPABILITY  = 2,
    APPLET_UNSIGNED_MAXIMUM_CAPABILITY  = 3,
}
    AppletCapabilityType;


typedef struct tagAppletCapabilityClass
{
    AppletCapabilityType    eType;
    ULONG                   nMinOrMax;
}
    AppletCapabilityClass;


typedef enum tagAppletCapIDType
{
	APPLET_STANDARD_CAPABILITY  = 0,
	APPLET_NONSTD_CAPABILITY	= 1,
}
    AppletCapIDType;


//
// GCC/MCS Resource Allocation Command
//

typedef enum tagAppletResourceAllocCommand
{
    APPLET_JOIN_DYNAMIC_CHANNEL     = 0, // compete among all members
    APPLET_GRAB_TOKEN_REQUEST		= 1, // nyi in SDK
}
    AppletResourceAllocCommand;

//
// Send Data
//

typedef enum tagAppletPriority
{
    APPLET_TOP_PRIORITY     = 0,
    APPLET_HIGH_PRIORITY    = 1,
    APPLET_MEDIUM_PRIORITY  = 2,
    APPLET_LOW_PRIORITY     = 3,
}
    AppletPriority;


//
// Key Type
//

typedef enum tagAppletKeyType
{
	APPLET_OBJECT_KEY		= 1,
	APPLET_H221_NONSTD_KEY	= 2,
}
	AppletKeyType;


//
// Error Code
//

enum tagAppletErrorCode
{
    APPLET_E_NO_SERVICE       		= 0x82000001,
    APPLET_E_SERVICE_FAIL      		= 0x82000002,
    APPLET_E_ALREADY_REGISTERED  	= 0x82000003,
    APPLET_E_NOT_REGISTERED      	= 0x82000004,
    APPLET_E_INVALID_CONFERENCE  	= 0x82000005,
    APPLET_E_INVALID_COOKIE      	= 0x82000006,
    APPLET_E_ALREADY_JOIN        	= 0x82000007,
    APPLET_E_NOT_JOINED          	= 0x82000008,
    APPLET_E_INVALID_JOIN_REQUEST	= 0x82000009,
    APPLET_E_ENTRY_ALREADY_EXISTS   = 0x8200000a,
    APPLET_E_ENTRY_DOES_NOT_EXIST   = 0x8200000b,
    APPLET_E_NOT_OWNER              = 0x8200000c,
    APPLET_E_NOT_ADVISED            = 0x8200000d,
    APPLET_E_ALREADY_ADVISED        = 0x8200000e,
};


//
// Reason Code
//

typedef enum tagAppletReason
{
    APPLET_R_UNSPECIFIED            = 0,
    APPLET_R_CONFERENCE_GONE        = 1,
    APPLET_R_USER_REJECTED          = 2,
    APPLET_R_RESOURCE_PURGED        = 3,
}
    AppletReason;


#endif // _NM_APPLET_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmdispid.h ===
#ifndef _NMDISPID_H_
#define _NMDISPID_H_

#include <olectl.h>

#define UUID_ICall					5948A4B0-8EFD-11d2-933E-0000F875AE17
#define UUID_INetMeeting			5572984E-7A76-11d2-9334-0000F875AE17
#define UUID_NetMeetingLib			5CE55CD7-5179-11D2-931D-0000F875AE17
#define UUID_NetMeeting				3E9BAF2D-7A79-11d2-9334-0000F875AE17

///////////////////////////////////////////////////////////////////////////////////////////////
// INetMeeting DISPIDs
#define NETMEETING_DISPID_START				(100)
#define DISPID_Version						(NETMEETING_DISPID_START + 0)
#define DISPID_UnDock						(NETMEETING_DISPID_START + 1)
#define DISPID_IsInConference				(NETMEETING_DISPID_START + 2)
#define DISPID_CallTo						(NETMEETING_DISPID_START + 3)
#define DISPID_LeaveConference				(NETMEETING_DISPID_START + 4)
#define NETMEETING_DISPID_END				(NETMEETING_DISPID_START + 100)

#define NETMEETING_EVENTS_DISPID_START		(NETMEETING_DISPID_END + 1)
#define DISPID_ConferenceStarted			(NETMEETING_EVENTS_DISPID_START + 1)
#define DISPID_ConferenceEnded				(NETMEETING_EVENTS_DISPID_START + 2)


#endif /* _NMDISPID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmdsprv.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       nmdsprv.h
 *  Content:    utility function to map WAVE IDs to DirectSound GUID IDs
 *              (Win98 and NT 5 only)
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/19/98     dereks  Created.
 *  8/24/98     jselbie	Streamlined up for lightweight use in NetMeeting
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#ifndef __NMDSPRV_INCLUDED__
#define __NMDSPRV_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus




// NetMeeting utility function

extern HRESULT __stdcall DsprvGetWaveDeviceMapping
(
    LPCSTR                                              pszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
);



#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // __DSPRV_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmevtmsg.h ===
/* Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.

    MODULE: nmevtmsg.mc

    AUTHOR: xin liu

    This file contains the message definition for the Remote Desktop Sharing 
    service program.
 */
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_ERR_SERVICE
//
// MessageText:
//
//  Service Error in %1
//
#define MSG_ERR_SERVICE                  0xC0000001L

//
// MessageId: MSG_INF_START
//
// MessageText:
//
//  NetMeeting RDS Service Start
//
#define MSG_INF_START                    0x40000010L

//
// MessageId: MSG_INF_STOP
//
// MessageText:
//
//  NetMeeting RDS Service Stop
//
#define MSG_INF_STOP                     0x40000011L

//
// MessageId: MSG_INF_ACCESS
//
// MessageText:
//
//  NetMeeting RDS Service is called from %1
//
#define MSG_INF_ACCESS                   0x40000012L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmqos.h ===
/*
 -  QOS.H
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	Header file
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.23.96	Yoram Yaacovi		Created
 *
 */

#ifndef _NMQOS_H_
#define _NMQOS_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/*
 *	Constants
 */

// Properties stuff
// Property types
#define PT_NULL         ((ULONG)  1)    /* NULL property value */
#define PT_I2           ((ULONG)  2)    /* Signed 16-bit value */
#define PT_LONG         ((ULONG)  3)    /* Signed 32-bit value */
#define PT_BOOLEAN      ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#define PT_STRING8      ((ULONG) 30)    /* Null terminated 8-bit character string */
#define PT_UNICODE      ((ULONG) 31)    /* Null terminated Unicode string */
#define PT_CLSID        ((ULONG) 72)    /* OLE GUID */
#define PT_BINARY       ((ULONG) 258)   /* Uninterpreted (counted byte array) */

// Property IDs
#define QOS_PROPERTY_BASE		0x3000
#define PR_QOS_WINDOW_HANDLE	PROPERTY_TAG( PT_LONG, QOS_PROPERTY_BASE+1)

// hresult codes, facility QOS = 0x300
#define QOS_E_RES_NOT_ENOUGH_UNITS	0x83000001
#define QOS_E_RES_NOT_AVAILABLE		0x83000002
#define QOS_E_NO_SUCH_REQUEST		0x83000003
#define QOS_E_NO_SUCH_RESOURCE		0x83000004
#define QOS_E_NO_SUCH_CLIENT		0x83000005
#define QOS_E_REQ_ERRORS			0x83000006		
#define QOS_W_MAX_UNITS_EXCEEDED	0x03000007		
#define QOS_E_INTERNAL_ERROR		0x83000008		
#define QOS_E_NO_SUCH_PROPERTY		0x83000100

// Resource IDs
#define RESOURCE_NULL				0
#define RESOURCE_OUTGOING_BANDWIDTH	1		/* units: bps */
#define RESOURCE_INCOMING_BANDWIDTH	2		/* units: bps */
#define RESOURCE_OUTGOING_LATENCY	3		/* units: */
#define RESOURCE_INCOMING_LATENCY	4		/* units: */
#define RESOURCE_CPU_CYCLES			10		/* units: */

#define QOS_CLIENT_NAME_ZISE		20

// For use as dimension for variable size arrays
#define VARIABLE_DIM				1


/*
 *	Macros
 */
#define PROPERTY_TYPE_MASK          ((ULONG)0x0000FFFF) /* Mask for Property type */
#define PROPERTY_TYPE(ulPropTag)    (((ULONG)(ulPropTag))&PROPERTY_TYPE_MASK)
#define PROPERTY_ID(ulPropTag)      (((ULONG)(ulPropTag))>>16)
#define PROPERTY_TAG(ulPropType,ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))

#ifndef GUARANTEE
// this used to be defined in the original winsock2.h
typedef enum
{
    BestEffortService,
    ControlledLoadService,
    PredictiveService,
    GuaranteedDelayService,
    GuaranteedService
} GUARANTEE;
#endif
/*
 *	Data Structures
 */

// Properties part
typedef struct _binaryvalue
{
    ULONG       cb;
    LPBYTE      lpb;
} BINARYVALUE, *PBINARYVALUE;

typedef union _propvalue
{
    short int           i;          /* case PT_I2 */
    LONG                l;          /* case PT_LONG */
    ULONG_PTR           ul;         /* alias for PT_LONG */
    unsigned short int  b;          /* case PT_BOOLEAN */
    LPSTR               lpszA;      /* case PT_STRING8 */
    BINARYVALUE         bin;        /* case PT_BINARY */
    LPWSTR              lpszW;      /* case PT_UNICODE */
    LPGUID              lpguid;     /* case PT_CLSID */
} PROPVALUE;

typedef struct _property
{
    ULONG				ulPropTag;
    ULONG				hResult;
    union _propvalue	Value;
} PROPERTY, *PPROPERTY;


typedef struct _proptagarray
{
    ULONG   cValues;
    ULONG   aulPropTag[VARIABLE_DIM];
} PROPTAGARRAY, *PPROPTAGARRAY;


// QoS part
typedef struct _resource
{
	DWORD		resourceID;
	DWORD		ulResourceFlags;	/* 0 in NetMeeting 2.0 */
	int			nUnits;				/* Total units of the resource */
	DWORD		reserved;			/* Must be 0 */
} RESOURCE, *LPRESOURCE;

typedef struct _resourcerequest
{
	DWORD		resourceID;
	DWORD		ulRequestFlags;		/* 0 in NetMeeting 2.0 */
	GUARANTEE	levelOfGuarantee;	/* Guaranteed, Predictive */
	int			nUnitsMin;			/* # of units to reserve */
	int			nUnitsMax;			/* 0 in NetMeeting 2.0 */
	SOCKET		socket;				/* Socket where the */
									/*  reservation will be used */
	HRESULT		hResult;			/* result code for this resource */
	DWORD		reserved;			/* Must be 0 */
} RESOURCEREQUEST, *LPRESOURCEREQUEST;

typedef struct _resourcelist
{
	ULONG		cResources;
	RESOURCE	aResources[VARIABLE_DIM];
} RESOURCELIST, *LPRESOURCELIST;

typedef struct _resourcerequestlist
{
	ULONG			cRequests;
	RESOURCEREQUEST	aRequests[VARIABLE_DIM];
} RESOURCEREQUESTLIST, *LPRESOURCEREQUESTLIST;

typedef struct _client
{
	GUID	guidClientGUID;
	int		priority;				/* 1 highest, 9 lowest, 0 invalid */
	WCHAR	wszName[QOS_CLIENT_NAME_ZISE];	/* name of the client */
	DWORD	reserved;				/* Must be 0 */
} CLIENT, *LPCLIENT;

typedef struct _clientlist
{
	ULONG	cClients;
	CLIENT	aClients[VARIABLE_DIM];
} CLIENTLIST, *LPCLIENTLIST;

/*
 *	Functions
 */
typedef HRESULT (CALLBACK *LPFNQOSNOTIFY)
				(LPRESOURCEREQUESTLIST lpResourceRequestList,
				DWORD_PTR dwParam);

/*
 *	Interfaces
 */

#ifndef DECLARE_INTERFACE_PTR
#ifdef __cplusplus
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	interface iface; typedef iface FAR * piface
#else
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	typedef interface iface iface, FAR * piface
#endif
#endif /* DECLARE_INTERFACE_PTR */


#define IUNKNOWN_METHODS(IPURE)										\
    STDMETHOD (QueryInterface)                                      \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;				\
    STDMETHOD_(ULONG,AddRef)  (THIS) IPURE;							\
    STDMETHOD_(ULONG,Release) (THIS) IPURE;							\

#define IQOS_METHODS(IPURE)											\
	STDMETHOD(RequestResources)										\
		(THIS_	LPGUID lpStreamGUID,								\
				LPRESOURCEREQUESTLIST lpResourceRequestList,		\
				LPFNQOSNOTIFY lpfnQoSNotify,		\
				DWORD_PTR dwParam) IPURE;					\
	STDMETHOD (ReleaseResources)									\
		(THIS_	LPGUID lpStreamGUID,								\
				LPRESOURCEREQUESTLIST lpResourceRequestList) IPURE;	\
	STDMETHOD (SetResources) (THIS_ LPRESOURCELIST lpResourceList) IPURE;	\
	STDMETHOD (GetResources) (THIS_ LPRESOURCELIST *lppResourceList) IPURE;	\
	STDMETHOD (SetClients) (THIS_ LPCLIENTLIST lpClientList) IPURE;	\
	STDMETHOD (NotifyNow) (THIS) IPURE;								\
	STDMETHOD (FreeBuffer) (THIS_ LPVOID lpBuffer) IPURE;			\

#define IPROP_METHODS(IPURE)										\
	STDMETHOD (SetProps)											\
		(THIS_  ULONG cValues,										\
				PPROPERTY pPropArray) IPURE;						\
    STDMETHOD (GetProps)											\
        (THIS_  PPROPTAGARRAY pPropTagArray,						\
                ULONG ulFlags,										\
                ULONG *pcValues,								\
                PPROPERTY *ppPropArray) IPURE;					\

#undef       INTERFACE
#define      INTERFACE  IQoS
DECLARE_INTERFACE_(IQoS, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
	IQOS_METHODS(PURE)
	IPROP_METHODS(PURE)
};

DECLARE_INTERFACE_PTR(IQoS, LPIQOS);

EXTERN_C HRESULT WINAPI CreateQoS (	IUnknown *punkOuter,
								REFIID riid,
								void **ppv);

typedef HRESULT (WINAPI *PFNCREATEQOS)
				(IUnknown *punkOuter, REFIID riid, void **ppv);


// QoS Class GUID
// {085C06A0-3CAA-11d0-A00E-00A024A85A2C}
DEFINE_GUID(CLSID_QoS, 0x085c06a0, 0x3caa, 0x11d0, 0xa0, 0x0e, 0x0, 0xa0, 0x24, 0xa8, 0x5a, 0x2c);
// QoS Interface GUID
// {DFC1F900-2DCE-11d0-92DD-00A0C922E6B2}
DEFINE_GUID(IID_IQoS, 0xdfc1f900, 0x2dce, 0x11d0, 0x92, 0xdd, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);

#include <poppack.h> /* End byte packing */

#endif  // _NMQOS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmmkcert.h ===
#ifndef _NMMKCERT_
#define _NMMKCERT_

// Flags
#define	NMMKCERT_F_DELETEOLDCERT	0x00000001
#define NMMKCERT_F_LOCAL_MACHINE	0x00000002
#define NMMKCERT_F_CLEANUP_ONLY		0x00000004

// NetMeeting certificate store
#define SZNMSTORE	"_NMSTR"
#define WSZNMSTORE	L"_NMSTR"

// Magic constant in user properties
#define NMMKCERT_MAGIC    0x2389ABD0

// RDN name of issuing root cert...
#define SZ_NMROOTNAME TEXT("NetMeeting Root")

// When issuer obtained using these flags
#ifndef CERT_NAME_STR_REVERSE_FLAG
#define CERT_NAME_STR_REVERSE_FLAG      0x02000000
#endif // CERT_NAME_STR_REVERSE_FLAG

#define CERT_FORMAT_FLAGS (CERT_SIMPLE_NAME_STR|CERT_NAME_STR_NO_PLUS_FLAG|\
    CERT_NAME_STR_REVERSE_FLAG)

// Library Name
#define SZ_NMMKCERTLIB TEXT("NMMKCERT.DLL")

// Prototype typedef
typedef DWORD (WINAPI *PFN_NMMAKECERT)(LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPCSTR, DWORD);

// Loadlibrary constant
#define SZ_NMMAKECERTFUNC "NmMakeCert"

// Static prototype
extern DWORD WINAPI NmMakeCert (LPCSTR szFirstName,
								LPCSTR szLastName,
								LPCSTR szEmailName,
								LPCSTR szCity,
								LPCSTR szCountry,
								DWORD dwFlags );

#endif // _NMMKCERT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmstat.h ===
//  NMSTAT.H
//
//      Headers for STATS.DLL: a library to accumulate high performance
//      statistics and allow them to be tabulated in a different
//      process.
//
//  Created 24-Oct-96 [JonT]

#ifndef _NMSTATS_H
#define _NMSTATS_H

#ifdef __cplusplus
extern "C" {
#endif

//#if defined(_BUILD_STATS_) || defined(__midl)
#ifdef _BUILD_STATS_
#define STATSAPI
#else
#define STATSAPI __declspec(dllimport)
#endif

// Equates
#define MAX_COUNTER_NAME    64
#define STATS_COUNTER_ADDDEL_EVENT  "StatsNewCounter"
#define STATS_REPORT_ADDDEL_EVENT  "StatsNewReport"
#define COUNTER_FLAG_NO_STATISTICS  1   // Flag to CreateCounter. No statistics accumulated
                                        // for this counter even if StartStatistics called.
                                        // (StartStatistics fails)
#define COUNTER_FLAG_ACCUMULATE     2   // UpdateCounter adds to the counter value rather
                                        // than replacing it.
#define COUNTER_CLEAR               1   // Flag to GetCounter. Specifies the counter should
                                        // be cleared after being read
#define MAX_REPORT_NAME    64
#define UNDEFINED -1L

// Call parameters report defines
#define	REP_SEND_AUDIO_FORMAT	0
#define	REP_SEND_AUDIO_SAMPLING	1
#define	REP_SEND_AUDIO_BITRATE	2
#define	REP_SEND_AUDIO_PACKET	3
#define	REP_RECV_AUDIO_FORMAT	4
#define	REP_RECV_AUDIO_SAMPLING	5
#define	REP_RECV_AUDIO_BITRATE	6
#define	REP_RECV_AUDIO_PACKET	7
#define	REP_SEND_VIDEO_FORMAT	8
#define	REP_SEND_VIDEO_MAXFPS	9
#define	REP_SEND_VIDEO_BITRATE	10
#define	REP_RECV_VIDEO_FORMAT	11
#define	REP_RECV_VIDEO_MAXFPS	12
#define	REP_RECV_VIDEO_BITRATE	13

// System settings report defines
#define	REP_SYS_BANDWIDTH			0
#define	REP_SYS_AUDIO_DSOUND		1
#define	REP_SYS_AUDIO_RECORD		2
#define	REP_SYS_AUDIO_PLAYBACK		3
#define	REP_SYS_AUDIO_DUPLEX		4
#define	REP_SYS_VIDEO_DEVICE		5
#define	REP_DEVICE_IMAGE_SIZE		6

// Types
#ifdef __midl
typedef DWORD HCOUNTER;
#else
typedef HANDLE HCOUNTER;
#endif
typedef HCOUNTER HREPORT;

typedef struct _FINDCOUNTER
{
    DWORD dwSize;
    char szName[MAX_COUNTER_NAME];      // Human-readable counter name
    HCOUNTER hcounter;                  // Handle to use with all stats functions
    int nValue;                         // Current value of counter
    WORD wFlags;                        // COUNTER_FLAG_* values
    WORD wRefCount;                     // Number of times StartStatistics has been called.
    DWORD dwReserved;                   // Must be preserved: used for FindNextCounter
} FINDCOUNTER;

typedef struct _FINDREPORT
{
    DWORD dwSize;
    char szName[MAX_REPORT_NAME];       // Human-readable report name
    HREPORT hreport;                    // Handle to use with all functions
    WORD wFlags;                        // COUNTER_FLAG_* values
    WORD wRefCount;                     // Number of times StartStatistics has been called.
    DWORD dwReserved;                   // Must be preserved: used for FindNextCounter
} FINDREPORT;

typedef struct _COUNTERSTAT
{
    DWORD dwSize;                       // Size of structure. Allows for future growth...
    int nValue;
    int nLow;                           // Lowest value seen since clear
    int nHigh;                          // Highest value seen since clear
    int nAverage;                       // Average value seen since clear
    DWORD dwNumSamples;                 // Number of samples accumulated
    DWORD dwmsAtClear;                  // GetTickCount at last Clear/StartStatistics call
} COUNTERSTAT;

// Nothing further needed by MIDL
#ifndef __midl

// Counter Functions

// Called by updater of counter to make new counter
// Sets the event named in the equate STATS_NEW_COUNTER_EVENT
STATSAPI HCOUNTER WINAPI    CreateCounter(char* szName, WORD wFlags);

// Called by updater of counter when counter is going away
STATSAPI BOOL WINAPI DeleteCounter(HCOUNTER hc);

// Used by reader app to locate specific named counters or walk entire list.
// Pass NULL in for name to walk entire list. Pass NULL to FINDCOUNTER if
// just an HCOUNTER is desired. FindNext returns FALSE when there are no more.
STATSAPI HCOUNTER WINAPI    FindFirstCounter(char* szName, FINDCOUNTER* pfc);
STATSAPI BOOL WINAPI        FindNextCounter(FINDCOUNTER* pfc);

// Called by updater of counter. Makes the value current in the counter.
STATSAPI void WINAPI        UpdateCounter(HCOUNTER hcounter, int value);

// Called by updater of counter. Initializes the max value for the counter.
STATSAPI void WINAPI        InitCounterMax(HCOUNTER hcounter, int nMaxValue);

// Called by user of counter and just returns value with no statistics
STATSAPI int WINAPI         GetCounter(HCOUNTER hcounter, DWORD dwFlags);

// Called by user of counter and just returns max value with no statistics
STATSAPI int WINAPI         GetCounterMax(HCOUNTER hcounter, DWORD dwFlags);

// Begins collecting statistics on a counter
STATSAPI BOOL WINAPI        StartStatistics(HCOUNTER hcounter);

// Done collecting statistics on a counter
STATSAPI void WINAPI        StopStatistics(HCOUNTER hcounter);

// Get statistics on a counter
STATSAPI BOOL WINAPI        ReadStatistics(HCOUNTER hcounter, COUNTERSTAT* pcs);

// Clear statistics on a counter
STATSAPI void WINAPI        ClearStatistics(HCOUNTER hcounter);

// Report Functions

// Called by updater of report to make new report
// Sets the event named in the equate STATS_NEW_COUNTER_EVENT
STATSAPI HREPORT WINAPI CreateReport(char* szName, WORD wFlags);

// Called by updater of report when report is going away
STATSAPI BOOL WINAPI DeleteReport(HREPORT hreport);

// Used by reader app to locate specific named reports or walk entire list.
// Pass NULL in for name to walk entire list. Pass NULL to FINDREPORT if
// just an HREPORT is desired. FindNext returns FALSE when there are no more.
STATSAPI HREPORT WINAPI FindFirstReport(char* szName, FINDREPORT* pfr);
STATSAPI BOOL WINAPI FindNextReport(FINDREPORT* pfr);

// Called by updater of report. Makes the value current in the report.
STATSAPI void WINAPI UpdateReportEntry(HREPORT hreport, int nValue, DWORD dwIndex);

// Called by creater of report.
STATSAPI void WINAPI CreateReportEntry(HREPORT hreport, char* szName, DWORD dwIndex);

// Called by user of report
STATSAPI int WINAPI GetReportEntry(HREPORT hreport, DWORD dwIndex);

// Called by user of report
STATSAPI void WINAPI GetReportEntryName(HREPORT hreport, char *szName, DWORD dwIndex);

// Called by user of report
STATSAPI int WINAPI GetNumReportEntries(HREPORT hreport);

#endif // #ifndef __midl

#ifdef __cplusplus
}
#endif

#endif // #ifndef _STATS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmhelp.h ===
// File: nmhelp.h

#ifndef _NMHELP_H_
#define _NMHELP_H_

#include <htmlhelp.h>

HRESULT InitHtmlHelpMarshaler(HINSTANCE hInst);

VOID ShowNmHelp(LPCTSTR lpcszHtmlHelpFile);

VOID DoNmHelp(HWND hwnd, UINT uCommand, DWORD_PTR dwData);
VOID DoHelp(LPARAM lParam);
VOID DoHelp(LPARAM lParam, const DWORD * rgId);
VOID DoHelpWhatsThis(WPARAM wParam, const DWORD * rgId);

VOID ShutDownHelp(void);

#endif /* _NMHELP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmutil.h ===
#ifndef _NMUTIL_H_
#define _NMUTIL_H_

#define NMINTERNAL __stdcall

#endif  // ! _NMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmremote.h ===
// nmremote.h
// Contains data structures and declarations shared by NetMeeting and
// the remote control service

// String for identifying remote control service.
#define	REMOTE_CONTROL_NAME  TEXT("mnmsrvc")

#ifdef DATA_CHANNEL
// GUID for the remote control data channel
// {B983C6DA-459A-11d1-8735-0000F8757125}
const GUID g_guidRemoteControl = 
{ 0xb983c6da, 0x459a, 0x11d1, { 0x87, 0x35, 0x0, 0x0, 0xf8, 0x75, 0x71, 0x25 } };

const UINT RC_CAP_DESKTOP       = 0x00000001;

typedef UINT RC_CAP_DATA;
#endif // DATA_CHANNEL

#ifdef DATA_CHANNEL
// Declarations for the remote control data channel protocol
typedef enum {
	RC_SENDCTRLALTDEL = 0,
#ifdef RDS_AV
	RC_STARTAUDIO = 1,
	RC_STOPAUDIO = 2,
	RC_STARTVIDEO = 3,
	RC_STOPVIDEO = 4
#endif // RDS_AV
} RC_COMMAND;

typedef struct tagRCDATA {
	DWORD	magic;			// magic number
	DWORD	command;		// which command
	DWORD	size;			// size of data afterwards
} RCDATA;

// Constants for use in parsing incoming data
const int RC_DATAMINSIZE = sizeof(RCDATA);	// minimum size for a data packet = size of the header
const DWORD RC_DATAMAGIC = 0x03271943;		// magic number to identify packets

const int RC_DATAMAGICOFFSET = 0;
const int RC_DATACMDOFFSET = sizeof(DWORD);
const int RC_DATABUFFEROFFSET = RC_DATACMDOFFSET + sizeof(DWORD);
#endif // DATA_CHANNEL;

// Application name for Win95 service
#define WIN95_SERVICE_APP_NAME	TEXT("mnmsrvc.exe")

#define REMOTE_CONTROL_DISPLAY_NAME 	TEXT("NetMeeting Remote Desktop Sharing")

#define SZRDSGROUP "NetMeeting RDS Users"

// Remote Control Conference Descriptor
#define RDS_CONFERENCE_DESCRIPTOR  L"0xb983c6da459a11d1873500f8757125"

// Strings for events used for communication between NetMeeting and the service
#define SERVICE_STOP_EVENT	TEXT("RDS:Stop")
#define SERVICE_PAUSE_EVENT     TEXT("RDS:Pause")
#define SERVICE_CONTINUE_EVENT  TEXT("RDS:Continue")
#define SERVICE_ACTIVE_EVENT    TEXT("RDS:Active")
#define SERVICE_CALL_EVENT  TEXT("RDS:Call")

// BUGBUG 03-02-98
// These string constants are copied from ui\conf\ipcpriv.h
const char g_szConfInit[] =				_TEXT("CONF:Init");
const char g_szConfShuttingDown[] =		_TEXT("CONF:ShuttingDown");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\oblist.h ===
#ifndef _OBLIST_H_
#define _OBLIST_H_

// class COBNODE;
#define POSITION COBNODE*

struct COBNODE
{
	POSITION	pNext;
	void*		pItem;
};

class COBLIST
{
protected:
	POSITION m_pHead;
	POSITION m_pTail;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
        {return(pItemToCompare == pComparator);};
public:
	COBLIST() : m_pHead(NULL), m_pTail(NULL) { };
	
	POSITION	    GetHeadPosition() { return(m_pHead); };
	POSITION	    GetTailPosition() { return(m_pTail); };
	virtual void *  RemoveAt(POSITION rPos);
	virtual void *	ReplaceAt(POSITION rPos, void* pNewItem)
	{
		void *pvoid = rPos->pItem;
		rPos->pItem = pNewItem;
		return(pvoid);
	}

	POSITION	    AddTail(void* pItem);
	BOOL		    IsEmpty() { return(!m_pHead); };
	void *		    GetTail();
	void *		    GetNext(POSITION& rPos);
    void *          SafeGetFromPosition(POSITION rPos);
    POSITION        GetPosition(void* pItem);
    POSITION        Lookup(void* pComparator);
    void            EmptyList();
    virtual         ~COBLIST();
#ifdef DEBUG
	void *		    GetHead();
	void *		    RemoveHead();
	// void *		RemoveTail(); // inefficient
	void *		    GetFromPosition(POSITION rPos);
#else
	void *		    GetHead(){return GetFromPosition(GetHeadPosition());};
	void *		    RemoveHead() { return RemoveAt(m_pHead); };
	// void *		RemoveTail() { return RemoveAt(m_pTail); }; // inefficient
	void *		    GetFromPosition(POSITION rPos){return(rPos->pItem);};
#endif
};

#endif // ndef _OBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\nmstd.h ===
#ifndef __NmStd_h__
#define __NmStd_h__

// Useful macros
inline LONG RectWidth(const RECT* pr) { return pr->right - pr->left; }
inline LONG RectHeight(const RECT* pr) { return pr->bottom - pr->top; }
inline LONG RectWidth(const RECT& rpr) { return rpr.right - rpr.left; }
inline LONG RectHeight(const RECT& rpr) { return rpr.bottom - rpr.top; }

inline HRESULT GetLocalIPAddress( DWORD *pdwIPAddress )
{
	HRESULT hr = S_OK;

	if( pdwIPAddress )
	{
		// get local host name
		CHAR szLocalHostName[MAX_PATH];
		szLocalHostName[0] = '\0';
		gethostname(&szLocalHostName[0], MAX_PATH);

		// get the host entry by name
		PHOSTENT phe = gethostbyname(&szLocalHostName[0]);
		if (phe != NULL)
		{
			// get info from the host entry
			*pdwIPAddress = *(DWORD *) phe->h_addr;
		}	
		else
		{
			hr = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_INTERNET,WSAGetLastError());
		}
	}
	else
	{
		hr = E_INVALIDARG;
	}

	return hr;
}

#endif  // ! _NMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\olestock.h ===
/*
 * olestock.h - Stock OLE header file.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _OLESTOCK_H_
#define _OLESTOCK_H_

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Types
 ********/

/* IDs */

DECLARE_STANDARD_TYPES(GUID);
DECLARE_STANDARD_TYPES(CLSID);
DECLARE_STANDARD_TYPES(IID);

typedef FARPROC *Interface;
DECLARE_STANDARD_TYPES(Interface);

/* interfaces */

DECLARE_STANDARD_TYPES(IAdviseSink);
DECLARE_STANDARD_TYPES(IBindCtx);
DECLARE_STANDARD_TYPES(IClassFactory);
DECLARE_STANDARD_TYPES(IDataObject);
DECLARE_STANDARD_TYPES(IDropSource);
DECLARE_STANDARD_TYPES(IDropTarget);
DECLARE_STANDARD_TYPES(IEnumFORMATETC);
DECLARE_STANDARD_TYPES(IEnumSTATDATA);
DECLARE_STANDARD_TYPES(IMalloc);
DECLARE_STANDARD_TYPES(IMoniker);
DECLARE_STANDARD_TYPES(IPersist);
DECLARE_STANDARD_TYPES(IPersistFile);
DECLARE_STANDARD_TYPES(IPersistStorage);
DECLARE_STANDARD_TYPES(IPersistStream);
DECLARE_STANDARD_TYPES(IStorage);
DECLARE_STANDARD_TYPES(IStream);
DECLARE_STANDARD_TYPES(IUnknown);

/* structures */

DECLARE_STANDARD_TYPES(DVTARGETDEVICE);
DECLARE_STANDARD_TYPES(FORMATETC);
DECLARE_STANDARD_TYPES(STGMEDIUM);

/* advise flags */

typedef enum advise_flags
{
   ALL_ADVISE_FLAGS   = (ADVF_NODATA |
                         ADVF_PRIMEFIRST |
                         ADVF_ONLYONCE |
                         ADVF_DATAONSTOP |
                         ADVFCACHE_NOHANDLER |
                         ADVFCACHE_FORCEBUILTIN |
                         ADVFCACHE_ONSAVE)
}
ADVISE_FLAGS;

/* data transfer direction flags */

typedef enum datadir_flags
{
   ALL_DATADIR_FLAGS   = (DATADIR_GET |
                          DATADIR_SET)
}
DATADIR_FLAGS;

/* drop effects */

typedef enum drop_effects
{
   ALL_DROPEFFECT_FLAGS   = (DROPEFFECT_NONE |
                             DROPEFFECT_COPY |
                             DROPEFFECT_MOVE |
                             DROPEFFECT_LINK |
                             DROPEFFECT_SCROLL)
}
DROP_EFFECTS;

/* mouse message key states */

typedef enum mk_flags
{
   ALL_KEYSTATE_FLAGS      = (MK_LBUTTON |
                              MK_RBUTTON |
                              MK_SHIFT |
                              MK_CONTROL |
                              MK_MBUTTON)
}
MK_FLAGS;

/* medium types */

typedef enum tymeds
{
   ALL_TYMED_FLAGS         = (TYMED_HGLOBAL |
                              TYMED_FILE |
                              TYMED_ISTREAM |
                              TYMED_ISTORAGE |
                              TYMED_GDI |
                              TYMED_MFPICT |
                              TYMED_ENHMF)
}
TYMEDS;


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#endif /* _OLESTOCK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\olevalid.h ===
/*
 * olevalid.h - OLE validation functions description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _OLEVALID_H_
#define _OLEVALID_H_

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Macros
 *********/

/* method validation macro */

#define IS_VALID_METHOD(piface, mthd) \
   IS_VALID_CODE_PTR((piface)->lpVtbl->mthd, mthd)


/* Prototypes
 *************/

/* olevalid.c */

#ifdef DEBUG

extern BOOL IsValidPCGUID(PCGUID);
extern BOOL IsValidPCCLSID(PCCLSID);
extern BOOL IsValidPCIID(PCIID);
extern BOOL IsValidPCDVTARGETDEVICE(PCDVTARGETDEVICE);
extern BOOL IsValidPCFORMATETC(PCFORMATETC);
extern BOOL IsValidStgMediumType(DWORD);
extern BOOL IsValidPCSTGMEDIUM(PCSTGMEDIUM);
extern BOOL IsValidREFIID(REFIID);
extern BOOL IsValidREFCLSID(REFCLSID);
extern BOOL IsValidPCINTERFACE(PCVOID);
extern BOOL IsValidPCIAdviseSink(PCIAdviseSink);
extern BOOL IsValidPCIClassFactory(PCIClassFactory);
extern BOOL IsValidPCIDataObject(PCIDataObject);
extern BOOL IsValidPCIDropSource(PCIDropSource);
extern BOOL IsValidPCIDropTarget(PCIDropTarget);
extern BOOL IsValidPCIEnumFORMATETC(PCIEnumFORMATETC);
extern BOOL IsValidPCIEnumSTATDATA(PCIEnumSTATDATA);
extern BOOL IsValidPCIMalloc(PCIMalloc);
extern BOOL IsValidPCIMoniker(PCIMoniker);
extern BOOL IsValidPCIPersist(PCIPersist);
extern BOOL IsValidPCIPersistFile(PCIPersistFile);
extern BOOL IsValidPCIPersistStorage(PCIPersistStorage);
extern BOOL IsValidPCIPersistStream(PCIPersistStream);
extern BOOL IsValidPCIStorage(PCIStorage);
extern BOOL IsValidPCIStream(PCIStream);
extern BOOL IsValidPCIUnknown(PCIUnknown);

#ifdef __INTSHCUT_H__

extern BOOL IsValidPCIUniformResourceLocator(PCIUniformResourceLocator);

#endif   /* __INTSHCUT_H__ */

#endif   /* DEBUG */


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#endif /* _OLEVALID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\oprahcom.h ===
#ifndef _OPRAHCOM_H_
#define _OPRAHCOM_H_

#include <nmutil.h>
#include <tchar.h>
#include <stock.h>
#include <confdbg.h>
#include <memtrack.h>

// Some string functions that used to be defined here have been moved to
// STRUTIL.  We include that header file so that source files that include
// this file continue to work.
#include <strutil.h>

BOOL    NMINTERNAL CanShellExecHttp();
BOOL    NMINTERNAL CanShellExecMailto();
BOOL    NMINTERNAL GetInstallDirectory(LPTSTR psz);

INLINE DWORD 
CompareGuid(GUID * p1, GUID * p2)
{
	ASSERT(NULL != p1);
	ASSERT(NULL != p2);
	return memcmp(p1, p2, sizeof(GUID));
}

INLINE VOID 
ClosePh(HANDLE * ph)
{
	if ((NULL == ph) || (NULL == *ph))
		return;

	CloseHandle(*ph);
	*ph = NULL;
}

BOOL    NMINTERNAL FFileExists(LPCTSTR szFile);
BOOL    NMINTERNAL FDirExists(LPCSTR szDir);
BOOL    NMINTERNAL FEnsureDirExists(LPCTSTR szDir);
BOOL    NMINTERNAL FEnsureDirName(LPTSTR pszPath);
DWORD   NMINTERNAL CreateNewFile(LPTSTR pszFile);
BOOL    NMINTERNAL FCreateNewFile(LPCTSTR pcszPath, LPCTSTR pcszName,
								  LPCTSTR pcszExt, LPTSTR pszResult, int cchMax);

LPCTSTR NMINTERNAL ExtractFileName(LPCTSTR pcszPathName);
#if defined(UNICODE)
LPCSTR NMINTERNAL ExtractFileNameA(LPCSTR pcszPathName);
#else // defined(UNICODE)
#define ExtractFileNameA ExtractFileName
#endif // defined(UNICODE)
BOOL    NMINTERNAL SanitizeFileName(LPTSTR psz);

VOID    NMINTERNAL CenterWindow(HWND hwndChild, HWND hwndParent);


/****************************************************************************

Processor ID and Speed routines

*****************************************************************************/
#ifdef _M_IX86
HRESULT NMINTERNAL GetNormalizedCPUSpeed (int *pdwNormalizedSpeed, int *iFamily);
int     NMINTERNAL GetProcessorSpeed(int *pdwFamily);
#endif

BOOL NMINTERNAL IsFloatingPointEmulated(void);

#endif // _OPRAHCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\os2.h ===
// Dummy file to prevent dependancy errors.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\ping.h ===
#ifndef _PING_H_
#define _PING_H_

#include <ipexport.h>
#include <icmpapi.h>


// Function prototypes equivalent to those in icmpapi.h
// these are required in order to use GetProcAddress()
typedef HANDLE (WINAPI * PFNIcmpCreateFile) (VOID);
typedef BOOL   (WINAPI * PFNIcmpCloseHandle) (HANDLE  IcmpHandle);
typedef DWORD  (WINAPI * PFNIcmpSendEcho) (
    HANDLE                   IcmpHandle,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout);

enum { AUTODIAL_UNKNOWN = -1, PLATFORM_UNKNOWN = -2 };

class CPing
{
protected:
	HINSTANCE			m_hICMPDLL;
	PFNIcmpCreateFile	m_pfnCreateFile;
	PFNIcmpCloseHandle	m_pfnCloseHandle;
	PFNIcmpSendEcho		m_pfnSendEcho;

	BOOL				m_fWinNTAutodialEnabled;
	DWORD				m_dwPlatformId;

public:
			CPing() :
				m_hICMPDLL			(NULL),
				m_pfnCreateFile		(NULL),
				m_pfnCloseHandle	(NULL),
				m_pfnSendEcho		(NULL),
				m_fWinNTAutodialEnabled (AUTODIAL_UNKNOWN),
				m_dwPlatformId			(PLATFORM_UNKNOWN)
			{ };
			~CPing() { if (m_hICMPDLL) ::FreeLibrary(m_hICMPDLL); };
	HRESULT	Ping(DWORD dwAddr, DWORD dwTimeout, DWORD dwRetries);

	BOOL IsWin95AutodialEnabled ( VOID );
	BOOL IsWinNTAutodialEnabled ( VOID );
	BOOL IsAutodialEnabled ( VOID ); // call either one above
};




#endif  // _PING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\refcount.hpp ===
/*
 * refcount.hpp - RefCount class description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _REFCOUNT_HPP_
#define _REFCOUNT_HPP_

/* Types
 ********/

// RefCount destructor callback function

typedef void (*OBJECTDESTROYEDPROC)(void);


/* Classes
 **********/

class RefCount
{
private:
   ULONG m_ulcRef;
   OBJECTDESTROYEDPROC m_ObjectDestroyed;

public:
   RefCount(OBJECTDESTROYEDPROC ObjectDestroyed);
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount(void);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCRefCount(const RefCount *pcrefcnt);

#endif

};
DECLARE_STANDARD_TYPES(RefCount);

#endif // _REFCOUNT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\pmwinp.h ===
// Dummy file to prevent dependancy errors.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\referenc.h ===
#ifndef	_REFERENC_H_
#define	_REFERENC_H_

class REFCOUNT
{
public:
	REFCOUNT();
	virtual ~REFCOUNT();
	DWORD AddRef();
	DWORD Release();
	DWORD Delete();
	void OnStack() {bOnStack = TRUE;};
private:
	DWORD		 NumRefs;

	// Give 2 bits since BOOL is signed
	BOOL		 bMarkedForDelete : 2;
	BOOL		 bOnStack : 2;
};

class REFERENCE
{
public:
	REFERENCE(REFCOUNT * _pRefCount) : pRefCount(_pRefCount) {pRefCount->AddRef();};
	~REFERENCE() {pRefCount->Release();};

private:
	REFCOUNT * pRefCount;
};

#endif // ! _REFERENC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\rostinfo.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/

//
//	File:		RostInfo.h
//	Created:	ChrisPi		6/17/96
//	Modified:
//
//	The CRosterInfo class is defined, which is used for adding user
//  information to the T.120 roster
//

#ifndef _ROSTINFO_H_
#define _ROSTINFO_H_

#include <oblist.h>
typedef POSITION HROSTINFO;
typedef HROSTINFO* PHROSTINFO;

extern GUID g_csguidRostInfo;

static const WCHAR g_cwchRostInfoSeparator =	L'\0';
static const WCHAR g_cwchRostInfoTagSeparator =	L':';
static const WCHAR g_cwszIPTag[] =				L"TCP";
static const WCHAR g_cwszULSTag[] =				L"ULS";
static const WCHAR g_cwszULS_EmailTag[] =		L"EMAIL";
static const WCHAR g_cwszULS_LocationTag[] =	L"LOCATION";
static const WCHAR g_cwszULS_PhoneNumTag[] =	L"PHONENUM";
static const WCHAR g_cwszULS_CommentsTag[] =	L"COMMENTS";
static const WCHAR g_cwszVerTag[] =				L"VER";

class CRosterInfo
{
protected:
	// Attributes:
	COBLIST		m_ItemList;
	PVOID		m_pvSaveData;

	// Methods:
	UINT		GetSize();

public:
	// Methods:
				CRosterInfo() : m_pvSaveData(NULL) { };
				~CRosterInfo();
	HRESULT		AddItem(PCWSTR pcwszTag,
						PCWSTR pcwszData);
	HRESULT		ExtractItem(PHROSTINFO phRostInfo,
							PCWSTR pcwszTag,
							LPTSTR pszBuffer,
							UINT cbLength);
	HRESULT		Load(PVOID pvData);
	HRESULT		Save(PVOID* ppvData, PUINT pcbLength);

	BOOL        IsEmpty() {return m_ItemList.IsEmpty(); }

#ifdef DEBUG
	VOID		Dump();
#endif // DEBUG
};

#endif // _ROSTINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\resstr.h ===
/*
 * resstr.h - Common return code to string translation routines description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _RESSTR_H_
#define _RESSTR_H_

#include <nmutil.h>

/* Prototypes
 *************/

/* resstr.c */

#ifdef DEBUG

extern PCSTR NMINTERNAL GetINTString(int);
extern PCSTR NMINTERNAL GetINT_PTRString(INT_PTR);
extern PCSTR NMINTERNAL GetULONGString(ULONG);
extern PCSTR NMINTERNAL GetBOOLString(BOOL);
extern PCSTR NMINTERNAL GetPVOIDString(PVOID);
extern PCSTR NMINTERNAL GetClipboardFormatNameString(UINT);
extern PCSTR NMINTERNAL GetCOMPARISONRESULTString(COMPARISONRESULT);
extern PCSTR NMINTERNAL GetHRESULTString(HRESULT);

#endif   /* DEBUG */

#endif /* _RESSTR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\regentry.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

regentry.h

Oct. 95		LenS

Wrapper for registry access

Construct a RegEntry object by specifying the subkey (under
HKEY_CURRENT_USER by default, but can be overridden.)

All member functions (except the destructor) set an internal
error state which can be retrieved with GetError().
Zero indicates no error.

RegEntry works only with strings and DWORDS which are both set
using the overloaded function SetValue()

	SetValue("valuename", "string");
	SetValue("valuename", 42);
	
Values are retrieved with GetString() and GetNumber().  
GetNumber() allows you to specificy a default if the valuename doesn't
exist.
GetString() returns a pointer to a string internal to RegEntry that is 
invalidated when another fuction is called on the same RegEntry object
(e.g. its destructor) so, if you want to use the string beyond this
time, then you must copy it out of the RegEntry object first.

DeleteValue() removes the valuename and value pair.

Registry flushes are automatic when RegEntry is destroys or moves to
another key.

****************************************************************************/

#ifndef	REGENTRY_INC
#define	REGENTRY_INC

class RegEntry
{
	public:
		RegEntry(	LPCTSTR pszSubKey,
					HKEY hkey = HKEY_CURRENT_USER,
					BOOL fCreate = TRUE,
					REGSAM samDesired = 0
					);
		~RegEntry();
		
		long	GetError()	{ return m_error;}
		VOID	ClearError() {m_error = ERROR_SUCCESS;}
		long	SetValue(LPCTSTR pszValueName, LPCTSTR string);
		long	SetValue(LPCTSTR pszValueName, unsigned long dwNumber);
		long	SetValue(LPCTSTR pszValue, void* pData, DWORD cbLength);
		LPTSTR	GetString(LPCTSTR pszValueName);
		DWORD	GetBinary(LPCTSTR pszValueName, void** ppvData);
		long	GetNumber(LPCTSTR pszValueName, long dwDefault = 0);
		ULONG	GetNumberIniStyle(LPCTSTR pszValueName, ULONG dwDefault = 0);
		long	DeleteValue(LPCTSTR pszValueName);
		long	FlushKey();
        VOID    MoveToSubKey(LPCTSTR pszSubKeyName);
        HKEY    GetKey()    { return m_hkey; }

	private:
		VOID	ChangeKey(HKEY hNewKey);
		VOID	UpdateWrittenStatus();
		VOID	ResizeValueBuffer(DWORD length);

		HKEY	m_hkey;
		long	m_error;
        BOOL    m_fhkeyValid;
		LPBYTE  m_pbValueBuffer;
        DWORD   m_cbValueBuffer;
		BOOL	m_fValuesWritten;
		TCHAR	m_szNULL;
};

inline long 
RegEntry::FlushKey()
{
    if (m_fhkeyValid) {
		m_error = ::RegFlushKey(m_hkey);
    }
	return m_error;
}


class RegEnumValues
{
	public:
		RegEnumValues(RegEntry *pRegEntry);
		~RegEnumValues();
		long	Next();
		LPTSTR 	GetName()       {return m_pchName;}
        DWORD   GetType()       {return m_dwType;}
        LPBYTE  GetData()       {return m_pbValue;}
        DWORD   GetDataLength() {return m_dwDataLength;}
		DWORD	GetCount()      {return m_cEntries;}

	private:
        RegEntry * m_pRegEntry;
		DWORD   m_iEnum;
        DWORD   m_cEntries;
		LPTSTR  m_pchName;
		LPBYTE  m_pbValue;
        DWORD   m_dwType;
        DWORD   m_dwDataLength;
        DWORD   m_cMaxValueName;
        DWORD   m_cMaxData;
        LONG    m_error;
};

class RegEnumSubKeys
{
	public:
		RegEnumSubKeys(RegEntry *pRegEntry);
		~RegEnumSubKeys();
		long    Next();
		LPTSTR 	GetName()       {return m_pchName;}
		DWORD	GetCount()      {return m_cEntries;}

	protected:
        RegEntry * m_pRegEntry;
		DWORD   m_iEnum;
        DWORD   m_cEntries;
		LPTSTR  m_pchName;
        DWORD   m_cMaxKeyName;
        LONG    m_error;
};

#endif // REGENTRY_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\rrcm_dll.h ===
/*
 * Filename: RRCM_DLL.H
 *
 * Description: Declares imported/exported RRCM functions.
 *
 * $Workfile:   rrcm_dll.h  $
 * $Author:   CMACIOCC  $
 * $Date:   14 Feb 1997 11:59:52  $
 * $Revision:   1.20  $
 * $Archive:   R:\rtp\src\include\rrcm_dll.h_v  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *
 */

#ifndef _RRCMDLL_H_
#define _RRCMDLL_H_

// force 8 byte structure packing
#include <pshpack8.h>

#if !defined (RRCMDLL)
//#define RRCMAPI __declspec (dllimport)
//#else
//#define RRCMAPI __declspec (dllexport)
#endif

#ifdef __cplusplus
extern "C" {
#endif


#define MAX_SDES_LEN			256
#define	MAX_ENCRYPT_KEY_SIZE	8
#define	NUM_COLLISION_ENTRIES	10
#define	MAX_ADDR_LEN			80


// RTCP SDES type
typedef enum {
	RTCP_SDES_END,
	RTCP_SDES_CNAME,
	RTCP_SDES_NAME,
	RTCP_SDES_EMAIL,
	RTCP_SDES_PHONE,
	RTCP_SDES_LOC,
	RTCP_SDES_TOOL,
	RTCP_SDES_TXT,
	RTCP_SDES_PRIV
	} RTCP_SDES_TYPE_T;


// RRCM events
typedef enum
	{
	RRCM_NO_EVENT,
	RRCM_NEW_SOURCE_EVENT,				// New SSRC detected
	RRCM_RECV_RTCP_RECV_REPORT_EVENT,	// RTCP RR received
	RRCM_RECV_RTCP_SNDR_REPORT_EVENT,	// RTCP SR received
	RRCM_LOCAL_COLLISION_EVENT,			// Collision detected
	RRCM_REMOTE_COLLISION_EVENT,		// Remote collision detected
	RRCM_TIMEOUT_EVENT,					// SSRC timed-out
	RRCM_BYE_EVENT,						// RTCP Bye received
	RRCM_RTCP_WS_RCV_ERROR,				// Winsock error on RTCP rcv
	RRCM_RTCP_WS_XMT_ERROR				// Winsock error on RTCP xmt
	} RRCM_EVENT_T;


// RRCM events callback
typedef void (*PRRCM_EVENT_CALLBACK) (RRCM_EVENT_T, DWORD_PTR, DWORD_PTR, DWORD_PTR);


// RRCM SSRC entry update
typedef enum
	{
	RRCM_UPDATE_SDES,
	RRCM_UPDATE_CALLBACK,
	RRCM_UPDATE_STREAM_FREQUENCY,
	RRCM_UPDATE_RTCP_STREAM_MIN_BW
	} RRCM_UPDATE_SSRC_ENTRY;


// RTP/RTCP session bits mask
#define	RTCP_DEST_LEARNED		0x00000001	// RTCP destination address known ?
#define	H323_CONFERENCE			0x00000002	// H.323 conference control
#define ENCRYPT_SR_RR			0x00000004	// Encrypt SR/RR
#define	RTCP_ON					0x00000008
#define NEW_RTCP_SESSION		0x00000010
#define RTCP_OFF				0x00000020
#define SHUTDOWN_IN_PROGRESS	0x80000000	// Shutdown in progress

// RTCP control
#define RRCM_CTRL_RTCP			0x00000000
#define RTCP_XMT_OFF			0x7FFFFFFF
#define RTCP_ONE_SEND_ONLY		0x80000000

//	RTCP SDES data
typedef struct _SDES_DATA
	{
	DWORD				dwSdesType;			// SDES type: CNAME/NAME/...
	char				sdesBfr[MAX_SDES_LEN];
	DWORD				dwSdesLength;		// SDES length
	DWORD				dwSdesFrequency;	// SDES frequency
	DWORD				dwSdesEncrypted;	// SDES encrypted Y/N ?
	} SDES_DATA, *PSDES_DATA;
	

// Encryption data
typedef struct _encryption_info
	{
	DWORD				dwEncryptType;			// DES/Triple DES/...
	DWORD				dwKeyLen;					// Encryption key length
	char				keyVal[MAX_ENCRYPT_KEY_SIZE];
	} ENCRYPT_INFO, *PENCRYPT_INFO;


//	Received sequence numbers/cycles.  Union allows access as combined
//	cycle/sequence number or as either field alone for optimizations
typedef struct _RTP_SEQUENCE
	{
	WORD	wSequenceNum;
	WORD	wCycle;
	} RTP_SEQUENCE, *PRTP_SEQUENCE;


typedef struct _RTP_SEQ_NUM
	{
	union {
		DWORD		dwXtndedHighSeqNumRcvd;	// Combined cycle/sequence number
		RTP_SEQUENCE RTPSequence;			// Cycle/sequence number separate
		} seq_union;
	} RTP_SEQ_NUM, *PRTP_SEQ_NUM;


//	Link list elements
typedef struct _LINK_LIST
	{
	struct _LINK_LIST 	*next;				// Next in list / Head of list
	struct _LINK_LIST	*prev;				// Previous in list	/ Tail of list
	} LINK_LIST, *PLINK_LIST, HEAD_TAIL, *PHEAD_TAIL;


//	Application provided buffer for RTCP to copy the raw RTCP report into
typedef struct _APP_RTCP_BFR
	{
	LINK_LIST			bfrList;			// Next/prev buffer in list		
	char				*bfr;
	DWORD				dwBfrLen;
	DWORD				dwBfrStatus;		// RTCP Operation on this Bfr
#define	RTCP_SR_ONLY	0x00000001			// Only copy RTCP packet
	DWORD				dwBytesRcvd;
	HANDLE				hBfrEvent;
	} APP_RTCP_BFR, *PAPP_RTCP_BFR;


// RTCP sender's feedback data structure
typedef struct _RTCP_FEEDBACK
	{
	DWORD		SSRC;
	DWORD		fractionLost:8;				// Fraction lost 				
	int  		cumNumPcktLost:24;			// Cumulative num of pckts lost
	RTP_SEQ_NUM	XtendedSeqNum;				// Xtnded highest seq. num rcvd	
	DWORD		dwInterJitter;				// Interarrival jitter 			
	DWORD		dwLastSR;					// Last sender report 			
	DWORD		dwDelaySinceLastSR;			// Delay since last SR 			
	DWORD		dwLastRcvRpt;				// Time of last Receive Report
	} RTCP_FEEDBACK, *PRTCP_FEEDBACK;


//	RTCPReportRequestEx bitmasks used to specify filter values
typedef enum
	{
	FLTR_SSRC	= 1,		// Filters report on SSRC value
	FLTR_CNAME,				// Filters report on CName
	FLTR_TIME_WITHIN		// Filters report receive within a time period
	} RRCM_RPT_FILTER_OPTION;


//	RTCP report data structure
typedef struct _RTCP_REPORT
	{
	// SSRC for this entry's information. Local SSRC if it's one of
	// are local stream, or a remote SSRC otherwise.
	DWORD				ssrc;				

	DWORD				status;
#define	LOCAL_SSRC_RPT						0x1
#define REMOTE_SSRC_RPT						0x2
#define	FEEDBACK_FOR_LOCAL_SSRC_PRESENT		0x4
	// LOCAL_SSRC_RPT identifies to the application that this entry is
	// one of our local stream.
	// Only 'dwSrcNumPcktRealTime & dwSrcNumByteRealTime' which
	// reflect the number of Pckt/byte transmitted are meaningful.

	// FEEDBACK_FOR_LOCAL_SSRC_PRESENT is set if the entry is for a
	// remote stream and if this remote stream has ever send us any
	// feedback about ourselve. Feedback send by the remote stream to
	// other SSRC are filtered out. Only feedback about ourselve is kept.

	// Number of Pckt/Byte send if this entry is for a local stream, or
	// number of Pckt/Byte received if this entry is for a remote stream
	// This counters are updated in real-time.
	DWORD				dwSrcNumPcktRealTime;
	DWORD				dwSrcNumByteRealTime;

	// This is the information we would be sending in a receiver report
	// for the stream identified by 'ssrc' if this 'ssrc' has been active
	// during the last report interval. This information is provided when the
	// API is queried, and will most likely be different than the one send
	// out by the receiver report. (RR will be send at some different time)
	DWORD				SrcFraction:8;
	int					SrcNumLost:24;
	DWORD				dwSrcXtndNum;
	DWORD				SrcJitter;
	DWORD				dwSrcLsr;
	DWORD				dwSrcDlsr;

	// This information has been received from 'ssrc' has part of an
	// RTCP sender report if 'ssrc' has been active, otherwise all 0s
	DWORD				dwSrcNumPckt;
	DWORD				dwSrcNumByte;
	DWORD				dwSrcNtpMsw;
	DWORD				dwSrcNtpLsw;
	DWORD				dwSrcRtpTs;

	// This is the feedback information about us from the SSRC identified
	// in the 'feedback' data structure. Currently we only store feedback
	// information about ourselve and we filter out feedback information
	// about additional streams. We'll have feedback information only if
	// our stream has been active. If our stream goes from active to inactive
	// the feedback information will be set, but not updated.
	RTCP_FEEDBACK		feedback;			

	// Generic information for the SSRC entry
	// Payload type for this SSRC. If a sender, it is assume that the
	// application knows what it is sending, and the type will be set
	// to 0. If a receiver, this is the last value seen on an RTP data packet
	DWORD				PayLoadType;		
	DWORD				dwStreamClock;			// Sampling frequency
    DWORD				dwLastReportRcvdTime;	// Time of last report rcvd
	char				fromAddr[MAX_ADDR_LEN];	
	DWORD				dwFromLen;			
	CHAR				cname[MAX_SDES_LEN];
	DWORD				dwCnameLen;
	CHAR				name[MAX_SDES_LEN];
	DWORD				dwNameLen;
	} RTCP_REPORT, *PRTCP_REPORT;



//----------------------------------------------------------------------------
//	ISDM Information
//----------------------------------------------------------------------------

#ifdef ENABLE_ISDM2

// RTCP Xmt information
typedef struct _XMIT_INFO_ISDM
	{
	DWORD		dwNumPcktSent;				// Number of packet sent 		
	DWORD		dwNumBytesSent;				// Number of bytes sent     	
	DWORD		dwNTPmsw;					// NTP most significant word	
	DWORD		dwNTPlsw;					// NTP least significant word	
	DWORD		dwRTPts;					// RTP timestamp				
	DWORD		dwCurXmtSeqNum;				// Current Xmt sequence number	
	DWORD		dwPrvXmtSeqNum;				// Previous Xmt sequence number
	DWORD		sessionBW;					// Session's bandwidth			
	DWORD		dwLastSR;					// Last sender report 			
	DWORD		dwLastSRLocalTime;			// Last sender report local time
	DWORD		dwLastSendRTPSystemTime;	// Last RTP packet send time
	DWORD		dwLastSendRTPTimeStamp;		// RTP timestamp of the last packet
	} XMIT_INFO_ISDM, *PXMIT_INFO_ISDM;



// RTCP receive information
typedef struct _RECV_INFO_ISDM
	{
	DWORD		dwNumPcktRcvd;				// Number of packet received	
	DWORD		dwPrvNumPcktRcvd;			// Previous number of pckt rcvd	
	DWORD		dwExpectedPrior;			// Number previously expected	
	DWORD		dwNumBytesRcvd;				// Number of bytes rcvd     	
	DWORD		dwBaseRcvSeqNum;			// Initial sequence number rcvd
	DWORD		dwBadSeqNum;				// Potential new valid seq num
	DWORD		dwProbation;				// # consec pkts for validation
	RTP_SEQ_NUM	XtendedSeqNum;				// Xtnded highest seq. num rcvd	
	DWORD		dwPropagationTime;			// Last packet's transmit time
	DWORD		interJitter;				// Interarrival jitter 			
	} RECV_INFO_ISDM, *PRECV_INFO_ISDM;


//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//----------------------------------------------------------------------------
#define szRRCMISDM			TEXT("RRCM_2")


// Structure used by new ISDM features

typedef struct _ISDM2_ENTRY
	{
	DWORD		SSRC;				// Source SSRC 			
	DWORD		dwSSRCStatus;		// Entry status
    #define XMITR   0x00000001
    #define RECVR   0x00000002

	DWORD		PayLoadType;		// Payload type for this SSRC
									// taken from the RTP header.

	// SSRC Transmit information
	// If on our transmit list, this is our SSRC information, and if on our
	// receive list, this is a SR feedback information.
    XMIT_INFO_ISDM	xmitinfo;

	// SSRC Receive information
	// If on our transmit list, this is undefined information, and if on our
	// receive list, this is the SSRC's receive information, ie, this SSRC
	// is an active sender somewhere on the network. This information is
	// maintained by RTP, and used by RTCP to generate RR.
	RECV_INFO_ISDM	rcvInfo;

	// Feedback information received about ourselve if we're an active source
	RTCP_FEEDBACK	rrFeedback;				// Feedback	information

    DWORD		dwLastReportRcvdTime;	// Time of last report received

	// SSRC SDES information
	SDES_DATA	cnameInfo;		// CNAME information
	SDES_DATA	nameInfo;		// NAME information

    // SSRC network address information
	int		fromLen;	        // From address length
	char	from[MAX_ADDR_LEN];	// From address
		
	DWORD		dwNumRptSent;		// Number of RTCP report sent	
	DWORD		dwNumRptRcvd;		// Number of RTCP report rcvd	
	DWORD		dwNumXmtIoPending;  // Number of transmit I/O pending
	DWORD		dwStreamClock;		// Sampling frequency

	} ISDM2_ENTRY, *PISDM2_ENTRY;

#endif // #ifdef ENABLE_ISDM2

//----------------------------------------------------------------------------
//	RTP/RTCP Error Codes
//----------------------------------------------------------------------------
#define	RRCM_NoError					NO_ERROR
#define	RTP_ERROR_BASE					0x8100
#define	RTCP_ERROR_BASE					0x8200

// Macro to create a custom HRESULT
// S: Severity Code
// C: Customer subsystem (TRUE)
// F: Facility code
// E: Error code
#define MAKE_RRCM_HRESULT(S,C,F,E)	\
((((DWORD)(S)<<31)|((DWORD)(C)<<29)|((DWORD)(F)<<16)|((DWORD)(E))))

// Custom facility codes
#define FACILITY_BASE              0x080
#define FACILITY_RRCM              (FACILITY_BASE+9)

// Sample macro to support custom error reporting //
#define MAKE_RRCM_ERROR(error)	\
MAKE_RRCM_HRESULT(SEVERITY_ERROR,TRUE,FACILITY_RRCM,error)

// RTP Error Codes
#define RRCMError_RTPReInit					RTP_ERROR_BASE
#define RRCMError_RTPResources				(RTP_ERROR_BASE+1)
#define RRCMError_RTPInvalidDelete			(RTP_ERROR_BASE+2)
#define RRCMError_RTPNoContext				(RTP_ERROR_BASE+3)
#define RRCMError_RTPSessResources			(RTP_ERROR_BASE+4)
#define RRCMError_RTPInvalid				(RTP_ERROR_BASE+5)
#define RRCMError_RTPInvSocket				(RTP_ERROR_BASE+6)
#define RRCMError_RTPSSRCNotFound			(RTP_ERROR_BASE+7)
#define RRCMError_RTCPCreateError			(RTP_ERROR_BASE+8)
#define RRCMError_RTPInvalidSession			(RTP_ERROR_BASE+9)
#define RRCMError_RTPStreamNotFound			(RTP_ERROR_BASE+10)
#define RRCMError_WinsockLibNotFound		(RTP_ERROR_BASE+11)
#define RRCMError_RTPNoSession				(RTCP_ERROR_BASE+12)


// RTCP Error Codes
#define	RRCMError_RTCPReInit				RTCP_ERROR_BASE
#define	RRCMError_RTCPResources				(RTCP_ERROR_BASE+1)
#define RRCMError_RTCPInvalidDelete			(RTCP_ERROR_BASE+2)
#define RRCMError_RTCPNoContext				(RTCP_ERROR_BASE+3)
#define RRCMError_RTCPInvalidRequest		(RTCP_ERROR_BASE+4)
#define RRCMError_RTCPheapError				(RTCP_ERROR_BASE+5)
#define RRCMError_RTCPThreadCreation		(RTCP_ERROR_BASE+6)
#define RRCMError_RTCPInvalidSession		(RTCP_ERROR_BASE+7)
#define RRCMError_RTCPNotimer				(RTCP_ERROR_BASE+8)
#define	RRCMError_RTCPMaxStreamPerSession	(RTCP_ERROR_BASE+9)
#define	RRCMError_RTCPInvalidSSRCentry		(RTCP_ERROR_BASE+10)
#define RRCMError_RTCPNoXmtList				(RTCP_ERROR_BASE+11)
#define RRCMError_RTCPNoCname				(RTCP_ERROR_BASE+12)
#define RRCMError_RTCPNotImpl				(RTCP_ERROR_BASE+13)

		

// RRCM Exported API
HANDLE WINAPI CreateRTPSession (SOCKET,
								  SOCKET,
								  LPVOID,
								  DWORD,
								  PSDES_DATA,
								  DWORD,
								  PENCRYPT_INFO,
								  DWORD,
								  PRRCM_EVENT_CALLBACK,
								  DWORD_PTR,
								  DWORD,
								  DWORD,
								  PDWORD);

HRESULT WINAPI CloseRTPSession (HANDLE,
							     PCHAR,
							     DWORD);

DWORD WINAPI RTPSendTo ( HANDLE,
						 SOCKET,
					     LPWSABUF,
					     DWORD,
					     LPDWORD,
					     int,
					     LPVOID,
					     int,
					     LPWSAOVERLAPPED,
					     LPWSAOVERLAPPED_COMPLETION_ROUTINE);

DWORD WINAPI RTPRecvFrom (SOCKET,
						   LPWSABUF,
						   DWORD,
						   LPDWORD,
						   LPDWORD,
						   PSOCKADDR,
						   LPINT,
						   LPWSAOVERLAPPED,
						   LPWSAOVERLAPPED_COMPLETION_ROUTINE);

HRESULT WINAPI RTCPReportRequest (SOCKET,
							       DWORD,
								   PDWORD,
								   PDWORD,
								   DWORD,
								   PRTCP_REPORT,
								   DWORD,
								   LPVOID,
								   DWORD);

HRESULT WINAPI getRtcpSessionList (PDWORD_PTR,
								    DWORD,
								    PDWORD);

DWORD WINAPI updateRTCPDestinationAddress (HANDLE,
	 										PSOCKADDR,
											int);

DWORD WINAPI getAnSSRC (void);

DWORD WINAPI RTCPThreadCtrl (DWORD);

HRESULT WINAPI RTCPSendSessionCtrl (DWORD_PTR,
									 DWORD);

HRESULT WINAPI updateSSRCentry ( HANDLE,
								 SOCKET,
							     DWORD,
							     DWORD,
							     DWORD);

HRESULT WINAPI addApplicationRtcpBfr (DWORD_PTR,
									   PAPP_RTCP_BFR);

PAPP_RTCP_BFR WINAPI removeApplicationRtcpBfr (DWORD_PTR);

#ifdef __cplusplus
}
#endif

// restore structure packing
#include <poppack.h>

#endif /* #ifndef _RRCMDLL_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\sehcall.h ===
#ifndef NM_SEH_H
#define NM_SEH_H


// CallWithSEH is a utility function to call a function with structured exception handling

typedef DWORD (CALLBACK *INEXCEPTION)(LPEXCEPTION_RECORD per, PCONTEXT pctx);
typedef DWORD (CALLBACK *EXCEPTPROC)(void* pv);


#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI CallWithSEH(EXCEPTPROC pfn, void* pv, INEXCEPTION InException);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\shell2.h ===
#include <shlobj.h>         // ;Internal
#include <shellapi.h>       // ;Internal
						/* ;Internal */
#ifndef _SHSEMIP_H_
#define _SHSEMIP_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#ifndef DONT_WANT_SHELLDEBUG
    
#ifndef DebugMsg                                                                /* ;Internal */
#define DM_TRACE    0x0001      // Trace messages                               /* ;Internal */
#define DM_WARNING  0x0002      // Warning                                      /* ;Internal */
#define DM_ERROR    0x0004      // Error                                        /* ;Internal */
#define DM_ASSERT   0x0008      // Assertions                                   /* ;Internal */
#define Assert(f)                                                               /* ;Internal */
#define AssertE(f)      (f)                                                     /* ;Internal */
#define AssertMsg   1 ? (void)0 : (void)                                        /* ;Internal */
#define DebugMsg    1 ? (void)0 : (void)                                        /* ;Internal */
#endif                                                                          /* ;Internal */
                                                                                /* ;Internal */
#endif
    
//====== Ranges for WM_NOTIFY codes ==================================
// If a new set of codes is defined, make sure the range goes   /* ;Internal */
// here so that we can keep them distinct                       /* ;Internal */
// Note that these are defined to be unsigned to avoid compiler warnings  
// since NMHDR.code is declared as UINT.
//
// NM_FIRST - NM_LAST defined in commctrl.h (0U-0U) - (OU-99U)
//
// LVN_FIRST - LVN_LAST defined in commctrl.h (0U-100U) - (OU-199U)
//
// PSN_FIRST - PSN_LAST defined in prsht.h (0U-200U) - (0U-299U)
//
// HDN_FIRST - HDN_LAST defined in commctrl.h (0U-300U) - (OU-399U)
//
// TVN_FIRST - TVN_LAST defined in commctrl.h (0U-400U) - (OU-499U)

// TTN_FIRST - TTN_LAST defined in commctrl.h (0U-520U) - (OU-549U)

#define RFN_FIRST       (0U-510U) // run file dialog notify
#define RFN_LAST        (0U-519U)

#define SEN_FIRST       (0U-550U)       // ;Internal
#define SEN_LAST        (0U-559U)       // ;Internal


#define MAXPATHLEN      MAX_PATH        // ;Internal
    
    
//===========================================================================
// ITEMIDLIST
//===========================================================================

WINSHELLAPI LPITEMIDLIST  WINAPI ILGetNext(LPCITEMIDLIST pidl);
WINSHELLAPI UINT          WINAPI ILGetSize(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCreate(void);
WINSHELLAPI LPITEMIDLIST  WINAPI ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend);
WINSHELLAPI void          WINAPI ILFree(LPITEMIDLIST pidl);
WINSHELLAPI void          WINAPI ILGlobalFree(LPITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCreateFromPath(LPCSTR szPath);
WINSHELLAPI BOOL          WINAPI ILGetDisplayName(LPCITEMIDLIST pidl, LPSTR pszName);
WINSHELLAPI LPITEMIDLIST  WINAPI ILFindLastID(LPCITEMIDLIST pidl);
WINSHELLAPI BOOL          WINAPI ILRemoveLastID(LPITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILClone(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCloneFirst(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILGlobalClone(LPCITEMIDLIST pidl);
WINSHELLAPI BOOL          WINAPI ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
WINSHELLAPI BOOL          WINAPI ILIsEqualItemID(LPCSHITEMID pmkid1, LPCSHITEMID pmkid2);
WINSHELLAPI BOOL          WINAPI ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
WINSHELLAPI LPITEMIDLIST  WINAPI ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
WINSHELLAPI HRESULT       WINAPI ILLoadFromStream(LPSTREAM pstm, LPITEMIDLIST *pidl);
WINSHELLAPI HRESULT       WINAPI ILSaveToStream(LPSTREAM pstm, LPCITEMIDLIST pidl);
WINSHELLAPI HRESULT       WINAPI ILLoadFromFile(HFILE hfile, LPITEMIDLIST *pidl);
WINSHELLAPI HRESULT       WINAPI ILSaveToFile(HFILE hfile, LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI _ILCreate(UINT cbSize);	

WINSHELLAPI HRESULT       WINAPI SHILCreateFromPath(LPCSTR szPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut);

// helper macros
#define ILIsEmpty(pidl)	((pidl)->mkid.cb==0)
#define IsEqualItemID(pmkid1, pmkid2)	(memcmp(pmkid1, pmkid2, (pmkid1)->cb)==0)
#define ILCreateFromID(pmkid)   ILAppendID(NULL, pmkid, TRUE)

// unsafe macros
#define _ILSkip(pidl, cb)	((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)		_ILSkip(pidl, (pidl)->mkid.cb)

/*
 * The SHObjectProperties API provides an easy way to invoke
 *   the Properties context menu command on shell objects.
 *
 *   PARAMETERS
 *
 *     hwndOwner    The window handle of the window which will own the dialog
 *     dwType       A SHOP_ value as defined below
 *     lpObject     Name of the object, see SHOP_ values below
 *     lpPage       The name of the property sheet page to open to or NULL.
 *
 *   RETURN
 *
 *     TRUE if the Properties command was invoked
 */
WINSHELLAPI BOOL WINAPI SHObjectProperties(HWND hwndOwner, DWORD dwType, LPCSTR lpObject, LPCSTR lpPage);

#define SHOP_PRINTERNAME 1  // lpObject points to a printer friendly name
#define SHOP_FILEPATH    2  // lpObject points to a fully qualified path+file name
#define SHOP_TYPEMASK   0x00000003
#define SHOP_MODAL	0x80000000




//====== ShellMessageBox ================================================
                                                                         
// If lpcTitle is NULL, the title is taken from hWnd                     
// If lpcText is NULL, this is assumed to be an Out Of Memory message    
// If the selector of lpcTitle or lpcText is NULL, the offset should be a
//     string resource ID                                                
// The variable arguments must all be 32-bit values (even if fewer bits  
//     are actually used)                                                
// lpcText (or whatever string resource it causes to be loaded) should   
//     be a formatting string similar to wsprintf except that only the   
//     following formats are available:                                  
//         %%              formats to a single '%'                        
//         %nn%s           the nn-th arg is a string which is inserted    
//         %nn%ld          the nn-th arg is a DWORD, and formatted decimal
//         %nn%lx          the nn-th arg is a DWORD, and formatted hex    
//     note that lengths are allowed on the %s, %ld, and %lx, just        
//                         like wsprintf /* ;Internal */                  
//                                                                        
int _cdecl ShellMessageBox(HINSTANCE hAppInst, HWND hWnd, LPCSTR      
        lpcText, LPCSTR lpcTitle, UINT fuStyle, ...);                                               
                                                                          
//===================================================================    
// Smart tiling API's                                                   
WINSHELLAPI WORD WINAPI ArrangeWindows(HWND hwndParent, WORD flags, LPCRECT lpRect, WORD chwnd, const HWND *ahwnd);                             


//
// Flags for SHGetSetSettings
//
typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    UINT fRestFlags : 13;

    LPSTR pszHiddenFileExts;
    UINT cbHiddenFileExts;
} SHELLSTATE, *LPSHELLSTATE;

#define SSF_SHOWALLOBJECTS 0x0001
#define SSF_SHOWEXTENSIONS 0x0002
#define SSF_HIDDENFILEEXTS 0x0004
#define SSF_NOCONFIRMRECYCLE 0x8000

//
// for SHGetNetResource
//
typedef HANDLE HNRES;

//
// For SHCreateDefClassObject
//
typedef HRESULT (CALLBACK *LPFNCREATEINSTANCE)(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObject);

                                                                          
typedef void (WINAPI FAR* RUNDLLPROC)(HWND hwndStub,                      
        HINSTANCE hAppInstance,                                           
        LPSTR lpszCmdLine, int nCmdShow);                                 



//======================================================================= 
// String constants for                                                   
//  1. Registration database keywords       (prefix STRREG_)              
//  2. Exported functions from handler dlls (prefix STREXP_)              
//  3. .INI file keywords                   (prefix STRINI_)              
//  4. Others                               (prefix STR_)                 
//======================================================================= 
#define STRREG_SHELLUI          "ShellUIHandler"                          
#define STRREG_SHELL            "Shell"                                   
#define STRREG_DEFICON          "DefaultIcon"                             
#define STRREG_SHEX             "shellex"                                
#define STRREG_SHEX_PROPSHEET   STRREG_SHEX "\\PropertySheetHandlers"     
#define STRREG_SHEX_DDHANDLER   STRREG_SHEX "\\DragDropHandlers"              
#define STRREG_SHEX_MENUHANDLER STRREG_SHEX "\\ContextMenuHandlers"           
#define STRREG_SHEX_COPYHOOK    "Directory\\" STRREG_SHEX "\\CopyHookHandlers"
#define STRREG_SHEX_PRNCOPYHOOK "Printers\\" STRREG_SHEX "\\CopyHookHandlers" 
                                                                         
#define STREXP_CANUNLOAD        "DllCanUnloadNow"       // From OLE 2.0  
                                                                         
#define STRINI_CLASSINFO        ".ShellClassInfo"       // secton name   
#define STRINI_SHELLUI          "ShellUIHandler"                         
#define STRINI_OPENDIRICON      "OpenDirIcon"                            
#define STRINI_DIRICON          "DirIcon"                                
                                                                         
#define STR_DESKTOPINI          "desktop.ini"                            
                                                                         
// Maximum length of a path string
#define CCHPATHMAX      MAX_PATH
#define MAXSPECLEN      MAX_PATH
#define DRIVEID(path)   ((path[0] - 'A') & 31)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


#define PATH_CCH_EXT    64
// PathResolve flags							
#define PRF_VERIFYEXISTS	    0x0001				
#define PRF_TRYPROGRAMEXTENSIONS    (0x0002 | PRF_VERIFYEXISTS)		
#define PRF_FIRSTDIRDEF		    0x0004
#define PRF_DONTFINDLNK		    0x0008	// if PRF_TRYPROGRAMEXTENSIONS is specified




//
// For CallCPLEntry16
//
DECLARE_HANDLE(FARPROC16);

// Needed for RunFileDlg
#define RFD_NOBROWSE		0x00000001
#define RFD_NODEFFILE		0x00000002
#define RFD_USEFULLPATHDIR	0x00000004
#define RFD_NOSHOWOPEN          0x00000008

#ifdef RFN_FIRST
#define RFN_EXECUTE             (RFN_FIRST - 0)
typedef struct {
    NMHDR hdr;
    LPCSTR lpszCmd;
    LPCSTR lpszWorkingDir;
    int nShowCmd;
} NMRUNFILE, *LPNMRUNFILE;
#endif

// RUN FILE RETURN values from notify message
#define RFR_NOTHANDLED 0
#define RFR_SUCCESS 1
#define RFR_FAILURE 2


#define PathRemoveBlanksORD	33
#define PathFindFileNameORD	34
#define PathGetExtensionORD	158
#define PathFindExtensionORD	31

WINSHELLAPI LPSTR WINAPI PathAddBackslash(LPSTR lpszPath);
WINSHELLAPI LPSTR WINAPI PathRemoveBackslash(LPSTR lpszPath);
WINSHELLAPI void  WINAPI PathRemoveBlanks(LPSTR lpszString);
WINSHELLAPI BOOL  WINAPI PathRemoveFileSpec(LPSTR lpszPath);
WINSHELLAPI LPSTR WINAPI PathFindFileName(LPCSTR pPath);
WINSHELLAPI BOOL  WINAPI PathIsRoot(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathIsRelative(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathIsUNC(LPCSTR lpsz);
WINSHELLAPI BOOL  WINAPI PathIsDirectory(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathIsExe(LPCSTR lpszPath);
WINSHELLAPI int   WINAPI PathGetDriveNumber(LPCSTR lpszPath);
WINSHELLAPI LPSTR WINAPI PathCombine(LPSTR szDest, LPCSTR lpszDir, LPCSTR lpszFile);
WINSHELLAPI BOOL  WINAPI PathAppend(LPSTR pPath, LPCSTR pMore);
WINSHELLAPI LPSTR WINAPI PathBuildRoot(LPSTR szRoot, int iDrive);
WINSHELLAPI int   WINAPI PathCommonPrefix(LPCSTR pszFile1, LPCSTR pszFile2, LPSTR achPath);
WINSHELLAPI LPSTR WINAPI PathGetExtension(LPCSTR lpszPath, LPSTR lpszExtension, int cchExt);
WINSHELLAPI LPSTR WINAPI PathFindExtension(LPCSTR pszPath);
WINSHELLAPI BOOL  WINAPI PathCompactPath(HDC hDC, LPSTR lpszPath, UINT dx);
WINSHELLAPI BOOL  WINAPI PathFileExists(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathMatchSpec(LPCSTR pszFile, LPCSTR pszSpec);
WINSHELLAPI BOOL  WINAPI PathMakeUniqueName(LPSTR pszUniqueName, UINT cchMax, LPCSTR pszTemplate, LPCSTR pszLongPlate, LPCSTR pszDir);
WINSHELLAPI LPSTR WINAPI PathGetArgs(LPCSTR pszPath);
WINSHELLAPI BOOL  WINAPI PathGetShortName(LPCSTR lpszLongName, LPSTR lpszShortName, UINT cbShortName);
WINSHELLAPI BOOL  WINAPI PathGetLongName(LPCSTR lpszShortName, LPSTR lpszLongName, UINT cbLongName);
WINSHELLAPI void  WINAPI PathQuoteSpaces(LPSTR lpsz);
WINSHELLAPI void  WINAPI PathUnquoteSpaces(LPSTR lpsz);
WINSHELLAPI BOOL  WINAPI PathDirectoryExists(LPCSTR lpszDir);
WINSHELLAPI void  WINAPI PathQualify(LPSTR lpsz);
WINSHELLAPI int   WINAPI PathResolve(LPSTR lpszPath, LPCSTR dirs[], UINT fFlags);	
WINSHELLAPI LPSTR WINAPI PathGetNextComponent(LPCSTR lpszPath, LPSTR lpszComponent);
WINSHELLAPI LPSTR WINAPI PathFindNextComponent(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathIsSameRoot(LPCSTR pszPath1, LPCSTR pszPath2);
WINSHELLAPI void  WINAPI PathSetDlgItemPath(HWND hDlg, int id, LPCSTR pszPath);
WINSHELLAPI BOOL  WINAPI ParseField(LPCSTR szData, int n, LPSTR szBuf, int iBufLen);

int   WINAPI PathCleanupSpec(LPCSTR pszDir, LPSTR pszSpec);
//
//  Return codes from PathCleanupSpec.	Negative return values are
//  unrecoverable errors
//
#define PCS_FATAL	    0x80000000
#define PCS_REPLACEDCHAR    0x00000001
#define PCS_REMOVEDCHAR     0x00000002
#define PCS_TRUNCATED	    0x00000004
#define PCS_PATHTOOLONG     0x00000008	// Always combined with FATAL


WINSHELLAPI int   WINAPI RestartDialog(HWND hwnd, LPCSTR lpPrompt, DWORD dwReturn);
WINSHELLAPI void  WINAPI ExitWindowsDialog(HWND hwnd);
WINSHELLAPI int WINAPI RunFileDlg(HWND hwndParent, HICON hIcon, LPCSTR lpszWorkingDir, LPCSTR lpszTitle,
	LPCSTR lpszPrompt, DWORD dwFlags);
WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPSTR pszIconPath, UINT cbIconPath, int *piIconIndex);
WINSHELLAPI BOOL  WINAPI GetFileNameFromBrowse(HWND hwnd, LPSTR szFilePath, UINT cbFilePath, LPCSTR szWorkingDir, LPCSTR szDefExt, LPCSTR szFilters, LPCSTR szTitle);

WINSHELLAPI int  WINAPI DriveType(int iDrive);
WINSHELLAPI void WINAPI InvalidateDriveType(int iDrive);
WINSHELLAPI int  WINAPI IsNetDrive(int iDrive);

WINSHELLAPI UINT WINAPI Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);

WINSHELLAPI void WINAPI SHGetSetSettings(LPSHELLSTATE lpss, DWORD dwMask, BOOL bSet);
WINSHELLAPI LRESULT WINAPI SHRenameFile(HWND hwndParent, LPCSTR pszDir, LPCSTR pszOldName, LPCSTR pszNewName, BOOL bRetainExtension);

WINSHELLAPI UINT WINAPI SHGetNetResource(HNRES hnres, UINT iItem, LPNETRESOURCE pnres, UINT cbMax);

WINSHELLAPI STDAPI SHCreateDefClassObject(REFIID riid, LPVOID * ppv, LPFNCREATEINSTANCE lpfn, UINT *pcRefDll, REFIID riidInstance);

WINSHELLAPI LRESULT WINAPI CallCPLEntry16(HINSTANCE hinst, FARPROC16 lpfnEntry, HWND hwndCPL, UINT msg, DWORD lParam1, DWORD lParam2);
WINSHELLAPI BOOL    WINAPI SHRunControlPanel(LPCSTR lpcszCmdLine, HWND hwndMsgParent);

WINSHELLAPI STDAPI SHCLSIDFromString(LPCSTR lpsz, LPCLSID lpclsid);

#define SHObjectPropertiesORD	178
WINSHELLAPI BOOL WINAPI SHObjectProperties(HWND hwndOwner, DWORD dwType, LPCSTR lpObject, LPCSTR lpPage);

WINSHELLAPI int WINAPI DriveType(int iDrive);
WINSHELLAPI int WINAPI RestartDialog(HWND hwnd, LPCSTR lpPrompt, DWORD dwReturn);
WINSHELLAPI int WINAPI PickIconDlg(HWND hwnd, LPSTR pszIconPath, UINT cbIconPath, int *piIconIndex);


//===================================================================
// Shell_MergeMenu parameter
//
#define MM_ADDSEPARATOR		0x00000001L
#define MM_SUBMENUSHAVEIDS	0x00000002L

//-------- drive type identification --------------
// iDrive      drive index (0=A, 1=B, ...)
//
#define DRIVE_CDROM     5           // extended DriveType() types
#define DRIVE_RAMDRIVE  6
#define DRIVE_TYPE      0x000F      // type masek
#define DRIVE_SLOW      0x0010      // drive is on a slow link
#define DRIVE_LFN       0x0020      // drive supports LFNs
#define DRIVE_AUTORUN   0x0040      // drive has AutoRun.inf in root.
#define DRIVE_AUDIOCD   0x0080      // drive is a AudioCD
#define DRIVE_AUTOOPEN  0x0100      // should *always* auto open on insert
#define DRIVE_NETUNAVAIL 0x0200     // Network drive that is not available
#define DRIVE_SHELLOPEN  0x0400     // should auto open on insert, if shell has focus

#define DriveTypeFlags(iDrive)      DriveType('A' + (iDrive))
#define DriveIsSlow(iDrive)         (DriveTypeFlags(iDrive) & DRIVE_SLOW)
#define DriveIsLFN(iDrive)          (DriveTypeFlags(iDrive) & DRIVE_LFN)
#define DriveIsAutoRun(iDrive)      (DriveTypeFlags(iDrive) & DRIVE_AUTORUN)
#define DriveIsAutoOpen(iDrive)     (DriveTypeFlags(iDrive) & DRIVE_AUTOOPEN)
#define DriveIsShellOpen(iDrive)    (DriveTypeFlags(iDrive) & DRIVE_SHELLOPEN)
#define DriveIsAudioCD(iDrive)      (DriveTypeFlags(iDrive) & DRIVE_AUDIOCD)
#define DriveIsNetUnAvail(iDrive)   (DriveTypeFlags(iDrive) & DRIVE_NETUNAVAIL)

#define IsCDRomDrive(iDrive)        (DriveType(iDrive) == DRIVE_CDROM)
#define IsRamDrive(iDrive)          (DriveType(iDrive) == DRIVE_RAMDRIVE)
#define IsRemovableDrive(iDrive)    (DriveType(iDrive) == DRIVE_REMOVABLE)
#define IsRemoteDrive(iDrive)       (DriveType(iDrive) == DRIVE_REMOTE)

// should be moved to shell32s private include files

WINSHELLAPI int  WINAPI GetDefaultDrive();
WINSHELLAPI int  WINAPI SetDefaultDrive(int iDrive);
WINSHELLAPI int  WINAPI SetDefaultDirectory(LPCSTR lpPath);
WINSHELLAPI void WINAPI GetDefaultDirectory(int iDrive, LPSTR lpPath);

#define POSINVALID  32767       // values for invalid position

#define IDCMD_SYSTEMFIRST       0x8000
#define IDCMD_SYSTEMLAST        0xbfff
#define IDCMD_CANCELED          0xbfff
#define IDCMD_PROCESSED         0xbffe
#define IDCMD_DEFAULT           0xbffe

//====== SEMI-PRIVATE API ===============================
DECLARE_HANDLE( HPSXA );
WINSHELLAPI HPSXA SHCreatePropSheetExtArray( HKEY hKey, PCSTR pszSubKey, UINT max_iface );
WINSHELLAPI void SHDestroyPropSheetExtArray( HPSXA hpsxa );
WINSHELLAPI UINT SHAddFromPropSheetExtArray( HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT SHReplaceFromPropSheetExtArray( HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );

//====== SEMI-PRIVATE API ORDINALS ===============================
// This is the list of semi-private ordinals we semi-publish.
#define SHAddFromPropSheetExtArrayORD		167
#define SHCreatePropSheetExtArrayORD		168
#define SHDestroyPropSheetExtArrayORD		169
#define SHReplaceFromPropSheetExtArrayORD	170
#define SHCreateDefClassObjectORD		 70
#define SHGetNetResourceORD			 69

#define SHEXP_SHADDFROMPROPSHEETEXTARRAY	MAKEINTRESOURCE(SHAddFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEPROPSHEETEXTARRAY	        MAKEINTRESOURCE(SHCreatePropSheetExtArrayORD)
#define SHEXP_SHDESTROYPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHDestroyPropSheetExtArrayORD)
#define SHEXP_SHREPLACEFROMPROPSHEETEXTARRAY    MAKEINTRESOURCE(SHReplaceFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEDEFCLASSOBJECT            MAKEINTRESOURCE(SHCreateDefClassObjectORD)
#define SHEXP_SHGETNETRESOURCE                  MAKEINTRESOURCE(SHGetNetResourceORD)

/*
 * The SHFormatDrive API provides access to the Shell
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that the Shell does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *		 NOTE that unlike SHCheckDrive, hwnd == NULL does not cause
 *		 this dialog to come up as a "top level application" window.
 *		 This parameter should always be non-null, this dialog is
 *		 only designed to be the child of another window, not a
 *		 stand-alone application.
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *		 NOTE: The special value SHFMT_ID_DEFAULT means "use the
 *		       default format specified by the DMaint_FormatDrive
 *		       engine". If you want to FORCE a particular format
 *		       ID "up front" you will have to call
 *		       DMaint_GetFormatOptions yourself before calling
 *		       this to obtain the valid list of phys format IDs
 *		       (contents of the PhysFmtIDList array in the
 *		       FMTINFOSTRUCT).
 *     options = There is currently only two option bits defined
 *
 *		  SHFMT_OPT_FULL
 *                SHFMT_OPT_SYSONLY
 *
 *		 The normal defualt in the Shell format dialog is
 *		 "Quick Format", setting this option bit indicates that
 *		 the caller wants to start with FULL format selected
 *		 (this is useful for folks detecting "unformatted" disks
 *		 and wanting to bring up the format dialog).
 *
 *               The SHFMT_OPT_SYSONLY initializes the dialog to
 *               default to just sys the disk.
 *
 *		 All other bits are reserved for future expansion and
 *		 must be 0.
 *
 *		 Please note that this is a bit field and not a value
 *		 and treat it accordingly.
 *
 *   RETURN
 *	The return is either one of the SHFMT_* values, or if the
 *	returned DWORD value is not == to one of these values, then
 *	the return is the physical format ID of the last succesful
 *	format. The LOWORD of this value can be passed on subsequent
 *	calls as the fmtID parameter to "format the same type you did
 *	last time".
 *
 */
DWORD WINAPI SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options);

//
// Special value of fmtID which means "use the default format"
//
#define SHFMT_ID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define SHFMT_OPT_FULL     0x0001
#define SHFMT_OPT_SYSONLY  0x0002

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define SHFMT_ERROR	0xFFFFFFFFL	// Error on last format, drive may be formatable
#define SHFMT_CANCEL	0xFFFFFFFEL	// Last format was canceled
#define SHFMT_NOFORMAT  0xFFFFFFFDL	// Drive is not formatable


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif // _SHSEMIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\security.h ===
// This is the header file for conference security functions in common.lib
//
//	Created:	ClausGi	10-24-95
//

// Functions:
BOOL WINAPI HashPassword ( LPSTR szPasswd, LPBYTE lpBuffer, LPDWORD lpcbBuffer );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\shguidp.h ===
//
// CLSIDs of shell object classes. They don't have to be in a public header
// unless we decided to let ISVs to create shell objects directly by calling
// OleCreateInstance with one of class IDs.
//
// NOTE: those that are commented out are ready to be used again...
//

DEFINE_GUID(CLSID_ShellNetwork,        	0x208D2C60, 0x3AEA, 0x1069, 0xA2,0xD7,0x08,0x00,0x2B,0x30,0x30,0x9D);//208D2C60-3AEA-1069-A2D7-08002B30309D
DEFINE_GUID(CLSID_ShellDrives,         	0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D);//20D04FE0-3AEA-1069-A2D8-08002B30309D

// do this so that we don't break anyone's build by pulling it out
#ifndef NO_CLSID_ShellFolder
DEFINE_GUID(CLSID_ShellFolder,         	0x210A4BA0, 0x3AEA, 0x1069, 0xA2,0xD9,0x08,0x00,0x2B,0x30,0x30,0x9D);//210A4BA0-3AEA-1069-A2D9-08002B30309D
#endif

// DEFINE_GUID(CLSID_,                 	0x21444760, 0x3AEA, 0x1069, 0xA2,0xDA,0x08,0x00,0x2B,0x30,0x30,0x9D);//21444760-3AEA-1069-A2DA-08002B30309D
DEFINE_GUID(CLSID_ShellCopyHook,       	0x217FC9C0, 0x3AEA, 0x1069, 0xA2,0xDB,0x08,0x00,0x2B,0x30,0x30,0x9D);//217FC9C0-3AEA-1069-A2DB-08002B30309D
DEFINE_GUID(CLSID_ShellFileDefExt,     	0x21B22460, 0x3AEA, 0x1069, 0xA2,0xDC,0x08,0x00,0x2B,0x30,0x30,0x9D);//21B22460-3AEA-1069-A2DC-08002B30309D
DEFINE_GUID(CLSID_ShellDrvDefExt,      	0x5F5295E0, 0x429F, 0x1069, 0xA2,0xE2,0x08,0x00,0x2B,0x30,0x30,0x9D);//5F5295E0-429F-1069-A2E2-08002B30309D
DEFINE_GUID(CLSID_ShellNetDefExt,       0x86422020, 0x42A0, 0x1069, 0xA2,0xE5,0x08,0x00,0x2B,0x30,0x30,0x9D);//86422020-42A0-1069-A2E5-08002B30309D
DEFINE_GUID(CLSID_CCommonShellExtInit, 	0xA2AD3100, 0x3B84, 0x1069, 0xA2,0xDF,0x08,0x00,0x2B,0x30,0x30,0x9D);//A2AD3100-3B84-1069-A2DF-08002B30309D
DEFINE_GUID(CLSID_Briefcase,           	0x85BBD920, 0x42A0, 0x1069, 0xA2,0xE4,0x08,0x00,0x2B,0x30,0x30,0x9D);//85BBD920-42A0-1069-A2E4-08002B30309D
//DEFINE_GUID(CLSID_ShellMoniker,        	0x86747AC0, 0x42A0, 0x1069, 0xA2,0xE6,0x08,0x00,0x2B,0x30,0x30,0x9D);//86747AC0-42A0-1069-A2E6-08002B30309D
DEFINE_GUID(CLSID_Clouds,               0x869DADA0, 0x42A0, 0x1069, 0xA2,0xE7,0x08,0x00,0x2B,0x30,0x30,0x9D);//869DADA0-42A0-1069-A2E7-08002B30309D   // secret credits object
//DEFINE_GUID(CLSID_ShellIDMoniker,      	0x86C86720, 0x42A0, 0x1069, 0xA2,0xE8,0x08,0x00,0x2B,0x30,0x30,0x9D);//86C86720-42A0-1069-A2E8-08002B30309D   // shellidmoniker
DEFINE_GUID(CLSID_PifProperties,        0x86F19A00, 0x42A0, 0x1069, 0xA2,0xE9,0x08,0x00,0x2B,0x30,0x30,0x9D);//86F19A00-42A0-1069-A2E9-08002B30309D   // pifprops
DEFINE_GUID(CLSID_ShellFSFolder, 	0xF3364BA0, 0x65B9, 0x11CE, 0xA9,0xBA,0x00,0xAA,0x00,0x4A,0xE8,0x37);// F3364BA0-65B9-11CE-A9BA-00AA004AE837
// DEFINE_GUID(CLSID_, 	               	0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D   // shelllink
DEFINE_GUID(CLSID_ShellViewerExt,      	0x84F26EA0, 0x42A0, 0x1069, 0xA2,0xE3,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D   // shelllink
DEFINE_GUID(CLSID_ShellBitBucket,	0x645FF040, 0x5081, 0x101B, 0x9F,0x08,0x00,0xAA,0x00,0x2F,0x95,0x4E);//645FF040-5081-101B-9F08-00AA002F954E
DEFINE_GUID(CLSID_CControls,		0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_CPrinters,		0x2227A280, 0x3AEA, 0x1069, 0xA2,0xDE,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_Remote,               0x992CFFA0, 0xF557, 0x101A, 0x88,0xEC,0x00,0xDD,0x01,0x0C,0xCC,0x48);
DEFINE_GUID(CLSID_ShellFindExt,         0x61E218E0, 0x65D3, 0x101B, 0x9F,0x08,0x06,0x1C,0xEA,0xC3,0xD5,0x0D);//61E218E0-65D3-101B-9F08-061CEAC3D50D
DEFINE_GUID(CLSID_CFonts,		0xBD84B380, 0x8CA2, 0x1069, 0xAB,0x1D,0x08,0x00,0x09,0x48,0xF5,0x34);//bd84b380-8ca2-1069-ab1d-08000948f534
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\shlobjp.h ===
HRESULT CALLBACK CShellFileDefExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CShellDrvDefExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CShellNetDefExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CDrives_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CTray_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CDesktop_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CBriefcase_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CRecycleBin_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CNetwork_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CShellCopyHook_CreateInstance(LPUNKNOWN, REFIID , LPVOID *);
HRESULT CALLBACK CShellLink_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CControls_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CPrinters_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CShellViewerExt_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CShellBitBucket_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CShellFindExt_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CProxyPage_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CScrapData_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CFSFolder_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\shlstock.h ===
/*
 * shlstock.h - Shell Stock header file.
 *
 * Taken from URL code by ChrisPi 9-20-95
 *
 * Note: some types are only available with internal shell headers
 *       (these are ifdef'ed with INTERNALSHELL)
 *
 */

#ifndef _SHLSTOCK_H_
#define _SHLSTOCK_H_



#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Types
 ********/

/* interfaces */

DECLARE_STANDARD_TYPES(IExtractIcon);
DECLARE_STANDARD_TYPES(INewShortcutHook);
#ifdef INTERNALSHELL
DECLARE_STANDARD_TYPES(IShellExecuteHook);
#endif
DECLARE_STANDARD_TYPES(IShellLink);
DECLARE_STANDARD_TYPES(IShellExtInit);
DECLARE_STANDARD_TYPES(IShellPropSheetExt);

/* structures */

DECLARE_STANDARD_TYPES(DROPFILES);
DECLARE_STANDARD_TYPES(FILEDESCRIPTOR);
DECLARE_STANDARD_TYPES(FILEGROUPDESCRIPTOR);
DECLARE_STANDARD_TYPES(ITEMIDLIST);
DECLARE_STANDARD_TYPES(PROPSHEETPAGE);
DECLARE_STANDARD_TYPES(SHELLEXECUTEINFO);

/* flags */

typedef enum _shellexecute_mask_flags
{
   ALL_SHELLEXECUTE_MASK_FLAGS = (SEE_MASK_CLASSNAME |
                                  SEE_MASK_CLASSKEY |
                                  SEE_MASK_IDLIST |
                                  SEE_MASK_INVOKEIDLIST |
                                  SEE_MASK_ICON |
                                  SEE_MASK_HOTKEY |
                                  SEE_MASK_NOCLOSEPROCESS |
                                  SEE_MASK_CONNECTNETDRV |
                                  SEE_MASK_FLAG_DDEWAIT |
                                  SEE_MASK_DOENVSUBST |
                                  SEE_MASK_FLAG_NO_UI 
#ifdef INTERNALSHELL
                                | SEE_MASK_FLAG_SHELLEXEC |
                                  SEE_MASK_FORCENOIDLIST
#endif
                                  )
}
SHELLEXECUTE_MASK_FLAGS;


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#endif /* _SHLSTOCK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\standrd.h ===
#ifndef __standrd_h__
#define __standrd_h__


// Useful macros

#ifndef TRACENOTIMPL
    #define TRACENOTIMPL(funcname)   TRACE_OUT((_T("%s not implemented.\n"), funcname)); hr = E_NOTIMPL
#endif 

#define CONSTANT( x ) enum{ x }

#define CASERET(x) case x: return _T(#x)

#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))

#ifndef STRING_RESOURCE_MODULE
    # define STRING_RESOURCE_MODULE _Module.GetModuleInstance()
#endif

typedef struct _tagCol {
	UINT  dwWidth;
	LPTSTR lpsz;
} COL;
typedef COL * LPCOL;


inline LPTSTR CopyLPCTSTR( LPCTSTR sz )
{
    LPTSTR newString = new TCHAR[ lstrlen( sz ) + 1 ];
    if( !lstrcpy( newString, sz ) )
    {
        // Somethnig fialide
        delete [] newString;
        newString = NULL;
    }

    return newString;
}

#ifndef CchMax
    #define CchMax(pcsz)        (sizeof(pcsz) / sizeof((pcsz)[0]))
#endif // CchMax

#define MAX_RESOURCE_STRING_LEN 256


/*  C O N V E R T  S Z  C H  */
/*-------------------------------------------------------------------------
    %%Function: ConvertSzCh

    Replace every instance of chSrc to chDest in the string
-------------------------------------------------------------------------*/
inline VOID ConvertSzCh(LPTSTR psz, TCHAR chSrc, TCHAR chDest)
{
	while (_T('\0') != *psz)
	{
		if (chSrc == *psz)
		{
			*psz = chDest;
			psz++;
		}
		else
		{
			psz = CharNext(psz);
		}
	}
}


inline VOID ConvertSzCh(LPTSTR psz, TCHAR chSrc = _T('|'), TCHAR chDest = _T('\0'));


inline HRESULT NmCtlLoadString(UINT id, LPTSTR lpsz, UINT cch)
{
    HRESULT hr = S_OK;

    if( NULL != STRING_RESOURCE_MODULE )
    {
        if( NULL != lpsz )
        {
	        if (0 == ::LoadString(STRING_RESOURCE_MODULE, id, lpsz, cch))
	        {
		        ERROR_OUT(("*** Resource %d does not exist", id));
		        *lpsz = _T('\0');
		        hr = HRESULT_FROM_WIN32( ::GetLastError() );
	        }


        }
        else
        {
            ERROR_OUT(("LoadString passed an empty buffer"));
            hr = E_INVALIDARG;
        }
    }
    else
    {
        ERROR_OUT(("LoadString could not find the module"));
        hr = E_UNEXPECTED;
    }

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////
// this works if you have a member variable CComBSTR m_bstrProp ( substitute Prop for the Prop param )
// Example:
//
// CComBSTR m_bstrName;
//
//
// DECLARE_CCOMBSTR_PROPPUT( Name, DISPID_PROP_NAME );
// DECLARE_CCOMBSTR_PROPGET( Name );
//
#define DECLARE_CCOMBSTR_PROPPUT( Prop, PROP_DISPID ) \
    STDMETHOD(put_##Prop)( BSTR newVal )  \
    {\
        HRESULT hr = S_OK;\
        if( S_OK == __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(GetUnknown(), PROP_DISPID) )\
        {\
            m_bstr##Prop = newVal;\
            hr = __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(GetUnknown(), PROP_DISPID);\
        }\
        return hr;                \
    }


#define DECLARE_CCOMBSTR_PROPGET( Prop ) \
    STDMETHOD(get_##Prop)( BSTR *pVal )  \
    {\
        if( pVal )\
        {\
            *pVal = m_bstr##Prop.Copy();\
        }\
        else\
        {\
            return E_POINTER;\
        }\
        return S_OK;\
    }



///////////////////////////////////////////////////////////////////////////////////////////////////////////
// this works if you have a member variable <class with iterator> m_aryProp ( substitute Prop for the Prop param )
// Example:
//
// lst<IUnknown*> m_AryName;
//
//
// DECLARE_SAFEARRAY_UNK_PROPPUT( Name, DISPID_PROP_NAME );
// DECLARE_SAFEARRAY_UNK_PROPGET( Name );
//

#define DECLARE_SAFEARRAY_UNK_PROPPUT( Prop, PROP_DISPID ) \
    STDMETHOD(put_##Prop)( SAFEARRAY newVal )  \
    {\
        HRESULT hr = S_OK;\
        if( S_OK == __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(GetUnknown(), PROP_DISPID) )\
        {\
            lst<IUnknown*>::iterator I = m_ary##Prop.begin();\
            while( I != m_ary##Prop.end() )\
            {\
                (*I)->Release();\
                ++I;\
            }\
            m_ary##Prop.erase(m_ary##Prop.begin(), m_ary##Prop.end());\
            IUnknown** ppUnkArray;\
            SafeArrayAccessData( &newVal, reinterpret_cast<void**>(&ppUnkArray) );\
            for (UINT x = 0; x < newVal.rgsabound->cElements; x++)\
	        {\
                IUnknown* pUnk = ppUnkArray[x];\
                pUnk->AddRef();\
                m_ary##Prop.push_back( pUnk );\
	        }\
            SafeArrayUnaccessData(&newVal);\
            hr = __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(GetUnknown(), PROP_DISPID);\
        }\
        return hr;                \
    }


#define DECLARE_SAFEARRAY_UNK_PROPGET( Prop ) \
    STDMETHOD(get_##Prop)( SAFEARRAY *pVal )  \
    {\
        if( pVal )\
        {\
            int nItems = m_ary##Prop.size();\
            SAFEARRAYBOUND bounds = { nItems, 0 };\
            pVal = SafeArrayCreate( VT_UNKNOWN, 1, &bounds );\
            IUnknown** ppUnkArray;\
            SafeArrayAccessData( pVal, reinterpret_cast<void**>(&ppUnkArray) );\
            lst<IUnknown*>::iterator I = m_ary##Prop.begin();\
            for( int i = 0; I != m_ary##Prop.end(); ++I, ++i )\
            {\
                ppUnkArray[i] = (*I);\
            }\
            SafeArrayUnaccessData(pVal);\
        }\
        else\
        {\
            return E_POINTER;\
        }\
        return S_OK;\
    }
///////////////////////////////////////////////////////////////////////////////////////////////////////
// The following DECLARE_PROPXXX macros define functions if you have a member variable that supports
// an issignment operator ( cleaning up memory if need be....
#define DECLARE_PROPPUT( Type, lVal, Prop, PROP_DISPID ) \
    STDMETHOD(put_##Prop)( Type newVal )  \
    {\
        HRESULT hr = S_OK;\
        if( S_OK == __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(GetUnknown(), PROP_DISPID) )\
        {\
            lVal = newVal;\
            hr = __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(GetUnknown(), PROP_DISPID);\
        }\
        return hr;                \
    }


#define DECLARE_PROPGET( Type, rVal, Prop ) \
    STDMETHOD(get_##Prop)( Type* pVal )\
    {\
        if( pVal )\
        {\
            *pVal = rVal;\
        }\
        else\
        {\
            return E_POINTER;\
        }\
        return S_OK;\
    }

inline HRESULT GetTextBoxHeight( HWND hwnd, int* pcy )
{

    HRESULT hr = S_OK;
    HDC hdc = NULL;
    HFONT hSysFont = NULL;
    HFONT hOldFont = NULL;
    TEXTMETRIC tm;

    int HeightOfCurrentFont = 0;
    int HeightOfSystemFont = 0;

    if( pcy )
    {
        if( IsWindow( hwnd ) )
        {
           //get the DC for the  control
           hdc = GetDC(hwnd);

           //get the metrics for the system font
           hSysFont = reinterpret_cast<HFONT>(GetStockObject(SYSTEM_FONT));
           hOldFont = reinterpret_cast<HFONT>(SelectObject(hdc, hSysFont));
           GetTextMetrics(hdc, &tm);
           HeightOfSystemFont = tm.tmHeight;

           //select the original font back into the DC and release the DC
           SelectObject(hdc, hOldFont);
           DeleteObject(hSysFont);
           
           GetTextMetrics(hdc, &tm);
           
		   ReleaseDC(hwnd, hdc);
		   
		   HeightOfCurrentFont = tm.tmHeight;

           *pcy = HeightOfCurrentFont + 
                  ( min( HeightOfSystemFont, HeightOfCurrentFont ) >> 1 ) + 
                  (GetSystemMetrics(SM_CYEDGE) * 2);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

#define RES_CH_MAX 256

inline TCHAR* Res2THelper( UINT uID, TCHAR* psz, int cch )
{
    if( LoadString( STRING_RESOURCE_MODULE, uID, psz, cch ) )
    {
        return psz;
    }

    return _T("");
}

#ifndef RES2T
#define COPY_RES2T(buff) lstrcpy(buff, s_Res2T);
#define USES_RES2T TCHAR s_Res2T[RES_CH_MAX];
#define RES2T(uID) ( Res2THelper( uID, s_Res2T , RES_CH_MAX ) )
#endif

inline LPCTSTR CommDlgLastErrorToa( DWORD dwErr )
{
    switch( dwErr )
    {
        CASERET ( CDERR_DIALOGFAILURE   ); 
        CASERET ( CDERR_GENERALCODES     );
        CASERET ( CDERR_STRUCTSIZE       );
        CASERET ( CDERR_INITIALIZATION   );
        CASERET ( CDERR_NOTEMPLATE       );
        CASERET ( CDERR_NOHINSTANCE      );
        CASERET ( CDERR_LOADSTRFAILURE   );
        CASERET ( CDERR_FINDRESFAILURE   );
        CASERET ( CDERR_LOADRESFAILURE   );
        CASERET ( CDERR_LOCKRESFAILURE   );
        CASERET ( CDERR_MEMALLOCFAILURE  );
        CASERET ( CDERR_MEMLOCKFAILURE   );
        CASERET ( CDERR_NOHOOK           );
        CASERET ( CDERR_REGISTERMSGFAIL  );

        CASERET ( PDERR_PRINTERCODES     );
        CASERET ( PDERR_SETUPFAILURE     );
        CASERET ( PDERR_PARSEFAILURE     );
        CASERET ( PDERR_RETDEFFAILURE    );
        CASERET ( PDERR_LOADDRVFAILURE   );
        CASERET ( PDERR_GETDEVMODEFAIL   );
        CASERET ( PDERR_INITFAILURE      );
        CASERET ( PDERR_NODEVICES        );
        CASERET ( PDERR_NODEFAULTPRN     );
        CASERET ( PDERR_DNDMMISMATCH     );
        CASERET ( PDERR_CREATEICFAILURE  );
        CASERET ( PDERR_PRINTERNOTFOUND  );
        CASERET ( PDERR_DEFAULTDIFFERENT );

        CASERET ( CFERR_CHOOSEFONTCODES  );
        CASERET ( CFERR_NOFONTS          );
        CASERET ( CFERR_MAXLESSTHANMIN   );

        CASERET ( FNERR_FILENAMECODES    );
        CASERET ( FNERR_SUBCLASSFAILURE  );
        CASERET ( FNERR_INVALIDFILENAME  );
        CASERET ( FNERR_BUFFERTOOSMALL   );

        CASERET ( FRERR_FINDREPLACECODES );
        CASERET ( FRERR_BUFFERLENGTHZERO );

        CASERET ( CCERR_CHOOSECOLORCODES );
    }

    return _T("NOERROR");
}

inline void DumpCommDlgLastError()
{
    ATLTRACE(_T("CommDlgExtendedError == %s"), CommDlgLastErrorToa( CommDlgExtendedError() ));
}

inline int _Points_From_LogFontHeight( int height, HWND hwnd )
{
	HDC hdc = ::GetDC( hwnd );
	if( NULL != hdc )
	{
		int iRet = MulDiv( -height, 72, GetDeviceCaps( hdc, LOGPIXELSY ) );
		::ReleaseDC( hwnd, hdc );
		return iRet;
	}

	return 0;
}


#endif // __standrd_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\shellp.h ===
#ifndef _SHELLP_H_
#define _SHELLP_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

//
// shell private header
//

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//===========================================================================
#ifndef _SHSEMIP_H_
// Handle to property sheet extension array
DECLARE_HANDLE( HPSXA );
#endif // _SHSEMIP_H_

//===========================================================================
// Shell restrictions. (Parameter for SHRestriction)
typedef enum
{
	REST_NONE			= 0x00000000,
	REST_NORUN 			= 0x00000001,
	REST_NOCLOSE			= 0x00000002,
	REST_NOSAVESET			= 0x00000004,
	REST_NOFILEMENU 		= 0x00000008,
	REST_NOSETFOLDERS		= 0x00000010,
	REST_NOSETTASKBAR		= 0x00000020,
	REST_NODESKTOP			= 0x00000040,
	REST_NOFIND			= 0x00000080,
	REST_NODRIVES			= 0x00000100,
	REST_NODRIVEAUTORUN		= 0x00000200,
	REST_NODRIVETYPEAUTORUN		= 0x00000400,
	REST_NONETHOOD			= 0x00000800,
	REST_STARTBANNER		= 0x00001000,
	REST_RESTRICTRUN		= 0x00002000,
	REST_NOPRINTERTABS		= 0x00004000,
	REST_NOPRINTERDELETE		= 0x00008000,
	REST_NOPRINTERADD		= 0x00010000,
	REST_NOSTARTMENUSUBFOLDERS	= 0x00020000,
        REST_MYDOCSONNET                = 0x00040000,
        REST_NOEXITTODOS                = 0x00080000,
} RESTRICTIONS;

WINSHELLAPI HRESULT WINAPI CIDLData_CreateFromIDArray(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], LPDATAOBJECT * ppdtobj);
WINSHELLAPI BOOL WINAPI SHIsBadInterfacePtr(LPCVOID pv, UINT cbVtbl);
//
// Stream API
//
WINSHELLAPI LPSTREAM WINAPI OpenRegStream(HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
WINSHELLAPI LPSTREAM WINAPI OpenFileStream(LPCSTR szFile, DWORD grfMode);
//
// OLE ripoffs of Drag and Drop related API
//
WINSHELLAPI HRESULT WINAPI SHRegisterDragDrop(HWND hwnd, LPDROPTARGET pdtgt);
WINSHELLAPI HRESULT WINAPI SHRevokeDragDrop(HWND hwnd);
WINSHELLAPI HRESULT WINAPI SHDoDragDrop(HWND hwndOwner, LPDATAOBJECT pdata, LPDROPSOURCE pdsrc, DWORD dwEffect, LPDWORD pdwEffect);
//
// Special folder
//
WINSHELLAPI LPITEMIDLIST WINAPI SHCloneSpecialIDList(HWND hwndOwner, int nFolder, BOOL fCreate);
WINSHELLAPI BOOL WINAPI SHGetSpecialFolderPath(HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate);
// DiskFull
WINSHELLAPI void WINAPI SHHandleDiskFull(HWND hwnd, int idDrive);

//
// File Search APIS
//
WINSHELLAPI BOOL WINAPI SHFindFiles(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);
WINSHELLAPI BOOL WINAPI SHFindComputer(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);
//
//
WINSHELLAPI void WINAPI PathGetShortPath(LPSTR pszLongPath);
WINSHELLAPI BOOL WINAPI PathFindOnPath(LPSTR szFile, LPCSTR FAR * ppszOtherDirs);
WINSHELLAPI BOOL WINAPI PathYetAnotherMakeUniqueName(LPSTR  pszUniqueName, LPCSTR pszPath, LPCSTR pszShort, LPCSTR pszFileSpec);
//
WINSHELLAPI BOOL WINAPI Win32CreateDirectory(LPCSTR lpszPath, LPSECURITY_ATTRIBUTES lpsa);
WINSHELLAPI BOOL WINAPI Win32RemoveDirectory(LPCSTR lpszPath);
WINSHELLAPI BOOL WINAPI Win32DeleteFile(LPCSTR lpszPath);

// Convert an IDList into a logical IDList so that desktop folders	
// appear at the right spot in the tree					
WINSHELLAPI LPITEMIDLIST WINAPI SHLogILFromFSIL(LPCITEMIDLIST pidlFS);		

// Convert an ole string.
WINSHELLAPI BOOL WINAPI StrRetToStrN(LPSTR szOut, UINT uszOut, LPSTRRET pStrRet, LPCITEMIDLIST pidl);

WINSHELLAPI DWORD WINAPI SHWaitForFileToOpen(LPCITEMIDLIST pidl,
                               UINT uOptions, DWORD dwtimeout);
WINSHELLAPI HRESULT WINAPI SHGetRealIDL(LPSHELLFOLDER psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST FAR* ppidlReal);

WINSHELLAPI void WINAPI SetAppStartingCursor(HWND hwnd, BOOL fSet);

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)

WINSHELLAPI DWORD WINAPI SHRestricted(RESTRICTIONS rest);
WINSHELLAPI LPVOID WINAPI SHGetHandlerEntry(LPCSTR szHandler, LPCSTR szProcName, HINSTANCE *lpModule);

WINSHELLAPI STDAPI SHCoCreateInstance(LPCSTR pszCLSID, const CLSID FAR * lpclsid,
	LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv);
WINSHELLAPI BOOL  WINAPI SignalFileOpen(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST WINAPI SHSimpleIDListFromPath(LPCSTR pszPath);
WINSHELLAPI int WINAPI SHCreateDirectory(HWND hwnd, LPCSTR pszPath);

WINSHELLAPI HPSXA SHCreatePropSheetExtArray( HKEY hKey, PCSTR pszSubKey, UINT max_iface );
WINSHELLAPI void SHDestroyPropSheetExtArray( HPSXA hpsxa );
WINSHELLAPI UINT SHAddFromPropSheetExtArray( HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT SHReplaceFromPropSheetExtArray( HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );
WINSHELLAPI DWORD SHNetConnectionDialog(HWND hwnd, LPSTR pszRemoteName, DWORD dwType) ;
WINSHELLAPI STDAPI SHLoadOLE(LPARAM lParam);
WINSHELLAPI void WINAPI Desktop_UpdateBriefcaseOnEvent(HWND hwnd, UINT uEvent);

WINSHELLAPI HRESULT WINAPI SHCreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], LPENUMFORMATETC * ppenumFormatEtc);

// Shell create link API
#define SHCL_USETEMPLATE	0x0001
#define SHCL_USEDESKTOP		0x0002
#define SHCL_CONFIRM		0x0004

WINSHELLAPI HRESULT WINAPI SHCreateLinks(HWND hwnd, LPCSTR pszDir, IDataObject *pDataObj, UINT fFlags, LPITEMIDLIST* ppidl);

//
// Interface pointer validation
//
#define IsBadInterfacePtr(pitf, ITF)  SHIsBadInterfacePtr(pitf, sizeof(ITF##Vtbl))

//===========================================================================
// Image dragging API (definitely private)
//===========================================================================

// stuff for doing auto scrolling
#define NUM_POINTS	3
typedef struct {	// asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

#define DAD_InitScrollData(pad) (pad)->bFull = FALSE, (pad)->iNextSample = 0, (pad)->dwLastScroll = 0

WINSHELLAPI BOOL WINAPI DAD_SetDragImage(HIMAGELIST him, POINT FAR* pptOffset);
WINSHELLAPI BOOL WINAPI DAD_DragEnter(HWND hwndTarget);
WINSHELLAPI BOOL WINAPI DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart);
WINSHELLAPI BOOL WINAPI DAD_ShowDragImage(BOOL fShow);
WINSHELLAPI BOOL WINAPI DAD_DragMove(POINT pt);
WINSHELLAPI BOOL WINAPI DAD_DragLeave(void);
WINSHELLAPI BOOL WINAPI DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
WINSHELLAPI BOOL WINAPI DAD_SetDragImageFromListView(HWND hwndLV, POINT ptOffset);

//===========================================================================
// Another block of private API
//===========================================================================

// indexes into the shell image lists (Shell_GetImageList) for default images
#define II_DOCNOASSOC   0         // document (blank page) (not associated)
#define II_DOCUMENT     1         // document (with stuff on the page)
#define II_APPLICATION  2         // application (exe, com, bat)
#define II_FOLDER       3         // folder (plain)
#define II_FOLDEROPEN   4         // folder (open)
// Startmenu images.							
#define II_STPROGS    	19						
#define II_STDOCS	20						
#define II_STSETNGS    	21						
#define II_STFIND    	22						
#define II_STHELP    	23						
#define II_STRUN  	24						
#define II_STSUSPD  	25						
#define II_STEJECT  	26						
#define II_STSHUTD    	27						
// More startmenu image.
#define II_STCPANEL	35
#define II_STSPROGS	36
#define II_STPRNTRS	37
#define II_STFONTS	38
#define II_STTASKBR	39
									
WINSHELLAPI BOOL  WINAPI Shell_GetImageLists(HIMAGELIST FAR *phiml, HIMAGELIST FAR *phimlSmall);
WINSHELLAPI void  WINAPI Shell_SysColorChange(void);
WINSHELLAPI int   WINAPI Shell_GetCachedImageIndex(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags);

WINSHELLAPI LRESULT WINAPI SHShellFolderView_Message(HWND hwndMain, UINT uMsg, LPARAM lParam);

// A usefull function in Defview for mapping idlist into index into system
// image list.  Optionally it can also look up the index of the selected
// icon.
WINSHELLAPI int WINAPI SHMapPIDLToSystemImageListIndex(LPSHELLFOLDER pshf, LPCITEMIDLIST pidl, int *piIndexSel);
//
// OLE string
//
WINSHELLAPI int WINAPI OleStrToStrN(LPSTR, int, LPCOLESTR, int);
WINSHELLAPI int WINAPI StrToOleStrN(LPOLESTR, int, LPCSTR, int);
WINSHELLAPI int WINAPI OleStrToStr(LPSTR, LPCOLESTR);
WINSHELLAPI int WINAPI StrToOleStr(LPOLESTR, LPCSTR);

//===========================================================================
// Useful macros
//===========================================================================
#define ResultFromShort(i)  ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, (USHORT)(i)))
#define ShortFromResult(r)  (short)SCODE_CODE(GetScode(r))


// Tray CopyData Messages
#define TCDM_APPBAR     0x00000000
#define TCDM_NOTIFY     0x00000001
#define TCDM_LOADINPROC 0x00000002


//===========================================================================
// IShellFolder::UIObject helper
//===========================================================================

STDAPI SHCreateDefExtIconKey(HKEY hkey, LPCSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, LPEXTRACTICON FAR* pxiconOut);
STDAPI SHCreateDefExtIcon(LPCSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, LPEXTRACTICON FAR* pxiconOut);

//
// BUGBUG: lParam for DFM_INVOKECOMMAND needs to be changed
// now it contains "args" but it should just contain the LPCMINVOKECOMMANDINFO
//                                  uMsg       wParam       lParam
#define DFM_MERGECONTEXTMENU         1      // uFlags       LPQCMINFO
#define DFM_INVOKECOMMAND            2      // idCmd        pszArgs
#define DFM_ADDREF                   3      // 0            0
#define DFM_RELEASE                  4      // 0            0
#define DFM_GETHELPTEXT              5      // idCmd,cchMax pszText
#define DFM_WM_MEASUREITEM           6      // ---from the message---
#define DFM_WM_DRAWITEM              7      // ---from the message---
#define DFM_WM_INITMENUPOPUP         8      // ---from the message---
#define DFM_VALIDATECMD              9      // idCmd        0
#define DFM_MERGECONTEXTMENU_TOP     10     // uFlags       LPQCMINFO

// Commands from DFM_INVOKECOMMAND when strings are passed in
#define DFM_CMD_DELETE		((WPARAM)-1)
#define DFM_CMD_MOVE		((WPARAM)-2)
#define DFM_CMD_COPY		((WPARAM)-3)
#define DFM_CMD_LINK		((WPARAM)-4)
#define DFM_CMD_PROPERTIES	((WPARAM)-5)
#define DFM_CMD_NEWFOLDER	((WPARAM)-6)
#define DFM_CMD_PASTE		((WPARAM)-7)
#define DFM_CMD_VIEWLIST	((WPARAM)-8)
#define DFM_CMD_VIEWDETAILS	((WPARAM)-9)
#define DFM_CMD_PASTELINK       ((WPARAM)-10)
#define DFM_CMD_PASTESPECIAL	((WPARAM)-11)
#define DFM_CMD_MODALPROP       ((WPARAM)-12)

typedef struct _QCMINFO	// qcm
{
    HMENU	hmenu;		// in
    UINT	indexMenu;	// in
    UINT	idCmdFirst;	// in/out
    UINT	idCmdLast;	// in
} QCMINFO, FAR* LPQCMINFO;

typedef HRESULT (CALLBACK FAR* LPFNDFMCALLBACK)(LPSHELLFOLDER psf,
						HWND hwndOwner,
						LPDATAOBJECT pdtobj,
						UINT uMsg,
						WPARAM wParam,
						LPARAM lParam);

STDAPI CDefFolderMenu_Create(LPCITEMIDLIST pidlFolder,
			     HWND hwndOwner,
			     UINT cidl, LPCITEMIDLIST FAR* apidl,
			     LPSHELLFOLDER psf,
			     LPFNDFMCALLBACK lpfn,
			     HKEY hkeyProgID, HKEY hkeyBaseProgID,
			     LPCONTEXTMENU FAR* ppcm);

void PASCAL CDefFolderMenu_MergeMenu(HINSTANCE hinst, UINT idMainMerge, UINT idPopupMerge,
	LPQCMINFO pqcm);
void PASCAL Def_InitFileCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
	BOOL bContext);
void PASCAL Def_InitEditCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
	LPDROPTARGET pdtgt, UINT fContext);
void NEAR PASCAL _SHPrettyMenu(HMENU hm);

//===========================================================================
// Default IShellView for IShellFolder
//===========================================================================

WINSHELLAPI HRESULT WINAPI SHCreateShellFolderView(LPSHELLFOLDER pshf, LPCITEMIDLIST pidl, LONG lEvent, LPSHELLVIEW FAR* ppsv);

// Menu ID's
#ifdef BUG_23171_FIXED
#define SFVIDM_FIRST			(FCIDM_SHVIEWLAST-0x0fff)
#else
// MENUEX currently cannot handle subtraction in the ID's, so we need
// to subtract for it.
#if (FCIDM_SHVIEWLAST != 0x7fff)
#error FCIDM_SHVIEWLAST has changed, so shellp.h needs to also
#endif
#define SFVIDM_FIRST			(0x7000)
#endif
#define SFVIDM_LAST			(FCIDM_SHVIEWLAST)

// Popup menu ID's used in merging menus
#define SFVIDM_MENU_ARRANGE	(SFVIDM_FIRST + 0x0001)
#define SFVIDM_MENU_VIEW	(SFVIDM_FIRST + 0x0002)
#define SFVIDM_MENU_SELECT	(SFVIDM_FIRST + 0x0003)

// TBINFO flags
#define TBIF_APPEND     0
#define TBIF_PREPEND    1
#define TBIF_REPLACE    2

typedef struct _TBINFO
{
    UINT        cbuttons;       // out
    UINT        uFlags;         // out (one of TBIF_ flags)
} TBINFO, FAR * LPTBINFO;

typedef struct _COPYHOOKINFO
{
    HWND hwnd;
    DWORD wFunc;
    DWORD wFlags;
    LPCSTR pszSrcFile;
    DWORD dwSrcAttribs;
    LPCSTR pszDestFile;
    DWORD dwDestAttribs;
} COPYHOOKINFO, *LPCOPYHOOKINFO;

typedef struct _DETAILSINFO
{
    LPCITEMIDLIST pidl;     // pidl to get details of
    // Note: do not change the order of these fields until IShellDetails
    //       has gone away!
    int fmt;                // LVCFMT_* value (header only)
    int cxChar;             // Number of "average" characters (header only)
    STRRET str;             // String information
} DETAILSINFO, *PDETAILSINFO;

//                               uMsg    wParam         lParam
#define DVM_MERGEMENU            1    // uFlags             LPQCMINFO
#define DVM_INVOKECOMMAND        2    // idCmd              0
#define DVM_GETHELPTEXT          3    // idCmd,cchMax       pszText
#define DVM_GETTOOLTIPTEXT       4    // idCmd,cchMax       pszText
#define DVM_GETBUTTONINFO        5    // 0                  LPTBINFO
#define DVM_GETBUTTONS           6    // idCmdFirst,cbtnMax LPTBBUTTON
#define DVM_INITMENUPOPUP        7    // idCmdFirst,nIndex  hmenu
#define DVM_SELCHANGE            8    // idCmdFirst,nItem   PDVSELCHANGEINFO
#define DVM_DRAWITEM             9    // idCmdFirst         pdis
#define DVM_MEASUREITEM         10    // idCmdFirst         pmis
#define DVM_EXITMENULOOP        11    // -                  -
#define DVM_RELEASE             12    // -                  lSelChangeInfo (ShellFolder private)
#define DVM_GETCCHMAX           13    // pidlItem           pcchMax
#define DVM_FSNOTIFY            14    // LPITEMIDLIST*      lEvent
#define DVM_WINDOWCREATED       15    // hwnd               PDVSELCHANGEINFO
#define DVM_WINDOWDESTROY       16    // hwnd               PDVSELCHANGEINFO
#define DVM_REFRESH             17    // -                  lSelChangeInfo
#define DVM_SETFOCUS            18    // -                  lSelChangeInfo
#define DVM_KILLFOCUS           19    // -                  -
#define DVM_QUERYCOPYHOOK	20    // -                  -
#define DVM_NOTIFYCOPYHOOK      21    // -                  LPCOPYHOOKINFO
#define DVM_NOTIFY		22    // idFrom		    LPNOTIFY
#define DVM_GETDETAILSOF        23    // iColumn            PDETAILSINFO
#define DVM_COLUMNCLICK         24    // iColumn            -
#define DVM_QUERYFSNOTIFY       25    // -                  FSNotifyEntry *
#define DVM_DEFITEMCOUNT        26    // -                  PINT
#define DVM_DEFVIEWMODE         27    // -                  PFOLDERVIEWMODE
#define DVM_UNMERGEMENU         28    // uFlags
#define DVM_INSERTITEM          29    // pidl               PDVSELCHANGEINFO
#define DVM_DELETEITEM          30    // pidl               PDVSELCHANGEINFO
#define DVM_UPDATESTATUSBAR     31    // -                  lSelChangeInfo
#define DVM_BACKGROUNDENUM      32
#define DVM_GETWORKINGDIR       33
#define DVM_GETCOLSAVESTREAM    34    // flags              IStream **
#define DVM_SELECTALL           35    //                    lSelChangeInfo
#define DVM_DIDDRAGDROP         36    // dwEffect           IDataObject *

typedef struct _DVSELCHANGEINFO {
    UINT uOldState;
    UINT uNewState;
    LPARAM lParamItem;
    LPARAM* plParam;
} DVSELCHANGEINFO, *PDVSELCHANGEINFO;

typedef HRESULT (CALLBACK FAR* LPFNVIEWCALLBACK)(LPSHELLVIEW psvOuter,
						LPSHELLFOLDER psf,
                                                HWND hwndMain,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

// SHCreateShellFolderViewEx struct
typedef struct _CSFV
{
    UINT            cbSize;
    LPSHELLFOLDER   pshf;
    LPSHELLVIEW     psvOuter;
    LPCITEMIDLIST   pidl;
    LONG            lEvents;
    LPFNVIEWCALLBACK pfnCallback;       // No callback if NULL
    FOLDERVIEWMODE  fvm;
} CSFV, FAR * LPCSFV;

// Tell the FolderView to rearrange.  The lParam will be passed to
// IShellFolder::CompareIDs
#define SFVM_REARRANGE		0x00000001
#define ShellFolderView_ReArrange(_hwnd, _lparam) \
	(BOOL)SHShellFolderView_Message(_hwnd, SFVM_REARRANGE, _lparam)

// Get the last sorting parameter given to FolderView
#define SFVM_GETARRANGEPARAM	0x00000002
#define ShellFolderView_GetArrangeParam(_hwnd) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETARRANGEPARAM, 0L)

// Add an OBJECT into the view (May need to add insert also)
#define SFVM_ADDOBJECT         0x00000003
#define ShellFolderView_AddObject(_hwnd, _pidl) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_ADDOBJECT, (LPARAM)_pidl)

// Gets the count of objects in the view
#define SFVM_GETOBJECTCOUNT         0x00000004
#define ShellFolderView_GetObjectCount(_hwnd) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECTCOUNT, (LPARAM)0)

// Returns a pointer to the Idlist associated with the specified index
// Returns NULL if at end of list.
#define SFVM_GETOBJECT         0x00000005
#define ShellFolderView_GetObject(_hwnd, _iObject) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECT, _iObject)

// Remove an OBJECT into the view (This works by pidl, may need index also);
#define SFVM_REMOVEOBJECT         0x00000006
#define ShellFolderView_RemoveObject(_hwnd, _pidl) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REMOVEOBJECT, (LPARAM)_pidl)

// updates an object by passing in pointer to two PIDLS, the first
// is the old pidl, the second one is the one with update information.
#define SFVM_UPDATEOBJECT         0x00000007
#define ShellFolderView_UpdateObject(_hwnd, _ppidl) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_UPDATEOBJECT, (LPARAM)_ppidl)

// Sets the redraw mode for the window that is displaying the information
#define SFVM_SETREDRAW           0x00000008
#define ShellFolderView_SetRedraw(_hwnd, fRedraw) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_SETREDRAW, (LPARAM)fRedraw)

// Returns an array of the selected IDS to the caller.
//     lparam is a pointer to receive the idlists into
//     return value is the count of items in the array.
#define SFVM_GETSELECTEDOBJECTS 0x00000009
#define ShellFolderView_GetSelectedObjects(_hwnd, ppidl) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDOBJECTS, (LPARAM)ppidl)

// Checks if the current drop is on the view window
//     lparam is unused
//     return value is TRUE if the current drop is upon the background of the
//         view window, FALSE otherwise
#define SFVM_ISDROPONSOURCE	0x0000000a
#define ShellFolderView_IsDropOnSource(_hwnd, _pdtgt) \
	(BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISDROPONSOURCE, (LPARAM)_pdtgt)

// Moves the selected icons in the listview
//     lparam is a pointer to a drop target
//     return value is unused
#define SFVM_MOVEICONS		0x0000000b
#define ShellFolderView_MoveIcons(_hwnd, _pdt) \
	(void)SHShellFolderView_Message(_hwnd, SFVM_MOVEICONS, (LPARAM)(LPDROPTARGET)_pdt)

// Gets the start point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDRAGPOINT	0x0000000c
#define ShellFolderView_GetDragPoint(_hwnd, _ppt) \
	(BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETDRAGPOINT, (LPARAM)(LPPOINT)_ppt)

// Gets the end point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDROPPOINT	0x0000000d
#define ShellFolderView_GetDropPoint(_hwnd, _ppt) \
	SHShellFolderView_Message(_hwnd, SFVM_GETDROPPOINT, (LPARAM)(LPPOINT)_ppt)

#define ShellFolderView_GetAnchorPoint(_hwnd, _fStart, _ppt) \
	(BOOL)((_fStart) ? ShellFolderView_GetDragPoint(_hwnd, _ppt) : ShellFolderView_GetDropPoint(_hwnd, _ppt))

typedef struct _SFV_SETITEMPOS
{
	LPCITEMIDLIST pidl;
	POINT pt;
} SFV_SETITEMPOS, FAR *LPSFV_SETITEMPOS;

// Sets the position of an item in the viewer
//     lparam is a pointer to a SVF_SETITEMPOS
//     return value is unused
#define SFVM_SETITEMPOS		0x0000000e
#define ShellFolderView_SetItemPos(_hwnd, _pidl, _x, _y) \
{	SFV_SETITEMPOS _sip = {_pidl, {_x, _y}}; \
	SHShellFolderView_Message(_hwnd, SFVM_SETITEMPOS, (LPARAM)(LPSFV_SETITEMPOS)&_sip);}

// Determines if a given drop target interface is the one being used for
// the background of the ShellFolderView (as opposed to an object in the
// view)
//     lparam is a pointer to a drop target interface
//     return value is TRUE if it is the background drop target, FALSE otherwise
#define SFVM_ISBKDROPTARGET	0x0000000f
#define ShellFolderView_IsBkDropTarget(_hwnd, _pdptgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISBKDROPTARGET, (LPARAM)(LPDROPTARGET)_pdptgt)

//  Notifies a ShellView when one of its objects get put on the clipboard
//  as a result of a menu command.
//
//  called by defcm.c when it does a copy/cut
//
//     lparam is the dwEffect (DROPEFFECT_MOVE, DROPEFFECT_COPY)
//     return value is void.
#define SFVM_SETCLIPBOARD       0x00000010
#define ShellFolderView_SetClipboard(_hwnd, _dwEffect) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETCLIPBOARD, (LPARAM)(DWORD)(_dwEffect))


// sets auto arrange
#define SFVM_AUTOARRANGE        0x00000011
#define ShellFolderView_AutoArrange(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_AUTOARRANGE, 0)

// sets snap to grid
#define SFVM_ARRANGEGRID        0x00000012
#define ShellFolderView_ArrangeGrid(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_ARRANGEGRID, 0)

#define SFVM_GETAUTOARRANGE     0x00000013
#define ShellFolderView_GetAutoArrange(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETAUTOARRANGE, 0)

#define SFVM_GETSELECTEDCOUNT     0x00000014
#define ShellFolderView_GetSelectedCount(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDCOUNT, 0)

typedef struct {
    int cxSmall;
    int cySmall;
    int cxLarge;
    int cyLarge;
} ITEMSPACING, *LPITEMSPACING;

#define SFVM_GETITEMSPACING     0x00000015
#define ShellFolderView_GetItemSpacing(_hwnd, lpis) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETITEMSPACING, (LPARAM)lpis)

// Causes an object to be repainted
#define SFVM_REFRESHOBJECT      0x00000016
#define ShellFolderView_RefreshObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REFRESHOBJECT, (LPARAM)_ppidl)


#define SFVM_SETPOINTS           0x00000017
#define ShellFolderView_SetPoints(_hwnd, _pdtobj) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETPOINTS, (LPARAM)_pdtobj)

// SVM_SELECTANDPOSITIONITEM lParam
typedef struct
{
	LPCITEMIDLIST pidl;	// relative pidl to the view
	UINT  uSelectFlags;	// select flags
        BOOL fMove; // if true, we should also move it to point pt
        POINT pt;
} SFM_SAP;

// shell view messages
#define SVM_SELECTITEM       		(WM_USER + 1)
#define SVM_MOVESELECTEDITEMS           (WM_USER + 2)
#define SVM_GETANCHORPOINT              (WM_USER + 3)
#define SVM_GETITEMPOSITION             (WM_USER + 4)
#define SVM_SELECTANDPOSITIONITEM       (WM_USER + 5)

// Heap tracking stuff.
#ifdef MEMMON
#ifndef INC_MEMMON
#define INC_MEMMON
#define LocalAlloc	SHLocalAlloc
#define LocalFree	SHLocalFree
#define LocalReAlloc	SHLocalReAlloc

WINSHELLAPI HLOCAL WINAPI SHLocalAlloc(UINT uFlags, UINT cb);
WINSHELLAPI HLOCAL WINAPI SHLocalReAlloc(HLOCAL hOld, UINT cbNew, UINT uFlags);
WINSHELLAPI HLOCAL WINAPI SHLocalFree(HLOCAL h);
#endif
#endif

//===========================================================================
// CDefShellFolder members (for easy subclassing)
//===========================================================================

// Single instance members
STDMETHODIMP_(ULONG) CSIShellFolder_AddRef(LPSHELLFOLDER psf) ;
STDMETHODIMP_(ULONG) CSIShellFolder_Release(LPSHELLFOLDER psf);

// Default implementation (no dependencies to the instance data)
STDMETHODIMP CDefShellFolder_QueryInterface(LPSHELLFOLDER psf, REFIID riid, LPVOID FAR* ppvObj);
STDMETHODIMP CDefShellFolder_BindToStorage(LPSHELLFOLDER psf, LPCITEMIDLIST pidl, LPBC pbc,
    			 REFIID riid, LPVOID FAR* ppvOut);
STDMETHODIMP CDefShellFolder_BindToObject(LPSHELLFOLDER psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, LPVOID FAR* ppvOut);
STDMETHODIMP CDefShellFolder_GetAttributesOf(LPSHELLFOLDER psf, UINT cidl, LPCITEMIDLIST FAR* apidl, ULONG FAR* rgfOut);
STDMETHODIMP CDefShellFolder_SetNameOf(LPSHELLFOLDER psf, HWND hwndOwner,
	LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD dwReserved, LPITEMIDLIST FAR* ppidlOut);

// File Search APIS
WINSHELLAPI LPCONTEXTMENU WINAPI SHFind_InitMenuPopup(HMENU hmenu, HWND hwndOwner, UINT idCmdFirst, UINT idCmdLast);

WINSHELLAPI void WINAPI Control_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);
// to add 16 bit pages to 32bit things.  hGlobal can be NULL
WINSHELLAPI UINT WINAPI SHAddPages16(HGLOBAL hGlobal, LPCSTR pszDllEntry, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

WINSHELLAPI HRESULT WINAPI SHCreateShellFolderViewEx(LPCSFV pcsfv, LPSHELLVIEW FAR* ppsv);

//===========================================================================
// Defview related API and interface
//
//  Notes: At this point, we have no plan to publish this mechanism.
//===========================================================================

typedef struct _SHELLDETAILS
{
	int	fmt;		// LVCFMT_* value (header only)
	int	cxChar;		// Number of "average" characters (header only)
	STRRET	str;		// String information
} SHELLDETAILS, FAR *LPSHELLDETAILS;

#undef  INTERFACE
#define INTERFACE   IShellDetails

DECLARE_INTERFACE_(IShellDetails, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellDetails methods ***
    STDMETHOD(GetDetailsOf)(THIS_ LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails) PURE;
    STDMETHOD(ColumnClick)(THIS_ UINT iColumn) PURE;
};

//
// Private QueryContextMenuFlag passed from DefView
//
#define CMF_DVFILE	 0x00010000	// "File" pulldown

//
// Functions to help the cabinets sync to each other
//  uOptions parameter to SHWaitForFileOpen
//
#define WFFO_WAITTIME 10000L

#define WFFO_ADD        0x0001
#define WFFO_REMOVE     0x0002
#define WFFO_WAIT       0x0004


// Common strings
#define STR_DESKTOPCLASS	"Progman"

//===========================================================================
// Helper functions for pidl allocation using the task allocator.
//
WINSHELLAPI HRESULT WINAPI SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut);
WINSHELLAPI HRESULT WINAPI SHILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut);
#define SHILFree(pidl)	SHFree(pidl)

WINSHELLAPI HRESULT WINAPI SHDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);


#include <fsmenu.h>

//===========================================================================

//----------------------------------------------------------------------------
#define IsLFNDriveORD		119
WINSHELLAPI BOOL WINAPI IsLFNDrive(LPCSTR pszPath);
WINSHELLAPI int WINAPI SHOutOfMemoryMessageBox(HWND hwndOwner, LPSTR pszTitle, UINT fuStyle);
WINSHELLAPI BOOL WINAPI SHWinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

WINSHELLAPI BOOL WINAPI RLBuildListOfPaths(void);

#define SHValidateUNCORD        173

#define VALIDATEUNC_NOUI        0x0002      // dont bring up stinking UI!
#define VALIDATEUNC_CONNECT     0x0001      // connect a drive letter
#define VALIDATEUNC_PRINT       0x0004      // validate as print share instead of disk share
#define VALIDATEUNC_VALID       0x0007      // valid flags


WINSHELLAPI BOOL WINAPI SHValidateUNC(HWND hwndOwner, LPSTR pszFile, UINT fConnect);

//----------------------------------------------------------------------------
#define OleStrToStrNORD			        78
#define SHCloneSpecialIDListORD		      	89
#define SHDllGetClassObjectORD		       128
#define SHLogILFromFSILORD			95
#define SHMapPIDLToSystemImageListIndexORD	77
#define SHShellFolderView_MessageORD		73
#define Shell_GetImageListsORD			71
#define SHGetSpecialFolderPathORD	       175
#define StrToOleStrNORD				79

#define ILCloneORD				18
#define ILCloneFirstORD				19
#define ILCombineORD				25
#define ILCreateFromPathORD			157
#define ILFindChildORD				24
#define ILFreeORD				155
#define ILGetNextORD				153
#define ILGetSizeORD				152
#define ILIsEqualORD				21
#define ILRemoveLastIDORD			17
#define PathAddBackslashORD			32
#define PathCombineORD				37
#define PathIsExeORD				43
#define PathMatchSpecORD			46
#define SHGetSetSettingsORD			68
#define SHILCreateFromPathORD			28

#define SHFreeORD				195
#define MemMon_FreeORD				123

//
// Storage name of a scrap/bookmark item
//
#define WSTR_SCRAPITEM L"\003ITEM000"

//
//  PifMgr Thunked APIs (in SHELL.DLL)
//
extern int  WINAPI PifMgr_OpenProperties(LPCSTR lpszApp, LPCSTR lpszPIF, int hInf, int flOpt);
extern int  WINAPI PifMgr_GetProperties(int hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, int flOpt);
extern int  WINAPI PifMgr_SetProperties(int hProps, LPCSTR lpszGroup, const VOID FAR *lpProps, int cbProps, int flOpt);
extern int  WINAPI PifMgr_CloseProperties(int hProps, int flOpt);

//
// exported from SHSCRAP.DLL
//
#define SCRAP_CREATEFROMDATAOBJECT "Scrap_CreateFromDataObject"
typedef HRESULT (WINAPI FAR * LPFNSCRAPCREATEFROMDATAOBJECT)(LPCSTR pszPath, LPDATAOBJECT pDataObj, BOOL fLink, LPSTR pszNewFile);
extern HRESULT WINAPI Scrap_CreateFromDataObject(LPCSTR pszPath, LPDATAOBJECT pDataObj, BOOL fLink, LPSTR pszNewFile);

WINSHELLAPI void WINAPI SHSetInstanceExplorer(IUnknown *punk);

// Always use TerminateThreadEx.
BOOL APIENTRY TerminateThreadEx(HANDLE hThread, DWORD dwExitCode, BOOL bCleanupFlag);
#define TerminateThread(hThread, dwExitCode) TerminateThreadEx(hThread, dwExitCode, TRUE)

//===========================================================================
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif // _SHELLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\temp.h ===
#ifndef _TEMP_H
#define _TEMP_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define WAVE_FORMAT_LH_CELP	0x0070
#define WAVE_FORMAT_LH_SB8	   0x0071
#define WAVE_FORMAT_LH_SB12	0x0072
#define WAVE_FORMAT_LH_SB16	0x0073

#define ACMDM_LH_DATA_PACKAGING		(ACMDM_USER + 1)


// lParam1 when sending ACMDM_LH_DATA_PACKAGING
enum
{
	LH_PACKET_DATA_NULL,	// uninitialized
	LH_PACKET_DATA_FRAMED,	// always aligned on frame boundary
	LH_PACKET_DATA_ANYTHING // do not assume alignment
};

#include <poppack.h> /* End byte packing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\tsecctrl.h ===
#ifndef _TSECCTRL_
#define _TSECCTRL_

// Command codes
#define LOADFTAPPLET                        100
#define UNLOADFTAPPLET                      101

// Sets credentials directly in the transport
#define TPRTCTRL_SETX509CREDENTIALS            111
#define TPRTCTRL_GETX509CREDENTIALS            112

// Prototype typedef
typedef DWORD (WINAPI *PFN_TPRTSECCTRL)(DWORD, DWORD, DWORD);

// Loadlibrary constant
#define SZ_TPRTSECCTRL TEXT("TprtSecCtrl")

// Static prototype
extern DWORD WINAPI TprtSecCtrl (DWORD dwCode, DWORD dwParam1, DWORD dwParam2);

#endif // _TSECCTRL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\ullaunch.h ===
#ifndef _ULLAUNCH_H_
#define _ULLAUNCH_H_

#include <windows.h>
#include "ulserror.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif


typedef struct tagUlsApp
{
    GUID    guid;           // application guid
    long    port;           // port number

    PTSTR   pszPathName;    // full path of the app
    PTSTR   pszCmdTemplate; // command-line template, could be NULL
    PTSTR   pszCmdLine;     // expanded command line, could be NULL
    PTSTR   pszWorkingDir;  // working directory, could be NULL
    long    idxDefIcon;     // default icon index
    PTSTR   pszDescription; // description of this app
    HICON   hIconAppDef;    // default icon
    BOOL    fPostMsg;       // launch existing app by posting a msg
}
    ULSAPP;


typedef struct tagUlsResult
{
    DWORD   dwIPAddr;
    long    idxApp;         // which app is selected thru ui
    long    nApps;
// TO BE TURNED ON    ULSAPP  App[1];
    ULSAPP  App[4];
}
    ULSRES;


typedef struct tagUlsToken
{
    TCHAR   cPrior;
    TCHAR   cPost;
    PTSTR   pszToken;
    WORD    cbTotal;
}
    ULSTOKEN;

enum
{
    TOKEN_IULS_BEGIN,
    TOKEN_IULS_END,
    TOKEN_RES,
    NumOf_Tokens
};


HRESULT WINAPI UlxParseUlsFile ( PTSTR pszUlsFile, ULSRES **ppUlsResult );
typedef HRESULT (WINAPI *PFN_UlxParseUlsFile) ( PTSTR, ULSRES ** );
#define ULXPARSEULSFILE     TEXT ("UlxParseUlsFile")

HRESULT WINAPI UlxParseUlsBuffer ( PTSTR pszBuf, DWORD cbBufSize, ULSRES **ppUlsResult );
typedef HRESULT (WINAPI *PFN_UlxParseUlsBuffer) ( PTSTR, DWORD, ULSRES ** );
#define ULXPARSEULSBUFFER   TEXT ("UlxParseUlsBuffer")

void WINAPI UlxFreeUlsResult ( ULSRES *pUlsResult );
typedef HRESULT (WINAPI *PFN_UlxFreeUlsResult) ( ULSRES * );
#define ULXFREEULSRESULT    TEXT ("UlxFreeUlsResult")

HRESULT WINAPI UlxFindAppInfo ( ULSRES *pUlsResult );
typedef HRESULT (WINAPI *PFN_UlxFindAppInfo) ( ULSRES * );
#define ULXFINDAPPINFO      TEXT ("UlxFindAppInfo")

HRESULT WINAPI UlxLaunchApp ( HWND hWnd, ULSRES *pUlsResult );
typedef HRESULT (WINAPI *PFN_UlxLaunchApp) ( HWND, ULSRES * );
#define ULXLAUNCHAPP        TEXT ("UlxLaunchApp")


#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif // _LAUNCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\ulsreg.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULSREG.H
//
// Brief Description:  This module contains definitions for all registry
//                     folders and keys.
//
// Author:  Lon-Chan Chu (LonChanC)
// Created: 09-Apr-1996
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------


#ifndef _ULSREG_H_
#define _ULSREG_H_

#include <pshpack1.h> /* Assume 1 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

// registry used in UL Client and Launcher

#define ULS_REGISTRY            TEXT ("Software\\Microsoft\\User Location Service")

    #define ULS_REGFLD_APP_GUID     TEXT ("Application GUID")
        #define ULS_REGKEY_APP_PATH     TEXT ("Path Name")
        #define ULS_REGKEY_CMD_LINE     TEXT ("Command Line Template")
        #define ULS_REGKEY_WORK_DIR     TEXT ("Working Directory")
        #define ULS_REGKEY_DEF_ICON     TEXT ("Default Icon")
        #define ULS_REGKEY_POST_MSG     TEXT ("Post Message")
        #define ULS_REGKEY_APP_TEXT     TEXT ("Description")

    #define ULS_REGFLD_CLIENT       TEXT ("Client")
        #define ULS_REGKEY_FIRST_NAME    TEXT ("First Name")
        #define ULS_REGKEY_LAST_NAME    TEXT ("Last Name")
        #define ULS_REGKEY_EMAIL_NAME   TEXT ("Email Name")
        #define ULS_REGKEY_LOCATION		TEXT ("Location")
        #define ULS_REGKEY_PHONENUM	    TEXT ("Phonenum")
        #define ULS_REGKEY_COMMENTS	    TEXT ("Comments")
        #define ULS_REGKEY_SERVER_NAME  TEXT ("Server Name")
        #define ULS_REGKEY_DONT_PUBLISH TEXT ("Don't Publish")
        #define ULS_REGKEY_USER_NAME	TEXT ("User Name")
		#define ULS_REGKEY_RESOLVE_NAME TEXT ("Resolve Name")
		#define ULS_REGKEY_CLIENT_ID	TEXT ("Client ID")


#define MAIL_REGISTRY            TEXT ("Software\\Microsoft\\Internet Mail and News")

    #define MAIL_REGFLD_MAIL      TEXT ("Mail")
    
        #define MAIL_REGKEY_SENDER_EMAIL    TEXT ("Sender EMail")
        #define MAIL_REGKEY_SENDER_NAME	  	TEXT ("Sender Name")


#define WINDOWS_REGISTRY		TEXT("SOFTWARE\\Microsoft\\Windows")
	#define WIN_REGFLD_CURVERSION	TEXT("CurrentVersion")			
		#define WIN_REGKEY_REGOWNER			TEXT("RegisteredOwner")
	
#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif // _ULSREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\ulstags.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULSTAGS.H
//
// Brief Description:  This module contains declarations of property
//					   tags for the User Location Service.
//
// Author:  Kent Settle (kentse)
// Created: 16-May-1996
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------


#ifndef ULSTAGS_H
#define ULSTAGS_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifndef WABTAGS_H
#include "wabtags.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////
// WAB related

#define PR_FIRST_NAME           PR_GIVEN_NAME
#define PR_FIRST_NAME_W         PR_GIVEN_NAME_W
#define PR_FIRST_NAME_A         PR_GIVEN_NAME_A

#define PR_LAST_NAME            PR_SURNAME
#define PR_LAST_NAME_W          PR_SURNAME_W
#define PR_LAST_NAME_A          PR_SURNAME_A

#define PR_EMAIL_NAME	        PR_EMAIL_ADDRESS
#define PR_EMAIL_NAME_A         PR_EMAIL_ADDRESS_A
#define PR_EMAIL_NAME_W         PR_EMAIL_ADDRESS_W

#define PR_CITY                 PR_LOCATION
#define PR_CITY_W               PR_LOCATION_W
#define PR_CITY_A               PR_LOCATION_A

// defined in wabtags.h
// #define PR_COUNTRY           PROP_TAG( PT_TSTRING,   0x3A26)
// #define PR_COUNTRY_W         PROP_TAG( PT_UNICODE,   0x3A26)
// #define PR_COUNTRY_A         PROP_TAG( PT_STRING8,   0x3A26)

#define PR_COMMENT_INTEREST     PR_COMMENT
#define PR_COMMENT_INTEREST_W   PR_COMMENT_W
#define PR_COMMENT_INTEREST_A   PR_COMMENT_A

/////////////////////////////////////
// ULS specifics

#define PR_IP_ADDRESS		    PROP_TAG(PT_LONG,		0x3A65)
#define PR_ULS_SERVERS		    PROP_TAG(PT_MV_TSTRING, 0x3A66)
#define PR_WP_SERVERS		    PROP_TAG(PT_MV_TSTRING, 0x3A67)
#define PR_AGE				    PROP_TAG(PT_LONG,		0x3A68)
#define PR_PORT_NUMBER		    PROP_TAG(PT_LONG,		0x3A69)
#define PR_APPLICATION_GUID		PROP_TAG(PT_CLSID,		0x3A6A)
#define PR_APPLICATION_NAME	    PROP_TAG(PT_TSTRING,	0x3A6B)
#define PR_APPLICATION_NAME_A   PROP_TAG(PT_STRING,	    0x3A6B)
#define PR_APPLICATION_NAME_W   PROP_TAG(PT_UNICODE,	0x3A6B)
#define PR_ULS_MODE		        PROP_TAG(PT_LONG,	    0x3A6C)
// #define PR_MIME_TYPE            PROP_TAG(PT_CLSID,	    0x3A6D)
#define PR_MIME_TYPE            PROP_TAG(PT_TSTRING,	0x3A6D)
#define PR_MIME_TYPE_A          PROP_TAG(PT_STRING,	    0x3A6D)
#define PR_MIME_TYPE_W          PROP_TAG(PT_UNICODE,	0x3A6D)
#define PR_PROTOCOL_GUID		PROP_TAG(PT_CLSID,		0x3A6E)


#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif // ULSTAGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\stock.h ===
/*
 * stock.h - Stock header file.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _STOCK_H_
#define _STOCK_H_

/* Constants
 ************/

#define ASTERISK                 '*'
#define BACKSLASH                '/'
#define COLON                    ':'
#define COMMA                    ','
#define EQUAL                    '='
#define PERIOD                   '.'
#define POUND                    '#'
#define QMARK                    '?'
#define QUOTE                    '\''
#define QUOTES                   '"'
#define SLASH                    '\\'
#define SPACE                    ' '
#define TAB                      '\t'

/* linkage */

#ifdef __cplusplus
#define INLINE                   inline
#else
#define INLINE                   __inline
#endif


/* Win32 HRESULTs */

#define E_FILE_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
                                        GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
                                        FILE_SHARE_WRITE)

#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                        FILE_ATTRIBUTE_HIDDEN |\
                                        FILE_ATTRIBUTE_SYSTEM |\
                                        FILE_ATTRIBUTE_DIRECTORY |\
                                        FILE_ATTRIBUTE_ARCHIVE |\
                                        FILE_ATTRIBUTE_NORMAL |\
                                        FILE_ATTRIBUTE_TEMPORARY |\
                                        FILE_ATTRIBUTE_ATOMIC_WRITE |\
                                        FILE_ATTRIBUTE_XACTION_WRITE)

#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
                                        ALL_FILE_FLAGS)


/* Macros
 *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

/* character manipulation */

#define IS_SLASH(ch)                      ((ch) == SLASH || (ch) == BACKSLASH)

/* bit flag manipulation */

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))

/* ChrisPi: DCL also defines this - override their definition */
#ifdef CLEAR_FLAG
#undef CLEAR_FLAG
#endif /* CLEAR_FLAG */

#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

/* array element count */

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))
#define CCHMAX(rg)                        ARRAY_ELEMENTS(rg)

/* clearing bytes */
#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))
#define InitStruct(lpv)      {ClearStruct(lpv); (* (LPDWORD)(lpv)) = sizeof(*(lpv));}


/* string safety */

#define CHECK_STRING(psz)                 ((psz) ? (psz) : "(null)")

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)                 (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))

/* stuff a point value packed in an LPARAM into a POINT */

#define LPARAM_TO_POINT(lparam, pt)       ((pt).x = (short)LOWORD(lparam), \
                                           (pt).y = (short)HIWORD(lparam))


/* Types
 ********/

typedef const void *PCVOID;
typedef const INT CINT;
typedef const INT *PCINT;
typedef const UINT CUINT;
typedef const UINT *PCUINT;
typedef const LONG CULONG;
typedef const LONG *PCULONG;
typedef const BYTE CBYTE;
typedef const BYTE *PCBYTE;
typedef const WORD CWORD;
typedef const WORD *PCWORD;
typedef const DWORD CDWORD;
typedef const DWORD *PCDWORD;
typedef const CRITICAL_SECTION CCRITICAL_SECTION;
typedef const CRITICAL_SECTION *PCCRITICAL_SECTION;
typedef const FILETIME CFILETIME;
typedef const FILETIME *PCFILETIME;
typedef const BITMAPINFO CBITMAPINFO;
typedef const BITMAPINFO *PCBITMAPINFO;
typedef const POINT CPOINT;
typedef const POINT *PCPOINT;
typedef const POINTL CPOINTL;
typedef const POINTL *PCPOINTL;
typedef const SECURITY_ATTRIBUTES CSECURITY_ATTRIBUTES;
typedef const SECURITY_ATTRIBUTES *PCSECURITY_ATTRIBUTES;
typedef const WIN32_FIND_DATA CWIN32_FIND_DATA;
typedef const WIN32_FIND_DATA *PCWIN32_FIND_DATA;

DECLARE_STANDARD_TYPES(HGLOBAL);
DECLARE_STANDARD_TYPES(HICON);
DECLARE_STANDARD_TYPES(HMENU);
DECLARE_STANDARD_TYPES(HWND);
DECLARE_STANDARD_TYPES(NMHDR);


#ifndef _COMPARISONRESULT_DEFINED_

/* comparison result */

typedef enum _comparisonresult
{
   CR_FIRST_SMALLER = -1,
   CR_EQUAL = 0,
   CR_FIRST_LARGER = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif

#endif /* _STOCK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\strutil.h ===
#ifndef _STRUTIL_H_
#define _STRUTIL_H_

#include <nmutil.h>
#include <stock.h>
#include <wincrypt.h>


INLINE BOOL
IsEmptyStringA(LPCSTR pcsz)
{
	return (NULL == pcsz) || ('\0' == *pcsz);
}

INLINE BOOL
IsEmptyStringW(LPCWSTR pcwsz)
{
	return (NULL == pcwsz) || (L'\0' == *pcwsz);
}

#if defined(UNICODE)
#define IsEmptyString IsEmptyStringW
#else // defined(UNICODE)
#define IsEmptyString IsEmptyStringA
#endif // defined(UNICODE)


#define IS_EMPTY_STRING(s)	  (IsEmptyString(s))
#define FEmptySz(psz)         (IsEmptyString(psz))

#define SetEmptySz(psz)       (*(psz) = _T('\0'))

	
// global helper functions for Unicode support in a DBCS environment

int     NMINTERNAL UnicodeCompare(PCWSTR s, PCWSTR t);
PWSTR   NMINTERNAL NewUnicodeString(PCWSTR wszText);
BOOL    NMINTERNAL UnicodeIsNumber(PCWSTR wszText);
PWSTR   NMINTERNAL DBCSToUnicode(UINT uCodePage, PCSTR szText);
PSTR    NMINTERNAL UnicodeToDBCS(UINT uCodePage, PCWSTR wszText);

INLINE PWSTR AnsiToUnicode(PCSTR szText)
{
	return DBCSToUnicode(CP_ACP, szText);
}

INLINE PWSTR OEMToUnicode(PCSTR szText)
{
	return DBCSToUnicode(CP_OEMCP, szText);
}

INLINE PSTR UnicodeToAnsi(PCWSTR wszText)
{
	return UnicodeToDBCS(CP_ACP, wszText);
}

INLINE PSTR UnicodeToOEM(PCWSTR wszText)
{
	return UnicodeToDBCS(CP_OEMCP, wszText);
}


// Functions to convert between Quad Words (expressed as ULARGE_INTEGERs)
// and ANSI strings.
BOOL NMINTERNAL HexStringToQWordA(LPCSTR pcszString, ULARGE_INTEGER* pqw);
int NMINTERNAL QWordToHexStringA(ULARGE_INTEGER qw, LPSTR pszString);

// Function to convert from a hex string to a DWORD.
DWORD   NMINTERNAL DwFromHex(LPCTSTR pchHex);

// CCHMAX_HEX_ULARGE_INTEGER - defines the minimum string buffer size needed
// for the second parameter of QWordToHexStringA().
#define CCHMAX_HEX_ULARGE_INTEGER 17 // 16 characters + n.t.

#define CCH_HEX_DWORD		8
#define CCH_HEX_QWORD		16
#define BITS_PER_HEX_CHAR	4


// Other Random string functions
VOID    NMINTERNAL GuidToSz(GUID * pguid, LPTSTR lpchDest);
/* sizeof(GUID)*2 + 7 (includes NULL terminator) characters (see GuidToSz) */
#define LENGTH_SZGUID_FORMATTED 39


int WINAPI RtStrToInt(LPCTSTR lpSrc);       // atoi()
#define ATOI					RtStrToInt

#ifdef __cplusplus
extern "C"{
#endif
UINT    NMINTERNAL DecimalStringToUINT(LPCTSTR pcszString);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"{
#endif
LPCTSTR NMINTERNAL _StrChr(LPCTSTR psz, TCHAR c);
int     NMINTERNAL _StrCmpN(LPCTSTR psz1, LPCTSTR psz2, UINT maxChars);
#ifdef __cplusplus
}
#endif
LPCTSTR NMINTERNAL _StrStr(LPCTSTR pcsz1, LPCTSTR pcsz2);
LPCWSTR NMINTERNAL _StrStrW(LPCWSTR pcsz1, LPCWSTR pcsz2);

LPSTR	NMINTERNAL _StrPbrkA(LPCSTR pcszString, LPCSTR pcszSearch);
LPWSTR	NMINTERNAL _StrPbrkW(LPCWSTR pcszString, LPCWSTR pcszSearch);

// To be used instead of lstrcmpi when comparing with a constant string
// using a case/locale insensitive comparison (Prefast warning)
#ifdef lstrcmpi
#undef lstrcmpi
#endif
#define lstrcmpi(s1, s2)    (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, (s1), -1, (s2), -1) - CSTR_EQUAL) 

#if defined(UNICODE)
#define _StrPbrk _StrPbrkW
#else // defined(UNICODE)
#define _StrPbrk _StrPbrkA
#endif // defined(UNICODE)

LPTSTR  NMINTERNAL SzFindLastCh(LPTSTR lpsz, TCHAR ch);
UINT    NMINTERNAL TrimSz(PTCHAR psz);

// Local LStrLenW function is unnecessary, since Windows 95 supports
// lstrlenW natively
#define LStrLenW lstrlenW

// Map LStrCpyW to its Win32 equivalent for Unicode builds
#if defined UNICODE
#define LStrCpyW lstrcpyW
#define LStrCpyNW lstrcpyn
#else // defined UNICODE
LPWSTR  NMINTERNAL LStrCpyW(LPWSTR pszDest, LPWSTR pszSrc);
LPWSTR  NMINTERNAL LStrCpyNW(LPWSTR pszDest, LPCWSTR pszSrc, INT iMaxLength);
#endif // defined UNICODE

LPWSTR NMINTERNAL _StrLwrW(LPWSTR pwszSrc);

#ifdef __cplusplus
class CHash
{
public:
	CHash();
	~CHash();
	DWORD GetHashedData(PBYTE pbData, DWORD cbData, void ** ppvHashedData);

private:
	HCRYPTPROV      m_hProv;
	HCRYPTHASH      m_hHash;
	PBYTE			m_pbHashedData;
	DWORD			m_cbHashedData;
	BOOL			m_fReady;
};
#endif
	
DWORD NMINTERNAL HashPasswd(PBYTE pbPasswd, DWORD cbPasswd, void **ppvData);

#endif // ndef STRUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\utf8str.h ===
#ifndef _UTF8STR_H_
#define _UTF8STR_H_

class CUTF8String
{
public:
	CUTF8String(LPCWSTR pcwszUnicode) :
		m_pwszUnicode	((LPWSTR) pcwszUnicode),
		m_pszUTF8		(NULL),
		m_eAlloc		(ALLOC_NONE),
		m_hr			(S_OK) { };
	CUTF8String(LPCSTR pcszUTF8) :
		m_pszUTF8		((LPSTR) pcszUTF8),
		m_pwszUnicode	(NULL),
		m_eAlloc		(ALLOC_NONE),
		m_hr			(S_OK) { };
	~CUTF8String();

	VOID AssignString(LPCSTR pcszUTF8) {
									delete m_pwszUnicode;
									m_pwszUnicode = NULL;
									m_eAlloc = ALLOC_NONE;
									m_hr = S_OK;
									m_pszUTF8 = (LPSTR) pcszUTF8; };

	VOID AssignString(LPCWSTR pcwszUnicode) {
									delete m_pszUTF8;
									m_pszUTF8 = NULL;
									m_eAlloc = ALLOC_NONE;
									m_hr = S_OK;
									m_pwszUnicode = (LPWSTR) pcwszUnicode; };

	operator LPWSTR();
	operator LPSTR();

	HRESULT GetError() { return m_hr; };
protected:
	VOID EncodeUTF8();
	VOID DecodeUTF8();

	HRESULT	m_hr;
	LPWSTR	m_pwszUnicode;
	LPSTR	m_pszUTF8;
	enum
	{
		ALLOC_NONE,
		ALLOC_UNICODE,
		ALLOC_UTF8,
	} m_eAlloc;
};

#endif // ! _UTF8STR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\valid.h ===
/*
 * valid.h - Validation functions description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _VALID_H_
#define _VALID_H_

/* Prototypes
 *************/

/* valid.c */

extern BOOL IsValidHWND(HWND);

#ifdef DEBUG

extern BOOL IsValidFileCreationMode(DWORD);
extern BOOL IsValidHANDLE(HANDLE);
extern BOOL IsValidHEVENT(HANDLE);
extern BOOL IsValidHFILE(HANDLE);
extern BOOL IsValidHGLOBAL(HGLOBAL);
extern BOOL IsValidHMENU(HMENU);
extern BOOL IsValidHICON(HICON);
extern BOOL IsValidHINSTANCE(HINSTANCE);
extern BOOL IsValidHKEY(HKEY);
extern BOOL IsValidHMODULE(HMODULE);
extern BOOL IsValidHPROCESS(HANDLE);
extern BOOL IsValidHTEMPLATEFILE(HANDLE);
extern BOOL IsValidIconIndex(HRESULT, LPCTSTR, UINT, int);
extern BOOL IsValidPCFILETIME(PCFILETIME);
extern BOOL IsValidPCPOINT(PCPOINT);
extern BOOL IsValidPCPOINTL(PCPOINTL);
extern BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES);
extern BOOL IsValidPCWIN32_FIND_DATA(PCWIN32_FIND_DATA);
extern BOOL IsValidPathResult(HRESULT, LPCTSTR, UINT);
extern BOOL IsValidExtension(LPCTSTR);
extern BOOL IsValidRegistryValueType(DWORD);
extern BOOL IsValidShowCmd(int);
extern BOOL IsValidHotkey(WORD);

extern BOOL IsValidPath(LPCTSTR);
#if defined(UNICODE)
extern BOOL IsValidPathA(PCSTR);
#else // defined(UNICODE)
#define IsValidPathA IsValidPath
#endif // defined(UNICODE)

#ifdef _COMPARISONRESULT_DEFINED_

extern BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT);

#endif   /* _COMPARISONRESULT_DEFINED_ */

#endif   /* DEBUG */

#endif /* _VALID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\wbguid.h ===
//****************************************************************************
//
//  File:       wbguid.h
//  Content:    This file contains the class GUID for Microsoft T126 WB.
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

// {340f4a60-7067-11d0-a041-444553540000}
//
const GUID CLSID_NM2Wb = { 0x340f4a60, 0x7067, 0x11d0, { 0xa0, 0x41, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

#if defined(WIN32) && !defined(SKIP_WINVER)
#include <winver.h>
#endif // defined(WIN32) && !defined(SKIP_WINVER)

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
#ifndef WIN32
#define VERSION                     "4.4.4000"
#endif
#define VER_PRODUCTVERSION_STR      "4.4.4000\0"
#define VER_PRODUCTVERSION           4,4,0,4000
#define VER_PRODUCTVERSION_REGSTR   "4,4,0,4000"
#define VERSIONBUILD_STR                  "4000"
#define VERSIONBUILD                       4000
#define VER_PRODUCTVERSION_DW       (0x04040000 | 4000)
#define VER_PRODUCTVERSION_W        (0x0400)
#define VER_PRODUCTVERSION_DW_REG   04,00,04,00,00,00,FA,00
#define VER_PRODUCTVERSION_DWSTR    L"04040FA0"


/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/


/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)


/* Allow these to be re-defined */

#ifndef VER_FILEOS
#ifdef WIN32
#define VER_FILEOS                  VOS__WINDOWS32
#else // WIN32
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#endif // WIN32
#endif // ! VER_FILEOS

#ifndef VER_COMPANYNAME_STR
#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#endif

#ifndef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR         "Windows\256 NetMeeting\256"
#endif

#ifndef VER_PRODUCTRELEASE_STR
#define VER_PRODUCTRELEASE_STR      "3.01"
#endif

#ifndef VER_LEGALTRADEMARKS_STR
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 , Windows\256 and NetMeeting\256 are registered trademarks of Microsoft Corporation in the U.S. and/or other countries."
#endif

#ifndef VER_COPYRIGHT_STR
#define VER_COPYRIGHT_STR       \
"Copyright \251 Microsoft Corporation 1996-2001"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\vidinout.h ===
/*****************************************************************************/
/* Let's bring the videoStream functions back from the dead, and rename them */
/* in a way consistent with the waveIn and waveOut APIs.                     */
/* This will allow us to create a VideoPacket class VERY similar to the      */
/* AudioPacket class. And we will be talking directly to the capture driver  */
/* which is much more straightforward than the stuff that is available today.*/
/*****************************************************************************/

#ifndef _INC_VIDEOINOUT
#define _INC_VIDEOINOUT

#pragma pack(1)         /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************
                        videoIn and videoOut Constants
****************************************************************************/
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 10 | MAXVIDEODRIVERS | Maximum number of video input capture drivers.
 *
 * @const WAVE_MAPPER | VIDEO_MAPPER | Arbitrary video driver.
 *
 * @const WAVE_FORMAT_PCM | VIDEO_FORMAT_DEFAULT | Default video format.
 *
 * @const 16 | NUM_4BIT_ENTRIES | Number of entries in a 4bit palette.
 *
 * @const 256 | NUM_8BIT_ENTRIES | Number of entries in an 8bit palette.
 *
 ****************************************************************************/
#define MAXVIDEODRIVERS 10
#define VIDEO_MAPPER WAVE_MAPPER
#define VIDEO_FORMAT_DEFAULT WAVE_FORMAT_PCM
#define NUM_4BIT_ENTRIES 16
#define NUM_8BIT_ENTRIES 256

/****************************************************************************
                        videoIn and videoOut Macros
****************************************************************************/
// WIDTHBYTES takes number of bits in a scan line and rounds up to nearest word.
#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)

/****************************************************************************
                       videoIn and videoOut Data Types
****************************************************************************/
DECLARE_HANDLE(HVIDEOIN);                 // generic handle
typedef HVIDEOIN *PHVIDEOIN;
DECLARE_HANDLE(HVIDEOOUT);                 // generic handle
typedef HVIDEOOUT *PHVIDEOOUT;

/****************************************************************************
                         Callback Capture Messages
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg VIM_OPEN | This message is sent to a video capture input callback function when
 *   a video capture input device is opened.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VIM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg MM_VIM_OPEN | This message is sent to a window when a video capture input
 *   device is opened.
 *
 * @parm WORD | wParam | Specifies a handle to the video capture input device
 *   that was opened.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VIM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg VIM_CLOSE | This message is sent to a video capture input callback function when
 *   a video capture input device is closed. The device handle is no longer
 *   valid once this message has been sent.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VIM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg MM_VIM_CLOSE | This message is sent to a window when a video capture input
 *   device is closed. The device handle is no longer valid once this message
 *   has been sent.
 *
 * @parm WORD | wParam | Specifies a handle to the video capture input device
 *   that was closed.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VIM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg VIM_DATA | This message is sent to a video capture input callback function when
 *   video data is present in the input buffer and the buffer is being
 *   returned to the application. The message can be sent either when the
 *   buffer is full, or after the <f videoInReset> function is called.
 *
 * @parm DWORD | dwParam1 | Specifies a far pointer to a <t VIDEOINOUTHDR> structure
 *   identifying the buffer containing the video data.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @comm The returned buffer may not be full. Use the
 *   <e VIDEOINOUTHDR.dwBytesUsed>
 *   field of the <t VIDEOINOUTHDR> structure specified by <p dwParam1> to
 *   determine the number of valid bytes into the returned buffer.
 *
 * @xref <m MM_VIM_DATA>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg MM_VIM_DATA | This message is sent to a window when video data is
 *   present in the input buffer and the buffer is being returned to the
 *   application. The message can be sent either when the buffer is full, or
 *   after the <f videoInReset> function is called.
 *
 * @parm WORD | wParam | Specifies a handle to the video capture input device
 *   that received the video data.
 *
 * @parm LONG | lParam | Specifies a far pointer to a <t VIDEOINOUTHDR> structure
 *   identifying the buffer containing the video data.
 *
 * @rdesc None
 *
 * @comm The returned buffer may not be full. Use the
 *   <e VIDEOINOUTHDR.dwBytesUsed>
 *   field of the <t VIDEOINOUTHDR> structure specified by <p lParam> to
 *   determine the number of valid bytes into the returned buffer.
 *
 * @xref <m VIM_DATA>
 ****************************************************************************/

#define MM_VIM_OPEN		MM_WIM_OPEN
#define MM_VIM_CLOSE	MM_WIM_CLOSE
#define MM_VIM_DATA		MM_WIM_DATA
#define VIM_OPEN		MM_VIM_OPEN
#define VIM_CLOSE		MM_VIM_CLOSE
#define VIM_DATA		MM_VIM_DATA

/****************************************************************************
                         Callback Playback Messages
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg VOM_OPEN | This message is sent to a video output callback function when
 *   a video output device is opened.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VOM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg MM_VOM_OPEN | This message is sent to a window when a video output
 *   device is opened.
 *
 * @parm WORD | wParam | Specifies a handle to the video output device
 *   that was opened.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VOM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg VOM_CLOSE | This message is sent to a video output callback function when
 *   a video output device is closed. The device handle is no longer
 *   valid once this message has been sent.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VOM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg MM_VOM_CLOSE | This message is sent to a window when a video output
 *   device is closed. The device handle is no longer valid once this message
 *   has been sent.
 *
 * @parm WORD | wParam | Specifies a handle to the video output device
 *   that was closed.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VOM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg VOM_DONE | This message is sent to a video output callback function when
 *   the specified output buffer is being returned to
 *   the application. Buffers are returned to the application when
 *   they have been played back, or as the result of a call to <f videoOutReset>.
 *
 * @parm DWORD | dwParam1 | Specifies a far pointer to a <t VIDEOINOUTHDR> structure
 *   identifying the buffer.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VOM_DONE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg MM_VOM_DONE | This message is sent to a window when
 *   the specified output buffer is being returned to
 *   the application. Buffers are returned to the application when
 *   they have been played, or as the result of a call to <f videoOutReset>.
 *
 * @parm WORD | wParam | Specifies a handle to the video output device
 *   that played the buffer.
 *
 * @parm LONG | lParam | Specifies a far pointer to a <t VIDEOINOUTHDR> structure
 *   identifying the buffer.
 *
 * @rdesc None
 *
 * @xref <m VOM_DONE>
 ****************************************************************************/

#define MM_VOM_OPEN		MM_WOM_OPEN
#define MM_VOM_CLOSE	MM_WOM_CLOSE
#define MM_VOM_DONE		MM_WOM_DONE
#define VOM_OPEN		MM_VOM_OPEN
#define VOM_CLOSE		MM_VOM_CLOSE
#define VOM_DONE		MM_VOM_DONE

/****************************************************************************
                       videoIn and videoOut Structures
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPSTRUCTENUM
 *
 * @struct VIDEOFORMATEX | The <t VIDEOFORMATEX> structure defines the format used to
 *   capture video data and settings for the capture device.
 *
 * @field DWORD | dwFormatTag | Specifies the video format type (FOURCC code).
 *
 * @field DWORD | nSamplesPerSec | Specifies the sample rate, in frames per second.
 *
 * @field DWORD | nAvgBytesPerSec | Specifies the average data-transfer rate, in bytes per second.
 *
 * @field DWORD | nMinBytesPerSec | Specifies the minimum data-transfer rate, in bytes per second.
 *
 * @field DWORD | nMaxBytesPerSec | Specifies the maximum data-transfer rate, in bytes per second.
 *
 * @field DWORD | nBlockAlign | Specifies the block alignment, in bytes.
 *
 * @field DWORD | wBitsPerSample | Specifies the bits per sample for the wFormatTag format type.
 *
 * @field DWORD | dwRequestMicroSecPerFrame | Specifies the requested frame rate, in microseconds.
 *
 * @field DWORD | dwPercentDropForError | Specifies the maximum allowable percentage of dropped frames during capture.
 *
 * @field DWORD | dwNumVideoRequested | This specifies the maximum number of video buffers to allocate.
 *
 * @field DWORD | dwSupportTSTradeOff | Specifies the usage of temporal/spatial trade off.
 *
 * @field BOOL | bLive | Specifies if the preview is to be allowed.
 *
 * @field HWND | hWndParent | Specifies handle of the parent window.
 *
 * @field DWORD | dwFormatSize | Specifies the size of the actual video format.
 *
 * @field DWORD | bih.biSize | Specifies the number of bytes required by the spatial information.
 *
 * @field LONG | bih.biWidth | Specifies the width of the bitmap, in pixels.
 *
 * @field LONG | bih.biHeight | Specifies the height of the bitmap, in pixels.
 *
 * @field WORD | bih.biPlanes | Specifies the number of planes for the target device.
 *
 * @field WORD | bih.biBitCount | Specifies the number of bits per pixel.
 *
 * @field DWORD | bih.biCompression | Specifies the type of compression.
 *
 * @field DWORD | bih.biSizeImage | Specifies the size, in bytes, of the image.
 *
 * @field LONG | bih.biXPelsPerMeter | Specifies the horizontal resolution, in pixels per meter, of the target device for the bitmap.
 *
 * @field LONG | bih.biYPelsPerMeter | Specifies the vertical resolution, in pixels per meter, of the target device for the bitmap.
 *
 * @field DWORD | bih.biClrUsed | Specifies the number of color indices in the color table that are actually used by the bitmap.
 *
 * @field DWORD | bih.biClrImportant | Specifies the number of color indices that are considered important for displaying the bitmap.
 *
 * @field DWORD | bmiColors[256] | Specifies an array of 256 RGBQUADs.
 *
 * @type PVIDEOFORMATEX | Pointer to a <t VIDEOFORMATEX> structure.
 *
 ****************************************************************************/

#define BMIH_SLOP 256+32
#define BMIH_SLOP_BYTES (256+32)*4

typedef struct videoformatex_tag {
	// Wave format compatibility fields
	DWORD		dwFormatTag;
	DWORD		nSamplesPerSec;
	DWORD		nAvgBytesPerSec;
	DWORD		nMinBytesPerSec;
	DWORD		nMaxBytesPerSec;
	DWORD		nBlockAlign;
	DWORD		wBitsPerSample;
	// Temporal fields
    DWORD		dwRequestMicroSecPerFrame;
    DWORD		dwPercentDropForError;
    DWORD		dwNumVideoRequested;
    DWORD		dwSupportTSTradeOff;
    BOOL		bLive;
	// Spatial fields
    DWORD       dwFormatSize;
    BITMAPINFOHEADER bih;
    DWORD 	bihSLOP[BMIH_SLOP];	// bmiColors = &bih + bih.biSize
//    RGBQUAD     bmiColors[256];
} VIDEOFORMATEX, *PVIDEOFORMATEX;

/*****************************************************************************
 * @doc EXTERNAL CAPSTRUCTENUM
 *
 * @struct VIDEOINCAPS | The <t VIDEOINCAPS> structure describes the
 *   capabilities of a video capture input device.
 *
 * @field TCHAR | szDeviceName[80] | Specifies the device name.
 *
 * @field TCHAR | szDeviceVersion[80] | Specifies the device version.
 *
 * @field DWORD | dwImageSize | Specifies which standard image sizes are supported.
 *   The supported sizes are specified with a logical OR of the following
 *   flags:
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_40_30	| 40x30 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_80_60	| 80x30 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_120_90	| 120x90 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_160_120	| 160x120 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_200_150	| 200x150 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_240_180	| 240x180 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_280_210	| 280x210 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_320_240	| 320x240 pixels
 *
 * @field DWORD | dwNumColors | Specifies what number of colors are supported.
 *   The supported number of colors are specified with a logical OR of the following
 *   flags:
 *   @flag VIDEO_FORMAT_NUM_COLORS_16 | 16 colors
 *   @flag VIDEO_FORMAT_NUM_COLORS_256 | 256 colors
 *   @flag VIDEO_FORMAT_NUM_COLORS_65536 | 65536 colors
 *   @flag VIDEO_FORMAT_NUM_COLORS_16777216 | 16777216 colors
 *
 * @field DWORD | dwStreamingMode | Specifies the preferred streaming mode.
 *   The supported mode is either one of the following
 *   flags:
 *   @flag STREAMING_PREFER_STREAMING | Real streaming
 *   @flag STREAMING_PREFER_FRAME_GRAB | Single frame grabbing
 *
 * @field DWORD | dwDialogs | Specifies the dialogs that we shoud enable\disable.
 *   The supported dialogs are specified with a logical OR of the following
 *   flags:
 *   @flag FORMAT_DLG_ON | Enable video format dialog
 *   @flag FORMAT_DLG_OFF | Disable video format dialog
 *   @flag SOURCE_DLG_ON | Enable source dialog
 *   @flag SOURCE_DLG_OFF | Disable source dialog
 *
 * @field RGBQUAD | bmi4bitColors[16] | Specifies a 16 color palette.
 *
 * @field RGBQUAD | bmi8bitColors[256] | Specifies a 256 color palette.
 *
 * @type PVIDEOINCAPS | Pointer to a <t VIDEOINCAPS> structure.
 *
 * @devnote We could allocate the memory space required by the palettes dynamically.
 *   But since the VIDEOINCAPS structure are only created on the stack of a couple of
 *   VCM functions, why bother.
 *
 * @xref <f videoInGetDevCaps>
 ****************************************************************************/
typedef struct videoincaps_tag {
    TCHAR		szDeviceName[80];
    TCHAR		szDeviceVersion[80];
    DWORD		dwImageSize;
    DWORD		dwNumColors;
    DWORD		dwStreamingMode;
    DWORD		dwDialogs;
    DWORD       dwFlags;
	RGBQUAD		bmi4bitColors[NUM_4BIT_ENTRIES];
	RGBQUAD		bmi8bitColors[NUM_8BIT_ENTRIES];
} VIDEOINCAPS, *PVIDEOINCAPS;

#define VICF_4BIT_TABLE     1   // set in dwFlags, if bmi4bitColors is valid
#define VICF_8BIT_TABLE     2   // set in dwFlags, if bmi8bitColors is valid

/*****************************************************************************
 * @doc EXTERNAL PLAYSTRUCTENUM
 *
 * @struct VIDEOOUTCAPS | The <t VIDEOOUTCAPS> structure describes the
 *   capabilities of a video output device.
 *
 * @field DWORD | dwFormats | Specifies which standard formats are supported.
 *   The supported formats are specified with a logical OR of the following
 *   flags:
 *   @flag VIDEO_FORMAT_04 | 4-bit palettized
 *   @flag VIDEO_FORMAT_08 | 8-bit palettized
 *   @flag VIDEO_FORMAT_16 | 16-bit
 *   @flag VIDEO_FORMAT_24 | 24-bit
 *   @flag VIDEO_FORMAT_SP | Driver supplies palettes
 *
 * @type PVIDEOOUTCAPS | Pointer to a <t VIDEOOUTCAPS> structure.
 *
 * @xref <f videoOutGetDevCaps>
 ****************************************************************************/
typedef struct videooutcaps_tag {
    DWORD		dwFormats;
} VIDEOOUTCAPS, *PVIDEOOUTCAPS;

// dwFlags field of VIDEOINOUTHDR
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000001 | VHDR_DONE | Data is done.
 *
 * @const 0x00000002 | VHDR_PREPARED | Data is prepared.
 *
 * @const 0x00000004 | VHDR_INQUEUE | Data is in queue.
 *
 ****************************************************************************/
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */
#define VHDR_VALID      0x0000000F  /* valid flags */     /* ;Internal */

// dwImageSize of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 27 | VIDEO_FORMAT_NUM_IMAGE_SIZE | Number of video input sizes used by the device.
 *
 * @const 0x00000001 | VIDEO_FORMAT_IMAGE_SIZE_40_30 | Video input device uses 40x30 pixel frames.
 *
 * @const 0x00000002 | VIDEO_FORMAT_IMAGE_SIZE_64_48 | Video input device uses 64x48 pixel frames.
 *
 * @const 0x00000004 | VIDEO_FORMAT_IMAGE_SIZE_80_60 | Video input device uses 80x60 pixel frames.
 *
 * @const 0x00000008 | VIDEO_FORMAT_IMAGE_SIZE_96_64 | Video input device uses 96x64 pixel frames.
 *
 * @const 0x00000010 | VIDEO_FORMAT_IMAGE_SIZE_112_80 | Video input device uses 112x80 pixel frames.
 *
 * @const 0x00000020 | VIDEO_FORMAT_IMAGE_SIZE_120_90 | Video input device uses 120x90 pixel frames.
 *
 * @const 0x00000040 | VIDEO_FORMAT_IMAGE_SIZE_128_96 | Video input device uses 128x96 (SQCIF) pixel frames.
 *
 * @const 0x00000080 | VIDEO_FORMAT_IMAGE_SIZE_144_112 | Video input device uses 144x112 pixel frames.
 *
 * @const 0x00000100 | VIDEO_FORMAT_IMAGE_SIZE_160_120 | Video input device uses 160x120 pixel frames.
 *
 * @const 0x00000200 | VIDEO_FORMAT_IMAGE_SIZE_160_128 | Video input device uses 160x128 pixel frames.
 *
 * @const 0x00000400 | VIDEO_FORMAT_IMAGE_SIZE_176_144 | Video input device uses 176x144 (QCIF) pixel frames.
 *
 * @const 0x00000800 | VIDEO_FORMAT_IMAGE_SIZE_192_160 | Video input device uses 192x160 pixel frames.
 *
 * @const 0x00001000 | VIDEO_FORMAT_IMAGE_SIZE_200_150 | Video input device uses 200x150 pixel frames.
 *
 * @const 0x00002000 | VIDEO_FORMAT_IMAGE_SIZE_208_176 | Video input device uses 208x176 pixel frames.
 *
 * @const 0x00004000 | VIDEO_FORMAT_IMAGE_SIZE_224_192 | Video input device uses 224x192 pixel frames.
 *
 * @const 0x00008000 | VIDEO_FORMAT_IMAGE_SIZE_240_180 | Video input device uses 240x180 pixel frames.
 *
 * @const 0x00010000 | VIDEO_FORMAT_IMAGE_SIZE_240_208 | Video input device uses 240x208 pixel frames.
 *
 * @const 0x00020000 | VIDEO_FORMAT_IMAGE_SIZE_256_224 | Video input device uses 256x224 pixel frames.
 *
 * @const 0x00040000 | VIDEO_FORMAT_IMAGE_SIZE_272_240 | Video input device uses 272x240 pixel frames.
 *
 * @const 0x00080000 | VIDEO_FORMAT_IMAGE_SIZE_280_210 | Video input device uses 280x210 pixel frames.
 *
 * @const 0x00100000 | VIDEO_FORMAT_IMAGE_SIZE_288_256 | Video input device uses 288x256 pixel frames.
 *
 * @const 0x00200000 | VIDEO_FORMAT_IMAGE_SIZE_304_272 | Video input device uses 304x272 pixel frames.
 *
 * @const 0x00400000 | VIDEO_FORMAT_IMAGE_SIZE_320_240 | Video input device uses 320x240 pixel frames.
 *
 * @const 0x00800000 | VIDEO_FORMAT_IMAGE_SIZE_320_288 | Video input device uses 320x288 pixel frames.
 *
 * @const 0x01000000 | VIDEO_FORMAT_IMAGE_SIZE_336_288 | Video input device uses 336x288 pixel frames.
 *
 * @const 0x02000000 | VIDEO_FORMAT_IMAGE_SIZE_352_288 | Video input device uses 352x288 (CIF) pixel frames.
 *
 * @const 0x04000000 | VIDEO_FORMAT_IMAGE_SIZE_640_480 | Video input device uses 640x480 pixel frames.
 *
 ****************************************************************************/
#define VIDEO_FORMAT_NUM_IMAGE_SIZE	27

#define VIDEO_FORMAT_IMAGE_SIZE_40_30	0x00000001
#define VIDEO_FORMAT_IMAGE_SIZE_64_48	0x00000002
#define VIDEO_FORMAT_IMAGE_SIZE_80_60	0x00000004
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
#define VIDEO_FORMAT_IMAGE_SIZE_80_64	0x00000008
#else
#define VIDEO_FORMAT_IMAGE_SIZE_96_64	0x00000008
#endif
#define VIDEO_FORMAT_IMAGE_SIZE_112_80	0x00000010
#define VIDEO_FORMAT_IMAGE_SIZE_120_90	0x00000020
#define VIDEO_FORMAT_IMAGE_SIZE_128_96	0x00000040
#define VIDEO_FORMAT_IMAGE_SIZE_144_112	0x00000080
#define VIDEO_FORMAT_IMAGE_SIZE_160_120	0x00000100
#define VIDEO_FORMAT_IMAGE_SIZE_160_128	0x00000200
#define VIDEO_FORMAT_IMAGE_SIZE_176_144	0x00000400
#define VIDEO_FORMAT_IMAGE_SIZE_192_160	0x00000800
#define VIDEO_FORMAT_IMAGE_SIZE_200_150	0x00001000
#define VIDEO_FORMAT_IMAGE_SIZE_208_176	0x00002000
#define VIDEO_FORMAT_IMAGE_SIZE_224_192	0x00004000
#define VIDEO_FORMAT_IMAGE_SIZE_240_180	0x00008000
#define VIDEO_FORMAT_IMAGE_SIZE_240_208	0x00010000
#define VIDEO_FORMAT_IMAGE_SIZE_256_224	0x00020000
#define VIDEO_FORMAT_IMAGE_SIZE_272_240	0x00040000
#define VIDEO_FORMAT_IMAGE_SIZE_280_210	0x00080000
#define VIDEO_FORMAT_IMAGE_SIZE_288_256	0x00100000
#define VIDEO_FORMAT_IMAGE_SIZE_304_272	0x00200000
#define VIDEO_FORMAT_IMAGE_SIZE_320_240	0x00400000
#define VIDEO_FORMAT_IMAGE_SIZE_320_288	0x00800000
#define VIDEO_FORMAT_IMAGE_SIZE_336_288	0x01000000
#define VIDEO_FORMAT_IMAGE_SIZE_352_288	0x02000000
#define VIDEO_FORMAT_IMAGE_SIZE_640_480	0x04000000

#define VIDEO_FORMAT_IMAGE_SIZE_USE_DEFAULT 0x80000000

// dwNumColors of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000001 | VIDEO_FORMAT_NUM_COLORS_16 | Video input device uses 16 colors.
 *
 * @const 0x00000002 | VIDEO_FORMAT_NUM_COLORS_256 | Video input device uses 256 colors.
 *
 * @const 0x00000004 | VIDEO_FORMAT_NUM_COLORS_65536 | Video input device uses 65536 colors.
 *
 * @const 0x00000008 | VIDEO_FORMAT_NUM_COLORS_16777216 | Video input device uses 16777216 colors.
 *
 * @const 0x00000010 | VIDEO_FORMAT_NUM_COLORS_YVU9 | Video input device uses the YVU9 compressed format.
 *
 * @const 0x00000020 | VIDEO_FORMAT_NUM_COLORS_I420 | Video input device uses the I420 compressed format.
 *
 * @const 0x00000040 | VIDEO_FORMAT_NUM_COLORS_IYUV | Video input device uses the IYUV compressed format.
 *
 ****************************************************************************/
#define VIDEO_FORMAT_NUM_COLORS_16			0x00000001
#define VIDEO_FORMAT_NUM_COLORS_256			0x00000002
#define VIDEO_FORMAT_NUM_COLORS_65536		0x00000004
#define VIDEO_FORMAT_NUM_COLORS_16777216	0x00000008
#define VIDEO_FORMAT_NUM_COLORS_YVU9		0x00000010
#define VIDEO_FORMAT_NUM_COLORS_I420		0x00000020
#define VIDEO_FORMAT_NUM_COLORS_IYUV		0x00000040
#define VIDEO_FORMAT_NUM_COLORS_YUY2		0x00000080
#define VIDEO_FORMAT_NUM_COLORS_UYVY		0x00000100

// dwDialogs of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000000 | FORMAT_DLG_OFF | Disable video format dialog.
 *
 * @const 0x00000000 | SOURCE_DLG_OFF | Disable source dialog.
 *
 * @const 0x00000001 | FORMAT_DLG_ON | Enable video format dialog.
 *
 * @const 0x00000002 | SOURCE_DLG_ON | Enable source dialog.
 *
 ****************************************************************************/
#define FORMAT_DLG_OFF	0x00000000
#define SOURCE_DLG_OFF	0x00000000
#define FORMAT_DLG_ON	0x00000001
#define SOURCE_DLG_ON	0x00000002

// dwFormats of VIDEOOUTCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000001 | VIDEO_FORMAT_04 | Video output device supports 4bit DIBs
 *
 * @const 0x00000002 | VIDEO_FORMAT_08 | Video output device supports 8bit DIBs
 *
 * @const 0x00000004 | VIDEO_FORMAT_16 | Video output device supports 16bit DIBs
 *
 * @const 0x00000008 | VIDEO_FORMAT_24 | Video output device supports 24bit DIBs
 *
 * @const 0x00000008 | VIDEO_FORMAT_32 | Video output device supports 32bit DIBs
 *
 ****************************************************************************/
#define VIDEO_FORMAT_04	0x00000001
#define VIDEO_FORMAT_08	0x00000002
#define VIDEO_FORMAT_16	0x00000004
#define VIDEO_FORMAT_24	0x00000008
#define VIDEO_FORMAT_32	0x00000010

/****************************************************************************
                            Error Return Values
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const WAVERR_BASE | VIDEOERR_BASE | Base for video errors.
 *
 * @const (VIDEOERR_BASE + 0) | VIDEOERR_BADFORMAT | Unsupported video format.
 *
 * @const (VIDEOERR_BASE + 1) | VIDEOERR_INQUEUE | Header is already or still queued.
 *
 * @const (VIDEOERR_BASE + 2) | VIDEOERR_UNPREPARED | Header is not prepared.
 *
 * @const (VIDEOERR_BASE + 3) | VIDEOERR_NONSPECIFIC | Non specific error.
 *
 * @const (VIDEOERR_BASE + 3) | VIDEOERR_LASTERROR | Last video error in range.
 *
 ****************************************************************************/
#define VIDEOERR_BASE			WAVERR_BASE				/* base for video errors */
#define VIDEOERR_BADFORMAT		(VIDEOERR_BASE + 0)		/* unsupported video format */
#define VIDEOERR_INQUEUE		(VIDEOERR_BASE + 1)		/* header is already queued */
#define VIDEOERR_UNPREPARED		(VIDEOERR_BASE + 2)		/* header not prepared */
#define VIDEOERR_NONSPECIFIC	(VIDEOERR_BASE + 3)		/* non specific */
#define VIDEOERR_LASTERROR		(VIDEOERR_BASE + 3)		/* last error in range */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#pragma pack()          /* Revert to default packing */

#endif  /* _INC_VIDEOINOUT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\vcmstrm.h ===
#ifndef _INC_VCM
#define _INC_VCM        /* #defined if vcmStrm.h has been included */

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#pragma pack(1)         /* Assume 1 byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************
			       Table Of Contents
****************************************************************************/
/****************************************************************************
@doc EXTERNAL

@contents1 Contents | To display a list of topics by category, click any
of the contents entries below. To display an alphabetical list of
topics, choose the Index button.

@head3 Introduction |

The vcmStreamXXX APIs are defined to simplify integration of video
compression and decompression in NetMeeting's datapump. Currently, the datapump
behavior relies a lot on the acmStreamXXX APIs. In order to limit the amount of modifications that need to be applied
to the datapump, we define video compression APIs with a behavior similar to
the audio compression APIs. Integration in the datapump will be achieved by defining
a FilterVideoManager class identical to the FilterManager class, where calls to
acmStreamXXX functions are simply replaced by calls to vcmStreamXXX functions.

@head3 vcmStreamXXX Compression/Decompression API |

@subindex Functions
@subindex Structures and Enums
@subindex Messages

@head3 vcmDevCapsXXX Capture Device Capabilities API |

@subindex Functions
@subindex Structures and Enums
@subindex Messages

@head3 Other |

@subindex Modules
@subindex Constants

***********************************************************************
@contents2 Compression/Decompression Functions |
@index func | COMPFUNC

***********************************************************************
@contents2 Compression/Decompression Structures and Enums |
@index struct,enum | COMPSTRUCTENUM

***********************************************************************
@contents2 Compression/Decompression Messages |
@index msg | COMPMSG

***********************************************************************
@contents2 Capture Device Capabilities Functions |
@index func | DEVCAPSFUNC

***********************************************************************
@contents2 Capture Device Capabilities Structures and Enums |
@index struct,enum | DEVCAPSSTRUCTENUM

***********************************************************************
@contents2 Modules |
@index module |

***********************************************************************
@contents2 Constants |
@index const |
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPSTRUCTENUM
 *
 * @struct VIDEOFORMATEX | The <t VIDEOFORMATEX> structure defines the format used to
 *   capture video data and settings for the capture device.
 *
 * @field DWORD | dwFormatTag | Specifies the video format type (FOURCC code).
 *
 * @field DWORD | nSamplesPerSec | Specifies the sample rate, in frames per second.
 *
 * @field DWORD | nAvgBytesPerSec | Specifies the average data-transfer rate, in bytes per second.
 *
 * @field DWORD | nMinBytesPerSec | Specifies the minimum data-transfer rate, in bytes per second.
 *
 * @field DWORD | nMaxBytesPerSec | Specifies the maximum data-transfer rate, in bytes per second.
 *
 * @field DWORD | nBlockAlign | Specifies the block alignment, in bytes.
 *
 * @field DWORD | wBitsPerSample | Specifies the bits per sample for the wFormatTag format type.
 *
 * @field DWORD | dwRequestMicroSecPerFrame | Specifies the requested frame rate, in microseconds.
 *
 * @field DWORD | dwPercentDropForError | Specifies the maximum allowable percentage of dropped frames during capture.
 *
 * @field DWORD | dwNumVideoRequested | This specifies the maximum number of video buffers to allocate.
 *
 * @field DWORD | dwSupportTSTradeOff | Specifies the usage of temporal/spatial trade off.
 *
 * @field BOOL | bLive | Specifies if the preview is to be allowed.
 *
 * @field HWND | hWndParent | Specifies handle of the parent window.
 *
 * @field DWORD | dwFormatSize | Specifies the size of the actual video format.
 *
 * @field DWORD | biSize | Specifies the number of bytes required by the spatial information.
 *
 * @field LONG | biWidth | Specifies the width of the bitmap, in pixels.
 *
 * @field LONG | biHeight | Specifies the height of the bitmap, in pixels.
 *
 * @field WORD | biPlanes | Specifies the number of planes for the target device.
 *
 * @field WORD | biBitCount | Specifies the number of bits per pixel.
 *
 * @field DWORD | biCompression | Specifies the type of compression.
 *
 * @field DWORD | biSizeImage | Specifies the size, in bytes, of the image.
 *
 * @field LONG | biXPelsPerMeter | Specifies the horizontal resolution, in pixels per meter, of the target device for the bitmap.
 *
 * @field LONG | biYPelsPerMeter | Specifies the vertical resolution, in pixels per meter, of the target device for the bitmap.
 *
 * @field DWORD | biClrUsed | Specifies the number of color indices in the color table that are actually used by the bitmap.
 *
 * @field DWORD | biClrImportant | Specifies the number of color indices that are considered important for displaying the bitmap.
 *
 * @field DWORD | bmiColors[256] | Specifies an array of 256 RGBQUADs.
 *
 * @type PVIDEOFORMATEX | Pointer to a <t VIDEOFORMATEX> structure.
 *
 ****************************************************************************/

#define VCMAPI                                          WINAPI

/****************************************************************************
			vcmStrm Constants
****************************************************************************/
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const WAVE_FORMAT_UNKNOWN | VIDEO_FORMAT_UNKNOWN | Constant for unknown video format.
 *
 * @const BI_RGB | VIDEO_FORMAT_BI_RGB | RGB video format.
 *
 * @const BI_RLE8 | VIDEO_FORMAT_BI_RLE8 | RLE 8 video format.
 *
 * @const BI_RLE4 | VIDEO_FORMAT_BI_RLE4 | RLE 4 video format.
 *
 * @const BI_BITFIELDS | VIDEO_FORMAT_BI_BITFIELDS | RGB Bit Fields video format.
 *
 * @const MAKEFOURCC('c','v','i','d') | VIDEO_FORMAT_CVID | Cinepack video format.
 *
 * @const MAKEFOURCC('I','V','3','2') | VIDEO_FORMAT_IV32 | Intel Indeo IV32 video format.
 *
 * @const MAKEFOURCC('Y','V','U','9') | VIDEO_FORMAT_YVU9 | Intel Indeo YVU9 video format.
 *
 * @const MAKEFOURCC('M','S','V','C') | VIDEO_FORMAT_MSVC | Microsoft CRAM video format.
 *
 * @const MAKEFOURCC('M','R','L','E') | VIDEO_FORMAT_MRLE | Microsoft RLE video format.
 *
 * @const MAKEFOURCC('h','2','6','3') | VIDEO_FORMAT_INTELH263 | Intel H.263 video format.
 *
 * @const MAKEFOURCC('h','2','6','1') | VIDEO_FORMAT_INTELH261 | Intel H.261 video format.
 *
 * @const MAKEFOURCC('M','2','6','3') | VIDEO_FORMAT_MSH263 | Microsoft H.263 video format.
 *
 * @const MAKEFOURCC('M','2','6','1') | VIDEO_FORMAT_MSH261 | Microsoft H.261 video format.
 *
 * @const MAKEFOURCC('V','D','E','C') | VIDEO_FORMAT_VDEC | Color QuickCam video format.
 *
 ****************************************************************************/
#define VIDEO_FORMAT_UNKNOWN		WAVE_FORMAT_UNKNOWN

#define VIDEO_FORMAT_BI_RGB			BI_RGB
#define VIDEO_FORMAT_BI_RLE8		BI_RLE8
#define VIDEO_FORMAT_BI_RLE4		BI_RLE4
#define VIDEO_FORMAT_BI_BITFIELDS	BI_BITFIELDS
#define VIDEO_FORMAT_CVID			MAKEFOURCC('C','V','I','D')	// hex: 0x44495643
#define VIDEO_FORMAT_IV31			MAKEFOURCC('I','V','3','1')	// hex: 0x31335649
#define VIDEO_FORMAT_IV32			MAKEFOURCC('I','V','3','2')	// hex: 0x32335649
#define VIDEO_FORMAT_YVU9			MAKEFOURCC('Y','V','U','9')	// hex: 0x39555659
#define VIDEO_FORMAT_I420			MAKEFOURCC('I','4','2','0')
#define VIDEO_FORMAT_IYUV			MAKEFOURCC('I','Y','U','V')
#define VIDEO_FORMAT_MSVC			MAKEFOURCC('M','S','V','C')	// hex: 0x4356534d
#define VIDEO_FORMAT_MRLE			MAKEFOURCC('M','R','L','E')	// hex: 0x454c524d
#define VIDEO_FORMAT_INTELH263		MAKEFOURCC('H','2','6','3')	// hex: 0x33363248
#define VIDEO_FORMAT_INTELH261		MAKEFOURCC('H','2','6','1')	// hex: 0x31363248
#define VIDEO_FORMAT_INTELI420		MAKEFOURCC('I','4','2','0')	// hex: 0x30323449
#define VIDEO_FORMAT_INTELRT21		MAKEFOURCC('R','T','2','1')	// hex: 0x31325452
#define VIDEO_FORMAT_MSH263			MAKEFOURCC('M','2','6','3')	// hex: 0x3336324d
#define VIDEO_FORMAT_MSH261			MAKEFOURCC('M','2','6','1')	// hex: 0x3136324d
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
#define VIDEO_FORMAT_MSH26X			MAKEFOURCC('M','2','6','X')	// hex: 0x5836324d
#endif
#define VIDEO_FORMAT_Y411			MAKEFOURCC('Y','4','1','1')	// hex:
#define VIDEO_FORMAT_YUY2			MAKEFOURCC('Y','U','Y','2')	// hex:
#define VIDEO_FORMAT_YVYU			MAKEFOURCC('Y','V','Y','U')	// hex:
#define VIDEO_FORMAT_UYVY			MAKEFOURCC('U','Y','V','Y')	// hex:
#define VIDEO_FORMAT_Y211			MAKEFOURCC('Y','2','1','1')	// hex:
// VDOnet VDOWave codec
#define VIDEO_FORMAT_VDOWAVE		MAKEFOURCC('V','D','O','W')	// hex:
// Color QuickCam video codec
#define VIDEO_FORMAT_VDEC			MAKEFOURCC('V','D','E','C')	// hex: 0x43454456
// Dec Alpha
#define VIDEO_FORMAT_DECH263		MAKEFOURCC('D','2','6','3')	// hex: 0x33363248
#define VIDEO_FORMAT_DECH261		MAKEFOURCC('D','2','6','1')	// hex: 0x31363248
// MPEG4 Scrunch codec
#ifdef USE_MPEG4_SCRUNCH
#define VIDEO_FORMAT_MPEG4_SCRUNCH	MAKEFOURCC('M','P','G','4')	// hex:
#endif


//--------------------------------------------------------------------------;
//
//  VCM General API's and Defines
//
//
//
//
//--------------------------------------------------------------------------;

//
//  there are four types of 'handles' used by the VCM. the first three
//  are unique types that define specific objects:
//
//  HVCMDRIVERID: used to _identify_ an VCM driver. this identifier can be
//  used to _open_ the driver for querying details, etc about the driver.
//
//  HVCMDRIVER: used to manage a driver (codec, filter, etc). this handle
//  is much like a handle to other media drivers--you use it to send
//  messages to the converter, query for capabilities, etc.
//
//  HVCMSTREAM: used to manage a 'stream' (conversion channel) with the
//  VCM. you use a stream handle to convert data from one format/type
//  to another--much like dealing with a file handle.
//
//
//  the fourth handle type is a generic type used on VCM functions that
//  can accept two or more of the above handle types (for example the
//  vcmMetrics and vcmDriverID functions).
//
//  HVCMOBJ: used to identify VCM objects. this handle is used on functions
//  that can accept two or more VCM handle types.
//
DECLARE_HANDLE(HVCMDRIVERID);
typedef HVCMDRIVERID       *PHVCMDRIVERID;

DECLARE_HANDLE(HVCMDRIVER);
typedef HVCMDRIVER         *PHVCMDRIVER;

DECLARE_HANDLE(HVCMSTREAM);
typedef HVCMSTREAM         *PHVCMSTREAM;

DECLARE_HANDLE(HVCMOBJ);
typedef HVCMOBJ            *PHVCMOBJ;

/****************************************************************************
    callback function type
****************************************************************************/
typedef void (CALLBACK* VCMSTREAMPROC) (HVCMSTREAM hvs, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  VCM Error Codes
//
//  Note that these error codes are specific errors that apply to the VCM
//  directly--general errors are defined as MMSYSERR_*.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef _MMRESULT_
#define _MMRESULT_
typedef UINT                MMRESULT;
#endif

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const ACMERR_BASE | VCMERR_BASE | Base for video errors.
 *
 * @const (VCMERR_BASE + 0) | VCMERR_NOTPOSSIBLE | Unsupported video compression format.
 *
 * @const (VCMERR_BASE + 1) | VCMERR_BUSY | Compression header is already or still queued.
 *
 * @const (VCMERR_BASE + 2) | VCMERR_UNPREPARED | Compression header is not prepared.
 *
 * @const (VCMERR_BASE + 3) | VCMERR_CANCELED | User canceled operation.
 *
 * @const (VCMERR_BASE + 4) | VCMERR_FAILED | Compression operation failed.
 *
 * @const (VCMERR_BASE + 5) | VCMERR_NOREGENTRY | Failed to read/write registry entry.
 *
 * @const (VCMERR_BASE + 6) | VCMERR_NONSPECIFIC | Some error occured.
 *
 * @const (VCMERR_BASE + 7) | VCERR_NOMOREPACKETS | No more packets to receive a payload header.
 *
 ****************************************************************************/
#define VCMERR_BASE				ACMERR_BASE
#define VCMERR_NOTPOSSIBLE		(VCMERR_BASE + 0)
#define VCMERR_BUSY				(VCMERR_BASE + 1)
#define VCMERR_UNPREPARED		(VCMERR_BASE + 2)
#define VCMERR_CANCELED			(VCMERR_BASE + 3)
#define VCMERR_FAILED			(VCMERR_BASE + 4)
#define VCMERR_NOREGENTRY		(VCMERR_BASE + 5)
#define VCMERR_NONSPECIFIC		(VCMERR_BASE + 6)
#define VCMERR_NOMOREPACKETS	(VCMERR_BASE + 7)
#define VCMERR_PSCMISSING		(VCMERR_BASE + 8)

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  VCM Window Messages
//
//  These window messages are sent by the VCM or VCM drivers to notify
//  applications of events.
//
//  Note that these window message numbers will also be defined in
//  mmsystem.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg VCM_OPEN | This message is sent to a video compression callback function when
 *   a video compression stream is opened.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VCM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg MM_VCM_OPEN | This message is sent to a window when a video compression
 *   stream is opened.
 *
 * @parm WORD | wParam | Specifies a handle to the video compression stream
 *   that was opened.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VCM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg VCM_CLOSE | This message is sent to a video compression stream function when
 *   a video ccompression stream is closed. The stream handle is no longer
 *   valid once this message has been sent.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VCM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg MM_VCM_CLOSE | This message is sent to a window when a video compression
 *   stream is closed. The stream handle is no longer valid once this message
 *   has been sent.
 *
 * @parm WORD | wParam | Specifies a handle to the video compression stream
 *   that was closed.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VCM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg VCM_DONE | This message is sent to a video compression stream callback function when
 *   video data is present in the compression buffer and the buffer is being
 *   returned to the application. The message can be sent either when the
 *   buffer is full, or after the <f acmStreamReset> function is called.
 *
 * @parm DWORD | dwParam1 | Specifies a far pointer to a <t VCMSTREAMHDR> structure
 *   identifying the buffer containing the compressed video data.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @comm The returned buffer may not be full. Use the <e VCMSTREAMHDR.dwDstBytesUsed>
 *   field of the <t VCMSTREAMHDR> structure specified by <p dwParam1> to
 *   determine the number of valid bytes into the returned buffer.
 *
 * @xref <m MM_VCM_DONE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg MM_VCM_DONE | This message is sent to a window when video data is
 *   present in the compression buffer and the buffer is being returned to the
 *   application. The message can be sent either when the buffer is full, or
 *   after the <f acmStreamReset> function is called.
 *
 * @parm WORD | wParam | Specifies a handle to the video compression stream
 *   that received the compressed video data.
 *
 * @parm LONG | lParam | Specifies a far pointer to a <t VCMSTREAMHDR> structure
 *   identifying the buffer containing the compressed video data.
 *
 * @rdesc None
 *
 * @comm The returned buffer may not be full. Use the <e VCMSTREAMHDR.dwDstBytesUsed>
 *   field of the <t VCMSTREAMHDR> structure specified by <p lParam> to
 *   determine the number of valid bytes into the returned buffer.
 *
 * @xref <m VCM_DONE>
 ****************************************************************************/

#define MM_VCM_OPEN         (MM_STREAM_OPEN)  // conversion callback messages
#define MM_VCM_CLOSE        (MM_STREAM_CLOSE)
#define MM_VCM_DONE         (MM_STREAM_DONE)
#define VCM_OPEN                        (MM_STREAM_OPEN)  // conversion states
#define VCM_CLOSE                       (MM_STREAM_CLOSE)
#define VCM_DONE                        (MM_STREAM_DONE)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmMetrics()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmMetrics
(
    HVCMOBJ                 hvo,
    UINT                    uMetric,
    LPVOID                  pMetric
);

#define VCM_METRIC_COUNT_DRIVERS            1
#define VCM_METRIC_COUNT_CODECS             2
#define VCM_METRIC_COUNT_CONVERTERS         3
#define VCM_METRIC_COUNT_FILTERS            4
#define VCM_METRIC_COUNT_DISABLED           5
#define VCM_METRIC_COUNT_HARDWARE           6
#define VCM_METRIC_COUNT_COMPRESSORS        7
#define VCM_METRIC_COUNT_DECOMPRESSORS      8
#define VCM_METRIC_COUNT_LOCAL_DRIVERS      20
#define VCM_METRIC_COUNT_LOCAL_CODECS       21
#define VCM_METRIC_COUNT_LOCAL_CONVERTERS   22
#define VCM_METRIC_COUNT_LOCAL_FILTERS      23
#define VCM_METRIC_COUNT_LOCAL_DISABLED     24
#define VCM_METRIC_HARDWARE_VIDEO_INPUT      30
#define VCM_METRIC_HARDWARE_VIDEO_OUTPUT     31
#define VCM_METRIC_MAX_SIZE_FORMAT          50
#define VCM_METRIC_MAX_SIZE_FILTER          51
#define VCM_METRIC_MAX_SIZE_BITMAPINFOHEADER 52
#define VCM_METRIC_DRIVER_SUPPORT           100
#define VCM_METRIC_DRIVER_PRIORITY          101

//--------------------------------------------------------------------------;
//
//  VCM Drivers
//
//
//
//
//--------------------------------------------------------------------------;

#define VCMDM_USER                  (DRV_USER + 0x0000)
#define VCMDM_RESERVED_LOW          (DRV_USER + 0x2000)
#define VCMDM_RESERVED_HIGH         (DRV_USER + 0x2FFF)

#define VCMDM_BASE                  VCMDM_RESERVED_LOW

#define VCMDM_DRIVER_ABOUT          (VCMDM_BASE + 11)


//
//  VCMDRIVERDETAILS
//
//  the VCMDRIVERDETAILS structure is used to get various capabilities from
//  an VCM driver (codec, converter, filter).
//
#define VCMDRIVERDETAILS_SHORTNAME_CHARS        16
#define VCMDRIVERDETAILS_LONGNAME_CHARS         128
#define VCMDRIVERDETAILS_MODULE_CHARS           128

/*****************************************************************************
 *  @doc EXTERNAL COMPSTRUCTENUM
 *
 *  @struct VCMDRIVERDETAILS | The <t VCMDRIVERDETAILS> structure describes
 *      various details of a Video Compression Manager (VCM) driver.
 *
 *  @field DWORD | dwSize | Specifies the size, in bytes,  of the valid
 *      information contained in the <t VCMDRIVERDETAILS> structure.
 *      An application should initialize this member to the size, in bytes, of
 *      the desired information. The size specified in this member must be
 *      large enough to contain the <e VCMDRIVERDETAILS.dwSize> member of
 *      the <t VCMDRIVERDETAILS> structure. When the <f vcmDriverDetails>
 *      function returns, this member contains the actual size of the
 *      information returned. The returned information will never exceed
 *      the requested size.
 *
 *  @field FOURCC | fccType | Specifies the type of the driver. For VCM drivers, set
 *      this member to <p vidc>, which represents VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC.
 *
 *  @field FOURCC | fccHandler | Specifies a four-character code identifying a specific compressor.
 *
 *  @field DWORD | dwFlags | Specifies applicable flags.
 *
 *  @field DWORD | dwVersion | Specifies version number of the driver.
 *
 *  @field DWORD | dwVersionICM | Specifies theersion of VCM supported by the driver.
 *      This member should be set to ICVERSION.
 *
 *  @field WCHAR | szName[VCMDRIVERDETAILS_SHORTNAME_CHARS] | Specifies
 *      a NULL-terminated string that describes the short version of the compressor name.
 *
 *  @field WCHAR | szDescription[VCMDRIVERDETAILS_LONGNAME_CHARS] | Specifies a
 *      NULL-terminated string that describes the long version of the compressor name.
 *
 *  @field WCHAR | szDriver[VCMDRIVERDETAILS_MODULE_CHARS] | Specifies
 *      a NULL-terminated string that provides the name of the module containing the VCM compression driver.
 *
 *  @xref <f vcmDriverDetails>
 ****************************************************************************/
// This structure is equivalent to ICINFO
typedef struct tVCMDRIVERDETAILS
{
	DWORD   dwSize;                                                                                 // Size, in bytes, of this structure
	DWORD   fccType;                                                                                // Four-character code indicating the type of stream being compressed or decompressed. Specify "VIDC" for video streams.
	DWORD   fccHandler;                                                                             // A four-character code identifying a specific compressor
	DWORD   dwFlags;                                                                                // Applicable flags
	DWORD   dwVersion;                                                                              // Version number of the driver
	DWORD   dwVersionICM;                                                                   // Version of VCM supported by the driver. This member should be set to ICVERSION
	WCHAR   szName[VCMDRIVERDETAILS_SHORTNAME_CHARS];               // Short version of the compressor name
	WCHAR   szDescription[VCMDRIVERDETAILS_LONGNAME_CHARS]; // Long version of the compressor name
	WCHAR   szDriver[VCMDRIVERDETAILS_MODULE_CHARS];                // Name of the module containing VCM compression driver. Normally, a driver does not need to fill this out.
} VCMDRIVERDETAILS, *PVCMDRIVERDETAILS;

#define VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC mmioFOURCC('v', 'i', 'd', 'c')
#define VCMDRIVERDETAILS_FCCCOMP_UNDEFINED  mmioFOURCC('\0', '\0', '\0', '\0')

MMRESULT VCMAPI vcmDriverDetails
(
    PVCMDRIVERDETAILS   pvdd
);

//--------------------------------------------------------------------------;
//
//  VCM Format Tags
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmFormatTagDetails()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define VCMFORMATTAGDETAILS_FORMATTAG_CHARS 48

typedef struct tVCMFORMATTAGDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    char            szFormatTag[VCMFORMATTAGDETAILS_FORMATTAG_CHARS];

} VCMFORMATTAGDETAILSA, *PVCMFORMATTAGDETAILSA;

typedef struct tVCMFORMATTAGDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    WCHAR           szFormatTag[VCMFORMATTAGDETAILS_FORMATTAG_CHARS];

} VCMFORMATTAGDETAILSW, *PVCMFORMATTAGDETAILSW;

#ifdef _UNICODE
#define VCMFORMATTAGDETAILS     VCMFORMATTAGDETAILSW
#define PVCMFORMATTAGDETAILS    PVCMFORMATTAGDETAILSW
#else
#define VCMFORMATTAGDETAILS     VCMFORMATTAGDETAILSA
#define PVCMFORMATTAGDETAILS    PVCMFORMATTAGDETAILSA
#endif

#define VCM_FORMATTAGDETAILSF_INDEX         0x00000000L
#define VCM_FORMATTAGDETAILSF_FORMATTAG     0x00000001L
#define VCM_FORMATTAGDETAILSF_LARGESTSIZE   0x00000002L
#define VCM_FORMATTAGDETAILSF_QUERYMASK     0x0000000FL

//--------------------------------------------------------------------------;
//
//  VCM Formats
//
//
//
//
//--------------------------------------------------------------------------;

#define VCMFORMATDETAILS_FORMAT_CHARS   128

/*****************************************************************************
 *  @doc EXTERNAL COMPSTRUCTENUM
 *
 *  @struct VCMFORMATDETAILS | The <t VCMFORMATDETAILS> structure details a
 *      video format.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t VCMFORMATDETAILS> structure. This member must be initialized
 *      before calling the <f vcmFormatDetails> or <f vcmFormatEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t VCMFORMATDETAILS> structure. When the
 *      <f vcmFormatDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFormatTag | Specifies the video format tag that the
 *      <t VCMFORMATDETAILS> structure describes. This member is always
 *      returned if the <f vcmFormatDetails> is successful. This member
 *      should be set to VIDEO_FORMAT_UNKNOWN before calling <f vcmFormatDetails>.
 *
 *  @field DWORD | dwFlags | Specifies if the format the <p pvfx> field points
 *      to is a format that can be generated by the capture driver + codec, decompressed
 *      by the codec, or both.
 *
 *      @flag VCM_FORMATENUMF_INPUT | Specifies that the format enumerated can be transmitted.
 *
 *      @flag VCM_FORMATENUMF_OUTPUT | Specifies that the format enumerated can be received.
 *
 *      @flag VCM_FORMATENUMF_BOTH | Specifies that the format enumerated can be transmitted and received.
 *
 *  @field PVIDEOFORMATEX | pvfx | Specifies a pointer to a <t VIDEOFORMATEX>
 *      data structure that will receive the format details. This structure requires no initialization
 *      by the application.
 *
 *  @field DWORD | cbvfx | Specifies the size, in bytes, available for
 *      the <e VCMFORMATDETAILS.pvfx> to receive the format details. The
 *      <f vcmMetrics> function can be used to
 *      determine the maximum size required for any format available for
 *      all installed VCM drivers.
 *
 *  @field char | szFormat[VCMFORMATDETAILS_FORMAT_CHARS] |
 *      Specifies a string that describes the format for the
 *      <e VCMFORMATDETAILS.dwFormatTag> type. This string is always returned
 *      if the <f vcmFormatDetails> function is successful.
 *
 *  @xref <f vcmFormatDetails> <f vcmFormatEnum>
 ****************************************************************************/
typedef struct tVCMFORMATDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFormatTag;
    DWORD           dwFlags;
    PVIDEOFORMATEX  pvfx;
    DWORD           cbvfx;
    WCHAR           szFormat[VCMFORMATDETAILS_FORMAT_CHARS];
} VCMFORMATDETAILS, *PVCMFORMATDETAILS;

MMRESULT VCMAPI vcmFormatDetails
(
    PVCMFORMATDETAILS   pvfd
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmFormatEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func BOOL VCMFORMATENUMCB | vcmFormatEnumCallback |
 *      The <f ccmFormatEnumCallback> function refers to the callback function used for
 *      Video Compression Manager (VCM) video format detail enumeration. The
 *      <f vcmFormatEnumCallback> is a placeholder for the application-supplied
 *      function name.
 *
 *  @parm HVCMDRIVERID | hvdid | Specifies a VCM driver identifier.
 *
 *  @parm  PVCMDRIVERDETAILS | pvfd | Specifies a pointer to a
 *      <t VCMDRIVERDETAILS> structure that contains the enumerated
 *      driver details.
 *
 *  @parm  PVCMFORMATDETAILS | pvfd | Specifies a pointer to a
 *      <t VCMFORMATDETAILS> structure that contains the enumerated
 *      format details.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f vcmFormatEnum> function.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f vcmFormatEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no formats are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f vcmFormatEnum> <f vcmFormatDetails>
 ***************************************************************************/
typedef BOOL (CALLBACK *VCMFORMATENUMCB)
(
    HVCMDRIVERID            hvdid,
    PVCMDRIVERDETAILS      pvdd,
    PVCMFORMATDETAILS      pvfd,
    DWORD_PTR              dwInstance
);

MMRESULT VCMAPI vcmFormatEnum
(
	UINT					uDevice,
	VCMFORMATENUMCB         fnCallback,
	PVCMDRIVERDETAILS       pvdd,
	PVCMFORMATDETAILS       pvfd,
	DWORD_PTR               dwInstance,
	DWORD                           fdwEnum
);

//#define VCM_FORMATENUMF_WFORMATTAG       0x00010000L
//#define VCM_FORMATENUMF_NCHANNELS        0x00020000L
//#define VCM_FORMATENUMF_NSAMPLESPERSEC   0x00040000L
//#define VCM_FORMATENUMF_WBITSPERSAMPLE   0x00080000L
//#define VCM_FORMATENUMF_CONVERT          0x00100000L
//#define VCM_FORMATENUMF_SUGGEST          0x00200000L
#define VCM_FORMATENUMF_INPUT           0x00400000L
#define VCM_FORMATENUMF_OUTPUT          0x00800000L
#define VCM_FORMATENUMF_BOTH            0x01000000L

#define VCM_FORMATENUMF_TYPEMASK        0x01C00000L

#define VCM_FORMATENUMF_APP			0x00000000L
#define VCM_FORMATENUMF_ALL			0x02000000L
#define VCM_FORMATENUMF_ALLMASK		VCM_FORMATENUMF_ALL

typedef struct
{
    WORD biWidth;
    WORD biHeight;
} MYFRAMESIZE;

typedef struct
{
	DWORD fccType;
	DWORD fccHandler;
	MYFRAMESIZE framesize[3];
} VCM_APP_ICINFO, *PVCM_APP_ICINFO;

typedef struct
{
    DWORD dwRes;
    MYFRAMESIZE framesize;
} NCAP_APP_INFO, *PNCAP_APP_INFO;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmFormatSuggest()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmFormatSuggest
(
	UINT				uDevice,
    HVCMDRIVER          hvd,
    PVIDEOFORMATEX      pvfxSrc,
    PVIDEOFORMATEX      pvfxDst,
    DWORD               cbvfxDst,
    DWORD               fdwSuggest
);

#define VCM_FORMATSUGGESTF_DST_WFORMATTAG       0x00010000L
#define VCM_FORMATSUGGESTF_DST_NSAMPLESPERSEC   0x00020000L
#define VCM_FORMATSUGGESTF_DST_WBITSPERSAMPLE   0x00040000L

#define VCM_FORMATSUGGESTF_SRC_WFORMATTAG       0x00100000L
#define VCM_FORMATSUGGESTF_SRC_NSAMPLESPERSEC   0x00200000L
#define VCM_FORMATSUGGESTF_SRC_WBITSPERSAMPLE   0x00400000L

#define VCM_FORMATSUGGESTF_TYPEMASK         0x00FF0000L


//--------------------------------------------------------------------------;
//
//  VCM Stream API's
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamOpen()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

/*****************************************************************************
 *  @doc EXTERNAL COMPSTRUCTENUM
 *
 *  @struct VCMSTREAMHEADER | The <t VCMSTREAMHEADER> structure defines the
 *      header used to identify an Video Compression Manager (VCM) conversion
 *      source and destination buffer pair for a conversion stream.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t VCMSTREAMHEADER> structure. This member must be initialized
 *      before calling any VCM stream functions using this structure.
 *      The size specified in this member must be large enough to contain
 *      the base <t VCMSTREAMHEADER> structure.
 *
 *  @field DWORD | fdwStatus | Specifies flags giving information about
 *      the conversion buffers. This member must be initialized to zero
 *      before calling <f vcmStreamPrepareHeader> and should not be modified
 *      by the application while the stream header remains prepared.
 *
 *      @flag VCMSTREAMHEADER_STATUSF_DONE | Set by the VCM or driver to
 *      indicate that it is finished with the conversion and is returning it
 *      to the application.
 *
 *      @flag VCMSTREAMHEADER_STATUSF_PREPARED | Set by the VCM to indicate
 *      that the data buffers have been prepared with <f acmStreamPrepareHeader>.
 *
 *      @flag VCMSTREAMHEADER_STATUSF_INQUEUE | Set by the VCM or driver to
 *      indicate that the data buffers are queued for conversion.
 *
 *  @field DWORD | dwUser | Specifies 32 bits of user data. This can be any
 *      instance data specified by the application.
 *
 *  @field PBYTE | pbSrc | Specifies a pointer to the source data buffer.
 *      This pointer must always refer to the same location while the stream
 *      header remains prepared. If an application needs to change the
 *      source location, it must unprepare the header and re-prepare it
 *      with the alternate location.
 *
 *  @field DWORD | cbSrcLength | Specifies the length, in bytes, of the source
 *      data buffer pointed to by <e VCMSTREAMHEADER.pbSrc>. When the
 *      header is prepared, this member must specify the maximum size
 *      that will be used in the source buffer. Conversions can be performed
 *      on source lengths less than or equal to the original prepared size.
 *      However, this member must be reset to the original size when
 *      unpreparing the header.
 *
 *  @field DWORD | cbSrcLengthUsed | Specifies the amount of data, in bytes,
 *      used for the conversion. This member is not valid until the
 *      conversion is complete. Note that this value can be less than or
 *      equal to <e VCMSTREAMHEADER.cbSrcLength>. An application must use
 *      the <e VCMSTREAMHEADER.cbSrcLengthUsed> member when advancing to
 *      the next piece of source data for the conversion stream.
 *
 *  @field DWORD | dwSrcUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field PBYTE | pbDst | Specifies a pointer to the destination data
 *      buffer. This pointer must always refer to the same location while
 *      the stream header remains prepared. If an application needs to change
 *      the destination location, it must unprepare the header and re-prepare
 *      it with the alternate location.
 *
 *  @field DWORD | cbDstLength | Specifies the length, in bytes, of the
 *      destination data buffer pointed to by <e VCMSTREAMHEADER.pbDst>.
 *      When the header is prepared, this member must specify the maximum
 *      size that will be used in the destination buffer. Conversions can be
 *      performed to destination lengths less than or equal to the original
 *      prepared size. However, this member must be reset to the original
 *      size when unpreparing the header.
 *
 *  @field DWORD | cbDstLengthUsed | Specifies the amount of data, in bytes,
 *      returned by a conversion. This member is not valid until the
 *      conversion is complete. Note that this value may be less than or
 *      equal to <e ACMSTREAMHEADER.cbDstLength>. An application must use
 *      the <e ACMSTREAMHEADER.cbDstLengthUsed> member when advancing to
 *      the next destination location for the conversion stream.
 *
 *  @field DWORD | dwDstUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field PBYTE | pbPrev | Specifies a pointer to the previous destination data
 *      buffer. This pointer must always refer to the same location while
 *      the stream header remains prepared. If an application needs to change
 *      the destination location, it must unprepare the header and re-prepare
 *      it with the alternate location.
 *
 *  @field DWORD | cbPrevLength | Specifies the length, in bytes, of the previous
 *      destination data buffer pointed to by <e VCMSTREAMHEADER.pbPrev>.
 *      When the header is prepared, this member must specify the maximum
 *      size that will be used in the destination buffer. Conversions can be
 *      performed to destination lengths less than or equal to the original
 *      prepared size. However, this member must be reset to the original
 *      size when unpreparing the header.
 *
 *  @field DWORD | cbPrevLengthUsed | Specifies the amount of data, in bytes,
 *      returned by a conversion. This member is not valid until the
 *      conversion is complete. Note that this value may be less than or
 *      equal to <e VCMSTREAMHEADER.cbPrevLength>. An application must use
 *      the <e VCMSTREAMHEADER.cbPrevLengthUsed> member when advancing to
 *      the next destination location for the conversion stream.
 *
 *  @field DWORD | dwDstUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field struct tVCMSTREAMHEADER * | lpNext | Reserved for driver use and should not be
 *      used. Typically, this maintains a linked list of buffers in the queue.
 *
 *  @field DWORD | reserved | Reserved for driver use and should not be used.
 *
 *  @type PVCMSTREAMHEADER | Pointer to a <t VCMSTREAMHEADER> structure.
 *
 *  @comm Before an <t VCMSTREAMHEADER> structure can be used for a conversion, it must
 *      be prepared with <f vcmStreamPrepareHeader>. When an application
 *      is finished with an <t VCMSTREAMHEADER> structure, the <f vcmStreamUnprepareHeader>
 *      function must be called before freeing the source and destination buffers.
 *
 *  @xref <f vcmStreamPrepareHeader> <f vcmStreamUnprepareHeader>
 *      <f vcmStreamConvert>
 ****************************************************************************/
typedef struct tVCMSTREAMHEADER
{
    DWORD           cbStruct;               // sizeof(VCMSTREAMHEADER)
    DWORD           fdwStatus;                          // status flags
    DWORD           dwUser;                 // user instance data for hdr
    PBYTE           pbSrc;
    DWORD           cbSrcLength;
    DWORD           cbSrcLengthUsed;
    DWORD           dwSrcUser;              // user instance data for src
    PBYTE           pbDst;
    DWORD           cbDstLength;
    DWORD           cbDstLengthUsed;
    DWORD           dwDstUser;              // user instance data for dst
    PBYTE           pbPrev;
    DWORD           cbPrevLength;
    DWORD           cbPrevLengthUsed;
    DWORD           dwPrevUser;             // user instance data for prev
    struct tVCMSTREAMHEADER *pNext;             // reserved for driver
    DWORD                       reserved;               // reserved for driver
} VCMSTREAMHEADER, *PVCMSTREAMHEADER;

typedef struct tVCMSTREAM
{
	HVCMDRIVER				hIC;				// Handle to driver (HIC)
	DWORD					dwICInfoFlags;		// Some properties of the compressor
	HWND					hWndParent;			// Handle to the parent window
	DWORD_PTR				dwCallback;			// Callback function, event, thread or window
	DWORD_PTR				dwCallbackInstance;	// User instance data
	DWORD					fdwOpen;			// Defines type of callback
	struct tVCMSTREAMHEADER	*pvhLast;			// Last of the list
	struct tVCMSTREAMHEADER	*pvhFirst;			// First of the list
	PVIDEOFORMATEX			pvfxSrc;			// Format of input buffers
	PVIDEOFORMATEX			pvfxDst;			// Format of output buffers
	BITMAPINFOHEADER		*pbmiPrev;			// Format of previous buffers
	UINT					cSrcPrepared;		// Number of input headers prepared
	UINT					cDstPrepared;		// Number of output headers prepared
	DWORD					dwFrame;			// Current frame number
	DWORD					dwQuality;			// Compression quality value
	DWORD					dwMaxPacketSize;	// Targeted max packet size for encode
	DWORD					fdwStream;			// Stream state flags, etc.
	CRITICAL_SECTION		crsFrameNumber;		// Used to allow the UI to request an I-Frame
	DWORD					dwLastTimestamp;	// Last known good timestamp
	DWORD					dwTargetByterate;	// Target bitrate
	DWORD					dwTargetFrameRate;	// Target frame rate
	BOOL					fPeriodicIFrames;	// Set to TRUE if we need to generate I-Frames periodically
	DWORD					dwLastIFrameTime;	// Holds the last time an I-Frame was generated
} VCMSTREAM, *PVCMSTREAM;

//
//  VCMSTREAMHEADER.fdwStatus
//
//  VCMSTREAMHEADER_STATUSF_DONE: done bit for async conversions.
//
#define VCMSTREAMHEADER_STATUSF_DONE        0x00010000L
#define VCMSTREAMHEADER_STATUSF_PREPARED    0x00020000L
#define VCMSTREAMHEADER_STATUSF_INQUEUE     0x00100000L

MMRESULT VCMAPI vcmStreamOpen
(
    PHVCMSTREAM             phas,			// pointer to stream handle
    HVCMDRIVER              had,			// optional driver handle
    PVIDEOFORMATEX          pvfxSrc,		// source format to convert
    PVIDEOFORMATEX          pvfxDst,		// required destination format
    DWORD                   dwImageQuality, // image compression factor
    DWORD					dwPacketSize,	// target fragment size
    DWORD_PTR               dwCallback,		// callback
    DWORD_PTR               dwInstance,		// callback instance data
    DWORD                   fdwOpen			// VCM_STREAMOPENF_* and CALLBACK_*
);

#define VCM_STREAMOPENF_QUERY           0x00000001
#define VCM_STREAMOPENF_ASYNC           0x00000002
#define VCM_STREAMOPENF_NONREALTIME     0x00000004

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamClose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamClose
(
    HVCMSTREAM              hvs
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamSize()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamSize
(
    HVCMSTREAM              has,
    DWORD                   cbInput,
    PDWORD                  pdwOutputBytes,
    DWORD                   fdwSize
);

#define VCM_STREAMSIZEF_SOURCE          0x00000000L
#define VCM_STREAMSIZEF_DESTINATION     0x00000001L
#define VCM_STREAMSIZEF_QUERYMASK       0x0000000FL

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamReset()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamReset
(
    HVCMSTREAM              has
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamMessage()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamMessage
(
    HVCMSTREAM              has,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamConvert()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamConvert
(
    HVCMSTREAM              has,
    PVCMSTREAMHEADER       pash,
    DWORD                   fdwConvert
);

#define VCM_STREAMCONVERTF_BLOCKALIGN           0x00000004
#define VCM_STREAMCONVERTF_START                        0x00000010
#define VCM_STREAMCONVERTF_END                          0x00000020
#define VCM_STREAMCONVERTF_FORCE_KEYFRAME   0x00000040

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamPrepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamPrepareHeader
(
    HVCMSTREAM          has,
    PVCMSTREAMHEADER   pash,
    DWORD               fdwPrepare
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamUnprepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamUnprepareHeader
(
    HVCMSTREAM          has,
    PVCMSTREAMHEADER   pash,
    DWORD               fdwUnprepare
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Device Capabilities Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmGetDevCaps(UINT uDevice, PVIDEOINCAPS pvc, UINT cbvc);
MMRESULT VCMAPI vcmDevCapsReadFromReg(LPSTR szDeviceName, LPSTR szDeviceVersion, PVIDEOINCAPS pvc, UINT cbvc);
MMRESULT VCMAPI vcmDevCapsProfile(UINT uDevice, PVIDEOINCAPS pvc, UINT cbvc);
MMRESULT VCMAPI vcmDevCapsWriteToReg(LPSTR szDeviceName, LPSTR szDeviceVersion, PVIDEOINCAPS pvc, UINT cbvc);
MMRESULT VCMAPI vcmGetDevCapsFrameSize(PVIDEOFORMATEX pvfx, PINT piWidth, PINT piHeight);
MMRESULT VCMAPI vcmGetDevCapsPreferredFormatTag(UINT uDevice, PDWORD pdwFormatTag);
MMRESULT VCMAPI vcmGetDevCapsStreamingMode(UINT uDevice, PDWORD pdwStreamingMode);
MMRESULT VCMAPI vcmGetDevCapsDialogs(UINT uDevice, PDWORD pdwDialogs);
MMRESULT VCMAPI vcmReleaseResources();

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Post-processing Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

BOOL VCMAPI vcmStreamIsPostProcessingSupported(HVCMSTREAM hvs);
MMRESULT VCMAPI vcmStreamSetBrightness(HVCMSTREAM hvs, DWORD dwBrightness);
MMRESULT VCMAPI vcmStreamSetContrast(HVCMSTREAM hvs, DWORD dwContrast);
MMRESULT VCMAPI vcmStreamSetSaturation(HVCMSTREAM hvs, DWORD dwSaturation);
MMRESULT VCMAPI vcmStreamSetImageQuality(HVCMSTREAM hvs, DWORD dwImageQuality);

#define PLAYBACK_CUSTOM_START				(ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS	(PLAYBACK_CUSTOM_START + 0)
#define PLAYBACK_CUSTOM_CHANGE_CONTRAST		(PLAYBACK_CUSTOM_START + 1)
#define PLAYBACK_CUSTOM_CHANGE_SATURATION	(PLAYBACK_CUSTOM_START + 2)

#define	G723MAGICWORD1							0xf7329ace
#define	G723MAGICWORD2							0xacdeaea2
#define CUSTOM_ENABLE_CODEC						(ICM_RESERVED_HIGH+201)

#define VCM_MAX_BRIGHTNESS		255UL
#define VCM_MIN_BRIGHTNESS		1UL
#define VCM_RESET_BRIGHTNESS	256UL
#define VCM_DEFAULT_BRIGHTNESS	128UL
#define VCM_MAX_CONTRAST		255UL
#define VCM_MIN_CONTRAST		1UL
#define VCM_RESET_CONTRAST		256UL
#define VCM_DEFAULT_CONTRAST	128UL
#define VCM_MAX_SATURATION		255UL
#define VCM_MIN_SATURATION		1UL
#define VCM_RESET_SATURATION	256UL
#define VCM_DEFAULT_SATURATION	128UL

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Custom Encoder Control Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamSetMaxPacketSize(HVCMSTREAM hvs, DWORD dwMaxPacketSize);

#define CUSTOM_START					(ICM_RESERVED_HIGH + 1)
#define CODEC_CUSTOM_ENCODER_CONTROL	(CUSTOM_START      + 9)

// CUSTOM_ENCODER_CONTROL: HIWORD(lParam1)
#define EC_SET_CURRENT               0
#define EC_GET_FACTORY_DEFAULT       1
#define EC_GET_FACTORY_LIMITS        2
#define EC_GET_CURRENT               3
#define EC_RESET_TO_FACTORY_DEFAULTS 4

// CUSTOM_ENCODER_CONTROL: LOWORD(lParam1)
#define EC_RTP_HEADER                0
#define EC_RESILIENCY                1
#define EC_PACKET_SIZE               2
#define EC_PACKET_LOSS               3
#define EC_BITRATE_CONTROL			 4
#define EC_BITRATE					 5

#define VCM_MAX_PACKET_SIZE		9600UL
#define VCM_MIN_PACKET_SIZE		64UL
#define VCM_RESET_PACKET_SIZE	512UL
#define VCM_DEFAULT_PACKET_SIZE	512UL

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Compression Ratio and Compression Options Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamSetImageQuality(HVCMSTREAM hvs, DWORD dwImageQuality);
MMRESULT VCMAPI vcmStreamRequestIFrame(HVCMSTREAM hvs);
MMRESULT VCMAPI vcmStreamPeriodicIFrames(HVCMSTREAM hvs, BOOL fPeriodicIFrames);
MMRESULT VCMAPI vcmStreamSetTargetRates(HVCMSTREAM hvs, DWORD dwTargetFrameRate, DWORD dwTargetByterate);

#define MIN_IFRAME_REQUEST_INTERVAL 15000

#define VCM_MAX_IMAGE_QUALITY		0UL
#define VCM_MIN_IMAGE_QUALITY		31UL

#define VCM_RESET_IMAGE_QUALITY		VCM_MAX_IMAGE_QUALITY
#define VCM_DEFAULT_IMAGE_QUALITY	VCM_MAX_IMAGE_QUALITY

#define VCM_MAX_FRAME_RATE			2997UL
#define VCM_MIN_FRAME_RATE			20UL
#define VCM_RESET_FRAME_RATE		700UL
#define VCM_DEFAULT_FRAME_RATE		700UL
#define VCM_MAX_BYTE_RATE			187500UL
#define VCM_MIN_BYTE_RATE			1UL
#define VCM_RESET_BYTE_RATE			1664UL
#define VCM_DEFAULT_BYTE_RATE		1664UL
#define VCM_MAX_FRAME_SIZE			32768UL
#define VCM_MIN_FRAME_SIZE			1UL
#define VCM_RESET_FRAME_SIZE		235UL
#define VCM_DEFAULT_FRAME_SIZE		235UL
#define VCM_MAX_TRADE_OFF			31UL
#define VCM_MIN_TRADE_OFF			1UL
#define VCM_RESET_TRADE_OFF			31UL
#define VCM_DEFAULT_TRADE_OFF		31UL


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  RTP Payload Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamFormatPayload(HVCMSTREAM hvs, PBYTE pDataSrc, DWORD dwDataSize, PBYTE *ppDataPkt, PDWORD pdwPktSize,
				       PDWORD pdwPktCount, UINT *pfMark, PBYTE *pHdrInfo,PDWORD pdwHdrSize);
MMRESULT VCMAPI vcmStreamRestorePayload(HVCMSTREAM hvs, WSABUF *ppDataPkt, DWORD dwPktCount, PBYTE pbyFrame, PDWORD pdwFrameSize, BOOL *pfReceivedKeyframe);
MMRESULT VCMAPI vcmStreamGetPayloadHeaderSize(HVCMSTREAM hvs, PDWORD pdwPayloadHeaderSize);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#pragma pack()          /* Revert to default packing */

#endif  /* _INC_VCM */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\gcc.h ===
/*
 *	gcc.h
 *
 *	Copyright (c) 1994, 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the GCC DLL.  This file defines all
 *		macros, types, and functions needed to use the GCC DLL, allowing GCC
 *		services to be accessed from user applications. 
 *
 *		An application requests services from GCC by making direct
 *		calls into the DLL (this includes T.124 requests and responses).  GCC
 *		sends information back to the application through a callback (this
 *		includes T.124 indications and confirms).  The callback for the node
 *		controller is specified in the call GCCInitialize, and the callback
 *		for a particular application service access point is specified in the 
 *		call GCCRegisterSAP.
 *
 *		During initialization, GCC allocates a timer in order to give itself
 *		a heartbeat. If zero is passed in here the owner application (the node 
 *		controller) must take the responsibility to call GCCHeartbeat.  Almost 
 *		all work is done by GCC during these clocks ticks. It is during these 
 *		clock ticks that GCC checks with MCS to see if there is any work to be 
 *		done.  It is also during these clock ticks that callbacks are made to 
 *		the user applications.  GCC will NEVER invoke a user callback during a 
 *		user request (allowing the user applications to not worry about 
 *		re-entrancy).  Since timer events are processed during the message 
 *		loop, the developer should be aware that long periods of time away 
 *		from the message loop will result in GCC "freezing" up.
 *
 *		Note that this is a "C" language interface in order to prevent any "C++"
 *		naming conflicts between different compiler manufacturers.  Therefore,
 *		if this file is included in a module that is being compiled with a "C++"
 *		compiler, it is necessary to use the following syntax:
 *
 *		extern "C"
 *		{
 *			#include "gcc.h"
 *		}
 *
 *		This disables C++ name mangling on the API entry points defined within
 *		this file.
 *
 *	Author:
 *		blp
 *
 *	Caveats:
 *		none
 */
#ifndef	__GCC_H__
#define	__GCC_H__

#include "t120type.h"

/************************************************************************
*																		*
*					Generally Used Typedefs								*
*																		*
*************************************************************************/

#define NM_T120_VERSION_3		(MAKELONG(0, 3))	// NM 3.0

typedef struct tagOSTR
{
    ULONG       length;
    LPBYTE      value;
}
    OSTR, *LPOSTR;

/*
**	Typedef for a GCC hex string.  This typedef is used throughout GCC for
**	storing	variable length wide character strings with embedded NULLs.
*/
typedef struct
{
	UINT                hex_string_length;
	USHORT           *  hex_string;
}
    T120HexString, GCCHexString, *PGCCHexString;

/*
**	Typedef for a GCC long string.  This typedef is used in GCC for
**	storing	variable length strings of longs with embedded NULLs.
*/
typedef struct tagT120LongString
{
	ULONG               long_string_length;
	ULONG         *     long_string;
}
    T120LongString, GCCLongString, *PGCCLongString;


/*
 *	TransportAddress is passed in with the ConnectRequest() call.
 *	This address is always a pointer to an ascii string.
 *	The TransportAddress represents a remote location.  It is the TCP
 *	address of the remote machine.
 *
 */
typedef	LPSTR       TransportAddress, *PTransportAddress;


/*
**	Typedef for a GCC Character string.  This typedef is used throughout GCC for
**	storing	variable length, NULL terminated, single byte character strings.
*/
// lonchanc: we should simply use char.
typedef BYTE        GCCCharacter, *GCCCharacterString, **PGCCCharacterString;

/*
**	Typedef for a GCC Numeric string.  This typedef is used throughout GCC for
**	storing	variable length, NULL terminated, single byte character strings.
**	A single character in this string is constrained to numeric values 
**	ranging from "0" to "9".
*/
typedef LPSTR       GCCNumericString, *PGCCNumericString;

/*
**	Typdef for GCC version which is used when registering the node controller
**	or an application.
*/
typedef	struct
{
	USHORT	major_version;
	USHORT	minor_version;
}
    GCCVersion, *PGCCVersion;



/* 
** Macros for values of Booleans passed through the GCC API.
*/
#define		CONFERENCE_IS_LOCKED					TRUE
#define		CONFERENCE_IS_NOT_LOCKED				FALSE
#define		CONFERENCE_IS_LISTED					TRUE
#define		CONFERENCE_IS_NOT_LISTED				FALSE
#define		CONFERENCE_IS_CONDUCTIBLE				TRUE
#define		CONFERENCE_IS_NOT_CONDUCTIBLE			FALSE
#define		PERMISSION_IS_GRANTED					TRUE
#define		PERMISSION_IS_NOT_GRANTED				FALSE
#define		TIME_IS_CONFERENCE_WIDE					TRUE
#define		TIME_IS_NOT_CONFERENCE_WIDE				FALSE
#define		APPLICATION_IS_ENROLLED_ACTIVELY		TRUE
#define		APPLICATION_IS_NOT_ENROLLED_ACTIVELY	FALSE
#define		APPLICATION_IS_CONDUCTING				TRUE
#define		APPLICATION_IS_NOT_CONDUCTING_CAPABLE	FALSE
#define		APPLICATION_IS_ENROLLED					TRUE
#define		APPLICATION_IS_NOT_ENROLLED				FALSE
#define		DELIVERY_IS_ENABLED						TRUE
#define		DELIVERY_IS_NOT_ENABLED					FALSE

/*
**	The following enum structure typedefs are used to define the GCC Object Key.
**	The GCC Object Key is used throughout GCC for things like the Application
**	keys and Capability IDs.
*/

typedef AppletKeyType               GCCObjectKeyType, *PGCCObjectKeyType;;
#define GCC_OBJECT_KEY              APPLET_OBJECT_KEY
#define GCC_H221_NONSTANDARD_KEY    APPLET_H221_NONSTD_KEY


typedef struct tagT120ObjectKey
{
    GCCObjectKeyType	key_type;
    GCCLongString		object_id;
    OSTR        		h221_non_standard_id;
}
    T120ObjectKey, GCCObjectKey, *PGCCObjectKey;

/*
**	GCCNonStandardParameter
**		This structure is used within the NetworkAddress typedef and
**		the NetworkService typedef defined below.
*/
typedef struct 
{
	GCCObjectKey		object_key;
	OSTR        		parameter_data;
}
    GCCNonStandardParameter, *PGCCNonStandardParameter;


/*
**	GCCConferenceName
**		This structure defines the conference name.  In a create request, the
**		conference name can include an optional unicode string but it must 
**		always include the simple numeric string.  In a join request, either
**		one can be specified.
*/
typedef struct
{
	GCCNumericString		numeric_string;
	LPWSTR					text_string;			/* optional */
}
    GCCConferenceName, GCCConfName, *PGCCConferenceName, *PGCCConfName;

/*
**	MCSChannelType
**		Should this be defined in MCATMCS?  It is used in a couple of places
**		below and is explicitly defined in the T.124 specification.
*/
typedef AppletChannelType               MCSChannelType, *PMCSChannelType;
#define MCS_STATIC_CHANNEL              APPLET_STATIC_CHANNEL
#define MCS_DYNAMIC_MULTICAST_CHANNEL   APPLET_DYNAMIC_MULTICAST_CHANNEL
#define MCS_DYNAMIC_PRIVATE_CHANNEL     APPLET_DYNAMIC_PRIVATE_CHANNEL
#define MCS_DYNAMIC_USER_ID_CHANNEL     APPLET_DYNAMIC_USER_ID_CHANNEL
#define MCS_NO_CHANNEL_TYPE_SPECIFIED   APPLET_NO_CHANNEL_TYPE_SPECIFIED

/*
**	GCCUserData
**		This structure defines a user data element which is used throughout GCC.
*/
typedef struct
{
	GCCObjectKey		key;
	LPOSTR          	octet_string;	/* optional */
}
    GCCUserData, *PGCCUserData;


/************************************************************************
*																		*
*					Node Controller Related Typedefs					*
*																		*
*************************************************************************/

/*
**	GCCTerminationMethod
**		The termination method is used by GCC to determine
**		what action to take when all participants of a conference have
**		disconnected.  The conference can either be manually terminated
**		by the node controller or it can terminate itself automatically when 
**		all the participants have left the conference.
*/
typedef enum
{
	GCC_AUTOMATIC_TERMINATION_METHOD 		= 0, 
	GCC_MANUAL_TERMINATION_METHOD 	 		= 1
}
    GCCTerminationMethod, *PGCCTerminationMethod;

/*
**	GCCNodeType
**		GCC specified node types.  These node types dictate node controller	  
**		behavior under certain conditions.  See T.124 specification for
**		proper assignment based on the needs of the Node Controller.
*/
typedef enum
{
	GCC_TERMINAL							= 0,
	GCC_MULTIPORT_TERMINAL					= 1,
	GCC_MCU									= 2
}
    GCCNodeType, *PGCCNodeType;

/*
**	GCCNodeProperties
**		GCC specified node properties.  See T.124 specification for proper
**		assignment by the Node Controller.
*/
typedef enum
{
	GCC_PERIPHERAL_DEVICE					= 0,
	GCC_MANAGEMENT_DEVICE					= 1,
	GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE	= 2,
	GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT	= 3
}
    GCCNodeProperties, *PGCCNodeProperties;

/*
**	GCCPassword
**		This is the unique password specified by the convenor of the
**		conference that is used by the node controller to insure conference
**		security. This is also a unicode string.
*/
typedef	struct
{
	GCCNumericString	numeric_string;
	LPWSTR				text_string;	/* optional */
}
    GCCPassword, *PGCCPassword;

/*
**	GCCChallengeResponseItem
**		This structure defines what a challenge response should look like.
**		Note that either a password string or response data should be passed
**		but not both.
*/
typedef struct
{
    GCCPassword		*		password_string;
	USHORT      			number_of_response_data_members;
	GCCUserData		**		response_data_list;
}
    GCCChallengeResponseItem, *PGCCChallengeResponseItem;

typedef	enum
{
	GCC_IN_THE_CLEAR_ALGORITHM	= 0,
	GCC_NON_STANDARD_ALGORITHM	= 1
}
    GCCPasswordAlgorithmType, *PGCCPasswordAlgorithmType;

typedef struct 
{
    GCCPasswordAlgorithmType		password_algorithm_type;
	GCCNonStandardParameter	*		non_standard_algorithm;	/* optional */
}
    GCCChallengeResponseAlgorithm, *PGCCChallengeResponseAlgorithm;

typedef struct 
{
    GCCChallengeResponseAlgorithm	response_algorithm;
	USHORT      					number_of_challenge_data_members;
	GCCUserData				**		challenge_data_list;
}
    GCCChallengeItem, *PGCCChallengeItem;

typedef struct 
{
    GCCResponseTag			challenge_tag;
	USHORT      			number_of_challenge_items;
	GCCChallengeItem	**	challenge_item_list;
}
    GCCChallengeRequest, *PGCCChallengeRequest;

typedef struct 
{
    GCCResponseTag						challenge_tag;
    GCCChallengeResponseAlgorithm		response_algorithm;
    GCCChallengeResponseItem			response_item;
}
    GCCChallengeResponse, *PGCCChallengeResponse;


typedef	enum
{
	GCC_PASSWORD_IN_THE_CLEAR	= 0,
	GCC_PASSWORD_CHALLENGE 		= 1
}
    GCCPasswordChallengeType, *PGCCPasswordChallengeType;

typedef struct 
{
	GCCPasswordChallengeType	password_challenge_type;
	
	union 
    {
        GCCPassword			password_in_the_clear;
        
        struct 
        {
            GCCChallengeRequest		*	challenge_request;	/* optional */
            GCCChallengeResponse	*	challenge_response;	/* optional */
        } challenge_request_response;
    } u;
}
    GCCChallengeRequestResponse, *PGCCChallengeRequestResponse;

/*
**	GCCAsymmetryType
**		Used in queries to determine if the calling and called node are known
**		by both Node Controllers involved with the connection.
*/
typedef enum
{
	GCC_ASYMMETRY_CALLER				= 1,
	GCC_ASYMMETRY_CALLED				= 2,
	GCC_ASYMMETRY_UNKNOWN				= 3
}
    GCCAsymmetryType, *PGCCAsymmetryType;

/*
**	GCCAsymmetryIndicator
**		Defines how the Node Controller sees itself when making a Query
**		request or response.  The random number portion of this structure is
**		only used if the asymmetry_type is specified to be 
**		GCC_ASYMMETRY_UNKNOWN.
*/
typedef struct
{
	GCCAsymmetryType	asymmetry_type;
	unsigned long		random_number;		/* optional */
}
    GCCAsymmetryIndicator, *PGCCAsymmetryIndicator;

/*
**	GCCNetworkAddress
**		The following block of structures defines the Network Address as defined 
**		by T.124.  Most of these structures were taken almost verbatim from the
**		ASN.1 interface file.  Since I'm not really sure what most of this stuff
**		is for I really didn't know how to simplify it.
*/
typedef	struct 
{
    BOOL         speech;
    BOOL         voice_band;
    BOOL         digital_56k;
    BOOL         digital_64k;
    BOOL         digital_128k;
    BOOL         digital_192k;
    BOOL         digital_256k;
    BOOL         digital_320k;
    BOOL         digital_384k;
    BOOL         digital_512k;
    BOOL         digital_768k;
    BOOL         digital_1152k;
    BOOL         digital_1472k;
    BOOL         digital_1536k;
    BOOL         digital_1920k;
    BOOL         packet_mode;
    BOOL         frame_mode;
    BOOL         atm;
}
    GCCTransferModes, *PGCCTransferModes;

#define		MAXIMUM_DIAL_STRING_LENGTH		17
typedef char	GCCDialingString[MAXIMUM_DIAL_STRING_LENGTH];

typedef struct 
{
    USHORT                  length;
    USHORT          *       value;
}
    GCCExtraDialingString, *PGCCExtraDialingString;

typedef	struct 
{
    BOOL         telephony3kHz;
    BOOL         telephony7kHz;
    BOOL         videotelephony;
    BOOL         videoconference;
    BOOL         audiographic;
    BOOL         audiovisual;
    BOOL         multimedia;
}
    GCCHighLayerCompatibility, *PGCCHighLayerCompatibility;

typedef	struct 
{
    GCCTransferModes				transfer_modes;
    GCCDialingString   				international_number;
    GCCCharacterString				sub_address_string;  		/* optional */
    GCCExtraDialingString		*	extra_dialing_string;  		/* optional */
  	GCCHighLayerCompatibility 	*	high_layer_compatibility;	/* optional */
}
    GCCAggregatedChannelAddress, *PGCCAggregatedChannelAddress;

#define		MAXIMUM_NSAP_ADDRESS_SIZE		20
typedef struct 
{
    struct 
    {
        UINT    length;
        BYTE    value[MAXIMUM_NSAP_ADDRESS_SIZE];
    } nsap_address;
   
	LPOSTR              transport_selector;				/* optional */
}
    GCCTransportConnectionAddress, *PGCCTransportConnectionAddress;

typedef enum
{
	GCC_AGGREGATED_CHANNEL_ADDRESS		= 1,
	GCC_TRANSPORT_CONNECTION_ADDRESS	= 2,
	GCC_NONSTANDARD_NETWORK_ADDRESS		= 3
}
    GCCNetworkAddressType, *PGCCNetworkAddressType;

typedef struct
{
    GCCNetworkAddressType  network_address_type;
    
    union 
    {
		GCCAggregatedChannelAddress		aggregated_channel_address;
		GCCTransportConnectionAddress	transport_connection_address;
        GCCNonStandardParameter			non_standard_network_address;
    } u;
}
    GCCNetworkAddress, *PGCCNetworkAddress;

/*
**	GCCNodeRecord
**		This structure defines a single conference roster record.  See the
**		T.124 specification for parameter definitions.
*/
typedef struct
{
	UserID					node_id;
	UserID					superior_node_id;
	GCCNodeType				node_type;
	GCCNodeProperties		node_properties;
	LPWSTR					node_name; 					/* optional */
	USHORT      			number_of_participants;
	LPWSTR			 	*	participant_name_list; 		/* optional */	
	LPWSTR					site_information; 			/* optional */
	UINT        			number_of_network_addresses;
	GCCNetworkAddress 	**	network_address_list;		/* optional */
	LPOSTR                  alternative_node_id;		/* optional */
	USHORT      			number_of_user_data_members;
	GCCUserData			**	user_data_list;				/* optional */
}
    GCCNodeRecord, *PGCCNodeRecord;

/*
**	GCCConferenceRoster
**		This structure hold a complete conference roster.  See the
**		T.124 specification for parameter definitions.
*/

typedef struct
{  
	USHORT  		instance_number;
	BOOL 			nodes_were_added;
	BOOL 			nodes_were_removed;
	USHORT			number_of_records;
	GCCNodeRecord		 **	node_record_list;
}
    GCCConferenceRoster, *PGCCConferenceRoster, GCCConfRoster, *PGCCConfRoster;

/*
**	GCCConferenceDescriptor
**		Definition for the conference descriptor returned in a 
**		conference query confirm.  This holds information about the
**		conferences that exists at the queried node.
*/
typedef struct
{
	GCCConferenceName		conference_name;
	GCCNumericString		conference_name_modifier;	/* optional */
	LPWSTR					conference_descriptor;		/* optional */
	BOOL				conference_is_locked;
	BOOL				password_in_the_clear_required;
	UINT    			number_of_network_addresses;
	GCCNetworkAddress **	network_address_list;		/* optional */
}
    GCCConferenceDescriptor, *PGCCConferenceDescriptor, GCCConfDescriptor, *PGCCConfDescriptor;

/*
**	ConferencePrivileges
**		This structure defines the list of privileges that can be assigned to
**		a particular conference. 
*/
typedef struct
{
	BOOL		terminate_is_allowed;
	BOOL		eject_user_is_allowed;
	BOOL		add_is_allowed;
	BOOL		lock_unlock_is_allowed;
	BOOL		transfer_is_allowed;
}
    GCCConferencePrivileges, *PGCCConferencePrivileges, GCCConfPrivileges, *PGCCConfPrivileges;

/************************************************************************
*																		*
*					User Application Related Typedefs					*
*																		*
*************************************************************************/

/*
**	GCCSessionKey
**		This is a unique identifier for an application that is
**		using GCC.  See the T.124 for the specifics on what an application
**		key should look like.  A session id of zero indicates that it is
**		not being used.
*/
typedef struct tagT120SessionKey
{
	GCCObjectKey		application_protocol_key;
	GCCSessionID		session_id;
}
    T120SessionKey, GCCSessionKey, *PGCCSessionKey;


/*
**	CapabilityType
**		T.124 supports three different rules when collapsing the capabilities
**		list.  "Logical" keeps a count of the Application Protocol Entities 
**		(APEs) that have that capability, "Unsigned Minimum" collapses to the 
**		minimum value and "Unsigned	Maximum" collapses to the maximum value.		
*/
typedef AppletCapabilityType            GCCCapabilityType, GCCCapType, *PGCCCapabilityType, *PGCCCapType;
#define GCC_UNKNOWN_CAP_TYPE            APPLET_UNKNOWN_CAP_TYPE
#define GCC_LOGICAL_CAPABILITY          APPLET_LOGICAL_CAPABILITY
#define GCC_UNSIGNED_MINIMUM_CAPABILITY APPLET_UNSIGNED_MINIMUM_CAPABILITY
#define GCC_UNSIGNED_MAXIMUM_CAPABILITY APPLET_UNSIGNED_MAXIMUM_CAPABILITY

typedef AppletCapIDType             T120CapabilityIDType, T120CapIDType, GCCCapabilityIDType, GCCCapIDType, *PGCCCapabilityIDType, *PGCCCapIDType;
#define GCC_STANDARD_CAPABILITY     APPLET_STANDARD_CAPABILITY
#define GCC_NON_STANDARD_CAPABILITY APPLET_NONSTD_CAPABILITY


/*
**	CapabilityID
**		T.124 supports both standard and non-standard capabilities.  This
**		structure is used to differentiate between the two.		
*/
typedef struct tagT120CapID
{
    GCCCapabilityIDType	capability_id_type;
    GCCObjectKey		non_standard_capability;
    ULONG               standard_capability;
}
    T120CapID, GCCCapabilityID, GCCCapID, *PGCCCapabilityID, *PGCCCapID;

/* 
**	CapabilityClass
**		This structure defines the class of capability and holds the associated
**		value. Note that Logical is not necessary.  Information associated with 
**		logical is stored in number_of_entities in the GCCApplicationCapability 
**		structure.
*/

typedef AppletCapabilityClass       T120CapClass, GCCCapabilityClass, GCCCapClass, *PGCCCapabilityClass, *PGCCCapClass;


/* 
**	GCCApplicationCapability
**		This structure holds all the data associated with a single T.124 
**		defined application capability.
*/
typedef struct tagT120AppCap
{
	GCCCapabilityID			capability_id;
	GCCCapabilityClass		capability_class;
    ULONG                   number_of_entities;
}
    T120AppCap, GCCApplicationCapability, GCCAppCap, *PGCCApplicationCapability, *PGCCAppCap;

/* 
**	GCCNonCollapsingCapability
*/
typedef struct tagT120NonCollCap
{
	GCCCapabilityID			capability_id;
	LPOSTR                  application_data;	/* optional */
}
    T120NonCollCap, GCCNonCollapsingCapability, GCCNonCollCap, *PGCCNonCollapsingCapability, *PGCCNonCollCap;

/* 
**	GCCApplicationRecord
**		This structure holds all the data associated with a single T.124 
**		application record.  See the T.124 specification for what parameters
**		are optional.
*/
typedef struct tagT120AppRecord
{
	GCCNodeID					node_id;
	GCCEntityID 				entity_id;
	BOOL    					is_enrolled_actively;
	BOOL    					is_conducting_capable;
	MCSChannelType				startup_channel_type; 
	UserID  					application_user_id;  			/* optional */
	ULONG       				number_of_non_collapsed_caps;
	GCCNonCollapsingCapability 
					**	non_collapsed_caps_list;		/* optional */
}
    T120AppRecord, GCCApplicationRecord, GCCAppRecord, *PGCCApplicationRecord, *PGCCAppRecord;

/* 
**	GCCApplicationRoster
**		This structure holds all the data associated with a single T.124 
**		application roster.  This includes the collapsed capabilites and
**		the complete list of application records associated with an Application
**		Protocol Entity (APE).
*/
typedef struct tagT120AppRoster
{
	GCCSessionKey		session_key;
	BOOL 				application_roster_was_changed;
	ULONG         		instance_number;
	BOOL 				nodes_were_added;
	BOOL 				nodes_were_removed;
	BOOL 				capabilities_were_changed;
	ULONG         		number_of_records;
	GCCApplicationRecord 	**	application_record_list;
	ULONG				number_of_capabilities;
	GCCApplicationCapability **	capabilities_list;	/* optional */		
}
    T120AppRoster, GCCApplicationRoster, GCCAppRoster, *PGCCApplicationRoster, *PGCCAppRoster;

/*
**	GCCRegistryKey
**		This key is used to identify a specific resource used
**		by an application. This may be a particular channel or token needed
**		for control purposes.
*/
typedef struct tagT120RegistryKey
{
	GCCSessionKey		session_key;
	OSTR        		resource_id;	/* Max length is 64 */
}
    T120RegistryKey, GCCRegistryKey, *PGCCRegistryKey;

/*
**	RegistryItemType
**		This enum is used to specify what type of registry item is contained
**		at the specified slot in the registry.
*/
typedef AppletRegistryItemType  GCCRegistryItemType, *PGCCRegistryItemType;
#define GCC_REGISTRY_CHANNEL_ID APPLET_REGISTRY_CHANNEL_ID
#define GCC_REGISTRY_TOKEN_ID   APPLET_REGISTRY_TOKEN_ID
#define GCC_REGISTRY_PARAMETER  APPLET_REGISTRY_PARAMETER
#define GCC_REGISTRY_NONE       APPLET_REGISTRY_NONE

/*
**	GCCRegistryItem
**		This structure is used to hold a single registry item.  Note that the
**		union supports all three registry types supported by GCC.
*/
typedef struct
{
	GCCRegistryItemType	item_type;
	// the following three fields were in a union
    ChannelID			channel_id;
	TokenID				token_id;
	OSTR         		parameter;		/* Max length is 64 */
}
    T120RegistryItem, GCCRegistryItem, *PGCCRegistryItem;

/*
**	GCCRegistryEntryOwner
**
*/
typedef struct
{
	BOOL		    entry_is_owned;
	GCCNodeID		owner_node_id;
	GCCEntityID 	owner_entity_id;
}
    T120RegistryEntryOwner, GCCRegistryEntryOwner, *PGCCRegistryEntryOwner;

/*
**	GCCModificationRights
**		This enum is used when specifing what kind of rights a node has to
**		alter the contents of a registry "parameter".
*/
typedef	AppletModificationRights    GCCModificationRights, *PGCCModificationRights;
#define GCC_OWNER_RIGHTS                        APPLET_OWNER_RIGHTS
#define GCC_SESSION_RIGHTS                      APPLET_SESSION_RIGHTS
#define GCC_PUBLIC_RIGHTS                       APPLET_PUBLIC_RIGHTS
#define GCC_NO_MODIFICATION_RIGHTS_SPECIFIED    APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED

/*
**	GCCAppProtocolEntity
**		This structure is used to identify a protocol entity at a remote node
**		when invoke is used.
*/
typedef	struct tagT120APE
{
	GCCSessionKey				session_key;
	MCSChannelType				startup_channel_type;
	BOOL					    must_be_invoked;
	ULONG         				number_of_expected_capabilities;
	GCCApplicationCapability **	expected_capabilities_list;
}
    T120APE, GCCAppProtocolEntity, GCCApe, *PGCCAppProtocolEntity, *PGCCApe;


/*
**	GCCMessageType
**		This section defines the messages that can be sent to the application
**		through the callback facility.  These messages correspond to the 
**		indications and confirms that are defined within T.124.
*/
typedef T120MessageType     GCCMessageType, *PGCCMessageType;

#endif // __GCC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\iappldr.h ===
#ifndef _I_APPLOADER_H
#define _I_APPLOADER_H

#include <basetyps.h>
#include "gcc.h"


typedef enum
{
	APPLET_ID_WB = 0,
    APPLET_ID_FT = 1,
    APPLET_ID_CHAT = 2,
    APPLET_LAST = 3,
}
    APPLET_ID;


typedef enum
{
    APPLDR_NO_ERROR = 0,
    APPLDR_FAIL,
    APPLDR_CANCEL_EXIT,
}
    APPLDR_RESULT;


typedef enum
{
    APPLET_QUERY_SHUTDOWN = 0,
    APPLET_QUERY_NM2xNODE,
}
    APPLET_QUERY_ID;


#undef INTERFACE
#define INTERFACE IAppletLoader
DECLARE_INTERFACE(IAppletLoader)
{
	STDMETHOD_(void,           ReleaseInterface)(THIS) PURE;
	STDMETHOD_(APPLDR_RESULT,  AppletStartup)(THIS_
	                                IN  BOOL    fNoUI) PURE;
	STDMETHOD_(APPLDR_RESULT,  AppletCleanup)(THIS_
									IN	DWORD	dwTimeout) PURE;
	STDMETHOD_(APPLDR_RESULT,  AppletInvoke)(THIS_
									IN	BOOL fLocal,
									IN	GCCConfID,
	                                IN  LPSTR   pszCmdLine) PURE;
    STDMETHOD_(APPLDR_RESULT,  AppletQuery)(THIS_
                                    IN  APPLET_QUERY_ID eQueryId) PURE; 
    STDMETHOD_(APPLDR_RESULT,  OnNM2xNodeJoin)(THIS) PURE;
};



typedef enum
{
    APPLET_LIBRARY_FREED = 0,
    APPLET_LIBRARY_LOADED,
    APPLET_WORK_THREAD_STARTED,
    APPLET_CLOSING,
    APPLET_WORK_THREAD_EXITED,
}
    APPLET_STATUS;



#define CREATE_APPLET_LOADER_INTERFACE  "CreateAppletLoaderInterface"
typedef T120Error (WINAPI *LPFN_CREATE_APPLET_LOADER_INTERFACE) (IAppletLoader **);



#ifdef __cplusplus
extern "C" {
#endif

// caller: NM/UI, T.120
T120Error WINAPI T120_LoadApplet(APPLET_ID, BOOL fLocal, T120ConfID, BOOL fNoUI, LPSTR pszCmdLine);

// caller: NM/UI shutdown
T120Error WINAPI T120_CloseApplet(APPLET_ID, BOOL fNowRegardlessRefCount, BOOL fSync, DWORD dwTimeout);

// caller: applet itself
T120Error WINAPI T120_AppletStatus(APPLET_ID, APPLET_STATUS);

// caller: NM/UI
T120Error WINAPI T120_QueryApplet(APPLET_ID, APPLET_QUERY_ID);

// node ID --> user name
//
// Return value is zero (in case of failure)
// or the length of node name (in case of valid <conf ID, node ID>).
//
// The caller should check if the buffer size given is large enough to
// hold the entire node name. If not, the caller should provide a new buffer
// and call this function again in order to get the entire node name.
//
ULONG WINAPI T120_GetNodeName(T120ConfID, T120NodeID, LPSTR pszName, ULONG cchName);

// node ID + GUID --> user data
//
// Return value is zero (in case of failure)
// or the size of user data (in case of valid <conf ID, node ID, GUID>).
//
// The caller should check if the buffer size given is large enough to
// hold the entire user data. If not, the caller should provide a new buffer
// and call this function again in order to get the entire user data.
//
ULONG WINAPI T120_GetUserData(T120ConfID, T120NodeID, GUID *, LPBYTE pbBuffer, ULONG cbBufSize);

// node ID --> node version
//
// Node version (like NM 3.0) is maintained iinside CConf's NodeVersion list
// Given confId and node id, returns node's version number
//
DWORD_PTR WINAPI T120_GetNodeVersion(T120ConfID, T120NodeID);

#ifdef __cplusplus
}
#endif


#endif // _I_APPLOADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\databeam.h ===
/*
 * databeam.h
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 * Abstract:
 *      This file defines common extensions to the C++ language for
 *		use at DataBeam Corporation.
 *
 * Author:
 *		James P. Galvin, Jr.
 *		Brian L. Pulito
 *		Carolyn J. Holmes
 *		John B. O'Nan
 *
 *	Revision History
 *		08AUG94		blp		Added UniChar
 *		15JUL94		blp		Added lstrcmp
 */

#ifndef _DATABEAM_
#define _DATABEAM_

#	include <windows.h>

/*
 * The following two macros can be used to get the minimum or the maximum
 * of two numbers.
 */
#ifndef min
#	define	min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#	define	max(a,b)	(((a) > (b)) ? (a) : (b))
#endif


/*
 *	This typedef defines Boolean as an BOOL, rather than an enum.  The
 *	thinking is that this is more likely to be compatible with other
 *	uses of Boolean (if any), as well as with the use of "#define" to
 *	define TRUE and FALSE.
 */
#ifndef	DBBoolean
typedef	BOOL						DBBoolean;
typedef	BOOL *						PDBBoolean;
#endif

/*
 *	These defines set up values that would typically be used in conjunction
 *	with the type Boolean as defined above.
 */
#ifndef	OFF
#	define	OFF		0
#endif
#ifndef	ON
#	define	ON		1
#endif


/*
 * EOS can be used for the NUL byte at the end of a string.  Do not 
 * confuse this with the pointer constant "NULL".
 */
#define EOS     '\0'


/*
 *	The following is a list of the standard typedefs that will be used
 *	in all programs written at DataBeam.  Use of this list gives us full
 *	control over types for portability.  It also gives us a standard
 *	naming convention for all types.
 */
typedef	char						Char;
typedef	unsigned char				UChar;
typedef	char *						PChar;
typedef	const char *				PCChar;
typedef	unsigned char *				PUChar;
typedef	const unsigned char *		PCUChar;
typedef	char *						FPChar;
typedef	const char *				FPCChar;
typedef	unsigned char *				FPUChar;
typedef	const unsigned char *		FPCUChar;
typedef	char  *						HPChar;
typedef	const char *				HPCChar;
typedef	unsigned char *				HPUChar;
typedef	const unsigned char *		HPCUChar;

typedef	short						Short;
typedef	unsigned short				UShort;
typedef	short *						PShort;
typedef	const short *				PCShort;
typedef	unsigned short *			PUShort;
typedef	const unsigned short *		PCUShort;
typedef	short *						FPShort;
typedef	const short *				FPCShort;
typedef	unsigned short *			FPUShort;
typedef	const unsigned short *		FPCUShort;
typedef	short *						HPShort;
typedef	const short *				HPCShort;
typedef	unsigned short *			HPUShort;
typedef	const unsigned short *		HPCUShort;

typedef	int							Int;
typedef	unsigned int				UInt;
typedef	int *						PInt;
typedef	const int *					PCInt;
typedef	unsigned int *				PUInt;
typedef	const unsigned int *		PCUInt;
typedef	int *						FPInt;
typedef	const int *					FPCInt;
typedef	unsigned int *				FPUInt;
typedef	const unsigned int *		FPCUInt;
typedef	int *						HPInt;
typedef	const int *					HPCInt;
typedef	unsigned int *				HPUInt;
typedef	const unsigned int *		HPCUInt;

typedef	long						Long;
typedef	unsigned long				ULong;
typedef	long *						PLong;
typedef	const long *				PCLong;
typedef	unsigned long *				PULong;
typedef	const unsigned long *		PCULong;
typedef	long *						FPLong;
typedef	const long *				FPCLong;
typedef	unsigned long *				FPULong;
typedef	const unsigned long *		FPCULong;
typedef	long *						HPLong;
typedef	const long *				HPCLong;
typedef	unsigned long *				HPULong;
typedef	const unsigned long *		HPCULong;

#ifdef USE_FLOATING_POINT
typedef	float						Float;
typedef	float *						PFloat;
typedef	const float *				PCFloat;
typedef	float *						FPFloat;
typedef	const float *				FPCFloat;
typedef	float *						HPFloat;
typedef	const float *				HPCFloat;

typedef	double						Double;
typedef	double *					PDouble;
typedef	const double *				PCDouble;
typedef	double *					FPDouble;
typedef	const double *				FPCDouble;
typedef	double *					HPDouble;
typedef	const double *				HPCDouble;

typedef	long double					LDouble;
typedef	long double *				PLDouble;
typedef	const long double *			PCLDouble;
typedef	long double *				FPLDouble;
typedef	const long double *			FPCLDouble;
typedef	long double *				HPLDouble;
typedef	const long double *			HPCLDouble;
#endif

typedef	void						Void;
typedef	void *						PVoid;
typedef	const void *				PCVoid;
typedef	void *						FPVoid;
typedef	const void *				FPCVoid;
typedef	void *						HPVoid;
typedef	const void *				HPCVoid;

/*
 *	Temporary fix for compatibility with the Symantec compiler, which doesn't
 *	recognize wchar_t as a valid type.
 */
typedef	unsigned short				UniChar;
typedef	UniChar		*				PUniChar;
typedef	UniChar		*				FPUniChar;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\igccapp.h ===
#ifndef _IGCCAPP_H_
#define _IGCCAPP_H_

#include <basetyps.h>
#include "gcc.h"

#define GCCAPI_(_type_) virtual _type_   __stdcall
#define GCCAPI          GCCAPI_(GCCError)


typedef struct
{
    GCCSessionKey           *pSessionKey;
    BOOL                    fEnrollActively;
    UserID                  nUserID;
    BOOL                    fConductingCapable;
    MCSChannelType          nStartupChannelType;
    ULONG                   cNonCollapsedCaps;
    GCCNonCollCap           **apNonCollapsedCaps;
    ULONG                   cCollapsedCaps;
    GCCAppCap               **apCollapsedCaps;
    BOOL                    fEnroll;
}
    GCCEnrollRequest, *PGCCEnrollRequest;


typedef struct
{
    ULONG                   cNodes;
    GCCNodeID               *aNodeIDs;
}
    GCCSimpleNodeList, *PGCCSimpleNodeList;


typedef struct
{
    ULONG                   cApes;
    GCCAppProtocolEntity    **apApes;
}
    GCCAppProtEntityList, *PGCCAppProtEntityList;


typedef struct
{
    GCCConfID               nConfID;
    ULONG                   cRosters;
    GCCAppRoster            **apAppRosters;
    GCCResult               nResult;
    LPVOID                  pReserved;          // do not touch
}
    GCCAppRosterInquireConfirm, *PGCCAppRosterInquireConfirm;


typedef struct
{
    GCCConfID               nConfID;
    GCCConfName             ConfName;
    LPSTR                   pszConfModifier;
    LPWSTR                  pwszConfDescriptor;
    GCCConfRoster           *pConfRoster;
    GCCResult               nResult;
}
    GCCConfRosterInquireConfirm, *PGCCConfRosterInquireConfirm;


typedef struct
{
    GCCConfID               nConfID;
    BOOL                    fPermissionGranted;
}
    GCCAppPermissionToEnrollInd, *PGCCAppPermissionToEnrollInd;


typedef struct
{
    GCCConfID               nConfID;
    // GCCSessionKey           *pSessionKey;
    GCCSessionID            sidMyself;
    GCCEntityID             eidMyself;
    GCCNodeID               nidMyself;
    GCCResult               nResult;
    GCCRequestTag           nReqTag;
}
    GCCAppEnrollConfirm, *PGCCAppEnrollConfirm;

typedef struct
{
    GCCConfID               nConfID;
    // GCCAppProtEntityList    *pApeList;
    GCCResult               nResult;
    GCCRequestTag           nReqTag;
}
    GCCAppInvokeConfirm, *PGCCAppInvokeConfirm;

typedef struct
{
    GCCConfID               nConfID;
    GCCAppProtEntityList    ApeList;
    GCCNodeID               nidInvoker;
}
    GCCAppInvokeInd, *PGCCAppInvokeInd;


typedef struct
{
    GCCConfID               nConfID;
    ULONG                   cRosters;
    GCCAppRoster            **apAppRosters;
    LPVOID                  pReserved;          // do not touch
}
    GCCAppRosterReportInd, *PGCCAppRosterReportInd;


typedef struct
{
    GCCConfID               nConfID;
    GCCRegistryKey          *pRegKey;
    GCCRegistryItem         *pRegItem;
    GCCRegistryEntryOwner   EntryOwner;
    GCCModificationRights   eRights;
    GCCResult               nResult;
    BOOL                    fDeliveryEnabled;   // for monitor confirm only
}
    GCCRegistryConfirm, *PGCCRegistryConfirm;


typedef struct
{
    GCCConfID               nConfID;
    ULONG                   nFirstHandle;
    ULONG                   cHandles;
    GCCResult               nResult;
}
    GCCRegAllocateHandleConfirm, *PGCCRegAllocateHandleConfirm;


typedef struct
{
    GCCConfID               nConfID;
    BOOL                    fConducted;
    GCCNodeID               nidConductor;
    BOOL                    fGranted;
    GCCResult               nResult;
}
    GCCConductorInquireConfirm, *PGCCConductorInquireConfirm;


typedef struct
{
    GCCConfID               nConfID;
    BOOL                    fThisNodeIsGranted;
    GCCSimpleNodeList       Granted;
    GCCSimpleNodeList       Waiting;
    LPVOID                  pReserved;      // do not touch
}
    GCCConductorPermitGrantInd, *PGCCConductorPermitGrantInd;


typedef struct
{
    GCCConfID               nConfID;
    GCCNodeID               nidConductor;
}
    GCCConductorAssignInd, *PGCCConductorAssignInd;


typedef struct
{
    GCCConfID               nConfID;
}
    GCCConductorReleaseInd, *PConductorReleaseInd;


/*
 *  GCCAppSapMsg
 *      This structure defines the callback message that is passed from GCC to
 *      a user application when an indication or confirm occurs.
 */

typedef struct
{
    GCCMessageType      eMsgType;
    LPVOID              pAppData;
    LPVOID              reserved1; // reserved
    GCCConfID           nConfID; // reserved

    union
    {
        GCCAppPermissionToEnrollInd         AppPermissionToEnrollInd;
        GCCAppEnrollConfirm                 AppEnrollConfirm;

        GCCAppRosterInquireConfirm          AppRosterInquireConfirm;
        GCCAppRosterReportInd               AppRosterReportInd;

        GCCConfRosterInquireConfirm         ConfRosterInquireConfirm;

        GCCAppInvokeConfirm                 AppInvokeConfirm;
        GCCAppInvokeInd                     AppInvokeInd;

        GCCRegistryConfirm                  RegistryConfirm;
        GCCRegAllocateHandleConfirm         RegAllocHandleConfirm;

        GCCConductorInquireConfirm          ConductorInquireConfirm;
        GCCConductorPermitGrantInd          ConductorPermitGrantInd;
        GCCConductorAssignInd               ConductorAssignInd;
        GCCConductorReleaseInd              ConductorReleaseInd;
    };
}
    GCCAppSapMsg, *PGCCAppSapMsg;


typedef void (CALLBACK *LPFN_APP_SAP_CB) (GCCAppSapMsg *);



#undef  INTERFACE
#define INTERFACE IGCCAppSap
DECLARE_INTERFACE(IGCCAppSap)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    /* application roster services */

    STDMETHOD_(GCCError, AppEnroll) (THIS_
                IN      GCCConfID,
                IN      GCCEnrollRequest *,
                OUT     PGCCRequestTag)
                PURE;

    STDMETHOD_(GCCError, AppInvoke) (THIS_
                IN      GCCConfID,
                IN      GCCAppProtEntityList *,
                IN      GCCSimpleNodeList *,
                OUT     PGCCRequestTag)
                PURE;

    // to acquire one or all full-refresh app roster.
    // can be called by both app sap and control sap.
    STDMETHOD_(GCCError, AppRosterInquire) (THIS_
                IN      GCCConfID,
                IN      GCCSessionKey *,
                OUT     GCCAppSapMsg **)
                PURE;

    STDMETHOD_(void, FreeAppSapMsg) (THIS_
                IN      GCCAppSapMsg *)
                PURE;

    /* conference roster service */

    STDMETHOD_(BOOL, IsThisNodeTopProvider) (THIS_
                IN      GCCConfID)
                PURE;

    STDMETHOD_(GCCNodeID, GetTopProvider) (THIS_
                IN      GCCConfID)
                PURE;

    // to acquire a full-refresh conf roster.
    STDMETHOD_(GCCError, ConfRosterInquire) (THIS_
                IN      GCCConfID,
                OUT     GCCAppSapMsg **)
                PURE;

    /* registry services */

    STDMETHOD_(GCCError, RegisterChannel) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *,
                IN      ChannelID)
                PURE;

    STDMETHOD_(GCCError, RegistryAssignToken) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistrySetParameter) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *,
                IN      LPOSTR,
                IN      GCCModificationRights)
                PURE;

    STDMETHOD_(GCCError, RegistryRetrieveEntry) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistryDeleteEntry) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistryMonitor) (THIS_
                IN      GCCConfID,
                IN      BOOL fEnableDelivery,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistryAllocateHandle) (THIS_
                IN      GCCConfID,
                IN      ULONG cHandles)
                PURE;

    /* conductorship services */

    STDMETHOD_(GCCError, ConductorInquire) (THIS_
                IN      GCCConfID)
                PURE;
};



//
// GCC Application Service Access Point exports
//

#ifdef __cplusplus
extern "C" {
#endif

GCCError WINAPI GCC_CreateAppSap(
                        OUT     IGCCAppSap **,
                        IN      LPVOID, // user defined data
                        IN      LPFN_APP_SAP_CB);
#ifdef __cplusplus
}
#endif


#endif // _IGCCAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\it120app.h ===
#ifndef _IT120APPSAP_H_
#define _IT120APPSAP_H_

#include <basetyps.h>
#include "gcc.h"
#include "igccapp.h"
#include "imcsapp.h"


typedef void (CALLBACK *LPFN_APPLET_SESSION_CB) (struct T120AppletSessionMsg *);
typedef void (CALLBACK *LPFN_APPLET_CB) (struct T120AppletMsg *);


/* ------ registry request ------ */

typedef struct tagT120RegistryParameter
{
    LPOSTR                      postrValue;
    AppletModificationRights    eModifyRights;
}
    T120RegistryParameter;

typedef struct tagT120RegistryRequest
{
    AppletRegistryCommand   eCommand;
    GCCRegistryKey         *pRegistryKey;
    union
    {
        // register channel
        T120ChannelID           nChannelID;
        // set parameter
        T120RegistryParameter   Param;
        // monitor
        BOOL                    fEnableDelivery;
        // allocate handle
        ULONG                   cHandles;
    };
}
    T120RegistryRequest;


/* ------ channel request ------ */

typedef struct tagT120ChannelRequest
{
    AppletChannelCommand    eCommand;
    T120ChannelID           nChannelID;
    ULONG                   cUsers;
    T120UserID             *aUsers;
}
    T120ChannelRequest;


/* ------ token request ------ */

typedef struct tagT120TokenRequest
{
    AppletTokenCommand      eCommand;
    T120TokenID             nTokenID;
    T120UserID              uidGiveTo;
    T120Result              eGiveResponse;
}
    T120TokenRequest;


/* ------ join conference ------ */

typedef struct tagT120ResourceRequest
{
    AppletResourceAllocCommand  eCommand;
    BOOL                        fImmediateNotification;
    T120ChannelID               nChannelID;
    T120TokenID                 nTokenID;
    GCCRegistryKey              RegKey;
}
    T120ResourceRequest;

typedef struct tagT120JoinSessionRequest
{
    // attach user flags
    DWORD                   dwAttachmentFlags;
    // session specific
    GCCSessionKey           SessionKey;
    // applet enroll
    BOOL                    fConductingCapable;
    AppletChannelType       nStartupChannelType;
    ULONG                   cNonCollapsedCaps;
    GCCNonCollCap         **apNonCollapsedCaps;
    ULONG                   cCollapsedCaps;
    GCCAppCap             **apCollapsedCaps;
    // static and dynamic channels
    ULONG                   cStaticChannels;
    T120ChannelID          *aStaticChannels;
    ULONG                   cResourceReqs;
    T120ResourceRequest    *aResourceReqs;
}
    T120JoinSessionRequest;



#undef  INTERFACE
#define INTERFACE IT120AppletSession
DECLARE_INTERFACE(IT120AppletSession)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(void, Advise) (THIS_
                IN      LPFN_APPLET_SESSION_CB pfnCallback,
                IN      LPVOID  pAppletContext,
                IN      LPVOID  pSessionContext) PURE;

    STDMETHOD_(void, Unadvise) (THIS) PURE;

    /* ------ basic info ------ */

    STDMETHOD_(T120ConfID, GetConfID) (THIS) PURE;

    STDMETHOD_(BOOL, IsThisNodeTopProvider) (THIS) PURE;

    STDMETHOD_(T120NodeID, GetTopProvider) (THIS) PURE;

    /* ------ join/leave ------ */

    STDMETHOD_(T120Error, Join) (THIS_
                IN      T120JoinSessionRequest *) PURE;

    STDMETHOD_(void, Leave) (THIS) PURE;

    /* ------ send data ------ */

    STDMETHOD_(T120Error, AllocateSendDataBuffer) (THIS_
                IN      ULONG,
                OUT     void **) PURE;

    STDMETHOD_(void, FreeSendDataBuffer) (THIS_
                IN      void *) PURE;

    STDMETHOD_(T120Error, SendData) (THIS_
                IN      DataRequestType,
                IN      T120ChannelID,
                IN      T120Priority,
                IN		LPBYTE,
                IN		ULONG,
                IN		SendDataFlags) PURE;

    /* ------ inquiry ------ */

    STDMETHOD_(T120Error, InvokeApplet) (THIS_
                IN      GCCAppProtEntityList *,
                IN      GCCSimpleNodeList *,
                OUT     T120RequestTag *) PURE;

    STDMETHOD_(T120Error, InquireRoster) (THIS_
                IN      GCCSessionKey *) PURE;

    /* ------ registry services ------ */

    STDMETHOD_(T120Error, RegistryRequest) (THIS_
                IN      T120RegistryRequest *) PURE;

    /* ------ channel services ------ */

    STDMETHOD_(T120Error, ChannelRequest) (THIS_
                IN      T120ChannelRequest *) PURE;

    /* ------ token services ------ */

    STDMETHOD_(T120Error, TokenRequest) (THIS_
                IN      T120TokenRequest *) PURE;
};


//
// T120 Applet Session Callback
//

typedef struct tagT120JoinSessionConfirm
{
    T120Result              eResult;
    T120Error               eError;
    IT120AppletSession     *pIAppletSession;
    T120UserID              uidMyself;
    T120SessionID           sidMyself;
    T120EntityID            eidMyself;
    T120NodeID              nidMyself;
    // the following two are the same as those in the request structure
    ULONG                   cResourceReqs;
    T120ResourceRequest    *aResourceReqs;
}
    T120JoinSessionConfirm;


typedef struct tagT120ChannelConfirm
{
    T120ChannelID           nChannelID;
    T120Result              eResult;
}
    T120ChannelConfirm;


typedef struct tagT120ChannelInd
{
    T120ChannelID           nChannelID;
    union
    {
        T120Reason          eReason;
        T120UserID          nManagerID;
    };
}
    T120ChannelInd;


typedef struct tagT120TokenConfirm
{
    T120TokenID             nTokenID;
    union
    {
        T120TokenStatus     eTokenStatus;
        T120Result          eResult;
    };
}
    T120TokenConfirm;


typedef struct tagT120TokenInd
{
    T120TokenID             nTokenID;
    union
    {
        T120Reason          eReason;
        T120UserID          nUserID;
    };
}
    T120TokenInd;


typedef struct tagT120DetachUserInd
{
    T120UserID              nUserID;
    T120Reason              eReason;
}
    T120DetachUserInd;


// internal use
typedef struct tagT120AttachUserConfirm
{
    T120UserID              nUserID;
    T120Result              eResult;
}
    T120AttachUserConfirm;


/*
 *  GCCAppSapMsg
 *      This structure defines the callback message that is passed from GCC to
 *      a user application when an indication or confirm occurs.
 */

typedef struct T120AppletSessionMsg
{
    T120MessageType     eMsgType;
    LPVOID              pAppletContext;
    LPVOID              pSessionContext;
    T120ConfID          nConfID;

    union
    {
        T120JoinSessionConfirm              JoinSessionConfirm;
        T120DetachUserInd                   DetachUserInd;

        GCCAppRosterInquireConfirm          AppRosterInquireConfirm;
        GCCAppRosterReportInd               AppRosterReportInd;

        GCCConfRosterInquireConfirm         ConfRosterInquireConfirm;

        GCCAppInvokeConfirm                 AppInvokeConfirm;
        GCCAppInvokeInd                     AppInvokeInd;

        GCCRegistryConfirm                  RegistryConfirm;
        GCCRegAllocateHandleConfirm         RegAllocHandleConfirm;

        SendDataIndicationPDU               SendDataInd;

        T120ChannelConfirm                  ChannelConfirm;
        T120ChannelInd                      ChannelInd;
        T120TokenConfirm                    TokenConfirm;
        T120TokenInd                        TokenInd;

        // will be removed in the future after converting all applets
        GCCAppEnrollConfirm                 AppEnrollConfirm;
        T120AttachUserConfirm               AttachUserConfirm;
    };
}
    T120AppletSessionMsg;



typedef struct T120AppletMsg
{
    T120MessageType     eMsgType;
    LPVOID              pAppletContext;
    LPVOID              Reserved1;
    T120ConfID          nConfID;

    union
    {
        GCCAppPermissionToEnrollInd         PermitToEnrollInd;
        T120JoinSessionConfirm              AutoJoinSessionInd;
    };
}
    T120AppletMsg;


#undef  INTERFACE
#define INTERFACE IT120AppletNotify
DECLARE_INTERFACE(IT120AppletNotify)
{
    STDMETHOD_(void, PermitToJoinSessionIndication) (THIS_
                    IN      T120ConfID,
                    IN      BOOL fPermissionGranted) PURE;

    STDMETHOD_(void, AutoJoinSessionIndication) (THIS_
                    IN      T120JoinSessionConfirm *) PURE;
};


#undef  INTERFACE
#define INTERFACE IT120Applet
DECLARE_INTERFACE(IT120Applet)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(void, Advise) (THIS_
                    IN      LPFN_APPLET_CB pfnCallback,
                    IN      LPVOID         pAppletContext) PURE;

    STDMETHOD_(void, Unadvise) (THIS) PURE;

    /* ------ Auto Join ------ */

    STDMETHOD_(T120Error, RegisterAutoJoin) (THIS_
                    IN      T120JoinSessionRequest *) PURE;

    STDMETHOD_(void, UnregisterAutoJoin) (THIS) PURE;

    /* ------ Session ------ */

    STDMETHOD_(T120Error, CreateSession) (THIS_
                    OUT     IT120AppletSession **,
                    IN      T120ConfID) PURE;
};


//
// T120 Applet SAP Exports
//

#ifdef __cplusplus
extern "C" {
#endif

T120Error WINAPI T120_CreateAppletSAP(IT120Applet **);

#ifdef __cplusplus
}
#endif


#endif // _IT120APPSAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\imcsapp.h ===
#ifndef _IMCSAPP_H_
#define _IMCSAPP_H_

#include <basetyps.h>
#include "mcatmcs.h"


#define MCSAPI_(_type_) virtual _type_   __stdcall
#define MCSAPI          MCSAPI_(MCSError)

#define	ATTACHMENT_DISCONNECT_IN_DATA_LOSS		0x1
#define ATTACHMENT_MCS_FREES_DATA_IND_BUFFER	0x2


#undef  INTERFACE
#define INTERFACE IMCSSap
DECLARE_INTERFACE(IMCSSap)
{
    STDMETHOD_(MCSError, ReleaseInterface) (THIS) PURE;

    /* memory calls */

    STDMETHOD_(MCSError, GetBuffer) (THIS_
                IN      UINT,
                OUT     PVoid *)
                PURE;

    STDMETHOD_(Void, FreeBuffer) (THIS_
                IN      PVoid)
                PURE;

    // channel request calls
    STDMETHOD_(MCSError, ChannelJoin) (THIS_
                IN      ChannelID)
                PURE;

    STDMETHOD_(MCSError, ChannelLeave) (THIS_
                IN      ChannelID)
                PURE;

    STDMETHOD_(MCSError, ChannelConvene) (THIS)
                PURE;

    STDMETHOD_(MCSError, ChannelDisband) (THIS_
                IN      ChannelID)
                PURE;

    STDMETHOD_(MCSError, ChannelAdmit) (THIS_
                IN      ChannelID,
                IN		PUserID,
				IN		UINT)
                PURE;

    /* send data services */

    STDMETHOD_(MCSError, SendData) (THIS_
                IN      DataRequestType,
                IN      ChannelID,
                IN      Priority,
                IN		unsigned char *,
                IN		ULong,
                IN		SendDataFlags)
                PURE;

	/*	token services */
    STDMETHOD_(MCSError, TokenGrab) (THIS_
                IN      TokenID)
                PURE;

    STDMETHOD_(MCSError, TokenInhibit) (THIS_
                IN      TokenID)
                PURE;

    STDMETHOD_(MCSError, TokenGive) (THIS_
                IN      TokenID,
                IN		UserID)
                PURE;

    STDMETHOD_(MCSError, TokenGiveResponse) (THIS_
                IN      TokenID,
                IN		Result)
                PURE;

    STDMETHOD_(MCSError, TokenPlease) (THIS_
                IN      TokenID)
                PURE;
                
    STDMETHOD_(MCSError, TokenRelease) (THIS_
                IN      TokenID)
                PURE;

    STDMETHOD_(MCSError, TokenTest) (THIS_
                IN      TokenID)
                PURE;
};

typedef IMCSSap * 		PIMCSSap;


//
// GCC Application Service Access Point exports
//

#ifdef __cplusplus
extern "C" {
#endif

MCSError WINAPI MCS_AttachRequest(
                        OUT     IMCSSap **,
                        IN		DomainSelector,
                        IN		UINT,
                        IN      MCSCallBack,
                        IN		PVoid,
                        IN		UINT);
#ifdef __cplusplus
}
#endif


#endif // _IMCSAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\it120nc.h ===
#ifndef _IGCCControlSAP_H_
#define _IGCCControlSAP_H_

#include <basetyps.h>
#include "gcc.h"
#include "igccapp.h"

/*
 *    These structures are used to hold the information included for the
 *    various callback messages.  In the case where these structures are used for 
 *    callbacks, the address of the structure is passed as the only parameter.
 */

typedef struct
{
    PGCCConferenceName          conference_name;
    GCCNumericString            conference_modifier;
    BOOL                        use_password_in_the_clear;
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    PGCCConferencePrivileges    conduct_privilege_list;
    PGCCConferencePrivileges    conduct_mode_privilege_list;
    PGCCConferencePrivileges    non_conduct_privilege_list;
    LPWSTR                      pwszConfDescriptor;
    LPWSTR                      pwszCallerID;
    TransportAddress            calling_address;
    TransportAddress            called_address;
    PDomainParameters           domain_parameters;
    UINT                        number_of_network_addresses;
    PGCCNetworkAddress         *network_address_list;
    PConnectionHandle           connection_handle;
}
    GCCConfCreateReqCore;

typedef struct
{
    GCCConfCreateReqCore        Core;
    PGCCPassword                convener_password;
    PGCCPassword                password;
    BOOL                        fSecure;
    UINT                        number_of_user_data_members;
    PGCCUserData               *user_data_list;
}
    GCCConfCreateRequest;


/*********************************************************************
 *                                                                   *
 *            NODE CONTROLLER CALLBACK INFO STRUCTURES               *
 *                                                                   *
 *********************************************************************/

typedef struct
{
    GCCConfID                   conference_id;
    GCCResult                   result;
}
    SimpleConfirmMsg;

/*
 *    GCC_CREATE_INDICATION
 *
 *    Union Choice:
 *        CreateIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the new conference that is about to be created.
 */
typedef struct
{
    GCCConferenceName           conference_name;
    GCCConferenceID             conference_id;
    GCCPassword                *convener_password;              /* optional */
    GCCPassword                *password;                       /* optional */
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    GCCConferencePrivileges    *conductor_privilege_list;       /* optional */
    GCCConferencePrivileges    *conducted_mode_privilege_list;  /* optional */
    GCCConferencePrivileges    *non_conducted_privilege_list;   /* optional */
    LPWSTR                      conference_descriptor;          /* optional */
    LPWSTR                      caller_identifier;              /* optional */
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    DomainParameters           *domain_parameters;              /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    ConnectionHandle            connection_handle;
}
    CreateIndicationMessage, *PCreateIndicationMessage;

/*
 *    GCC_CREATE_CONFIRM
 *
 *    Union Choice:
 *        CreateConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the result of a conference create request.
 *            The connection handle and physical handle will be zero on a
 *            local create.
 */
typedef struct
{
    GCCConferenceName           conference_name;
    GCCNumericString            conference_modifier;            /* optional */
    GCCConferenceID             conference_id;
    DomainParameters           *domain_parameters;              /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;              /* optional */
}
    CreateConfirmMessage, *PCreateConfirmMessage;

/*
 *    GCC_QUERY_INDICATION
 *
 *    Union Choice:
 *        QueryIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the conference query.
 */
typedef struct
{
    GCCResponseTag              query_response_tag;
    GCCNodeType                 node_type;
    GCCAsymmetryIndicator      *asymmetry_indicator;
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    ConnectionHandle            connection_handle;
}
    QueryIndicationMessage, *PQueryIndicationMessage;

/*
 *    GCC_QUERY_CONFIRM
 *
 *    Union Choice:
 *        QueryConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the result of a conference query request.
 */
typedef struct
{
    GCCNodeType                 node_type;
    GCCAsymmetryIndicator      *asymmetry_indicator;            /* optional */
    UINT                        number_of_descriptors;
    GCCConferenceDescriptor   **conference_descriptor_list;     /* optional*/
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;
}
    QueryConfirmMessage, *PQueryConfirmMessage;
    

/*
 *    GCC_JOIN_INDICATION
 *
 *    Union Choice:
 *        JoinIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the join request.
 */
typedef struct
{
    GCCResponseTag              join_response_tag;
    GCCConferenceID             conference_id;
    GCCPassword                *convener_password;              /* optional */
    GCCChallengeRequestResponse*password_challenge;             /* optional */
    LPWSTR                      caller_identifier;              /* optional */
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    BOOL                        node_is_intermediate;
    ConnectionHandle            connection_handle;
}
    JoinIndicationMessage, *PJoinIndicationMessage;

/*
 *    GCC_JOIN_CONFIRM
 *
 *    Union Choice:
 *        JoinConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the join confirm.
 */
typedef struct
{
    GCCConferenceName           conference_name;
    GCCNumericString            called_node_modifier;           /* optional */
    GCCNumericString            calling_node_modifier;          /* optional */
    GCCConferenceID             conference_id;
    GCCChallengeRequestResponse*password_challenge;             /* optional */
    DomainParameters           *domain_parameters;
    BOOL                        clear_password_required;
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    GCCConferencePrivileges    *conductor_privilege_list;       /* optional */
    GCCConferencePrivileges    *conducted_mode_privilege_list;  /* optional */
    GCCConferencePrivileges    *non_conducted_privilege_list;   /* optional */
    LPWSTR                      conference_descriptor;          /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;
    PBYTE                       pb_remote_cred;
    DWORD                       cb_remote_cred;
}
    JoinConfirmMessage, *PJoinConfirmMessage;

/*
 *    GCC_INVITE_INDICATION
 *
 *    Union Choice:
 *        InviteIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the invite indication.
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           conference_name;
    LPWSTR                      caller_identifier;              /* optional */
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    BOOL                        fSecure;
    DomainParameters           *domain_parameters;              /* optional */
    BOOL                        clear_password_required;
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    GCCConferencePrivileges    *conductor_privilege_list;       /* optional */
    GCCConferencePrivileges    *conducted_mode_privilege_list;  /* optional */
    GCCConferencePrivileges    *non_conducted_privilege_list;   /* optional */
    LPWSTR                      conference_descriptor;          /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    ConnectionHandle            connection_handle;
}
    InviteIndicationMessage, *PInviteIndicationMessage;

/*
 *    GCC_INVITE_CONFIRM
 *
 *    Union Choice:
 *        InviteConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the invite confirm.
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;
}
    InviteConfirmMessage, *PInviteConfirmMessage;

/*
 *    GCC_ADD_INDICATION
 *
 *    Union Choice:
 *        AddIndicationMessage
 */
typedef struct
{
    GCCResponseTag              add_response_tag;
    GCCConferenceID             conference_id;
    UINT                        number_of_network_addresses;
    GCCNetworkAddress         **network_address_list;
    UserID                      requesting_node_id;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
}
    AddIndicationMessage, *PAddIndicationMessage;

/*
 *    GCC_ADD_CONFIRM
 *
 *    Union Choice:
 *        AddConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_of_network_addresses;
    GCCNetworkAddress         **network_address_list;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
}
    AddConfirmMessage, *PAddConfirmMessage;

/*
 *    GCC_LOCK_INDICATION
 *
 *    Union Choice:
 *        LockIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requesting_node_id;
}
    LockIndicationMessage, *PLockIndicationMessage;

/*
 *    GCC_UNLOCK_INDICATION
 *
 *    Union Choice:
 *        UnlockIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requesting_node_id;
}
    UnlockIndicationMessage, *PUnlockIndicationMessage;

/*
 *    GCC_DISCONNECT_INDICATION
 *
 *    Union Choice:
 *        DisconnectIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCReason                   reason;
    UserID                      disconnected_node_id;
}
    DisconnectIndicationMessage, *PDisconnectIndicationMessage;

/*
 *    GCC_DISCONNECT_CONFIRM
 *
 *    Union Choice:
 *        PDisconnectConfirmMessage
 */
typedef SimpleConfirmMsg    DisconnectConfirmMessage, *PDisconnectConfirmMessage;

/*
 *    GCC_TERMINATE_INDICATION
 *
 *    Union Choice:
 *        TerminateIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requesting_node_id;
    GCCReason                   reason;
}
    TerminateIndicationMessage, *PTerminateIndicationMessage;

/*
 *    GCC_TERMINATE_CONFIRM
 *
 *    Union Choice:
 *        TerminateConfirmMessage
 */
typedef SimpleConfirmMsg    TerminateConfirmMessage, *PTerminateConfirmMessage;

/*
 *    GCC_CONNECTION_BROKEN_INDICATION
 *
 *    Union Choice:
 *        ConnectionBrokenIndicationMessage
 *
 *    Caveat: 
 *        This is a non-standard indication.
 */
typedef struct
{
    ConnectionHandle            connection_handle;
}
    ConnectionBrokenIndicationMessage, *PConnectionBrokenIndicationMessage;


/*
 *    GCC_EJECT_USER_INDICATION
 *
 *    Union Choice:
 *        EjectUserIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      ejected_node_id;
    GCCReason                   reason;
}
    EjectUserIndicationMessage, *PEjectUserIndicationMessage;

/*
 *    GCC_PERMIT_TO_ANNOUNCE_PRESENCE
 *
 *    Union Choice:
 *        PermitToAnnouncePresenceMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      node_id;
}
    PermitToAnnouncePresenceMessage, *PPermitToAnnouncePresenceMessage;

/*
 *    GCC_ANNOUNCE_PRESENCE_CONFIRM
 *
 *    Union Choice:
 *        AnnouncePresenceConfirmMessage
 */
typedef SimpleConfirmMsg    AnnouncePresenceConfirmMessage, *PAnnouncePresenceConfirmMessage;

/*
 *    GCC_ROSTER_REPORT_INDICATION
 *
 *    Union Choice:
 *        ConfRosterReportIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceRoster        *conference_roster;
}
    ConfRosterReportIndicationMessage, *PConfRosterReportIndicationMessage;

/*
 *    GCC_CONDUCT_GIVE_INDICATION
 *
 *    Union Choice:
 *        ConductorGiveIndicationMessage
 */
typedef struct
{        
    GCCConferenceID             conference_id;
}
    ConductGiveIndicationMessage, *PConductGiveIndicationMessage;

/*
 *    GCC_TIME_INQUIRE_INDICATION
 *
 *    Union Choice:
 *        TimeInquireIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        time_is_conference_wide;
    UserID                      requesting_node_id;
}
    TimeInquireIndicationMessage, *PTimeInquireIndicationMessage;

/*
 *    GCC_STATUS_INDICATION
 *
 *    Union Choice:
 *        GCCStatusMessage
 *            This callback is used to relay GCC status to the node controller
 */
typedef    enum
{
    GCC_STATUS_PACKET_RESOURCE_FAILURE      = 0,
    GCC_STATUS_PACKET_LENGTH_EXCEEDED       = 1,
    GCC_STATUS_CTL_SAP_RESOURCE_ERROR       = 2,
    GCC_STATUS_APP_SAP_RESOURCE_ERROR       = 3, /*    parameter = Sap Handle */
    GCC_STATUS_CONF_RESOURCE_ERROR          = 4, /*    parameter = Conference ID */
    GCC_STATUS_INCOMPATIBLE_PROTOCOL        = 5, /*    parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME    = 6, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONVENER     = 7, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_LOCKED           = 8  /* parameter = Physical Handle */
}
    GCCStatusMessageType;

typedef struct
{
    GCCStatusMessageType        status_message_type;
    UINT                        parameter;
}
    GCCStatusIndicationMessage, *PGCCStatusIndicationMessage;

/*
 *    GCC_SUB_INITIALIZED_INDICATION
 *
 *    Union Chice:
 *        SubInitializedIndicationMessage
 */
typedef struct
{
    ConnectionHandle            connection_handle;
    UserID                      subordinate_node_id;
}
    SubInitializedIndicationMessage, *PSubInitializedIndicationMessage;



#ifdef JASPER // ------------------------------------------------
/*
 *    GCC_LOCK_CONFIRM
 *
 *    Union Choice:
 *        LockConfirmMessage
 */
typedef SimpleConfirmMsg    LockConfirmMessage, *PLockConfirmMessage;

/*
 *    GCC_UNLOCK_CONFIRM
 *
 *    Union Choice:
 *        UnlockConfirmMessage
 */
typedef SimpleConfirmMsg    UnlockConfirmMessage, *PUnlockConfirmMessage;

/*
 *    GCC_LOCK_REPORT_INDICATION
 *
 *    Union Choice:
 *        LockReportIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        conference_is_locked;
}
    LockReportIndicationMessage, *PLockReportIndicationMessage;

/*
 *    GCC_EJECT_USER_CONFIRM
 *
 *    Union Choice:
 *        EjectUserConfirmMessage
 */
typedef struct
{
    GCCConferenceID              conference_id;
    GCCResult                    result;
    UserID                       ejected_node_id;
}
    EjectUserConfirmMessage, *PEjectUserConfirmMessage;

/*
 *    GCC_TRANSFER_INDICATION
 *
 *    Union Choice:
 *        TransferIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           destination_conference_name;
    GCCNumericString            destination_conference_modifier;/* optional */
    UINT                        number_of_destination_addresses;
    GCCNetworkAddress         **destination_address_list;
    GCCPassword                *password;                       /* optional */
}
    TransferIndicationMessage, *PTransferIndicationMessage;

/*
 *    GCC_TRANSFER_CONFIRM
 *
 *    Union Choice:
 *        TransferConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           destination_conference_name;
    GCCNumericString            destination_conference_modifier;/* optional */
    UINT                        number_of_destination_nodes;
    UserID                     *destination_node_list;
    GCCResult                   result;
}
    TransferConfirmMessage, *PTransferConfirmMessage;

/*
 *    GCC_CONDUCT_ASSIGN_CONFIRM
 *
 *    Union Choice:
 *        ConductAssignConfirmMessage
 */
typedef SimpleConfirmMsg    ConductAssignConfirmMessage, *PConductAssignConfirmMessage;

/*
 *    GCC_CONDUCT_RELEASE_CONFIRM
 *
 *    Union Choice:
 *        ConductorReleaseConfirmMessage
 */
typedef SimpleConfirmMsg    ConductReleaseConfirmMessage, *PConductReleaseConfirmMessage; 

/*
 *    GCC_CONDUCT_PLEASE_INDICATION
 *
 *    Union Choice:
 *        ConductorPleaseIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requester_node_id;
}
    ConductPleaseIndicationMessage, *PConductPleaseIndicationMessage; 

/*
 *    GCC_CONDUCT_PLEASE_CONFIRM
 *
 *    Union Choice:
 *        ConductPleaseConfirmMessage
 */
typedef SimpleConfirmMsg    ConductPleaseConfirmMessage, *PConductPleaseConfirmMessage;

/*
 *    GCC_CONDUCT_GIVE_CONFIRM
 *
 *    Union Choice:
 *        ConductorGiveConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCResult                   result;
    UserID                      recipient_node_id;
}
    ConductGiveConfirmMessage, *PConductGiveConfirmMessage;

/*
 *    GCC_CONDUCT_ASK_INDICATION
 *
 *    Union Choice:
 *        ConductPermitAskIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        permission_is_granted;
    UserID                      requester_node_id;
}
    ConductPermitAskIndicationMessage, *PConductPermitAskIndicationMessage; 

/*
 *    GCC_CONDUCT_ASK_CONFIRM
 *
 *    Union Choice:
 *        ConductPermitAskConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCResult                   result;
    BOOL                        permission_is_granted;
}
    ConductPermitAskConfirmMessage, *PConductPermitAskConfirmMessage;

/*
 *    GCC_CONDUCT_GRANT_CONFIRM
 *
 *    Union Choice:
 *        ConductPermissionGrantConfirmMessage
 */
typedef SimpleConfirmMsg    ConductPermitGrantConfirmMessage, *PConductPermitGrantConfirmMessage;

/*
 *    GCC_TIME_REMAINING_INDICATION
 *
 *    Union Choice:
 *        TimeRemainingIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        time_remaining;
    UserID                      node_id;
    UserID                      source_node_id;
}
    TimeRemainingIndicationMessage, *PTimeRemainingIndicationMessage;

/*
 *    GCC_TIME_REMAINING_CONFIRM
 *
 *    Union Choice:
 *        TimeRemainingConfirmMessage
 */
typedef SimpleConfirmMsg    TimeRemainingConfirmMessage, *PTimeRemainingConfirmMessage;

/*
 *    GCC_TIME_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        TimeInquireConfirmMessage
 */
typedef SimpleConfirmMsg    TimeInquireConfirmMessage, *PTimeInquireConfirmMessage;

/*
 *    GCC_CONFERENCE_EXTEND_INDICATION
 *
 *    Union Choice:
 *        ConferenceExtendIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        extension_time;
    BOOL                        time_is_conference_wide;
    UserID                      requesting_node_id;
}
    ConferenceExtendIndicationMessage, *PConferenceExtendIndicationMessage;

/*
 *    GCC_CONFERENCE_EXTEND_CONFIRM
 *
 *    Union Choice:
 *        ConferenceExtendConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        extension_time;
    GCCResult                   result;
}
    ConferenceExtendConfirmMessage, *PConferenceExtendConfirmMessage;

/*
 *    GCC_ASSISTANCE_INDICATION
 *
 *    Union Choice:
 *        ConferenceAssistIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;
    UserID                      source_node_id;
}
    ConferenceAssistIndicationMessage, *PConferenceAssistIndicationMessage;

/*
 *    GCC_ASSISTANCE_CONFIRM
 *
 *    Union Choice:
 *        ConferenceAssistConfirmMessage
 */
typedef SimpleConfirmMsg    ConferenceAssistConfirmMessage, *PConferenceAssistConfirmMessage;

/*
 *    GCC_TEXT_MESSAGE_INDICATION
 *
 *    Union Choice:
 *        TextMessageIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    LPWSTR                      text_message;
    UserID                      source_node_id;
}
    TextMessageIndicationMessage, *PTextMessageIndicationMessage;

/*
 *    GCC_TEXT_MESSAGE_CONFIRM
 *
 *    Union Choice:
 *        TextMessageConfirmMessage
 */
typedef SimpleConfirmMsg    TextMessageConfirmMessage, *PTextMessageConfirmMessage;
#endif // JASPER // ------------------------------------------------


/*********************************************************************
 *                                                                   *
 *            USER APPLICATION CALLBACK INFO STRUCTURES              *
 *                                                                   *
 *********************************************************************/

/*
 *    GCC_APP_ROSTER_REPORT_INDICATION
 *
 *    Union Choice:
 *        AppRosterReportIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_rosters;
    GCCApplicationRoster      **application_roster_list;
}
    AppRosterReportIndicationMessage, *PAppRosterReportIndicationMessage;

/*********************************************************************
 *                                                                     *
 *                SHARED CALLBACK INFO STRUCTURES                         *
 *        (Note that this doesn't include all the shared callbacks)    *
 *                                                                     *
 *********************************************************************/

/*
 *    GCC_ROSTER_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        ConfRosterInquireConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           conference_name;
    GCCNumericString            conference_modifier;
    LPWSTR                      conference_descriptor;
    GCCConferenceRoster        *conference_roster;
    GCCResult                   result;
}
    ConfRosterInquireConfirmMessage, *PConfRosterInquireConfirmMessage;

/*
 *    GCC_APPLICATION_INVOKE_INDICATION
 *
 *    Union Choice:
 *        ApplicationInvokeIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_app_protocol_entities;
    GCCAppProtocolEntity      **app_protocol_entity_list;
    UserID                      invoking_node_id;
}
    ApplicationInvokeIndicationMessage, *PApplicationInvokeIndicationMessage;

/*
 *    GCC_APPLICATION_INVOKE_CONFIRM
 *
 *    Union Choice:
 *        ApplicationInvokeConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_app_protocol_entities;
    GCCAppProtocolEntity      **app_protocol_entity_list;
    GCCResult                   result;
}
    ApplicationInvokeConfirmMessage, *PApplicationInvokeConfirmMessage;
 


#ifdef JASPER // ------------------------------------------------
/*
 *    GCC_APP_ROSTER_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        AppRosterInquireConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_rosters;
    GCCApplicationRoster      **application_roster_list;
    GCCResult                   result;
}
    AppRosterInquireConfirmMessage, *PAppRosterInquireConfirmMessage;

/*
 *    GCC_CONDUCT_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        ConductorInquireConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        mode_is_conducted;
    UserID                      conductor_node_id;
    BOOL                        permission_is_granted;
    GCCResult                   result;
}
    ConductInquireConfirmMessage, *PConductInquireConfirmMessage;

/*
 *    GCC_CONDUCT_ASSIGN_INDICATION
 *
 *    Union Choice:
 *        ConductAssignIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      node_id;
}
    ConductAssignIndicationMessage, *PConductAssignIndicationMessage; 

/*
 *    GCC_CONDUCT_RELEASE_INDICATION
 *
 *    Union Choice:
 *        ConductReleaseIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
}
    ConductReleaseIndicationMessage, *PConductReleaseIndicationMessage;

/*
 *    GCC_CONDUCT_GRANT_INDICATION
 *
 *    Union Choice:
 *        ConductPermitGrantIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_granted;
    UserID                     *granted_node_list;
    UINT                        number_waiting;
    UserID                     *waiting_node_list;
    BOOL                        permission_is_granted;
}
    ConductPermitGrantIndicationMessage, *PConductPermitGrantIndicationMessage; 
#endif // JASPER  // ------------------------------------------------


/*
 *    GCCMessage
 *        This structure defines the message that is passed from GCC to either
 *        the node controller or a user application when an indication or
 *        confirm occurs.
 */

typedef    struct
{
    GCCMessageType              message_type;
    LPVOID                      user_defined;

    // GCCNC relies on easy access to conference ID.
    GCCConfID                   nConfID;

    union
    {
        CreateIndicationMessage                 create_indication;
        CreateConfirmMessage                    create_confirm;
        QueryIndicationMessage                  query_indication;
        QueryConfirmMessage                     query_confirm;
        JoinIndicationMessage                   join_indication;
        JoinConfirmMessage                      join_confirm;
        InviteIndicationMessage                 invite_indication;
        InviteConfirmMessage                    invite_confirm;
        AddIndicationMessage                    add_indication;
        AddConfirmMessage                       add_confirm;
        LockIndicationMessage                   lock_indication;
        UnlockIndicationMessage                 unlock_indication;
        DisconnectIndicationMessage             disconnect_indication;
        DisconnectConfirmMessage                disconnect_confirm;
        TerminateIndicationMessage              terminate_indication;
        TerminateConfirmMessage                 terminate_confirm;
        ConnectionBrokenIndicationMessage       connection_broken_indication;
        EjectUserIndicationMessage              eject_user_indication;    
        ApplicationInvokeIndicationMessage      application_invoke_indication;
        ApplicationInvokeConfirmMessage         application_invoke_confirm;
        SubInitializedIndicationMessage         conf_sub_initialized_indication;
        PermitToAnnouncePresenceMessage         permit_to_announce_presence;
        AnnouncePresenceConfirmMessage          announce_presence_confirm;
        ConfRosterReportIndicationMessage       conf_roster_report_indication;
        ConductGiveIndicationMessage            conduct_give_indication;
        TimeInquireIndicationMessage            time_inquire_indication;
        GCCStatusIndicationMessage              status_indication;
        AppRosterReportIndicationMessage        app_roster_report_indication;
        ConfRosterInquireConfirmMessage         conf_roster_inquire_confirm;
#ifdef TSTATUS_INDICATION
        TransportStatus                         transport_status;
#endif // TSTATUS_INDICATION

#ifdef JASPER // ------------------------------------------------
        TextMessageIndicationMessage            text_message_indication;
        TimeRemainingIndicationMessage          time_remaining_indication;
        AppRosterInquireConfirmMessage          app_roster_inquire_confirm;
        ConferenceAssistConfirmMessage          conference_assist_confirm;
        ConferenceAssistIndicationMessage       conference_assist_indication;
        ConductPermitAskConfirmMessage          conduct_permit_ask_confirm;
        ConductPermitAskIndicationMessage       conduct_permit_ask_indication; 
        ConductAssignConfirmMessage             conduct_assign_confirm;
        ConductAssignIndicationMessage          conduct_assign_indication; 
        ConductGiveConfirmMessage               conduct_give_confirm;
        ConductPermitGrantConfirmMessage        conduct_permit_grant_confirm;
        ConductPermitGrantIndicationMessage     conduct_permit_grant_indication; 
        ConductInquireConfirmMessage            conduct_inquire_confirm;
        ConductPleaseConfirmMessage             conduct_please_confirm;
        ConductPleaseIndicationMessage          conduct_please_indication;
        ConductReleaseConfirmMessage            conduct_release_confirm; 
        ConductReleaseIndicationMessage         conduct_release_indication; 
        ConferenceExtendConfirmMessage          conference_extend_confirm;
        ConferenceExtendIndicationMessage       conference_extend_indication;
        EjectUserConfirmMessage                 eject_user_confirm;
        LockConfirmMessage                      lock_confirm;
        LockReportIndicationMessage             lock_report_indication;
        TextMessageConfirmMessage               text_message_confirm;
        TimeInquireConfirmMessage               time_inquire_confirm;
        TimeRemainingConfirmMessage             time_remaining_confirm;
        TransferConfirmMessage                  transfer_confirm;
        TransferIndicationMessage               transfer_indication;
        UnlockConfirmMessage                    unlock_confirm;
#endif // JASPER // ------------------------------------------------

        // easy acess to conf id and gcc result
        SimpleConfirmMsg        simple_confirm;
    } u;
}
    GCCMessage, *PGCCMessage, T120Message, *PT120Message;


// node controller callback entry
typedef void (CALLBACK *LPFN_T120_CONTROL_SAP_CB) (T120Message *);


#undef  INTERFACE
#define INTERFACE IT120ControlSAP
DECLARE_INTERFACE(IT120ControlSAP)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    /*
     *  GCCError    ConfCreateRequest()
     *        This routine is a request to create a new conference. Both 
     *        the local node and the node to which the create conference 
     *        request is directed to, join the conference automatically.  
     */
    STDMETHOD_(GCCError, ConfCreateRequest) (THIS_
                    GCCConfCreateRequest *,
                    GCCConfID *) PURE;

    /*    
     *  GCCError    ConfCreateResponse()
     *        This procedure is a remote node controller's response to a con-
     *        ference creation request by the convener. 
     */

    STDMETHOD_(GCCError, ConfCreateResponse) (THIS_
                    GCCNumericString            conference_modifier,
                    GCCConfID,
                    BOOL                        use_password_in_the_clear,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfQueryRequest()
     *        This routine is a request to query a node for information about the
     *        conferences that exist at that node.
     */
    STDMETHOD_(GCCError, ConfQueryRequest) (THIS_
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle) PURE;

    STDMETHOD_(void, CancelConfQueryRequest) (THIS_
                    ConnectionHandle) PURE;

    /*
     *  GCCError    ConfQueryResponse()
     *        This routine is called in response to a conference query request.
     */
    STDMETHOD_(GCCError, ConfQueryResponse) (THIS_
                    GCCResponseTag              query_response_tag,
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    AnnouncePresenceRequest()
     *        This routine is invoked by node controller when a node joins a 
     *        conference, to announce the presence of the new node to all
     *        other nodes of the conference. This should be followed by a
     *        GCCConferenceReport indication by the GCC to all nodes.
     */
    STDMETHOD_(GCCError, AnnouncePresenceRequest) (THIS_
                    GCCConfID,
                    GCCNodeType                 node_type,
                    GCCNodeProperties           node_properties,
                    LPWSTR                      pwszNodeName,
                    UINT                        number_of_participants,
                    LPWSTR                     *ppwszParticipantNameList,
                    LPWSTR                      pwszSiteInfo,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    LPOSTR                      alternative_node_id,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list) PURE;

    /*
     *  GCCError    ConfJoinRequest()
     *        This routine is invoked by node controller to cause the local
     *        node to join an existing conference.    
     */
    STDMETHOD_(GCCError, ConfJoinRequest) (THIS_
                    GCCConferenceName          *conference_name,
                    GCCNumericString            called_node_modifier,
                    GCCNumericString            calling_node_modifier,
                    GCCPassword                *convener_password,
                    GCCChallengeRequestResponse*password_challenge,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle,
                    GCCConfID                  *pnConfID) PURE;

    /*
     *  GCCError    ConfJoinResponse()
     *        This routine is remote node controller's response to conference join 
     *        request by the local node controller.
     */
    STDMETHOD_(GCCError, ConfJoinResponse) (THIS_
                    GCCResponseTag              join_response_tag,
                    GCCChallengeRequestResponse*password_challenge,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfInviteRequest()
     *        This routine is invoked by node controller to invite a node  
     *        to join a conference.
     */
    STDMETHOD_(GCCError, ConfInviteRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle) PURE;

    STDMETHOD_(void, CancelInviteRequest) (THIS_
                    GCCConfID,
                    ConnectionHandle) PURE;

    /*
     *  GCCError    ConfInviteResponse()
     *        This routine is invoked by node controller to respond to an
     *        invite indication.
     */
    STDMETHOD_(GCCError, ConfInviteResponse) (THIS_
                    GCCConfID,
                    GCCNumericString            conference_modifier,
                    BOOL                        fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfAddResponse()
     */
    STDMETHOD_(GCCError, ConfAddResponse) (THIS_
                    GCCResponseTag              app_response_tag,
                    GCCConfID,
                    UserID                      requesting_node,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfLockResponse()
     *        This routine is invoked by node controller to respond to a
     *        lock indication.
     */
    STDMETHOD_(GCCError, ConfLockResponse) (THIS_
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfDisconnectRequest()
     *        This routine is used by a node controller to disconnect itself
     *        from a specified conference. GccConferenceDisconnectIndication
     *        sent to all other nodes of the conference. This is for client 
     *        initiated case.
     */
    STDMETHOD_(GCCError, ConfDisconnectRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfEjectUserRequest()
     */
    STDMETHOD_(GCCError, ConfEjectUserRequest) (THIS_
                    GCCConfID,
                    UserID                      ejected_node_id,
                    GCCReason) PURE;

    /*
     *  GCCError    AppletInvokeRequest()
     */
    STDMETHOD_(GCCError, AppletInvokeRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_app_protcol_entities,
                    GCCAppProtocolEntity      **app_protocol_entity_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *list_of_destination_nodes) PURE;

    /*
     *  GCCError    ConfRosterInqRequest()
     *        This routine is invoked to request a conference roster.  It can be
     *        called by either the Node Controller or the client application.
     */
    STDMETHOD_(GCCError, ConfRosterInqRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorGiveResponse()
     */
    STDMETHOD_(GCCError, ConductorGiveResponse) (THIS_
                    GCCConfID,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfTimeRemainingRequest()
     */
    STDMETHOD_(GCCError, ConfTimeRemainingRequest) (THIS_
                    GCCConfID,
                    UINT                        time_remaining,
                    UserID                      node_id) PURE;


    STDMETHOD_(GCCError, GetParentNodeID) (THIS_
                    GCCConfID,
                    GCCNodeID *) PURE;

#ifdef JASPER // ------------------------------------------------
    /*
     *  GCCError    ConfAddRequest()
     */
    STDMETHOD_(GCCError, ConfAddRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    UserID                      adding_node,
                    UINT                         number_of_user_data_members,
                    GCCUserData               **user_data_list) PURE;

    /*
     *  GCCError    ConfLockRequest()
     *        This routine is invoked by node controller to lock a conference.
     */
    STDMETHOD_(GCCError, ConfLockRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfUnlockRequest()
     *        This routine is invoked by node controller to unlock a conference.
     */
    STDMETHOD_(GCCError, ConfUnlockRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfUnlockResponse()
     *        This routine is invoked by node controller to respond to an
     *        unlock indication.
     */
    STDMETHOD_(GCCError, ConfUnlockResponse) (
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfTerminateRequest()
     */
    STDMETHOD_(GCCError, ConfTerminateRequest) (THIS_
                    GCCConfID,
                    GCCReason) PURE;

    /*
     *  GCCError    ConfTransferRequest()
     */
    STDMETHOD_(GCCError, ConfTransferRequest) (THIS_
                    GCCConfID,
                    GCCConferenceName          *destination_conference_name,
                    GCCNumericString            destination_conference_modifier,
                    UINT                        number_of_destination_addresses,
                    GCCNetworkAddress         **destination_address_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *destination_node_list,
                    GCCPassword                *password) PURE;

    /*
     *  GCCError    ConductorAssignRequest()
     */
    STDMETHOD_(GCCError, ConductorAssignRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorReleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorReleaseRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorPleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorPleaseRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorGiveRequest()
     */
    STDMETHOD_(GCCError, ConductorGiveRequest) (THIS_
                    GCCConfID,
                    UserID                      recipient_user_id) PURE;

    /*
     *  GCCError    ConductorPermitAskRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitAskRequest) (THIS_
                            GCCConfID,
                            BOOL                grant_permission) PURE;

    /*
     *  GCCError    ConductorPermitGrantRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitGrantRequest) (THIS_
                    GCCConfID,
                    UINT                        number_granted,
                    UserID                     *granted_node_list,
                    UINT                        number_waiting,
                    UserID                     *waiting_node_list) PURE;

    /*
     *  GCCError    ConductorInquireRequest()
     */
    STDMETHOD_(GCCError, ConductorInquireRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfTimeInquireRequest()
     */
    STDMETHOD_(GCCError, ConfTimeInquireRequest) (THIS_
                    GCCConfID,
                    BOOL                        time_is_conference_wide) PURE;

    /*
     *  GCCError    ConfExtendRequest()
     */
    STDMETHOD_(GCCError, ConfExtendRequest) (THIS_
                    GCCConfID,
                    UINT                        extension_time,
                    BOOL                        time_is_conference_wide) PURE;

    /*
     *  GCCError    ConfAssistanceRequest()
     */
    STDMETHOD_(GCCError, ConfAssistanceRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list) PURE;

    /*
     *  GCCError    TextMessageRequest()
     */
    STDMETHOD_(GCCError, TextMessageRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszTextMsg,
                    UserID                      destination_node) PURE;
#endif // JASPER // ------------------------------------------------

};



//
// GCC Application Service Access Point exports
//

#ifdef __cplusplus
extern "C" {
#endif

GCCError WINAPI T120_CreateControlSAP(
                        OUT     IT120ControlSAP **,
                        IN      LPVOID, // user defined data
                        IN      LPFN_T120_CONTROL_SAP_CB);

#ifdef __cplusplus
}
#endif

#endif // _IGCCControlSAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\it120xprt.h ===
#ifndef _IT120_TRANSPORT_H_
#define _IT120_TRANSPORT_H_


#include <basetyps.h>
#include <t120type.h>


#define T120_CONNECTION_ID_LENGTH       64


typedef enum tagPLUGXPRT_PROTOCOL
{
    PLUGXPRT_PROTOCOL_X224          = 0,
}
    PLUGXPRT_PROTOCOL;


typedef enum tagPLUGXPRT_RESULT
{
    PLUGXPRT_RESULT_SUCCESSFUL      = 0,
    PLUGXPRT_RESULT_READ_FAILED     = 1,
    PLUGXPRT_RESULT_WRITE_FAILED    = 2,
    PLUGXPRT_RESULT_FAILED          = 3,
    PLUGXPRT_RESULT_ABANDONED       = 4,
}
    PLUGXPRT_RESULT;


typedef enum tagPLUGXPRT_STATE
{
    PLUGXPRT_UNKNOWN_STATE      = 0,
    PLUGXPRT_CONNECTING         = 1,
    PLUGXPRT_CONNECTED          = 2,
    PLUGXPRT_DISCONNECTING      = 3,
    PLUGXPRT_DISCONNECTED       = 4,
}
    PLUGXPRT_STATE;


typedef struct tagPLUGXPRT_MESSAGE
{
    PLUGXPRT_STATE          eState;
    LPVOID                  pContext;
    LPSTR                   pszConnID;
    PLUGXPRT_PROTOCOL       eProtocol;
    PLUGXPRT_RESULT         eResult;
}
    PLUGXPRT_MESSAGE;


typedef void (CALLBACK *LPFN_PLUGXPRT_CB) (PLUGXPRT_MESSAGE *);


#undef  INTERFACE
#define INTERFACE IT120PluggableTransport
DECLARE_INTERFACE(IT120PluggableTransport)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(T120Error, CreateConnection) (THIS_
                    char                szConnID[], /* out */
                    PLUGXPRT_CALL_TYPE  eCaller, // caller vs callee
                    HANDLE              hCommLink,
                    HANDLE              hevtDataAvailable,
                    HANDLE              hevtWriteReady,
                    HANDLE              hevtConnectionClosed,
                    PLUGXPRT_FRAMING    eFraming,
                    PLUGXPRT_PARAMETERS *pParams) PURE;

    STDMETHOD_(T120Error, UpdateConnection) (THIS_
                    LPSTR               pszConnID,
                    HANDLE              hCommLink) PURE;

    STDMETHOD_(T120Error, CloseConnection) (THIS_ LPSTR pszConnID) PURE; 

    STDMETHOD_(T120Error, EnableWinsock) (THIS) PURE; 

    STDMETHOD_(T120Error, DisableWinsock) (THIS) PURE; 

    STDMETHOD_(void, Advise) (THIS_ LPFN_PLUGXPRT_CB, LPVOID pContext) PURE;

    STDMETHOD_(void, UnAdvise) (THIS) PURE;

    STDMETHOD_(void, ResetConnCounter) (THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

T120Error WINAPI T120_CreatePluggableTransport(IT120PluggableTransport **);

#ifdef __cplusplus
}
#endif


#endif // _IT120_TRANSPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\t120.h ===
/*
 *    t120.h
 *
 *    Copyright (c) 1994, 1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the interface file for the communications infrastructure of
 *        T120.
 *
 *        Note that this is a "C" language interface in order to prevent any "C++"
 *        naming conflicts between different compiler manufacturers.  Therefore,
 *        if this file is included in a module that is being compiled with a "C++"
 *        compiler, it is necessary to use the following syntax:
 *
 *        extern "C"
 *        {
 *            #include "t120.h"
 *        }
 *
 *        This disables C++ name mangling on the API entry points defined within
 *        this file.
 *
 *    Author:
 *        blp
 *
 *    Caveats:
 *        none
 */
#ifndef __T120_H__
#define __T120_H__


/*
 *    These macros are used to pack 2 16-bit values into a 32-bit variable, and
 *    get them out again.
 */
#ifndef LOWUSHORT
    #define LOWUSHORT(ul)    (LOWORD(ul))
#endif

#ifndef HIGHUSHORT
    #define HIGHUSHORT(ul)    (HIWORD(ul))
#endif


#include "t120type.h"
#include "mcatmcs.h"
#include "gcc.h"

#endif // __T120_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmmkcert\global.h ===
#ifndef _MAKECERT_GLOBAL_H
#define _MAKECERT_GLOBAL_H

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <wincrypt.h>

#include <nmutil.h>
#include <confdbg.h>
#include <strutil.h>
#include <regentry.h>
#include <confreg.h>
#include <nmmkcert.h>

#include "nmpvkhlp.h"
#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\mcspdu.h ===
#ifndef _MCSPDU_Module_H_
#define _MCSPDU_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct SetOfUserIDs * PSetOfUserIDs;

typedef struct SetOfPDUChannelAttributes * PSetOfPDUChannelAttributes;

typedef struct SetOfChannelIDs * PSetOfChannelIDs;

typedef struct SetOfPDUTokenAttributes * PSetOfPDUTokenAttributes;

typedef struct SetOfTokenIDs * PSetOfTokenIDs;

typedef ASN1uint16_t ChannelID;

typedef ChannelID StaticChannelID;

typedef ChannelID DynamicChannelID;

typedef DynamicChannelID UserID;

typedef DynamicChannelID PrivateChannelID;

typedef DynamicChannelID AssignedChannelID;

typedef ASN1uint16_t TokenID;

typedef enum PDUTokenStatus {
    not_in_use = 0,
    self_grabbed = 1,
    other_grabbed = 2,
    self_inhibited = 3,
    other_inhibited = 4,
    self_recipient = 5,
    self_giving = 6,
    other_giving = 7,
} PDUTokenStatus;

typedef enum PDUPriority {
    TOP_PRIORITY = 0,
    HIGH_PRIORITY = 1,
    MEDIUM_PRIORITY = 2,
    LOW_PRIORITY = 3,
} PDUPriority;

typedef ASN1uint8_t PDUSegmentation;
// #define begin 0x80
// #define end 0x40

typedef enum PDUReason {
    rn_domain_disconnected = 0,
    rn_provider_initiated = 1,
    rn_token_purged = 2,
    rn_user_requested = 3,
    rn_channel_purged = 4,
} PDUReason;

typedef enum PDUResult {
    rt_successful = 0,
    rt_domain_merging = 1,
    rt_domain_not_hierarchical = 2,
    rt_no_such_channel = 3,
    rt_no_such_domain = 4,
    rt_no_such_user = 5,
    rt_not_admitted = 6,
    rt_other_user_id = 7,
    rt_parameters_unacceptable = 8,
    rt_token_not_available = 9,
    rt_token_not_possessed = 10,
    rt_too_many_channels = 11,
    rt_too_many_tokens = 12,
    rt_too_many_users = 13,
    rt_unspecified_failure = 14,
    rt_user_rejected = 15,
} PDUResult;

typedef enum Diagnostic {
    dc_inconsistent_merge = 0,
    dc_forbidden_pdu_downward = 1,
    dc_forbidden_pdu_upward = 2,
    dc_invalid_ber_encoding = 3,
    dc_invalid_per_encoding = 4,
    dc_misrouted_user = 5,
    dc_unrequested_confirm = 6,
    dc_wrong_transport_priority = 7,
    dc_channel_id_conflict = 8,
    dc_token_id_conflict = 9,
    dc_not_user_id_channel = 10,
    dc_too_many_channels = 11,
    dc_too_many_tokens = 12,
    dc_too_many_users = 13,
} Diagnostic;

typedef struct Given {
    TokenID token_id;
    UserID recipient;
} Given;

typedef struct Ungivable {
    TokenID token_id;
    UserID grabber;
} Ungivable;

typedef struct Giving {
    TokenID token_id;
    UserID grabber;
    UserID recipient;
} Giving;

typedef struct Inhibited {
    TokenID token_id;
    PSetOfUserIDs inhibitors;
} Inhibited;

typedef struct Grabbed {
    TokenID token_id;
    UserID grabber;
} Grabbed;

typedef struct ChannelAttributesAssigned {
    AssignedChannelID channel_id;
} ChannelAttributesAssigned;

typedef struct ChannelAttributesPrivate {
    ASN1bool_t joined;
    PrivateChannelID channel_id;
    UserID manager;
    PSetOfUserIDs admitted;
} ChannelAttributesPrivate;

typedef struct ChannelAttributesUserID {
    ASN1bool_t joined;
    UserID user_id;
} ChannelAttributesUserID;

typedef struct ChannelAttributesStatic {
    StaticChannelID channel_id;
} ChannelAttributesStatic;

typedef struct PDUDomainParameters {
    ASN1uint32_t max_channel_ids;
    ASN1uint32_t max_user_ids;
    ASN1uint32_t max_token_ids;
    ASN1uint32_t number_priorities;
    ASN1uint32_t min_throughput;
    ASN1uint32_t max_height;
    ASN1uint32_t max_mcspdu_size;
    ASN1uint32_t protocol_version;
} PDUDomainParameters;

typedef struct ConnectInitialPDU {
    ASN1octetstring_t calling_domain_selector;
    ASN1octetstring_t called_domain_selector;
    ASN1bool_t upward_flag;
    PDUDomainParameters target_parameters;
    PDUDomainParameters minimum_parameters;
    PDUDomainParameters maximum_parameters;
    ASN1octetstring_t user_data;
} ConnectInitialPDU;

typedef struct ConnectResponsePDU {
    PDUResult result;
    ASN1uint32_t called_connect_id;
    PDUDomainParameters domain_parameters;
    ASN1octetstring_t user_data;
} ConnectResponsePDU;

typedef struct ConnectAdditionalPDU {
    ASN1uint32_t called_connect_id;
    PDUPriority data_priority;
} ConnectAdditionalPDU;

typedef struct ConnectResultPDU {
    PDUResult result;
} ConnectResultPDU;

typedef struct PlumbDomainIndicationPDU {
    ASN1uint32_t height_limit;
} PlumbDomainIndicationPDU;

typedef struct ErectDomainRequestPDU {
    UINT_PTR sub_height;
    ASN1uint32_t sub_interval;
} ErectDomainRequestPDU;

typedef struct PDUChannelAttributes {
    ASN1choice_t choice;
    union {
#	define channel_attributes_static_chosen 1
	ChannelAttributesStatic channel_attributes_static;
#	define channel_attributes_user_id_chosen 2
	ChannelAttributesUserID channel_attributes_user_id;
#	define channel_attributes_private_chosen 3
	ChannelAttributesPrivate channel_attributes_private;
#	define channel_attributes_assigned_chosen 4
	ChannelAttributesAssigned channel_attributes_assigned;
    } u;
} PDUChannelAttributes;

typedef struct MergeChannelsPDU {
    PSetOfPDUChannelAttributes merge_channels;
    PSetOfChannelIDs purge_channel_ids;
} MergeChannelsPDU;

typedef	MergeChannelsPDU			MergeChannelsRequestPDU;
typedef	MergeChannelsPDU			MergeChannelsConfirmPDU;

typedef struct PurgeChannelIndicationPDU {
    PSetOfUserIDs detach_user_ids;
    PSetOfChannelIDs purge_channel_ids;
} PurgeChannelIndicationPDU;

typedef struct PDUTokenAttributes {
    ASN1choice_t choice;
    union {
#	define grabbed_chosen 1
	Grabbed grabbed;
#	define inhibited_chosen 2
	Inhibited inhibited;
#	define giving_chosen 3
	Giving giving;
#	define ungivable_chosen 4
	Ungivable ungivable;
#	define given_chosen 5
	Given given;
    } u;
} PDUTokenAttributes;

typedef struct SetOfUserIDs {
    PSetOfUserIDs next;
    UserID value;
} SetOfUserIDs_Element;

typedef struct SetOfPDUChannelAttributes {
    PSetOfPDUChannelAttributes next;
    PDUChannelAttributes value;
} SetOfPDUChannelAttributes_Element;

typedef struct SetOfChannelIDs {
    PSetOfChannelIDs next;
    ChannelID value;
} SetOfChannelIDs_Element;

typedef struct SetOfPDUTokenAttributes {
    PSetOfPDUTokenAttributes next;
    PDUTokenAttributes value;
} SetOfPDUTokenAttributes_Element;

typedef struct SetOfTokenIDs {
    PSetOfTokenIDs next;
    TokenID value;
} SetOfTokenIDs_Element;

typedef struct MergeTokensPDU {
    PSetOfPDUTokenAttributes merge_tokens;
    PSetOfTokenIDs purge_token_ids;
} MergeTokensPDU;

typedef MergeTokensPDU			MergeTokensRequestPDU;
typedef MergeTokensPDU			MergeTokensConfirmPDU;

typedef struct PurgeTokenIndicationPDU {
    PSetOfTokenIDs purge_token_ids;
} PurgeTokenIndicationPDU;

typedef struct DisconnectProviderUltimatumPDU {
    PDUReason reason;
} DisconnectProviderUltimatumPDU;

typedef struct RejectUltimatumPDU {
    Diagnostic diagnostic;
    ASN1octetstring_t initial_octets;
} RejectUltimatumPDU;

typedef struct AttachUserRequestPDU {
    char placeholder;
} AttachUserRequestPDU;

typedef struct AttachUserConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PDUResult result;
#   define initiator_present 0x80
    UserID initiator;
} AttachUserConfirmPDU;

typedef struct DetachUserRequestPDU {
    PDUReason reason;
    PSetOfUserIDs user_ids;
} DetachUserPDU;

typedef DetachUserPDU		DetachUserRequestPDU;
typedef DetachUserPDU		DetachUserIndicationPDU;

typedef struct ChannelJoinRequestPDU {
    UserID initiator;
    ChannelID channel_id;
} ChannelJoinRequestPDU;

typedef struct ChannelJoinConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PDUResult result;
    UserID initiator;
    ChannelID requested;
#   define join_channel_id_present 0x80
    ChannelID join_channel_id;
} ChannelJoinConfirmPDU;

typedef struct ChannelLeaveRequestPDU {
    PSetOfChannelIDs channel_ids;
} ChannelLeaveRequestPDU;

typedef struct ChannelConveneRequestPDU {
    UserID initiator;
} ChannelConveneRequestPDU;

typedef struct ChannelConveneConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PDUResult result;
    UserID initiator;
#   define convene_channel_id_present 0x80
    PrivateChannelID convene_channel_id;
} ChannelConveneConfirmPDU;

typedef struct ChannelDisbandRequestPDU {
    UserID initiator;
    PrivateChannelID channel_id;
} ChannelDisbandRequestPDU;

typedef struct ChannelDisbandIndicationPDU {
    PrivateChannelID channel_id;
} ChannelDisbandIndicationPDU;

typedef struct ChannelAdmitRequestPDU {
    UserID initiator;
    PrivateChannelID channel_id;
    PSetOfUserIDs user_ids;
} ChannelAdmitExpelPDU;

typedef ChannelAdmitExpelPDU		ChannelAdmitRequestPDU;
typedef ChannelAdmitExpelPDU		ChannelAdmitIndicationPDU;
typedef ChannelAdmitExpelPDU		ChannelExpelRequestPDU;

typedef struct ChannelExpelIndicationPDU {
    PrivateChannelID channel_id;
    PSetOfUserIDs user_ids;
} ChannelExpelIndicationPDU;

typedef struct SendDataRequestPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} SendDataRequestPDU;

typedef struct SendDataIndicationPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} SendDataIndicationPDU;

typedef struct UniformSendDataRequestPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} UniformSendDataRequestPDU;

typedef struct UniformSendDataIndicationPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} UniformSendDataIndicationPDU;

typedef struct TokenGrabRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenGrabRequestPDU;

typedef struct TokenGrabConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenGrabConfirmPDU;

typedef struct TokenInhibitRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenInhibitRequestPDU;

typedef struct TokenInhibitConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenInhibitConfirmPDU;

typedef struct TokenGiveRequestPDU {
    UserID initiator;
    TokenID token_id;
    UserID recipient;
} TokenGiveRequestPDU;

typedef struct TokenGiveIndicationPDU {
    UserID initiator;
    TokenID token_id;
    UserID recipient;
} TokenGiveIndicationPDU;

typedef struct TokenGiveResponsePDU {
    PDUResult result;
    UserID recipient;
    TokenID token_id;
} TokenGiveResponsePDU;

typedef struct TokenGiveConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenGiveConfirmPDU;

typedef struct TokenPleaseRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenPleaseRequestPDU;

typedef struct TokenPleaseIndicationPDU {
    UserID initiator;
    TokenID token_id;
} TokenPleaseIndicationPDU;

typedef struct TokenReleaseRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenReleaseRequestPDU;

typedef struct TokenReleaseConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenReleaseConfirmPDU;

typedef struct TokenTestRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenTestRequestPDU;

typedef struct TokenTestConfirmPDU {
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenTestConfirmPDU;

typedef struct ConnectMCSPDU {
    ASN1choice_t choice;
    union {
#	define connect_initial_chosen 1
	ConnectInitialPDU connect_initial;
#	define connect_response_chosen 2
	ConnectResponsePDU connect_response;
#	define connect_additional_chosen 3
	ConnectAdditionalPDU connect_additional;
#	define connect_result_chosen 4
	ConnectResultPDU connect_result;
    } u;
} ConnectMCSPDU;
#define ConnectMCSPDU_PDU 0
#define SIZE_MCSPDU_Module_PDU_0 sizeof(ConnectMCSPDU)

typedef struct DomainMCSPDU {
    ASN1choice_t choice;
    union {
#	define plumb_domain_indication_chosen 1
	PlumbDomainIndicationPDU plumb_domain_indication;
#	define erect_domain_request_chosen 2
	ErectDomainRequestPDU erect_domain_request;
#	define merge_channels_request_chosen 3
	MergeChannelsRequestPDU merge_channels_request;
#	define merge_channels_confirm_chosen 4
	MergeChannelsConfirmPDU merge_channels_confirm;
#	define purge_channel_indication_chosen 5
	PurgeChannelIndicationPDU purge_channel_indication;
#	define merge_tokens_request_chosen 6
	MergeTokensRequestPDU merge_tokens_request;
#	define merge_tokens_confirm_chosen 7
	MergeTokensConfirmPDU merge_tokens_confirm;
#	define purge_token_indication_chosen 8
	PurgeTokenIndicationPDU purge_token_indication;
#	define disconnect_provider_ultimatum_chosen 9
	DisconnectProviderUltimatumPDU disconnect_provider_ultimatum;
#	define reject_user_ultimatum_chosen 10
	RejectUltimatumPDU reject_user_ultimatum;
#	define attach_user_request_chosen 11
	AttachUserRequestPDU attach_user_request;
#	define attach_user_confirm_chosen 12
	AttachUserConfirmPDU attach_user_confirm;
#	define detach_user_request_chosen 13
	DetachUserRequestPDU detach_user_request;
#	define detach_user_indication_chosen 14
	DetachUserIndicationPDU detach_user_indication;
#	define channel_join_request_chosen 15
	ChannelJoinRequestPDU channel_join_request;
#	define channel_join_confirm_chosen 16
	ChannelJoinConfirmPDU channel_join_confirm;
#	define channel_leave_request_chosen 17
	ChannelLeaveRequestPDU channel_leave_request;
#	define channel_convene_request_chosen 18
	ChannelConveneRequestPDU channel_convene_request;
#	define channel_convene_confirm_chosen 19
	ChannelConveneConfirmPDU channel_convene_confirm;
#	define channel_disband_request_chosen 20
	ChannelDisbandRequestPDU channel_disband_request;
#	define channel_disband_indication_chosen 21
	ChannelDisbandIndicationPDU channel_disband_indication;
#	define channel_admit_request_chosen 22
	ChannelAdmitRequestPDU channel_admit_request;
#	define channel_admit_indication_chosen 23
	ChannelAdmitIndicationPDU channel_admit_indication;
#	define channel_expel_request_chosen 24
	ChannelExpelRequestPDU channel_expel_request;
#	define channel_expel_indication_chosen 25
	ChannelExpelIndicationPDU channel_expel_indication;
#	define send_data_request_chosen 26
	SendDataRequestPDU send_data_request;
#	define send_data_indication_chosen 27
	SendDataIndicationPDU send_data_indication;
#	define uniform_send_data_request_chosen 28
	UniformSendDataRequestPDU uniform_send_data_request;
#	define uniform_send_data_indication_chosen 29
	UniformSendDataIndicationPDU uniform_send_data_indication;
#	define token_grab_request_chosen 30
	TokenGrabRequestPDU token_grab_request;
#	define token_grab_confirm_chosen 31
	TokenGrabConfirmPDU token_grab_confirm;
#	define token_inhibit_request_chosen 32
	TokenInhibitRequestPDU token_inhibit_request;
#	define token_inhibit_confirm_chosen 33
	TokenInhibitConfirmPDU token_inhibit_confirm;
#	define token_give_request_chosen 34
	TokenGiveRequestPDU token_give_request;
#	define token_give_indication_chosen 35
	TokenGiveIndicationPDU token_give_indication;
#	define token_give_response_chosen 36
	TokenGiveResponsePDU token_give_response;
#	define token_give_confirm_chosen 37
	TokenGiveConfirmPDU token_give_confirm;
#	define token_please_request_chosen 38
	TokenPleaseRequestPDU token_please_request;
#	define token_please_indication_chosen 39
	TokenPleaseIndicationPDU token_please_indication;
#	define token_release_request_chosen 40
	TokenReleaseRequestPDU token_release_request;
#	define token_release_confirm_chosen 41
	TokenReleaseConfirmPDU token_release_confirm;
#	define token_test_request_chosen 42
	TokenTestRequestPDU token_test_request;
#	define token_test_confirm_chosen 43
	TokenTestConfirmPDU token_test_confirm;
    } u;
} DomainMCSPDU;
#define DomainMCSPDU_PDU 1
#define SIZE_MCSPDU_Module_PDU_1 sizeof(DomainMCSPDU)

extern ASN1module_t MCSPDU_Module;
extern void ASN1CALL MCSPDU_Module_Startup(void);
extern void ASN1CALL MCSPDU_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_SetOfUserIDs_ElmFn(ASN1encoding_t enc, PSetOfUserIDs val);
    extern int ASN1CALL ASN1Dec_SetOfUserIDs_ElmFn(ASN1decoding_t dec, PSetOfUserIDs val);
    extern void ASN1CALL ASN1Free_SetOfUserIDs_ElmFn(PSetOfUserIDs val);
    extern int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUChannelAttributes val);
    extern int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUChannelAttributes val);
    extern void ASN1CALL ASN1Free_SetOfPDUChannelAttributes_ElmFn(PSetOfPDUChannelAttributes val);
    extern int ASN1CALL ASN1Enc_SetOfChannelIDs_ElmFn(ASN1encoding_t enc, PSetOfChannelIDs val);
    extern int ASN1CALL ASN1Dec_SetOfChannelIDs_ElmFn(ASN1decoding_t dec, PSetOfChannelIDs val);
    extern void ASN1CALL ASN1Free_SetOfChannelIDs_ElmFn(PSetOfChannelIDs val);
    extern int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUTokenAttributes val);
    extern int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUTokenAttributes val);
    extern void ASN1CALL ASN1Free_SetOfPDUTokenAttributes_ElmFn(PSetOfPDUTokenAttributes val);
    extern int ASN1CALL ASN1Enc_SetOfTokenIDs_ElmFn(ASN1encoding_t enc, PSetOfTokenIDs val);
    extern int ASN1CALL ASN1Dec_SetOfTokenIDs_ElmFn(ASN1decoding_t dec, PSetOfTokenIDs val);
    extern void ASN1CALL ASN1Free_SetOfTokenIDs_ElmFn(PSetOfTokenIDs val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _MCSPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\mcatmcs.h ===
/*
 *	mcatmcs.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MCS DLL.  This file defines all
 *		macros, types, and functions needed to use the MCS DLL, allowing MCS
 *		services to be accessed from user applications.
 *
 *		Basically, an application requests services from MCS by making direct
 *		calls into the DLL (this includes T.122 requests and responses).  MCS
 *		sends information back to the application through a callback (this
 *		includes T.122 indications and confirms).  The callback 
 *		for a particular user attachment is specified in the call
 *		MCS_AttachRequest.
 *
 *		Note that this is a "C" language interface in order to prevent any "C++"
 *		naming conflicts between different compiler manufacturers.  Therefore,
 *		if this file is included in a module that is being compiled with a "C++"
 *		compiler, it is necessary to use the following syntax:
 *
 *		extern "C"
 *		{
 *		#include "mcatmcs.h"
 *		}
 *
 *		This disables C++ name mangling on the API entry points defined within
 *		this file.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	__MCATMCS_H__
#define	__MCATMCS_H__

#include "databeam.h"
#include "mcspdu.h"
#include <t120type.h>

/*
 *	The following definitions are used to identify various parameters within
 *	MCS, and are part of the MCS protocol definition.
 *
 *	Priority
 *		MCS specifies the use of up to four levels of priority.  An application
 *		should NOT use TOP_PRIORITY (this level is reserved for MCS traffic).
 *	Segmentation
 *		This type is used when specifying whether a given data indication is the
 *		first or last one in a user data block (or both or neither).
 *	TokenStatus
 *		This type is returned when testing the current state of a token.
 *	Reason
 *		When MCS issues an indication to a user application, it often includes a
 *		reason parameter informing the user of why the activity is occurring.
 *	Result
 *		When a user makes a request of MCS, MCS often responds with a result,
 *		letting the user know whether or not the request succeeded.
 */

typedef PDUPriority				Priority;
typedef	PDUSegmentation			Segmentation;

typedef	Priority  *				PPriority;
typedef	Segmentation  *			PSegmentation;

#define	SEGMENTATION_BEGIN			0x80
#define	SEGMENTATION_END			0x40


/*
 *	The following type is used to indicate what merge state the local provider
 *	is in.  Note that this is a local implementation feature that is not part
 *	of the standard MCS definition.
 *
 *	Whenever the former Top Provider of a domain enters the domain merge state,
 *	it indicates this to all applications locally attached to that domain by
 *	sending an MCS_MERGE_DOMAIN_INDICATION.  This type (MergeStatus) is the
 *	parameter to that call.  It will be called twice, the first time indicating
 *	that the domain is entering the merge state.  The second time indicates that
 *	the domain merger is complete.
 *
 *	All T.122 primitives (requests and responses) will be rejected during the
 *	time that the domain merger is in progress.  It is the repsonsibility of
 *	the user application to re-try the primitive once the merge is complete.
 */
typedef	unsigned short			MergeStatus;
typedef	MergeStatus  *			PMergeStatus;

#define	MERGE_DOMAIN_IN_PROGRESS	0
#define	MERGE_DOMAIN_COMPLETE		1

/*
 *	This type is the signature of an MCS call back function.  MCS uses this
 *	function to let the application know when an event occurs.
 *
 *	Note that an MCS callback routine needs to return a value to MCS.  This
 *	value should either be MCS_NO_ERROR if the callback was successfully
 *	processed, or MCS_CALLBACK_NOT_PROCESSED if the callback was not processed.
 *	In the latter case, MCS will hold on to the information contained in the
 *	callback message, so that it can try issuing the same callback during the
 *	next time slice.  It will keep retrying until the user application accepts
 *	the callback message (by returning MCS_NO_ERROR).  This is how flow control
 *	works for information flowing upward from MCS to the application.
 */
typedef	void (CALLBACK *MCSCallBack) (UINT, LPARAM, LPVOID);

/*
typedef	struct
{
	ChannelID			channel_id;
	Priority			priority;
	UserID				sender_id;
	Segmentation		segmentation;
	unsigned char  *	user_data;
	unsigned long		user_data_length;
} SendData;
*/
typedef SendDataRequestPDU				SendData;
typedef	SendData  *						PSendData;

// This constant defines the maximum MCS PDU size for applications
#define MAX_MCS_DATA_SIZE	4096

/*
 *	This section defines the messages that can be sent to the application
 *	through the callback facility.  These messages correspond to the indications
 *	and confirms that are defined within T.122.
 */
typedef T120MessageType  MCSMessageType;


/*
 *	The following declaration defines the flags that can be set when 
 *	calling MCSSendDataRequest.
 */
typedef enum {
	APP_ALLOCATION,
	MCS_ALLOCATION
} SendDataFlags, *PSendDataFlags;


/*
 *	The following type defines whether the SendDataRequest
 *	is a normal send or a uniform send.
 */
typedef enum {
	NORMAL_SEND_DATA,
	UNIFORM_SEND_DATA
} DataRequestType, *PDataRequestType;

typedef enum
{
	TOP_PRIORITY_MASK		=0x0001,
	HIGH_PRIORITY_MASK		=0x0002,
	LOW_MEDIUM_MASK			=0x0004,
	LOW_PRIORITY_MASK		=0x0008,
	UNIFORM_SEND_DATA_MASK	=0x0010,
	NORMAL_SEND_DATA_MASK	=0x0020,
	MCS_ALLOCATION_MASK		=0x0040,
	APP_ALLOCATION_MASK		=0x0080
} MCSSenDataMasks;



#endif // __MCATMCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\h\t120\t120type.h ===
#ifndef _T120_TYPE_H_
#define  _T120_TYPE_H_

#include <nmapptyp.h>

/*
 *	This is a list of types that are used extensively throughout MCS.  For
 *	each type there is also a pointer to that type defined, which has a "P"
 *	prefix.  These types are described as follows:
 *
 *	DomainSelector - This is a string of bytes that acts as the name of a given
 *		domain.  It is used when creating a new domain, as well as in accessing
 *		that domain after creation.  The length of the string is specified with
 *		a separate parameter, and the string CAN contain embedded zeroes.
 *	ConnectionHandle - When a user application connects two domains using
 *		MCSConnectProviderRequest, a ConnectionHandle is assigned to that MCS
 *		connection.  This allows more direct access to it for further services.
 *	ConnectID - This type is used only during MCS connection establishment.
 *		It identifies a particular transport connection for the purpose of
 *		adding multiple data priorities on the same MCS connection.
 *	ChannelID - This type identifies an MCS channel.  There are four different
 *		types of channels that are part of this type: user ID; static; private;
 *		and assigned.
 *	UserID - This is a special channel that identifies a particular user in an
 *		MCS domain.  Only that user can join the channel, so this is referred
 *		to as a single-cast channel.  All other channels are multi-cast, meaning
 *		that any number of users can join them at once.
 *	TokenID - This is an MCS object that is used to resolve resource conflicts.
 *		If an application has a particular resource or service that can only
 *		be used by one user at a time, that user can request exclusive ownership
 *		of a token.
 */
// ushort
typedef AppletSessionID     T120SessionID, GCCSessionID, *PGCCSessionID;
typedef	AppletChannelID     T120ChannelID, ChannelID, *PChannelID;
typedef	AppletUserID        T120UserID, UserID, *PUserID, GCCUserID, *PGCCUserID;
typedef	AppletTokenID       T120TokenID, TokenID, *PTokenID;
typedef AppletNodeID        T120NodeID, GCCNodeID, *PGCCNodeID;
typedef AppletEntityID      T120EntityID, GCCEntityID, *PGCCEntityID;
// ulong
typedef AppletConfID        T120ConfID, GCCConferenceID, GCCConfID, *PGCCConferenceID, *PGCCConfID;
// uint
typedef AppletRequestTag    T120RequestTag, GCCRequestTag, *PGCCRequestTag;
typedef AppletRequestTag    T120ResponseTag, GCCResponseTag, *PGCCResponseTag;
// enum
typedef AppletPriority      T120Priority;


typedef	LPBYTE          DomainSelector, *PDomainSelector;
typedef	USHORT          ConnectionHandle, *PConnectionHandle;
typedef	USHORT          ConnectID, *PConnectID;


#define GCC_INVALID_EID     0   // invalid entity id
#define GCC_INVALID_UID     0   // invalid user id
#define GCC_INVALID_NID     0   // invalid node id
#define GCC_INVALID_CID     0   // invalid conference id
#define GCC_INVALID_TID     0   // invalid token id
#define GCC_INVALID_TAG     0   // invalid request id




/*
 *	This section defines the valid return values from GCC function calls.  Do
 *	not confuse this return value with the Result and Reason values defined
 *	by T.124 (which are discussed later).  These values are returned directly
 *	from the call to the API entry point, letting you know whether or not the
 *	request for service was successfully invoked.  The Result and Reason
 *	codes are issued as part of an indication or confirm which occurs
 *	asynchronously to the call that causes it.
 *
 *	All GCC function calls return type GCCError.  Its valid values are as
 *	follows:
 *
 *	GCC_NO_ERROR
 *		This means that the request was successfully invoked.  It does NOT
 *		mean that the service has been successfully completed.  Remember that
 *		all GCC calls are non-blocking.  This means that each request call
 *		begins the process, and if necessary, a subsequent indication or
 *		confirm will result.  By convention, if ANY GCC call returns a value
 *		other than this, something went wrong.  Note that this value should
 *		also be returned to GCC during a callback if the application processes
 *		the callback successfully.
 *
 *	GCC_NOT_INITIALIZED
 *		The application has attempted to use GCC services before GCC has been
 *		initialized.  It is necessary for the node controller (or whatever
 *		application is serving as the node controller), to initialize GCC before
 *		it is called upon to perform any services.
 *
 *	GCC_ALREADY_INITIALIZED
 *		The application has attempted to initialize GCC when it is already
 *		initialized.
 *
 *	GCC_ALLOCATION_FAILURE
 *		This indicates a fatal resource error inside GCC.  It usually results
 *		in the automatic termination of the affected conference.
 *
 *	GCC_NO_SUCH_APPLICATION	
 *		This indicates that the Application SAP handle passed in was invalid.
 *
 *	GCC_INVALID_CONFERENCE
 *		This indicates that an illegal conference ID was passed in.
 *
 *	GCC_CONFERENCE_ALREADY_EXISTS
 *		The Conference specified in the request or response is already in
 *		existence.
 *
 *	GCC_NO_TRANSPORT_STACKS
 *		This indicates that MCS failed to load the TCP transport stack during
 *		initialization.  This is now an error.  MCS exits when this happens and
 *		can not be used any more, since NetMeeting is now a TCP-only
 *		product.
 *
 *	GCC_INVALID_ADDRESS_PREFIX
 *		The called address parameter in a request such as 
 *		GCCConferenceCreateRequest does not	contain a recognized prefix.  MCS 
 *		relies on the prefix to know which transport stack to invoke.
 *
 *	GCC_INVALID_TRANSPORT
 *		The dynamic load of a transport stack failed either because the DLL
 *		could not be found, or because it did not export at least one entry
 *		point that MCS requires.
 *
 *	GCC_FAILURE_CREATING_PACKET
 *		This is a FATAL error which means that for some reason the 
 *		communications packet generated due to a request could not be created.
 *		This typically flags a problem with the ASN.1 toolkit.
 *
 *	GCC_QUERY_REQUEST_OUTSTANDING
 *		This error indicates that all the domains that set aside for querying
 *		are used up by other outstanding query request.
 *
 *	GCC_INVALID_QUERY_TAG
 *		The query response tag specified in the query response is not valid.
 *
 *	GCC_FAILURE_CREATING_DOMAIN
 *		Many requests such as GCCConferenceCreateRequest require that an MCS
 *		domain be created.  If the request to MCS fails this will be returned.
 *
 *	GCC_CONFERENCE_NOT_ESTABLISHED
 *		If a request is made to a conference before it is established, this
 *		error value will be returned.
 *
 *	GCC_INVALID_PASSWORD
 *		The password passed in the request is not valid.  This usually means
 *		that a numeric string needs to be specified.
 *		
 *	GCC_INVALID_MCS_USER_ID
 *		All MCS User IDs must have a value greater than 1000.
 *
 *	GCC_INVALID_JOIN_RESPONSE_TAG
 *		The join response tag specified in the join response is not valid.
 *	
 *	GCC_TRANSPORT_NOT_READY
 *		Request was made to a transport before it was ready to process it.
 *
 *	GCC_DOMAIN_PARAMETERS_UNACCEPTABLE
 *		The specified domain parameters do not fit within the range allowable
 *		by GCC and MCS.
 *
 *	GCC_APP_NOT_ENROLLED
 *		Occurs if a request is made by an Application Protocol Entity to a
 *		conference before the "APE" is enrolled.
 *
 *	GCC_NO_GIVE_RESPONSE_PENDING
 *		This will occur if a conductor Give Request is issued before a 
 *		previously pending conductor Give Response has been processed.
 *
 *	GCC_BAD_NETWORK_ADDRESS_TYPE
 *		An illegal network address type was passed in.  Valid types are	
 *		GCC_AGGREGATED_CHANNEL_ADDRESS, GCC_TRANSPORT_CONNECTION_ADDRESS and
 *		GCC_NONSTANDARD_NETWORK_ADDRESS.
 *
 *	GCC_BAD_OBJECT_KEY
 *		The object key passed in is invalid.
 *
 *	GCC_INVALID_CONFERENCE_NAME
 *		The conference name passed in is not a valid conference name.
 *
 *	GCC_INVALID_CONFERENCE_MODIFIER
 *		The conference modifier passed in is not a valid conference name.
 *
 *	GCC_BAD_SESSION_KEY
 *		The session key passed in was not valid.
 *				  
 *	GCC_BAD_CAPABILITY_ID
 *		The capability ID passed into the request is not valid.
 *
 *	GCC_BAD_REGISTRY_KEY
 *		The registry key passed into the request is not valid.
 *
 *	GCC_BAD_NUMBER_OF_APES
 *		Zero was passed in for the number of APEs in the invoke request. Zero
 *		is illegal here.
 *
 *	GCC_BAD_NUMBER_OF_HANDLES
 *		A number < 1 or	> 1024 was passed into the allocate handle request.
 *		  
 *	GCC_ALREADY_REGISTERED
 *		The user application attempting to register itself has already 
 *		registered.
 *			  
 *	GCC_APPLICATION_NOT_REGISTERED	  
 *		The user application attempting to make a request to GCC has not 
 *		registered itself with GCC.
 *
 *	GCC_BAD_CONNECTION_HANDLE_POINTER
 *		A NULL connection handle pointer was passed in.
 * 
 *	GCC_INVALID_NODE_TYPE
 *		A node type value other than GCC_TERMINAL, GCC_MULTIPORT_TERMINAL or
 *		GCC_MCU was passed in.
 *
 *	GCC_INVALID_ASYMMETRY_INDICATOR
 *		An asymetry type other than GCC_ASYMMETRY_CALLER, GCC_ASYMMETRY_CALLED
 *		or GCC_ASYMMETRY_UNKNOWN was passed into the request.
 *	
 *	GCC_INVALID_NODE_PROPERTIES
 *		A node property other than GCC_PERIPHERAL_DEVICE, GCC_MANAGEMENT_DEVICE,
 *		GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE or	
 *		GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT was passed into the request.
 *		
 *	GCC_BAD_USER_DATA
 *		The user data list passed into the request was not valid.
 *				  
 *	GCC_BAD_NETWORK_ADDRESS
 *		There was something wrong with the actual network address portion of
 *		the passed in network address.
 *
 *	GCC_INVALID_ADD_RESPONSE_TAG
 *		The add response tag passed in the response does not match any add
 *		response tag passed back in the add indication.
 *			  
 *	GCC_BAD_ADDING_NODE
 *		You can not request that the adding node be the node where the add
 *		request is being issued.
 *				  
 *	GCC_FAILURE_ATTACHING_TO_MCS
 *		Request failed because GCC could not create a user attachment to MCS.
 *	  
 *	GCC_INVALID_TRANSPORT_ADDRESS	  
 *		The transport address specified in the request (usually the called
 *		address) is not valid.  This will occur when the transport stack
 *		detects an illegal transport address.
 *
 *	GCC_INVALID_PARAMETER
 *		This indicates an illegal parameter is passed into the GCC function
 *		call.
 *
 *	GCC_COMMAND_NOT_SUPPORTED
 *		This indicates that the user application has attempted to invoke an
 *		GCC service that is not yet supported.
 *
 *	GCC_UNSUPPORTED_ERROR
 *		An error was returned from a request to MCS that is not recognized 
 *		by GCC.
 *
 *	GCC_TRANSMIT_BUFFER_FULL
 *		Request can not be processed because the transmit buffer is full.
 *		This usually indicates a problem with the shared memory portal in the
 *		Win32 client.
 *		
 *	GCC_INVALID_CHANNEL
 *		The channel ID passed into the request is not a valid MCS channel ID
 *		(zero is not valid).
 *
 *	GCC_INVALID_MODIFICATION_RIGHTS
 *		The modification rights passed in in not one of the enumerated types
 *		supported.
 *
 *	GCC_INVALID_REGISTRY_ITEM
 *		The registry item passed in is not one of the valid enumerated types.
 *
 *	GCC_INVALID_NODE_NAME
 *		The node name passed in is not valid.  Typically this means that it
 *		is to long.
 *
 *	GCC_INVALID_PARTICIPANT_NAME
 *		The participant name passed in is not valid.  Typically this means that 
 *		it is to long.
 *		
 *	GCC_INVALID_SITE_INFORMATION
 *		The site information passed in is not valid.  Typically this means that 
 *		it is to long.
 *
 *	GCC_INVALID_NON_COLLAPSED_CAP
 *		The non-collapsed capability passed in is not valid.  Typically this 
 *		means that it is to long.
 *
 *	GCC_INVALID_ALTERNATIVE_NODE_ID
 *		Alternative node IDs can only be two characters long.
 */


/*
 *	This section defines the valid return values from MCS function calls.  Do
 *	not confuse this return value with the Result and Reason values defined
 *	by T.125 (which are discussed later).  These values are returned directly
 *	from the call to the API entry point, letting you know whether or not the
 *	request for service was successfully invoked.  The Result and Reason
 *	codes are issued as part of an indication or confirm which occurs
 *	asynchronously to the call that causes it.
 *
 *	All MCS function calls return type MCSError.  Its valid values are as
 *	follows:
 *
 *	MCS_NO_ERROR
 *		This means that the request was successfully invoked.  It does NOT
 *		mean that the service has been successfully completed.  Remember that
 *		all MCS calls are non-blocking.  This means that each request call
 *		begins the process, and if necessary, a subsequent indication or
 *		confirm will result.  By convention, if ANY MCS call returns a value
 *		other than this, something went wrong.  Note that this value should
 *		also be returned to MCS during a callback if the application processes
 *		the callback successfully.
 *	MCS_COMMAND_NOT_SUPPORTED
 *		This indicates that the user application has attempted to invoke an
 *		MCS service that is not yet supported.  Note that this return value
 *		will NEVER be returned from the release version of MCS, and is left
 *		defined only for backward compatibility.  It WILL be removed in a future
 *		version of MCS.
 *	MCS_NOT_INITIALIZED
 *		The application has attempted to use MCS services before MCS has been
 *		initialized.  It is necessary for the node controller (or whatever
 *		application is serving as the node controller), to initialize MCS before
 *		it is called upon to perform any services.
 *	MCS_ALREADY_INITIALIZED
 *		The application has attempted to initialize MCS when it is already
 *		initialized.
 *	MCS_NO_TRANSPORT_STACKS
 *		This indicates that MCS did not load the TCP transport stack during
 *		initialization.  This is now considered an error.  MCS can not
 *		be used in a local only manner.  We no longer load other ransport stacks can also be loaded
 *		after initialization using the call MCSLoadTransport.  Note that when
 *		getting this return code during initialization, it IS necessary for the
 *		node controller to cleanly shut down MCS.
 *	MCS_DOMAIN_ALREADY_EXISTS
 *		The application has attempted to create a domain that already exists.
 *	MCS_NO_SUCH_DOMAIN
 *		The application has attempted to use a domain that has not yet been
 *		created.
 *	MCS_USER_NOT_ATTACHED
 *		This indicates that the application has issued an MCS_AttachRequest,
 *		and then tried to use the returned handle before receiving an
 *		MCS_ATTACH_USER_CONFIRM (which essentially validates the handle).
 *	MCS_NO_SUCH_USER
 *		An MCS primitive has been invoked with an unknown user handle.
 *	MCS_TRANSMIT_BUFFER_FULL
 *		This indicates that the call failed due to an MCS resource shortage.
 *		This will typically occur when there is a LOT of traffic through the
 *		MCS layer.  It simply means that MCS could not process the request at
 *		this time.  It is the responsibility of the application to retry at a
 *		later time.
 *	MCS_NO_SUCH_CONNECTION
 *		An MCS primitive has been invoked with an unknown connection handle.
 *	MCS_DOMAIN_NOT_HIERARCHICAL
 *		An attempt has been made to create an upward connection from a local
 *		domain that already has an upward connection.
 *	MCS_INVALID_ADDRESS_PREFIX
 *		The called address parameter of MCSConnectProviderRequest does not
 *		contain a recognized prefix.  MCS relies on the prefix to know which
 *		transport stack to invoke.
 *	MCS_ALLOCATION_FAILURE
 *		The request could not be successfully invoked due to a memory allocation
 *		failure.
 *	MCS_INVALID_PARAMETER
 *		One of the parameters to the request is invalid.
 *	MCS_CALLBACK_NOT_PROCESSED
 *		This value should be returned to MCS during a callback if the
 *		application cannot process the callback at that time.  This provides
 *		a form of flow control between the application and MCS.  When MCS
 *		receives this return value during a callback, it will retry the same
 *		callback again during the next time slice.  Note that the user
 *		application can refuse a callback as many times as it wishes, but the
 *		programmer should be aware that this will cause MCS to "back up".
 *		Eventually this back pressure will cause MCS to refuse data from the
 *		transport layer (and so on).  Information should always be processed
 *		in a timely manner in order to insure smooth operation.
 *	MCS_DOMAIN_MERGING
 *		This value indicates that the call failed because of a domain merger
 *		that is in progress.  This will happen at the former Top Provider of
 *		the lower domain while it is still merging into the upper domain.
 *	MCS_TRANSPORT_NOT_READY
 *		This is returned from MCSConnectProviderRequest when the transport
 *		stack could not create the connection because it was not ready for the
 *		request.  This will usually happen if the request follows too closely
 *		behind the initialization of the transport stack (while it is still
 *		actively initializing).
 *	MCS_DOMAIN_PARAMETERS_UNACCEPTABLE
 *		This is returned from MCSConnectProviderResponse when the inbound
 *		connection could not be accepted because of no overlap in acceptable
 *		domain parameters.  Each MCS provider has a set of minimum and maximum
 *		domain parameters for each domain.  When a connection is to be created,
 *		the negotiated values will fall within the overlap of the two sets.
 *		If there is no overlap, then the connection cannot be accepted.  Note
 *		that this error does NOT refer to the acceptability of the domain
 *		parameters passed into the MCSConnectProviderResponse call.
 */

typedef	enum tagT120Error
{
	// the first values have to remain unmodified, because they match
	// MCS error values.
	T120_NO_ERROR			            = 0,

	T120_COMMAND_NOT_SUPPORTED,
	T120_NOT_INITIALIZED,
	T120_ALREADY_INITIALIZED,
	T120_NO_TRANSPORT_STACKS,
	T120_INVALID_ADDRESS_PREFIX,
	T120_ALLOCATION_FAILURE,
	T120_INVALID_PARAMETER,
	T120_TRANSPORT_NOT_READY,
	T120_DOMAIN_PARAMETERS_UNACCEPTABLE,
	T120_SECURITY_FAILED,
	
	// the following values can be modified in their orders
	GCC_NO_SUCH_APPLICATION             = 100,
	GCC_INVALID_CONFERENCE,
	GCC_CONFERENCE_ALREADY_EXISTS,
	GCC_INVALID_TRANSPORT,
	GCC_FAILURE_CREATING_PACKET,
	GCC_QUERY_REQUEST_OUTSTANDING,
	GCC_INVALID_QUERY_TAG,
	GCC_FAILURE_CREATING_DOMAIN,
	GCC_CONFERENCE_NOT_ESTABLISHED,
	GCC_INVALID_PASSWORD,
	GCC_INVALID_MCS_USER_ID,
	GCC_INVALID_JOIN_RESPONSE_TAG,
	GCC_APP_NOT_ENROLLED,
	GCC_NO_GIVE_RESPONSE_PENDING,
	GCC_BAD_NETWORK_ADDRESS_TYPE,
	GCC_BAD_OBJECT_KEY,	    
	GCC_INVALID_CONFERENCE_NAME,
	GCC_INVALID_CONFERENCE_MODIFIER,
	GCC_BAD_SESSION_KEY,
	GCC_BAD_CAPABILITY_ID,
	GCC_BAD_REGISTRY_KEY,
	GCC_BAD_NUMBER_OF_APES,
	GCC_BAD_NUMBER_OF_HANDLES,
	GCC_ALREADY_REGISTERED,
	GCC_APPLICATION_NOT_REGISTERED,
	GCC_BAD_CONNECTION_HANDLE_POINTER,
	GCC_INVALID_NODE_TYPE,
	GCC_INVALID_ASYMMETRY_INDICATOR,
	GCC_INVALID_NODE_PROPERTIES,
	GCC_BAD_USER_DATA,
	GCC_BAD_NETWORK_ADDRESS,
	GCC_INVALID_ADD_RESPONSE_TAG,
	GCC_BAD_ADDING_NODE,
	GCC_FAILURE_ATTACHING_TO_MCS,
	GCC_INVALID_TRANSPORT_ADDRESS,
	GCC_UNSUPPORTED_ERROR,
	GCC_TRANSMIT_BUFFER_FULL,
	GCC_INVALID_CHANNEL,
	GCC_INVALID_MODIFICATION_RIGHTS,
	GCC_INVALID_REGISTRY_ITEM,
	GCC_INVALID_NODE_NAME,
	GCC_INVALID_PARTICIPANT_NAME,
	GCC_INVALID_SITE_INFORMATION,
	GCC_INVALID_NON_COLLAPSED_CAP,
	GCC_INVALID_ALTERNATIVE_NODE_ID,
	GCC_INSUFFICIENT_PRIVILEGE,
	GCC_APPLET_EXITING,
	GCC_APPLET_CANCEL_EXIT,
	GCC_NYI,
	T120_POLICY_PROHIBIT,

	// the following values can be modified in their orders
	MCS_DOMAIN_ALREADY_EXISTS           = 200,
	MCS_NO_SUCH_DOMAIN,
	MCS_USER_NOT_ATTACHED,
	MCS_NO_SUCH_USER,
	MCS_TRANSMIT_BUFFER_FULL,
	MCS_NO_SUCH_CONNECTION,
	MCS_DOMAIN_NOT_HIERARCHICAL,
	MCS_CALLBACK_NOT_PROCESSED,
	MCS_DOMAIN_MERGING,
	MCS_DOMAIN_NOT_REGISTERED,
	MCS_SIZE_TOO_BIG,
	MCS_BUFFER_NOT_ALLOCATED,
	MCS_MORE_CALLBACKS,

    T12_ERROR_CHECK_T120_RESULT         = 299,
	INVALID_T120_ERROR                  = 300,
}
    T120Error, GCCError, *PGCCError, MCSError, *PMCSError;

#define GCC_NO_ERROR    T120_NO_ERROR
#define MCS_NO_ERROR    T120_NO_ERROR

#define GCC_COMMAND_NOT_SUPPORTED           T120_COMMAND_NOT_SUPPORTED
#define GCC_NOT_INITIALIZED                 T120_NOT_INITIALIZED
#define GCC_ALREADY_INITIALIZED             T120_ALREADY_INITIALIZED
#define GCC_NO_TRANSPORT_STACKS             T120_NO_TRANSPORT_STACKS
#define GCC_INVALID_ADDRESS_PREFIX          T120_INVALID_ADDRESS_PREFIX
#define GCC_ALLOCATION_FAILURE              T120_ALLOCATION_FAILURE
#define GCC_INVALID_PARAMETER               T120_INVALID_PARAMETER
#define GCC_TRANSPORT_NOT_READY             T120_TRANSPORT_NOT_READY
#define GCC_DOMAIN_PARAMETERS_UNACCEPTABLE  T120_DOMAIN_PARAMETERS_UNACCEPTABLE
#define GCC_SECURITY_FAILED                 T120_SECURITY_FAILED

#define MCS_COMMAND_NOT_SUPPORTED           T120_COMMAND_NOT_SUPPORTED
#define MCS_NOT_INITIALIZED                 T120_NOT_INITIALIZED
#define MCS_ALREADY_INITIALIZED             T120_ALREADY_INITIALIZED
#define MCS_NO_TRANSPORT_STACKS             T120_NO_TRANSPORT_STACKS
#define MCS_INVALID_ADDRESS_PREFIX          T120_INVALID_ADDRESS_PREFIX
#define MCS_ALLOCATION_FAILURE              T120_ALLOCATION_FAILURE
#define MCS_INVALID_PARAMETER               T120_INVALID_PARAMETER
#define MCS_TRANSPORT_NOT_READY             T120_TRANSPORT_NOT_READY
#define MCS_DOMAIN_PARAMETERS_UNACCEPTABLE  T120_DOMAIN_PARAMETERS_UNACCEPTABLE
#define MCS_SECURITY_FAILED                 T120_SECURITY_FAILED


//
// Token Status
//

typedef AppletTokenStatus       T120TokenStatus, TokenStatus;
#define TOKEN_NOT_IN_USE        APPLET_TOKEN_NOT_IN_USE
#define TOKEN_SELF_GRABBED      APPLET_TOKEN_SELF_GRABBED
#define TOKEN_OTHER_GRABBED     APPLET_TOKEN_OTHER_GRABBED
#define TOKEN_SELF_INHIBITED    APPLET_TOKEN_SELF_INHIBITED
#define TOKEN_OTHER_INHIBITED   APPLET_TOKEN_OTHER_INHIBITED
#define TOKEN_SELF_RECIPIENT    APPLET_TOKEN_SELF_RECIPIENT
#define TOKEN_SELF_GIVING       APPLET_TOKEN_SELF_GIVING
#define TOKEN_OTHER_GIVING      APPLET_TOKEN_OTHER_GIVING


/*
**	MCSReason
**      The order is important because they are in the same order of those
**      defined in mcspdu.h.
**  GCCReason
**		When GCC issues an indication to a user application, it often includes a
**		reason parameter informing the user of why the activity is occurring.
*/
typedef	enum
{
    REASON_DOMAIN_DISCONNECTED 		            = 0,
    REASON_PROVIDER_INITIATED 		            = 1,
    REASON_TOKEN_PURGED 			            = 2,
    REASON_USER_REQUESTED 			            = 3,
    REASON_CHANNEL_PURGED 			            = 4,
    REASON_REMOTE_NO_SECURITY			        = 5,
    REASON_REMOTE_DOWNLEVEL_SECURITY		    = 6,
    REASON_REMOTE_REQUIRE_SECURITY		        = 7,
	REASON_AUTHENTICATION_FAILED				= 8,

	GCC_REASON_USER_INITIATED					= 100,
	GCC_REASON_UNKNOWN							= 101,
	GCC_REASON_NORMAL_TERMINATION				= 102,
	GCC_REASON_TIMED_TERMINATION				= 103,
	GCC_REASON_NO_MORE_PARTICIPANTS				= 104,
	GCC_REASON_ERROR_TERMINATION				= 105,
	GCC_REASON_ERROR_LOW_RESOURCES				= 106,
	GCC_REASON_MCS_RESOURCE_FAILURE				= 107,
	GCC_REASON_PARENT_DISCONNECTED				= 108,
	GCC_REASON_CONDUCTOR_RELEASE				= 109,
	GCC_REASON_SYSTEM_RELEASE					= 110,
	GCC_REASON_NODE_EJECTED						= 111,
	GCC_REASON_HIGHER_NODE_DISCONNECTED 		= 112,
	GCC_REASON_HIGHER_NODE_EJECTED				= 113,
	GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE	= 114,
	INVALID_GCC_REASON,
}
    T120Reason, Reason, *PReason, GCCReason, *PGCCReason;

/*
**	MCSResult
**      The order is important because they are in the same order of those
**      defined in mcspdu.h.
**	GCCResult
**		When a user makes a request of GCC, GCC often responds with a result,
**		letting the user know whether or not the request succeeded.
*/
typedef	enum
{
    T120_RESULT_SUCCESSFUL              = 0,

    RESULT_DOMAIN_MERGING               = 1,
    RESULT_DOMAIN_NOT_HIERARCHICAL      = 2,
    RESULT_NO_SUCH_CHANNEL              = 3,
    RESULT_NO_SUCH_DOMAIN               = 4,
    RESULT_NO_SUCH_USER                 = 5,
    RESULT_NOT_ADMITTED                 = 6,
    RESULT_OTHER_USER_ID                = 7,
    RESULT_PARAMETERS_UNACCEPTABLE      = 8,
    RESULT_TOKEN_NOT_AVAILABLE          = 9,
    RESULT_TOKEN_NOT_POSSESSED          = 10,
    RESULT_TOO_MANY_CHANNELS            = 11,
    RESULT_TOO_MANY_TOKENS              = 12,
    RESULT_TOO_MANY_USERS               = 13,
    RESULT_UNSPECIFIED_FAILURE          = 14,
    RESULT_USER_REJECTED                = 15,
    RESULT_REMOTE_NO_SECURITY           = 16,
    RESULT_REMOTE_DOWNLEVEL_SECURITY    = 17,
    RESULT_REMOTE_REQUIRE_SECURITY      = 18,
	RESULT_AUTHENTICATION_FAILED		= 19,

	GCC_RESULT_RESOURCES_UNAVAILABLE   			= 101,
	GCC_RESULT_INVALID_CONFERENCE	   			= 102,
	GCC_RESULT_INVALID_PASSWORD		   			= 103,
	GCC_RESULT_INVALID_CONVENER_PASSWORD		= 104,
	GCC_RESULT_SYMMETRY_BROKEN		   			= 105,
	GCC_RESULT_UNSPECIFIED_FAILURE	   			= 106,
	GCC_RESULT_NOT_CONVENER_NODE	   			= 107,
	GCC_RESULT_REGISTRY_FULL		   			= 108,
	GCC_RESULT_INDEX_ALREADY_OWNED 	   			= 109,
	GCC_RESULT_INCONSISTENT_TYPE 	   			= 110,
	GCC_RESULT_NO_HANDLES_AVAILABLE	   			= 111,
	GCC_RESULT_CONNECT_PROVIDER_FAILED 			= 112,
	GCC_RESULT_CONFERENCE_NOT_READY    			= 113,
	GCC_RESULT_USER_REJECTED		   			= 114,
	GCC_RESULT_ENTRY_DOES_NOT_EXIST    			= 115,
	GCC_RESULT_NOT_CONDUCTIBLE	   	   			= 116,
	GCC_RESULT_NOT_THE_CONDUCTOR	   			= 117,
	GCC_RESULT_NOT_IN_CONDUCTED_MODE   			= 118,
	GCC_RESULT_IN_CONDUCTED_MODE	   			= 119,
	GCC_RESULT_ALREADY_CONDUCTOR	   			= 120,
	GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED		= 121,
	GCC_RESULT_INVALID_CHALLENGE_RESPONSE		= 122,
	GCC_RESULT_INVALID_REQUESTER				= 123,
	GCC_RESULT_ENTRY_ALREADY_EXISTS				= 124,	
	GCC_RESULT_INVALID_NODE						= 125,
	GCC_RESULT_INVALID_SESSION_KEY				= 126,
	GCC_RESULT_INVALID_CAPABILITY_ID			= 127,
	GCC_RESULT_INVALID_NUMBER_OF_HANDLES		= 128,	
	GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING		= 129,
	GCC_RESULT_INCOMPATIBLE_PROTOCOL			= 130,
	GCC_RESULT_CONFERENCE_ALREADY_LOCKED		= 131,
	GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED		= 132,
	GCC_RESULT_INVALID_NETWORK_TYPE				= 133,
	GCC_RESULT_INVALID_NETWORK_ADDRESS			= 134,
	GCC_RESULT_ADDED_NODE_BUSY					= 135,
	GCC_RESULT_NETWORK_BUSY						= 136,
	GCC_RESULT_NO_PORTS_AVAILABLE				= 137,
	GCC_RESULT_CONNECTION_UNSUCCESSFUL			= 138,
	GCC_RESULT_LOCKED_NOT_SUPPORTED    			= 139,
	GCC_RESULT_UNLOCK_NOT_SUPPORTED				= 140,
	GCC_RESULT_ADD_NOT_SUPPORTED				= 141,
	GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE	= 142,
	GCC_RESULT_CANCELED                         = 143,
	GCC_RESULT_CONNECT_PROVIDER_REMOTE_NO_SECURITY          = 144,
	GCC_RESULT_CONNECT_PROVIDER_REMOTE_DOWNLEVEL_SECURITY   = 145,
	GCC_RESULT_CONNECT_PROVIDER_REMOTE_REQUIRE_SECURITY     = 146,
	GCC_RESULT_CONNECT_PROVIDER_AUTHENTICATION_FAILED		= 147,

	T120_RESULT_CHECK_T120_ERROR                = 148,
	INVALID_GCC_RESULT,
}
    T120Result, Result, *PResult, GCCResult, *PGCCResult;

#define RESULT_SUCCESSFUL           T120_RESULT_SUCCESSFUL
#define GCC_RESULT_SUCCESSFUL       T120_RESULT_SUCCESSFUL



//
//  T120 Messages (Control SAP and Applet SAP)
//

typedef enum
{
    /******************* NODE CONTROLLER CALLBACKS ***********************/
    
    /* Conference Create, Terminate related calls */
    GCC_CREATE_INDICATION                   = 0,
    GCC_CREATE_CONFIRM                      = 1,
    GCC_QUERY_INDICATION                    = 2,
    GCC_QUERY_CONFIRM                       = 3,
    GCC_JOIN_INDICATION                     = 4,
    GCC_JOIN_CONFIRM                        = 5,
    GCC_INVITE_INDICATION                   = 6,
    GCC_INVITE_CONFIRM                      = 7,
    GCC_ADD_INDICATION                      = 8,
    GCC_ADD_CONFIRM                         = 9,
    GCC_LOCK_INDICATION                     = 10,
    GCC_LOCK_CONFIRM                        = 11,
    GCC_UNLOCK_INDICATION                   = 12,
    GCC_UNLOCK_CONFIRM                      = 13,
    GCC_LOCK_REPORT_INDICATION              = 14,
    GCC_DISCONNECT_INDICATION               = 15,
    GCC_DISCONNECT_CONFIRM                  = 16,
    GCC_TERMINATE_INDICATION                = 17,
    GCC_TERMINATE_CONFIRM                   = 18,
    GCC_EJECT_USER_INDICATION               = 19,
    GCC_EJECT_USER_CONFIRM                  = 20,
    GCC_TRANSFER_INDICATION                 = 21,
    GCC_TRANSFER_CONFIRM                    = 22,
    GCC_APPLICATION_INVOKE_INDICATION       = 23,        /* SHARED CALLBACK */
    GCC_APPLICATION_INVOKE_CONFIRM          = 24,        /* SHARED CALLBACK */
    GCC_SUB_INITIALIZED_INDICATION          = 25,

    /* Conference Roster related callbacks */
    GCC_ANNOUNCE_PRESENCE_CONFIRM           = 26,
    GCC_ROSTER_REPORT_INDICATION            = 27,        /* SHARED CALLBACK */
    GCC_ROSTER_INQUIRE_CONFIRM              = 28,        /* SHARED CALLBACK */

    /* Conductorship related callbacks */
    GCC_CONDUCT_ASSIGN_INDICATION           = 29,        /* SHARED CALLBACK */
    GCC_CONDUCT_ASSIGN_CONFIRM              = 30,
    GCC_CONDUCT_RELEASE_INDICATION          = 31,        /* SHARED CALLBACK */
    GCC_CONDUCT_RELEASE_CONFIRM             = 32,
    GCC_CONDUCT_PLEASE_INDICATION           = 33,
    GCC_CONDUCT_PLEASE_CONFIRM              = 34,
    GCC_CONDUCT_GIVE_INDICATION             = 35,
    GCC_CONDUCT_GIVE_CONFIRM                = 36,
    GCC_CONDUCT_INQUIRE_CONFIRM             = 37,        /* SHARED CALLBACK */
    GCC_CONDUCT_ASK_INDICATION              = 38,
    GCC_CONDUCT_ASK_CONFIRM                 = 39,
    GCC_CONDUCT_GRANT_INDICATION            = 40,        /* SHARED CALLBACK */
    GCC_CONDUCT_GRANT_CONFIRM               = 41,

    /* Miscellaneous Node Controller callbacks */
    GCC_TIME_REMAINING_INDICATION           = 42,
    GCC_TIME_REMAINING_CONFIRM              = 43,
    GCC_TIME_INQUIRE_INDICATION             = 44,
    GCC_TIME_INQUIRE_CONFIRM                = 45,
    GCC_CONFERENCE_EXTEND_INDICATION        = 46,
    GCC_CONFERENCE_EXTEND_CONFIRM           = 47,
    GCC_ASSISTANCE_INDICATION               = 48,
    GCC_ASSISTANCE_CONFIRM                  = 49,
    GCC_TEXT_MESSAGE_INDICATION             = 50,
    GCC_TEXT_MESSAGE_CONFIRM                = 51,

    /***************** USER APPLICATION CALLBACKS *******************/

    /* Application Roster related callbacks */
    GCC_PERMIT_TO_ENROLL_INDICATION         = 52,
    GCC_ENROLL_CONFIRM                      = 53,
    GCC_APP_ROSTER_REPORT_INDICATION        = 54,        /* SHARED CALLBACK */
    GCC_APP_ROSTER_INQUIRE_CONFIRM          = 55,        /* SHARED CALLBACK */

    /* Application Registry related callbacks */
    GCC_REGISTER_CHANNEL_CONFIRM            = 56,
    GCC_ASSIGN_TOKEN_CONFIRM                = 57,
    GCC_RETRIEVE_ENTRY_CONFIRM              = 58,
    GCC_DELETE_ENTRY_CONFIRM                = 59,
    GCC_SET_PARAMETER_CONFIRM               = 60,
    GCC_MONITOR_INDICATION                  = 61,
    GCC_MONITOR_CONFIRM                     = 62,
    GCC_ALLOCATE_HANDLE_CONFIRM             = 63,

    /****************** NON-Standard Primitives **********************/

    GCC_PERMIT_TO_ANNOUNCE_PRESENCE         = 100,    /*    Node Controller Callback */    
    GCC_CONNECTION_BROKEN_INDICATION        = 101,    /*    Node Controller Callback */
    GCC_FATAL_ERROR_SAP_REMOVED             = 102,    /*    Application Callback     */
    GCC_STATUS_INDICATION                   = 103,    /*    Node Controller Callback */
    GCC_TRANSPORT_STATUS_INDICATION         = 104,    /*    Node Controller Callback */

    T120_JOIN_SESSION_CONFIRM               = 120,

    /******************* MCS CALLBACKS ***********************/

    MCS_CONNECT_PROVIDER_INDICATION         = 200,
    MCS_CONNECT_PROVIDER_CONFIRM            = 201,
    MCS_DISCONNECT_PROVIDER_INDICATION      = 202,
    MCS_ATTACH_USER_CONFIRM                 = 203,
    MCS_DETACH_USER_INDICATION              = 204,
    MCS_CHANNEL_JOIN_CONFIRM                = 205,
    MCS_CHANNEL_LEAVE_INDICATION            = 206,
    MCS_CHANNEL_CONVENE_CONFIRM             = 207,
    MCS_CHANNEL_DISBAND_INDICATION          = 208,
    MCS_CHANNEL_ADMIT_INDICATION            = 209,
    MCS_CHANNEL_EXPEL_INDICATION            = 210,
    MCS_SEND_DATA_INDICATION                = 211,
    MCS_UNIFORM_SEND_DATA_INDICATION        = 212,
    MCS_TOKEN_GRAB_CONFIRM                  = 213,
    MCS_TOKEN_INHIBIT_CONFIRM               = 214,
    MCS_TOKEN_GIVE_INDICATION               = 215,
    MCS_TOKEN_GIVE_CONFIRM                  = 216,
    MCS_TOKEN_PLEASE_INDICATION             = 217,
    MCS_TOKEN_RELEASE_CONFIRM               = 218,
    MCS_TOKEN_TEST_CONFIRM                  = 219,
    MCS_TOKEN_RELEASE_INDICATION            = 220,
    MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION= 221,
    MCS_LAST_USER_MESSAGE                   = 222,

    /******************* Non-standard MCS CALLBACKS ***********************/
    
    MCS_TRANSPORT_STATUS_INDICATION         = 301,
}
    T120MessageType;



/*
 *	MCS_CONNECT_PROVIDER_INDICATION
 *
 *	Parameter:
 *		PConnectProviderIndication
 *			This is a pointer to a structure that contains all necessary
 *			information about an incoming connection.
 *
 *	Functional Description:
 *		This indication is sent to the node controller when an incoming
 *		connection is detected.  The node controller should respond by calling
 *		MCSConnectProviderResponse indicating whether or not the connection
 *		is to be accepted.
 */

/*
 *	MCS_CONNECT_PROVIDER_CONFIRM
 *
 *	Parameter:
 *		PConnectProviderConfirm
 *			This is a pointer to a structure that contains all necessary
 *			information about an outgoing connection.
 *
 *	Functional Description:
 *		This confirm is sent to the node controller in response to a previous
 *		call to MCSConnectProviderRequest.  It informs the node controller
 *		of when the new connection is available for use, or that the
 *		connection could not be established (or that it was rejected by the
 *		remote site).
 */

/*
 *	MCS_DISCONNECT_PROVIDER_INDICATION
 *
 *	Parameter:
 *		PDisconnectProviderIndication
 *			This is a pointer to a structure that contains all necessary
 *			information about a connection that has been lost.
 *
 *	Functional Description:
 *		This indication is sent to the node controller whenever a connection
 *		is lost.  This essentially tells the node controller that the contained
 *		connection handle is no longer valid.
 */

/*
 *	MCS_ATTACH_USER_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) UserID
 *			If the result is success, then this is the newly assigned user ID.
 *			If the result is failure, then this field is undefined.
 *		(HIGHUSHORT) Result
 *			This is the result of the attach user request.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCS_AttachRequest.  It contains the result of that service
 *		request.  If successful, it also contains the user ID that has been
 *		assigned to that attachment.
 */

/*
 *	MCS_DETACH_USER_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) UserID
 *			This is the user ID of the user that is detaching.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the detachment.
 *
 *	Functional Description:
 *		This indication is sent to the user application whenever a user detaches
 *		from the domain.  This is sent to ALL remaining users in the domain
 *		automatically.  Note that if the user ID contained in this indication
 *		is the same as that of the application receiving it, the application is
 *		essentially being told that it has been kicked out of the conference.
 *		The user handle and user ID are no longer valid in this case.  It is the
 *		responsibility of the application to recognize when this occurs.
 */

/*
 *	MCS_CHANNEL_JOIN_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been joined.
 *		(HIGHUSHORT) Result
 *			This is the result of the join request.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSChannelJoinRequest.  It lets the application know if the
 *		join was successful for a particular channel.  Furthermore, if the
 *		join request was for channel 0 (zero), then the ID of the assigned
 *		channel is contained in this confirm.
 */

/*
 *	MCS_CHANNEL_LEAVE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been left or is being told to leave.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the leave.
 *
 *	Functional Description:
 *		This indication is sent to a user application when a domain merger has
 *		caused a channel to be purged from the lower domain.  This informs the
 *		the user that it is no longer joined to the channel.
 */

/*
 *	MCS_CHANNEL_CONVENE_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that is being convened.
 *		(HIGHUSHORT) Result
 *			This is the result of the convene request.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSChannelConveneRequest.  It lets the application know whether
 *		or not the convene request was successful, and if so, what the channel
 *		number is.
 */

/*
 *	MCS_CHANNEL_DISBAND_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that is being disbanded.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the disband.
 *
 *	Functional Description:
 *		This indication is sent to a user application when a private channel
 *		that it convened is disbanded by MCS.  This is sent to only the channel
 *		manager (all other members of the private channel will receive an
 *		MCS_CHANNEL_EXPEL_INDICATION).
 */

/*
 *	MCS_CHANNEL_ADMIT_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that the user is being admitted to.
 *		(HIGHUSHORT) UserID
 *			This is the User ID of the manager of this private channel.
 *
 *	Functional Description:
 *		This indication is sent to a user application when it is admitted to
 *		a private channel (its User ID is added to the authorized user list).
 *		This lets the user know that it is now allowed to use the private
 *		channel.
 */

/*
 *	MCS_CHANNEL_EXPEL_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that the user is being expelled from.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the expel.
 *
 *	Functional Description:
 *		This indication is sent to a user application when it is expelled from
 *		a private channel (its User ID is removed from the authorized user
 *		list).  This lets the user know that it is no longer allowed to use
 *		the private channel.
 */

/*
 *	MCS_SEND_DATA_INDICATION
 *
 *	Parameter:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *
 *	Functional Description:
 *		This indication is sent to a user application when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */

/*
 *	MCS_UNIFORM_SEND_DATA_INDICATION
 *
 *	Parameter:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *
 *	Functional Description:
 *		This indication is sent to a user application when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */

/*
 *	MCS_TOKEN_GRAB_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application has attempted
 *			to grab.
 *		(HIGHUSHORT) Result
 *			This is the result of the token grab operation.  This will be
 *			RESULT_SUCCESSFUL if the token was grabbed.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenGrabRequest.  It lets the application know if the grab
 *		request was successful or not.
 */

/*
 *	MCS_TOKEN_INHIBIT_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application has attempted
 *			to inhibit.
 *		(HIGHUSHORT) Result
 *			This is the result of the token inhibit operation.  This will be
 *			RESULT_SUCCESSFUL if the token was inhibited.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenInhibitRequest.  It lets the application know if the
 *		inhibit request was successful or not.
 */

/*
 *	MCS_TOKEN_GIVE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token being offered to another user.
 *		(HIGHUSHORT) UserID
 *			This is the User ID of the user that is attempting to give the
 *			token away.
 *
 *	Functional Description:
 *		This indication is sent to a user application when another user in the
 *		domain attempts to give a token to it.  The user application should
 *		respond by calling MCSTokenGiveResponse indicating whether or not the
 *		token was accepted.
 */

/*
 *	MCS_TOKEN_GIVE_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token being offered to another user.
 *		(HIGHUSHORT) Result
 *			This is the result of the token give operation.  This will be
 *			RESULT_SUCCESSFUL if the token was accepted.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenGiveRequest (which in turn will cause another user to
 *		call MCSTokenGiveResponse).  The result code will inform the user
 *		as to whether or not the token was accepted.
 */

/*
 *	MCS_TOKEN_PLEASE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application would like to
 *			gain possesion of.
 *		(HIGHUSHORT) UserID
 *			This is the User ID of the user that is asking to receive ownership
 *			of a token.
 *
 *	Functional Description:
 *		This indication is sent to all owners (grabbers or inhibitors) of a
 *		token when a user issues an MCSTokenPleaseRequest.  This allows a user
 *		to "ask" for possession of a token without having to know exactly
 *		who currently owns it (MCS will route this indication appropriately).
 */

/*
 *	MCS_TOKEN_RELEASE_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application has attempted
 *			to release.
 *		(HIGHUSHORT) Result
 *			This is the result of the token release operation.  This will be
 *			RESULT_SUCCESSFUL if the token was released.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenReleaseRequest.  It lets the application know if the
 *		release request was successful or not.
 */

/*
 *	MCS_TOKEN_TEST_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application is testing.
 *		(HIGHUSHORT) TokenStatus
 *			This is the status of that token.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenTestRequest.  It lets the application know the current
 *		state of the specified token.
 */

/*
 *	MCS_TOKEN_RELEASE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that is being taken away from its
 *			current owner.
 *		(HIGHUSHORT) Reason
 *			This is the reason that the token is being taken away from its
 *			owner.
 *
 *	Functional Description:
 *		This indication is sent to a user application when a domain merger has
 *		caused a token to be purged from the lower domain.  This tells the
 *		user that a token that it used to own has been taken away.
 */

/*
 *	MCS_MERGE_DOMAIN_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) MergeStatus
 *			The is the status of the merge.  This informs the applications of
 *			whether the merge is just starting, or whether it is complete.
 *
 *	Functional Description:
 *		This indication is sent to the application when a provider begins
 *		merging its information base upward.  It informs the application that
 *		all domain activity is temporarily suspended.  It is sent again when the
 *		merge operation is complete, letting the application know that domain
 *		activity is once again valid.
 */

/*
 *  MCS_TRANSPORT_STATUS_INDICATION
 *
 *	This primitive is non-standard, and is issed through MCS by a transport
 *	stack when a state change occurs.  MCS merely passes the information
 *	through to the node controller.  This primitive will NOT be received by
 *	any user attachment.
 */


#endif // _T120_TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmmkcert\nmmkcert.cpp ===
//+-------------------------------------------------------------------------
//
// NmMkCert - NetMeeting internal certificate generator
//
//            Generates NetMeeting default user certificates. The NetMeeting
//            root key and certificate are stored as a program resource.
//
// ClausGi    7/29/98 created based on MAKECERT
//
//--------------------------------------------------------------------------

#include "global.h"
#include <oprahcom.h>

#ifdef DEBUG
HDBGZONE    ghDbgZone = NULL;
static PTCHAR _rgZonesNmMkCert[] = { TEXT("nmmkcert"), };
#endif /* DEBUG */

//+-------------------------------------------------------------------------
//  contants
//--------------------------------------------------------------------------

//allow max 10 extensions per certificate
#define MAX_EXT_CNT 10

//+-------------------------------------------------------------------------
//  globals
//--------------------------------------------------------------------------

WCHAR*   g_wszSubjectKey            = L"_NmMkCert";
WCHAR*     g_wszSubjectStore          = WSZNMSTORE;
DWORD     g_dwSubjectStoreFlag          = CERT_SYSTEM_STORE_CURRENT_USER;

DWORD     g_dwIssuerKeySpec          = AT_SIGNATURE;
DWORD    g_dwSubjectKeySpec         = AT_KEYEXCHANGE;

WCHAR   *g_wszSubjectDisplayName = NULL; // BUGBUG set this?

LPWSTR  g_wszIssuerProviderName   = NULL;
LPWSTR    g_wszSubjectProviderName    = NULL;

WCHAR*   g_wszSubjectX500Name;

DWORD g_dwProvType = PROV_RSA_FULL;

HMODULE    hModule=NULL;

BOOL MakeCert(DWORD dwFlags);

BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            hModule = hDllInst;
            ASSERT (hModule != NULL);
            DBGINIT(&ghDbgZone, _rgZonesNmMkCert);
            DisableThreadLibraryCalls (hDllInst);
            DBG_INIT_MEMORY_TRACKING(hDllInst);
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            DBG_CHECK_MEMORY_TRACKING(hDllInst);
            hModule = NULL;
            break;
        }

        default:
            break;
    }
    return (TRUE);
}

//
// X.509 cert strings must be from X.208 printable character set... this
// function enforces that.
//

static const char szPrintable[] = " '()+,-./:=?\"";   // along with A-Za-z0-9

VOID MkPrintableString ( LPSTR szString )
{
    CHAR * p = szString;

    while ( *p )
    {
        if (!(('a' <= *p && *p <='z') ||
              ('A' <= *p && *p <='Z') ||
              ('0' <= *p && *p <='9') ||
              _StrChr(szPrintable,*p)))
        {
            *p = '-';
        }
        p++;
    }
}

DWORD WINAPI NmMakeCert(     LPCSTR szFirstName,
                            LPCSTR szLastName,
                            LPCSTR szEmailName,
                            LPCSTR szCity,
                            LPCSTR szCountry,
                            DWORD flags)
{
    DWORD dwRet = -1;

    WARNING_OUT(("NmMakeCert called"));

    // Form the unencoded X500 subject string. It would be nice to
    // use official constants for the below... CertRDNValueToString?

    UINT cbX500Name = ( szFirstName ? lstrlen(szFirstName) : 0 ) +
                      ( szLastName ? lstrlen(szLastName) : 0 ) +
                      ( szEmailName ? lstrlen(szEmailName) : 0 ) +
                      ( szCity ? lstrlen(szCity) : 0 ) +
                      ( szCountry ? lstrlen(szCountry) : 0 ) +
                      128; // Extra is for RDN OID strings: CN= etc.

    char * pX500Name = new char[cbX500Name];

    if ( NULL == pX500Name )
    {
        ERROR_OUT(("couldn't allocate %d bytes for x500 name", cbX500Name));
        goto cleanup;
    }

    ASSERT( ( szFirstName && *szFirstName ) || ( szLastName && *szLastName ) );

    wsprintf( pX500Name, "CN=\"%s %s\"", szFirstName ? szFirstName : "", szLastName ? szLastName : "" );

    if ( szEmailName && *szEmailName )
        wsprintf( pX500Name + lstrlen(pX500Name), ", E=\"%s\"", szEmailName );

    if ( szCity && *szCity )
        wsprintf( pX500Name + lstrlen(pX500Name), ", S=\"%s\"", szCity );

    if ( szCountry && *szCountry )
        wsprintf( pX500Name + lstrlen(pX500Name), ", C=\"%s\"", szCountry );

    MkPrintableString ( pX500Name );

    g_wszSubjectX500Name = AnsiToUnicode ( pX500Name );

    ASSERT(g_wszSubjectX500Name);

    if ( flags & NMMKCERT_F_LOCAL_MACHINE )
    {
        // We are being asked to generate a local machine cert...
        // change the subject store flag and the key container name
        g_dwSubjectStoreFlag          = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        g_wszSubjectKey = L"_NmMkMchCert";
    }

    // If we're on NT5 we have to generate the cert using the
    // PROV_RSA_SCHANNEL provider, on other platforms this provider type
    // doesn't exist.

    OSVERSIONINFO       osVersion;

    ZeroMemory(&osVersion, sizeof(osVersion));
    osVersion.dwOSVersionInfoSize = sizeof(osVersion);
    GetVersionEx(&osVersion);

    if (osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        osVersion.dwMajorVersion >= 5)
    {
        g_dwProvType = PROV_RSA_SCHANNEL;
    }
        
    // Get to work and make the certificate
    if (!MakeCert(flags))
    {
        WARNING_OUT(("NmMakeCert failed."));
    }
    else
    {
        dwRet = 1;
    }

cleanup:

    if ( NULL != g_wszSubjectX500Name )
    {
        delete g_wszSubjectX500Name;
    }

    if ( NULL != pX500Name )
    {
        delete [] pX500Name;
    }

    return dwRet;
}


// RUNDLL entry point for certificate uninstall... the prototype is given
// by RUNDLL32.EXE requirements!
void CALLBACK NmMakeCertCleanup ( HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow )
{
    // Clean up exisint certs and private keys
    MakeCert(NMMKCERT_F_CLEANUP_ONLY);
    g_dwSubjectStoreFlag          = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    g_wszSubjectKey = L"_NmMkMchCert";
    MakeCert(NMMKCERT_F_LOCAL_MACHINE|NMMKCERT_F_CLEANUP_ONLY);
}


//+=========================================================================
//  Local Support Functions
//==========================================================================

//+=========================================================================
//  MakeCert support functions
//==========================================================================

BOOL VerifyIssuerKey( IN HCRYPTPROV hProv,
        IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo);
HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer);

BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    );
BOOL EncodeSubject(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
BOOL CreateSpcCommonName(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

BOOL    SaveCertToStore(HCRYPTPROV    hProv,        
                        HCERTSTORE        hStore,        
                        DWORD        dwFlag,
                        BYTE        *pbEncodedCert,    
                        DWORD        cbEncodedCert,
                        LPWSTR        wszPvk,            
                        DWORD        dwKeySpecification,
                        LPWSTR        wszCapiProv,        
                        DWORD        dwCapiProvType);


//+-------------------------------------------------------------------------
//  Get the root's certificate from the program's resources
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetRootCertContext()
{
    PCCERT_CONTEXT    pCert = NULL;
    HRSRC            hRes;

    //
    // The root certificate is stored as a resource of ours.
    // Load it...
    //
    if (0 != (hRes = FindResource(hModule, MAKEINTRESOURCE(IDR_ROOTCERTIFICATE),
                        "CER"))) {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(hModule, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(hModule, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);

            if (cbRes && pbRes)
                pCert = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                    pbRes, cbRes);
            if ( NULL == pCert )
            {
                DWORD dwError = GetLastError();
            }

            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (pCert == NULL)
    {
        ERROR_OUT(("Error creating root cert: %x", GetLastError()));
    }
    return pCert;
}

//+-------------------------------------------------------------------------
//  Get the root's private key from the program's resources and create
//  a temporary key provider container
//--------------------------------------------------------------------------
HCRYPTPROV GetRootProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV        hProv = 0;
    HRSRC            hRes;
    WCHAR            wszRootSig[] = L"Root Signature";

    *ppwszTmpContainer = NULL;

    if (0 != (hRes = FindResource(hModule,MAKEINTRESOURCE(IDR_PVKROOT),"PVK")))
    {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(hModule, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(hModule, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);
            if (cbRes && pbRes) {
                PvkPrivateKeyAcquireContextFromMemory(
                    g_wszIssuerProviderName,
                    PROV_RSA_FULL,
                    pbRes,
                    cbRes,
                    NULL,               // hwndOwner
                    wszRootSig,
                    &g_dwIssuerKeySpec,
                    &hProv
                    );
            }
            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (hProv == 0)
    {
        ERROR_OUT(("couldn't create root key provider: %x", GetLastError()));
    }
    return hProv;
}

//+-------------------------------------------------------------------------
//  Make the subject certificate. If the subject doesn't have a private
//  key, then, create.
//--------------------------------------------------------------------------
BOOL MakeCert(DWORD dwFlags)
{
    BOOL fResult;

    HCRYPTPROV        hIssuerProv = 0;
    LPWSTR            pwszTmpIssuerContainer = NULL;
    PCCERT_CONTEXT    pIssuerCertContext = NULL;
    PCERT_INFO        pIssuerCert =NULL; // not allocated

    HCRYPTPROV        hSubjectProv = 0;
    LPWSTR            pwszTmpSubjectContainer = NULL;

    PCERT_PUBLIC_KEY_INFO pSubjectPubKeyInfo = NULL;         // not allocated
    PCERT_PUBLIC_KEY_INFO pAllocSubjectPubKeyInfo = NULL;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded =0;
    BYTE *pbSpcCommonNameEncoded = NULL;
    DWORD cbSpcCommonNameEncoded =0;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded =0;
    BYTE *pbEKUEncoded = NULL;
    DWORD cbEKUEncoded = 0;

    CERT_INFO Cert;
    GUID SerialNumber;
    HCERTSTORE                hStore=NULL;

    CERT_EXTENSION rgExt[MAX_EXT_CNT];
    DWORD cExt = 0;

    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm = {
        szOID_RSA_MD5RSA, 0, 0
    };

    if (0 == (hSubjectProv = GetSubjectProv(&pwszTmpSubjectContainer)))
        goto ErrorReturn;


#define TEMP_CLEAN_CODE
#ifdef TEMP_CLEAN_CODE
    // open the system store where we used to generate certs
    hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        hSubjectProv,
        CERT_STORE_NO_CRYPT_RELEASE_FLAG | g_dwSubjectStoreFlag,
        L"MY" );

	if ( hStore )
	{
		//
		// Delete all old certs
		//
		PCCERT_CONTEXT pCertContext = NULL;

		// Clear out any certificate(s) we may have added before
		while ( pCertContext = CertEnumCertificatesInStore(
										hStore, (PCERT_CONTEXT)pCertContext ))
		{
			DWORD dwMagic;
			DWORD cbMagic;

			cbMagic = sizeof(dwMagic);

			if (CertGetCertificateContextProperty(pCertContext,
				CERT_FIRST_USER_PROP_ID, &dwMagic, &cbMagic) &&
				cbMagic == sizeof(dwMagic) && dwMagic == NMMKCERT_MAGIC )
			{
				CertDeleteCertificateFromStore(pCertContext);
				// Restart the enumeration
				pCertContext = NULL;
				continue;
			}
		}
		CertCloseStore(hStore,0);
	}
#endif // TEMP_CLEAN_CODE

    // open a new cert store
    hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        hSubjectProv,
        CERT_STORE_NO_CRYPT_RELEASE_FLAG | g_dwSubjectStoreFlag,
        g_wszSubjectStore);

    if(hStore==NULL)
        goto ErrorReturn;
        
    // Empty the store
    PCCERT_CONTEXT pCertContext;
    while ( pCertContext = CertEnumCertificatesInStore ( hStore, NULL ))
    {
        if ( !CertDeleteCertificateFromStore ( pCertContext ))
        {
            WARNING_OUT(("Failed to delete certificate: %x", GetLastError()));
            break;
        }
    }

    // If NMMKCERT_F_CLEANUP_ONLY is set, we are done
    if ( dwFlags & NMMKCERT_F_CLEANUP_ONLY )
    {
        // We've just deleted the existing certs, now delete the
        // private key container and exit.
        CryptAcquireContextU(
                &hSubjectProv,
                g_wszSubjectKey,
                g_wszSubjectProviderName,
                g_dwProvType,
                CRYPT_DELETEKEYSET |  
                    ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                        CRYPT_MACHINE_KEYSET : 0 ));
        fResult = TRUE;
        goto CommonReturn;
    }

    //
    // Get access to the subject's (public) key, creating it if necessary
    //
    if (!GetPublicKey(hSubjectProv, &pAllocSubjectPubKeyInfo))
        goto ErrorReturn;
    pSubjectPubKeyInfo = pAllocSubjectPubKeyInfo;


    //
    // Encode the subject name
    //
    if (!EncodeSubject(&pbSubjectEncoded, &cbSubjectEncoded))
        goto ErrorReturn;

    //
    // Get access to the issuer's (private) key
    //
    hIssuerProv= GetRootProv(&pwszTmpIssuerContainer);

    if (NULL == (pIssuerCertContext = GetRootCertContext()))
        goto ErrorReturn;

    pIssuerCert = pIssuerCertContext->pCertInfo;

    if (!VerifyIssuerKey(hIssuerProv, &pIssuerCert->SubjectPublicKeyInfo))
        goto ErrorReturn;

    //
    // Update the CERT_INFO
    //
    ClearStruct(&Cert);
    Cert.dwVersion = CERT_V3;

    CoCreateGuid(&SerialNumber);
    Cert.SerialNumber.pbData = (BYTE *) &SerialNumber;
    Cert.SerialNumber.cbData = sizeof(SerialNumber);

    Cert.SignatureAlgorithm = SignatureAlgorithm;
    Cert.Issuer.pbData = pIssuerCert->Subject.pbData;
    Cert.Issuer.cbData = pIssuerCert->Subject.cbData;

    {
        SYSTEMTIME st;

        // Valid starting now...
        GetSystemTimeAsFileTime(&Cert.NotBefore);

        // Ending in 2039 (arbitrarily)
        ClearStruct(&st);
        st.wYear  = 2039;
        st.wMonth = 12;
        st.wDay   = 31;
        st.wHour  = 23;
        st.wMinute= 59;
        st.wSecond= 59;
        SystemTimeToFileTime(&st, &Cert.NotAfter);
    }

    Cert.Subject.pbData = pbSubjectEncoded;
    Cert.Subject.cbData = cbSubjectEncoded;
    Cert.SubjectPublicKeyInfo = *pSubjectPubKeyInfo;

    // Cert Extensions

    if (!CreateEnhancedKeyUsage(
            &pbEKUEncoded,
            &cbEKUEncoded))
        goto ErrorReturn;

    rgExt[cExt].pszObjId = szOID_ENHANCED_KEY_USAGE;
    rgExt[cExt].fCritical = FALSE;
    rgExt[cExt].Value.pbData = pbEKUEncoded;
    rgExt[cExt].Value.cbData = cbEKUEncoded;
    cExt++;

    if (g_wszSubjectDisplayName) {
        if (!CreateSpcCommonName(
                &pbSpcCommonNameEncoded,
                &cbSpcCommonNameEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_COMMON_NAME;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbSpcCommonNameEncoded;
        rgExt[cExt].Value.cbData = cbSpcCommonNameEncoded;
        cExt++;
    }

    Cert.rgExtension = rgExt;
    Cert.cExtension = cExt;

    //
    // Sign and encode the certificate
    //
    cbCertEncoded = 0;
    CryptSignAndEncodeCertificate(
        hIssuerProv,
        g_dwIssuerKeySpec,
        X509_ASN_ENCODING,
        X509_CERT_TO_BE_SIGNED,
        &Cert,
        &Cert.SignatureAlgorithm,
        NULL,                       // pvHashAuxInfo
        NULL,                       // pbEncoded
        &cbCertEncoded
        );
    if (cbCertEncoded == 0) {
        ERROR_OUT(("CryptSignAndEncodeCertificate failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    pbCertEncoded = new BYTE[cbCertEncoded];
    if (pbCertEncoded == NULL) goto ErrorReturn;
    if (!CryptSignAndEncodeCertificate(
            hIssuerProv,
            g_dwIssuerKeySpec,
            X509_ASN_ENCODING,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &Cert.SignatureAlgorithm,
            NULL,                       // pvHashAuxInfo
            pbCertEncoded,
            &cbCertEncoded
            )) {
        ERROR_OUT(("CryptSignAndEncodeCertificate(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    // Output the encoded certificate to an cerificate store

    ASSERT(g_wszSubjectStore);
    ASSERT(AT_KEYEXCHANGE == g_dwSubjectKeySpec);

    if((!SaveCertToStore(hSubjectProv,
            hStore,
            g_dwSubjectStoreFlag,
            pbCertEncoded,
            cbCertEncoded,
            g_wszSubjectKey,
            g_dwSubjectKeySpec,
            g_wszSubjectProviderName,
            g_dwProvType)))
    {
        ERROR_OUT(("SaveCertToStore failed: %x", GetLastError()));
        goto ErrorReturn;

    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:

    PvkFreeCryptProv(hSubjectProv, g_wszSubjectProviderName,
                    g_dwProvType,pwszTmpSubjectContainer);

    //free the cert store
    if(hStore)
         CertCloseStore(hStore, 0);
    if (pIssuerCertContext)
        CertFreeCertificateContext(pIssuerCertContext);
    if (pAllocSubjectPubKeyInfo)
        delete (pAllocSubjectPubKeyInfo);
    if (pbSubjectEncoded)
        delete (pbSubjectEncoded);
    if (pbEKUEncoded)
        delete (pbEKUEncoded);
    if (pbSpcCommonNameEncoded)
        delete (pbSpcCommonNameEncoded);
    if (pbCertEncoded)
        delete [] (pbCertEncoded);
    if (hIssuerProv)
        CryptReleaseContext(hIssuerProv,0);

    return fResult;
}

//+-------------------------------------------------------------------------
//  save the certificate to a certificate store.  Attach private key information
//  to the certificate
//--------------------------------------------------------------------------
BOOL    SaveCertToStore(
                HCRYPTPROV hProv,
                HCERTSTORE hStore,        DWORD dwFlag,
                BYTE *pbEncodedCert,    DWORD cbEncodedCert,
                LPWSTR wszPvk,
                DWORD dwKeySpecification,
                LPWSTR wszCapiProv,        DWORD dwCapiProvType)
{
        BOOL                    fResult=FALSE;
        PCCERT_CONTEXT            pCertContext=NULL;
        CRYPT_KEY_PROV_INFO        KeyProvInfo;

        HCRYPTPROV              hDefaultProvName=NULL;
        DWORD                   cbData=0;
        LPSTR                   pszName=NULL;
        LPWSTR                  pwszName=NULL;
        WCHAR *pwszFriendlyName = NULL;

        //init
        ClearStruct(&KeyProvInfo);

        //add the encoded certificate to store
        if(!CertAddEncodedCertificateToStore(
                    hStore,
                    X509_ASN_ENCODING,
                    pbEncodedCert,
                    cbEncodedCert,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    &pCertContext))
            goto CLEANUP;

        //add properties to the certificate
        KeyProvInfo.pwszContainerName=wszPvk;
        KeyProvInfo.pwszProvName=wszCapiProv,
        KeyProvInfo.dwProvType=dwCapiProvType,
        KeyProvInfo.dwKeySpec=dwKeySpecification;

        if ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE )
        {
            // If this is a local machine cert, set the keyset flags
            // indicating that the private key will be under HKLM
            KeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET;
        }

        ASSERT(AT_KEYEXCHANGE == dwKeySpecification);

        //if wszCapiProv is NULL, we get the default provider name
        if(NULL==wszCapiProv)
        {
            //get the default provider
            if(CryptAcquireContext(&hDefaultProvName,
                                    NULL,
                                    NULL,
                                    KeyProvInfo.dwProvType,
                                    CRYPT_VERIFYCONTEXT))
            {

                //get the provider name
                if(CryptGetProvParam(hDefaultProvName,
                                    PP_NAME,
                                    NULL,
                                    &cbData,
                                    0) && (0!=cbData))
                {

                    if(pszName= new CHAR[cbData])
                    {
                        if(CryptGetProvParam(hDefaultProvName,
                                            PP_NAME,
                                            (BYTE *)pszName,
                                            &cbData,
                                            0))
                        {
                            pwszName= AnsiToUnicode(pszName);

                            KeyProvInfo.pwszProvName=pwszName;
                        }
                    }
                }
            }
        }

        //free the provider as we want
        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        hDefaultProvName=NULL;

        //add property related to the key container
        if(!CertSetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                &KeyProvInfo))
            goto CLEANUP;

        //
        // Load the display name from resource and create a blob to
        // set the cert friendly name.
        //
        CHAR szFriendlyName[128];

        if (!LoadString(hModule, IDS_DEFNAME, szFriendlyName,
                                    sizeof(szFriendlyName)))
        {
            ERROR_OUT(("LoadString failed: %d", GetLastError()));
            goto CLEANUP;
        }

        pwszFriendlyName = AnsiToUnicode ( szFriendlyName );

        if ( NULL == pwszFriendlyName )
        {
            ERROR_OUT(("AnsiToUnicode failed"));
            goto CLEANUP;
        }

        CRYPT_DATA_BLOB FriendlyName;

        FriendlyName.pbData = (PBYTE)pwszFriendlyName;
        FriendlyName.cbData = ( lstrlenW(pwszFriendlyName) + 1 ) *
                                sizeof(WCHAR);

        if(!CertSetCertificateContextProperty(
                pCertContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                0,
                &FriendlyName))
            goto CLEANUP;

        //
        // Add magic ID
        //
        CRYPT_DATA_BLOB MagicBlob;
        DWORD dwMagic;

        dwMagic = NMMKCERT_MAGIC;
        MagicBlob.pbData = (PBYTE)&dwMagic;
        MagicBlob.cbData = sizeof(dwMagic);

        if(!CertSetCertificateContextProperty(
                pCertContext,
                CERT_FIRST_USER_PROP_ID,
                0,
                &MagicBlob))
            goto CLEANUP;

        fResult=TRUE;

CLEANUP:

        if (pwszFriendlyName)
            delete [] pwszFriendlyName;

        //free the cert context
        if(pCertContext)
            CertFreeCertificateContext(pCertContext);

        if(pszName)
            delete [] (pszName);

        if(pwszName)
           delete [] pwszName;

        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        return fResult;

}

//+-------------------------------------------------------------------------
//  Verify the issuer's certificate. The public key in the certificate
//  must match the public key associated with the private key in the
//  issuer's provider
//--------------------------------------------------------------------------
BOOL VerifyIssuerKey(
    IN HCRYPTPROV hProv,
    IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    // Get issuer's public key
    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,                        
        g_dwIssuerKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0)
    {
        ERROR_OUT(("CryptExportPublicKeyInfo failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) new BYTE[cbPubKeyInfo]))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            g_dwIssuerKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        ERROR_OUT(("CrypteExportPublicKeyInfo(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    if (!CertComparePublicKeyInfo(
            X509_ASN_ENCODING,
            pIssuerKeyInfo,
            pPubKeyInfo)) {
        // BUGBUG:: This might be the test root with an incorrectly
        // encoded public key. Convert to the capi representation and
        // compare.
        BYTE rgProvKey[256]; //BUGBUG needs appropriate constant or calc
        BYTE rgCertKey[256]; //BUGBUG needs appropriate constant or calc
        DWORD cbProvKey = sizeof(rgProvKey);
        DWORD cbCertKey = sizeof(rgCertKey);

        if (!CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pIssuerKeyInfo->PublicKey.pbData,
                    pIssuerKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgProvKey,
                    &cbProvKey)                             ||
            !CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pPubKeyInfo->PublicKey.pbData,
                    pPubKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgCertKey,
                    &cbCertKey)                             ||
                cbProvKey == 0 || cbProvKey != cbCertKey    ||
                memcmp(rgProvKey, rgCertKey, cbProvKey) != 0) {
            ERROR_OUT(("mismatch: %x", GetLastError()));
            goto ErrorReturn;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pPubKeyInfo)
        delete [] (pPubKeyInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Get the subject's private key provider
//--------------------------------------------------------------------------
HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV    hProv=0;
    WCHAR        wszKeyName[40] = L"Subject Key";
    int            ids;
    WCHAR       *wszRegKeyName=NULL;
    BOOL        fResult;
    HCRYPTKEY    hKey=NULL;
    GUID        TmpContainerUuid;

    //try to get the hProv from the private key container
    if(S_OK != PvkGetCryptProv(NULL,
                                wszKeyName,
                                g_wszSubjectProviderName,
                                g_dwProvType,
                                NULL,
                                g_wszSubjectKey,
                                &g_dwSubjectKeySpec,
                                ppwszTmpContainer,
                                &hProv))
        hProv=0;

    //generate the private keys
    if (0 == hProv)
    {
        //now that we have to generate private keys, generate
        //AT_KEYEXCHANGE key

        // If there is an existing container with the name of the
        // one we are about to create, attempt to delete it first so
        // that creating it won't fail. This should only happen if the
        // container exists but we were unable to acquire a context to
        // it previously.
        CryptAcquireContextU(
                &hProv,
                g_wszSubjectKey,
                g_wszSubjectProviderName,
                g_dwProvType,
                CRYPT_DELETEKEYSET |  
                    ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                        CRYPT_MACHINE_KEYSET : 0 ));

        // Open a new key container
        if (!CryptAcquireContextU(
                &hProv,
                g_wszSubjectKey,
                g_wszSubjectProviderName,
                g_dwProvType,
                CRYPT_NEWKEYSET |
                    ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                        CRYPT_MACHINE_KEYSET : 0 )))
        {
            ERROR_OUT(("CryptAcquireContext failed: %x", GetLastError()));
            goto CreateKeyError;
        }
        
        //generate new keys in the key container - make sure its EXPORTABLE
        //for SCHANNEL! (Note: remove that when SCHANNEL no longer needs it).
        if (!CryptGenKey( hProv, g_dwSubjectKeySpec, CRYPT_EXPORTABLE, &hKey))
        {
            ERROR_OUT(("CryptGenKey failed: %x", GetLastError()));
            goto CreateKeyError;
        }
        else
            CryptDestroyKey(hKey);

        //try to get the user key
        if (CryptGetUserKey( hProv, g_dwSubjectKeySpec, &hKey))
        {
            CryptDestroyKey(hKey);
        }
        else
        {
            // Doesn't have the specified public key
            CryptReleaseContext(hProv, 0);
            hProv=0;
        }

        if (0 == hProv )
        {
            ERROR_OUT(("sub key error: %x", GetLastError()));
            goto ErrorReturn;
        }
    } //hProv==0

    goto CommonReturn;

CreateKeyError:
ErrorReturn:
    if (hProv)
    {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
CommonReturn:
    if(wszRegKeyName)
        delete (wszRegKeyName);

    return hProv;
}



//+-------------------------------------------------------------------------
//  Allocate and get the public key info for the provider
//--------------------------------------------------------------------------
BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    )
{
    BOOL fResult;

    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        g_dwSubjectKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        ERROR_OUT(("CryptExportPublicKeyInfo failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) new BYTE[cbPubKeyInfo]))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            g_dwSubjectKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        ERROR_OUT(("CryptExportPublicKeyInfo(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (pPubKeyInfo) {
        delete [] (pPubKeyInfo);
        pPubKeyInfo = NULL;
    }
CommonReturn:
    *ppPubKeyInfo = pPubKeyInfo;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert and encode the subject's X500 formatted name
//--------------------------------------------------------------------------
BOOL EncodeSubject(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL            fResult;
    DWORD            cbEncodedSubject=0;
    BYTE            *pbEncodedSubject=NULL;
    BYTE            *pbEncoded = NULL;
    DWORD            cbEncoded;

    //encode the wszSubjectX500Name into an encoded X509_NAME

    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        g_wszSubjectX500Name,
        0,
        NULL,
        NULL,
        &cbEncodedSubject,
        NULL))
    {
        ERROR_OUT(("CertStrToNameW failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    pbEncodedSubject = new BYTE[cbEncodedSubject];
    if (pbEncodedSubject == NULL) goto ErrorReturn;    

    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        g_wszSubjectX500Name,
        0,
        NULL,
        pbEncodedSubject,
        &cbEncodedSubject,
        NULL))
    {
        ERROR_OUT(("CertStrToNameW(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    cbEncoded=cbEncodedSubject;
    pbEncoded=pbEncodedSubject;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        delete (pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


// The test root's public key isn't encoded properly in the certificate.
// It's missing a leading zero to make it a unsigned integer.
static BYTE rgbTestRoot[] = {
    #include "root.h"
};
static CERT_PUBLIC_KEY_INFO TestRootPublicKeyInfo = {
    szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot), rgbTestRoot, 0
};

static BYTE rgbTestRootInfoAsn[] = {
    #include "rootasn.h"
};

//+-------------------------------------------------------------------------
//  X509 Extensions: Allocate and Encode functions
//--------------------------------------------------------------------------

BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL               fResult = TRUE;
    LPBYTE             pbEncoded =NULL;
    DWORD              cbEncoded;
    PCERT_ENHKEY_USAGE pUsage =NULL;

    //
    // Allocate a cert enhanced key usage structure and fill it in
    //

    pUsage = (PCERT_ENHKEY_USAGE) new BYTE[sizeof(CERT_ENHKEY_USAGE) +
                                                2 * sizeof(LPSTR)];
    if ( pUsage != NULL )
    {
        pUsage->cUsageIdentifier = 2;
        pUsage->rgpszUsageIdentifier = (LPSTR *)((LPBYTE)pUsage+sizeof(CERT_ENHKEY_USAGE));

        pUsage->rgpszUsageIdentifier[0] = szOID_PKIX_KP_CLIENT_AUTH;
        pUsage->rgpszUsageIdentifier[1] = szOID_PKIX_KP_SERVER_AUTH;
    }
    else
    {
        fResult = FALSE;
    }

    //
    // Encode the usage
    //

    if ( fResult == TRUE )
    {
        fResult = CryptEncodeObject(
                       X509_ASN_ENCODING,
                       szOID_ENHANCED_KEY_USAGE,
                       pUsage,
                       NULL,
                       &cbEncoded
                       );

        if ( fResult == TRUE )
        {
            pbEncoded = new BYTE[cbEncoded];
            if ( pbEncoded != NULL )
            {
                fResult = CryptEncodeObject(
                               X509_ASN_ENCODING,
                               szOID_ENHANCED_KEY_USAGE,
                               pUsage,
                               pbEncoded,
                               &cbEncoded
                               );
            }
            else
            {
                fResult = FALSE;
            }
        }
    }

    //
    // Cleanup
    //

    delete [] (pUsage);

    if ( fResult == TRUE )
    {
        *ppbEncoded = pbEncoded;
        *pcbEncoded = cbEncoded;
    }
    else
    {
        delete [] (pbEncoded);
    }

    return( fResult );
}

BOOL CreateSpcCommonName(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CERT_NAME_VALUE NameValue;

    NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
    NameValue.Value.pbData =  (BYTE *) g_wszSubjectDisplayName;
    NameValue.Value.cbData =0;

    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME_VALUE,
            &NameValue,
            NULL,           // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        ERROR_OUT(("CryptEncodeObject failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    pbEncoded = new BYTE[cbEncoded];
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME_VALUE,
            &NameValue,
            pbEncoded,
            &cbEncoded
            )) {
        ERROR_OUT(("CryptEncodeObject failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        delete [] (pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmmkcert\nmpvkhlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       nmpvkhlp.h
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __NMPVKHLP_H__
#define __NMPVKHLP_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PRIVATEKEYBLOB
#define PRIVATEKEYBLOB  0x7
#endif


    //+-------------------------------------------------------------------------
    //  Creates a temporary container in the provider and loads the private key
    //  from memory.
    //  For success, returns a handle to a cryptographic provider for the private
    //  key and the name of the temporary container. PrivateKeyReleaseContext must
    //  be called to release the hCryptProv and delete the temporary container.
    //
    //  PrivateKeyLoadFromMemory is called to load the private key into the
    //  temporary container.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyAcquireContextFromMemory(IN LPCWSTR pwszProvName,
                                           IN DWORD dwProvType,
                                           IN BYTE *pbData,
                                           IN DWORD cbData,
                                           IN HWND hwndOwner,
                                           IN LPCWSTR pwszKeyName,
                                           IN OUT OPTIONAL DWORD *pdwKeySpec,
                                           OUT HCRYPTPROV *phCryptProv);

    //+-------------------------------------------------------------------------
    //  Releases the cryptographic provider and deletes the temporary container
    //  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyReleaseContext(IN HCRYPTPROV hCryptProv,
                                 IN LPCWSTR pwszProvName,
                                 IN DWORD dwProvType,
                                 IN LPWSTR pwszTmpContainer);

//+-------------------------------------------------------------------------
//  Acquiring hprovs, Trys the file first and then the KeyContainer. Use
//  PvkFreeCryptProv to release HCRYPTPROV and resources.
//--------------------------------------------------------------------------
    HCRYPTPROV WINAPI 
        PvkGetCryptProvU(IN HWND hwnd,
                         IN LPCWSTR pwszCaption,
                         IN LPCWSTR pwszCapiProvider,
                         IN DWORD   dwProviderType,
                         IN LPCWSTR pwszPrivKey,
                         OUT LPWSTR *ppwszTmpContainer);
    
    void WINAPI
        PvkFreeCryptProvU(IN HCRYPTPROV hProv,
                          IN LPCWSTR  pwszCapiProvider,
                          IN DWORD    dwProviderType,
                          IN LPWSTR   pwszTmpContainer);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(	IN HWND hwnd,
							IN LPCWSTR pwszCaption,
							IN LPCWSTR pwszCapiProvider,
							IN DWORD   dwProviderType,
							IN LPCWSTR pwszPvkFile,
							IN LPCWSTR pwszKeyContainerName,
							IN DWORD   *pdwKeySpec,
							OUT LPWSTR *ppwszTmpContainer,
							OUT HCRYPTPROV *phCryptProv);

#ifdef _M_IX86
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );
#else
#define CryptAcquireContextU    CryptAcquireContextW
#endif

//+-------------------------------------------------------------------------
//  Private Key helper  error codes
//--------------------------------------------------------------------------
#define PVK_HELPER_BAD_PARAMETER        0x80097001
#define PVK_HELPER_BAD_PVK_FILE         0x80097002
#define PVK_HELPER_WRONG_KEY_TYPE       0x80097003
#define PVK_HELPER_PASSWORD_CANCEL      0x80097004

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmmkcert\root.h ===
0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmmkcert\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecert.rc
//
#define IDR_PVKROOT                 101
#define IDR_ROOTCERTIFICATE         102
#define IDS_DEFNAME                 103

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmmkcert\rootasn.h ===
0x30,0x5B,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x01,0x05,
0x00,0x03,0x4A,0x00,0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,
0xD6,0xE7,0xD9,0x66,0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,
0xB1,0xF7,0x87,0x30,0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,
0x5F,0x42,0xB6,0x9D,0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,
0x58,0x11,0xCB,0x40,0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\confirm.h ===
#ifndef __Confirm_h__
#define __Confirm_h__

#include "FilePane.h"

class CConfirmationSheet {

friend class CNmAkWiz;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );
    static CConfirmationSheet* ms_pConfirmationSheet;


private: // DATA
    CPropertySheetPage m_PropertySheetPage;
	ULONG			   m_uIndex;
	CFilePanePropWnd2 *		   m_pFilePane;

private: 
    CConfirmationSheet( void );
    ~CConfirmationSheet( void );

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}

    void _FillListBox( void );
	void _CreateFilePane(HWND hDlg);

public:
	CFilePanePropWnd2 * GetFilePane() { return m_pFilePane; }
	HWND GetListHwnd() { return GetDlgItem( m_pFilePane->GetHwnd(), IDC_LIST_SETTINGS ); }

};


#endif // __Confirm_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmmkcert\pvkutil.cpp ===
#include "global.h"


//+-------------------------------------------------------------------------
//  Private Key file definitions
//
//  The file consists of the FILE_HDR followed by cbEncryptData optional
//  bytes used to encrypt the private key and then the private key.
//  The private key is encrypted according to dwEncryptType.
//
//  The public key is included with the private key.
//--------------------------------------------------------------------------

typedef struct _FILE_HDR {
    DWORD               dwMagic;
    DWORD               dwVersion;
    DWORD               dwKeySpec;
    DWORD               dwEncryptType;
    DWORD               cbEncryptData;
    DWORD               cbPvk;
} FILE_HDR, *PFILE_HDR;

// BUGBUG: enum from pvk.h?
#ifndef ENTER_PASSWORD
#define ENTER_PASSWORD    0
#endif // ENTER_PASSWORD

#define PVK_FILE_VERSION_0          0
#define PVK_MAGIC                   0xb0b5f11e

// Private key encrypt types
#define PVK_NO_ENCRYPT                  0

#define MAX_PVK_FILE_LEN            4096

typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);

extern DWORD     g_dwSubjectStoreFlag;

//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pb;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

static BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
        // copy the bytes
        memcpy(p, &pMemInfo->pb[pMemInfo->cbSeek], cb);
        pMemInfo->cbSeek += cb;
        return TRUE;
    } else {
        SetLastError(ERROR_END_OF_MEDIA);
        return FALSE;
    }
}

//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

#define UUID_WSTR_BYTES ((sizeof(GUID) * 2 + 1) * sizeof(WCHAR))

//-------------------------------------------------------------------------
//
//    Call GetLastError and convert the return code to HRESULT
//--------------------------------------------------------------------------
HRESULT WINAPI SignError ()
{
    DWORD   dw = GetLastError ();
    HRESULT hr;
    if ( dw <= (DWORD) 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;
    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

static BOOL LoadKeyW(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hKey = 0;
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    // Read the file header and verify
    if (!pfnRead(hRead, &Hdr, sizeof(Hdr)))
    {
        ERROR_OUT(("can't read in-memory pvk file hdr"));
        goto BadPvkFile;
    }
    
    ASSERT( Hdr.dwMagic == PVK_MAGIC );

    // Treat as a "normal" private key file
    cbPvk = Hdr.cbPvk;
    if (Hdr.dwVersion != PVK_FILE_VERSION_0 ||
        Hdr.cbEncryptData > MAX_PVK_FILE_LEN ||
        cbPvk == 0 || cbPvk > MAX_PVK_FILE_LEN)
    goto BadPvkFile;

    if (pdwKeySpec) {
        DWORD dwKeySpec = *pdwKeySpec;
        *pdwKeySpec = Hdr.dwKeySpec;
        if (dwKeySpec && dwKeySpec != Hdr.dwKeySpec) {
            SetLastError(PVK_HELPER_WRONG_KEY_TYPE);
            goto ErrorReturn;
        }
    }

    // Allocate and read the private key
    if (NULL == (pbPvk = new BYTE[cbPvk]))
        goto ErrorReturn;
    if (!pfnRead(hRead, pbPvk, cbPvk))
        goto BadPvkFile;

    ASSERT(Hdr.dwEncryptType == PVK_NO_ENCRYPT);

    // Decrypt and import the private key
    if (!CryptImportKey(hCryptProv, pbPvk, cbPvk, 0, dwFlags,
            &hKey))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

BadPvkFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
    if (pdwKeySpec)
        *pdwKeySpec = 0;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbPvk)
        delete [] (pbPvk);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}

static BOOL AcquireKeyContextW(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    GUID TmpContainerUuid;
    LPWSTR pwszTmpContainer = NULL;

    // Create a temporary keyset to load the private key into
    // UuidCreate(&TmpContainerUuid);
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto ErrorReturn;
    }

    if (NULL == (pwszTmpContainer = (LPWSTR) new BYTE[
            6 * sizeof(WCHAR) + UUID_WSTR_BYTES]))
        goto ErrorReturn;
    LStrCpyW(pwszTmpContainer, L"TmpKey");
    BytesToWStr(sizeof(UUID), &TmpContainerUuid, pwszTmpContainer + 6);

    if (!CryptAcquireContextU(
            &hProv,
            pwszTmpContainer,
            pwszProvName,
            dwProvType,
            CRYPT_NEWKEYSET |
                ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                    CRYPT_MACHINE_KEYSET : 0 )))
        goto ErrorReturn;

    if (!LoadKeyW(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pwszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContextU(
        &hProv,
        pwszTmpContainer,
        pwszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    fResult = FALSE;

CommonReturn:
    if (pwszTmpContainer) {
        delete [] (pwszTmpContainer);
    }
    *phCryptProv = hProv;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from memory.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoadFromMemory is called to load the private key into the
//  temporary container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyAcquireContextFromMemory(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv
    )
{

    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    BOOL fhr = AcquireKeyContextW(
        pwszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv
        );
    return fhr;
}

//+-------------------------------------------------------------------------
//  Releases the cryptographic provider and deletes the temporary container
//  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyReleaseContext(
    IN HCRYPTPROV hCryptProv,
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN LPWSTR pwszTmpContainer
    )
{

    HRESULT hr = S_OK;

    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContextU(
                &hCryptProv,
                pwszTmpContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        delete (pwszTmpContainer);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get crypto provider to based on either the pvkfile or key container name
//--------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(    IN HWND hwnd,
                            IN LPCWSTR pwszCaption,
                            IN LPCWSTR pwszCapiProvider,
                            IN DWORD   dwProviderType,
                            IN LPCWSTR pwszPvkFile,
                            IN LPCWSTR pwszKeyContainerName,
                            IN DWORD   *pdwKeySpec,
                            OUT LPWSTR *ppwszTmpContainer,
                            OUT HCRYPTPROV *phCryptProv)
{
    HANDLE    hFile=NULL;
    HRESULT    hr=E_FAIL;
    DWORD    dwRequiredKeySpec=0;

    //Init
    *ppwszTmpContainer=NULL;
    *phCryptProv=NULL;

    //get the provider handle based on the key container name
    if(!CryptAcquireContextU(phCryptProv,
                pwszKeyContainerName,
                pwszCapiProvider,
                dwProviderType,
                ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                    CRYPT_MACHINE_KEYSET : 0 )))
        return SignError();

    dwRequiredKeySpec=*pdwKeySpec;

    //make sure *pdwKeySpec is the correct key spec
    HCRYPTKEY hPubKey;
    if (CryptGetUserKey(
        *phCryptProv,
        dwRequiredKeySpec,
        &hPubKey
        )) 
    {
        CryptDestroyKey(hPubKey);
        *pdwKeySpec=dwRequiredKeySpec;
        return S_OK;
    } 
    else 
    {
        // Doesn't have the specified public key
        hr=SignError();
        CryptReleaseContext(*phCryptProv, 0);
        *phCryptProv=NULL;
        return hr;
    }        
}



void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer)
{
    
    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        PvkPrivateKeyReleaseContext(hProv,
                                    pwszCapiProvider,
                                    dwProviderType,
                                    pwszTmpContainer);
    } else {
        if (hProv)
            CryptReleaseContext(hProv, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\controlid.h ===
#ifndef _ControlID_h_
#define _ControlID_h_

#include <list>
using namespace std;

#define MAX_DIGITS 16

class CControlID
{
	public:
		typedef enum eTypes
		{
			EDIT,
			CHECK,
			SLIDER,
			COMBO,
			EDIT_NUM,
			STATIC
		} IDTYPE;

	private:
		UINT m_ID;
		HWND m_hwndCond;
		UINT m_condID;
		UINT m_staticID;
		IDTYPE m_type;

	public:
		CControlID( HWND hwndCond, UINT condID, UINT ID, IDTYPE type )
			: m_ID( ID ), m_condID( condID ), m_hwndCond( hwndCond ), m_staticID( 0 ), m_type( type )
		{
		}

		CControlID( UINT ID, IDTYPE type )
			: m_ID( ID ), m_condID( 0 ), m_hwndCond( NULL ), m_staticID( 0 ), m_type( type )
		{
		}

		CControlID( IDTYPE type )
			: m_ID( 0 ), m_condID( 0 ), m_hwndCond( NULL ), m_staticID( 0 ), m_type( type )
		{
		}

		inline HWND GetCondHwnd() const
		{
			return m_hwndCond;
		}

		inline UINT GetCondID() const
		{
			return m_condID;
		}

		inline UINT GetID() const
		{
			return m_ID;
		}

		inline IDTYPE GetType() const
		{
			return m_type;
		}

		inline UINT GetStaticID() const
		{
			return m_staticID;
		}

		inline void SetStaticID( UINT ID )
		{
			m_staticID = ID;
		}

		void Reset( HWND hDlg )
		{
			switch( m_type )
			{
				case STATIC:
					break;

				case EDIT:
				case EDIT_NUM:
				{
					SetDlgItemText( hDlg, m_ID, TEXT("") );
					break;
				}
				case CHECK:
				{
					Button_SetCheck( GetDlgItem( hDlg, m_ID ), FALSE );
					break;
				}
				case SLIDER:
				{
					HWND hwndSlide = GetDlgItem( hDlg, m_ID );
					LONG lVal = TrackBar_GetRangeMin( hwndSlide );
					TrackBar_SetPos( hwndSlide, true, lVal );
					TCHAR szBuff[ MAX_DIGITS ];
					wsprintf( szBuff, "%d", lVal );
					SetDlgItemText( hDlg, m_staticID, szBuff );
					break;
				}
				case COMBO:
				{
					ComboBox_SetCurSel( GetDlgItem( hDlg, m_ID ), 0 );
					break;
				}
				default:
					assert( 0 );
					break;
			}
		}
		
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\confirm.cpp ===
#include "precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
#include "SetSht.h"
#include "dslist.h"
#include "Confirm.h"
#include "nmakreg.h"
#include "nmakwiz.h"



////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CConfirmationSheet* CConfirmationSheet::ms_pConfirmationSheet = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

INT_PTR CALLBACK CConfirmationSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {

    switch( message )
    {
		case WM_INITDIALOG:
        {
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
			ms_pConfirmationSheet->_CreateFilePane(hDlg);
			return TRUE;
            break;
        }

		case WM_NOTIFY:
        {
			switch( reinterpret_cast< NMHDR FAR* >( lParam )->code )
            {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    ms_pConfirmationSheet->_FillListBox( );
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
					ms_pConfirmationSheet->m_pFilePane->Validate(FALSE);
			        return TRUE;

				case PSN_WIZBACK:
					if( !ms_pConfirmationSheet->m_pFilePane->Validate( TRUE ) )
					{
						SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
						return TRUE;
					}
					break;

				case PSN_WIZNEXT:
					if( !ms_pConfirmationSheet->m_pFilePane->Validate( TRUE ) )
					{
						SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
						return TRUE;
					}
					break;
			}
            break;
        }

		default:
			break;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CConfirmationSheet::CConfirmationSheet() :
    m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						 CConfirmationSheet::DlgProc /*,
						PSP_HASHELP   */ 
                       ),
	m_uIndex( 0 ),
	m_pFilePane( NULL )
{
    ms_pConfirmationSheet = this;
}


CConfirmationSheet::~CConfirmationSheet( void ) 
{
	delete m_pFilePane;
    m_pFilePane = NULL;
    ms_pConfirmationSheet = NULL;
}

void CConfirmationSheet::_FillListBox(void)
{

	HWND hwndList = GetDlgItem( m_pFilePane->GetHwnd(), IDC_LIST_SETTINGS );

	ListBox_ResetContent( hwndList );

    int iLine = 0;

	iLine = g_pWiz->m_SettingsSheet.SpewToListBox( hwndList, iLine );
    iLine = g_pWiz->m_CallModeSheet.SpewToListBox( hwndList, iLine );

	// Note - 500 is just a large and arbitrary value
	ListBox_SetHorizontalExtent( hwndList, 500 );
}



void CConfirmationSheet::_CreateFilePane(HWND hDlg)
{
	RECT rect;

	GetClientRect(hDlg, &rect );
	int iHeight = rect.bottom - rect.top;
	int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;
	
	m_pFilePane = new CFilePanePropWnd2(hDlg,
										IDD_FILEPANE_SUMMARY,
										TEXT("IDD_FILEPANE_SUMMARY"),
										0,
										CPropertyDataWindow2::mcs_iLeft,
										CPropertyDataWindow2::mcs_iTop,
										iWidth,
										iHeight );
	assert( m_pFilePane );
	HWND hwndCond = GetDlgItem( m_pFilePane->GetHwnd(), IDC_CREATE_CONFIGURATION_SUMMARY_FILE );
	m_pFilePane->ConnectControlsToCheck( IDC_CREATE_CONFIGURATION_SUMMARY_FILE, 2,
										new CControlID( hwndCond,
														IDC_CREATE_CONFIGURATION_SUMMARY_FILE,
														IDC_CONFIGURATION_SUMMARY_PATH,
														CControlID::EDIT ),
										new CControlID( hwndCond,
														IDC_CREATE_CONFIGURATION_SUMMARY_FILE,
														IDC_BROWSE_CONFIGURATION_SUMMARY,
														// Note this is not a check but I don't think I care
														CControlID::CHECK ) );

	m_pFilePane->SetFilePane( FALSE, IDC_CONFIGURATION_SUMMARY_PATH,
							IDC_CREATE_CONFIGURATION_SUMMARY_FILE,
							IDC_BROWSE_CONFIGURATION_SUMMARY,
							TEXT( "Text File (*.txt)" ),
							TEXT( ".txt" ),
							TEXT( "Summary.txt" ));

	m_pFilePane->ShowWindow( TRUE );
    m_pFilePane->SetCheck(IDC_CREATE_CONFIGURATION_SUMMARY_FILE, TRUE);

	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
	{
		m_pFilePane->ReadSettings();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\dspropwnd2.cpp ===
#include "precomp.h"
#include "resource.h"
#include "PropWnd2.h"
#include "DsPropWnd2.h"
#include "NmAkWiz.h"
#include "EditServer.h"
#include "WndProcs.h"
//#include "poldata.h"
#include "nmakreg.h"

#include <algorithm>

const int CDsPropWnd2::MAXSERVERS = 15;
const TCHAR c_szMSServer[] = TEXT("logon.netmeeting.microsoft.com");

CWebViewInfo* GetWebViewInfo()
{
	static CWebViewInfo g_wvi;
	return(&g_wvi);
}

BOOL IsMSServer(LPCTSTR szServer) { return(0 == lstrcmp(szServer, c_szMSServer)); }

// Read the WebView information, but only once
void ReadWebViewSettings(CPropertyDataWindow2 *pData)
{
	static BOOL g_bRead = FALSE;

	if (g_bRead)
	{
		return;
	}

	CWebViewInfo *pWebView = GetWebViewInfo();

	pData->ReadStringValue(KEYNAME_WEBVIEWNAME  , pWebView->m_szWebViewName  , CCHMAX(pWebView->m_szWebViewName  ));
	pData->ReadStringValue(KEYNAME_WEBVIEWURL   , pWebView->m_szWebViewURL   , CCHMAX(pWebView->m_szWebViewURL   ));
	pData->ReadStringValue(KEYNAME_WEBVIEWSERVER, pWebView->m_szWebViewServer, CCHMAX(pWebView->m_szWebViewServer));

	g_bRead = TRUE;
}

void WriteWebViewSettings(CPropertyDataWindow2 *pData)
{
	CWebViewInfo *pWebView = GetWebViewInfo();

	// If the WebView is the default, write blanks to the file
	LPCTSTR szWVName   = pWebView->m_szWebViewName  ;
	LPCTSTR szWVURL    = pWebView->m_szWebViewURL   ;
	LPCTSTR szWVServer = pWebView->m_szWebViewServer;
	if (IsMSServer(szWVServer))
	{
		szWVName = szWVURL = szWVServer = TEXT("");
	}

	pData->WriteStringValue(KEYNAME_WEBVIEWNAME  , szWVName  );
	pData->WriteStringValue(KEYNAME_WEBVIEWURL   , szWVURL   );
	pData->WriteStringValue(KEYNAME_WEBVIEWSERVER, szWVServer);
}

void WriteWebViewToINF(HANDLE hFile, BOOL bWebViewAllowed)
{
	CWebViewInfo *pWebView = GetWebViewInfo();

	// If the WebView is the default, write blanks to the file
	if (!bWebViewAllowed || IsMSServer(pWebView->m_szWebViewServer))
	{
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_NAME,
					 CPolicyData::OpDelete()
                   ).SaveToINFFile( hFile );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_URL,
					 CPolicyData::OpDelete()
                   ).SaveToINFFile( hFile );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_SERVER,
					 CPolicyData::OpDelete()
                   ).SaveToINFFile( hFile );
	}
	else
	{
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_NAME,
					 pWebView->m_szWebViewName
                   ).SaveToINFFile( hFile );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_URL,
					 pWebView->m_szWebViewURL
                   ).SaveToINFFile( hFile );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_SERVER,
					 pWebView->m_szWebViewServer
                   ).SaveToINFFile( hFile );
	}
}

void CWebViewInfo::SetWebView(LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL)
{
	lstrcpy(m_szWebViewServer, szServer);
	if (NULL != szName)
	{
		lstrcpy(m_szWebViewName, szName);
	}
	if (NULL != szURL)
	{
		lstrcpy(m_szWebViewURL, szURL);
	}
}

CDsPropWnd2::CDsPropWnd2( HWND hwndParent, int iX, int iY, int iWidth, int iHeight )
	: CPropertyDataWindow2( hwndParent, IDD_CHILDPAGE_ILSGATEWAY, TEXT("IDD_CHILDPAGE_ILSGATEWAY"), (WNDPROC) DsPropWndProc, 0, iX, iY, iWidth, iHeight, FALSE )
{
	SetWindowLong( m_hwnd, GWL_USERDATA, (long)this );
	Edit_LimitText( GetDlgItem( m_hwnd, IDC_EDIT_NEW_SERVER ), MAX_PATH );
    Edit_LimitText( GetDlgItem( m_hwnd, IDC_EDIT_GATEWAY ), MAX_PATH );

	m_hwndList = GetDlgItem( m_hwnd, IDC_LIST_SERVERS );

    ConnectControlsToCheck( IDC_CHECK_GATEWAY, 1,
        new CControlID(GetDlgItem(m_hwnd, IDC_CHECK_GATEWAY),
            IDC_CHECK_GATEWAY,
            IDC_EDIT_GATEWAY,
            CControlID::EDIT ) );

    PrepSettings(FALSE);
	SetButtons();
}

CDsPropWnd2::~CDsPropWnd2()
{
	deque< LPTSTR >::iterator it;
	for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it )
	{
		delete [] *it;
	}
}


void CDsPropWnd2::QueryWizNext(void)
{
	bool bWarned = false;

    if (DirectoryEnabled())
	{
		CWebViewInfo *pWebView = GetWebViewInfo();
		if (('\0' == pWebView->m_szWebViewServer[0] ||
			IsMSServer(pWebView->m_szWebViewServer))
			&& IsWebViewAllowed())
		{
			// Just using default Web View information; see if the default
			// server is there
			for (int i=m_serverDQ.size()-1; ; --i)
			{
				if (i < 0)
				{
					// Got through the list without finding the default server
					NmrkMessageBox(MAKEINTRESOURCE(IDS_WEBDIR_AUTOADD), NULL, MB_OK | MB_ICONINFORMATION);
					bWarned = true;
					break;
				}

				if (IsMSServer(m_serverDQ.at(i)))
				{
					// Found the default server; no need to proceed
					break;
				}
			}
		}

		// Note that the MID may be automatically added even if users are not
		// allowed to add servers
		if (!bWarned && 0 == CountServers())
		{
			if (AllowUserToAdd())
			{
				NmrkMessageBox(MAKEINTRESOURCE(IDS_DSLIST_EMPTY), NULL, MB_OK | MB_ICONINFORMATION);
			}
			else
			{
				NmrkMessageBox(MAKEINTRESOURCE(IDS_DS_WILL_BE_EMPTY), NULL, MB_OK | MB_ICONINFORMATION);
			}
		}
	}
}

LRESULT CALLBACK CDsPropWnd2::DsPropWndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uiMsg )
	{
		case WM_VSCROLL:
		case WM_VKEYTOITEM:
		case WM_COMMAND:
		{
			CDsPropWnd2 * pPropWnd = (CDsPropWnd2 *)GetWindowLong( hwnd, GWL_USERDATA );
			return pPropWnd->_WndProc( hwnd, uiMsg, wParam, lParam );
			break;
		}
		default:
		{
			return DefWindowProc( hwnd, uiMsg, wParam, lParam );
			break;
		}
	}
}


BOOL CDsPropWnd2::DoCommand(WPARAM wParam, LPARAM lParam)
{
    return(_WndProc(m_hwnd, WM_COMMAND, wParam, lParam));
}


LRESULT CALLBACK CDsPropWnd2::_WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	
	switch( uiMsg ) 
	{
		case WM_VSCROLL: 
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
			break;
		} 
		case WM_VKEYTOITEM:
		{
			if( m_serverDQ.size() )
			{
				switch( LOWORD( wParam ) )
				{    
					case VK_DELETE:                     
					{
						_DeleteCurSel();
						return 0;
						break;
					}
				}
			}
			break;
		}
		case WM_COMMAND:
		{
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_LIST_SERVERS:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
        				case LBN_SELCHANGE:
		        		{
				        	SetButtons();
        					return 0;
		        			break;
				        }

        				case LBN_DBLCLK:
		        		{
				        	_EditCurSel();
        					return 0;
		        			break;
				        }
                    }
                    break;
                }

                case IDC_BUTTON_SET_AS_DEFAULT:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
    				{
                        case BN_CLICKED:
                        {
							_SetAsDefault( ListBox_GetCurSel( m_hwndList ) );
							return 0;
							break;
						}
                    }
                    break;
                }

                case IDC_BUTTON_EDIT:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
					{
                        case BN_CLICKED:
                        {
							_EditCurSel();
							return 0;
							break;
						}
                    }
                    break;
                }

                case IDC_BUTTON_SET_WEBVIEW:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
					{
                        case BN_CLICKED:
                        {
							_EditCurSelWebView();
							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_BUTTON_REMOVE:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							_DeleteCurSel();
							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_BUTTON_UP:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							_MoveCurSel( -1 );
							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_BUTTON_DOWN:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							_MoveCurSel( 1 );
							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_BUTTON_ADDDIRECTORYSERVER:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							HWND hwndEdit = GetDlgItem( m_hwnd, IDC_EDIT_NEW_SERVER );
							if( Edit_GetTextLength( hwndEdit ) )
							{
								LPTSTR szServer = new TCHAR[ MAX_PATH ];
								Edit_GetText( hwndEdit, szServer, MAX_PATH );
								_AddServer( szServer );
								Edit_SetText( hwndEdit, TEXT("") );
							}
							else
							{
								NmrkMessageBox( MAKEINTRESOURCE(IDS_DSNAME_INVALID), NULL,
											MB_OK | MB_ICONEXCLAMATION );
							}

							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							SetButtons();
							return 0;
							break;
						}
					}
					break;
				}

				case IDC_DISABLE_WEBDIR:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							_UpdateServerList();
							SetButtons();
							return 0;
							break;
						}
					}
					break;
				}
			}
			break;
		}	
	}
	
	return DefWindowProc( hwnd, uiMsg, wParam, lParam );
}

void CDsPropWnd2::SetButtons()
{
	BOOL bEnable = DirectoryEnabled();
	HWND hwndFocus = GetFocus();
	BOOL bFocusEnabled = IsWindowEnabled(hwndFocus);

	if( m_serverDQ.size() )
	{
		int iCurSel = ListBox_GetCurSel( m_hwndList );
		
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_UP ),
			bEnable && 1 < iCurSel && m_defaultServer != iCurSel );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_DOWN ),
			bEnable && (m_serverDQ.size() - 1) != iCurSel && m_defaultServer != iCurSel );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SET_AS_DEFAULT ),
			bEnable && iCurSel != m_defaultServer );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SET_WEBVIEW ),
			bEnable
			&& IsWebViewAllowed()
			&& !(IsWebView(iCurSel) && IsMSServer(GetWebViewInfo()->m_szWebViewServer)) );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_EDIT ),
			bEnable );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_REMOVE ),
			bEnable );
	}
	else
	{
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SET_AS_DEFAULT ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SET_WEBVIEW ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_EDIT ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_REMOVE ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_UP ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_DOWN ),
			FALSE );
	}

	::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_ADDDIRECTORYSERVER ),
		bEnable && m_serverDQ.size() != MAXSERVERS );
	::EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_NEW_SERVER ),
		bEnable && m_serverDQ.size() != MAXSERVERS );
	::EnableWindow( GetDlgItem( m_hwnd, IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS ),
		bEnable );
    ::EnableWindow( GetDlgItem( m_hwnd, IDC_DISABLE_WEBDIR), bEnable);
	::EnableWindow( m_hwndList, bEnable );

	if (bFocusEnabled && !IsWindowEnabled(hwndFocus))
	{
		// We seem to have disabled the focus window. Let's try to set the
		// focus to an enabled window
		if (IsWindowEnabled(m_hwndList))
		{
			FORWARD_WM_NEXTDLGCTL(m_hwndParent, m_hwndList, TRUE, SendMessage);
		}
		else
		{
			FORWARD_WM_NEXTDLGCTL(m_hwndParent, FALSE, FALSE, SendMessage);
		}
	}
}

void CDsPropWnd2::_AddServer( LPTSTR szServer )
{
	int iSize = m_serverDQ.size();
	if( iSize > 0 && iSize < MAXSERVERS )
	{
		int iCurSel = ListBox_GetCurSel( m_hwndList );
		if( iCurSel == m_defaultServer )
		{
			++iCurSel;
		}

		deque< LPTSTR >::iterator it = m_serverDQ.begin();
		for( int i = 0; i < iCurSel; ++i )
		{
			++it;
		}

		m_serverDQ.insert( it, szServer );
		ListBox_InsertString( m_hwndList, iCurSel, szServer );

		ListBox_SetCurSel( m_hwndList, iCurSel );
	}
	else
	{
		m_serverDQ.push_front( szServer );
		ListBox_InsertString( m_hwndList, 0, szServer );
		_SetAsDefault( 0 );
	}
	SetButtons();
}

	

void CDsPropWnd2::_MoveCurSel( int iPlaces )
{
	int iCurSel = ListBox_GetCurSel( m_hwndList );
	int iNewPos = iCurSel + iPlaces;

	if( iNewPos == m_defaultServer )
	{
		_SetAsDefault( iCurSel );
	}
	else if( iCurSel == m_defaultServer )
	{
		_SetAsDefault( iNewPos );
	}
	else
	{
		LPTSTR szCur = m_serverDQ.at( iCurSel );
		LPTSTR szNew = m_serverDQ.at( iNewPos );

		m_serverDQ.at( iCurSel ) = szNew;
		m_serverDQ.at( iNewPos ) = szCur;

		if( iPlaces > 0 )
		{
			ListBox_DeleteString( m_hwndList, iCurSel );
			ListBox_InsertString( m_hwndList, iCurSel, m_serverDQ.at( iCurSel ) );

			ListBox_DeleteString( m_hwndList, iNewPos );
			ListBox_InsertString( m_hwndList, iNewPos, m_serverDQ.at( iNewPos ) );
		}
		else
		{
			ListBox_DeleteString( m_hwndList, iNewPos );
			ListBox_InsertString( m_hwndList, iNewPos, m_serverDQ.at( iNewPos ) );

			ListBox_DeleteString( m_hwndList, iCurSel );
			ListBox_InsertString( m_hwndList, iCurSel, m_serverDQ.at( iCurSel ) );
		}
	}
	ListBox_SetCurSel( m_hwndList, iNewPos );

	_UpdateServerList();

	SetButtons();
}

void CDsPropWnd2::PrepSettings( BOOL fGkMode )
{
	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
	{
		ReadSettings();
	}
	else
	{
		deque <LPTSTR>::iterator it;
		for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it )
		{
			delete [] *it;
		}

		m_serverDQ.erase( m_serverDQ.begin(), m_serverDQ.end() );


		LPTSTR szServerName = NULL;

		szServerName = new TCHAR[ MAX_PATH ];
		lstrcpy( szServerName, c_szMSServer );
		m_serverDQ.push_back( szServerName );

		m_defaultServer = 0;

		Button_SetCheck( GetDlgItem( m_hwnd, IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES ), TRUE );
		Button_SetCheck( GetDlgItem( m_hwnd, IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS ), FALSE );
        Button_SetCheck( GetDlgItem( m_hwnd, IDC_DISABLE_WEBDIR), FALSE);

        Button_SetCheck( GetDlgItem( m_hwnd, IDC_CHECK_GATEWAY), FALSE);
	}

	ListBox_ResetContent( m_hwndList );

	// Add Items to listbox
	deque< LPTSTR >::const_iterator it;
	int i = 0;
	for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it, ++i )
	{
		ListBox_InsertString( m_hwndList, i, *it );
	}

	if( m_serverDQ.size() )
	{
		// This will do an _UpdateServerList for us
		_SetAsDefault( m_defaultServer );
	}
}

void CDsPropWnd2::_UpdateServerList()
{
	int iSel = ListBox_GetCurSel(m_hwndList);

	// We only want to find one WebView
	BOOL bFoundWebView = FALSE;

	for (int index=ListBox_GetCount(m_hwndList)-1; index>=0; --index)
	{
		TCHAR szNewText[MAX_PATH];
		lstrcpy(szNewText, m_serverDQ.at(index));

		BOOL bWebView = FALSE;
		if (!bFoundWebView)
		{
			bWebView = IsWebView(szNewText);
		}

		if (IsDefault(index))
		{
			lstrcat(szNewText, TEXT(" (Default)"));
		}
		if (bWebView)
		{
			bFoundWebView = TRUE;

			if (IsWebViewAllowed())
			{
				lstrcat(szNewText, TEXT(" (WebView)"));
			}
		}

		TCHAR szOldText[MAX_PATH];
		ListBox_GetText(m_hwndList, index, szOldText);
		if (lstrcmp(szOldText, szNewText) != 0)
		{
			ListBox_DeleteString(m_hwndList, index);
			ListBox_InsertString(m_hwndList, index, szNewText);
			if (iSel == index)
			{
				ListBox_SetCurSel(m_hwndList, iSel);
			}
		}
	}

	if (!bFoundWebView && !IsMSServer(GetWebViewInfo()->m_szWebViewServer))
	{
		SetWebView(c_szMSServer);
		_UpdateServerList();
	}
}

void CDsPropWnd2::_EditCurSel()
{
	int iCurSel = ListBox_GetCurSel( m_hwndList );
	LPTSTR szOldServer = m_serverDQ.at( iCurSel );
	CEditServer* pEditServer = new CEditServer( m_hwnd, szOldServer, MAX_PATH );
	
	if( pEditServer->ShowDialog() == IDOK )
	{
		LPTSTR szServer = new TCHAR[ MAX_PATH ];
		lstrcpy( szServer, pEditServer->GetServer() );
		m_serverDQ.at( iCurSel ) = szServer;

		if (IsWebView(szOldServer))
		{
			SetWebView(szServer);
		}

		_UpdateServerList();

		delete [] szOldServer;
	}

	ListBox_SetCurSel( m_hwndList, iCurSel );
}

void CDsPropWnd2::SetWebView(LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL)
{
	GetWebViewInfo()->SetWebView(szServer, szName, szURL);
	_UpdateServerList();
}

void CDsPropWnd2::_EditCurSelWebView()
{
	int iCurSel = ListBox_GetCurSel( m_hwndList );
	LPTSTR szServer = m_serverDQ.at( iCurSel );

	if (IsMSServer(szServer))
	{
		if (IDYES == NmrkMessageBox(MAKEINTRESOURCE(IDS_DEFAULT_WEBVIEW),
			MAKEINTRESOURCE(IDS_EDIT_WEBVIEW), MB_ICONEXCLAMATION | MB_YESNO))
		{
			SetWebView(szServer, TEXT(""), TEXT(""));
			SetButtons();
		}
		return;
	}

	CWebViewInfo *pWebView = GetWebViewInfo();

	LPCTSTR szWVName = TEXT("");
	LPCTSTR szWVURL = TEXT("");
	if (IsWebView(szServer))
	{
		szWVName = pWebView->m_szWebViewName;
		szWVURL = pWebView->m_szWebViewURL;
	}

	CEditWebView* pEditWebView = new CEditWebView(
		m_hwnd, szServer, szWVName, szWVURL, MAX_PATH );
	pEditWebView->SetEditServer(FALSE);
	
	if( pEditWebView->ShowDialog() == IDOK )
	{
		SetWebView(szServer, pEditWebView->GetName(), pEditWebView->GetURL());
		SetButtons();
	}

	delete pEditWebView;
}

BOOL CDsPropWnd2::_SetAsDefault( int iIndex )
{
	if( iIndex < 0 || iIndex > m_serverDQ.size() )
	{
		return FALSE;
	}

	// Move default server to top of deque
	LPTSTR szNewZero = m_serverDQ.at( iIndex );

	m_serverDQ.erase( m_serverDQ.begin() + iIndex );
	ListBox_DeleteString( m_hwndList, iIndex );

	ListBox_InsertString( m_hwndList, 0, szNewZero );
	m_serverDQ.push_front( szNewZero );
	m_defaultServer = 0;

	ListBox_SetCurSel( m_hwndList, 0 );

	_UpdateServerList();

	SetButtons();

	return TRUE;
}

BOOL CDsPropWnd2::_DeleteCurSel()
{
	int iCurSel = ListBox_GetCurSel( m_hwndList );

	LPTSTR szKill = m_serverDQ.at( iCurSel );

	TCHAR szBuffer[ MAX_PATH ];
	LoadString( IDS_ARE_YOU_SURE_YOU_WISH_TO_REMOVE, szBuffer, CCHMAX( szBuffer ) );

	TCHAR lpszMessage[ MAX_PATH ];
	wsprintf( lpszMessage, szBuffer, szKill );

	if( IDNO == NmrkMessageBox(lpszMessage, MAKEINTRESOURCE(IDS_VERIFY), MB_YESNO | MB_ICONQUESTION ) )
	{
		return FALSE;
	}

	m_serverDQ.erase( m_serverDQ.begin() + iCurSel );

	delete [] szKill;
	ListBox_DeleteString( m_hwndList, iCurSel );


	if( m_defaultServer == iCurSel )
	{
		if( m_serverDQ.size() > iCurSel )
		{
			_SetAsDefault( iCurSel );
		}
		else
		{
			_SetAsDefault( iCurSel - 1 );
		}
	}
	else
	{
		if( m_serverDQ.size() > iCurSel )
		{
			ListBox_SetCurSel( m_hwndList, iCurSel );
		}
		else if( iCurSel > 0 )
		{
			ListBox_SetCurSel( m_hwndList, iCurSel - 1);
		}
	}

	// Make sure all the WebView information is up-to-date
	_UpdateServerList();

	// Bug fix - I do not get a LBN_SELCHANGE message all the time when I want one
	// even though the string selected changes.  So just for that I gotta do this
	SetButtons();

	return TRUE;
}

void CDsPropWnd2::ReadSettings( void )
{
	TCHAR szValue[ MAX_PATH ];
	TCHAR szServerName[ MAX_PATH ];

	for( int i = 0; i < MAXSERVERS; i++ )
	{
		wsprintf( szValue, KEYNAME_ILSSERVER, i );
        ReadStringValue(szValue, szServerName, CCHMAX(szServerName));
        if (!szServerName[0])
            break;

		LPTSTR szServer = new TCHAR[ lstrlen( szServerName ) + 1 ];
		lstrcpy( szServer, szServerName );
		m_serverDQ.push_back( szServer );
	}

	ReadWebViewSettings(this);

    ReadNumberValue(KEYNAME_ILSDEFAULT, &m_defaultServer);

	_ReadCheckSetting( IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES );
	_ReadCheckSetting( IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS );
    _ReadCheckSetting( IDC_DISABLE_WEBDIR);

    _ReadCheckSetting( IDC_CHECK_GATEWAY );
    _ReadEditSetting ( IDC_EDIT_GATEWAY );
}


void CDsPropWnd2::WriteSettings( BOOL fGkMode )
{
	TCHAR szValue[ MAX_PATH ];
	deque< LPTSTR >::const_iterator it;
	
	int i = 0;
	for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it )
	{
		wsprintf( szValue, KEYNAME_ILSSERVER, i );
        WriteStringValue(szValue, (LPTSTR)*it);
		i++;
	}

	while( i < MAXSERVERS )
	{
		wsprintf( szValue, KEYNAME_ILSSERVER, i );
        WriteStringValue(szValue, TEXT(""));
		i++;
	}

	WriteWebViewSettings(this);

    WriteNumberValue(KEYNAME_ILSDEFAULT, m_defaultServer);

	_WriteCheckSetting( IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES );
	_WriteCheckSetting( IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS );
    _WriteCheckSetting( IDC_DISABLE_WEBDIR );

    _WriteCheckSetting( IDC_CHECK_GATEWAY );
    _WriteEditSetting( IDC_EDIT_GATEWAY );
}


BOOL CDsPropWnd2::WriteToINF(BOOL fGkMode, HANDLE hFile )
{
	TCHAR szValue[ MAX_PATH ];
	deque< LPTSTR >::const_iterator it;
	
	int i = 0;
	for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it, ++i )
	{
		wsprintf( szValue, TEXT("Name%d"), i );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     DIR_MRU_KEY, 
                     szValue, 
                     *it
                   ).SaveToINFFile( hFile );
	}

	CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     DIR_MRU_KEY, 
                     TEXT("Count"), 
                     (DWORD)m_serverDQ.size() 
                   ).SaveToINFFile( hFile );

	while( i < MAXSERVERS )
	{
		wsprintf( szValue, TEXT("Name%d"), i );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     DIR_MRU_KEY, 
                     szValue, 
					 CPolicyData::OpDelete()
                   ).SaveToINFFile( hFile );
		i++;
	}

	if( m_serverDQ.size() )
	{
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
             ISAPI_CLIENT_KEY, 
             REGVAL_SERVERNAME, 
             m_serverDQ.at( m_defaultServer )
           ).SaveToINFFile( hFile );
	}

    //
    // Directory stuff
    //
	BOOL bCheckValues = !fGkMode && DirectoryEnabled();
	
	if (!fGkMode)
	{
		WriteWebViewToINF(hFile, IsWebViewAllowed());
	    _WriteCheckToINF( hFile, IDC_DISABLE_WEBDIR, bCheckValues);
	}

	CPolicyData( ms_ClassMap[ IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES ], 
             ms_KeyMap[ IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES ], 
             ms_ValueMap[ IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES ], 
             !bCheckValues
           ).SaveToINFFile( hFile );

	CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
				 POLICIES_KEY,
				 REGVAL_POL_NO_DIRECTORY_SERVICES,
				 !bCheckValues
			   ).SaveToINFFile( hFile );

	_WriteCheckToINF( hFile, IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS, bCheckValues );

    //
    // Gateway stuff
    //
    bCheckValues = !fGkMode & GatewayEnabled();

    _WriteCheckToINF( hFile, IDC_CHECK_GATEWAY, bCheckValues);
    _WriteEditToINF(hFile, IDC_EDIT_GATEWAY, bCheckValues);

	return TRUE;
}

int CDsPropWnd2::SpewToListBox( HWND hwndList, int iStartLine )
{
	if( DirectoryEnabled() )
	{	
		if( m_serverDQ.size() )
		{
			ListBox_InsertString( hwndList, iStartLine, TEXT("Adding Directory Servers:") );
			iStartLine++;

			deque< LPTSTR >::const_iterator it;
			for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it )
			{
				LPTSTR sz = new TCHAR[ lstrlen( *it ) + 2 ];
				sz[ 0 ] = '\t'; sz[1] = '\0';
				lstrcat( sz, *it );

				ListBox_InsertString( hwndList, iStartLine, sz );
				iStartLine++;

				delete [] sz;
			}

			ListBox_InsertString( hwndList, iStartLine, TEXT("Default Server:") );
			iStartLine++;

			{
				LPTSTR sz = new TCHAR[ lstrlen( m_serverDQ.at( m_defaultServer ) ) + 2 ];
				sz[ 0 ] = '\t'; sz[1] = '\0';
				lstrcat( sz, m_serverDQ.at( m_defaultServer ) );

				ListBox_InsertString( hwndList, iStartLine, sz );
				iStartLine++;

				delete [] sz;
			}
		}

		if( !AllowUserToAdd() )
		{
			ListBox_InsertString( hwndList, iStartLine, TEXT("Prevent users from adding new servers to the list you provide") );
			iStartLine++;
		}

        if (!IsWebViewAllowed())
        {
            ListBox_InsertString( hwndList, iStartLine, TEXT("Prevent users from viewing web directory"));
            iStartLine++;
        }
	}
	else
	{
		ListBox_InsertString( hwndList, iStartLine, TEXT("Disable Directory Services") );
		iStartLine++;
	}

    if (GatewayEnabled())
    {
        TCHAR   szGateway[MAX_PATH];

        ListBox_InsertString( hwndList, iStartLine, TEXT("Adding Gateway server:") );
        iStartLine++;

        szGateway[0] = '\t';
        GetDlgItemText(m_hwnd, IDC_EDIT_GATEWAY, szGateway+1,
                CCHMAX(szGateway)-1);
        ListBox_InsertString( hwndList, iStartLine, szGateway);
        iStartLine++;
    }

	return iStartLine;
}


//
// GATEKEEPER STUFF
//


CGkPropWnd2::CGkPropWnd2( HWND hwndParent, int iX, int iY, int iWidth, int iHeight )
	: CPropertyDataWindow2( hwndParent, IDD_CHILDPAGE_GATEKEEPER, TEXT("IDD_CHILDPAGE_GATEKEEPER"), (WNDPROC) GkPropWndProc, 0, iX, iY, iWidth, iHeight, FALSE )
{
	SetWindowLong( m_hwnd, GWL_USERDATA, (long)this );

    HWND    hwndChild;

	// Calling method radio buttons
    hwndChild = GetDlgItem(m_hwnd, IDC_RADIO_GKMODE_ACCOUNT);
    SetWindowLong( hwndChild, GWL_USERDATA, GK_LOGON_USING_ACCOUNT );

    hwndChild = GetDlgItem(m_hwnd, IDC_RADIO_GKMODE_PHONE);
    SetWindowLong(hwndChild, GWL_USERDATA, GK_LOGON_USING_PHONENUM);

    hwndChild = GetDlgItem(m_hwnd, IDC_RADIO_GKMODE_BOTH);
    SetWindowLong(hwndChild, GWL_USERDATA, GK_LOGON_USING_BOTH);

	Edit_LimitText( GetDlgItem( m_hwnd, IDC_EDIT_GATEKEEPER ), MAX_PATH );
    ConnectControlsToCheck( IDC_CHECK_GATEKEEPER, 1,
        new CControlID(GetDlgItem(m_hwnd, IDC_CHECK_GATEKEEPER),
        IDC_CHECK_GATEKEEPER,
        IDC_EDIT_GATEKEEPER,
        CControlID::EDIT ) );

    PrepSettings(FALSE);

	SetButtons();
}

CGkPropWnd2::~CGkPropWnd2()
{
}

void CGkPropWnd2::_EditCurSelWebView()
{
	CWebViewInfo *pWebView = GetWebViewInfo();

	CEditWebView* pEditWebView = new CEditWebView(
		m_hwnd, pWebView->m_szWebViewServer, pWebView->m_szWebViewName, pWebView->m_szWebViewURL, MAX_PATH );
	
	if( pEditWebView->ShowDialog() == IDOK )
	{
		SetWebView(pEditWebView->GetServer(), pEditWebView->GetName(), pEditWebView->GetURL());
		SetButtons();
	}

	delete pEditWebView;
}

LRESULT CALLBACK CGkPropWnd2::GkPropWndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uiMsg )
	{
		case WM_VSCROLL:
		case WM_VKEYTOITEM:
		case WM_COMMAND:
		{
			CGkPropWnd2 * pPropWnd = (CGkPropWnd2 *)GetWindowLong( hwnd, GWL_USERDATA );
			return pPropWnd->_WndProc( hwnd, uiMsg, wParam, lParam );
			break;
		}
		default:
		{
			return DefWindowProc( hwnd, uiMsg, wParam, lParam );
			break;
		}
	}
}


BOOL CGkPropWnd2::DoCommand(WPARAM wParam, LPARAM lParam)
{
    return(_WndProc(m_hwnd, WM_COMMAND, wParam, lParam));
}


LRESULT CALLBACK CGkPropWnd2::_WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	
	switch( uiMsg ) 
	{
		case WM_VSCROLL: 
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
			break;
		}

		case WM_COMMAND:
			if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
			{
				switch (GET_WM_COMMAND_ID(wParam, lParam))
				{
				case IDC_BUTTON_SET_WEBVIEW:
					_EditCurSelWebView();
					break;

				case IDC_DISABLE_WEBDIR_GK:
					SetButtons();
					break;
				}
			}
			break;
	}
	
	return DefWindowProc( hwnd, uiMsg, wParam, lParam );
}

void CGkPropWnd2::SetButtons()
{
	::EnableWindow(GetDlgItem(m_hwnd, IDC_BUTTON_SET_WEBVIEW),
		!IsDlgButtonChecked(m_hwnd, IDC_DISABLE_WEBDIR_GK));
}




void CGkPropWnd2::PrepSettings( BOOL fGkMode )
{
	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
	{
		ReadSettings();
	}
	else
	{
        TCHAR   szText[1];

        szText[0] = 0;
        SetDlgItemText(m_hwnd, IDC_EDIT_GATEKEEPER, szText);

        Button_SetCheck(GetDlgItem(m_hwnd, IDC_CHECK_GATEKEEPER), FALSE);
        Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIO_GKMODE_BOTH), BST_CHECKED);
	}
}



void CGkPropWnd2::ReadSettings( void )
{
    int iRadio;

    _ReadEditSetting ( IDC_EDIT_GATEKEEPER );
    Button_SetCheck(GetDlgItem(m_hwnd, IDC_CHECK_GATEKEEPER),
        (GetWindowTextLength(GetDlgItem(m_hwnd, IDC_EDIT_GATEKEEPER)) != 0));

    for (iRadio = IDC_RADIO_GKMODE_FIRST; iRadio < IDC_RADIO_GKMODE_MAX; iRadio++)
    {
        _ReadCheckSetting(iRadio);
    }

	ReadWebViewSettings(this);

    _ReadCheckSetting( IDC_DISABLE_WEBDIR_GK);
}


void CGkPropWnd2::WriteSettings( BOOL fGkMode )
{
    int iRadio;

    _WriteEditSetting( IDC_EDIT_GATEKEEPER );

    for (iRadio = IDC_RADIO_GKMODE_FIRST; iRadio < IDC_RADIO_GKMODE_MAX; iRadio++)
    {
        _WriteCheckSetting(iRadio);
    }

	WriteWebViewSettings(this);

    _WriteCheckSetting( IDC_DISABLE_WEBDIR_GK );
}


BOOL CGkPropWnd2::WriteToINF( BOOL fGkMode, HANDLE hFile )
{
    int iRadio;

    _WriteEditToINF( hFile, IDC_EDIT_GATEKEEPER,
        fGkMode && IsDlgButtonChecked(m_hwnd, IDC_CHECK_GATEKEEPER));

    for (iRadio = IDC_RADIO_GKMODE_FIRST; iRadio < IDC_RADIO_GKMODE_MAX; iRadio++)
    {
        _WriteCheckToINF(hFile, iRadio, fGkMode);
    }

	if (fGkMode)
	{
		WriteWebViewToINF(hFile, IsWebViewAllowed());
	    _WriteCheckToINF( hFile, IDC_DISABLE_WEBDIR_GK, fGkMode );
	}

	return TRUE;
}

int CGkPropWnd2::SpewToListBox( HWND hwndList, int iStartLine )
{
    TCHAR   szTemp[MAX_PATH];
    int     iRadio;

    if (IsDlgButtonChecked(m_hwnd, IDC_CHECK_GATEKEEPER))
    {
        ListBox_InsertString(hwndList, iStartLine, TEXT("Adding Gatekeeper server:") );
        iStartLine++;

        szTemp[0] = '\t';
        GetDlgItemText(m_hwnd, IDC_EDIT_GATEKEEPER, szTemp+1,
            CCHMAX(szTemp)-1);
        ListBox_InsertString(hwndList, iStartLine, szTemp);
        iStartLine++;
    }

    ListBox_InsertString(hwndList, iStartLine, TEXT("Gatekeeper addressing mode:") );
    iStartLine++;

    for (iRadio = IDC_RADIO_GKMODE_FIRST; iRadio < IDC_RADIO_GKMODE_MAX; iRadio++)
    {
        if (IsDlgButtonChecked(m_hwnd, iRadio))
        {
            szTemp[0] = '\t';
            GetDlgItemText(m_hwnd, iRadio, szTemp+1, CCHMAX(szTemp)-1);
            ListBox_InsertString(hwndList, iStartLine, szTemp);
            iStartLine++;

            break;
        }
    }

    return(iStartLine);
}


void CGkPropWnd2::QueryWizNext(void)
{

}

void CGkPropWnd2::SetWebView(LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL)
{
	GetWebViewInfo()->SetWebView(szServer, szName, szURL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\dspropwnd2.h ===
#ifndef _DsPropWnd2_h_
#define _DsPropWnd2_h_

#include "PropWnd2.h"
#include <deque>
using namespace std;

class CWebViewInfo
{
public:
	CWebViewInfo()
	{
		m_szWebViewName  [0] = '\0';
		m_szWebViewURL   [0] = '\0';
		m_szWebViewServer[0] = '\0';
	}

	TCHAR m_szWebViewName[MAX_PATH];
	TCHAR m_szWebViewURL[MAX_PATH];
	TCHAR m_szWebViewServer[MAX_PATH];

	void SetWebView(LPCTSTR szServer, LPCTSTR szName=NULL, LPCTSTR szURL=NULL);
} ;

CWebViewInfo* GetWebViewInfo();

class CDsPropWnd2 : public CPropertyDataWindow2
{
	friend class CCallModeSheet;

private:
	static const int MAXSERVERS;

private:
	deque< LPTSTR >		m_serverDQ;
//	list< LPTSTR >		m_oldServerList;
	int					m_defaultServer;
	HWND				m_hwndList;

public:
	CDsPropWnd2( HWND hwndParent, int iX, int iY, int iWidth, int iHeight );
	~CDsPropWnd2();

	void ReadSettings( void );
	void WriteSettings( BOOL fGkMode );
	void SetButtons();
	BOOL WriteToINF( BOOL fGkMode, HANDLE hFile );
	int SpewToListBox( HWND hwndList, int iStartLine );
	void PrepSettings(BOOL fGkMode);
    BOOL DoCommand(WPARAM wParam, LPARAM lParam);
    void QueryWizNext(void);

	inline BOOL DirectoryEnabled()
	{
		HWND hwndBut = GetDlgItem( m_hwnd, IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES );
		return hwndBut && Button_GetCheck( hwndBut );
	}

    inline BOOL GatewayEnabled()
    {
        HWND hwndBut = GetDlgItem( m_hwnd, IDC_CHECK_GATEWAY);
        return hwndBut && Button_GetCheck( hwndBut );
    }

	inline BOOL AllowUserToAdd()
	{
		HWND hwndBut = GetDlgItem( m_hwnd, IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS );
		return hwndBut && !Button_GetCheck( hwndBut );
	}

	inline int CountServers()
	{
		return m_serverDQ.size();
	}

private:

	BOOL IsWebView(LPCTSTR szServer) { return(0 == lstrcmp(szServer, GetWebViewInfo()->m_szWebViewServer)); }
	BOOL IsWebView(int index) { return(IsWebView(m_serverDQ.at(index))); }
	void SetWebView(LPCTSTR szServer, LPCTSTR szName=NULL, LPCTSTR szURL=NULL);

	BOOL IsWebViewAllowed() { return(!IsDlgButtonChecked(m_hwnd, IDC_DISABLE_WEBDIR)); }

	BOOL IsDefault(int index) { return(index == m_defaultServer); }

	void _UpdateServerList();
	BOOL _SetAsDefault( int iIndex );
	void _EditCurSel( void );
	void _EditCurSelWebView();
	BOOL _DeleteCurSel( void );
	void _MoveCurSel( int iPlaces );
	void _AddServer( LPTSTR szServer );

	LRESULT CALLBACK _WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );
	
private:
	static LRESULT CALLBACK DsPropWndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );
};




class CGkPropWnd2 : public CPropertyDataWindow2
{
	friend class CCallModeSheet;

public:
	CGkPropWnd2( HWND hwndParent, int iX, int iY, int iWidth, int iHeight );
	~CGkPropWnd2();

	void ReadSettings( void );
	void WriteSettings( BOOL fGkMode );
	void SetButtons();
	BOOL WriteToINF( BOOL fGkMode, HANDLE hFile );
	int  SpewToListBox( HWND hwndList, int iStartLine );
	void PrepSettings(BOOL fGkMode);
    BOOL DoCommand(WPARAM wParam, LPARAM lParam);
    void QueryWizNext();

private:
	void SetWebView(LPCTSTR szServer, LPCTSTR szName=NULL, LPCTSTR szURL=NULL);

	BOOL IsWebViewAllowed() { return(!IsDlgButtonChecked(m_hwnd, IDC_DISABLE_WEBDIR_GK)); }

	void _EditCurSelWebView();

	LRESULT CALLBACK _WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );

private:
	static LRESULT CALLBACK GkPropWndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\dslist.h ===
#pragma warning( disable : 4786 )
#include <list>
#include <string>

#ifndef __DSList_h__
#define __DSList_h__

#include "DsPropWnd2.h"

class CCallModeSheet
{

friend class CNmAkWiz;
friend class CConfirmationSheet;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
    static CCallModeSheet* ms_pCallModeSheet;

public:
    int     SpewToListBox(HWND hwndList, int iStartLine);
    void    PrepSettings();
    void    WriteSettings();
    BOOL    WriteToINF(HANDLE hFile);

private: // DATA
    CPropertySheetPage  m_PropertySheetPage;
	CDsPropWnd2 *	    m_pDsPropWnd;
    CGkPropWnd2 *       m_pGkPropWnd;
    BOOL                m_fGkActive;    

private: 
    CCallModeSheet( void );
    ~CCallModeSheet( void );
    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}

private: // Helper Fns
	
    void _InitDialog(HWND hDlg);
	void _CreatePropWnd(HWND hDlg);

};





#endif // __DSList_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\dslist.cpp ===
#include "precomp.h"
#include "resource.h"
#include <algorithm>
#include "global.h"
#include "PropPg.h"
#include "DSList.h"
#include "NmAkWiz.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CCallModeSheet* CCallModeSheet::ms_pCallModeSheet = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

INT_PTR CALLBACK CCallModeSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {
    
    TCHAR sz[ MAX_PATH ];

    switch( message )
    {
		case WM_INITDIALOG:
			ms_pCallModeSheet->_InitDialog(hDlg);
			ms_pCallModeSheet->_CreatePropWnd(hDlg);
			return TRUE;
            
        case WM_COMMAND:
        {
            if (ms_pCallModeSheet)
            {
                if (ms_pCallModeSheet->m_fGkActive)
                {
                    if (ms_pCallModeSheet->m_pGkPropWnd)
                        return(ms_pCallModeSheet->m_pGkPropWnd->DoCommand(wParam, lParam));
                }
                else
                {
                    if (ms_pCallModeSheet->m_pDsPropWnd)
                        return(ms_pCallModeSheet->m_pDsPropWnd->DoCommand(wParam, lParam));
                }
            }
            break;
        }
 
		case WM_NOTIFY:
			switch( reinterpret_cast< NMHDR FAR* >( lParam )->code ) {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    ms_pCallModeSheet->m_fGkActive = g_pWiz->m_SettingsSheet.IsGateKeeperModeSelected();

                    if (ms_pCallModeSheet->m_fGkActive)
                    {
                        if (ms_pCallModeSheet->m_pDsPropWnd)
                            ms_pCallModeSheet->m_pDsPropWnd->ShowWindow( FALSE );

                        if (ms_pCallModeSheet->m_pGkPropWnd)
                            ms_pCallModeSheet->m_pGkPropWnd->ShowWindow( TRUE );
                    }
                    else
                    {
                        if (ms_pCallModeSheet->m_pGkPropWnd)
                            ms_pCallModeSheet->m_pGkPropWnd->ShowWindow( FALSE );

                        if (ms_pCallModeSheet->m_pDsPropWnd)
                        	ms_pCallModeSheet->m_pDsPropWnd->ShowWindow( TRUE );
                    }
                	PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
			        return TRUE;

				case PSN_WIZNEXT:
					if (ms_pCallModeSheet->m_fGkActive)
                    {
                        if (ms_pCallModeSheet->m_pGkPropWnd)
                            ms_pCallModeSheet->m_pGkPropWnd->QueryWizNext();
                    }
                    else
                    {
                        if (ms_pCallModeSheet->m_pDsPropWnd)
                            ms_pCallModeSheet->m_pDsPropWnd->QueryWizNext();
                    }
					return TRUE;
			}

		default:
			break;

	}

	return FALSE;

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CCallModeSheet::CCallModeSheet( void )
	: m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						CCallModeSheet::DlgProc /*, 
						PSP_HASHELP   */
                       ),
	m_pDsPropWnd( NULL ),
    m_pGkPropWnd( NULL ),
    m_fGkActive( FALSE )
{
    assert(ms_pCallModeSheet == NULL);
    ms_pCallModeSheet = this; 
}


void CCallModeSheet::_CreatePropWnd(HWND hDlg)
{
	RECT rect;

	GetClientRect(hDlg, &rect );
	int iHeight = rect.bottom;
	int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;

	m_pDsPropWnd = new CDsPropWnd2(hDlg, CPropertyDataWindow2::mcs_iLeft,
			CPropertyDataWindow2::mcs_iTop, iWidth, iHeight );

    m_pGkPropWnd = new CGkPropWnd2(hDlg, CPropertyDataWindow2::mcs_iLeft,
            CPropertyDataWindow2::mcs_iTop, iWidth, iHeight );
}

CCallModeSheet::~CCallModeSheet( void ) 
{
    delete m_pDsPropWnd;
    m_pDsPropWnd = NULL;

    delete m_pGkPropWnd;
    m_pGkPropWnd = NULL;

    ms_pCallModeSheet = NULL;
}


void CCallModeSheet::_InitDialog(HWND hDlg)
{
     // Set the buttons
	PropSheet_SetWizButtons( GetParent(hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
}


int CCallModeSheet::SpewToListBox(HWND hwndList, int iStartLine )
{
    if (m_fGkActive)
    {
        if (m_pGkPropWnd)
            iStartLine = m_pGkPropWnd->SpewToListBox(hwndList, iStartLine);
    }
    else
    {
        if (m_pDsPropWnd)
            iStartLine = m_pDsPropWnd->SpewToListBox(hwndList, iStartLine);
    }

    return(iStartLine);
}



void CCallModeSheet::PrepSettings(void)
{
    if (m_pDsPropWnd)
        m_pDsPropWnd->PrepSettings(m_fGkActive);

    if (m_pGkPropWnd)
        m_pGkPropWnd->PrepSettings(m_fGkActive);
}


void CCallModeSheet::WriteSettings(void)
{
    if (m_pDsPropWnd)
        m_pDsPropWnd->WriteSettings(m_fGkActive);

    if (m_pGkPropWnd)
        m_pGkPropWnd->WriteSettings(m_fGkActive);
}


BOOL CCallModeSheet::WriteToINF(HANDLE hFile)
{
    if (m_pDsPropWnd)
        m_pDsPropWnd->WriteToINF(m_fGkActive, hFile);

    if (m_pGkPropWnd)
        m_pGkPropWnd->WriteToINF(m_fGkActive, hFile);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\editserver.h ===
#ifndef _EditServer_h_
#define _EditServer_h_

class CEditServer
{
	private:
		static CEditServer *ms_pThis;

	private:
		HWND m_hwnd;
		LPTSTR m_szServerBuffer;
		HWND m_hwndParent;
		size_t m_cbLen;

	public:
		CEditServer( HWND hwndParent, LPTSTR szServer, size_t cbLen );
		~CEditServer();
		int ShowDialog();

		inline LPTSTR GetServer() { return m_szServerBuffer; }

	private:
		static BOOL CALLBACK _Proc(  HWND hwndDlg,  // handle to dialog box
							  UINT uMsg,     // message  
							  WPARAM wParam, // first message parameter
							  LPARAM lParam  // second message parameter
							  );


};

class CEditWebView
{
	private:
		static CEditWebView *ms_pThis;

	private:
		LPTSTR m_szServerBuffer;
		LPTSTR m_szNameBuffer;
		LPTSTR m_szURLBuffer;
		HWND m_hwndParent;
		size_t m_cbLen;

		BOOL m_bEditServer : 2;

	public:
		CEditWebView( HWND hwndParent, LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL, size_t cbLen );
		~CEditWebView();
		int ShowDialog();

		LPCTSTR GetServer() { return m_szServerBuffer; }
		LPCTSTR GetName()   { return m_szNameBuffer; }
		LPCTSTR GetURL()    { return m_szURLBuffer; }

		void SetEditServer(BOOL bEditServer) { m_bEditServer = (bEditServer != FALSE); }
		BOOL GetEditServer() { return(m_bEditServer); }

	private:
		static BOOL CALLBACK _Proc(  HWND hwndDlg,  // handle to dialog box
							  UINT uMsg,     // message  
							  WPARAM wParam, // first message parameter
							  LPARAM lParam  // second message parameter
							  );


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\editserver.cpp ===
#include "precomp.h"
#include "resource.h"
#include "EditServer.h"
#include "nmakwiz.h"

CEditServer* CEditServer::ms_pThis = NULL;

CEditServer::CEditServer( HWND hwndParent, LPTSTR szServer, size_t cbLen )
	: m_hwnd( NULL ), m_hwndParent( hwndParent ), m_cbLen( cbLen )
{
	ms_pThis = this;
	m_szServerBuffer = new TCHAR[ m_cbLen ];
	lstrcpy( m_szServerBuffer, szServer );
}


CEditServer::~CEditServer()
{
	ms_pThis = NULL;
	delete [] m_szServerBuffer;
}

int CEditServer::ShowDialog()
{
	return DialogBox(  g_hInstance,  // handle to application instance
						  MAKEINTRESOURCE( IDD_DIALOG_EDIT_SERVERNAME ),  // identifies dialog box template
						  m_hwndParent,      // handle to owner window
						  _Proc, // pointer to dialog box procedure
						  );
}

INT_PTR CALLBACK CEditServer::_Proc(  HWND hwndDlg,  // handle to dialog box
					  UINT uMsg,     // message  
					  WPARAM wParam, // first message parameter
					  LPARAM lParam  // second message parameter
					  )
{
	switch( uMsg )
	{
		case WM_INITDIALOG:
		{
			HWND hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_SERVER_NAME );
			Edit_SetText( hwndEdit, ms_pThis->m_szServerBuffer );
			Edit_LimitText( hwndEdit, ms_pThis->m_cbLen - 1 );
			return TRUE;
			break;
		}
		case WM_COMMAND:
		{
            switch (GET_WM_COMMAND_ID(wParam, lParam))
			{
                case IDOK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							HWND hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_SERVER_NAME );
							if( Edit_GetTextLength( hwndEdit ) )
							{
								if( !Edit_GetText( hwndEdit, ms_pThis->m_szServerBuffer, ms_pThis->m_cbLen ) )
								{
									ErrorMessage( TEXT("Edit_GetText"), GetLastError() );
								}
								EndDialog( hwndDlg, IDOK );
							}
							else
							{
								NmrkMessageBox(
                                    MAKEINTRESOURCE(IDS_REMOVE_SERVER),
                                    MAKEINTRESOURCE(IDS_EMPTY_SERVER),
									MB_ICONEXCLAMATION | MB_OK,
									hwndDlg);
							}
							return TRUE;
                            break;
                        }
                    }
                    break;
                }

                case IDCANCEL:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							EndDialog( hwndDlg, IDCANCEL );
							return TRUE;
                            break;
                        }
                    }
                    break;
                }
            }

            break;
        }
	}

	return 0;
}


CEditWebView* CEditWebView::ms_pThis = NULL;

CEditWebView::CEditWebView( HWND hwndParent, LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL, size_t cbLen )
	: m_hwndParent( hwndParent ), m_cbLen( cbLen ), m_bEditServer(TRUE)
{
	ms_pThis = this;

	m_szServerBuffer = new TCHAR[ m_cbLen ];
	lstrcpy( m_szServerBuffer, szServer );
	m_szNameBuffer = new TCHAR[ m_cbLen ];
	lstrcpy( m_szNameBuffer, szName );
	m_szURLBuffer = new TCHAR[ m_cbLen ];
	lstrcpy( m_szURLBuffer, szURL );
}


CEditWebView::~CEditWebView()
{
	ms_pThis = NULL;
	delete [] m_szServerBuffer;
	delete [] m_szNameBuffer;
	delete [] m_szURLBuffer;
}

int CEditWebView::ShowDialog()
{
	return DialogBox(  g_hInstance,  // handle to application instance
						  MAKEINTRESOURCE( IDD_DIALOG_EDIT_WEBVIEW ),  // identifies dialog box template
						  m_hwndParent,      // handle to owner window
						  _Proc, // pointer to dialog box procedure
						  );
}

INT_PTR CALLBACK CEditWebView::_Proc(  HWND hwndDlg,  // handle to dialog box
					  UINT uMsg,     // message  
					  WPARAM wParam, // first message parameter
					  LPARAM lParam  // second message parameter
					  )
{
	switch( uMsg )
	{
		case WM_INITDIALOG:
		{
			HWND hwndEdit;

			hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_SERVER_NAME );
			Edit_SetText( hwndEdit, ms_pThis->m_szServerBuffer );
			Edit_LimitText( hwndEdit, ms_pThis->m_cbLen - 1 );

			FORWARD_WM_NEXTDLGCTL(hwndDlg, hwndEdit, TRUE, SendMessage);
			if (!ms_pThis->GetEditServer())
			{
				Edit_SetReadOnly(hwndEdit, TRUE);
				FORWARD_WM_NEXTDLGCTL(hwndDlg, FALSE, FALSE, SendMessage);
			}

			hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_URL_NAME );
			Edit_SetText( hwndEdit, ms_pThis->m_szURLBuffer );
			Edit_LimitText( hwndEdit, ms_pThis->m_cbLen - 1 );

			hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_DISPLAY_NAME );
			Edit_SetText( hwndEdit, ms_pThis->m_szNameBuffer );
			Edit_LimitText( hwndEdit, ms_pThis->m_cbLen - 1 );

			// I already set the focus
			return FALSE;
			break;
		}
		case WM_COMMAND:
		{
            switch (GET_WM_COMMAND_ID(wParam, lParam))
			{
                case IDOK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							if( GetDlgItemText( hwndDlg, IDC_EDIT_SERVER_NAME, ms_pThis->m_szServerBuffer, ms_pThis->m_cbLen )
								&& GetDlgItemText( hwndDlg, IDC_EDIT_URL_NAME, ms_pThis->m_szURLBuffer, ms_pThis->m_cbLen )
								&& GetDlgItemText( hwndDlg, IDC_EDIT_DISPLAY_NAME, ms_pThis->m_szNameBuffer, ms_pThis->m_cbLen ))
							{
								EndDialog( hwndDlg, IDOK );
							}
							else
							{
								NmrkMessageBox(
                                    MAKEINTRESOURCE(IDS_ERROR_NEEDALLFIELDS),
                                    MAKEINTRESOURCE(IDS_EDIT_WEBVIEW),
									MB_ICONEXCLAMATION | MB_OK,
									hwndDlg);
							}
							return TRUE;
                            break;
                        }
                    }
                    break;
                }

                case IDCANCEL:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							EndDialog( hwndDlg, IDCANCEL );
							return TRUE;
                            break;
                        }
                    }
                    break;
                }
            }

            break;
        }
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\filepane.h ===
#ifndef _FilePane_h_
#define _FilePane_h_

#include "propwnd2.h"

//UINT CALLBACK _ButtonProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
//UINT CALLBACK _CheckProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

class CFilePanePropWnd2 : public CPropertyDataWindow2
{
//	friend UINT CALLBACK _ButtonProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
//	friend UINT CALLBACK _CheckProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

private:
	static UINT CALLBACK OFNHookProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
	static LRESULT CALLBACK WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );
	UINT CALLBACK _OFNHookProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
private:
	HWND m_hwndEdit;
	HWND m_hwndCheck;
	HWND m_hwndBrowse;

	UINT m_editID;
	UINT m_checkID;
	UINT m_browseID;

	TCHAR m_szOFNData[MAX_PATH];

	LPTSTR m_lptstrFilter;
	LPTSTR m_lptstrDefExtension;

	LPTSTR m_lptstrDefFileName;

	OPENFILENAME m_ofn;

    BOOL   m_fOpenDialog;

public:
	CFilePanePropWnd2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll = FALSE );
	void SetFilePane( BOOL fOpenDialog, UINT editID, UINT checkID, UINT browseID, LPTSTR lptstDesc, LPTSTR lptstrDefExtension, LPTSTR lptstrDefFileName);

	~CFilePanePropWnd2();

public:
	void CreateOutputDir( void );
	void QueryFilePath( void );
	LPTSTR GetPathAndFile( LPTSTR lpstrPath );
	LPTSTR GetPath( LPTSTR lpstrPath );
	LPTSTR GetFile( LPTSTR lpstrFile );
    void SetFileName(LPTSTR lpstrFullFileName);
	BOOL OptionEnabled();
	void Enable( BOOL bEnable );
	BOOL Validate( BOOL bMsg );
	HANDLE CreateFile( DWORD dwDesiredAccess,
							 DWORD dwShareMode,
							 LPSECURITY_ATTRIBUTES lpSecurityAttributes,
							 DWORD dwCreationDisposition,
							 DWORD dwFlagsAndAttributes );


private:
	void _Enable( BOOL bEnable );
	void _InitOFN( void );
	void _CopyString( LPTSTR * szTarget, LPTSTR szSource );
	void _CopyFilter( LPTSTR * szTarget, LPTSTR szDesc, LPTSTR szExt );
	void _SetDefaultPath( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\filepane.cpp ===
#include "Precomp.h"
#include "resource.h"
#include "global.h"
#include "propwnd2.h"
#include "FilePane.h"
#include "NmAkWiz.h"
#include "wndprocs.h"



CFilePanePropWnd2::CFilePanePropWnd2(HWND hwndParent, UINT uIDD, LPTSTR szClassName, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll ) :
    CPropertyDataWindow2( hwndParent, uIDD, szClassName, CFilePanePropWnd2::WndProc, PopUpHelpMenuTextId, iX, iY, iWidth, iHeight, bScroll ),
    m_fOpenDialog(FALSE)
{
	// All the new stuff done in setfilepane...
	// this constructor is already too big
}

void CFilePanePropWnd2::SetFilePane(BOOL fOpenDialog, UINT editID, UINT checkID, UINT browseID, LPTSTR lptstrDesc, LPTSTR lptstrDefExtension, LPTSTR lptstrDefFileName )
{
	SetWindowLong( m_hwnd, GWL_USERDATA, (long)this );

    m_fOpenDialog = fOpenDialog;
	m_editID = editID;
	m_checkID = checkID;
	m_browseID = browseID;
	m_lptstrFilter = NULL;
	m_lptstrDefExtension = NULL;
	m_lptstrDefFileName = NULL;

	_CopyFilter( &m_lptstrFilter, lptstrDesc, lptstrDefExtension );
	_CopyString( &m_lptstrDefExtension, lptstrDefExtension );
	_CopyString( &m_lptstrDefFileName, lptstrDefFileName );

	m_hwndEdit = GetDlgItem( m_hwnd, editID );
	m_hwndCheck = GetDlgItem( m_hwnd, checkID );
	Edit_LimitText( m_hwndEdit, MAX_PATH );
	m_hwndBrowse = GetDlgItem( m_hwnd, browseID );

	_SetDefaultPath();

	_InitOFN();
}

CFilePanePropWnd2::~CFilePanePropWnd2( void )
{
	delete [] m_lptstrFilter;
	delete [] m_lptstrDefExtension;
	delete [] m_lptstrDefFileName;
}


LRESULT CALLBACK CFilePanePropWnd2::WndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
	switch( iMsg )
	{
		case WM_VSCROLL: 
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
			break;
		} 
		case WM_COMMAND:
		if (BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam))
		{
    		CFilePanePropWnd2 *p = (CFilePanePropWnd2 *)GetWindowLong( hwnd, GWL_USERDATA);

            if (p && GET_WM_COMMAND_ID(wParam, lParam) == p->m_browseID)
            {
                p->QueryFilePath();
            }

            return(0);
            break;
        }
	}
	return( DefWindowProc( hwnd, iMsg, wParam, lParam ) );
}



HANDLE CFilePanePropWnd2::CreateFile( DWORD dwDesiredAccess,
							 DWORD dwShareMode,
							 LPSECURITY_ATTRIBUTES lpSecurityAttributes,
							 DWORD dwCreationDisposition,
							 DWORD dwFlagsAndAttributes )
{
	CreateOutputDir();

	TCHAR szFile[ MAX_PATH ];
	TCHAR szPath[ MAX_PATH ];
	GetPath( szPath );
	GetFile( szFile );
	if( '\\' != szPath[ lstrlen( szPath ) - 1 ] )
	{
		lstrcat( szPath, TEXT("\\") );
	}
	lstrcat( szPath, szFile );

	return ::CreateFile( szPath,
						dwDesiredAccess,
						dwShareMode,
						lpSecurityAttributes,
						dwCreationDisposition,
						dwFlagsAndAttributes,
						NULL );
}

void CFilePanePropWnd2::_CopyFilter( LPTSTR* szTarget, LPTSTR szDec, LPTSTR szExt )
{
	int index = 0;
	// Note - add 4 because this filter needs three null terminators and a '*'
	int iLen = (lstrlen( szDec ) + 1) + (1 + lstrlen( szExt ) + 1) + 1;
	*szTarget = new TCHAR[ iLen ];
	lstrcpy( *szTarget, szDec );

	index = lstrlen( *szTarget ) + 1;

	(*szTarget)[index] = '*';
	lstrcpy( &((*szTarget)[index+1]), szExt );

	(*szTarget)[ iLen - 1] = '\0';

}

void CFilePanePropWnd2::_CopyString( LPTSTR* szTarget, LPTSTR szSource )
{
	int iLen = lstrlen( szSource ) + 1;
	*szTarget = new TCHAR[ iLen ];
	lstrcpy( *szTarget, szSource );
}

UINT CALLBACK CFilePanePropWnd2::OFNHookProc(  HWND hdlg,      // handle to child dialog window
							UINT uiMsg,     // message identifier  
							WPARAM wParam,  // message parameter
							LPARAM lParam   // message parameter
						 )
{
	switch (uiMsg)
	{
    	case WM_INITDIALOG:
	    {
		    SetWindowLong(hdlg, GWL_USERDATA, ((OPENFILENAME *)lParam)->lCustData);
    		break;
	    }

    	case WM_NOTIFY:
	    {
		    CFilePanePropWnd2 *p = (CFilePanePropWnd2 *)GetWindowLong( hdlg, GWL_USERDATA );
    		if (NULL == p)
	    		break;
		    return p->_OFNHookProc(hdlg, uiMsg, wParam, lParam);
    	}

	    default:
		    break;
	}

	return 0;
}

UINT CALLBACK CFilePanePropWnd2::_OFNHookProc(  HWND hdlg,      // handle to child dialog window
							UINT uiMsg,     // message identifier  
							WPARAM wParam,  // message parameter
							LPARAM lParam   // message parameter
						 )
{
	switch( uiMsg )
	{
		case WM_NOTIFY:
		{
			OFNOTIFY * pOfnotify = (OFNOTIFY *) lParam;
			switch( pOfnotify -> hdr . code )
			{
				case CDN_FOLDERCHANGE:
				{

					TCHAR szFile[ MAX_PATH ];
					if( !CommDlg_OpenSave_GetSpec( GetParent( hdlg ), szFile, MAX_PATH ) ||
						0 == lstrlen( szFile ) ||
						_tcschr( szFile, '\\' ) )
					{
						CommDlg_OpenSave_SetControlText( GetParent( hdlg ), edt1,
							m_szOFNData );
					}
					else
					{
						lstrcpy( m_szOFNData, szFile );
						OutputDebugString( szFile );
					}
					break;
				}
				case CDN_INITDONE:
				{
					GetFile( m_szOFNData );
					break;
				}
			}
		}
	}

	return( 0 );
}

void CFilePanePropWnd2::_InitOFN( void )
{
	ZeroMemory( &m_ofn, sizeof( m_ofn ) );
	m_ofn.lStructSize = sizeof( m_ofn );
	m_ofn.hwndOwner = m_hwnd;
    m_ofn.hInstance = g_hInstance;
	m_ofn.lpstrFilter = m_lptstrFilter;
	m_ofn.nMaxFile  = MAX_PATH;
	m_ofn.lpstrDefExt = m_lptstrDefExtension;
	m_ofn.Flags = OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ENABLEHOOK ;// | OFN_OVERWRITEPROMPT;
    if (m_fOpenDialog)
        m_ofn.Flags |= OFN_FILEMUSTEXIST;
	m_ofn.lCustData     = (long)this;
	m_ofn.lpfnHook      = OFNHookProc;
	m_ofn.lpstrTitle    = TEXT("Browse");
}

void CFilePanePropWnd2::QueryFilePath( void )
{
	TCHAR szDir[MAX_PATH];
    TCHAR szFile[MAX_PATH];

	GetPath(szDir);
	GetFile(szFile);

	m_ofn.lpstrInitialDir   = szDir;
	m_ofn.lpstrFile         = szFile;

    BOOL bRet;
    if (m_fOpenDialog)
        bRet = GetOpenFileName(&m_ofn);
    else
        bRet = GetSaveFileName(&m_ofn);

	if( bRet )
	{
		Edit_SetText( m_hwndEdit, m_ofn.lpstrFile );
	}
}

void CFilePanePropWnd2::_SetDefaultPath( void ) 
{

    TCHAR szDefaultDistributionFilePath[ MAX_PATH ];
    const TCHAR* szInstallationPath;
    szInstallationPath = GetInstallationPath();
    if( szInstallationPath )
    {
        lstrcpy( szDefaultDistributionFilePath, szInstallationPath );
        _tcscat( szDefaultDistributionFilePath, TEXT("\\output\\") );
		_tcscat( szDefaultDistributionFilePath, m_lptstrDefFileName );
    }
    else
    {
        _tcscat( szDefaultDistributionFilePath, m_lptstrDefFileName );
    }
    Edit_SetText( m_hwndEdit, szDefaultDistributionFilePath );

}

void CFilePanePropWnd2::CreateOutputDir( void ) 
{
    TCHAR sz[ MAX_PATH ];
	GetPath( sz );
	CreateDirectory( sz, NULL );
}


LPTSTR CFilePanePropWnd2::GetPathAndFile( LPTSTR lpstrPath )
{
	Edit_GetText( m_hwndEdit, lpstrPath, MAX_PATH );

	return lpstrPath;
}

LPTSTR CFilePanePropWnd2::GetPath( LPTSTR sz )
{
	TCHAR path[ MAX_PATH], drive[_MAX_DRIVE], dir[_MAX_DIR];
	Edit_GetText( m_hwndEdit, path, MAX_PATH );

	_splitpath( path, drive, dir, NULL, NULL );
	wsprintf( sz, TEXT("%s%s"), drive, dir );

	return sz;
}

LPTSTR CFilePanePropWnd2::GetFile( LPTSTR sz )
{
	TCHAR path[ MAX_PATH], file[_MAX_FNAME], ext[ _MAX_EXT];
	Edit_GetText( m_hwndEdit, path, MAX_PATH );

	_splitpath( path, NULL, NULL, file, ext );

	if (file[0] && (NULL == _tcschr(file, '\\')))
	{
		if (!lstrcmp( m_lptstrDefExtension, ext))
		{
			wsprintf(sz, TEXT("%s%s"), file, m_lptstrDefExtension);
		}
		else
		{
			wsprintf(sz, TEXT("%s%s%s"), file, ext, m_lptstrDefExtension);
		}
	}
	else
	{
        lstrcpy(sz, m_lptstrDefFileName);
	}

	return sz;
}

BOOL CFilePanePropWnd2::OptionEnabled()
{
	return Button_GetCheck( m_hwndCheck ) ? TRUE : FALSE;
}

BOOL CFilePanePropWnd2::Validate( BOOL bMsg )
{
	if( !OptionEnabled() )
	{
		return TRUE;
	}

	TCHAR szPath[ MAX_PATH ];
	TCHAR drive[ _MAX_DRIVE], dir[_MAX_DIR], ext[ _MAX_EXT];
	Edit_GetText( m_hwndEdit, szPath, MAX_PATH );

	if( 0 == lstrlen( szPath ) ) 
	{
		_SetDefaultPath();
		return FALSE;
	}

	_splitpath( szPath, drive, dir, NULL, ext );

	if( 0 != lstrcmp( m_lptstrDefExtension, ext ) )
	{
		lstrcat( szPath, m_lptstrDefExtension );
	}

	wsprintf( szPath, TEXT("%s%s"), drive, dir );

    // Verify that we can write to the location 

    if( szPath[ lstrlen( szPath ) - 1 ] != '\\' ) {
        _tcscat( szPath, TEXT("\\") );
    }

    strcat( szPath, TEXT("eraseme.now") );

    HANDLE hFile = ::CreateFile( szPath, 
                               GENERIC_WRITE, 
                               0,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                               NULL
                             );
    
    if( INVALID_HANDLE_VALUE == hFile ) 
	{
        switch( GetLastError() ) 
		{
            case ERROR_PATH_NOT_FOUND:
			{
                // Try to create the directory...

				GetPath( szPath );
                if( CreateDirectory( szPath, NULL ) ) 
				{
                    // Everything is OK, we created the directory at the path
                    RemoveDirectory( szPath );
				
					// Ask if we should create the directory
					if( bMsg ) 
					{
						if( IDNO == NmrkMessageBox(MAKEINTRESOURCE(IDS_CREATE_DIRECTORY), NULL, MB_YESNO | MB_ICONQUESTION ) )
						{
							return FALSE;
						}
						else
						{
							return TRUE;
						}
					}
					else
					{
						_SetDefaultPath();
						return FALSE;
					}
                }                
                //ErrorMessage();
                if( bMsg ) 
				{
                    NmrkMessageBox(MAKEINTRESOURCE(IDS_SELECTED_PATH_IS_INVALID_PLEASE_CHANGE_THE_PATH_NAME_OR_BROWSE_FOR_A_NEW_PATH),
                                   MAKEINTRESOURCE( IDS_NMAKWIZ_ERROR_CAPTION),
                                MB_OK | MB_ICONEXCLAMATION
                              );
                }
				else
				{
					_SetDefaultPath();
				}
                return FALSE;
				break;
			}
            case ERROR_ACCESS_DENIED:
			{
                if( bMsg ) 
				{
                    NmrkMessageBox(
								MAKEINTRESOURCE(IDS_YOU_DO_NOT_HAVE_WRITE_ACCESS_TO_THE_SELECTED_PATH_PLEASE_SELECT_A_PATH_IN_WHICH_YOU_HAVE_WRITE_PERMISSION),
                                MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
								MB_OK | MB_ICONEXCLAMATION
                              );
                }
				else
				{
					_SetDefaultPath();
				}
                return FALSE;
				break;
			}
            default:
                return FALSE;
				break;
        }

    }
    else {
        CloseHandle( hFile );
        DeleteFile( szPath );
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\finishdg.cpp ===
#include "Precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
#include "FinishDg.h"
#include "nmakwiz.h"



// Static
CFinishSheet* CFinishSheet::ms_pFinishSheet = NULL;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CFinishSheet::CFinishSheet( void ) :
    m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						CFinishSheet::DlgProc),
    m_pFilePane( NULL )
{
    ms_pFinishSheet = this;
}


CFinishSheet::~CFinishSheet(void) 
{
    delete m_pFilePane;
    m_pFilePane = NULL;
    ms_pFinishSheet = NULL;
}




////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

INT_PTR CALLBACK CFinishSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {

    switch( message )
    {
		case WM_INITDIALOG:
        {
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_FINISH | PSWIZB_BACK );
            ms_pFinishSheet->_CreateFilePane(hDlg);
			return TRUE;
        }

		case WM_NOTIFY:
        {
			switch( reinterpret_cast< NMHDR FAR* >( lParam ) -> code )
            {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_FINISH | PSWIZB_BACK );
                    ms_pFinishSheet->m_pFilePane->Validate(FALSE);
			        return TRUE;

                case PSN_WIZBACK:
                    if (!ms_pFinishSheet->m_pFilePane->Validate(TRUE))
                    {
                        SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                        return TRUE;
                    }
                    break;

                case PSN_WIZFINISH:
                    if (!ms_pFinishSheet->m_pFilePane->Validate(TRUE))
                    {
                        SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                        return TRUE;
                    }

                    g_pWiz->CallbackForWhenUserHitsFinishButton();
                    return TRUE;
			}
            break;
        }

		default:
			break;

	}

	return FALSE;

}



//
// _CreateFilePane()
//
void CFinishSheet::_CreateFilePane(HWND hDlg)
{
    RECT    rect;

    GetClientRect(hDlg, &rect);
    int iHeight = rect.bottom - rect.top;
    int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;

    m_pFilePane = new CFilePanePropWnd2(hDlg, IDD_FILEPANE_SETTINGS,
        TEXT("IDD_FILEPANE_SETTINGS"), 0, CPropertyDataWindow2::mcs_iLeft,
        CPropertyDataWindow2::mcs_iTop, iWidth, iHeight);

    HWND hwndCond = GetDlgItem(m_pFilePane->GetHwnd(), IDC_SETTINGS_FILE);
    m_pFilePane->ConnectControlsToCheck(IDC_SETTINGS_FILE, 2,
            new CControlID(hwndCond, IDC_SETTINGS_FILE, IDE_SETTINGS_FILE,
                    CControlID::EDIT),
            new CControlID(hwndCond, IDC_SETTINGS_FILE, IDC_BROWSE_SETTINGS_FILE,
                    CControlID::CHECK));

    m_pFilePane->SetFilePane(FALSE, IDE_SETTINGS_FILE, IDC_SETTINGS_FILE,
        IDC_BROWSE_SETTINGS_FILE, TEXT("Configuration File (*.ini)"),
        TEXT(".ini"), TEXT("nm3c.ini"));

	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
    {
        TCHAR   szFile[MAX_PATH];

        g_pWiz->m_IntroSheet.GetFilePane()->GetPathAndFile(szFile);
        Edit_SetText(GetDlgItem(m_pFilePane->GetHwnd(), IDE_SETTINGS_FILE),
            szFile);
    }

    m_pFilePane->ShowWindow(TRUE);
    m_pFilePane->SetCheck(IDC_SETTINGS_FILE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\fileparm.h ===
#ifndef __FileParm_h__
#define __FileParm_h__

#include "FilePane.h"

class CDistributionSheet {

friend class CNmAkWiz;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	static UINT CALLBACK DistroOFNHookProc(  HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam );
	static UINT CALLBACK AutoConfOFNHookProc(  HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam );
    static CDistributionSheet* ms_pDistributionFileSheet;
    static int ms_MaxDistributionFilePathLen;
	static  TCHAR ms_szOFNData[ MAX_PATH];


private: // DATA
    CPropertySheetPage m_PropertySheetPage; 
	OPENFILENAME	   m_ofn;

	CFilePanePropWnd2 *		   m_pDistroFilePane;
	CFilePanePropWnd2 *        m_pAutoFilePane;

	BOOL			m_bHadAutoConf;
	BOOL			m_bLastRoundUp;
	LPTSTR			m_szLastLocation;
  
public:
	inline CFilePanePropWnd2 * GetDistroFilePane() { return m_pDistroFilePane; }
	inline CFilePanePropWnd2 * GetAutoFilePane() { return m_pAutoFilePane; }
	inline BOOL TurnedOffAutoConf() { return m_bLastRoundUp; }

private: 
    CDistributionSheet( void );
    ~CDistributionSheet( void );

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}
	void CreateFilePanes(HWND hDlg);
//    int GetEditLen( UINT id );
//    void GetEditText( UINT id, TCHAR* sz, int cb );
};

#endif // __FileParm_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\finishdg.h ===
#ifndef __FinishDg_h__
#define __FinishDg_h__

#include "filepane.h"

class CFinishSheet
{

friend class CNmAkWiz;

private: // DATA
    CPropertySheetPage      m_PropertySheetPage;
    CFilePanePropWnd2 *     m_pFilePane;
    static CFinishSheet *   ms_pFinishSheet;

public:
    CFilePanePropWnd2 * GetFilePane(void) const {return m_pFilePane;}

private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );

    CFinishSheet( void );
    ~CFinishSheet( void );

    void _CreateFilePane(HWND hDlg);

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}
};

#endif // __FinishDg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\nmak.cpp ===
#include "precomp.h"
#include "resource.h"
#include "NmAkWiz.h"



int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPSTR lpCmdLine, int nCmdShow) 
{

	CNmAkWiz::DoWizard( hInstance );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\global.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// This is a collection of useful functions. 
// 


#ifndef __Global_h__
#define __Global_h__


    // Display a message box to query the user if she is sure she wants to exit the wizard
BOOL VerifyExitMessageBox(void);
    
    // Return a SIZE structure for the size that text will be in a window        
    // A return value of SIZE( -1, -1 ) indicates an error
SIZE GetTextSize( HWND hWnd, LPCTSTR sz );

    // Return a the height for the text will be in a window        
    // A return value of -1 indicates an error
int GetTextHeight( HWND hWnd, LPCTSTR sz );

    // Return a the width for the text will be in a window        
    // A return value of -1 indicates an error
int GetTextWidth( HWND hWnd, LPCTSTR sz );

TCHAR *MakeCopyOfString( const TCHAR* sz );

#endif // __Global_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\nmakreg.h ===
#ifndef __NMAKReg_h__
#define __NMAKReg_h__


////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef TEXT
    #define TEXT( a ) ( a )
#endif // TEXT

////////////////////////////////////////////////////////////////////////////////////////////////////


//
// GLOBAL SETTINGS FILE, THIS IS USED BY THE SOFTWARE COMPONENTS ALSO.
// That way, we have one place where registry keys, settings go, and 
// modifications affect the NMRK as well as the code.
// 
#include <confreg.h>

#define REGKEY_NMRK                         TEXT("SOFTWARE\\Microsoft\\NMRK")
#define REGVAL_INSTALLATIONDIRECTORY        TEXT("InstallationDirectory")
#define REGVAL_LASTCONFIG                   TEXT("LastConfig")

#define DEFAULT_CONFIGFILE                  "nm3c.ini"
#define SECTION_SETTINGS                    TEXT("NMRK30Settings")

#define KEYNAME_AUTOCONF                    TEXT("AutoConf")
#define KEYNAME_ILSSERVER                   TEXT("IlsServer%d")
#define KEYNAME_ILSDEFAULT                  TEXT("IlsDefault")

#define KEYNAME_WEBVIEWNAME					TEXT("WebViewName")
#define KEYNAME_WEBVIEWURL					TEXT("WebViewURL")
#define KEYNAME_WEBVIEWSERVER				TEXT("WebViewServer")

#endif // __NMAKReg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\fileparm.cpp ===
#include "Precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
//#include "SelTargt.h"
#include "FileParm.h"
#include "nmakwiz.h"



////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
/* static */ CDistributionSheet* CDistributionSheet::ms_pDistributionFileSheet = NULL;
/* static */ int CDistributionSheet::ms_MaxDistributionFilePathLen;
/* static */ TCHAR CDistributionSheet::ms_szOFNData[ MAX_PATH];

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

INT_PTR CALLBACK CDistributionSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {
    

    switch( message ) 
	{
		case WM_INITDIALOG:
		{
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
			ms_pDistributionFileSheet->CreateFilePanes(hDlg);
	
			return TRUE;
		}

        case WM_COMMAND:
		{
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_BUTTON_BROWSE_DISTRIBUTION_FILE_PATH:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							ms_pDistributionFileSheet->m_pDistroFilePane->QueryFilePath( );
							return TRUE;
                            break;
                        }
                    }
                    break;
                }

                case IDC_BUTTON_BROWSE_AUTO_CONFIG_PATH:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							ms_pDistributionFileSheet->m_pAutoFilePane->QueryFilePath( );
							return TRUE;
                            break;
                        }
                    }
                    break;
                }
            }
            break;
        }


		case WM_NOTIFY:
		{
			switch( reinterpret_cast< NMHDR FAR* >( lParam )->code ) 
			{
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 

                    ms_pDistributionFileSheet->m_pDistroFilePane->Validate(FALSE);

					ms_pDistributionFileSheet->m_pAutoFilePane->Validate(FALSE);

			        return TRUE;

                case PSN_WIZNEXT:   
					// Distro
                    if( !ms_pDistributionFileSheet->m_pDistroFilePane->Validate(TRUE) )
					{
						SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
						return TRUE;
					}

					// AutoConf
					if( !ms_pDistributionFileSheet->m_pAutoFilePane->Validate(TRUE) )
					{
						SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
						return TRUE;
					}
					
					if( ms_pDistributionFileSheet->m_pAutoFilePane->OptionEnabled() )
					{
						if( !Edit_GetTextLength( 
							GetDlgItem( ms_pDistributionFileSheet->m_pAutoFilePane->GetHwnd(),
										IDC_AUTOCONF_URL ) ) )
						{
							NmrkMessageBox(MAKEINTRESOURCE(IDS_NEED_CONF_SERVER), NULL, MB_OK | MB_ICONWARNING );
							SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
							return TRUE;
						}
					}
					else if( ms_pDistributionFileSheet->m_bHadAutoConf )
					{
						if( IDNO == NmrkMessageBox(MAKEINTRESOURCE(IDS_TURNING_OFF_AUTOCONF), NULL, MB_YESNO | MB_ICONWARNING ) )
						{
							ms_pDistributionFileSheet->m_pAutoFilePane->SetCheck( IDC_CHECK_AUTOCONFIG_CLIENTS, TRUE );
							SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
							return TRUE;
						}
						else
						{
							ms_pDistributionFileSheet->m_pAutoFilePane->SetEditData( IDC_EDIT_AUTO_CONFIG_FILE_PATH, ms_pDistributionFileSheet->m_szLastLocation );
							ms_pDistributionFileSheet->m_bLastRoundUp = TRUE;
						}
					}

					return TRUE;
			}
		}

		default:
			break;

	}

	return FALSE;

}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CDistributionSheet::CDistributionSheet( void )
 : m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						CDistributionSheet::DlgProc /*, 
						PSP_HASHELP   */
                       ),
    m_pDistroFilePane( NULL ), m_pAutoFilePane( NULL ), m_bHadAutoConf( FALSE ), m_bLastRoundUp( FALSE ), m_szLastLocation( NULL )
{   
	 ZeroMemory( &m_ofn, sizeof( OPENFILENAME ) );
     ms_MaxDistributionFilePathLen = MAX_PATH;
     ms_pDistributionFileSheet = this; 
}

CDistributionSheet::~CDistributionSheet( void ) 
{ 
	delete m_pDistroFilePane;
    m_pDistroFilePane = NULL;

	delete m_pAutoFilePane;
    m_pAutoFilePane = NULL;

	delete [] m_szLastLocation;
    m_szLastLocation = NULL;

    ms_pDistributionFileSheet = NULL;
}

void CDistributionSheet::CreateFilePanes(HWND hWndDlg) 
{
	RECT rect;

	GetClientRect( hWndDlg, &rect );
	int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;
	int iTop = CPropertyDataWindow2::mcs_iTop + CPropertyDataWindow2::mcs_iBorder;

	// The top panel is being given 1/3 of the vertical space
	int iHeight = MulDiv( rect.bottom, 1, 3 );
	m_pDistroFilePane = new CFilePanePropWnd2(hWndDlg,
											IDD_FILEPANE_DISTRO,
											TEXT("IDD_FILEPANE_DISTRO"),
											0,
											CPropertyDataWindow2::mcs_iLeft,
											iTop,
											iWidth,
											iHeight );

	HWND hwndCond = GetDlgItem( m_pDistroFilePane->GetHwnd(), IDC_CHECK_CREATE_DISTRIBUTION );
	m_pDistroFilePane->ConnectControlsToCheck( IDC_CHECK_CREATE_DISTRIBUTION, 2,
										new CControlID( hwndCond,
														IDC_CHECK_CREATE_DISTRIBUTION,
														IDC_EDIT_DISTRIBUTION_FILE_PATH,
														CControlID::EDIT ),
										new CControlID( hwndCond,
														IDC_CHECK_CREATE_DISTRIBUTION,
														IDC_BUTTON_BROWSE_DISTRIBUTION_FILE_PATH,
														// Note this is not a check but I don't think I care
														CControlID::CHECK ) );

	m_pDistroFilePane->SetFilePane( FALSE, IDC_EDIT_DISTRIBUTION_FILE_PATH,
								IDC_CHECK_CREATE_DISTRIBUTION,
								IDC_BUTTON_BROWSE_DISTRIBUTION_FILE_PATH,
					   			TEXT( "Application (*.exe)" ),
								TEXT( ".exe" ),
								TEXT( "Nm3c.exe" ) );

	m_pDistroFilePane->SetCheck( IDC_CHECK_CREATE_DISTRIBUTION, TRUE );


	//iHeight = rect.bottom - iHeight;
	m_pAutoFilePane = new CFilePanePropWnd2(hWndDlg,
										IDD_FILEPANE_AUTOCONF,
										TEXT("IDD_FILEPANE_AUTOCONF"),
										0,
										CPropertyDataWindow2::mcs_iLeft,
										iHeight,
										iWidth,
										rect.bottom - iHeight );

	hwndCond = GetDlgItem( m_pAutoFilePane->GetHwnd(), IDC_CHECK_AUTOCONFIG_CLIENTS );
	m_pAutoFilePane->ConnectControlsToCheck( IDC_CHECK_AUTOCONFIG_CLIENTS, 3,
										new CControlID( hwndCond,
														IDC_CHECK_AUTOCONFIG_CLIENTS,
														IDC_EDIT_AUTO_CONFIG_FILE_PATH,
														CControlID::EDIT ),
										new CControlID( hwndCond,
														IDC_CHECK_AUTOCONFIG_CLIENTS,
														IDC_AUTOCONF_URL,
														CControlID::EDIT ),
										new CControlID( hwndCond,
														IDC_CHECK_AUTOCONFIG_CLIENTS,
														IDC_BUTTON_BROWSE_AUTO_CONFIG_PATH,
														// Note this is not a check but I don't think I care
														CControlID::CHECK ) );


	m_pAutoFilePane->SetFilePane( FALSE, IDC_EDIT_AUTO_CONFIG_FILE_PATH,
								IDC_CHECK_AUTOCONFIG_CLIENTS,
								IDC_BUTTON_BROWSE_AUTO_CONFIG_PATH,
								TEXT( "Application Settings(*.inf)" ),
								TEXT( ".inf" ),
								TEXT( "nm3conf.inf" ) );
	m_pAutoFilePane->SetCheck( IDC_CHECK_AUTOCONFIG_CLIENTS, FALSE );

	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
	{
		m_pDistroFilePane->ReadSettings();
		m_pAutoFilePane->ReadSettings();
	}

	if (m_bHadAutoConf = m_pAutoFilePane->OptionEnabled())
	{
		m_szLastLocation = new TCHAR[ MAX_PATH ];
		assert( m_szLastLocation );
		m_pAutoFilePane->GetPathAndFile( m_szLastLocation );
	}

	m_pAutoFilePane->ShowWindow( TRUE );
	m_pDistroFilePane->ShowWindow( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\global.cpp ===
#include "precomp.h"
#include "resource.h"
#include "global.h"
#include "nmakwiz.h"

////////////////////////////////////////////////////////////////////////////////////////////////////


//#include <crtdbg.h>
//#ifdef _DEBUG
//#undef THIS_FILE
//static char THIS_FILE[] = __FILE__;
//#define new new( _NORMAL_BLOCK, THIS_FILE, __LINE__)
//#endif

////////////////////////////////////////////////////////////////////////////////////////////////////
// Display a message box to query the user if she is sure she wants to exit the wizard
// Returns TRUE if the user wants to quit, else returns FALSE

BOOL VerifyExitMessageBox(void)
{
	int ret = NmrkMessageBox(MAKEINTRESOURCE(IDS_DO_YOU_REALLY_WANT_TO_QUIT_THE_WIZARD_NOW),
        NULL, MB_YESNO | MB_DEFBUTTON2);

	return ( ret == IDYES ) ? TRUE : FALSE;

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Copy a string using the "new" allocator.... string must be deleted with delete [];
//
TCHAR *MakeCopyOfString( const TCHAR* sz ) {

    if( NULL == sz ) { return NULL; }
    TCHAR* local = new char[ strlen( sz ) + 1 ];
    if( NULL == local ) { return NULL; }
    lstrcpy( local, sz );
    return local;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\nmakwiz.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------
//| NetMeeting Administration Kit Wizard  ( NmAkWiz )|
//----------------------------------------------------
//
// This is the controling class for the NetMeeting Administration Kit Wizard. Most of
// this could have been done globally, but it is so much prettier when it is enclosed in a class...
// CNmAkViz objects are not actually created by the user.  The only access is provided through the
// static member function DoWizard.  All the user has to do is call this single function, like this:
//
//
/////////////
//
// #include "NmAkWiz.h"
//
//
// int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPSTR lpCmdLine, int nCmdShow) {
//
//      CNmAkWiz::DoWizard( hInstance );
//      ExitProcess(0);
//    return 0;
// }
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////


#ifndef __NmAkWiz_h__
#define __NmAkWiz_h__

////////////////////////////////////////////////////////////////////////////////////////////////////
// Include files

#include "PShtHdr.h"
#include "WelcmSht.h"
#include "SetInSht.h"
#include "SetSht.h"
#include "FileParm.h"
#include "FinishDg.h"
#include "PolData.h"
#include "DSList.h"
#include "Confirm.h"



////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4786 )
#include <map>
using namespace std;



////////////////////////////////////////////////////////////////////////////////////////////////////
// This is the NetMeeting Resource Deployment Wizard

class CNmAkWiz {

public: 
	friend class CIntroSheet;
	friend class CSettingsSheet;
    friend class CCallModeSheet;
    friend class CConfirmationSheet;
    friend class CDistributionSheet;
    friend class CFinishSheet;
    friend class CPropertyDataWindow2;
	
	// STATIC Fns
	static  HRESULT  DoWizard( HINSTANCE hInstance );
    void    CallbackForWhenUserHitsFinishButton( void );

private: // private static Data
    static TCHAR                                ms_InfFilePath[ MAX_PATH ];
    static TCHAR                                ms_InfFileName[ MAX_PATH ];
    static TCHAR                                ms_FileExtractPath[ MAX_PATH ];
    static TCHAR                                ms_ToolsFolder[ MAX_PATH ];
    static TCHAR                                ms_NetmeetingSourceDirectory[ MAX_PATH ];
    static TCHAR                                ms_NetmeetingOutputDirectory[ MAX_PATH ];
    static TCHAR                                ms_NetmeetingOriginalDistributionFilePath[ MAX_PATH ];
    static TCHAR                                ms_NetmeetingOriginalDistributionFileName[ MAX_PATH ];
    static TCHAR                                ms_NMRK_TMP_FolderName[ MAX_PATH ];

public: // DATATYPES
	enum eSheetIDs
    {
        ID_WelcomeSheet = 0, 
        ID_IntroSheet,
        ID_SettingsSheet,
        ID_CallModeSheet,
        ID_ConfirmationSheet,
        ID_DistributionSheet,
        ID_FinishSheet,
        ID_NumSheets
    };



private:    // Construction / destruction ( private, so only access is through DoWizard( ... )
	CNmAkWiz( void );
	~CNmAkWiz( void );

public:    // Data
	CPropertySheetHeader        m_PropSheetHeader;
	CWelcomeSheet               m_WelcomeSheet;
    CIntroSheet                 m_IntroSheet;
    CSettingsSheet              m_SettingsSheet;
    CCallModeSheet              m_CallModeSheet;
    CConfirmationSheet          m_ConfirmationSheet;
    CDistributionSheet          m_DistributionSheet;
    CFinishSheet                m_FinishSheet;

private:
    HANDLE                      m_hInfFile;

private: // HELPER Fns

	void _CreateTextSpew( void );
	void _CreateDistro( void );
	void _CreateAutoConf( void );
	void _CreateFinalAutoConf( void );
    void _CreateSettingsFile( void );

    BOOL _InitInfFile( void );
    BOOL _StoreDialogData( HANDLE hFile );
    BOOL _CloseInfFile( void );
    BOOL _CreateDistributableFile( CFilePanePropWnd2 *pFilePane );
    BOOL _CreateFileDistribution( CFilePanePropWnd2 *pFilePane );
    BOOL _DeleteFiles( void );
    BOOL _GetNetMeetingOriginalDistributionData( void );
    BOOL _NetMeetingOriginalDistributionIsAtSpecifiedLocation( void );

    BOOL _ExtractOldNmCabFile( void );
    BOOL _CreateNewInfFile( void );
    BOOL _SetPathNames( void );
};

extern CNmAkWiz *   g_pWiz;
const TCHAR* GetInstallationPath( void );


int NmrkMessageBox(LPCSTR lpText, LPCSTR lpCaption, UINT uType, HWND hwndParent=NULL);


#endif // __NmAkWiz_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\nmakwiz.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// Look at the header file for usage information...


#include "precomp.h"
#include "resource.h"
#include <direct.h>
#include "PropPg.h"
#include "PShtHdr.h"
#include "NmAkWiz.h"
#include "PolData.h"
#include "NMAKReg.h"

/////////////////
// Global
/////////////////
CNmAkWiz *  g_pWiz = NULL;
HWND        g_hwndActive = NULL;
HINSTANCE   g_hInstance = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static Data
////////////////////////////////////////////////////////////////////////////////////////////////////

/* static */ TCHAR CNmAkWiz::ms_InfFilePath[ MAX_PATH ] = TEXT("output");
/* static */ TCHAR CNmAkWiz::ms_InfFileName[ MAX_PATH ] = TEXT("msnetmtg.inf");
/* static */ TCHAR CNmAkWiz::ms_FileExtractPath[ MAX_PATH ] = TEXT("output");
/* static */ TCHAR CNmAkWiz::ms_ToolsFolder[ MAX_PATH ] = TEXT("tools");
/* static */ TCHAR CNmAkWiz::ms_NetmeetingOriginalDistributionFilePath[ MAX_PATH ] = TEXT("");
/* static */ TCHAR CNmAkWiz::ms_NetmeetingSourceDirectory[ MAX_PATH ] = TEXT("source");
/* static */ TCHAR CNmAkWiz::ms_NetmeetingOutputDirectory[ MAX_PATH ] = TEXT("output");
/* static */ TCHAR CNmAkWiz::ms_NetmeetingOriginalDistributionFileName[ MAX_PATH ] = TEXT("nm30.exe");
/* static */ TCHAR CNmAkWiz::ms_NMRK_TMP_FolderName[ MAX_PATH ] = TEXT("nmrktmp");


////////////////////////////////////////////////////////////////////////////////////////////////////
// Static Fns
////////////////////////////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------------------------------
// DoWizard is a static function of CNmAkWiz.  This was done for two reasons:
// 1.) There is always only a single CNmAkViz object
// 2.) I wanted to make it clear that duriving something from CNmAkWiz is nonsense, so only access
//         to the CNmAkViz constructor and destructor is through this static helper function
// 
// Do Wizard "blocks" while the modal NetMeeting AK Wizard does it's thing.
HRESULT CNmAkWiz::DoWizard( HINSTANCE hInstance )
{
    g_hInstance = hInstance;
    
    if( NULL == GetInstallationPath() )
    {   
        // This means that NMRK is not properly installed
        NmrkMessageBox(MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_NMRK_MUST_BE_PROPERLY_INSTALLED),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION), MB_OK | MB_ICONSTOP);

        NmrkMessageBox(MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_PLEASE_REINSTALL_NET_MEETING_RESOURCE_KIT),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION), MB_OK | MB_ICONSTOP);

        return E_FAIL;


    }

    // Init common controls
	InitCommonControls();

    g_pWiz = new CNmAkWiz();
    if (!g_pWiz)
        return E_FAIL;

	HRESULT hr;

	// Initialize the Welcome property page
    g_pWiz->m_PropSheetHeader[ ID_WelcomeSheet ]         = g_pWiz->m_WelcomeSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_IntroSheet ]           = g_pWiz->m_IntroSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_SettingsSheet ]        = g_pWiz->m_SettingsSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_CallModeSheet ]        = g_pWiz->m_CallModeSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_ConfirmationSheet ]    = g_pWiz->m_ConfirmationSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_DistributionSheet ]    = g_pWiz->m_DistributionSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_FinishSheet ]          = g_pWiz->m_FinishSheet.GetPropertySheet();

    if (-1 == PropertySheet(g_pWiz->m_PropSheetHeader))
    {
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }
    
    delete g_pWiz;
    g_pWiz = NULL;

    return hr;
}

void CNmAkWiz::_CreateTextSpew( void )
{
	CFilePanePropWnd2 * pFilePane = m_ConfirmationSheet.GetFilePane();
	if( pFilePane->OptionEnabled() )
	{
		HANDLE hFile = pFilePane->CreateFile( 
						GENERIC_WRITE | GENERIC_READ,
						FILE_SHARE_READ,
						NULL,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_NORMAL );
		if( INVALID_HANDLE_VALUE == hFile )
		{
			return;
		}
		else 
		{
			HWND hList = m_ConfirmationSheet.GetListHwnd();
			int iLines = ListBox_GetCount( hList );
			DWORD dwWritten = 0;

			for( int i = 0; i < iLines; i++ )
			{
				int iLen = ListBox_GetTextLen( hList, i ) + 1;
				LPTSTR szLine = new TCHAR[ iLen ];
				ListBox_GetText( hList, i, szLine );

				if( !WriteFile( hFile, (void *)szLine, iLen, &dwWritten, NULL ) ||
					!WriteFile( hFile, (void *)TEXT("\r\n"), lstrlen( TEXT("\r\n") ), &dwWritten, NULL ) )
				{
					delete [] szLine;
					return;
				}
				delete [] szLine;
			}

			CloseHandle( hFile );
		}
	}
}

void CNmAkWiz::_CreateDistro( void )
{
	CFilePanePropWnd2 * pFilePane = m_DistributionSheet.GetDistroFilePane();

	if( pFilePane->OptionEnabled() )
	{
        if( ! _SetPathNames() ) { assert( 0 ); return; }

        // First Extract the nm21.exe file to the OUTPUT Directory
        if( !_ExtractOldNmCabFile() ) { assert( 0 ); return; }    

        // Create the new MsNetMtg.inf file in the OUTPUT Directory
        if( !_CreateNewInfFile() ) { assert( 0 ); return; }    

        if( !_CreateFileDistribution( pFilePane ) ) { return; }

		// Clean up after ourselves
        if( !_DeleteFiles() ) { assert( 0 ); return; }
	}
}

void CNmAkWiz::_CreateFinalAutoConf( void )
{
	CFilePanePropWnd2 * pFilePane = m_DistributionSheet.GetAutoFilePane();

//	if( pFilePane->OptionEnabled() )
//	{
		//
		// Try to drop most of the output in a temp file...
		//
		TCHAR szBuf[ 256 ];
		ULONG cbWritten;

		HANDLE hAutoINF = pFilePane->CreateFile( GENERIC_WRITE | GENERIC_READ,
											 FILE_SHARE_READ,
											 NULL,
											 CREATE_ALWAYS,
											 FILE_ATTRIBUTE_NORMAL
										   );
		if( INVALID_HANDLE_VALUE == hAutoINF )
		{
			ErrorMessage();
			return;
		}

		lstrcpy( szBuf, TEXT("[version]\r\nsignature=\"$CHICAGO$\"\r\n\r\n\r\nAdvancedINF=2.5\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write string [NetMtg.Install.NMRK]\n
		lstrcpy( szBuf, TEXT("[NetMtg.Install.NMRK]\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("AddReg=NetMtg.Install.Reg.NMRK\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("DelReg=NetMtg.Install.DeleteReg.NMRK\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}


		// Write string [NetMtg.Install.Reg.NMRK]\n
		lstrcpy( szBuf, TEXT("\r\n\r\n[NetMtg.Install.Reg.NMRK]\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("HKCU,\"SOFTWARE\\Microsoft\\Conferencing\\AutoConf\",\"Use AutoConfig\",65537,0, 0, 0, 0\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write the REG Keys
		//_StoreDialogData( hAutoINF );

		// Write string [NetMtg.Install.DeleteReg.NMRK]\n
		lstrcpy( szBuf, TEXT("\r\n\r\n[NetMtg.Install.DeleteReg.NMRK]\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write the REG Delete Keys
		//CPolicyData::FlushCachedInfData( hAutoINF );

		// this is needed...
		lstrcpy( szBuf, TEXT("\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		CloseHandle( hAutoINF );
//	}
}


void CNmAkWiz::_CreateAutoConf( void )
{
	CFilePanePropWnd2 * pFilePane = m_DistributionSheet.GetAutoFilePane();

	if( pFilePane->OptionEnabled() )
	{
		//
		// Try to drop most of the output in a temp file...
		//
		TCHAR szBuf[ 256 ];
		ULONG cbWritten;

		HANDLE hAutoINF = pFilePane->CreateFile( GENERIC_WRITE | GENERIC_READ,
											 FILE_SHARE_READ,
											 NULL,
											 CREATE_ALWAYS,
											 FILE_ATTRIBUTE_NORMAL
										   );
		if( INVALID_HANDLE_VALUE == hAutoINF )
		{
			ErrorMessage();
			return;
		}

		lstrcpy( szBuf, TEXT("[version]\r\nsignature=\"$CHICAGO$\"\r\n\r\n\r\nAdvancedINF=2.5\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write string [NetMtg.Install.NMRK]\n
		lstrcpy( szBuf, TEXT("[NetMtg.Install.NMRK]\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("AddReg=NetMtg.Install.Reg.NMRK\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("DelReg=NetMtg.Install.DeleteReg.NMRK\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}


		// Write string [NetMtg.Install.Reg.NMRK]\n
		lstrcpy( szBuf, TEXT("\r\n\r\n[NetMtg.Install.Reg.NMRK]\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write the REG Keys
		_StoreDialogData( hAutoINF );

		// Write string [NetMtg.Install.DeleteReg.NMRK]\n
		lstrcpy( szBuf, TEXT("\r\n\r\n[NetMtg.Install.DeleteReg.NMRK]\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write the REG Delete Keys
		CPolicyData::FlushCachedInfData( hAutoINF );

		// this is needed...
		lstrcpy( szBuf, TEXT("\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		CloseHandle( hAutoINF );
	}
}



//
// CreateSettingsFile()
//
// This saves the options (policies, servers, auto-conf location, distro loc)
// to a .INI file
//
void CNmAkWiz::_CreateSettingsFile(void)
{
    CFilePanePropWnd2 * pFilePane = m_FinishSheet.GetFilePane();

    if (pFilePane->OptionEnabled())
    {
        HKEY    hKey;

    	m_SettingsSheet.WriteSettings();
        m_CallModeSheet.WriteSettings();
    	m_ConfirmationSheet.GetFilePane()->WriteSettings();
	    m_DistributionSheet.GetDistroFilePane()->WriteSettings();
    	m_DistributionSheet.GetAutoFilePane()->WriteSettings();

        // Save last config path in registry.
        if (RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_NMRK, &hKey) == ERROR_SUCCESS)
        {
            TCHAR   szFile[MAX_PATH];

            pFilePane->GetPathAndFile(szFile);

            RegSetValueEx(hKey, REGVAL_LASTCONFIG, 0, REG_SZ, (LPBYTE)szFile,
                lstrlen(szFile)+1);

            RegCloseKey(hKey);
        }
    }
}


//-------------------------------------------------------------------------------------------------
// This is called when the user hits the the FINISH button after entering data with the wizard...
//  We simply get the information from the various dialogs ( property sheets as they are ), and 
//  set the appropriate data in the .INF file
void CNmAkWiz::CallbackForWhenUserHitsFinishButton( void )
{
	if (m_DistributionSheet.TurnedOffAutoConf() )
	{
		_CreateFinalAutoConf();
	}
	else
	{
		_CreateAutoConf();
	}

	_CreateTextSpew();
    _CreateSettingsFile();
	_CreateDistro();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructors, Destructors, and Initialization Fns
////////////////////////////////////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------------------------------------
// CNmAkWiz::CNmAkWiz
CNmAkWiz::CNmAkWiz(void)
:   m_WelcomeSheet(),
    m_IntroSheet(),
    m_SettingsSheet(),
    m_CallModeSheet(),
    m_ConfirmationSheet(),
    m_DistributionSheet(),
    m_FinishSheet(),
    m_PropSheetHeader( ID_NumSheets, 
                       PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW /* | PSH_HASHELP */
                     )
{ 
}


//--------------------------------------------------------------------------------------------------
// CNmAkWiz::~CNmAkWiz
CNmAkWiz::~CNmAkWiz( void ) 
{ 
}



//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_InitInfFile opens the reg file specified by  ms_InfFilePath\ms_InfFileName.
// If the file cannot be created there, the user is prompted for a good location for the file.
BOOL CNmAkWiz::_InitInfFile( void ) {

        // First we have to open the .INF file
    TCHAR szFileName[ MAX_PATH ];
    int Err;        

    const TCHAR* szInstallationPath = GetInstallationPath();
    if( NULL != szInstallationPath ) {
        
        lstrcpy( szFileName, szInstallationPath );
        lstrcat( szFileName, TEXT("\\") );
        lstrcat( szFileName, ms_InfFilePath );
        lstrcat( szFileName, TEXT("\\") );
        lstrcat( szFileName, ms_InfFileName );
    }
    else {
        assert( 0 );          
        lstrcat( szFileName, ms_InfFileName );
    }

    /**/m_hInfFile = CreateFile( szFileName, 
                                        GENERIC_WRITE, 
                                        0,
                                        NULL,
                                        CREATE_ALWAYS, // This is going to overwrite existing files
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL
                                      );
    

    
    if( INVALID_HANDLE_VALUE == m_hInfFile ) {
        switch( Err = GetLastError() ) {

            case ERROR_ACCESS_DENIED:
                assert( 0 ); return FALSE;

            case ERROR_PATH_NOT_FOUND:
                
                assert( 0 ); return FALSE;


            case ERROR_WRITE_PROTECT:
                
                assert( 0 ); return FALSE;

            default:
                ErrorMessage( "", Err );
                assert( 0 );
                return FALSE;
        }

    }

    DWORD cbWritten;        

    TCHAR szPreamble [] = TEXT("[version]\nsignature=\"$CHICAGO$\"\nAdvancedINF=2.5\n\n[DefaultInstall]\nAddReg\t= AddRegSection\nDelReg\t= DelRegSection\n\n\n[AddRegSection]\n");

    RETFAIL( WriteFile( m_hInfFile, szPreamble, lstrlen( szPreamble ), &cbWritten, NULL ) );
    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_StoreDialogData 
//  The user specifies a bunch of data in the g_pWiz-> NetMeeting ( conf.exe ) reads customization
//  data stored from the registry. We have to store this customization data in a .INF file for 
//  the setup program to use.  This function will get the data from the wizard and save it to
//  a .INF file according to the key maps which map a Wizard property to a Infistry entry...
BOOL CNmAkWiz::_StoreDialogData( HANDLE hFile ) {

	m_SettingsSheet.WriteToINF( hFile );
    m_CallModeSheet.WriteToINF( hFile );

	m_DistributionSheet.GetAutoFilePane()->WriteToINF( hFile, TRUE );

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_CloseInfFile closes the registry file that we are using to store the data entered
//  by the user in the Wizard. 
BOOL CNmAkWiz::_CloseInfFile( void ) {

    TCHAR szDelRegSectionPrefix[] = "\n\n[DelRegSection]\n";

    DWORD cbWritten;

    RETFAIL( WriteFile( m_hInfFile, szDelRegSectionPrefix, lstrlen( szDelRegSectionPrefix ), &cbWritten, NULL ) );

    CPolicyData::FlushCachedInfData( m_hInfFile );

    CloseHandle( m_hInfFile );
    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_CreateDistributableFile creates a custom NetMeeting distributable incorporating
//  the registry changes that are stored in ms_InfFilePath\ms_InfFileName
//  The szPathName is a path where we are going to create a file called:
//    CNmAkWiz::ms_NetmeetingCustomDistributionFileName;
BOOL CNmAkWiz::_CreateDistributableFile( CFilePanePropWnd2 *pFilePane ) {

        // Get the location of the original distribution
    if( !_GetNetMeetingOriginalDistributionData() ) { return FALSE; }

    TCHAR szNMOriginalDistributableFile[ MAX_PATH ];
    TCHAR szNMCustomDistributableFile[ MAX_PATH ];
    TCHAR szUpdateCommandLine[ MAX_PATH ];

    pFilePane->CreateOutputDir();
	pFilePane->GetPathAndFile( szNMCustomDistributableFile );

    const TCHAR* sz = GetInstallationPath();
    if( NULL != sz ) {
        lstrcpy( szNMOriginalDistributableFile, sz );
        lstrcat( szNMOriginalDistributableFile, TEXT("\\" ) );
        lstrcat( szNMOriginalDistributableFile, ms_NetmeetingSourceDirectory );
        lstrcat( szNMOriginalDistributableFile, TEXT("\\" ) );
        lstrcat( szNMOriginalDistributableFile, ms_NetmeetingOriginalDistributionFileName );
    }

    // Copy source distribution to  custom exe
    SHFILEOPSTRUCT FileOp;
    ZeroMemory( &FileOp, sizeof( FileOp ) );
    FileOp.hwnd     = g_hwndActive;
    FileOp.wFunc    = FO_COPY;
    FileOp.fFlags   = FOF_SIMPLEPROGRESS | FOF_NOCONFIRMATION;

        // Must double-null terminate file names for the struct...
    szNMOriginalDistributableFile[ lstrlen( szNMOriginalDistributableFile ) + 1 ] = '\0';
    szNMCustomDistributableFile[ lstrlen( szNMCustomDistributableFile ) + 1 ] = '\0';

    FileOp.pFrom = szNMOriginalDistributableFile;
    FileOp.pTo = szNMCustomDistributableFile;
    
    TCHAR szProgressTitle[ 256 ];

    LoadString( g_hInstance, 
                IDS_CREATING_CUSTOM_DISTRIBUTION,
                szProgressTitle,
                CCHMAX( szProgressTitle )
              );


    FileOp.lpszProgressTitle = szProgressTitle;
    
    int iRet = SHFileOperation( &FileOp );
    if( 0 != iRet ) { return FALSE; }


    // CreateProcess: updfile nm30.exe MsNetMtg.inf    
    const TCHAR* szInstallationPath = GetInstallationPath();

    wsprintf(szUpdateCommandLine, "\"%s\\%s\\updfile.exe\" \"%s\" \"%s\\%s\"",
        szInstallationPath, ms_ToolsFolder, szNMCustomDistributableFile,
        ms_FileExtractPath, ms_InfFileName);
    OutputDebugString(szUpdateCommandLine);
    OutputDebugString("\n\r");


    PROCESS_INFORMATION ProcInfo;
    STARTUPINFO StartupInfo;

    ZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb          = sizeof( StartupInfo );
    
    
    BOOL bRet = CreateProcess( NULL,
                               szUpdateCommandLine,
                               NULL,
                               NULL,
                               TRUE,
                               DETACHED_PROCESS,
                               NULL,
                               NULL,
                               &StartupInfo,
                               &ProcInfo
                             );

    if( 0 == bRet ) {
        DWORD dwErr;
        if( ERROR_FILE_NOT_FOUND == ( dwErr = GetLastError() ) ) {
            TCHAR szMsg[ 256 ];

            LoadString( g_hInstance, 
                        IDS_COULD_NOT_FIND_THE_TOOL,
                        szMsg,
                        CCHMAX( szMsg )
                      );

            lstrcat( szMsg, TEXT(" \"") );
            lstrcat( szMsg, szInstallationPath );
            lstrcat( szMsg, TEXT("\\") );
            lstrcat( szMsg, ms_ToolsFolder );
            lstrcat( szMsg, TEXT("\\") );
            lstrcat( szMsg, TEXT("updfile.exe\"") );

            NmrkMessageBox(
                        szMsg,
                        MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
                        MB_OK | MB_ICONSTOP
                      );

            NmrkMessageBox(MAKEINTRESOURCE(IDS_REINSTALL_THE_NETMEETING_RESOURCE_KIT_AND_TRY_AGAIN),
                MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
                MB_OK | MB_ICONSTOP);
        }

        return FALSE;
    }

    SetLastError( 0 );

    DWORD   dwRet;
    MSG     msg;

    while (TRUE)
    {
        dwRet = MsgWaitForMultipleObjects(1, &ProcInfo.hThread, FALSE, INFINITE, QS_ALLINPUT);

        // Process is done
        if (dwRet == WAIT_OBJECT_0)
            break;

        // Something went wrong
        if (dwRet != WAIT_OBJECT_0 + 1)
        {
            ErrorMessage();
            assert(0);
            return FALSE;
        }
        
        // GUI stuff
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            if (WaitForSingleObject(ProcInfo.hThread, 0) == WAIT_OBJECT_0)
            {
                // Process is done
                break;
            }
        }
    }


    DWORD dwExitCode;        
    bRet = GetExitCodeProcess( ProcInfo.hProcess, &dwExitCode );
    if (dwExitCode != 0)
    {
		NmrkMessageBox(MAKEINTRESOURCE(IDS_NOT_ENOUGH_SPACE_IN_FINAL),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
					MB_OK | MB_ICONEXCLAMATION
				  );
        return FALSE;
    }

    TCHAR szMsg[ 256 ];

    lstrcpy( szMsg, szNMCustomDistributableFile );

    int len = lstrlen( szMsg );

    LoadString( g_hInstance, 
                IDS_SUCCESSFULLY_CREATED,
                szMsg + len,
                CCHMAX(szMsg) - len
              );

    NmrkMessageBox(szMsg, NULL, MB_OK);
                

    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_CreateFileDistribution
//  We are going to create a file called CNmAkWiz::ms_NetmeetingCustomDistributionFileName in the
//  location specified by the user in the m_DistributionSheet dialog
BOOL CNmAkWiz::_CreateFileDistribution( CFilePanePropWnd2 *pFilePane ) {

    if ( !_CreateDistributableFile( pFilePane ))
    { 
        NmrkMessageBox(MAKEINTRESOURCE(IDS_THERE_WAS_AN_UNEXPECTED_ERROR),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
            MB_OK | MB_ICONSTOP);

        return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_NetMeetingOriginalDistributionIsAtSpecifiedLocationsearches 
//

BOOL CNmAkWiz::_NetMeetingOriginalDistributionIsAtSpecifiedLocation( void ) {

    TCHAR szFileName[ MAX_PATH ];
    const TCHAR* sz = GetInstallationPath();
    if( NULL != sz ) {
        lstrcpy( ms_NetmeetingOriginalDistributionFilePath, sz );
        lstrcat( ms_NetmeetingOriginalDistributionFilePath, TEXT("\\") );
        lstrcat( ms_NetmeetingOriginalDistributionFilePath, ms_NetmeetingSourceDirectory );
        lstrcat( ms_NetmeetingOriginalDistributionFilePath, TEXT("\\") );
    }
    if( MAX_PATH < ( lstrlen( ms_NetmeetingOriginalDistributionFilePath ) + 
                     lstrlen( ms_NetmeetingOriginalDistributionFileName ) + 1 ) 
       ) {
        assert( 0 );
        return FALSE;   // This should not happen becaues the file should have been 
                            // Created in this same program
    }

    lstrcpy( szFileName, ms_NetmeetingOriginalDistributionFilePath );
    lstrcat( szFileName, ms_NetmeetingOriginalDistributionFileName );

    HANDLE hFile = CreateFile( szFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                             );
    if( INVALID_HANDLE_VALUE != hFile ) {
        // The NetMeeting Distribution file was at the specified location...
        CloseHandle( hFile );
        return TRUE;
    }

    return FALSE;

}


//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_GetNetMeetingOriginalDistributionData searches for the NetMeeting original 
//  distribution and if it can't find it, it will ask the user to help
//  return TRUE if the user selected one, and FALSE if the user wants to quit

BOOL CNmAkWiz::_GetNetMeetingOriginalDistributionData( void )
{
        // We have to get the file path from the user
    OPENFILENAME OpenFileName;
    while( !_NetMeetingOriginalDistributionIsAtSpecifiedLocation() )
    {
        NmrkMessageBox(MAKEINTRESOURCE(IDS_CANT_FIND_NETMEETING_ORIGINAL_DISTRIBUTION),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
                MB_OK | MB_ICONEXCLAMATION);

        ZeroMemory( &OpenFileName, sizeof( OpenFileName ) );
        OpenFileName.lStructSize = sizeof( OpenFileName );
        OpenFileName.hwndOwner = g_hwndActive;
        OpenFileName.lpstrFile = ms_NetmeetingOriginalDistributionFileName;
        OpenFileName.nMaxFile = MAX_PATH;
        OpenFileName.Flags = OFN_PATHMUSTEXIST;

        if( GetOpenFileName( &OpenFileName ) ) {
            lstrcpy( ms_NetmeetingOriginalDistributionFilePath, "" );
        }
        else {
            // This means that the user wants to cancel
            if( IDCANCEL == NmrkMessageBox(
                MAKEINTRESOURCE(IDS_CANT_FIND_NETMEETING_ORIGINAL_DISTRIBUTION_QUERY_ABORT),
                MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
                                        MB_OKCANCEL | MB_ICONEXCLAMATION
                                      ) ) {
                exit( 0 );
            }

        }
    }
    return TRUE; 
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_DeleteFiles deletes the Temp files that we have been using...
BOOL CNmAkWiz::_DeleteFiles( void ) {

    TCHAR szProgressTitle[ 256 ];

    LoadString( g_hInstance, 
                IDS_DELETING_TEMPORARY_FILES_PROGRESS_TITLE,
                szProgressTitle,
                CCHMAX( szProgressTitle )
              );


    TCHAR szOutputDirectoryPath[ MAX_PATH ];

    lstrcpy( szOutputDirectoryPath, ms_FileExtractPath );
    lstrcat( szOutputDirectoryPath, TEXT("\\*.*") );
        // Must double NULL terminate this!
    szOutputDirectoryPath[ lstrlen( szOutputDirectoryPath ) + 1 ] = '\0';

    int iRet = rmdir( ms_FileExtractPath );
    if( ( -1 == iRet ) && ( ENOENT != errno ) ) {
        
        SHFILEOPSTRUCT FileOp;
        ZeroMemory( &FileOp, sizeof( FileOp ) );
        FileOp.hwnd     = g_hwndActive;
        FileOp.wFunc    = FO_DELETE;
        FileOp.fFlags   = FOF_SIMPLEPROGRESS | FOF_NOCONFIRMATION;
        FileOp.pFrom    = szOutputDirectoryPath;
        FileOp.lpszProgressTitle = szProgressTitle;
    
        iRet = SHFileOperation( &FileOp );
        iRet = rmdir( ms_FileExtractPath );
    }
   

    return TRUE;

}

BOOL CNmAkWiz::_SetPathNames( void ) {

    GetTempPath( MAX_PATH, ms_FileExtractPath );
    lstrcat( ms_FileExtractPath, ms_NMRK_TMP_FolderName );
    OutputDebugString( "ms_FileExtractPath = " );
    OutputDebugString( ms_FileExtractPath );
    OutputDebugString( "\r\n" );
    return TRUE;
}


const TCHAR* GetInstallationPath( void ) {

    static TCHAR szPath[ MAX_PATH ];
    
    HKEY hKey;
    long lRet = RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_NMRK, &hKey );
    if( ERROR_SUCCESS != lRet ) { return NULL; }
    
    DWORD cb = MAX_PATH;
    DWORD dwType = REG_SZ;
    if( ERROR_SUCCESS != RegQueryValueEx( hKey, 
                                          REGVAL_INSTALLATIONDIRECTORY, 
                                          NULL,
                                          &dwType,
                                          reinterpret_cast< LPBYTE >( szPath ), 
                                          &cb ) ) {
        ErrorMessage();
        if( ERROR_SUCCESS != RegCloseKey( hKey ) ) {
            ErrorMessage();
        }
        return NULL;
    }

    if( ERROR_SUCCESS != RegCloseKey( hKey ) ) {
        ErrorMessage();
    }
    return szPath;

}



BOOL CNmAkWiz::_CreateNewInfFile( void ) {

    // Load MsNetMtg.inf into memory
    TCHAR szInfFilePath[ MAX_PATH ];
    TCHAR szBuf[ MAX_PATH ];
    TCHAR* pOriginalInfFileData;
    TCHAR* pOriginalInfFileDataCursor;
    TCHAR* pCursor;
    DWORD dwSize;
    DWORD cbWritten;

    lstrcpy( szInfFilePath, ms_FileExtractPath );
    lstrcat( szInfFilePath, TEXT("\\") );
    lstrcat( szInfFilePath, ms_InfFileName );

    m_hInfFile = CreateFile( szInfFilePath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                           );

    if( INVALID_HANDLE_VALUE == m_hInfFile ) { goto ExitError; }

    DWORD dwFileSizeHigh;
    dwSize = GetFileSize( m_hInfFile, &dwFileSizeHigh );

    pOriginalInfFileData = new TCHAR[ dwSize ];
    pOriginalInfFileDataCursor = pOriginalInfFileData;

    DWORD cbRead;
    if( 0 == ReadFile( m_hInfFile, pOriginalInfFileData, dwSize, &cbRead, NULL ) ) {
        goto ExitError;
    }
    if( cbRead != dwSize ) { goto ExitError; }

    // Close MsNetMtg.inf file
    CloseHandle( m_hInfFile );

    
        // Open MsNetMtg.inf for writing ( overwrite existing )
    m_hInfFile = CreateFile( szInfFilePath,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                           );

    if( INVALID_HANDLE_VALUE == m_hInfFile ) { goto ExitError; }

        // Set cursor to [DefaultInstall] string
    pCursor = strstr( pOriginalInfFileDataCursor, TEXT("[DefaultInstall]") );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to next "AddReg"
    pCursor = strstr( pCursor, TEXT("AddReg") );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to the end of the line
    pCursor = strstr( pCursor, TEXT("\r") );
    if( NULL == pCursor ) { goto ExitError; }

        // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }

        // Write ",NetMtg.Install.Reg.NMRK" to INF
    lstrcpy( szBuf, ",NetMtg.Install.Reg.NMRK" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

        // Set cursor to next "DelReg"
    pCursor = strstr( pCursor, "DelReg" );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to the end of the line
    pCursor = strstr( pCursor, "\r" );
    if( NULL == pCursor ) { goto ExitError; }

        // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

        // Write ",NetMtg.Install.DeleteReg.NMRK" to INF
    lstrcpy( szBuf, ",NetMtg.Install.DeleteReg.NMRK" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }


        // Set cursor to [DefaultInstall.NT] string
    pCursor = strstr( pOriginalInfFileDataCursor, "[DefaultInstall.NT]" );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to next "AddReg"
    pCursor = strstr( pCursor, "AddReg" );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to the end of the line
    pCursor = strstr( pCursor, "\r" );
    if( NULL == pCursor ) { goto ExitError; }

        // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }

        // Write ",NetMtg.Install.Reg.NMRK" to INF
    lstrcpy( szBuf, ",NetMtg.Install.Reg.NMRK" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

        // Set cursor to next "DelReg"
    pCursor = strstr( pCursor, "DelReg" );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to the end of the line
    pCursor = strstr( pCursor, "\r" );
    if( NULL == pCursor ) { goto ExitError; }

        // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

        // Write ",NetMtg.Install.DeleteReg.NMRK" to INF
    lstrcpy( szBuf, ",NetMtg.Install.DeleteReg.NMRK" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

    //
    // Now we have to yank the old Ils stuff...
    //


    // Set cursor to [NetMtg.Install.Reg.PerUser] string
    pCursor = strstr( pCursor, "[NetMtg.Install.Reg.PerUser]" );
    if( NULL == pCursor ) { goto ExitError; }

    // Skip to the start of the next line
    pCursor = strstr( pCursor, "\n" ); // This is the last TCHARacter on the line
    pCursor++; // This will be the first TCHARacter on the line

    // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;
    
    // skip white space
    while( isspace( *pCursor ) ) { pCursor++; }

    // While the cursor is not '['
    while( *pCursor != '[' ) {
        // if current line starts with 
        if( ( pCursor == strstr( pCursor, "HKCU,\"%KEY_CONFERENCING%\\UI\\Directory\",\"Name" ) ) ||
            ( pCursor == strstr( pCursor, "HKCU,\"%KEY_CONFERENCING%\\UI\\Directory\",\"Count" ) ) ) {
            // Delete the line by incrementing the base cursor to the beginning of the next line
            pCursor = strstr( pCursor, "\n" );
            pCursor++;
        }
        else {
            break;
        }
    }

    // Set pOriginalInfFileDataCursor to cursor ( thus skipping the old Ils stuff )
    pOriginalInfFileDataCursor = pCursor;

        // Set Cursor to [Strings] string
    pCursor = strstr( pCursor, "[Strings]" );
    if( NULL == pCursor ) { goto ExitError; }

    // Write original data to the cursor
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

    // Write string [NetMtg.Install.Reg.NMRK]\n
    lstrcpy( szBuf, "\r\n\r\n[NetMtg.Install.Reg.NMRK]\r\n\r\n" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

    // Write the REG Keys
    _StoreDialogData( m_hInfFile );

    // Write string [NetMtg.Install.DeleteReg.NMRK]\n
    lstrcpy( szBuf, "\r\n\r\n[NetMtg.Install.DeleteReg.NMRK]\r\n\r\n" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

    // Write the REG Delete Keys
    CPolicyData::FlushCachedInfData( m_hInfFile );

    // this is needed...
    lstrcpy( szBuf, "\r\n\r\n" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }



    // Write the rest of the Original File to the INF
    pCursor = pOriginalInfFileData + dwSize;
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }

    CloseHandle( m_hInfFile );
    m_hInfFile = INVALID_HANDLE_VALUE;
    delete [] pOriginalInfFileData;

    return TRUE;

    ExitError:
        assert( 0 );
        if( INVALID_HANDLE_VALUE != INVALID_HANDLE_VALUE ) {         
            CloseHandle( m_hInfFile );
        }

        delete [] pOriginalInfFileData;

        return FALSE;
}



BOOL CNmAkWiz::_ExtractOldNmCabFile( void ) {

    TCHAR szCabPath[ MAX_PATH ];
    TCHAR szOutputDirectoryPath[ MAX_PATH ];
    TCHAR szCommandLine[ MAX_PATH ];

        // Clean up in case we abnormally terminated before...
    _DeleteFiles();

        // Create the temp folder
    mkdir( ms_FileExtractPath );


    const TCHAR* szInstallationPath = GetInstallationPath();

    if( NULL != szInstallationPath ) {
        lstrcpy( szCabPath, "\"" );
        lstrcat( szCabPath, szInstallationPath );
        lstrcat( szCabPath, "\\" );
        lstrcat( szCabPath, ms_NetmeetingSourceDirectory );
        lstrcat( szCabPath, "\\" );
        lstrcat( szCabPath, ms_NetmeetingOriginalDistributionFileName );
        lstrcat( szCabPath, "\" " );
    }
    else {
        assert( 0 );          
        lstrcat( szCabPath, ms_InfFileName );
    }

    

    lstrcpy( szOutputDirectoryPath, ms_FileExtractPath );

    lstrcpy( szCommandLine, "/C /T:\"" );
    lstrcat( szCommandLine, szOutputDirectoryPath );
    lstrcat( szCommandLine, "\" /Q" );

    PROCESS_INFORMATION ProcInfo;
    STARTUPINFO StartupInfo;
    ZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );

    lstrcat( szCabPath, szCommandLine );
    OutputDebugString( szCabPath );
    OutputDebugString( "\n" );
    BOOL iRet = CreateProcess( NULL,
                               szCabPath,
                               NULL,
                               NULL,
                               FALSE,
                               0,
                               NULL,
                               NULL,
                               &StartupInfo,
                               &ProcInfo
                             );
    
    if( FALSE == iRet ) {
        ErrorMessage();
        assert( 0 );                
        return FALSE;
    }

    SetLastError( 0 );

    DWORD   dwRet;
    MSG     msg;

    while (TRUE)
    {
        dwRet = MsgWaitForMultipleObjects(1, &ProcInfo.hThread, FALSE, INFINITE, QS_ALLINPUT);

        // Process is done
        if (dwRet == WAIT_OBJECT_0)
            break;

        // Something went wrong
        if (dwRet != WAIT_OBJECT_0 + 1)
        {
            ErrorMessage();
            assert(0);
            return FALSE;
        }
        
        // GUI stuff
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            if (WaitForSingleObject(ProcInfo.hThread, 0) == WAIT_OBJECT_0)
            {
                // Process is done
                break;
            }
        }
    }

    DWORD dwExitCode;        
    BOOL bRet = GetExitCodeProcess( ProcInfo.hProcess, &dwExitCode );

    // dwExitCode 0 is success
    
    if (dwExitCode != 0)
    {
		NmrkMessageBox(MAKEINTRESOURCE(IDS_NOT_ENOUGH_SPACE_IN_TEMP_DIR),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
					MB_OK | MB_ICONEXCLAMATION
				  );
        return FALSE;
    }

    return TRUE;
}




//
// NmrkMessageBox()
//
// Puts up a message box owned by the wizard
//
int NmrkMessageBox
(
    LPCSTR  lpszText,
    LPCSTR  lpszCaption,
    UINT    uType,
	HWND	hwndParent
)
{
    MSGBOXPARAMS    mbp;

    ZeroMemory(&mbp, sizeof(mbp));
    mbp.cbSize      = sizeof(mbp);

    mbp.hwndOwner   = NULL == hwndParent ? g_hwndActive : hwndParent;
    mbp.hInstance   = g_hInstance;
    mbp.lpszText    = lpszText;
    if (!lpszCaption)
        mbp.lpszCaption = MAKEINTRESOURCE(IDS_MSG_CAPTION);
    else
        mbp.lpszCaption = lpszCaption;
    mbp.dwStyle     = uType | MB_SETFOREGROUND;

    return(MessageBoxIndirect(&mbp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\poldata.cpp ===
#include "precomp.h"
#include "global.h"
#include "PolData.h"

/* static */ void CPolicyData::FlushCachedInfData( HANDLE hFile ) {
    std::list< std::string >::iterator I = ms_CachedInfData . begin();
    DWORD cbWritten;
    while( I != ms_CachedInfData . end() ) {
        if( !WriteFile( hFile, ( *I ) . c_str(), lstrlen( ( *I ) . c_str() ), &cbWritten, NULL ) ) {
            assert( 0 );
            ErrorMessage();
            return;
        }
        I++;
    }

    ms_CachedInfData . erase( ms_CachedInfData . begin(), ms_CachedInfData . end() );

}
/* static */ std::list< std::string > CPolicyData::ms_CachedInfData;


CPolicyData::CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, DWORD dwVal ) {
    
    m_KeyType = KeyType;
    m_ValueType = ValueType_DWORD;
    m_dwVal     = dwVal;
    
    m_szKeyName = MakeCopyOfString( szKeyName );
    m_szValueName = MakeCopyOfString( szValueName );

}


CPolicyData::CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, const char* szVal ) {

    m_KeyType = KeyType;
    m_ValueType = ValueType_String;
    m_szVal     = MakeCopyOfString( szVal );
    
    m_szKeyName = MakeCopyOfString( szKeyName );
    m_szValueName = MakeCopyOfString( szValueName );

}

CPolicyData::CPolicyData( eValueType ValType, eKeyType KeyType, const char* szKeyName, const char* szValueName, const char* szVal ) {

    m_KeyType   = KeyType;
    m_ValueType = ValType;
    m_szVal     = MakeCopyOfString( szVal );
    
    m_szKeyName = MakeCopyOfString( szKeyName );
    m_szValueName = MakeCopyOfString( szValueName );

}


CPolicyData::CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, const OpDelete& r ) {

    m_KeyType = KeyType;
    m_ValueType = ValueType_Delete;
    
    m_szKeyName = MakeCopyOfString( szKeyName );
    m_szValueName = MakeCopyOfString( szValueName );

}

CPolicyData::CPolicyData( const CPolicyData& r ) 
: m_ValueType ( ValueType_NotInitialized )
{ *this = r; }

CPolicyData::~CPolicyData( void ) {
    _KillHeapData();
}


CPolicyData& CPolicyData::operator=( const CPolicyData& r )
{
    _KillHeapData();
    
    m_KeyType = r . m_KeyType;

    switch( m_ValueType = r . m_ValueType )
    {
        case ValueType_BinaryAsString:
        case ValueType_String:
            m_szVal = MakeCopyOfString( r . m_szVal );
            break;

        case ValueType_DWORD:
            m_dwVal = r.m_dwVal;
            break;

    }

    m_szKeyName = MakeCopyOfString( r . m_szKeyName );        
    m_szValueName = MakeCopyOfString( r . m_szValueName );        

    return *this;
}

#define KEYSIZE 1000

BOOL CPolicyData::SaveToINFFile( HANDLE hFile ) {

    DWORD cbWritten;
    static char szLastKey[ KEYSIZE ] = "";    
    

    // We have to save the key name first
    char szKey[ KEYSIZE ];
    switch( m_KeyType ) {
        case eKeyType_HKEY_CURRENT_USER:
            strcpy( szKey, "HKCU," );
            break;

        case eKeyType_HKEY_LOCAL_MACHINE:
            strcpy( szKey, "HKLM," );
            break;

        default:
            assert( 0 );
            break;

    }
    strcat( szKey, "\"" );
    strcat( szKey, m_szKeyName );
    strcat( szKey, "\",\""  );
    strcat( szKey, m_szValueName );
    strcat( szKey, "\""  );
    
    switch( m_ValueType ) {

        case ValueType_String:
            // 0 is FLG_ADDREG_TYPE_SZ
            strcat( szKey, ",0,\"" );
            if( NULL == m_szVal ) {
                strcat( szKey, "" );
            }
            else {
                strcat( szKey, m_szVal );
            }
            strcat( szKey, "\"" );
            break;

        case ValueType_DWORD:
            // 1 is FLG_ADDREG_TYPE_BINARY
            // NOTE that DWORDs are 4 byte BINARY values.  This works on
            // all platforms.  The later FLG_ADDREG_TYPE_DWORD isn't
            // supported on Win95.
            strcat( szKey, ",1," );
            sprintf( szKey + lstrlen( szKey ), "%x, %x, %x, %x", 
                            LOBYTE( LOWORD( m_dwVal ) ), 
                            HIBYTE( LOWORD( m_dwVal ) ),
                            LOBYTE( HIWORD( m_dwVal ) ), 
                            HIBYTE( HIWORD( m_dwVal ) ));
            break;

        case ValueType_BinaryAsString:
            // 1 is FLG_ADDREG_TYPE_BINARY
            strcat( szKey, ",1," );
            strcat( szKey, m_szVal );
            break;

        case ValueType_Delete:
            strcat( szKey, "\r\n" );
            ms_CachedInfData . push_back( szKey );
            return TRUE;

        default:
            assert( 0 );
            break;

    }
        
    strcat( szKey, "\r\n" );

    RETFAIL( WriteFile( hFile, szKey, lstrlen( szKey ), &cbWritten, NULL ) );

    return TRUE;


}


// This will break if the following occurs:
   // Same key name as the last call in this process
   // but a new file....
BOOL CPolicyData::SaveToREGFile( HANDLE hFile ) {

    DWORD cbWritten;
    static char szLastKey[ KEYSIZE ] = "";    
    

    // We have to save the key name first
    char szKey[ KEYSIZE ];
    strcpy( szKey, "[" );
    switch( m_KeyType ) {
        case eKeyType_HKEY_CURRENT_USER:
            strcat( szKey, "HKEY_CURRENT_USER\\" );
            break;

        case eKeyType_HKEY_LOCAL_MACHINE:
            strcat( szKey, "HKEY_LOCAL_MACHINE\\" );
            break;

        default:
            assert( 0 );
            break;

    }

    strcat( szKey, m_szKeyName );
    strcat( szKey, "]\n" );

    if( strcmp( szLastKey, szKey ) ) {
        // We hawe to save the key first if it is different
        // From the last one 
        RETFAIL( WriteFile( hFile, szKey, lstrlen( szKey ), &cbWritten, NULL ) );
        strcpy( szLastKey, szKey );    
    }

    
    char szVal[ KEYSIZE ];
    strcpy( szVal, "\"" );
    strcat( szVal, m_szValueName );
    strcat( szVal, "\"=" );
    
    switch( m_ValueType ) {
        case ValueType_String:
            if( NULL == m_szVal ) {
                strcat( szVal, "\"\"\n" );
            }
            else {
                strcat( szVal, "\"" );
                strcat( szVal, m_szVal );
                strcat( szVal, "\"\n" );

            }
            break;

        case ValueType_DWORD:
            strcat( szVal, "dword:" );
            sprintf( szVal + lstrlen( szVal ), "%x", m_dwVal );
            strcat( szVal, "\n" );
            break;

        case ValueType_BinaryAsString:
            strcat( szVal, "hex:" );
            strcat( szVal, m_szVal );
            strcat( szVal, "\n" );
            break;

        case ValueType_Delete:
            strcat( szVal, "-\n" );
            break;

        default:
            assert( 0 );
            break;

    }
        
    RETFAIL( WriteFile( hFile, szVal, lstrlen( szVal ), &cbWritten, NULL ) );  

    return TRUE;
}

void CPolicyData::_KillHeapData( void ) {
    
    if( ( ValueType_String == m_ValueType ) || ( ValueType_BinaryAsString == m_ValueType ) ) {
        delete [] m_szVal;
        m_szVal = NULL;
        m_ValueType = ValueType_NotInitialized;
    }

    delete [] m_szKeyName;
    m_szKeyName = NULL;
    delete m_szValueName;
    m_szValueName = NULL;
        


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\poldata.h ===
#ifndef __PolData_h__
#define __PolData_h__

////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4786 )
#include <string>
#include <list>
////////////////////////////////////////////////////////////////////////////////////////////////////


class CPolicyData {

public: // Static Fns
    static void FlushCachedInfData( HANDLE hFile );

private:// Static Fns
    static std::list< std::string > ms_CachedInfData;

public: // Datatypes
    enum eValueType {
                      ValueType_BinaryAsString,
                      ValueType_String,
                      ValueType_DWORD,  
                      ValueType_Delete,  // This will delete the value name entry in the registry
                      ValueType_NotInitialized
                    };

public:
    enum eKeyType { eKeyType_HKEY_CURRENT_USER,
                    eKeyType_HKEY_LOCAL_MACHINE,
                    eKeyType_INVALID
                  };
                

    class OpDelete { ; }; // Symbol class to signify deleting a registry value entry
    
private: // Data
    eKeyType    m_KeyType;
    char        *m_szKeyName;
    char        *m_szValueName;

    eValueType  m_ValueType;

    union {
        char*   m_szVal;
        DWORD   m_dwVal;
    };
        
public: // Construction / destruction
    CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, DWORD dwVal );
    CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, const char* szVal );
    CPolicyData( eValueType ValType, eKeyType KeyType, const char* szKeyName, const char* szValueName, const char* szVal );
    CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, const OpDelete& r );
    CPolicyData( const CPolicyData& r );
    ~CPolicyData( void );

public: // Member Fns

    CPolicyData& operator=( const CPolicyData& r );

    BOOL SaveToREGFile( HANDLE hFile );
    BOOL SaveToINFFile( HANDLE hFile );

private: // Helper Fns
    void _KillHeapData( void );

private: // Unused, declared to make sure compiler does not make a default and mess us up...
    CPolicyData( void );


};


#endif // __PolData_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\precomp.h ===
#ifndef __Precomp_h_
#define __Precomp_h_

#define OEMRESOURCE
#pragma warning( disable : 4786 )

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <dlgs.h>
#include <shellapi.h>
#include <prsht.h>
#include <assert.h>
#include <limits.h>
#include <tchar.h>
#include <shlobj.h>
#include "Util.h"

//#include "resource.h"
extern HINSTANCE    g_hInstance;
extern HWND         g_hwndActive;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\proppg.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// NOTE: THIS HAS NOT BEEN THROUGHLY TESTED. IT IS A SIMPLE CLASS, AND BUGS SHOULD 
//      PRESENT THEMSELVES THROUGH USAGE. THE BUGS SHOULD BE SIMPLE TO FIX. 

////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Files
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PropPg.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Construction, Destruction, and Initialization funcs
////////////////////////////////////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage

CPropertySheetPage::CPropertySheetPage( void ) {
	_InitData();
}



//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( const CPropertySheetPage& r ) {
	_InitData();
	*this = r;
}



//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
// pszTemplate can specify either the resource identifier of the template 
// or the address of a string that specifies the name of the template
CPropertySheetPage::CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
										DWORD dwFlags /* = 0 */,  LPARAM lParam /* = 0L */  ) {

	_InitData();

	this -> dwFlags = dwFlags;
	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pszTemplate( pszTemplate ) )		{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Validate() )							{ return; }
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc,
										DWORD dwFlags /* = 0 */,  LPARAM lParam /* = 0L */  ) {

	_InitData();
	this -> dwFlags = dwFlags;
	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pResource( pResource ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Validate() )							{ return; }

}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
// pszTemplate can specify either the resource identifier of the template 
// or the address of a string that specifies the name of the template
CPropertySheetPage::CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
										HICON hIcon, /* = NULL */ LPCTSTR pszTitle /* = NULL */,  DWORD dwFlags, /* = 0 */
										LPARAM lParam /* =NULL */, LPFNPSPCALLBACK pfnCallBack, /* =NULL */
										UINT FAR * pcRefParent /* =NULL */
										) {
	_InitData();
	this -> dwFlags = dwFlags;

	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pszTemplate( pszTemplate ) )		{ return; }
	if( ! _Set_hIcon( hIcon ) )					{ return; }
	if( ! _Set_pszTitle( pszTitle ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Set_pfnCallback( pfnCallBack ) )		{ return; }
	if( ! _Set_pcRefParent( pcRefParent ) )		{ return; }
	if( ! _Validate() )							{ return; }

}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc, 
										HICON hIcon, /* = NULL */ LPCTSTR pszTitle /* = NULL */, DWORD dwFlags, /* = 0 */
										LPARAM lParam /* =NULL */, LPFNPSPCALLBACK pfnCallBack,/* =NULL */
										UINT FAR * pcRefParent /* =NULL */
										) {

	_InitData();
	this -> dwFlags = dwFlags;

	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pResource( pResource ) )			{ return; }
	if( ! _Set_hIcon( hIcon ) )					{ return; }
	if( ! _Set_pszTitle( pszTitle ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Set_pfnCallback( pfnCallBack ) )		{ return; }
	if( ! _Set_pcRefParent( pcRefParent ) )		{ return; }
	if( ! _Validate() )							{ return; }


}

//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
										LPCTSTR pszIcon /* =0 */, LPCTSTR pszTitle /* = NULL */, DWORD dwFlags, /* = 0 */
										LPARAM lParam /* =NULL */, LPFNPSPCALLBACK pfnCallBack, /* =NULL */
										UINT FAR * pcRefParent /* =NULL */
										) {
	_InitData();
	this -> dwFlags = dwFlags;

	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pszTemplate( pszTemplate ) )		{ return; }
	if( ! _Set_pszIcon( pszIcon ) )				{ return; }
	if( ! _Set_pszTitle( pszTitle ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Set_pfnCallback( pfnCallBack ) )		{ return; }
	if( ! _Set_pcRefParent( pcRefParent ) )		{ return; }
	if( ! _Validate() )							{ return; }


}

//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc, 
										LPCTSTR pszIcon /* =0 */, LPCTSTR pszTitle /* = NULL */, DWORD dwFlags, /* = 0 */
										LPARAM lParam /* =NULL */, LPFNPSPCALLBACK pfnCallBack, /* =NULL */ 
										UINT FAR * pcRefParent /* =NULL */
										) {

	_InitData();
	this -> dwFlags = dwFlags;

	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pResource( pResource ) )			{ return; }
	if( ! _Set_pszIcon( pszIcon ) )				{ return; }
	if( ! _Set_pszTitle( pszTitle ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Set_pfnCallback( pfnCallBack ) )		{ return; }
	if( ! _Set_pcRefParent( pcRefParent ) )		{ return; }
	if( ! _Validate() )							{ return; }
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCPROPSHEETPAGE pPageVector ) {

    memcpy( this, pPageVector, sizeof( PROPSHEETPAGE ) );
	_Validate();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::~CPropertySheetPage
CPropertySheetPage::~CPropertySheetPage( void ) {

}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Public Member Fns
////////////////////////////////////////////////////////////////////////////////////////////////////



//--------------------------------------------------------------------------------------------------
// operator= assigns *this to another CPropertySheetPage
// Because there are no pointers or references in the PROPSHEETPAGE structure, the contents may 
// simply be memory copied

CPropertySheetPage& CPropertySheetPage::operator=( const CPropertySheetPage& r ) {
	
	LPCPROPSHEETPAGE pcSrc = static_cast< LPCPROPSHEETPAGE >( &r );
	LPPROPSHEETPAGE pDst = static_cast< LPPROPSHEETPAGE >( this );

	memcpy( pDst, pcSrc, sizeof( PROPSHEETPAGE ) );

	return *this;
}





////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Helper Fns
////////////////////////////////////////////////////////////////////////////////////////////////////


void CPropertySheetPage::_InitData( void ) {
	ZeroMemory( this, sizeof( PROPSHEETPAGE ) );
	this -> dwSize = sizeof( PROPSHEETPAGE );
	this -> dwFlags |= PSP_DEFAULT;
}
			
//--------------------------------------------------------------------------------------------------
// _IsRightToLeftLocale is called to determine the value of one of the flags in the PROPSHEETPAGE
// datastructure.  If this is to be a robust and complete wrapper class, this should be implemented

BOOL CPropertySheetPage::_IsRightToLeftLocale( void ) const {
	// BUGBUG
	// this is not implemented, and it may not act properly when implemented, 
	// Look at the the usage as well
	return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Data Setting and validation funcs
////////////////////////////////////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------------------------------------
// _Set_hInstance

BOOL CPropertySheetPage::_Set_hInstance( HINSTANCE hInst ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( NULL == hInst ) { assert( 0 ); return FALSE; }

#endif // CPropertySheetPage_ValidateParameters

	this -> hInstance = hInst;

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pszTemplate

BOOL CPropertySheetPage::_Set_pszTemplate( LPCTSTR pszTemplate ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( NULL == pszTemplate ) { assert( 0 ); return FALSE; }
	if( this -> dwFlags & PSP_DLGINDIRECT ) { // If the PSP_DLGINDIRECT is set, pszTemplate is ignored
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	this -> pszTemplate = pszTemplate;
	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pResource

BOOL CPropertySheetPage::_Set_pResource( LPCDLGTEMPLATE pResource ) {

#ifdef CPropertySheetPage_ValidateParameters
	
	if( NULL == pResource ) { assert( 0 ); return FALSE; }

#endif // CPropertySheetPage_ValidateParameters

	this -> pResource = pResource;
	this -> dwFlags |= PSP_DLGINDIRECT;
	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_hIcon

BOOL CPropertySheetPage::_Set_hIcon( HICON hIcon ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == hIcon ) && ( dwFlags & PSP_USEHICON ) ) { assert( 0 ); return FALSE; }
	if ( dwFlags & PSP_USEICONID ) { assert( 0 ); return FALSE; }

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != hIcon ) {
		this -> dwFlags |= PSP_USEHICON;
		this -> hIcon = hIcon;
	}
	
	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pszIcon

BOOL CPropertySheetPage::_Set_pszIcon( LPCTSTR pszIcon ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == pszIcon ) && ( dwFlags & PSP_USEICONID  ) ) { // This is a bad parameter
		assert( 0 );
		return FALSE;
	}

	if ( dwFlags & PSP_USEHICON ) {	// Wrong function signature, use the one that takes LPCTSTR pszIcon /* =0 */
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != pszIcon ) {
		this -> pszIcon = pszIcon;
		this -> dwFlags |= PSP_USEICONID;
	}

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pszTitle

BOOL CPropertySheetPage::_Set_pszTitle( LPCTSTR pszTitle ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == pszTitle ) && ( dwFlags & PSP_USETITLE ) ) { // This is a bad parameter
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != pszTitle ) {
		this -> pszTitle = pszTitle;
		this -> dwFlags |= PSP_USETITLE;
	}

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pfnDlgProc


BOOL CPropertySheetPage::_Set_pfnDlgProc( DLGPROC pfnDlgProc ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( NULL == pfnDlgProc ) { assert( 0 ); return FALSE; }
#endif // CPropertySheetPage_ValidateParameters

	this -> pfnDlgProc = pfnDlgProc;
	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pfnCallback


BOOL CPropertySheetPage::_Set_pfnCallback( LPFNPSPCALLBACK pfnCallBack ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == pfnCallBack ) && ( dwFlags & PSP_USECALLBACK ) ) {	// This is a bad parameter
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != pfnCallback ) {
		this -> pfnCallback = pfnCallback;
		this -> dwFlags |= PSP_USECALLBACK;
	}

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pcRefParent


BOOL CPropertySheetPage::_Set_pcRefParent( UINT FAR * pcRefParent ) {


#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == pcRefParent ) && ( dwFlags & PSP_USEREFPARENT ) ) {	// This is a bad parameter
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != pcRefParent ) {
		this -> pcRefParent = pcRefParent;
		this -> dwFlags |= PSP_USEREFPARENT;
	}

	return TRUE;

}

//--------------------------------------------------------------------------------------------------
// _Set_lParam


BOOL CPropertySheetPage::_Set_lParam( LPARAM lParam ) {

#ifdef CPropertySheetPage_ValidateParameters

#endif // CPropertySheetPage_ValidateParameters

	this -> lParam = lParam;

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Validate


BOOL CPropertySheetPage::_Validate( void ) const {

#ifdef CPropertySheetPage_ValidateParameters

	// Make sure there are no mutually exclusize flags set

	if( ( this -> dwFlags & PSP_USEICONID ) && ( this -> dwFlags & PSP_USEHICON ) ) {
		assert( 0 );
		return FALSE;
	}

	// Make sure that the data is valid ( for set flags )
	if( this -> dwFlags & PSP_DLGINDIRECT ) { // We must validate pResource
		if( NULL == pResource ) {
			assert( 0 );
			return FALSE;
		}
	}
	else { // We must validate pszTemplate 
		if( NULL == this -> pszTemplate ) {
			assert( 0 );
			return FALSE;
		}
	}

	if( this -> dwFlags & PSP_USECALLBACK ) {
		if( NULL == this -> pfnCallback ) {
			assert( 0 );
			return FALSE;
		}
	}

	if( this -> dwFlags & PSP_USEREFPARENT ) {
		if( NULL == this -> pcRefParent ) {
			assert( 0 );
			return FALSE;
		}
	}
	if( this -> dwFlags & PSP_USETITLE ) {
		if( NULL == this -> pszTitle ) {
			assert( 0 );
			return FALSE;
		}
	}
 
#endif // CPropertySheetPage_ValidateParameters

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\proppg.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// CPropertySheetPage is a small wrapper around the PROPSHEETPAGE structure.  
// The class mostly does parameter validation.  
//
// This is an example of how it can be used...
//
//
// CPropertySheetPage MyPropertySheetPage( 
//                                         MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
//                                         ( DLGPROC ) MyDlgProc, 
//                                         PSP_HASHELP   
//                                       );
//      
//
// The casting operators are defined to cast a CPropertySheetPage to a LPPROPSHEETPAGE, which is
//      useful for assigning to the elements in a PROPSHEETHEADER
//
//
//  PROPSHEETHEADER Psh;
//  LPPROPSHEETPAGE pPageAry;
//  extern PROPSHEETPAGE OtherPage;        
//
//  pPageAry = new PROPSHEETPAGE[ 2 ]
//  
//
//      pPageAry[ 0 ] = MyPropertySheetPage;
//      pPageAry[ 0 ] = OtherPage;
//
//      Psh . ppsp = pPageAry;
//
//
//
//
// NOTE: this is the signature for the callback function, if specified:
//
// UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA FAR *ppsp);
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////


#ifndef __PropPg_h__
#define __PropPg_h__


////////////////////////////////////////////////////////////////////////////////////////////////////
//  comment this out if you don't want data validation ( class essentially does nothing )
//
#define CPropertySheetPage_ValidateParameters
////////////////////////////////////////////////////////////////////////////////////////////////////

class CPropertySheetPage : public PROPSHEETPAGE {

public: // Construction / destruction
	CPropertySheetPage( void );	 // So We can make an Array of these things

	CPropertySheetPage( const CPropertySheetPage& r );

        // pssTemplate can specify either the resource identifier of the template 
        // or the address of a string that specifies the name of the template
	CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
						DWORD dwFlags = 0, LPARAM lParam = 0L 
					  );

	CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc,
						DWORD dwFlags = 0, LPARAM lParam = 0L  
					  );

        // psTemplate can specify either the resource identifier of the template 
        // or the address of a string that specifies the name of the template
	CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
						HICON hIcon, LPCTSTR pszTitle = NULL,  DWORD dwFlags = 0,
						LPARAM lParam = NULL, LPFNPSPCALLBACK pfnCallBack = NULL, 
						UINT FAR * pcRefParent = NULL
					  );

	CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc, 
						HICON hIcon, LPCTSTR pszTitle = NULL, DWORD dwFlags = 0,
						LPARAM lParam = NULL, LPFNPSPCALLBACK pfnCallBack = NULL, 
						UINT FAR * pcRefParent = NULL
					  );

        // pszTemplate can specify either the resource identifier of the template 
        // or the address of a string that specifies the name of the template
	CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc,
						LPCTSTR pszIcon, LPCTSTR pszTitle = NULL, DWORD dwFlags = 0,
						LPARAM lParam = NULL, LPFNPSPCALLBACK pfnCallBack = NULL, 
						UINT FAR * pcRefParent = NULL
					  );

	CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc,
						LPCTSTR pszIcon, LPCTSTR pszTitle = NULL, DWORD dwFlags = 0,
						LPARAM lParam = NULL, LPFNPSPCALLBACK pfnCallBack = NULL, 
						UINT FAR * pcRefParent = NULL
					  );

    CPropertySheetPage( LPCPROPSHEETPAGE pPageVector );

	CPropertySheetPage& operator=( const CPropertySheetPage& r );
	~CPropertySheetPage( void );

    
        // conversion operator
    operator LPPROPSHEETPAGE() { return this; }
    operator LPCPROPSHEETPAGE() { return this; }

private:    // Helper Fns

	void _InitData( void );
	BOOL _IsRightToLeftLocale( void ) const;

		// Set with optional validation, defined in the cpp file
	BOOL _Set_hInstance( HINSTANCE hInst );
	BOOL _Set_pszTemplate( LPCTSTR pszTemplate );
	BOOL _Set_pResource( LPCDLGTEMPLATE pResource );
	BOOL _Set_hIcon( HICON hIcon );
	BOOL _Set_pszIcon( LPCTSTR pszIcon );
	BOOL _Set_pszTitle( LPCTSTR pszTitle );
	BOOL _Set_pfnDlgProc( DLGPROC pfnDlgProc );
	BOOL _Set_pfnCallback( LPFNPSPCALLBACK pfnCallBack );
	BOOL _Set_lParam( LPARAM lParam );
	BOOL _Set_pcRefParent( UINT FAR * pcRefParent );
	BOOL _Validate( void ) const;
};
		


#endif // __PropPg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\pshthdr.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Files

#include "precomp.h"
#include "PropPg.h"
#include "PShtHdr.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Construction, destruction, and Initialization
////////////////////////////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader
CPropertySheetHeader::CPropertySheetHeader( void ) {
    _InitData();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader

CPropertySheetHeader::CPropertySheetHeader( int nPages, UsePropertySheetArray dummy, PFNPROPSHEETCALLBACK pfnCallback /* = NULL */ ) {

    _InitData();

    this -> ppsp = new PROPSHEETPAGE[ nPages ];
    this -> dwFlags |= PSH_PROPSHEETPAGE;
	this -> nPages = nPages;

    _Set_pfnCallback( pfnCallback );

#ifdef CPropertySheetHeader_ValidateParameters
        
#endif // CPropertySheetHeader_ValidateParameters

    _Validate();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader

CPropertySheetHeader::CPropertySheetHeader( int nPages, UsePropertySheetHandleArray dummy, PFNPROPSHEETCALLBACK pfnCallback /* = NULL */  ) {

    _InitData();

    this -> phpage = new HPROPSHEETPAGE[ nPages ];
    this -> dwFlags &= ~PSH_PROPSHEETPAGE;
	this -> nPages = nPages;

    _Set_pfnCallback( pfnCallback );

#ifdef CPropertySheetHeader_ValidateParameters
        
#endif // CPropertySheetHeader_ValidateParameters

    _Validate();

}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader

CPropertySheetHeader::CPropertySheetHeader( LPCPROPSHEETPAGE pPageVector, int nPages, PFNPROPSHEETCALLBACK pfnCallback /* = NULL */ ) 
{ 

    _InitData();

    if( _Set_ppsp( pPageVector, nPages ) )       { assert( 0 ); return; }
    
    _Set_pfnCallback( pfnCallback );

#ifdef CPropertySheetHeader_ValidateParameters
        
#endif // CPropertySheetHeader_ValidateParameters

    _Validate();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader
// Note that we are assuming that you are telling us wether to use the ppsp or the phpage member
// of PROPSHEETHEADER, as specified by the flag PSH_PROPSHEETPAGE
CPropertySheetHeader::CPropertySheetHeader( int nPages, DWORD dwFlags, PFNPROPSHEETCALLBACK pfnCallback /* = NULL */  ) {
    _InitData();

	this -> dwFlags = dwFlags;
	if( this -> dwFlags & PSH_PROPSHEETPAGE ) {
		this -> ppsp = new PROPSHEETPAGE[ nPages ];
		this -> nPages = nPages;
		ZeroMemory( const_cast<LPPROPSHEETPAGE>( this -> ppsp ), sizeof( PROPSHEETPAGE ) * nPages );
	}
	else {
		this -> phpage = new HPROPSHEETPAGE[ nPages ];
		this -> nPages = nPages;
		ZeroMemory( this -> phpage, sizeof( HPROPSHEETPAGE )  * nPages );
	}
    
    _Set_pfnCallback( pfnCallback );
    
    _Validate();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::~CPropertySheetHeader

CPropertySheetHeader::~CPropertySheetHeader( void ) {
    _DeletePageData();
}




//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_InitData

BOOL CPropertySheetHeader::_InitData( void ) {
    ZeroMemory( this, sizeof( PROPSHEETHEADER ) );
    this -> dwSize = sizeof( PROPSHEETHEADER );
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Methods and operators
////////////////////////////////////////////////////////////////////////////////////////////////////

    

//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::operator[]
// This is a funny little beastie.  Basically, it returns an iterator so the results can be used as 
// both an lval and an rval.
//
//  MyPropertySheetPage = MyPropSheetHeader[ 0 ];
//  MyPropSheetHeader[ 1 ] = OtherPage;

CPropertySheetHeader::CPropertySheetPageDataIterator CPropertySheetHeader::operator[]( int index ) {

#ifdef CPropertySheetHeader_ValidateParameters
    assert( index >= 0 );
    if( static_cast< UINT >( index ) >= this -> nPages ) { // This is out of range ( they start at 0 )
        assert( 0 );
        return CPropertySheetPageDataIterator( 0, this );
    }
#endif // CPropertySheetHeader_ValidateParameters

    return CPropertySheetPageDataIterator( index, this );
}
    


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Validate

BOOL CPropertySheetHeader::_Validate( void ) {

#ifdef CPropertySheetHeader_ValidateParameters

    if( ( this -> dwFlags & PSH_PROPTITLE ) || ( this -> dwFlags & PSH_USEICONID ) ) {
        if( NULL == this -> hInstance ) {
            assert( 0 );
            return FALSE;
        }
    }

#endif // CPropertySheetHeader_ValidateParameters

    return TRUE;
}



//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_hwndParent

BOOL CPropertySheetHeader::_Set_hwndParent( HWND hwndParent ) {

#ifdef CPropertySheetHeader_ValidateParameters
    
#endif // CPropertySheetHeader_ValidateParameters

    this -> hwndParent = hwndParent;
    return TRUE;
}

BOOL CPropertySheetHeader::_Set_hInstance( HINSTANCE hInstance ) {
#ifdef CPropertySheetHeader_ValidateParameters


#endif // CPropertySheetHeader_ValidateParameters

    this -> hInstance = hInstance;
    return TRUE;

}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_hIcon
BOOL CPropertySheetHeader::_Set_hIcon( HICON hIcon ) {

    if( NULL == hIcon ) { return FALSE; }
#ifdef CPropertySheetHeader_ValidateParameters

#endif // CPropertySheetHeader_ValidateParameters


    this -> dwFlags &= ~PSH_USEICONID;
    this -> dwFlags |= PSH_USEHICON;
    this -> hIcon = hIcon;
    
    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_pszIcon
BOOL CPropertySheetHeader::_Set_pszIcon( LPCTSTR pszIcon )  {

    if( NULL == pszIcon ) { return FALSE; }
#ifdef CPropertySheetHeader_ValidateParameters
    if( NULL == this -> hInstance ) { // This must be set first
        assert( 0 );
        return FALSE;
    }

#endif // CPropertySheetHeader_ValidateParameters

    this -> dwFlags &= ~PSH_USEHICON;
    this -> dwFlags |= PSH_USEICONID;
    this -> pszIcon = pszIcon;

    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_pszCaption
BOOL CPropertySheetHeader::_Set_pszCaption( LPCTSTR pszCaption ) {

    if( NULL == pszCaption ) { return FALSE; }
#ifdef CPropertySheetHeader_ValidateParameters
    if( NULL == this -> hInstance ) { // This must be set first
        assert( 0 );
        return FALSE;
    }

#endif // CPropertySheetHeader_ValidateParameters

    this -> dwFlags |= PSH_PROPTITLE;
    this -> pszCaption = pszCaption;

    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_nStartPage

BOOL CPropertySheetHeader::_Set_nStartPage( UINT nStartPage ) {

#ifdef CPropertySheetHeader_ValidateParameters
    if( ( nStartPage > 0 ) || ( nStartPage >= this -> nPages ) ) {
        assert( 0 );
        return FALSE;
    }

#endif // CPropertySheetHeader_ValidateParameters

    this -> dwFlags &= ~PSH_USEPSTARTPAGE;
    this -> nStartPage = nStartPage;
    return TRUE;
}



//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_pStartPage
BOOL CPropertySheetHeader::_Set_pStartPage( LPCTSTR pStartPage ) {

    if( NULL == pStartPage ) { return FALSE; }

#ifdef CPropertySheetHeader_ValidateParameters

#endif // CPropertySheetHeader_ValidateParameters

    this -> dwFlags |= PSH_USEPSTARTPAGE;
    this -> pStartPage = pStartPage;
    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_ppsp

BOOL CPropertySheetHeader::_Set_ppsp( LPCPROPSHEETPAGE ppsp, UINT nPages ) {


    _DeletePageData();

    this -> ppsp = new PROPSHEETPAGE[ nPages ];
    this -> dwFlags |= PSH_PROPSHEETPAGE;

#ifdef CPropertySheetHeader_ValidateParameters
    for( UINT i = 0; i < this -> nPages; i++ ) {
        const_cast<LPPROPSHEETPAGE>( this -> ppsp )[ i ] = CPropertySheetPage( ppsp + i );
    }
#else
    memcpy( this -> ppsp, ppsp, sizeof( PROPSHEETPAGE ) * nPages );
#endif // CPropertySheetHeader_ValidateParameters

    this -> nPages = nPages;

    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_phpage
BOOL CPropertySheetHeader::_Set_phpage( HPROPSHEETPAGE FAR phpage, UINT nPages ) {

#ifdef CPropertySheetHeader_ValidateParameters

#endif // CPropertySheetHeader_ValidateParameters

    _DeletePageData();

    this -> phpage = new HPROPSHEETPAGE[ nPages ];
    this -> dwFlags &= ~PSH_PROPSHEETPAGE;
    memcpy( this -> phpage, phpage, sizeof( HPROPSHEETPAGE ) * nPages );
    this -> nPages = nPages;
    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_pfnCallback
BOOL CPropertySheetHeader::_Set_pfnCallback( PFNPROPSHEETCALLBACK pfnCallback ) {

#ifdef CPropertySheetHeader_ValidateParameters

#endif // CPropertySheetHeader_ValidateParameters

    if( NULL != pfnCallback ) {
        this -> pfnCallback = pfnCallback;
        this -> dwFlags |= PSH_USECALLBACK;
    }
    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_DeletePageData

BOOL CPropertySheetHeader::_DeletePageData( void ) {

    if( this -> dwFlags & PSH_PROPSHEETPAGE ) {
        LPPROPSHEETPAGE ppsp = const_cast<LPPROPSHEETPAGE>( this -> ppsp );
        delete [] ppsp;
        this -> ppsp = NULL;
    }
    else {
        delete [] const_cast<HPROPSHEETPAGE FAR *>( this -> phpage );
        this -> phpage = NULL;
    }

    this -> nPages = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\pshthdr.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// CPropertySHeetHeader is a wrapper class around the PROPSHEETHEADER structure
//  this class mostly does data validation. The operator[] and Iterator member class allows for
//  pretty syntax.  Hopefully the prettyness outweighs the confusion... 
//
//
// 	CPropertySheetHeader		MyPropSheetHeader( 2,                             // NumPropShtPages
//                                                 PSH_PROPSHEETPAGE | PSH_WIZARD // Flags
//                                                );            
//                                                 
//
//
//  CPropertySheetPage MyPropertySheetPage( 
//                                          IDD_PROPPAGE_TEMPLATE, 
//                                          ( DLGPROC ) MyDlgProc, 
//                                          PSP_HASHELP   
//                                        );
//  extern PROPSHEETPAGE OtherPage;        
//
//  MyPropSheetHeader[ 0 ] = MyPropertySheetPage;
//  MyPropSheetHeader[ 1 ] = OtherPage;
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __PhtHdr_h__
#define __PhtHdr_h__


////////////////////////////////////////////////////////////////////////////////////////////////////
// Include files

#include "PropPg.h"



////////////////////////////////////////////////////////////////////////////////////////////////////
// Comment this if you do not want parameter validation ( class would do essentially nothing )
//
#define CPropertySheetHeader_ValidateParameters
////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////
// Property Sheet Header


class CPropertySheetHeader : public PROPSHEETHEADER {

        // Forward declarations and friend declarations
    class CPropertySheetPageDataIterator;
    friend CPropertySheetPageDataIterator;

private: // DATATYPES

        ///////////////////////////////////////////////////////////////////////////////////////////
        // CPropertySheetPageDataIterator is for getting at a PROPSHEETPAGE in the ppsp member
        //      array of a PROPSHEETHEADER
    class CPropertySheetPageDataIterator {
            // Forward Decls and Friend decls
        friend CPropertySheetHeader;

    private:    // DATA
        UINT                m_Index;
        PROPSHEETHEADER    *m_pPsh;

    private:    // Construction / destruction
            // This may only be created by CPropertySheetHeader
        CPropertySheetPageDataIterator( UINT index, PROPSHEETHEADER* pPsh ) 
            : m_Index( index ), m_pPsh( pPsh ) { ; }

    public:     
        ~CPropertySheetPageDataIterator( void ) { ; }

    public: // Public Member Fns
        void operator=( LPCPROPSHEETPAGE p ) { 
            assert( m_pPsh -> dwFlags & PSH_PROPSHEETPAGE );    // We only handle this case now
            const_cast< LPPROPSHEETPAGE >( m_pPsh -> ppsp )[ m_Index ] = *p; 
        }
        void operator=( HPROPSHEETPAGE FAR * p ) {
            assert( !( m_pPsh -> dwFlags & PSH_PROPSHEETPAGE ) ); // We only handle this case now
            m_pPsh -> phpage[ m_Index ] = *p; 
        }
    private:    // UNUSED
        CPropertySheetPageDataIterator( void );
        CPropertySheetPageDataIterator( const CPropertySheetPageDataIterator& r );
    };


public:  // symbol classes for signature disambiguation...
    class UsePropertySheetArray{ ; };
    class UsePropertySheetHandleArray{ ; };

public: // Construction / destruction
	CPropertySheetHeader( void ); 	
	CPropertySheetHeader( LPCPROPSHEETPAGE pPageVector, int nPages, PFNPROPSHEETCALLBACK pfnCallback = NULL );
	CPropertySheetHeader( int nPages, UsePropertySheetArray dummy, PFNPROPSHEETCALLBACK pfnCallback = NULL );
	CPropertySheetHeader( int nPages, DWORD dwFlags, PFNPROPSHEETCALLBACK pfnCallback = NULL );
    CPropertySheetHeader( int nPages, UsePropertySheetHandleArray dummy, PFNPROPSHEETCALLBACK pfnCallback = NULL );
	~CPropertySheetHeader( void );

        // Methods and operators
    CPropertySheetPageDataIterator operator[]( int index );
	void SetParent( HWND hWndParent ) { _Set_hwndParent( hWndParent ); }
	
		// Conversion operator
    operator LPPROPSHEETHEADER() { return this; }

private: // Helper Fns
    BOOL _InitData( void );
    BOOL _Validate( void );
    BOOL _Set_hwndParent( HWND hwndParent );
    BOOL _Set_hInstance( HINSTANCE hInstance );
    BOOL _Set_hIcon( HICON hIcon );
    BOOL _Set_pszIcon( LPCTSTR pszIcon );  
    BOOL _Set_pszCaption( LPCTSTR pszCaption );
    BOOL _Set_nStartPage( UINT nStartPage );
    BOOL _Set_pStartPage( LPCTSTR pStartPage );
    BOOL _Set_ppsp( LPCPROPSHEETPAGE ppsp, UINT nPages );
    BOOL _Set_phpage( HPROPSHEETPAGE FAR phpage, UINT nPages );
    BOOL _Set_pfnCallback( PFNPROPSHEETCALLBACK pfnCallback );
    BOOL _DeletePageData( void );

private: // UNUSED
	CPropertySheetHeader( const CPropertySheetHeader& r );
 	CPropertySheetHeader& operator=( const CPropertySheetHeader& r );
};

#endif // __PhtHdr_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\propwnd2.cpp ===
#include "precomp.h"
#include "resource.h"
#include "PropWnd2.h"
#include "WndProcs.h"
#include "nmakwiz.h"
#include "nmakreg.h"
#include <algorithm>

const int CPropertyDataWindow2::mcs_iTop = 0;
const int CPropertyDataWindow2::mcs_iLeft = 150;
const int CPropertyDataWindow2::mcs_iBorder = 15;

/* static */ map< UINT, CPolicyData::eKeyType > CPropertyDataWindow2::ms_ClassMap;
/* static */ map< UINT, TCHAR* > CPropertyDataWindow2::ms_KeyMap;
/* static */ map< UINT, TCHAR* > CPropertyDataWindow2::ms_ValueMap;


LRESULT CALLBACK DefaultProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
    switch( iMsg )
    {
        case WM_VSCROLL: 
        {
            OnMsg_VScroll( hwnd, wParam );
            return 0;
            break;
        } 
        case WM_COMMAND:
        {
            return 0;
        }
    }
    return( DefWindowProc( hwnd, iMsg, wParam, lParam ) );
}

CPropertyDataWindow2::CPropertyDataWindow2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll ) :
        m_hwnd( NULL ),
        m_IDD( uIDD ),
        m_wndProc( (WNDPROC) DefaultProc),
        m_bInit( FALSE ),
        m_hwndParent( hwndParent )
{ 
    m_szClassName = new TCHAR[ lstrlen( szClassName ) + 1 ];
    lstrcpy( m_szClassName, szClassName );
    _InitWindow();
    _SizeWindow( iX, iY, iWidth, iHeight );
    if( bScroll )
    {
        _PrepScrollBars();
    }
    ShowWindow( FALSE );
}

CPropertyDataWindow2::CPropertyDataWindow2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, WNDPROC wndProc, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll ) :
        m_IDD( uIDD ),
        m_hwnd( NULL ),
        m_wndProc( wndProc ),
        m_bInit( FALSE ),
        m_hwndParent( hwndParent )
{ 
    m_szClassName = new TCHAR[ lstrlen( szClassName ) + 1 ];
    lstrcpy( m_szClassName, szClassName );
    _InitWindow();
    _SizeWindow( iX, iY, iWidth, iHeight );
    if( bScroll )
    {
        _PrepScrollBars();
    }
    ShowWindow( FALSE );
}

CPropertyDataWindow2::~CPropertyDataWindow2( void ) 
{
    delete [] m_szClassName;
    list< CControlID * >::iterator it;
    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        delete *it;
    }
    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        delete *it;
    }

}

void CPropertyDataWindow2::Reset()
{
    list< HWND >::iterator i;

    for( i = m_enableList.begin(); i != m_enableList.end(); i++ )
    {
        switch (GetWindowLong(*i, GWL_STYLE) & 0x0F)
        {
            case BS_AUTORADIOBUTTON:
            case BS_RADIOBUTTON:
                // Do nothing -- we always want default item checked
                break;

            default:
                Button_SetCheck(*i, FALSE);
                break;
        }
    }

    list< CControlID * >::iterator it;
    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        (*it)->Reset( m_hwnd );
    }
    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        (*it)->Reset( m_hwnd );
    }
}

void CPropertyDataWindow2::SetEnableListID( UINT uCount, ... )
{
    UINT uID;
    HWND hwnd;
    
    va_list ap;
    va_start( ap, uCount );

    while( uCount )
    {
        uID = va_arg( ap, UINT );
        uCount--;
        if( NULL == ( hwnd = GetDlgItem( m_hwnd, uID ) ) )
        {
            OutputDebugString( TEXT("Enabling Invalid ID\n") );
        }
        else
        {
            m_checkIDList.push_front( uID );
            m_enableList.push_front( hwnd );
        }
    }
    
    va_end( ap );
}

BOOL CPropertyDataWindow2::SetFocus( UINT id ) 
{     
    return ::SetFocus( GetDlgItem( m_hwnd, id ) ) ? TRUE : FALSE;
}

void CPropertyDataWindow2::SetEditData( UINT id, TCHAR* sz ) 
{
    Edit_SetText( GetDlgItem( m_hwnd, id ), sz );
}

void CPropertyDataWindow2::GetEditData( UINT id, LPTSTR sz, ULONG cb ) const 
{
    Edit_GetText( GetDlgItem( m_hwnd, id ), sz, cb );
}

ULONG CPropertyDataWindow2::GetEditDataLen( UINT id ) const
{
    return Edit_GetTextLength( GetDlgItem( m_hwnd, id ) );
}

BOOL CPropertyDataWindow2::GetCheck( UINT id ) const
{
    return(Button_GetCheck( GetDlgItem( m_hwnd, id ) ) ? TRUE : FALSE);
}

void CPropertyDataWindow2::SetCheck( UINT id, BOOL bCheck )
{
    Button_SetCheck( GetDlgItem( m_hwnd, id ), bCheck );
}

void CPropertyDataWindow2::ShowWindow( BOOL bShowWindow /* = TRUE */ )
{
    ::ShowWindow( m_hwnd, bShowWindow ? SW_SHOW : SW_HIDE );
}

void CPropertyDataWindow2::EnableWindow( BOOL bEnable /* = TRUE */ )
{
    list< HWND >::const_iterator it;
    
    for (it = m_enableList.begin(); it != m_enableList.end(); ++it)
    {
        ::EnableWindow( (HWND)(*it), bEnable );
    }

    if( m_specialControlList.size() )
    {
        list< CControlID * >::const_iterator iter;
        for( iter = m_specialControlList.begin();
            iter != m_specialControlList.end();
            iter++ )
        {
                switch( (*iter)->GetType() )
                {
                    case CControlID::CHECK:
                    case CControlID::SLIDER:
                    case CControlID::EDIT:
                    case CControlID::EDIT_NUM:
                    case CControlID::STATIC:
                    case CControlID::COMBO:
                    {
                        HWND hwnd = GetDlgItem( m_hwnd, (*iter)->GetID() );
                        ::EnableWindow( hwnd, bEnable );
                        break;
                    }
                    default:
                        OutputDebugString( TEXT("CPropertyDataWindow2::EnableWindow: unknown CControlID::type\n") );
                        assert( 0 );
                        break;
                }
        }
    }

    if( m_condList.size() )
    {
        list< CControlID * >::const_iterator iter;
        for( iter = m_condList.begin();
            iter != m_condList.end();
            iter++ )
        {
            ::EnableWindow( (*iter)->GetCondHwnd(), bEnable );
        }
    }
}

BOOL CPropertyDataWindow2::_InitWindow( void ) 
{

    if( FALSE == m_bInit )
    {
        WNDCLASSEX wc;
    
        ZeroMemory( &wc, sizeof( WNDCLASSEX ) );
        wc . cbSize = sizeof( WNDCLASSEX );
        wc . style = 0;
        wc . cbWndExtra = DLGWINDOWEXTRA;     
        wc . hInstance = g_hInstance;
        wc . lpfnWndProc = m_wndProc;
        wc . lpszClassName = m_szClassName;
        
        if( 0 == RegisterClassEx( &wc ) ) 
        { 
            return FALSE; 
        }
    
        //m_hwnd = CreateDialogParam( g_hInstance, MAKEINTRESOURCE( m_IDD ), m_hwndParent, NULL/*(DLGPROC)m_wndProc*/, 0 );
        m_hwnd = CreateDialogParam( g_hInstance, MAKEINTRESOURCE( m_IDD ), m_hwndParent, NULL, 0 );
        if( NULL == m_hwnd )
        {
            ErrorMessage( TEXT("CPropertyDataWindow2::_InitWindow"), GetLastError() );
        }
    
        m_bInit = TRUE;
    }
    return TRUE;
}

BOOL CPropertyDataWindow2::_SizeWindow( int X, int Y, int Width, int Height )
{
    GetClientRect( m_hwnd, &m_rect );
    return SetWindowPos(  m_hwnd,    // handle to window
                        HWND_TOP,  // placement-order handle
                        X,   // horizontal position
                        Y,   // vertical position
                        Width,    // width
                        Height,   // height
                        0          // window-positioning flags
                        );
}

void CPropertyDataWindow2::_PrepScrollBars()
{
    RECT clientRect;
    GetClientRect( m_hwnd, &clientRect );

    int iTotalHeight = (m_rect.bottom - m_rect.top);
    int iVisible = clientRect.bottom - clientRect.top;

    if( iTotalHeight <= iVisible )
    {
        return;
    }

    SCROLLINFO ScrollInfo;
    ScrollInfo . cbSize = sizeof( SCROLLINFO );
    ScrollInfo . fMask = SIF_ALL;
    ScrollInfo . nMin = 0;
    ScrollInfo . nMax = iTotalHeight;
    // Make the scroll bar scroll 4/5th of a screen per page
    ScrollInfo . nPage = MulDiv( iVisible, 4, 5 );
    ScrollInfo . nPos = 0;
    SetScrollInfo( m_hwnd, SB_VERT, &ScrollInfo, 0 );
}

void CPropertyDataWindow2::AddControl( CControlID *pControlID )
{
    m_specialControlList.push_front( pControlID );
}

void CPropertyDataWindow2::ConnectControlsToCheck( UINT idCheck, UINT uCount, ... )
{
    HWND hwndCheck = GetDlgItem( m_hwnd, idCheck );
    PSUBDATA pSubData = new SUBDATA;
    pSubData -> proc = SubclassWindow( hwndCheck, wndProcForCheckTiedToEdit );

    va_list ap;
    va_start( ap, uCount );

    while( uCount )
    {
        uCount--;
        CControlID *pControlID = va_arg( ap, CControlID * );
        m_condList.push_front( pControlID );

        switch( pControlID->GetType() )
        {
            case CControlID::STATIC:
            case CControlID::CHECK:
            case CControlID::SLIDER:
            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
            case CControlID::COMBO:
            {
                HWND hwnd = GetDlgItem( m_hwnd, pControlID->GetID() );
                pSubData->list.push_front( hwnd );
                break;
            }
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::ConnectControlsToCheck: unknown CControlID::type\n") );
                break;

        }
    }

    SetWindowLong( hwndCheck, GWL_USERDATA, (long)pSubData );
}





BOOL CPropertyDataWindow2::WriteStringValue
(
    LPCTSTR  szKeyName,
    LPCTSTR  szValue
)
{
    TCHAR   szFile[MAX_PATH];

    //
    // We SAVE settings to the file on the finish page.
    //
    g_pWiz->m_FinishSheet.GetFilePane()->GetPathAndFile(szFile);

    return(WritePrivateProfileString(SECTION_SETTINGS, szKeyName,
        szValue, szFile));
}



BOOL CPropertyDataWindow2::WriteNumberValue
(
    LPCTSTR  szKeyName,
    int     nValue
)
{
    TCHAR   szValue[MAX_DIGITS];
    TCHAR   szFile[MAX_PATH];

    //
    // We SAVE settings to the file on the finish page.
    //
    g_pWiz->m_FinishSheet.GetFilePane()->GetPathAndFile(szFile);

    wsprintf(szValue, "%d", nValue);
    return(WritePrivateProfileString(SECTION_SETTINGS, szKeyName,
        szValue, szFile));
}



void CPropertyDataWindow2::ReadStringValue
(
    LPCTSTR  szKeyName,
    LPTSTR  szValue,
    UINT    cchMax
)
{
    TCHAR   szFile[MAX_PATH];

    //
    // We READ settings from the file on the intro page.
    //
    g_pWiz->m_IntroSheet.GetFilePane()->GetPathAndFile(szFile);

    GetPrivateProfileString(SECTION_SETTINGS, szKeyName,
            TEXT(""), szValue, cchMax, szFile);
}



void CPropertyDataWindow2::ReadNumberValue
(
    LPCTSTR  szKeyName,
    int *   pnValue
)
{
    TCHAR   szFile[MAX_PATH];

    //
    // We READ settings from the file on the intro page.
    //
    g_pWiz->m_IntroSheet.GetFilePane()->GetPathAndFile(szFile);

    *pnValue = GetPrivateProfileInt(SECTION_SETTINGS, szKeyName,
        0, szFile);
}



void CPropertyDataWindow2::ReadSettings()
{
    list< CControlID *>::const_iterator it;

    _ReadCheckSettings();

    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        _ReadCheckSetting( (*it)->GetCondID() );
        switch( (*it)->GetType() )
        {
            case CControlID::STATIC:
                break;

            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
                _ReadEditSetting( (*it)->GetID() );
                break;
            case CControlID::CHECK:
                _ReadCheckSetting( (*it)->GetID() );
                break;
            case CControlID::COMBO:
                _ReadComboSetting( (*it)->GetID() );
                break;
            case CControlID::SLIDER:
                _ReadSliderSetting( (*it) );
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::ReadSettings: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        switch( (*it)->GetType() )
        {
            case CControlID::STATIC:
                break;

            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
                _ReadEditSetting( (*it)->GetID() );
                break;
            case CControlID::CHECK:
                _ReadCheckSetting( (*it)->GetID() );
                break;
            case CControlID::COMBO:
                _ReadComboSetting( (*it)->GetID() );
                break;
            case CControlID::SLIDER:
                _ReadSliderSetting( (*it) );
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::ReadSettings: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }
}


BOOL CPropertyDataWindow2::WriteSettings()
{
    list< CControlID *>::const_iterator it;

    _WriteCheckSettings();

    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        _WriteCheckSetting( (*it)->GetCondID() );
        switch( (*it)->GetType() )
        {
            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
                _WriteEditSetting( (*it)->GetID() );
                break;
            case CControlID::CHECK:
                _WriteCheckSetting( (*it)->GetID() );
                break;
            case CControlID::COMBO:
                _WriteComboSetting( (*it)->GetID() );
                break;
            case CControlID::SLIDER:
                _WriteSliderSetting( (*it)->GetID() );
                break;
            case CControlID::STATIC:
                break;

            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::WriteSettings: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        switch( (*it)->GetType() )
        {
            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
                _WriteEditSetting( (*it)->GetID() );
                break;
            case CControlID::CHECK:
                _WriteCheckSetting( (*it)->GetID() );
                break;
            case CControlID::COMBO:
                _WriteComboSetting( (*it)->GetID() );
                break;
            case CControlID::SLIDER:
                _WriteSliderSetting( (*it)->GetID() );
                break;
            case CControlID::STATIC:
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::WriteSettings: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    return TRUE;
}

void CPropertyDataWindow2::_ReadEditSetting( UINT EditID )
{
    TCHAR   szKeyName[8];
    TCHAR   szSetting[512];

    wsprintf( szKeyName, TEXT("%d"), EditID );

    ReadStringValue(szKeyName, szSetting, CCHMAX(szSetting));
    SetEditData(EditID, szSetting);
}


BOOL CPropertyDataWindow2::_WriteEditSetting( UINT EditID )
{
    BOOL    fSuccess;
    int iLen = GetEditDataLen( EditID ) + 1;
    LPTSTR szData = new TCHAR[ iLen ];
    GetEditData( EditID, szData, iLen );

    TCHAR szKeyName[ 8 ];
    wsprintf(szKeyName, TEXT("%d"), EditID);

    fSuccess = WriteStringValue(szKeyName, szData);

    delete [] szData;

    return(fSuccess);
}


void CPropertyDataWindow2::_ReadIntSetting( UINT ID, int *pData )
{
    TCHAR szKeyName[ 8 ];
    
    wsprintf( szKeyName, TEXT("%d"), ID );

    ReadNumberValue(szKeyName, pData);
}


BOOL CPropertyDataWindow2::_WriteIntSetting( UINT ID, int data )
{
    TCHAR szKeyName[ 8 ];

    wsprintf( szKeyName, TEXT("%d"), ID );
    
    return(WriteNumberValue(szKeyName, data));
}


void CPropertyDataWindow2::_ReadSliderSetting( CControlID *pControlID )
{
    int iPos;
    UINT ID = pControlID->GetID();

    _ReadIntSetting( ID, &iPos);

    //
    // HACK FOR AV BANDWIDTH -- TrackBars are limited to WORD-sized values
    // for range.  So the registry has the real value (bits/sec) but we 
    // represent it in NMRK UI as (kbits/sec).
    //
    iPos /= 1000;

    TrackBar_SetPos( GetDlgItem( m_hwnd, ID  ), TRUE, iPos);

    TCHAR szPos[ MAX_DIGITS ];
    wsprintf( szPos, TEXT("%u"), iPos );
    Static_SetText( GetDlgItem( m_hwnd, pControlID->GetStaticID()), szPos );
}


BOOL CPropertyDataWindow2::_WriteSliderSetting(  UINT ID )
{
    int iPos;

    //
    // HACK FOR AV BANDWIDTH -- TrackBars are limited to WORD-sized values
    // for range.  So the registry has the real value (bits/sec) but we 
    // represent it in NMRK UI as (kbits/sec).
    //

    iPos = TrackBar_GetPos(GetDlgItem(m_hwnd, ID));
    iPos *= 1000;

    return _WriteIntSetting( ID, iPos);
}



void CPropertyDataWindow2::_ReadComboSetting( UINT ID )
{
    int iSelected;

    _ReadIntSetting( ID, &iSelected );

    HWND hwndCombo = GetDlgItem( m_hwnd, ID );
    ComboBox_SetCurSel( hwndCombo, iSelected );
}


BOOL CPropertyDataWindow2::_WriteComboSetting( UINT ID )
{
    return _WriteIntSetting( ID, ComboBox_GetCurSel( GetDlgItem( m_hwnd, ID ) ) );
}


void CPropertyDataWindow2::_ReadCheckSetting( UINT ID )
{
    TCHAR szKeyName[ 8 ];
    int   nValue;

    wsprintf( szKeyName, TEXT("%d"), ID );
    ReadNumberValue(szKeyName, &nValue);

    CheckDlgButton(m_hwnd, ID, nValue);
}


BOOL CPropertyDataWindow2::_WriteCheckSetting( UINT ID )
{
    TCHAR szKeyName[ MAX_DIGITS ];

    wsprintf( szKeyName, TEXT("%d"), ID );

    return(WriteNumberValue(szKeyName, IsDlgButtonChecked(m_hwnd, ID)));
}


void CPropertyDataWindow2::_ReadCheckSettings()
{
    for( list< UINT >::const_iterator it = m_checkIDList.begin(); it != m_checkIDList.end(); it++ )
    {
        _ReadCheckSetting(*it);
    }
}


BOOL CPropertyDataWindow2::_WriteCheckSettings()
{
    for( list< UINT >::const_iterator it = m_checkIDList.begin(); it != m_checkIDList.end(); it++ )
    {
        if (!_WriteCheckSetting(*it))
        {
            return FALSE;
        }
    }
    return TRUE;
}





void CPropertyDataWindow2::MapControlsToRegKeys( void ) 
{
    
    if( 0 != ms_ValueMap.size() )
    {
        return;
    }

    UINT CurrentID;
    // File Transfer
    CurrentID = IDC_PREVENT_THE_USER_FROM_SENDING_FILES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID  ] = POLICIES_KEY;;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_FILETRANSFER_SEND;

    CurrentID = IDC_PREVENT_THE_USER_FROM_RECEIVING_FILES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_FILETRANSFER_RECEIVE;

    CurrentID = IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_MAX_SENDFILESIZE;

    // App Sharing
    CurrentID = IDC_DISABLE_ALL_SHARING_FEATURES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_APP_SHARING;

    CurrentID = IDC_DISABLE_WEBDIR;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_WEBDIR;

    CurrentID = IDC_DISABLE_WEBDIR_GK;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_WEBDIR;

    CurrentID = IDC_PREVENT_SHARING;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_SHARING;

    CurrentID = IDC_PREVENT_SHARING_DESKTOP;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_DESKTOP_SHARING;

    CurrentID = IDC_PREVENT_SHARING_TRUECOLOR;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_TRUECOLOR_SHARING;

    CurrentID = IDC_PREVENT_SHARING_EXPLORER;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_EXPLORER_SHARING;

    CurrentID = IDC_PREVENT_SHARING_DOS;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_MSDOS_SHARING;

    CurrentID = IDC_PREVENT_SHARING_CONTROL;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_ALLOW_CONTROL;

    CurrentID = IDC_DISABLE_RDS_ON_ALL;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_RDS;

    CurrentID = IDC_DISABLE_RDS_ON_WIN9X;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_RDS_WIN9X;


    // Audio
    CurrentID = IDC_CREATE_AN_AUDIO_LOG_FILE; // HKLM
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = DEBUG_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_RETAIL_LOG;

    CurrentID = IDC_CHECK_MUTE_SPEAKER_BY_DEFAULT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_SPKMUTE;

    CurrentID = IDC_CHECK_MUTE_MICROPHONE_BY_DEFAULT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_RECMUTE;

    CurrentID = IDC_ENABLE_DIRECT_SOUND;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_DIRECTSOUND;

    CurrentID = IDC_NOCHANGE_DIRECT_SOUND;
    ms_ClassMap[CurrentID] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[CurrentID] = POLICIES_KEY;
    ms_ValueMap[CurrentID] = REGVAL_POL_NOCHANGE_DIRECTSOUND;

    CurrentID = IDC_PREVENT_THE_USER_FROM_USING_AUDIO;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_AUDIO;

    CurrentID = IDC_DISABLE_FULL_DUPLEX_AUDIO;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_FULLDUPLEX;                

    // Video
    CurrentID = IDC_DISABLE_SENDING_VIDEO;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_VIDEO_SEND;

    CurrentID = IDC_DISABLE_RECIEVING_VIDEO;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_VIDEO_RECEIVE;

    // Notifications

    //
    // REMOTE OLDER WARNING is GONE
    //
    CurrentID = IDC_REQUIRE_COMPLETE_AUTHENTICATION;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_INCOMPLETE_CERTS;

    CurrentID = IDC_EDIT_SET_RDN_FOR_REQUIRED_CA;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_ISSUER;

    // Directory Services
    CurrentID = IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_DONT_LOGON_ULS;

    CurrentID = IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_ADDING_NEW_ULS;

    // Chat
    CurrentID = IDC_DISABLE_CHAT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_CHAT;


    // Whiteboard
    // 
    // BOGUS BUGBUG LAURABU
    // We have OLD and NEW whiteboard
    //
    CurrentID = IDC_DISABLE_2XWHITEBOARD;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_OLDWHITEBOARD;

    CurrentID = IDC_DISABLE_WHITEBOARD;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_NEWWHITEBOARD;

    // Online Support
    CurrentID = IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_INTRANET_SUPPORT_URL;

    CurrentID = IDC_SHOW_THE_ONLINE_SUPPORT_PAGE_THE_FIRST_TIME_NETMEETING_STARTS;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_SHOW_FIRST_TIME_URL;

    // Options Dialog 
    CurrentID = IDC_DISABLE_THE_GENERAL_OPTIONS_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_GENERALPAGE;

    CurrentID = IDC_DISABLE_THE_ADVANCED_CALLING_BUTTON;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_ADVANCEDCALLING;

    CurrentID = IDC_DISABLE_THE_SECURITY_OPTIONS_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_SECURITYPAGE;

    CurrentID = IDC_DISABLE_THE_AUDIO_OPTIONS_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_AUDIOPAGE;

    CurrentID = IDC_DISABLE_THE_VIDEO_OPTIONS_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_VIDEOPAGE;

    CurrentID = IDC_DISABLE_AUTOACCEPT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_AUTOACCEPTCALLS;

    CurrentID = IDC_PERSIST_AUTOACCEPT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_PERSIST_AUTOACCEPTCALLS;

    // Security RADIO Options
    CurrentID = IDC_RADIO_SECURITY_DEFAULT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_SECURITY;

    CurrentID = IDC_RADIO_SECURITY_REQUIRED;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_SECURITY;

    CurrentID = IDC_RADIO_SECURITY_DISABLED;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_SECURITY;

    // Call mode RADIO options
    CurrentID = IDC_RADIO_CALLMODE_DIRECT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_CALLING_MODE;

    CurrentID = IDC_RADIO_CALLMODE_GATEKEEPER;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_CALLING_MODE;


    // Gateway
    CurrentID = IDC_CHECK_GATEWAY;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_USE_H323_GATEWAY;

    CurrentID = IDC_EDIT_GATEWAY;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_H323_GATEWAY;

    // Gatekeeper addressing RADIO options
    CurrentID = IDC_RADIO_GKMODE_ACCOUNT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_GK_METHOD;

    CurrentID = IDC_RADIO_GKMODE_PHONE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_GK_METHOD;

    CurrentID = IDC_RADIO_GKMODE_BOTH;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_GK_METHOD;



    CurrentID = IDC_EDIT_GATEKEEPER;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_GK_SERVER;

    CurrentID = IDC_CHECK_NOCHANGECALLMODE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NOCHANGECALLMODE;

    // AV Throughput
    CurrentID = IDC_SLIDE_AV_THROUGHPUT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_MAX_BANDWIDTH;

    // AutoConf
    CurrentID = IDC_CHECK_AUTOCONFIG_CLIENTS;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_AUTOCONF_USE;

    CurrentID = IDC_AUTOCONF_URL;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_AUTOCONF_CONFIGFILE;
 
    // Network Speed RADIO options
    CurrentID = IDC_RADIO_NETSPEED_144;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_TYPICALBANDWIDTH;

    CurrentID = IDC_RADIO_NETSPEED_288;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_TYPICALBANDWIDTH;

    CurrentID = IDC_RADIO_NETSPEED_ISDN;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_TYPICALBANDWIDTH;

    CurrentID = IDC_RADIO_NETSPEED_LAN;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_TYPICALBANDWIDTH;

}

BOOL CPropertyDataWindow2::WriteToINF( HANDLE hFile, BOOL bCheckValues ) 
{
    list< UINT > condList;
    list< CControlID *>::const_iterator it;

    _WriteChecksToINF( hFile, bCheckValues );

    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        if( ms_ValueMap.find( (*it)->GetCondID() ) != ms_ValueMap.end() )
        {
            list< UINT >::const_iterator i;
            if( (i = find( condList.begin(), condList.end(), (*it)->GetCondID() ) ) == condList.end()  )
            {
                condList.push_front( (*it)->GetCondID() );
                _WriteCheckToINF( hFile, (*it)->GetCondID(), bCheckValues );
            }
        }

        if( bCheckValues)
        {
            bCheckValues = Button_GetCheck( (*it)->GetCondHwnd() );
        }
        switch( (*it)->GetType() )
        {
            case CControlID::STATIC:
                break;

            case CControlID::EDIT_NUM:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteEditNumToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::EDIT:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteEditToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::CHECK:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteCheckToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::COMBO:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteComboToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::SLIDER:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteSliderToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::WriteToINF: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        switch( (*it)->GetType() )
        {
            case CControlID::STATIC:
                break;

            case CControlID::EDIT_NUM:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteEditNumToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::EDIT:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteEditToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::CHECK:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteCheckToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::COMBO:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteComboToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::SLIDER:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteSliderToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::WriteToINF: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    return TRUE;
}

void CPropertyDataWindow2::_WriteCheckToINF( HANDLE hFile, UINT ID, BOOL bCheckValues ) 
{
    HWND    hwndButton;
    BOOL    fIsRadioButton;
    DWORD   dwWrite;

    hwndButton = GetDlgItem(m_hwnd, ID);
    switch (GetWindowLong(hwndButton, GWL_STYLE) & 0x0F)
    {
        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
            fIsRadioButton = TRUE;
            break;

        default:
            fIsRadioButton = FALSE;
            break;
    }

    if (bCheckValues && Button_GetCheck(hwndButton))
    {
        if (fIsRadioButton)
        {
            //
            // For radio buttons, real value is in user data
            //
            dwWrite = GetWindowLong(hwndButton, GWL_USERDATA);
        }
        else
        {
            dwWrite = TRUE;
        }

        CPolicyData(ms_ClassMap[ID], ms_KeyMap[ID], ms_ValueMap[ID], dwWrite).
            SaveToINFFile(hFile);
    }
    else 
    {
        //
        // If this is a radio button, do not write the unchecked ones out.
        //
        if (!fIsRadioButton)
        {
            dwWrite = FALSE;

            CPolicyData(ms_ClassMap[ ID ],
                        ms_KeyMap[ ID ],
                        ms_ValueMap[ ID ],
                        dwWrite).SaveToINFFile( hFile );
        }
    }
}


void CPropertyDataWindow2::_WriteChecksToINF( HANDLE hFile, BOOL bCheckValues ) 
{
    list< UINT >::const_iterator it;

    for (it = m_checkIDList.begin(); it != m_checkIDList.end(); it++)
    {
        if (ms_ValueMap.find(*it) != ms_ValueMap.end())
        {
            _WriteCheckToINF(hFile, *it, bCheckValues);
        }
    }
}


void CPropertyDataWindow2::_WriteEditNumToINF( HANDLE hFile, UINT EditID, BOOL bCheckValues )
{
    if( bCheckValues )
    {
        CPolicyData( ms_ClassMap[ EditID ],
                     ms_KeyMap[ EditID ],
                     ms_ValueMap[ EditID ],
                     (DWORD) GetDlgItemInt(  m_hwnd, EditID, NULL, FALSE ) ).SaveToINFFile( hFile );
    }
    else
    {
        _DeleteKey( hFile, EditID );
    }
}

void CPropertyDataWindow2::_WriteEditToINF( HANDLE hFile, UINT EditID, BOOL bCheckValues )
{
    if( bCheckValues )
    {
        int iLen = GetEditDataLen( EditID ) + 1;
        LPTSTR szData = new TCHAR[ iLen ];
        GetEditData( EditID, szData, iLen );

        CPolicyData( ms_ClassMap[ EditID ],
                     ms_KeyMap[ EditID ],
                     ms_ValueMap[ EditID ],
                     szData ).SaveToINFFile( hFile );
        delete [] szData;
    }
    else
    {
        _DeleteKey( hFile, EditID );
    }
}



void CPropertyDataWindow2::_WriteSliderToINF( HANDLE hFile, UINT SliderID, BOOL bCheckValues )
{
    if( bCheckValues )
    {
        int iPos;

        iPos = TrackBar_GetPos(GetDlgItem(m_hwnd, SliderID));
        iPos *= 1000;
        CPolicyData( ms_ClassMap[ SliderID ], 
                     ms_KeyMap[ SliderID ], 
                     ms_ValueMap[ SliderID ], 
                     (DWORD)iPos
                   ).SaveToINFFile( hFile );
    }
    else
    {
        _DeleteKey( hFile, SliderID );
    }
}

void CPropertyDataWindow2::_WriteComboToINF( HANDLE hFile, UINT ComboID, BOOL bCheckValues )
{
    if( bCheckValues )
    {
        HWND hwndCombo = GetDlgItem( m_hwnd, ComboID );

        CPolicyData( ms_ClassMap[ ComboID ], 
                 ms_KeyMap[ ComboID ], 
                 ms_ValueMap[ ComboID ], 
                 (DWORD) ComboBox_GetItemData( hwndCombo, ComboBox_GetCurSel( hwndCombo ) ) 
               ).SaveToINFFile( hFile );
    }
    else
    {
        _DeleteKey( hFile, ComboID );
    }
}

void CPropertyDataWindow2::_DeleteKey( HANDLE hFile, UINT ID ) 
{
    CPolicyData( ms_ClassMap[ ID ], 
                 ms_KeyMap[ ID ], 
                 ms_ValueMap[ ID ], 
                 CPolicyData::OpDelete()
               ).SaveToINFFile( hFile );

}

int CPropertyDataWindow2::Spew( HWND hwndList, int iStartLine )
{
    list< UINT >::const_iterator it;
    for( it = m_checkIDList.begin(); it != m_checkIDList.end(); it++ ) 
    {
        if( Button_GetCheck( GetDlgItem( m_hwnd, *it ) ) )
        {
            HWND hwndButton = GetDlgItem( m_hwnd, *it );
            // 2 is 1 for '\0' and 1 for '\t'
            int iButtonTextLen = Button_GetTextLength( hwndButton ) + 2;
            LPTSTR szButtonText = new TCHAR[ iButtonTextLen ];
            szButtonText[0] = '\t';
            Button_GetText( hwndButton, &(szButtonText[1]), iButtonTextLen - 1 );
            ListBox_InsertString( hwndList, iStartLine, szButtonText );
            iStartLine++;
        }
    }

    list< CControlID *>::const_iterator i;
    if( m_condList.size() )
    {
        for( i = m_condList.begin(); i != m_condList.end(); i++ )
        {
            if( Button_GetCheck( (*i)->GetCondHwnd() ) )
            {
                iStartLine = _Spew( hwndList, iStartLine, *i );
            }
        }
    }

    if( m_specialControlList.size() )
    {
        for( i = m_specialControlList.begin(); i != m_specialControlList.end(); i++ )
        {
            iStartLine = _Spew( hwndList, iStartLine, *i );
        }
    }

    return iStartLine;
}

int CPropertyDataWindow2::_Spew( HWND hwndList, int iStartLine, CControlID *pControlID )
{
    switch( pControlID->GetType() )
    {
        case CControlID::EDIT_NUM:
        case CControlID::EDIT:
        {
            int iEditLen = GetEditDataLen( pControlID->GetID() ) + 1;
            if( iEditLen )
            {
                int iLen = Button_GetTextLength( pControlID->GetCondHwnd() ) + 1;

                LPTSTR sz = new TCHAR[ iLen];
                Button_GetText( pControlID->GetCondHwnd(), sz, iLen );    

                LPTSTR szData = new TCHAR[ iEditLen];
                GetEditData( pControlID->GetID(), szData, iEditLen );

                // 2 is: 1 for ' ' and 1 for '\t'
                LPTSTR szBuff = new TCHAR[ iLen + iEditLen + 2];
                wsprintf( szBuff, TEXT("\t%s %s"), sz, szData );
                ListBox_InsertString( hwndList, iStartLine, szBuff );
                iStartLine++;
                delete [] szData;
                delete [] szBuff;
                delete [] sz;
            }
            break;
        }

        case CControlID::CHECK:
        {
            HWND hwnd = GetDlgItem( m_hwnd, pControlID->GetID() );
            if( Button_GetCheck( hwnd ) )
            {
                int iLen = Button_GetTextLength( hwnd ) + 2;

                LPTSTR sz = new TCHAR[ iLen];
                sz[0] = '\t';
                Button_GetText( hwnd, &sz[1], iLen );

                ListBox_InsertString( hwndList, iStartLine, sz );
                iStartLine++;

                delete [] sz;
            }
            break;
        }

        case CControlID::COMBO:
        {
            HWND hwnd = GetDlgItem( m_hwnd, pControlID->GetID() );
            int iCurSel = ComboBox_GetCurSel( hwnd );
            int iLen = ComboBox_GetLBTextLen( hwnd, iCurSel ) + 2;
            LPTSTR sz = new TCHAR[ iLen ];
            sz[0] = '\t';
            ComboBox_GetLBText( hwnd, iCurSel, &(sz[1]) );
    
            ListBox_InsertString( hwndList, iStartLine, sz );
            iStartLine++;

            delete [] sz;
            break;
        }

        case CControlID::SLIDER:
        {
            HWND hwnd = GetDlgItem( m_hwnd, pControlID->GetID() );
            TCHAR sz[ MAX_DIGITS ]; 
            wsprintf( sz, TEXT("\t%d kbits/s"), TrackBar_GetPos( hwnd ) );
    
            ListBox_InsertString( hwndList, iStartLine, sz );
            iStartLine++;

            break;
        }

        case CControlID::STATIC:
            break;

        default:
            OutputDebugString( TEXT("CPropertyDataWindow2::_Spew: unknown CControlID::type\n") );
            assert( 0 );
            break;
    }

    return iStartLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nmrk.rc
//
#define IDS_NOT_ENOUGH_SPACE_IN_FINAL   51
#define IDS_REMOVE_SERVER               52
#define IDS_EMPTY_SERVER                53
#define IDS_NMAKWIZ_ERROR_CAPTION       54
#define IDS_CANT_FIND_NETMEETING_ORIGINAL_DISTRIBUTION 55
#define IDS_CANT_FIND_NETMEETING_ORIGINAL_DISTRIBUTION_QUERY_ABORT 56
#define IDS_ERROR_MUST_SELECT_DISTRIBUTION_FOLDER 57
#define IDS_DLG_TITLE_SELECT_ROOT_FOLDER_FOR_DISTRIBUTION 58
#define IDC_SETTINGS_FILE               59
#define IDS_EDIT_WEBVIEW                59
#define IDE_SETTINGS_FILE               60
#define IDS_ERROR_NEEDALLFIELDS         60
#define IDC_BROWSE_SETTINGS_FILE        61
#define IDS_DEFAULT_WEBVIEW             61
#define IDS_NMAKWIZ_ERROR_NMRK_MUST_BE_PROPERLY_INSTALLED 62
#define IDS_NMAKWIZ_ERROR_PLEASE_REINSTALL_NET_MEETING_RESOURCE_KIT 63
#define IDS_SELECTED_PATH_DISTRO_IS_INVALID_PLEASE_CHANGE_THE_PATH_NAME_OR_BROWSE_FOR_A_NEW_PATH 64
#define IDS_YOU_DO_NOT_HAVE_WRITE_ACCESS_TO_THE_SELECTED_DISTRO_PATH_PLEASE_SELECT_A_PATH_IN_WHICH_YOU_HAVE_WRITE_PERMISSION 65
#define IDS_DO_YOU_REALLY_WANT_TO_QUIT_THE_WIZARD_NOW 66
#define IDS_MSG_CAPTION 67
#define IDS_REINSTALL_THE_NETMEETING_RESOURCE_KIT_AND_TRY_AGAIN 68
#define IDS_COULD_NOT_FIND_THE_TOOL     69
#define IDS_SUCCESSFULLY_CREATED        70
#define IDS_THERE_WAS_AN_UNEXPECTED_ERROR 71
#define IDS_DELETING_TEMPORARY_FILES_PROGRESS_TITLE 72
#define IDS_CREATING_CUSTOM_DISTRIBUTION 73
#define IDS_YOU_MUST_SELECT_AT_LEAST_ONE_DISTRIBUTION_TYPE 74
#define IDS_YOU_MUST_ENTER_AT_LEAST_ONE_DIRECTORY_SERVER 75
#define IDS_AUDIO_VIDEO_THROUGHPUT_VALUE_IS_INVALID 76
#define IDS_INVALID_DATA_ERROR          77
#define IDS_KBPS                        82
#define IDS_NMAKWIZ_VERIFY_CAPTION      83
#define IDS_SELECTED_PATH_HAS_TOO_MANY_CHARACTERS 86
#define IDS_NETMEETING_HOMEPAGE_IS_INVALID 87
#define IDS_GATEKEEPER_SERVER_IS_INVALID 88

#define IDD_PROPPAGE_DEFAULT            100
#define IDD_PROPPAGE_WELCOME            101
#define IDD_CHILDPAGE_ILSGATEWAY        102
#define IDD_CHILDPAGE_GATEKEEPER        103
#define IDD_FILEPANE_INTRO              104
#define IDD_FILEPANE_SUMMARY            105
#define IDD_FILEPANE_DISTRO             106
#define IDD_FILEPANE_AUTOCONF           107
#define IDD_FILEPANE_SETTINGS           108

#define IDS_FT_THROUGHPUT_VALUE_IS_INVALID 119
#define IDS_SHOW_ONLINE_SUPPORT_PAGE    120
#define IDS_MUST_ENTER_DISTRONAME       121
#define IDS_CREATE_AUTOCONF_DIRECTORY   122
#define IDS_NOT_ENOUGH_SPACE_IN_TEMP_DIR 123
#define IDS_CREATE_DIRECTORY            124
#define IDS_SELECTED_PATH_IS_INVALID_PLEASE_CHANGE_THE_PATH_NAME_OR_BROWSE_FOR_A_NEW_PATH 125
#define IDS_YOU_DO_NOT_HAVE_WRITE_ACCESS_TO_THE_SELECTED_PATH_PLEASE_SELECT_A_PATH_IN_WHICH_YOU_HAVE_WRITE_PERMISSION 126
#define IDS_MUST_ENTER_AUTOCONF_NAME    127
#define IDS_AUTHSERVER_URL              129
#define IDS_CAPTION_AUTHSERVER_URL      130
#define IDS_AUTHENTICATION_URL_IS_INVALID 131
#define IDS_NEED_CONF_SERVER            132
#define IDS_TURNING_OFF_AUTOCONF        133
#define IDS_ERASE_ALL_SETTINGS          134
#define IDS_WEBDIR_AUTOADD              135
#define IDS_DSLIST_EMPTY                136
#define IDS_DS_WILL_BE_EMPTY            137
#define IDS_DSNAME_INVALID              138
#define IDS_ARE_YOU_SURE_YOU_WISH_TO_REMOVE 139
#define IDS_VERIFY                      140
#define IDD_DIALOG_EDIT_SERVERNAME      150
#define IDI_ICON2                       153
#define IDD_FILETRANSFER                168
#define IDD_CATEGORY_LIST               169
#define IDD_AUDIO                       171
#define IDD_VIDEO                       172
#define IDD_SECURITY                    173
#define IDD_RDS                         174
#define IDD_CHAT                        175
#define IDD_WHITEBOARD                  176
#define IDD_ONLINE_SUPPORT              180
#define IDD_OPTIONS_DIALOG              181
#define IDC_DISABLE_AUTOACCEPT          182
#define IDC_DISABLE_WEBDIR              183
#define IDC_DISABLE_WEBDIR_GK           184
#define IDD_LIMIT_AV_THROUGHPUT         185
#define IDC_PERSIST_AUTOACCEPT          186
#define IDD_SHARING                     197
#define IDB_BITMAP1                     215
#define IDD_SET_CALLING_OPTIONS         219
#define IDD_DIALOG_EDIT_WEBVIEW         220
#define IDC_CHECK_CREATE_DISTRIBUTION   1005
#define IDC_PREVENT_THE_USER_FROM_SENDING_FILES 1006
#define IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER 1007
#define IDC_PREVENT_THE_USER_FROM_USING_AUDIO 1008
#define IDC_DISABLE_SENDING_VIDEO       1009
#define IDC_CHECK_AUTOCONFIG_CLIENTS    1011
#define IDC_PREVENT_THE_USER_FROM_RECEIVING_FILES 1012
#define IDC_RESTRICT_THE_USE_OF_SHARING 1013
#define IDC_RESTRICT_THE_USE_OF_RDS     1014
#define IDC_DISABLE_RECIEVING_VIDEO     1015
#define IDC_DISABLE_RDS_ON_ALL          1016
#define IDC_DISABLE_RDS_ON_WIN9X        1017
#define IDC_MAXIMUM_SIZE_OF_SENT_FILES  1018
#define IDC_RESTRICT_THE_USE_OF_AUDIO   1019
#define IDC_ENABLE_DIRECT_SOUND         1020
#define IDC_DISABLE_FULL_DUPLEX_AUDIO   1021
#define IDC_CREATE_AN_AUDIO_LOG_FILE    1022
#define IDC_DISABLE_ALL_SHARING_FEATURES    1023
#define IDC_PREVENT_SHARING             1024
#define IDC_PREVENT_SHARING_DESKTOP     1025
#define IDC_PREVENT_SHARING_EXPLORER    1026
#define IDC_PREVENT_SHARING_DOS         1027
#define IDC_PREVENT_SHARING_CONTROL     1028
#define IDC_PREVENT_SHARING_TRUECOLOR   1029
#define IDC_RESTRICT_THE_USE_OF_WHITEBOARD  1030
#define IDC_DISABLE_2XWHITEBOARD        1031
#define IDC_DISABLE_WHITEBOARD          1032
#define IDC_NOCHANGE_DIRECT_SOUND       1033
#define IDC_EDIT_DISTRIBUTION_FILE_PATH 1044
#define IDC_EDIT_AUTO_CONFIG_FILE_PATH  1046
#define IDC_STATIC_DISTRIBUTION_FILE_PATH_EDIT_CAPTION 1047
#define IDC_AUTO_CONFIG_FILE_PATH_EDIT_CAPTION 1049
#define IDC_AUTO_CONFIG_FILE_PATH_EDIT_CAPTION2 1050
#define IDC_BUTTON_BROWSE_DISTRIBUTION_FILE_PATH 1053
#define IDC_BUTTON_BROWSE_AUTO_CONFIG_PATH 1055
#define IDC_BUTTON_UP                   1057
#define IDC_BUTTON_ADDDIRECTORYSERVER   1059
#define IDC_BUTTON_EDIT                 1061
#define IDC_EDIT_SERVER_NAME            1062
#define IDC_BUTTON_REMOVE               1063
#define IDC_EDIT_DISPLAY_NAME           1063
#define IDC_EDIT_URL_NAME               1064
#define IDC_BUTTON_DOWN                 1065
#define IDC_BUTTON_SET_AS_DEFAULT       1067
#define IDC_RADIO_LOAD_SAVED_CONFIG     1068
#define IDC_RADIO_START_FROM_SCRATCH    1069
#define IDE_SAVED_CONFIG_FILE           1070
#define IDC_BROWSE_CONFIG_FILE          1071
#define IDC_STATIC2                     1072
#define IDC_STATIC3                     1073
#define IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES 1074
#define IDC_STATIC1                     1075
#define IDC_RESTRICT_THE_USE_OF_VIDEO   1076
#define IDC_SET_SECURITY_OPTIONS        1077

#define IDC_RADIO_SECURITY_FIRST        1078
#define IDC_RADIO_SECURITY_DEFAULT      (IDC_RADIO_SECURITY_FIRST)
#define IDC_RADIO_SECURITY_REQUIRED     (IDC_RADIO_SECURITY_FIRST+1)
#define IDC_RADIO_SECURITY_DISABLED     (IDC_RADIO_SECURITY_FIRST+2)
#define IDC_RADIO_SECURITY_MAX          (IDC_RADIO_SECURITY_FIRST+3)

#define IDC_STATIC4                     1089
#define IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS 1090
#define IDC_RESTRICT_THE_USE_OF_DIRECTORY_SERVICES 1091
#define IDC_DISABLE_CHAT                1092
#define IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE 1094
#define IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE 1095
#define IDC_SHOW_THE_ONLINE_SUPPORT_PAGE_THE_FIRST_TIME_NETMEETING_STARTS 1096
#define IDC_ONLINE_SUPPORT              1097
#define IDC_DISABLE_THE_GENERAL_OPTIONS_PAGE 1098
#define IDC_DISABLE_THE_SECURITY_OPTIONS_PAGE 1099
#define IDC_DISABLE_THE_AUDIO_OPTIONS_PAGE 1100
#define IDC_DISABLE_THE_VIDEO_OPTIONS_PAGE 1101
#define IDC_DISABLE_THE_ADVANCED_CALLING_BUTTON    1102
#define IDC_RESTRICT_USE_OF_THE_OPTIONS_DIALOG 1104
#define IDC_SET_CALLING_OPTIONS         1109
#define IDC_SLIDE_AV_THROUGHPUT         1114
#define IDC_STATIC_MAX_AV_THROUGHPUT    1115
#define IDC_LIMIT_AV_THROUGHPUT         1116
#define IDC_LIST_SETTINGS               1117
#define IDC_CREATE_CONFIGURATION_SUMMARY_FILE 1118
#define IDC_CONFIGURATION_SUMMARY_PATH  1119
#define IDC_BROWSE_CONFIGURATION_SUMMARY 1120
#define IDC_EDIT_NEW_SERVER             1122
#define IDC_LIST_SERVERS                1123
#define IDC_AUTOCONF_URL                1124

// These are RADIO items, keep contiguous
#define IDC_RADIO_NETSPEED_FIRST        1125
#define IDC_RADIO_NETSPEED_144          (IDC_RADIO_NETSPEED_FIRST)
#define IDC_RADIO_NETSPEED_288          (IDC_RADIO_NETSPEED_FIRST+1)
#define IDC_RADIO_NETSPEED_ISDN         (IDC_RADIO_NETSPEED_FIRST+2)
#define IDC_RADIO_NETSPEED_LAN          (IDC_RADIO_NETSPEED_FIRST+3)
#define IDC_RADIO_NETSPEED_MAX          (IDC_RADIO_NETSPEED_FIRST+4)

#define IDC_NETWORK_SPEED               1132

// These are RADIO items, keep contiguous
#define IDC_RADIO_GKMODE_FIRST          1140
#define IDC_RADIO_GKMODE_PHONE          (IDC_RADIO_GKMODE_FIRST)
#define IDC_RADIO_GKMODE_ACCOUNT        (IDC_RADIO_GKMODE_FIRST+1)
#define IDC_RADIO_GKMODE_BOTH           (IDC_RADIO_GKMODE_FIRST+2)
#define IDC_RADIO_GKMODE_MAX            (IDC_RADIO_GKMODE_FIRST+3)

#define IDC_DROP_NAME                   1149
#define IDC_DROP_EMAIL                  1150
#define IDC_DROP_PHONENUM               1151
#define IDC_DROP_LOCATION               1152
#define IDC_DROP_COMMENTS               1153
#define IDC_DROP_SURNAME                1154
#define IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES 1160
#define IDC_STATIC_NAME                 1163
#define IDC_STATIC_SUR_NAME             1164
#define IDC_STATIC_EMAIL                1165
#define IDC_STATIC_LOCATION             1166
#define IDC_STATIC_PHONENUM             1167
#define IDC_STATIC_COMMENTS             1168
#define IDC_DROP_VALUES                 1171

// These are RADIO items, keep continugous
#define IDC_RADIO_CALLMODE_FIRST              1172
#define IDC_RADIO_CALLMODE_DIRECT             (IDC_RADIO_CALLMODE_FIRST)
#define IDC_RADIO_CALLMODE_GATEKEEPER         (IDC_RADIO_CALLMODE_FIRST+1)
#define IDC_RADIO_CALLMODE_MAX                (IDC_RADIO_CALLMODE_FIRST+2)

#define IDC_CHECK_GATEKEEPER            1180
#define IDC_EDIT_GATEKEEPER             1181
#define IDC_CHECK_GATEWAY               1182
#define IDC_EDIT_GATEWAY                1183

#define IDC_CHECK_NOCHANGECALLMODE            1187
#define IDC_CHECK_MUTE_SPEAKER_BY_DEFAULT 1190
#define IDC_CHECK_MUTE_MICROPHONE_BY_DEFAULT 1191
#define IDC_REQUIRE_COMPLETE_AUTHENTICATION 1192
#define IDC_SET_RDN_FOR_REQUIRED_CA 1193
#define IDC_EDIT_SET_RDN_FOR_REQUIRED_CA 1194
#define IDC_BUTTON_SET_WEBVIEW          1195

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        220
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1195
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\propwnd2.h ===
#ifndef __PropWnd2_h__
#define __PropWnd2_h__

////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4786 )
#include <list>
#include <map>
#include "poldata.h"
#include "controlID.h"
using namespace std;
////////////////////////////////////////////////////////////////////////////////////////////////////


LRESULT CALLBACK DefaultProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

class CPropertyDataWindow2 
{
friend class CNmAkWiz;

public: // Static functions
	static void MapControlsToRegKeys( void );

private: // Static functions
	

public: // Static Data
	static const int mcs_iTop;
	static const int mcs_iLeft;
	static const int mcs_iBorder;

protected: // Static Data
	static  map< UINT, CPolicyData::eKeyType > ms_ClassMap;
	static  map< UINT, TCHAR* > ms_KeyMap;
	static  map< UINT, TCHAR* > ms_ValueMap;
	
protected:    // DATA

    // Frame Window for data boxes
	TCHAR					*m_szClassName;
    HWND                    m_hwnd;
	HWND					m_hwndParent;
	UINT					m_IDD;
	WNDPROC					m_wndProc;
	RECT					m_rect;

	list< UINT >			m_checkIDList;
	list< HWND >			m_enableList;
	list< CControlID * >	m_condList;
	list< CControlID * >    m_specialControlList;
	BOOL					m_bInit;

public: // construction / destruction
	CPropertyDataWindow2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, WNDPROC wndProc, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll = TRUE );
	CPropertyDataWindow2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll = TRUE );
    ~CPropertyDataWindow2( void );
        
public: // Member fns
	inline HWND GetHwnd() { return m_hwnd; };
	inline int LoadString( UINT IDS, LPTSTR lpszBuffer, int cb ) { return ::LoadString( g_hInstance, IDS, lpszBuffer, cb ); }

	void ConnectControlsToCheck( UINT idCheck, UINT uCount, ... );
	void AddControl( CControlID *pControl );
	void SetEnableListID( UINT uCount, ... );

    void GetEditData( UINT id, TCHAR* sz, ULONG cb ) const;
    void SetEditData( UINT id, TCHAR* sz );
	ULONG GetEditDataLen( UINT id ) const;
    
	BOOL SetFocus( UINT id );

    BOOL GetCheck( UINT id ) const;
	void SetCheck( UINT id, BOOL bCheck );

	void ShowWindow( BOOL bShowWindow = TRUE );
	void EnableWindow( BOOL bEnable = TRUE );

	void ReadSettings( void );
	BOOL WriteSettings( void );
	void Reset();

	BOOL WriteToINF( HANDLE hFile, BOOL bCheckValues );

	int Spew( HWND hwndList, int iStartLine );

protected: // Helper Fns
    BOOL _InitWindow( void );
	BOOL _SizeWindow( int X, int Y, int Width, int Height );
	void _PrepScrollBars( void );

	void _ReadIntSetting( UINT ID, int *pData );
	void _ReadEditSetting( UINT EditID );
	void _ReadCheckSetting( UINT ID);
	void _ReadComboSetting( UINT ComboID );
	void _ReadSliderSetting( CControlID * );
	void _ReadCheckSettings( void );

	BOOL _WriteIntSetting(UINT ID, int iData);
	BOOL _WriteEditSetting( UINT EditID );
	BOOL _WriteCheckSetting( UINT ID);
	BOOL _WriteComboSetting( UINT ComboID );
	BOOL _WriteSliderSetting( UINT ID );
	BOOL _WriteCheckSettings( void );

	// We need these friends so that the WebView data can be shared
	friend void ReadWebViewSettings(CPropertyDataWindow2 *pData);
	friend void WriteWebViewSettings(CPropertyDataWindow2 *pData);

    BOOL    WriteStringValue(LPCTSTR szKeyName, LPCTSTR szValue);
    BOOL    WriteNumberValue(LPCTSTR szKeyName, int nValue);
    void    ReadStringValue(LPCTSTR szKeyName, LPTSTR szValue, UINT cchValueMax);
    void    ReadNumberValue(LPCTSTR szKeyName, int * pnValue);


	void _WriteCheckToINF( HANDLE hFile, UINT ID, BOOL bCheckValues );
	void _WriteChecksToINF( HANDLE hFile, BOOL bCheckValues );
	void _WriteEditToINF( HANDLE hFile, UINT EditID, BOOL bCheckValues );
	void _WriteEditNumToINF( HANDLE hFile, UINT EditID, BOOL bCheckValues );
	void _WriteSliderToINF( HANDLE hFile, UINT SliderID, BOOL bCheckValues );
	void _WriteComboToINF( HANDLE hFile, UINT ComboID, BOOL bCheckValues );
	void _DeleteKey( HANDLE hFile, UINT ID );

	int _Spew( HWND hwndList, int iStartLine, CControlID *pControlID );

};

#endif // __PropWnd_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\setinsht.h ===
#ifndef __SetInSht_h__
#define __SetInSht_h__

#include "filepane.h"

class CIntroSheet
{
friend class CNmAkWiz;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );
    static CIntroSheet* ms_pIntroSheet;

    CFilePanePropWnd2 *         m_pFilePane;
    CPropertySheetPage          m_PropertySheetPage;
	BOOL				        m_bBeenToNext;

public: 
    CIntroSheet(void);
    ~CIntroSheet(void);
    void                _CreateFilePane(HWND hDlg);
    CFilePanePropWnd2 * GetFilePane() { return m_pFilePane; }

private:
    LPCPROPSHEETPAGE    GetPropertySheet( void ) const { return &m_PropertySheetPage;}
};

#endif // __SetInSht_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\setinsht.cpp ===
#include "precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
#include "SetInSht.h"
#include "nmakwiz.h"
#include "nmakreg.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CIntroSheet* CIntroSheet::ms_pIntroSheet = NULL;


CIntroSheet::CIntroSheet( void ) :
    m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						CIntroSheet::DlgProc
                       ),
    m_bBeenToNext( FALSE ),
    m_pFilePane(NULL)
{    
    ms_pIntroSheet = this;
}


CIntroSheet::~CIntroSheet(void) 
{
    delete m_pFilePane;
    m_pFilePane = NULL;

    ms_pIntroSheet = NULL;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

INT_PTR CALLBACK CIntroSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {

    switch( message )
    {
		case WM_INITDIALOG:
        {
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
            ms_pIntroSheet->_CreateFilePane(hDlg);
			return TRUE;

        }

		case WM_NOTIFY:
        {
			switch( reinterpret_cast< NMHDR FAR* >( lParam )->code )
            {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
                    return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                	PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                    ms_pIntroSheet->m_pFilePane->Validate(FALSE);
			        return TRUE;

				case PSN_WIZNEXT:
                    if (!ms_pIntroSheet->m_pFilePane->Validate(TRUE))
                    {
                        SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                        return TRUE;
                    }

					if (ms_pIntroSheet->m_bBeenToNext)
					{
						g_pWiz->m_SettingsSheet.PrepSettings();
                        g_pWiz->m_CallModeSheet.PrepSettings();
					}

					ms_pIntroSheet->m_bBeenToNext = TRUE;
                    break;
			}
            break;
        }

        default:
            break;
	}

	return FALSE;
}



//
// _CreateFilePane()
//
void CIntroSheet::_CreateFilePane(HWND hDlg)
{
    RECT    rect;

    GetClientRect(hDlg, &rect);
    int iHeight = rect.bottom - rect.top;
    int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;

    m_pFilePane = new CFilePanePropWnd2(hDlg, IDD_FILEPANE_INTRO,
        TEXT("IDD_FILEPANE_INTRO"), 0, CPropertyDataWindow2::mcs_iLeft,
        CPropertyDataWindow2::mcs_iTop, iWidth, iHeight);

    HWND hwndCond = GetDlgItem(m_pFilePane->GetHwnd(), IDC_RADIO_LOAD_SAVED_CONFIG);
    m_pFilePane->ConnectControlsToCheck(IDC_RADIO_LOAD_SAVED_CONFIG, 2,
            new CControlID(hwndCond, IDC_RADIO_LOAD_SAVED_CONFIG,
                    IDE_SAVED_CONFIG_FILE,
                    CControlID::EDIT),
            new CControlID(hwndCond, IDC_RADIO_LOAD_SAVED_CONFIG,
                    IDC_BROWSE_CONFIG_FILE,
                    CControlID::CHECK));

    m_pFilePane->SetFilePane(TRUE, IDE_SAVED_CONFIG_FILE,
        IDC_RADIO_LOAD_SAVED_CONFIG, IDC_BROWSE_CONFIG_FILE,
        TEXT("Configuration File (*.ini)"),
        TEXT(".ini"), TEXT("Nm3c.ini"));

    //
    // Get last edited/saved config from registry
    //
    HKEY    hKey;
    TCHAR   szFile[MAX_PATH];

    szFile[0] = 0;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_NMRK, &hKey) == ERROR_SUCCESS)
    {
        DWORD   dwType;
        DWORD   cb;

        dwType  = REG_SZ;
        cb      = sizeof(szFile);

        RegQueryValueEx(hKey, REGVAL_LASTCONFIG, NULL, &dwType, (LPBYTE)szFile,
            &cb);
    }

    Edit_SetText(GetDlgItem(m_pFilePane->GetHwnd(), IDE_SAVED_CONFIG_FILE), szFile);
    m_pFilePane->ShowWindow(TRUE);
    m_pFilePane->SetCheck(IDC_RADIO_START_FROM_SCRATCH, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\setsht.h ===
#ifndef __SetSht_h__
#define __SetSht_h__

////////////////////////////////////////////////////////////////////////////////////////////////////

//#pragma warning( disable : 4786 )
#include <map>
using namespace std;
#include "PropWnd2.h"


////////////////////////////////////////////////////////////////////////////////////////////////////

class CSettingsSheet {
 
private:
		// Static Data
    static CSettingsSheet* ms_pSettingsSheet;

    static map< UINT, CPropertyDataWindow2* > ms_PropertyWindows;
	static map< UINT, HWND >				  ms_FocusList;
	static list< UINT > ms_CategoryIDList;
		
		// Static fns
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );


private: // DATA
    CPropertySheetPage		m_PropertySheetPage;
	CPropertyDataWindow2*	m_pCategoryList;
    HWND                    m_hWndDlg;
	UINT					m_uPropWndShowing;

public: 
    CSettingsSheet( void );
    ~CSettingsSheet( void );

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}

	inline CPropertyDataWindow2* GetPropWnd( UINT idCategory ) { return ms_PropertyWindows[ idCategory ]; }
	inline HWND GetHwnd( UINT idCategory ) const { return ms_PropertyWindows[ idCategory ] -> GetHwnd(); }
	LPTSTR GetStringData( UINT idCategory, UINT idEdit, LPTSTR* sz );

	inline CPropertyDataWindow2* GetCatWnd() { return m_pCategoryList; }
	inline BOOL GetCategoryCheck( UINT idCategory ) { return m_pCategoryList -> GetCheck( idCategory ); }
	inline void SetCategoryCheck( UINT idCategory, BOOL bSet ) { m_pCategoryList -> SetCheck( idCategory, bSet ); }

	BOOL GetCheckData( UINT idCategory, UINT idCheck );
	BOOL SetCheckData( UINT idCategory, UINT idCheck, BOOL bSet );

	void EnableWindow( UINT idCategory, BOOL bShow );
	BOOL IsShowing( UINT idCategory );
	void ShowWindow( UINT idCategory, BOOL bShow );
	void ShowWindow( HWND hWnd, BOOL bShow );

	void PrepSettings(void);
	void WriteSettings( void );

	void WriteToINF( HANDLE hFile );

	int SpewToListBox( HWND hwndList, int iStartLine ) ;
	void SetFocus( UINT catID );
	
	static bool IsGateKeeperModeSelected(void);

private:
	void _KillPropertyDataWindows( void );
	BOOL _InitWindows( void );
	BOOL _AddPropertyDataWindows( int iX, int iY, int iWidth, int iHeight );
	BOOL _IsDataValid( void );
	void _SetButtons( void );
	void _ReadSettings( void );
	BOOL _INFComment( HANDLE hFile, LPCTSTR sz );
};
#endif // __SetSht_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\util.cpp ===
#include "precomp.h"
#include "util.h"


void ErrorMessage( void ) {
    ErrorMessage( "", GetLastError() );
}

void ErrorMessage( LPCTSTR str, HRESULT hr ) {

#ifdef _DEBUG

	void* pMsgBuf;

	::FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		hr,
		MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
		(LPTSTR ) &pMsgBuf,
		0,
		NULL
	);

	OutputDebugString( str );
	if( NULL != pMsgBuf ) {
		OutputDebugString( (LPTSTR ) pMsgBuf );
	}

	LocalFree( pMsgBuf );
#endif _DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\setsht.cpp ===
#include "precomp.h"
#include "resource.h"
#include <algorithm>
#include "global.h"
#include "PropPg.h"
#include "SetSht.h"
#include "WndProcs.h"
#include "nmakwiz.h"
#include "nmakreg.h"
#include <common.h>

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CSettingsSheet* CSettingsSheet::ms_pSettingsSheet = NULL;

// This is a map to keep track of the PropertyDataWindows
/* static */ map<UINT, HWND> CSettingsSheet::ms_FocusList;
/* static */ map< UINT, CPropertyDataWindow2* > CSettingsSheet::ms_PropertyWindows;
/* static */ list< UINT > CSettingsSheet::ms_CategoryIDList;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns


/* static */ INT_PTR CALLBACK CSettingsSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {

    BOOL bRetval;
    NMHDR FAR* pnmhdr;
    
    switch( message ) {
        case WM_INITDIALOG:
            ms_pSettingsSheet->m_hWndDlg = hDlg;
            ms_pSettingsSheet->_InitWindows();
            ms_pSettingsSheet->PrepSettings();
            ms_pSettingsSheet->_SetButtons();
            return TRUE;

        case WM_CHAR:
        case WM_KEYDOWN:
            return FALSE;

        case WM_NOTIFY:
            pnmhdr = reinterpret_cast< NMHDR FAR* >( lParam ); 
            switch( pnmhdr -> code ) {

                case PSN_QUERYCANCEL: 
                    SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
                    return TRUE;
                    break;
                    
                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    ms_pSettingsSheet->_SetButtons();
                    return TRUE;
                    break;

                case PSN_WIZNEXT:
                    if( !ms_pSettingsSheet -> _IsDataValid() )
                    { 
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1); 
                    }

                    return TRUE;
                    break;

                case PSN_WIZBACK:
                {
                    int iRet = NmrkMessageBox(MAKEINTRESOURCE(IDS_ERASE_ALL_SETTINGS),
                        NULL, MB_YESNO | MB_ICONQUESTION );
                    if( IDNO == iRet )
                    {
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                    }
                    return TRUE;
                    break;
                }
             }
            break;

         default:
            break;

    }

    return FALSE;

}


/* static */ bool CSettingsSheet::IsGateKeeperModeSelected(void)
{
    bool bRet = false;
    
    if( ms_pSettingsSheet )
    {
        if( ms_pSettingsSheet->GetCategoryCheck( IDC_SET_CALLING_OPTIONS ) )
        {
            if( ms_pSettingsSheet->GetCheckData( IDC_SET_CALLING_OPTIONS, IDC_RADIO_CALLMODE_GATEKEEPER ) )
            {
                bRet = TRUE;
            }
        }
    }
        
    return bRet;

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CSettingsSheet::CSettingsSheet( void )
    : m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
                            CSettingsSheet::DlgProc ),
    m_uPropWndShowing( 0 )
{    
    if( NULL == ms_pSettingsSheet ) { ms_pSettingsSheet = this; }
}

CSettingsSheet::~CSettingsSheet( void ) 
{ 
    _KillPropertyDataWindows();
}

void CSettingsSheet::SetFocus( UINT catID )
{
    map< UINT, HWND >::iterator I = ms_FocusList.find( catID );
    if( I != ms_FocusList.end() )
    {
        ::SetFocus( (*I).second );
    }
}

// Allocates the memory needed!!!
// User must dealloc
LPTSTR CSettingsSheet::GetStringData( UINT idCategory, UINT idEdit, LPTSTR *sz ) 
{
    *sz = NULL;
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) 
    {
        ULONG uLen = ( *I ) . second -> GetEditDataLen( idEdit );
        if( !uLen )
        {
            return NULL;
        }
        *sz = new TCHAR[ uLen + 1];
        ( *I ) . second -> GetEditData( idEdit, *sz, uLen + 1 );
        return *sz;
    }
    
    return NULL;
}

BOOL CSettingsSheet::SetCheckData( UINT idCategory, UINT idCheck, BOOL bSet )
{

    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) {
        ( *I ) . second -> SetCheck( idCheck, bSet );
        return TRUE;
    }

    return FALSE;
}

BOOL CSettingsSheet::GetCheckData( UINT idCategory, UINT idCheck ) 
{

    if( FALSE == m_pCategoryList -> GetCheck( idCategory ) ) {
        return FALSE;
    }
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) {
        return ( *I ) . second -> GetCheck( idCheck );
    }

    return FALSE;
}

void CSettingsSheet::EnableWindow( UINT idCategory, BOOL bShow )
{
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) {
        ( *I ) . second -> EnableWindow( bShow );
    }
    else
    {
        OutputDebugString( TEXT("Error in CSettingsSheet::EnableWindow") );
    }
}

BOOL CSettingsSheet::IsShowing( UINT idCategory )
{
    return( idCategory == m_uPropWndShowing );
}

void CSettingsSheet::ShowWindow( UINT idCategory, BOOL bShow )
{
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) {
        if( 0 != m_uPropWndShowing )
        {
            map< UINT, CPropertyDataWindow2* >::iterator it = ms_PropertyWindows . find( m_uPropWndShowing );
            (*it).second-> ShowWindow( FALSE );
            SetWindowLong( GetDlgItem( m_pCategoryList->GetHwnd(), m_uPropWndShowing), GWL_USERDATA, 0 );
        }
        ( *I ) . second -> ShowWindow( bShow );
        m_uPropWndShowing = idCategory;
    }
}

void CSettingsSheet::ShowWindow( HWND hWnd, BOOL bShow )
{
    ShowWindow( GetWindowLong( hWnd, GWL_ID ), bShow );
}

void CSettingsSheet::_KillPropertyDataWindows( void ) 
{
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . begin();
    while( I != ms_PropertyWindows . end() ) {
        delete ( *I ) . second;
        I++;
    }

    ms_PropertyWindows . erase( ms_PropertyWindows . begin(), ms_PropertyWindows . end() );

    // TODO - This is being deleted else where... I should find where
//    delete m_pCategoryList;
}

BOOL CSettingsSheet::_InitWindows(void) 
{
    int iTotal = 9;
    int iFractionTop = 4;
    RECT rect;
    GetClientRect( m_hWndDlg, &rect );
    int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft - 
        CPropertyDataWindow2::mcs_iBorder;
    int iHeight = MulDiv( (rect.bottom - CPropertyDataWindow2::mcs_iBorder ), iFractionTop, iTotal );
    m_pCategoryList = new CPropertyDataWindow2( m_hWndDlg,
                                                IDD_CATEGORY_LIST,
                                                TEXT("IDD_CATEGORY_LIST"),
                                                CatListWndProc,
                                                0,
                                                CPropertyDataWindow2::mcs_iLeft,
                                                CPropertyDataWindow2::mcs_iTop, 
                                                iWidth,
                                                iHeight
                                               );
    m_pCategoryList -> ShowWindow( TRUE );
    if( !_AddPropertyDataWindows( CPropertyDataWindow2::mcs_iLeft,
                                    CPropertyDataWindow2::mcs_iTop + iHeight + CPropertyDataWindow2::mcs_iBorder,
                                    iWidth,
                                    MulDiv( (rect.bottom - CPropertyDataWindow2::mcs_iBorder ), iTotal - iFractionTop, iTotal ) ) ) 
    { 
        return FALSE; 
    }
  
    return TRUE;
}

void CSettingsSheet::PrepSettings()
{
	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
    {
        _ReadSettings();
    }
    else
    {
        m_pCategoryList->Reset();
        for( map< UINT, CPropertyDataWindow2* >::const_iterator it = ms_PropertyWindows.begin();
        it != ms_PropertyWindows.end();
        it++ )
        {
            (*it).second->Reset();
        }
    }
}

void CSettingsSheet::_ReadSettings()
{
    for( map< UINT, CPropertyDataWindow2* >::const_iterator it = ms_PropertyWindows.begin();
        it != ms_PropertyWindows.end();
        it++ )
    {
        (*it).second->ReadSettings();
    }
    
    m_pCategoryList->ReadSettings();

    for( list< UINT >::const_iterator i = ms_CategoryIDList.begin();
        i != ms_CategoryIDList.end();
        i++ )
    {
        if( GetCategoryCheck( *i ) )
        {
            ms_PropertyWindows[ *i ]->EnableWindow( TRUE );
        }
    }
}


void CSettingsSheet::WriteSettings()
{
    for( map< UINT, CPropertyDataWindow2* >::const_iterator it = ms_PropertyWindows.begin();
        it != ms_PropertyWindows.end();
        it++ )
    {
        (*it).second->WriteSettings();
    }
    
    m_pCategoryList->WriteSettings();
}

void CSettingsSheet::WriteToINF( HANDLE hFile )
{
    CPropertyDataWindow2::MapControlsToRegKeys();

    _INFComment( hFile, TEXT("Categories") );
    m_pCategoryList->WriteToINF( hFile, TRUE );

    for( map< UINT, CPropertyDataWindow2* >::const_iterator it = ms_PropertyWindows.begin();
        it != ms_PropertyWindows.end();
        it++ )
    {
        {
            HWND hwnd = GetDlgItem( m_pCategoryList->GetHwnd(), (*it).first );
            int iLen = Button_GetTextLength( hwnd ) + 1;
            LPTSTR szButtonText = new TCHAR[ iLen ];
            Button_GetText( hwnd, szButtonText, iLen );

            _INFComment( hFile, szButtonText );

            delete [] szButtonText;
        }

        (*it).second->WriteToINF( hFile, GetCategoryCheck( (*it).first ) );
    }
}

BOOL CSettingsSheet::_INFComment( HANDLE hFile, LPCTSTR sz )
{
#if _NMAKUSEINFCOMMENTS
    DWORD dwWritten;
    WriteFile( hFile, (void *)TEXT(";;"), lstrlen( TEXT(";;") ), &dwWritten, NULL );
    WriteFile( hFile, (void *)sz, lstrlen( sz ), &dwWritten, NULL );
    return WriteFile( hFile, (void *)TEXT("\r\n"), lstrlen( TEXT("\r\n") ), &dwWritten, NULL );
#else
    return 0;
#endif
}

BOOL CSettingsSheet::_AddPropertyDataWindows( int iX, int iY, int iWidth, int iHeight ) 
{

    UINT ItemID;
    CPropertyDataWindow2* pPropDataWnd;

    _KillPropertyDataWindows();

    //
    // CALLING
    //
////////
    ItemID = IDC_SET_CALLING_OPTIONS;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_SET_CALLING_OPTIONS, TEXT("IDD_SET_CALLING_OPTIONS"),
                                0, iX, iY, iWidth, iHeight );
    {
        // Calling method radio buttons
        HWND hwnd;

        // DIRECT radio item is default CALLING_MODE
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_CALLMODE_DIRECT );
        SetWindowLong( hwnd, GWL_USERDATA, CALLING_MODE_DIRECT );
        Button_SetCheck(hwnd, BST_CHECKED);

        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_CALLMODE_GATEKEEPER );
        SetWindowLong( hwnd, GWL_USERDATA, CALLING_MODE_GATEKEEPER );

        // Netspeed radio buttons
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_NETSPEED_144 );
        SetWindowLong( hwnd, GWL_USERDATA, BW_144KBS );

        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_NETSPEED_288 );
        SetWindowLong( hwnd, GWL_USERDATA, BW_288KBS );

        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_NETSPEED_ISDN );
        SetWindowLong( hwnd, GWL_USERDATA, BW_ISDN );

        // LAN radio item is default NETSPEED
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_NETSPEED_LAN );
        SetWindowLong( hwnd, GWL_USERDATA, BW_MOREKBS );
        Button_SetCheck(hwnd, BST_CHECKED);

        pPropDataWnd->SetEnableListID( 9,
                                       IDC_RADIO_CALLMODE_DIRECT,
                                       IDC_RADIO_CALLMODE_GATEKEEPER,
                                       IDC_CHECK_NOCHANGECALLMODE,
                                       IDC_DISABLE_AUTOACCEPT,
                                       IDC_PERSIST_AUTOACCEPT,
                                       IDC_RADIO_NETSPEED_144,
                                       IDC_RADIO_NETSPEED_288,
                                       IDC_RADIO_NETSPEED_ISDN,
                                       IDC_RADIO_NETSPEED_LAN);
    }

    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_CALLMODE_DIRECT );
    pPropDataWnd -> EnableWindow( FALSE );


////////
    ItemID = IDC_SET_SECURITY_OPTIONS;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_SECURITY, TEXT("IDD_SECURITY"),
                                0, iX, iY, iWidth, iHeight );
    {
        HWND hwnd;

        // DEFAULT radio item is default SECURITY
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_SECURITY_DEFAULT );
        SetWindowLong( hwnd, GWL_USERDATA, DEFAULT_POL_SECURITY);
        Button_SetCheck(hwnd, BST_CHECKED);
        
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_SECURITY_REQUIRED );
        SetWindowLong( hwnd, GWL_USERDATA, REQUIRED_POL_SECURITY);

        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_SECURITY_DISABLED );
        SetWindowLong( hwnd, GWL_USERDATA, DISABLED_POL_SECURITY);

        pPropDataWnd -> SetEnableListID( 5,
                                         IDC_RADIO_SECURITY_DEFAULT,
                                         IDC_RADIO_SECURITY_REQUIRED,
                                         IDC_RADIO_SECURITY_DISABLED,
                                         IDC_REQUIRE_COMPLETE_AUTHENTICATION,
                                         IDC_SET_RDN_FOR_REQUIRED_CA
                                         );

        //
        // Link Set URL checkbox with edit field
        //
        {
            HWND hwndCond = GetDlgItem(pPropDataWnd->GetHwnd(), IDC_SET_RDN_FOR_REQUIRED_CA);
            pPropDataWnd->ConnectControlsToCheck( IDC_SET_RDN_FOR_REQUIRED_CA,
                    1,
                    new CControlID(hwndCond, IDC_SET_RDN_FOR_REQUIRED_CA,
                        IDC_EDIT_SET_RDN_FOR_REQUIRED_CA,
                        CControlID::EDIT ) );
        }
    }
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_SECURITY_DEFAULT );
    pPropDataWnd -> EnableWindow( FALSE );


    //
    // A/V OPTIONS
    //

//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_AUDIO;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                            IDD_AUDIO, TEXT("IDD_AUDIO"),
                            0, iX, iY, iWidth, iHeight );
    pPropDataWnd -> SetEnableListID( 7,
                                    IDC_PREVENT_THE_USER_FROM_USING_AUDIO,
                                    IDC_ENABLE_DIRECT_SOUND,
                                    IDC_NOCHANGE_DIRECT_SOUND,
                                    IDC_DISABLE_FULL_DUPLEX_AUDIO,
                                    IDC_CREATE_AN_AUDIO_LOG_FILE,
                                    IDC_CHECK_MUTE_SPEAKER_BY_DEFAULT,
                                    IDC_CHECK_MUTE_MICROPHONE_BY_DEFAULT
                                   );
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_PREVENT_THE_USER_FROM_USING_AUDIO );
    pPropDataWnd -> EnableWindow( FALSE );

//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_VIDEO;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                            IDD_VIDEO, TEXT("IDD_VIDEO"),
                            0, iX, iY, iWidth, iHeight );
    pPropDataWnd -> SetEnableListID( 2,
                                    IDC_DISABLE_SENDING_VIDEO,
                                    IDC_DISABLE_RECIEVING_VIDEO );
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_DISABLE_SENDING_VIDEO );
    pPropDataWnd -> EnableWindow( FALSE );

////////
    ItemID = IDC_LIMIT_AV_THROUGHPUT;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_LIMIT_AV_THROUGHPUT, TEXT("IDD_LIMIT_AV_THROUGHPUT"),
                                RestrictAvThroughputWndProc,
                                0, iX, iY, iWidth, iHeight );
    {
        CControlID *pControl = new CControlID( IDC_SLIDE_AV_THROUGHPUT,
                                        CControlID::SLIDER );
        pControl->SetStaticID( IDC_STATIC_MAX_AV_THROUGHPUT );
        pPropDataWnd->AddControl( pControl );
    }

    HWND hwndTrack = GetDlgItem( pPropDataWnd -> GetHwnd(), IDC_SLIDE_AV_THROUGHPUT );

    TrackBar_ClearTics(hwndTrack, FALSE);
    TrackBar_SetRange(hwndTrack, FALSE, BW_ISDN_BITS / 1000, BW_SLOWLAN_BITS / 1000);
    TrackBar_SetTicFreq(hwndTrack, 10, 0);
    TrackBar_SetPageSize( hwndTrack,  5);
    TrackBar_SetThumbLength( hwndTrack, 5);

    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = hwndTrack;
    pPropDataWnd -> EnableWindow( FALSE );

    //
    // TOOLS
    //
/////////
    ItemID = IDC_DISABLE_CHAT;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_CHAT, TEXT("IDD_CHAT"),
                                0, iX, iY, iWidth, iHeight );
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    pPropDataWnd -> EnableWindow( FALSE );


//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                            IDD_FILETRANSFER, TEXT("IDD_FILETRANSFER"),
                            0, iX, iY, iWidth, iHeight );

    pPropDataWnd -> SetEnableListID(     2,
                                    IDC_PREVENT_THE_USER_FROM_SENDING_FILES,
                                    IDC_PREVENT_THE_USER_FROM_RECEIVING_FILES
                                 );

    //
    // Link max send size check box to inverse of prevent sending checkbox
    //

    {
        HWND hwndCond = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_MAXIMUM_SIZE_OF_SENT_FILES );
        pPropDataWnd -> ConnectControlsToCheck( IDC_MAXIMUM_SIZE_OF_SENT_FILES, 1,
                                            new CControlID( hwndCond,
                                                            IDC_MAXIMUM_SIZE_OF_SENT_FILES,
                                                            IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES,
                                                            CControlID::EDIT_NUM ) );
    }
    
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_PREVENT_THE_USER_FROM_SENDING_FILES );
    pPropDataWnd -> EnableWindow( FALSE );


//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_SHARING;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                            IDD_SHARING, TEXT("IDD_SHARING"),
                            0, iX, iY, iWidth, iHeight );
    pPropDataWnd -> SetEnableListID( 7,
                                    IDC_DISABLE_ALL_SHARING_FEATURES,
                                    IDC_PREVENT_SHARING,
                                    IDC_PREVENT_SHARING_DESKTOP,
                                    IDC_PREVENT_SHARING_TRUECOLOR,
                                    IDC_PREVENT_SHARING_EXPLORER,
                                    IDC_PREVENT_SHARING_DOS,
                                    IDC_PREVENT_SHARING_CONTROL);
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_DISABLE_ALL_SHARING_FEATURES );

    pPropDataWnd -> EnableWindow( FALSE );

////////
    ItemID = IDC_RESTRICT_THE_USE_OF_WHITEBOARD;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_WHITEBOARD, TEXT("IDD_WHITEBOARD"),
                                0, iX, iY, iWidth, iHeight );

    pPropDataWnd -> SetEnableListID( 2,
                                    IDC_DISABLE_2XWHITEBOARD,
                                    IDC_DISABLE_WHITEBOARD);
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_DISABLE_2XWHITEBOARD );
    pPropDataWnd -> EnableWindow( FALSE );

//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_RDS;
    m_pCategoryList->SetEnableListID(1, ItemID);
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_RDS, TEXT("IDD_RDS"),
                                0, iX, iY, iWidth, iHeight );

    pPropDataWnd->SetEnableListID(2,
                                  IDC_DISABLE_RDS_ON_ALL,
                                  IDC_DISABLE_RDS_ON_WIN9X);
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_DISABLE_RDS_ON_ALL );
    pPropDataWnd->EnableWindow(FALSE);


    //
    // MISCELLANEOUS
    //
////////
    ItemID = IDC_RESTRICT_USE_OF_THE_OPTIONS_DIALOG;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_OPTIONS_DIALOG, TEXT("IDD_OPTIONS_DIALOG"),
                                0, iX, iY, iWidth, iHeight );
    pPropDataWnd -> SetEnableListID( 5,
                                IDC_DISABLE_THE_GENERAL_OPTIONS_PAGE,
                                IDC_DISABLE_THE_ADVANCED_CALLING_BUTTON,
                                IDC_DISABLE_THE_SECURITY_OPTIONS_PAGE,
                                IDC_DISABLE_THE_AUDIO_OPTIONS_PAGE,
                                IDC_DISABLE_THE_VIDEO_OPTIONS_PAGE
                                );
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_DISABLE_THE_GENERAL_OPTIONS_PAGE );
    pPropDataWnd -> EnableWindow( FALSE );


////////
    ItemID = IDC_ONLINE_SUPPORT;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_ONLINE_SUPPORT, TEXT("IDD_ONLINE_SUPPORT"),
                                0, iX, iY, iWidth, iHeight );
    {
        HWND hwndCond = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE );
        pPropDataWnd -> ConnectControlsToCheck(IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                                                2,
                                                new CControlID(
                                                    hwndCond,
                                                    IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                                                    IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                                                    CControlID::EDIT ),
                                                new CControlID(
                                                    hwndCond,
                                                    IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                                                    IDC_SHOW_THE_ONLINE_SUPPORT_PAGE_THE_FIRST_TIME_NETMEETING_STARTS,
                                                    CControlID::CHECK )
                                                );
    }
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE );
    pPropDataWnd -> EnableWindow( FALSE );

    return TRUE;
}

BOOL CSettingsSheet::_IsDataValid( void ) 
{
    // Validate FT Throughput
    if( GetCategoryCheck( IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER ) &&
        GetCheckData( IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER, IDC_MAXIMUM_SIZE_OF_SENT_FILES ) ) 
    {
        if( 0 >= GetDlgItemInt( ms_PropertyWindows[ IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER ]->GetHwnd(),
                                IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES,
                                NULL,
                                FALSE ) ) 
        {
            NmrkMessageBox(MAKEINTRESOURCE(IDS_FT_THROUGHPUT_VALUE_IS_INVALID),
                MAKEINTRESOURCE(IDS_INVALID_DATA_ERROR),
                MB_OK | MB_ICONEXCLAMATION);

            ShowWindow( IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER, TRUE );
            ms_PropertyWindows[ IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER ]->SetFocus( IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES );
            return FALSE;
        }
    }

    // Validate online support URL
    if( GetCategoryCheck( IDC_ONLINE_SUPPORT ) &&
        GetCheckData( IDC_ONLINE_SUPPORT, IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE ) ) 
    {
        LPTSTR sz;
        GetStringData( IDC_ONLINE_SUPPORT,
                    IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                    &sz ); 

        if( NULL == sz ) 
        {
            delete [] sz;
            NmrkMessageBox(MAKEINTRESOURCE(IDS_NETMEETING_HOMEPAGE_IS_INVALID),
                MAKEINTRESOURCE(IDS_INVALID_DATA_ERROR), MB_OK | MB_ICONEXCLAMATION);
            
            ShowWindow( IDC_ONLINE_SUPPORT, TRUE );
            ms_PropertyWindows[ IDC_ONLINE_SUPPORT ]->SetFocus( IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE );
            ms_PropertyWindows[ IDC_ONLINE_SUPPORT ]->SetFocus( IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE );
            return FALSE;
        }
        delete [] sz;
    }

    return TRUE;
}

int CSettingsSheet::SpewToListBox( HWND hwndList, int iStartLine ) 
{
    HWND hwndCat = m_pCategoryList->GetHwnd();
    map< UINT, CPropertyDataWindow2 * >::const_iterator it;
    for( it = ms_PropertyWindows.begin(); it != ms_PropertyWindows.end(); it++ )
    {
        if( GetCategoryCheck( (*it).first ) )
        {
            HWND hwndButton = GetDlgItem( hwndCat, (*it).first );
            int iButtonTextLen = Button_GetTextLength( hwndButton ) + 2;
            LPTSTR szButtonText = new TCHAR[ iButtonTextLen ];

            Button_GetText( hwndButton, szButtonText, iButtonTextLen -1 );
            lstrcat( szButtonText, TEXT(":") );

            ListBox_InsertString( hwndList, iStartLine, szButtonText );
            iStartLine++;

            iStartLine = (*it).second->Spew( hwndList, iStartLine );
        }
    }
    return iStartLine;
}

void CSettingsSheet::_SetButtons( void ) 
{

    DWORD dwFlags = PSWIZB_BACK;
    dwFlags |= PSWIZB_NEXT;
    PropSheet_SetWizButtons( GetParent( m_hWndDlg ), dwFlags ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\welcmsht.h ===
#ifndef __WelcmSht_h__
#define __WelcmSht_h__


class CWelcomeSheet {

friend class CNmAkWiz;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );
    static CWelcomeSheet* ms_pWelcomeSheet;


private: // DATA
    CPropertySheetPage m_PropertySheetPage;

private: 
    CWelcomeSheet( void );
    ~CWelcomeSheet( void );

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}
};


#endif // __WelcmSht_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\util.h ===
#ifndef __util_h__
#define __util_h__

#define ARRAY_SIZE( A ) ( sizeof(A) / sizeof(A[0]) )
#define CCHMAX	ARRAY_SIZE

void ErrorMessage( void );
void ErrorMessage( LPCTSTR str, HRESULT hr );

HRESULT LPTSTR_to_BSTR(BSTR *pbstr, LPCTSTR psz);
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);

#define RETFAIL( x ) if( false == ( x ) ) { ErrorMessage( "", GetLastError() ); assert( 0 ); return false; }

#define RETNULL( x ) if( NULL == ( x ) ) { ErrorMessage( "", GetLastError() ); assert( 0 ); return NULL; }

//-------------------------------------------------------------------
// Track Bar Helper Macros
//-------------------------------------------------------------------
// Pilfered from Petzold, "Programming Windows 95", Chapter 12, comctlhlp.h
#define TrackBar_ClearSel(hwnd, fRedraw) \
    (void)SendMessage((hwnd), TBM_CLEARSEL, (WPARAM) (BOOL) fRedraw, 0L)

#define TrackBar_ClearTics(hwnd, fRedraw) \
    (void)SendMessage((hwnd), TBM_CLEARTICS, (WPARAM) (BOOL) fRedraw, 0L)

#define TrackBar_GetChannelRect(hwnd, lprc) \
    (void)SendMessage((hwnd), TBM_GETCHANNELRECT, 0, (LPARAM) (LPRECT) lprc)

#define TrackBar_GetLineSize(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETLINESIZE, 0, 0L)

#define TrackBar_GetNumTics(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETNUMTICS, 0, 0L)

#define TrackBar_GetPageSize(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETPAGESIZE, 0, 0L)

#define TrackBar_GetPos(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETPOS, 0, 0L)

#define TrackBar_GetPTics(hwnd) \
    (LPLONG)SendMessage((hwnd), TBM_GETPTICS, 0, 0L)

#define TrackBar_GetRangeMax(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETRANGEMAX, 0, 0L)

#define TrackBar_GetRangeMin(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETRANGEMIN, 0, 0L)

#define TrackBar_GetSelEnd(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETSELEND, 0, 0L)

#define TrackBar_GetSelStart(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETSELSTART, 0, 0L)

#define TrackBar_GetThumbLength(hwnd) \
    (UINT)SendMessage((hwnd), TBM_GETTHUMBLENGTH, 0, 0L)

#define TrackBar_GetThumbRect(hwnd, lprc) \
    (void)SendMessage((hwnd), TBM_GETTHUMBRECT, 0, (LPARAM) (LPRECT) lprc)

#define TrackBar_GetTic(hwnd, iTic) \
    (LONG)SendMessage((hwnd), TBM_GETTIC, (WPARAM) (WORD) iTic, 0L)

#define TrackBar_GetTicPos(hwnd, iTic) \
    (LONG)SendMessage((hwnd), TBM_GETTICPOS, (WPARAM) (WORD) iTic, 0L)

#define TrackBar_SetLineSize(hwnd, lLineSize) \
    (LONG)SendMessage((hwnd), TBM_SETLINESIZE, 0, (LONG) lLineSize)

#define TrackBar_SetPageSize(hwnd, lPageSize) \
    (LONG)SendMessage((hwnd), TBM_SETPAGESIZE, 0, (LONG) lPageSize)

#define TrackBar_SetPos(hwnd, bPosition, lPosition) \
    (void)SendMessage((hwnd), TBM_SETPOS, (WPARAM) (BOOL) bPosition, (LPARAM) (LONG) lPosition)

#define TrackBar_SetRange(hwnd, bRedraw, lMinimum, lMaximum) \
    (void)SendMessage((hwnd), TBM_SETRANGE, (WPARAM) (BOOL) bRedraw, (LPARAM) MAKELONG(lMinimum, lMaximum))

#define TrackBar_SetRangeMax(hwnd, bRedraw, lMaximum) \
    (void)SendMessage((hwnd), TBM_SETRANGEMAX, (WPARAM) bRedraw, (LPARAM) lMaximum)

#define TrackBar_SetRangeMin(hwnd, bRedraw, lMinimum) \
    (void)SendMessage((hwnd), TBM_SETRANGEMIN, (WPARAM) bRedraw, (LPARAM) lMinimum)

#define TrackBar_SetSel(hwnd, bRedraw, lMinimum, lMaximum) \
    (void)SendMessage((hwnd), TBM_SETSEL, (WPARAM) (BOOL) bRedraw, (LPARAM) MAKELONG(lMinimum, lMaximum))

#define TrackBar_SetSelEnd(hwnd, bRedraw, lEnd) \
    (void)SendMessage((hwnd), TBM_SETSELEND, (WPARAM) (BOOL) bRedraw, (LPARAM) (LONG) lEnd)

#define TrackBar_SetSelStart(hwnd, bRedraw, lStart) \
    (void)SendMessage((hwnd), TBM_SETSELSTART, (WPARAM) (BOOL) bRedraw, (LPARAM) (LONG) lStart)

#define TrackBar_SetThumbLength(hwnd, iLength) \
    (void)SendMessage((hwnd), TBM_SETTHUMBLENGTH, (WPARAM) (UINT) iLength, 0L)

#define TrackBar_SetTic(hwnd, lPosition) \
    (BOOL)SendMessage((hwnd), TBM_SETTIC, 0, (LPARAM) (LONG) lPosition)

#define TrackBar_SetTicFreq(hwnd, wFreq, lPosition) \
    (void)SendMessage((hwnd), TBM_SETTICFREQ, (WPARAM) wFreq, (LPARAM) (LONG) lPosition)


#endif // __util_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\wndprocs.h ===
#ifndef _WNDPROCS_H_
#define _WNDPROCS_H_

#define CAT_CHECK_STATE_UNSEL  0
#define CAT_CHECK_STATE_SEL	   1
#define CAT_CHECK_STATE_CHECK  2

typedef struct tagSubData
{
	WNDPROC		  proc;
	list<HWND>    list;
} SUBDATA, *PSUBDATA;

void OnMsg_VScroll( HWND hwnd, WPARAM wParam );
LRESULT CALLBACK RestrictAvThroughputWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK CatListWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK wndProcForCheckTiedToEdit( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\welcmsht.cpp ===
#include "precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
#include "WelcmSht.h"
#include "nmakwiz.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CWelcomeSheet* CWelcomeSheet::ms_pWelcomeSheet = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

INT_PTR CALLBACK CWelcomeSheet::DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam ) {

    switch( message ) {
		case WM_INITDIALOG:
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT ); 
			return TRUE;

		case WM_NOTIFY:
			switch( reinterpret_cast< NMHDR FAR* >( lParam ) -> code ) {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                	PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT ); 
			        return TRUE;

			}

		default:
			break;

	}

	return FALSE;

}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CWelcomeSheet::CWelcomeSheet( void )
 : m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_WELCOME ), 
						CWelcomeSheet::DlgProc 
                       )
{   
     if( NULL == ms_pWelcomeSheet ) { ms_pWelcomeSheet = this; }
}

CWelcomeSheet::~CWelcomeSheet( void ) 
{ ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmrk\wndprocs.cpp ===
#include "precomp.h"
#include "resource.h"
#include "nmakwiz.h"
#include "wndprocs.h"

LRESULT CALLBACK RestrictAvThroughputWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
	switch( iMsg )
	{
		case WM_VSCROLL: 
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
			break;
		} 
		case WM_HSCROLL:
		{
			TCHAR szPos[ MAX_DIGITS ];
			DWORD dwPos = SendMessage( GetDlgItem( hwnd, IDC_SLIDE_AV_THROUGHPUT), TBM_GETPOS, 0, 0); 
			wsprintf( szPos, "%d", dwPos );
			Static_SetText( GetDlgItem( hwnd, IDC_STATIC_MAX_AV_THROUGHPUT), szPos );
			return 0;
			break;
		}

		case WM_COMMAND:
		{
			return 0;
            break;
		}
	}
	return( DefWindowProc( hwnd, iMsg, wParam, lParam ) );
}

LRESULT CALLBACK wndProcForCheckTiedToEdit( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
	PSUBDATA pSubData = (PSUBDATA)GetWindowLong( hwnd, GWL_USERDATA );
	WNDPROC proc = pSubData->proc;

	switch( iMsg )
	{
		case WM_ENABLE:
		{
			if( Button_GetCheck( hwnd ) )
			{
				list< HWND >::const_iterator it;
				
				for( it = pSubData -> list . begin(); it != pSubData -> list . end(); ++it )
				{
					::EnableWindow( (HWND)(*it), (BOOL)wParam );
				}
			}
			break;
		}
		case BM_SETCHECK:
		{
			if( IsWindowEnabled( hwnd ) )
			{
				list< HWND >::const_iterator it;
				
				for( it = pSubData -> list . begin(); it != pSubData -> list . end(); ++it )
				{
					::EnableWindow( (HWND)(*it), (BOOL)wParam );
				}
			}
			break;
		}
		case WM_NCDESTROY:
		{
			delete pSubData;
			break;
		}
	}

	return( CallWindowProc( proc, hwnd, iMsg, wParam, lParam ) );
}

int _ControlIsObscured( HWND parentControl, HWND hwndControl );

int _ControlIsObscured( HWND parentControl, HWND hwndControl )
{
	RECT rectControl;
	GetWindowRect( hwndControl, &rectControl );

	RECT rectParent;
	GetWindowRect( parentControl, &rectParent );

	if( rectControl . top < rectParent . top )
	{
		// Scroll 
		return -1;
	}
	else if( rectControl . bottom > rectParent . bottom )
	{
		// Scroll
		return 1;
	}
	else 
	{
		return 0;
	}
}


enum tagCategoryButtonStates
{
	STATE_UNSELECTED,
	STATE_SELECTED,
	STATE_SELECTED_VIS,
	STATE_CHECKED,
	STATE_CHECKED_VIS
};

LRESULT CALLBACK CatListWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
	switch( iMsg )
	{
		case WM_CREATE:
		{
			// Note - this should be set to the top check box
			PostMessage( hwnd, WM_COMMAND, MAKEWPARAM( IDC_SET_CALLING_OPTIONS, BN_CLICKED ), 0L );
			break;
		}
		
		case WM_COMMAND:
		{
			UINT uHiword = GET_WM_COMMAND_CMD(wParam, lParam);
            UINT uLoword = GET_WM_COMMAND_ID(wParam, lParam);
			switch( uHiword )
			{
				case BN_DOUBLECLICKED:
				case BN_CLICKED:
				{
					HWND hwndButton = GetDlgItem(hwnd, uLoword);
					ULONG uState = GetWindowLong( hwndButton, GWL_USERDATA );
					switch( uState )
					{
						case STATE_UNSELECTED:
						{
							if (Button_GetCheck(hwndButton))
							{
								SetWindowLong(hwndButton, GWL_USERDATA, STATE_CHECKED_VIS  );
							}
							else
							{
								SetWindowLong(hwndButton, GWL_USERDATA, STATE_SELECTED_VIS );
							}
							g_pWiz->m_SettingsSheet.ShowWindow(uLoword, TRUE);
							break;
						}
						case STATE_SELECTED:
						case STATE_SELECTED_VIS:
						{
							if ((uHiword == BN_DOUBLECLICKED) && (STATE_SELECTED_VIS != uState))
							{
								break;
							}
							Button_SetCheck( hwndButton, TRUE );
							g_pWiz -> m_SettingsSheet . EnableWindow( uLoword, TRUE );
							g_pWiz->m_SettingsSheet.SetFocus( uLoword );
							SetWindowLong( hwndButton, GWL_USERDATA, STATE_CHECKED );
							break;
						}
						case STATE_CHECKED:
						case STATE_CHECKED_VIS:
						{
							if ((uHiword == BN_DOUBLECLICKED) && (STATE_CHECKED_VIS != uState))
							{
								break;
							}

							Button_SetCheck( hwndButton, FALSE );
							g_pWiz -> m_SettingsSheet . EnableWindow( uLoword, FALSE );
							SetWindowLong( hwndButton, GWL_USERDATA, STATE_SELECTED );
							break;
						}
					}			
					return 0;
					break;	
				}

				case EN_SETFOCUS:
				case BN_SETFOCUS:
				{
					return 0;
				}
			}
		}
		
		case WM_VSCROLL:
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
		}
		
	}

	return( DefWindowProc( hwnd, iMsg, wParam, lParam ) );
}

enum { SCROLL_JUMP = 20 };

void OnMsg_VScroll( HWND hwnd, WPARAM wParam )
{
	int         nPosition; 
	int         nHorzScroll = 0; 
	int         nVertScroll = 0; 
	SCROLLINFO  ScrollInfo; 
	WORD		wScrollCode = (WORD)LOWORD(wParam);

	// Get current scroll information. 
	ScrollInfo.cbSize = sizeof(SCROLLINFO); 
	ScrollInfo.fMask = SIF_ALL; 
	GetScrollInfo(hwnd, SB_VERT, &ScrollInfo); 
	nPosition = ScrollInfo.nPos; 

	// Modify scroll information based on requested 
	// scroll action. 

	RECT rectWindow;
	GetClientRect( hwnd, &rectWindow );

	int iDelta;
	switch (wScrollCode) 
	{ 
		case SB_LINEDOWN:
			iDelta = -SCROLL_JUMP;
			ScrollInfo.nPos += SCROLL_JUMP; 
			break; 

		case SB_LINEUP:
			iDelta = SCROLL_JUMP;
			ScrollInfo.nPos -= SCROLL_JUMP; 
			break; 

		case SB_PAGEDOWN: 
			iDelta = -ScrollInfo.nPage;
			ScrollInfo.nPos += ScrollInfo.nPage; 
			break; 

		case SB_PAGEUP: 
			iDelta = ScrollInfo.nPage;
			ScrollInfo.nPos -= ScrollInfo.nPage; 
			break; 

		case SB_TOP: 
			iDelta = rectWindow . top - rectWindow . bottom;/*170;*/
			ScrollInfo.nPos = ScrollInfo.nMin; 
			break; 

		case SB_BOTTOM: 
			iDelta = rectWindow . top - rectWindow . bottom;/*170;*/
			ScrollInfo.nPos = ScrollInfo.nMax; 
			break; 

			// Don't do anything. 
		case SB_THUMBPOSITION: 
		case SB_THUMBTRACK: 
			iDelta = -(ScrollInfo.nTrackPos - ScrollInfo.nPos);
			ScrollInfo.nPos = ScrollInfo.nTrackPos; 
			break; 

		case SB_ENDSCROLL: 
			default: 
			return; 
	} 

	// Make sure that scroll position is in range. 
	if (0 > ScrollInfo.nPos)
	{
		ScrollInfo.nPos = 0; 
	}
	else if (ScrollInfo.nMax - (int) ScrollInfo.nPage + 1 < ScrollInfo.nPos) 
	{
		ScrollInfo.nPos = ScrollInfo.nMax  - ScrollInfo.nPage + 1; 
	}

	// Set new scroll position. 
	ScrollInfo.fMask = SIF_POS; 
	SetScrollInfo(hwnd, SB_VERT, &ScrollInfo, TRUE); 

	// Scroll window. 
	nVertScroll = nPosition - ScrollInfo.nPos; 


	ScrollWindowEx(hwnd, nHorzScroll, nVertScroll, NULL, NULL, 
				   NULL, NULL, SW_ERASE | SW_INVALIDATE | SW_SCROLLCHILDREN); 

	//InvalidateRect( hwnd, NULL, TRUE );
	if( 0 < iDelta )
	{
		iDelta += 1;
		SetRect( &rectWindow, rectWindow . left, rectWindow . top , rectWindow . right, rectWindow . top + iDelta /*164, 200, 164 + 375, 200 + iDelta */ );
	}
	else if( 0 > iDelta )
	{
		iDelta -= 1;
		SetRect( &rectWindow, rectWindow . left, rectWindow . bottom + iDelta , rectWindow . right, rectWindow . bottom /*164, 200 + 170 + iDelta, 164 + 375, 200 + 170*/ );
	}
	else
	{
		return;
	}

	MapWindowPoints(  hwnd, GetParent( hwnd ), (LPPOINT) &rectWindow, 2 );
	RedrawWindow( GetParent( hwnd ), &rectWindow, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ERASENOW | RDW_UPDATENOW | RDW_ALLCHILDREN );

	return; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\borderwindow.cpp ===
// File: Toolbar.cpp

#include "precomp.h"

#include "GenContainers.h"

#include <windowsx.h>

CBorderWindow::CBorderWindow() :
	m_uParts(0),
	m_hGap(0),
	m_vGap(0)
{
}

BOOL CBorderWindow::Create(
	HWND hWndParent	// The parent of this window
	)
{
	return(CGenWindow::Create(
		hWndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMBorderWindow"),	// Window name
		WS_CLIPCHILDREN,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
		));
}

extern void GetWindowDesiredSize(HWND hwnd, SIZE *ppt);

extern BOOL IsChildVisible(HWND hwndChild);

enum Parts
{
	TL = 0,
	T,
	TR,
	L,
	C,
	R,
	BL,
	B,
	BR,
} ;

// Returns the number of child windows
UINT FillWindowSizes(
	HWND hwndParent,
	HWND hwnds[CBorderWindow::NumParts],
	SIZE sizes[CBorderWindow::NumParts],
	UINT uParts
	)
{
	UINT nChildren = 0;

	HWND hwndChild = ::GetWindow(hwndParent, GW_CHILD);

	for (int i=0; i<CBorderWindow::NumParts; ++i)
	{
		sizes[i].cx = sizes[i].cy = 0;

		if ((uParts&(1<<i)) == 0)
		{
			hwnds[i] = NULL;
		}
		else
		{
			hwnds[i] = hwndChild;

			if (NULL != hwndChild && IsChildVisible(hwndChild))
			{
				IGenWindow *pWin = IGenWindow::FromHandle(hwndChild);
				if (NULL != pWin)
				{
					++nChildren;
					pWin->GetDesiredSize(&sizes[i]);
				}

				hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT);
			}
		}
	}

	return(nChildren);
}

// Returns the total children desired size in the arrays
// Return value is the number of child windows
UINT CBorderWindow::GetDesiredSize(
	HWND hwnds[NumParts],
	SIZE sizes[NumParts],
	int rows[3],
	int cols[3],
	SIZE *psize)
{
	UINT nChildren = FillWindowSizes(GetWindow(), hwnds, sizes, m_uParts);

	cols[0] = max(max(sizes[TL].cx, sizes[L].cx), sizes[BL].cx);
	cols[1] = max(max(sizes[T ].cx, sizes[C].cx), sizes[B ].cx);
	cols[2] = max(max(sizes[TR].cx, sizes[R].cx), sizes[BR].cx);

	rows[0] = max(max(sizes[TL].cy, sizes[T].cy), sizes[TR].cy);
	rows[1] = max(max(sizes[L ].cy, sizes[C].cy), sizes[R ].cy);
	rows[2] = max(max(sizes[BL].cy, sizes[B].cy), sizes[BR].cy);

	psize->cx = cols[0] + cols[1] + cols[2];
	psize->cy = rows[0] + rows[1] + rows[2];

	// Add the gaps
	if (0 != cols[0])
	{
		if (0 != cols[1] || 0 != cols[2])
		{
			psize->cx += m_hGap;
		}
	}
	if (0 != cols[1] && 0 != cols[2])
	{
		psize->cx += m_hGap;
	}

	if (0 != rows[0])
	{
		if (0 != rows[1] || 0 != rows[2])
		{
			psize->cy += m_vGap;
		}
	}
	if (0 != rows[1] && 0 != rows[2])
	{
		psize->cy += m_vGap;
	}

	return(nChildren);
}

void CBorderWindow::GetDesiredSize(SIZE *psize)
{
	HWND hwnds[NumParts];
	SIZE sizes[NumParts];
	int rows[3];
	int cols[3];

	GetDesiredSize(hwnds, sizes, rows, cols, psize);

	// Add on any non-client size
	SIZE sizeTemp;
	CGenWindow::GetDesiredSize(&sizeTemp);
	psize->cx += sizeTemp.cx;
	psize->cy += sizeTemp.cy;
}

HDWP SetWindowPosI(HDWP hdwp, HWND hwndChild, int left, int top, int width, int height)
{
	if (NULL == hwndChild)
	{
		return(hdwp);
	}

#if TRUE
	return(DeferWindowPos(hdwp, hwndChild, NULL, left, top, width, height, SWP_NOZORDER));
#else
	// Helpful for debugging
	SetWindowPos(hwndChild, NULL, left, top, width, height, SWP_NOZORDER);
	return(hdwp);
#endif
}

// Move the children into their various locations
void CBorderWindow::Layout()
{
	HWND hwnds[NumParts];
	SIZE sizes[NumParts];
	int rows[3];
	int cols[3];

	SIZE desiredSize;

	UINT nChildren = GetDesiredSize(hwnds, sizes, rows, cols, &desiredSize);
	bool bCenterOnly = (1 == nChildren) && (0 != (m_uParts & Center));

	HWND hwndThis = GetWindow();

	RECT rcClient;
	GetClientRect(hwndThis, &rcClient);

	// Add extra space to the center
	if (desiredSize.cx < rcClient.right || bCenterOnly)
	{
		cols[1] += rcClient.right  - desiredSize.cx;
	}
	if (desiredSize.cy < rcClient.bottom || bCenterOnly)
	{
		rows[1] += rcClient.bottom - desiredSize.cy;
	}

	// Speed up layout by deferring it
	HDWP hdwp = BeginDeferWindowPos(NumParts);

	// Add the gaps

	// Make the dimension 3 so we can safely iterate through the loop below
	int hGaps[3] = { 0, 0 };
	if (0 != cols[0])
	{
		if (0 != cols[1] || 0 != cols[2])
		{
			hGaps[0] = m_hGap;
		}
	}
	if (0 != cols[1] && 0 != cols[2])
	{
		hGaps[1] = m_hGap;
	}

	// Make the dimension 3 so we can safely iterate through the loop below
	int vGaps[3] = { 0, 0 };
	if (0 != rows[0])
	{
		if (0 != rows[1] || 0 != rows[2])
		{
			vGaps[0] = m_vGap;
		}
	}
	if (0 != rows[1] && 0 != rows[2])
	{
		vGaps[1] = m_vGap;
	}

	// Layout by rows
	int top = 0;
	for (int i=0; i<3; ++i)
	{
		int left = 0;

		for (int j=0; j<3; ++j)
		{
			hdwp = SetWindowPosI(hdwp, hwnds[3*i+j], left, top, cols[j], rows[i]);
			left += cols[j] + hGaps[j];
		}

		top += rows[i] + vGaps[i];
	}

	// Actually move all the windows now
	EndDeferWindowPos(hdwp);
}

LRESULT CBorderWindow::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

void CBorderWindow::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	FORWARD_WM_COMMAND(GetParent(hwnd), id, hwndCtl, codeNotify, SendMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\bestintf.cpp ===
#include "precomp.h"
#include "bestintf.h"



typedef DWORD (WINAPI * PFNGetBestInterface) (
    IN  IPAddr  dwDestAddr,
    OUT PDWORD  pdwBestIfIndex
    );

typedef DWORD (WINAPI * PFNGetIpAddrTable) (
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PULONG           pdwSize,
    IN     BOOL             bOrder
    );

static HINSTANCE s_hIPHLPAPI = NULL;
const TCHAR g_cszIPHLPAPIDllName[] = _TEXT("iphlpapi.dll");
static PFNGetBestInterface s_pfnGetBestInterface;
static PFNGetIpAddrTable s_pfnGetIpAddrTable;


//forward references
static DWORD IpAddrTable(PMIB_IPADDRTABLE& pIpAddrTable, BOOL fOrder = FALSE);
static DWORD InterfaceIdxToInterfaceIp(PMIB_IPADDRTABLE
		pIpAddrTable, DWORD dwIndex, in_addr* s);


DWORD NMINTERNAL NMGetBestInterface ( SOCKADDR_IN* srem, SOCKADDR_IN* sloc )
{
	SOCKET hSock;
	int nAddrSize = sizeof(SOCKADDR);
	
	const int maxhostname = 1024;
	char hostname[maxhostname + 1];
	hostent *ha;
	char** c;
	int cIpAddr; // count of IpAddresses
	in_addr* in;

	DWORD BestIFIndex;
	PMIB_IPADDRTABLE pIpAddrTable = NULL;

	int dwStatus = ERROR_SUCCESS;

    ASSERT(srem);
    ASSERT(sloc);

	// This function tries to find the best IP interface to return when given a remote address
	// Three different ways are tried.

	//(1) statically get the list of interfaces, this will work when there's only one IP address
	dwStatus = gethostname(hostname, maxhostname);
	if (dwStatus != 0)
	{
		return WSAGetLastError();
	}

	ha = gethostbyname(hostname);
	if (ha == NULL)
	{
		return WSAGetLastError();
	}

	cIpAddr = 0;   // count the interfaces, if there's only one this is easy
	for (c = ha->h_addr_list; *c != NULL; ++c)
	{
		cIpAddr++;
		in = (in_addr*)*c;
	}

	if (cIpAddr == 1) //just a single IP Address
	{
		sloc->sin_family = 0;
		sloc->sin_port = 0;
		sloc->sin_addr = *in;
		return dwStatus;
	}
	

	// (2) This computer has multiple IP interfaces, try the functions
	//     in IPHLPAPI.DLL
	//     As of this writing - Win98, NT4SP4, Windows 2000 contain these functions.
	//
	// This is a win because the information we need can be looked up statically.

	if (NULL == s_hIPHLPAPI)
	{
		s_hIPHLPAPI = NmLoadLibrary(g_cszIPHLPAPIDllName, TRUE);
	}
	if (NULL != s_hIPHLPAPI)
	{
		s_pfnGetBestInterface = (PFNGetBestInterface)
			::GetProcAddress(s_hIPHLPAPI, "GetBestInterface");
		s_pfnGetIpAddrTable   = (PFNGetIpAddrTable)
			::GetProcAddress(s_hIPHLPAPI, "GetIpAddrTable");
		if ((NULL != s_pfnGetBestInterface) &&
			(NULL != s_pfnGetIpAddrTable))
		{
		    dwStatus = s_pfnGetBestInterface( (IPAddr)((ULONG_PTR)srem), &BestIFIndex);
			if (dwStatus != ERROR_SUCCESS)
			{
			    FreeLibrary(s_hIPHLPAPI);
				s_hIPHLPAPI = NULL;
				return dwStatus;
			}
			
			// get IP Address Table for mapping interface index number to ip address
			dwStatus = IpAddrTable(pIpAddrTable);
			if (dwStatus != ERROR_SUCCESS)
			{
				if (pIpAddrTable)
					MemFree(pIpAddrTable);
			    FreeLibrary(s_hIPHLPAPI);
				s_hIPHLPAPI = NULL;
				return dwStatus;
			}
			
			dwStatus = InterfaceIdxToInterfaceIp(pIpAddrTable,
												 BestIFIndex, &(sloc->sin_addr));

			MemFree(pIpAddrTable);
			if (dwStatus == ERROR_SUCCESS)
			{
			    FreeLibrary(s_hIPHLPAPI);
				s_hIPHLPAPI = NULL;
			    return dwStatus;
			}
		}
	}


	// (3) As a last resort, try and connect on the stream socket that was passed in
	//     This will work for NetMeeting when connecting to an LDAP server, for example.
	//
	hSock = socket(AF_INET, SOCK_STREAM, 0); // must be a STREAM socket for MS stack
	if (hSock != INVALID_SOCKET)
	{
		dwStatus = connect(hSock, (LPSOCKADDR)&srem, sizeof (SOCKADDR));
		if (dwStatus != SOCKET_ERROR)
		{
			getsockname(hSock, (LPSOCKADDR)&sloc, (int *) &nAddrSize);
		}
		closesocket(hSock);
		return ERROR_SUCCESS;
	}
	return SOCKET_ERROR;
}
	

//----------------------------------------------------------------------------
// Inputs: pIpAddrTable is the IP address table
//         dwIndex is the Interface Number
// Output: returns ERROR_SUCCESS when a match is found, s contains the IpAddr
//----------------------------------------------------------------------------
DWORD InterfaceIdxToInterfaceIp(PMIB_IPADDRTABLE pIpAddrTable, DWORD dwIndex, in_addr* s)
{
    for (DWORD dwIdx = 0; dwIdx < pIpAddrTable->dwNumEntries; dwIdx++)
    {
        if (dwIndex == pIpAddrTable->table[dwIdx].dwIndex)
        {
            s->S_un.S_addr = pIpAddrTable->table[dwIdx].dwAddr;
			return ERROR_SUCCESS;
        }
    }
    return 1;

}


//----------------------------------------------------------------------------
// If returned status is ERROR_SUCCESS, then pIpAddrTable points to a Ip Address
// table.
//----------------------------------------------------------------------------
DWORD IpAddrTable(PMIB_IPADDRTABLE& pIpAddrTable, BOOL fOrder)
{
    DWORD status = ERROR_SUCCESS;
    DWORD statusRetry = ERROR_SUCCESS;
    DWORD dwActualSize = 0;

    // query for buffer size needed
    status = s_pfnGetIpAddrTable(pIpAddrTable, &dwActualSize, fOrder);

    if (status == ERROR_SUCCESS)
    {
        return status;
    }
    else if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        // need more space
        pIpAddrTable = (PMIB_IPADDRTABLE) MemAlloc(dwActualSize);

        statusRetry = s_pfnGetIpAddrTable(pIpAddrTable, &dwActualSize, fOrder);
        return statusRetry;
    }
    else
    {
        return status;
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\bstring.cpp ===
/*
 * BSTRING.CPP
 *
 * Implementation of the member functions of the BSTRING C++ class.  See
 * BSTRING.H for the class declaration and the implementation of the inline
 * member functions.
 *
 * Author:
 *		dannygl, 29 Oct 96
 */

#include "precomp.h"
#include <bstring.h>

// We don't support construction from an ANSI string in the Unicode build.
#if !defined(UNICODE)

BSTRING::BSTRING(LPCSTR lpcString)
{
    // Initialize the member pointer to NULL
    m_bstr = NULL;
    if (NULL == lpcString)
        return;

    // Compute the length of the required BSTR, including the null
    int cWC;

    cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
    if (cWC <= 0)
    {
        return;
    };

    // Allocate the BSTR, including the null
    m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

    ASSERT(NULL != m_bstr);

    if (NULL == m_bstr)
    {
        return;
    }

    // Copy the string
    MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

    // Verify that the string is null terminated
    ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // !defined(UNICODE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\custring.cpp ===
// CUSTRING.CPP
//
// Implementation of the CUSTRING class, a lightweight class used to convert
// strings seamlessly between ANSI and Unicode.
//
// Derived from STRCORE.CPP.

#include "precomp.h"
#include <oprahcom.h>
#include <cstring.hpp>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CUSTRING::CUSTRING(PCWSTR wszText) : 
	wszData((PWSTR)wszText), 
	szData(NULL), 
	bUnicodeNew(FALSE),
	bAnsiNew(FALSE)
{
	// AssignString;
}

CUSTRING::CUSTRING(PCSTR szText) : 
	szData((PSTR)szText), 
	wszData(NULL), 
	bUnicodeNew(FALSE),
	bAnsiNew(FALSE)
{
	// AssignString;
}

CUSTRING::~CUSTRING()
{
	if (bUnicodeNew) {
		delete wszData;
	}
	if (bAnsiNew) {
		delete szData;
	}
}

CUSTRING::operator PWSTR()
{ 
	if (szData && !wszData) {
		wszData = AnsiToUnicode(szData);
		bUnicodeNew = TRUE;
	}
	return wszData;
}

CUSTRING::operator PSTR()
{ 
	if (wszData && !szData) {
		szData = UnicodeToAnsi(wszData);
		bAnsiNew = TRUE;
	}
	return szData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\combobox.cpp ===
// File: BitmapButton.cpp

#include "precomp.h"

#include "GenControls.h"

#include <windowsx.h>

CComboBox::CComboBox() :
    m_combo(NULL),
    m_hbrBack(NULL),
    m_hfText(NULL),
    m_pNotify(NULL)
{
}

CComboBox::~CComboBox()
{
	SetColors(NULL, 0, 0);
	SetFont(NULL);

	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}
}

BOOL CComboBox::Create(
	HWND hWndParent,			// Parent of the edit control
	UINT height,				// The height of the combo (with drop-down)
	DWORD dwStyle,				// Edit control style
	LPCTSTR szTitle,			// Initial text for the edit control
	IComboBoxChange *pNotify	// Object to notify of changes
	)
{
	if (!CFillWindow::Create(
		hWndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMComboBox"),	// Window name
		0,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
		))
	{
		return(FALSE);
	}

	// Create the actual edit control and save it away
	m_combo = CreateWindowEx(0, TEXT("combobox"), szTitle,
		WS_CHILD|WS_VISIBLE|WS_TABSTOP|WS_VSCROLL|dwStyle,
		0, 0, 10, height, GetWindow(), 0,
		reinterpret_cast<HINSTANCE>(GetWindowLongPtr(hWndParent, GWLP_HINSTANCE)),
		NULL);

    //
    // We don't have a font yet, we can't set it.
    //

	m_pNotify = pNotify;
	if (NULL != m_pNotify)
	{
		m_pNotify->AddRef();
	}

	return(TRUE);
}

// Not actually implemented yet; should use the font to determine a size
void CComboBox::GetDesiredSize(SIZE *ppt)
{
	CFillWindow::GetDesiredSize(ppt);

	HWND combo = GetComboBox();
	if (NULL == combo)
	{
		return;
	}

	// ComboBoxes always size themselves to their desired size
	RECT rc;
	GetClientRect(combo, &rc);

	// Just pick a number
	ppt->cx += 100;
	ppt->cy += rc.bottom;
}

// HACKHACK georgep: This object now owns the brush
void CComboBox::SetColors(HBRUSH hbrBack, COLORREF back, COLORREF fore)
{
	// Store off the colors and brush
	if (NULL != m_hbrBack)
	{
		DeleteObject(m_hbrBack);
	}
	m_hbrBack = hbrBack;
	m_crBack = back;
	m_crFore = fore;

    HWND edit = GetEdit();
    if (NULL != edit)
    {
    	InvalidateRect(edit, NULL, TRUE);
    }
}

// HACKHACK georgep: This object now owns the font
void CComboBox::SetFont(HFONT hf)
{
	if (NULL != m_hfText)
	{
		DeleteObject(m_hfText);
	}
	m_hfText = hf;

	// Tell the edit control the font to use
    HWND edit = GetEdit();
	if (NULL != edit)
    {
	    FORWARD_WM_SETFONT(edit, hf, TRUE, ::SendMessage);
    }
}

LRESULT CComboBox::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(GetWindow(), WM_CTLCOLOREDIT, OnCtlColor);
		HANDLE_MSG(GetWindow(), WM_COMMAND     , OnCommand);
		HANDLE_MSG(GetWindow(), WM_NCDESTROY   , OnNCDestroy);

	case WM_SETFOCUS:
	{
		HWND edit = GetEdit();
		if (NULL != edit)
		{
			::SetFocus(edit);
		}
		break;
	}

	default:
		break;
	}

	return(CFillWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

HBRUSH CComboBox::OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
{
	// Do default processing if there is no brush
	if (NULL == m_hbrBack)
	{
		return(FORWARD_WM_CTLCOLOREDIT(hwnd, hdc, hwndChild, CFillWindow::ProcessMessage));
	}

	// Set the colors in the DC, and return the brush
	SetBkColor(hdc, m_crBack);
	SetTextColor(hdc, m_crFore);
	return(m_hbrBack);
}

// Sets the text for the control
void CComboBox::SetText(
	LPCTSTR szText	// The text to set
	)
{
	SetWindowText(GetEdit(), szText);
}

// Returns the number of items in the list
int CComboBox::GetNumItems()
{
    HWND combo = GetComboBox();
    int  numItems;

    if (combo)
    {
    	numItems = ComboBox_GetCount(combo);
    }
    else
    {
        numItems = 0;
    }

    return(numItems);
}

// Returns the index of the currently selected item
int CComboBox::GetSelectedIndex()
{
	return(ComboBox_GetCurSel(GetComboBox()));
}

// Sets the index of the currently selected item
void CComboBox::SetSelectedIndex(int index)
{
	ComboBox_SetCurSel(GetComboBox(), index);
}

// Gets the text for the control; returns the total text length
int CComboBox::GetText(
	LPTSTR szText,	// Where to put the text
	int nLen		// The length of the buffer
	)
{
	HWND edit = GetEdit();

	szText[0] = '\0';

	GetWindowText(edit, szText, nLen);
	return(GetWindowTextLength(edit));
}

int CComboBox::AddText(
	LPCTSTR pszText,	// The string to add
	LPARAM lUserData	// User data to associate with the string
	)
{
	HWND combo = GetComboBox();

	int index = ComboBox_AddString(combo, pszText);
	if (0 != lUserData && 0 <= index)
	{
		ComboBox_SetItemData(combo, index, lUserData);
	}

	return(index);
}

int CComboBox::GetText(
	UINT index,		// The index of the string to get
	LPTSTR pszText,	// The string buffer to fill
	int nLen		// User data to associate with the string
	)
{
	HWND combo = GetComboBox();

	int nActualLen = ComboBox_GetLBTextLen(combo, index);
	if (nActualLen >= nLen)
	{
		pszText[0] = '\0';
		return(nActualLen);
	}

	ComboBox_GetLBText(combo, index, pszText);
	return(nActualLen);
}

LPARAM CComboBox::GetUserData(
	int index	// The index of the user data to get
	)
{
	return(ComboBox_GetItemData(GetComboBox(), index));
}

// Removes an item from the list
void CComboBox::RemoveItem(
	UINT index	// The index of the item to remove
	)
{
	ComboBox_DeleteString(GetComboBox(), index);
}

void CComboBox::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (codeNotify)
	{
	case CBN_EDITUPDATE:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnTextChange(this);
		}
		break;

	case CBN_SETFOCUS:
		SetHotControl(this);
	case CBN_KILLFOCUS:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnFocusChange(this, CBN_SETFOCUS==codeNotify);
		}
		break;

	case CBN_SELCHANGE:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnSelectionChange(this);
		}
		break;
	}

	FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, CFillWindow::ProcessMessage);
}

void CComboBox::OnNCDestroy(HWND hwnd)
{
	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}

    m_combo = NULL;
	FORWARD_WM_NCDESTROY(hwnd, CFillWindow::ProcessMessage);
}

void CComboBox::Layout()
{
	HWND child = GetComboBox();
	if (NULL != child)
	{
		RECT rcClient;
		GetClientRect(GetWindow(), &rcClient);

		RECT rcDropped;
		ComboBox_GetDroppedControlRect(GetComboBox(), &rcDropped);

		SetWindowPos(child, NULL, 0, 0, rcClient.right, rcDropped.bottom-rcDropped.top, SWP_NOZORDER);
	}
}

// Get the info necessary for displaying a tooltip
void CComboBox::GetSharedTooltipInfo(TOOLINFO *pti)
{
	CFillWindow::GetSharedTooltipInfo(pti);

	// Since the child covers this whole area, we need to change the HWND to
	// hook
	HWND hwnd = GetChild();

	// HACKHACK georgep: Setting the tooltip on the first child of the combo
	// box, which should be the edit control
	if (NULL != hwnd)
	{
		hwnd = GetFirstChild(hwnd);
		if (NULL != hwnd)
		{
			pti->hwnd = hwnd;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\button.cpp ===
// File: BitmapButton.cpp

#include "precomp.h"

#include "GenControls.h"

#include <windowsx.h>

static const UINT IDT_FLASH = 1;
static const UINT FLASH_INTERVAL = 500;

CButton::CButton() :
	m_pNotify(NULL)
{
	m_sizeIcon.cx = 16;
	m_sizeIcon.cy = 16;
}

CButton::~CButton()
{
}

BOOL CButton::Create(
	HWND hWndParent,
	INT_PTR nId,
	LPCTSTR szTitle,
	DWORD dwStyle,
	IButtonChange *pNotify
	)
{
	if (!CFillWindow::Create(
		hWndParent,	// Window parent
		nId,		// ID of the child window
		szTitle,	// Window name
		0,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
		))
	{
		return(FALSE);
	}

	m_pNotify = pNotify;
	if (NULL != m_pNotify)
	{
		m_pNotify->AddRef();
	}

	// Create the Win32 button
	CreateWindowEx(0, TEXT("button"), szTitle,
		dwStyle|WS_CHILD|WS_VISIBLE|BS_NOTIFY,
		0, 0, 10, 10,
		GetWindow(),
		reinterpret_cast<HMENU>(nId),
		reinterpret_cast<HINSTANCE>(GetWindowLongPtr(hWndParent, GWLP_HINSTANCE)),
		NULL);

	return(TRUE);
}

// Set the icon displayed with this button
void CButton::SetIcon(
	HICON hIcon	// The icon to use for this button
	)
{
	SendMessage(GetChild(), BM_SETIMAGE, IMAGE_ICON, reinterpret_cast<LPARAM>(hIcon));

	m_sizeIcon.cx = 16;
	m_sizeIcon.cy = 16;

	// If we actually stored an icon, get its info
	hIcon = GetIcon();
	if (NULL != hIcon)
	{
		ICONINFO iconinfo;
		if (GetIconInfo(hIcon, &iconinfo))
		{
			if (NULL != iconinfo.hbmColor)
			{
				CBitmapButton::GetBitmapSizes(&iconinfo.hbmColor, &m_sizeIcon, 1);
				DeleteObject(iconinfo.hbmColor);
			}
			if (NULL != iconinfo.hbmMask)
			{
				DeleteObject(iconinfo.hbmMask);
			}
		}
	}
}

// Get the icon displayed with this button
HICON CButton::GetIcon()
{
	return(reinterpret_cast<HICON>(SendMessage(GetChild(), BM_GETIMAGE, IMAGE_ICON, 0)));
}

// Set the bitmap displayed with this button
void CButton::SetBitmap(
	HBITMAP hBitmap	// The bitmap to use for this button
	)
{
	SendMessage(GetChild(), BM_SETIMAGE, IMAGE_BITMAP, reinterpret_cast<LPARAM>(hBitmap));
}

// Get the bitmap displayed with this button
HBITMAP CButton::GetBitmap()
{
	return(reinterpret_cast<HBITMAP>(SendMessage(GetChild(), BM_GETIMAGE, IMAGE_BITMAP, 0)));
}

// Get/set the checked state of the button
void CButton::SetChecked(
	BOOL bCheck	// TRUE if the button should be checked
	)
{
	Button_SetCheck(GetChild(), bCheck);
}

BOOL CButton::IsChecked()
{
	return(Button_GetCheck(GetChild()));
}

void CButton::GetDesiredSize(SIZE *psize)
{
	static const int DefDlgUnitWidth = 50;
	static const int DefDlgUnitHeight = 14;
	static const int PushButtonBorder = 4;
	static const int CheckLeftBorder = 5;
	static const int CheckOtherBorder = 1;

	HWND child = GetChild();

	SIZE sizeMinPush = { 0, 0 };
	*psize = sizeMinPush;

	DWORD dwStyle = GetWindowLong(GetChild(), GWL_STYLE);

	switch (dwStyle&(BS_ICON|BS_BITMAP))
	{
	case BS_ICON:
	{
		*psize = m_sizeIcon;
		break;
	}

	case BS_BITMAP:
	{
		HBITMAP hImg = GetBitmap();
		if (NULL == hImg)
		{
			break;
		}
		CBitmapButton::GetBitmapSizes(&hImg, psize, 1);
		break;
	}

	default: // Text
	{
		// HACKHACK georgep: Button text should not be too large
		TCHAR szTitle[80];
		GetWindowText(child, szTitle, ARRAY_ELEMENTS(szTitle));

		HDC hdc = GetDC(child);

		HFONT hf = GetWindowFont(child);
		HFONT hOld = reinterpret_cast<HFONT>(SelectObject(hdc, hf));

		GetTextExtentPoint(hdc, szTitle, lstrlen(szTitle), psize);

		TEXTMETRIC tm;
		GetTextMetrics(hdc, &tm);
		sizeMinPush.cx = tm.tmAveCharWidth * DefDlgUnitWidth  / 4;
		sizeMinPush.cy = tm.tmHeight       * DefDlgUnitHeight / 8;

		SelectObject(hdc, hOld);
		ReleaseDC(child, hdc);
		break;
	}
	}

	switch (dwStyle&(BS_PUSHBUTTON|BS_CHECKBOX|BS_RADIOBUTTON))
	{
	case BS_CHECKBOX:
	case BS_RADIOBUTTON:
	{
		psize->cx += CheckLeftBorder + GetSystemMetrics(SM_CXMENUCHECK) + CheckOtherBorder;
		psize->cy += CheckOtherBorder*2;

		int cy = GetSystemMetrics(SM_CYMENUCHECK);
		psize->cy = max(psize->cy, cy);
		break;
	}

	case BS_PUSHBUTTON:
	default:
		psize->cx += PushButtonBorder*2;
		psize->cy += PushButtonBorder*2;

		psize->cx = max(psize->cx, sizeMinPush.cx);
		psize->cy = max(psize->cy, sizeMinPush.cy);
		break;
	}
}

LRESULT CButton::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_COMMAND  , OnCommand);

	case WM_DESTROY:
		if (NULL != m_pNotify)
		{
			m_pNotify->Release();
			m_pNotify = NULL;
		}
		break;
	}

	return(CFillWindow::ProcessMessage(hwnd, message, wParam, lParam));
}


void CButton::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	// Change the HWND to this and forward to the parent
	HWND hwndThis = GetWindow();

	switch (codeNotify)
	{
	case BN_CLICKED:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnClick(this);
			break;
		}
		FORWARD_WM_COMMAND(GetParent(hwndThis), id, hwndThis, codeNotify, ::SendMessage);
		break;

	case BN_SETFOCUS:
		SetHotControl(this);
		break;
	}
}

CBitmapButton::CBitmapButton() :
	m_hbStates(NULL),
	m_nInputStates(0),
	m_nCustomStates(0),
	m_nCustomState(0),
	m_bHot(FALSE),
	m_nFlashState(NoFlash)
{
}

CBitmapButton::~CBitmapButton()
{
	if (NULL != m_hbStates)
	{
		DeleteObject(m_hbStates);
		m_hbStates = NULL;
	}
}

BOOL CBitmapButton::Create(
	HWND hWndParent,	// The parent of the button
	int nId,			// The ID for WM_COMMAND messages
	HBITMAP hbStates,	// The 2D array of bitmaps for the states of the button,
						// vertically in the order specified in the StateBitmaps enum
						// and horizontally in the custom states order
	UINT nInputStates,	// The number of input states (Normal, Pressed, Hot, Disabled)
	UINT nCustomStates,	// The number of custom states
	IButtonChange *pNotify	// The click handler
	)
{
	// Copy the bitmap handle; note that we now own this bitmap, even if the
	// create fails
	m_hbStates = hbStates;

	// Must have a "normal" bitmap
	ASSERT(NULL!=hbStates && Normal<nInputStates && 1<=nCustomStates);

	if (!CButton::Create(
		hWndParent,		// Window parent
		nId,				// ID of the child window
		TEXT("NMButton"),	// Window name
		BS_OWNERDRAW|BS_NOTIFY|BS_PUSHBUTTON|WS_TABSTOP,	// Window style; WS_CHILD|WS_VISIBLE will be added to this
		pNotify
		))
	{
		return(FALSE);
	}

	m_nInputStates = nInputStates;
	m_nCustomStates = nCustomStates;

	return(TRUE);
}

// Creates the button, using the bitmaps specified
BOOL CBitmapButton::Create(
	HWND hWndParent,	// The parent of the button
	int nId,			// The ID for WM_COMMAND messages
	HINSTANCE hInst,	// The instance to load the bitmap from
	int nIdBitmap,		// The ID of the bitmap to use
	BOOL bTranslateColors,		// Use system background colors
	UINT nInputStates,	// The number of input states (Normal, Pressed, Hot, Disabled)
	UINT nCustomStates,			// The number of custom states
	IButtonChange *pNotify	// The click handler
	)
{
	HBITMAP hb;
	LoadBitmaps(hInst, &nIdBitmap, &hb, 1, bTranslateColors);

	return(Create(hWndParent, nId, hb, nInputStates, nCustomStates, pNotify));
}

// Return the size of the "normal" bitmap.
void CBitmapButton::GetDesiredSize(SIZE *ppt)
{
	// Note that I don't want CButton::GetDesiredSize
	CGenWindow::GetDesiredSize(ppt);

	BITMAP bm;

	// HACKHACK georgep: Only based on the normal bitmap
	if (NULL == m_hbStates || 0 == m_nInputStates || 0 == m_nCustomStates
		|| 0 == GetObject(m_hbStates, sizeof(BITMAP), &bm))
	{
		return;
	}

	ppt->cx += bm.bmWidth/m_nCustomStates;
	ppt->cy += bm.bmHeight/m_nInputStates;
}

#if FALSE
void DumpWindow(HWND hwnd, LPCTSTR pszPrefix)
{
	TCHAR szTemp[80];
	wsprintf(szTemp, TEXT("%s: %d "), pszPrefix, GetWindowLong(hwnd, GWL_ID));
	GetWindowText(hwnd, szTemp+lstrlen(szTemp), ARRAY_ELEMENTS(szTemp)-lstrlen(szTemp));
	lstrcat(szTemp, TEXT("\n"));
	OutputDebugString(szTemp);
}
#endif // FALSE

LRESULT CBitmapButton::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_DRAWITEM , OnDrawItem);
		HANDLE_MSG(hwnd, WM_SETCURSOR, OnSetCursor);
		HANDLE_MSG(hwnd, WM_TIMER    , OnTimer);

	case WM_ENABLE:
		SchedulePaint();
		break;
	}

	return(CButton::ProcessMessage(hwnd, message, wParam, lParam));
}

void CBitmapButton::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem)
{
	int nState = Normal;
	int state = lpDrawItem->itemState;

	// If pressed or selected, show the pressed bitmap
	if ((((state&ODS_DISABLED) == ODS_DISABLED) || !IsWindowEnabled(GetWindow())) && m_nInputStates > Disabled)
	{
		nState = Disabled;
	}
	// If pressed or selected, show the pressed bitmap
	else if ((state&ODS_SELECTED) == ODS_SELECTED && m_nInputStates > Pressed)
	{
		nState = Pressed;
	}
	// If hot, show the hot bitmap
	else if ((m_nFlashState != ForceNormal) && ((m_nFlashState == ForceHot) || IsHot()) && m_nInputStates > Hot)
	{
		nState = Hot;
	}
	// Otherwise show the normal bitmap
	else
	{
		nState = Normal;
	}

	// Draw in the upper left
	HDC hdcDraw = lpDrawItem->hDC;
	HDC hdcTemp = CreateCompatibleDC(hdcDraw);

	if (NULL != hdcTemp)
	{
		HPALETTE hPal = GetPalette();
		HPALETTE hOld = NULL;
		if (NULL != hPal)
		{
			hOld = SelectPalette(hdcDraw, hPal, TRUE);
			RealizePalette(hdcDraw);
			SelectPalette(hdcTemp, hPal, TRUE);
			RealizePalette(hdcTemp);
		}

		// This will tell me the size of an individual bitmap
		SIZE size;
		// Do not use an override
		CBitmapButton::GetDesiredSize(&size);

		if (NULL != SelectObject(hdcTemp, m_hbStates))
		{
			BitBlt(hdcDraw,
				lpDrawItem->rcItem.left, lpDrawItem->rcItem.top,
				size.cx, size.cy,
				hdcTemp, m_nCustomState*size.cx, nState*size.cy, SRCCOPY);

			// BUGBUG georgep: We should clear any "uncovered" area here
		}

		DeleteDC(hdcTemp);

		if (NULL != hPal)
		{
			SelectPalette(hdcDraw, hOld, TRUE);
		}
	}

	FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, CButton::ProcessMessage);
}

BOOL CBitmapButton::OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
{
	SetHotControl(this);

	return(FORWARD_WM_SETCURSOR(hwnd,hwndCursor, codeHitTest, msg, CButton::ProcessMessage));
}

void CBitmapButton::SetCustomState(UINT nCustomState)
{
	ASSERT(m_nCustomState < m_nCustomStates);

	if (m_nCustomState == nCustomState)
	{
		// Nothing to do
		return;
	}

	m_nCustomState = nCustomState;
	SchedulePaint();
}

void CBitmapButton::SetHot(BOOL bHot)
{
	bHot = (bHot != FALSE);
	if (m_bHot == bHot)
	{
		return;
	}

	m_bHot = bHot;
	SchedulePaint();
}


// Change to flashing mode
void CBitmapButton::SetFlashing(int nSeconds)
{
	HWND hwndThis = GetWindow();

	if (0 == nSeconds)
	{
		KillTimer(hwndThis, IDT_FLASH);

		// This means to stop flashing
		if (IsFlashing())
		{
			m_nFlashState = NoFlash;
			SchedulePaint();
		}
	}
	else
	{
		if (NULL == hwndThis)
		{
			// I need a window to do this
			return;
		}

		m_endFlashing = GetTickCount() + nSeconds*1000;

		if (!IsFlashing())
		{
			SetTimer(hwndThis, IDT_FLASH, FLASH_INTERVAL, NULL);
			OnTimer(hwndThis, IDT_FLASH);
		}
	}
}

void CBitmapButton::OnTimer(HWND hwnd, UINT id)
{
	if (IDT_FLASH == id)
	{
		if (static_cast<int>(GetTickCount() - m_endFlashing) > 0)
		{
			SetFlashing(0);
		}
		else
		{
			m_nFlashState = (ForceNormal==m_nFlashState ? ForceHot : ForceNormal);
			SchedulePaint();
		}
	}
}

// Helper function for getting the sizes of an array of bitmaps
void CBitmapButton::GetBitmapSizes(HBITMAP parts[], SIZE sizes[], int nParts)
{
	for (--nParts; nParts>=0; --nParts)
	{
		if (NULL == parts[nParts])
		{
			sizes[nParts].cx = sizes[nParts].cy = 0;
			continue;
		}

		BITMAP bm;
		GetObject(parts[nParts], sizeof(bm), &bm);
		sizes[nParts].cx = bm.bmWidth;
		sizes[nParts].cy = bm.bmHeight;
	}
}

// I would really rather just use LoadImage with the proper flags, but it turns
// out that Win95 then tries to write into a read-only resource, which faults.
// So I have to make a copy of the BITMAPINFO with the color table and change
// it myself.
static HBITMAP MyLoadImage(HINSTANCE hInst, int id)
{
	// Load up the bitmap resource bits
	HRSRC hFound = FindResource(hInst, MAKEINTRESOURCE(id), RT_BITMAP);
	if (NULL == hFound)
	{
		return(NULL);
	}
	HGLOBAL hLoaded = LoadResource(hInst, hFound);
	if (NULL == hLoaded)
	{
		return(NULL);
	}

	HBITMAP ret = NULL;

	LPVOID lpBits = LockResource(hLoaded);
	if (NULL != lpBits)
	{
		BITMAPINFO *pbmi = reinterpret_cast<BITMAPINFO*>(lpBits);
		// create a "shortcut"
		BITMAPINFOHEADER &bmih = pbmi->bmiHeader;

		// Only deal with 8bpp, uncompressed image
		if (bmih.biSize == sizeof(BITMAPINFOHEADER)
			&& 1 == bmih.biPlanes
			&& BI_RGB == bmih.biCompression)
		{
			// Determine the length of the color table
			UINT nColors = bmih.biClrUsed;
			if (0 == nColors)
			{
				nColors = 1 << bmih.biBitCount;
			}
			ASSERT(nColors <= static_cast<UINT>(1<<bmih.biBitCount));

			// Make a copy of the BITMAPINFO and color table so I can change
			// the value of one of the table entries.
			struct
			{
				BITMAPINFO bmi;
				RGBQUAD rgb[256];
			} mbmi;
			CopyMemory(&mbmi, pbmi, sizeof(BITMAPINFOHEADER)+nColors*sizeof(RGBQUAD));

			// This is a "packed DIB" so the pixels are immediately after the
			// color table
			LPBYTE pPixels = reinterpret_cast<LPBYTE>(&pbmi->bmiColors[nColors]);
			BYTE byFirst = pPixels[0];
			switch (bmih.biBitCount)
			{
			case 8:
				break;

			case 4:
				byFirst = (byFirst >> 4) & 0x0f;
				break;

			case 1:
				byFirst = (byFirst >> 7) & 0x01;
				break;

			default:
				goto CleanUp;
			}
			ASSERT(static_cast<UINT>(byFirst) < nColors);

			// Change the value of the first pixel to be the 3DFace color
			RGBQUAD &rgbChange = mbmi.bmi.bmiColors[byFirst];
			COLORREF cr3DFace = GetSysColor(COLOR_3DFACE);
			rgbChange.rgbRed   = GetRValue(cr3DFace);
			rgbChange.rgbGreen = GetGValue(cr3DFace);
			rgbChange.rgbBlue  = GetBValue(cr3DFace);

			// Create the DIB section and copy the bits into it
			LPVOID lpDIBBits;
			ret = CreateDIBSection(NULL, &mbmi.bmi, DIB_RGB_COLORS,
				&lpDIBBits, NULL, 0);
			if (NULL != ret)
			{
				// Round the width up to the nearest DWORD
				int widthBytes = (bmih.biWidth*bmih.biBitCount+7)/8;
				widthBytes = (widthBytes+3)&~3;
				CopyMemory(lpDIBBits, pPixels, widthBytes*bmih.biHeight);
			}
		}

CleanUp:
		UnlockResource(hLoaded);
	}

	FreeResource(hLoaded);

	return(ret);
}

//Helper function for loading up a bunch of bitmaps
void CBitmapButton::LoadBitmaps(
	HINSTANCE hInst,	// The instance to load the bitmap from
	const int ids[],	// Array of bitmap ID's
	HBITMAP bms[],		// Array of HBITMAP's for storing the result
	int nBmps,			// Number of entries in the arrays
	BOOL bTranslateColors // Use system background colors
	)
{
	for (--nBmps; nBmps>=0; --nBmps)
	{
		if (0 == ids[nBmps])
		{
			bms[nBmps] = NULL;
		}
		else
		{
// #define TRYBMPFILE
#ifdef TRYBMPFILE
			bms[nBmps] = NULL;

			// This is useful for the designer to try out different bitmaps
			TCHAR szFile[80];
			wsprintf(szFile, TEXT("%d.bmp"), ids[nBmps]);

			if (((DWORD)-1) != GetFileAttributes(szFile))
			{
				int nLoadFlags = LR_CREATEDIBSECTION;

				if (bTranslateColors)
				{
					nLoadFlags |= LR_LOADMAP3DCOLORS|LR_LOADTRANSPARENT;
				}
				bms[nBmps] = (HBITMAP)LoadImage(_Module.GetModuleInstance(),
					szFile, IMAGE_BITMAP, 0, 0, nLoadFlags|LR_LOADFROMFILE);
			}

			if (NULL == bms[nBmps])
#endif // TRYBMPFILE
			{
				if (bTranslateColors)
				{
					//
					// LAURABU 2/21/99 -- LoadImage with translated colors only works
					// on Win9x if your resources
					// are NOT read-only, since Win9x tries to write into the resource
					// memory temporarily.  It faults if not.
					//
					bms[nBmps] = MyLoadImage(hInst, ids[nBmps]);
				}

				if (NULL == bms[nBmps])
				{
					bms[nBmps] = (HBITMAP)LoadImage(hInst,
						MAKEINTRESOURCE(ids[nBmps]), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\cstring.cpp ===
// CSTRING.CPP
//
// Based on the original MFC source file.

//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <cstring.hpp>

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
REMAFX_DATADEF TCHAR AFXChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int RGInitData[] = { -1, 0, 0, 0 };
static REMAFX_DATADEF CSTRINGData* AFXDataNil = (CSTRINGData*)&RGInitData;
static LPCTSTR AFXPchNil = (LPCTSTR)(((BYTE*)&RGInitData)+sizeof(CSTRINGData));
// special function to make AFXEmptyString work even during initialization
const CSTRING& REMAFXAPI AFXGetEmptyString()
	{ return *(CSTRING*)&AFXPchNil; }


//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CSTRING::CSTRING()
{
	Init();
}

CSTRING::CSTRING(const CSTRING& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != AFXDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CSTRING::CSTRING(LPCTSTR lpch, int nLength)
{
	Init();

	if (nLength != 0)
	{
//		ASSERT(AfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

void CSTRING::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CSTRINGData* pData =
			(CSTRINGData*)new BYTE[sizeof(CSTRINGData) + (nLen+1)*sizeof(TCHAR)];
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}
}

void CSTRING::Release()
{
	if (GetData() != AFXDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

void PASCAL CSTRING::Release(CSTRINGData* pData)
{
	if (pData != AFXDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

void CSTRING::Empty()
{
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &AFXChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}


void CSTRING::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CSTRINGData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CSTRING::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CSTRING::~CSTRING()
//  free any attached data
{
	if (GetData() != AFXDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CSTRING::AllocCopy(CSTRING& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CSTRING::CSTRING(LPCTSTR lpsz)
{
	Init();
//	if (lpsz != NULL && HIWORD(lpsz) == NULL)
//	{
//		UINT nID = LOWORD((DWORD)lpsz);
//		if (!LoadString(nID)) {
//			;// TRACE1("Warning: implicit LoadString(%u) failed\n", nID);
//		}
//	}
//	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			AllocBuffer(nLen);
			memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CSTRING::CSTRING(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CSTRING::CSTRING(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? LStrLenW(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Diagnostic support

//#ifdef _DEBUG
//CDumpContext& REMAFXAPI operator<<(CDumpContext& dc, const CSTRING& string)
//{
//	dc << string.m_pchData;
//	return dc;
//}
//#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CSTRING&') so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CSTRING::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CSTRING& CSTRING::operator=(const CSTRING& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != AFXDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != AFXDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CSTRING& CSTRING::operator=(LPCTSTR lpsz)
{
//lts	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CSTRING& CSTRING::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CSTRING& CSTRING::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? LStrLenW(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CSTRING + CSTRING
// and for ? = TCHAR, LPCTSTR
//          CSTRING + ?
//          ? + CSTRING

void CSTRING::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CSTRING object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CSTRING REMAFXAPI operator+(const CSTRING& string1, const CSTRING& string2)
{
	CSTRING s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CSTRING REMAFXAPI operator+(const CSTRING& string, LPCTSTR lpsz)
{
//	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CSTRING s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CSTRING::SafeStrlen(lpsz), lpsz);
	return s;
}

CSTRING REMAFXAPI operator+(LPCTSTR lpsz, const CSTRING& string)
{
//	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CSTRING s;
	s.ConcatCopy(CSTRING::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CSTRING::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CSTRINGData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CSTRING::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CSTRING& CSTRING::operator+=(LPCTSTR lpsz)
{
//	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CSTRING& CSTRING::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CSTRING& CSTRING::operator+=(const CSTRING& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

/*
 * Length-sensitive comparison
 *
 *	NOTE: FEqual returns TRUE if the 2 CSTRINGS have the same length and contain
 *		  the same characters, and FALSE, otherwise.
 */

BOOL CSTRING::FEqual (const CSTRING &s2) const
{
	int						 length;

	// Compare the lengths first
	length = GetData()->nDataLength;
	if (length != s2.GetData()->nDataLength)
		return FALSE;

#ifdef _UNICODE
	// adjust the length in bytes
	length *= sizeof (TCHAR);
#endif

	/*
	 *	Now, compare the strings themselves
	 *	We use memcmp and not lstrcmp because the stings may
	 *	have embedded null characters.
	 */
	if (memcmp ((const void *) m_pchData, (const void *) s2.m_pchData, length))
		return FALSE;
	else
		return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CSTRING::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CSTRINGData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CSTRING::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CSTRING::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CSTRING::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CSTRING::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CSTRINGData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CSTRING::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CSTRING::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CSTRING::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != AFXDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)


// find position of the first character match  (or -1 on failure)
int CSTRING::Find(TCHAR ch) const
{
	for (TCHAR * pch = m_pchData; _T('\0') != *pch; pch = CharNext(pch))
	{
		if (ch == *pch)
			return ((int)(pch - m_pchData) / sizeof(TCHAR));
	}
	return -1;
}

CSTRING CSTRING::Left(int nCount) const
{
        if (nCount < 0)
                nCount = 0;
        else if (nCount > GetData()->nDataLength)
                nCount = GetData()->nDataLength;

        CSTRING dest;
        AllocCopy(dest, nCount, 0, 0);
		return dest;
}

CSTRING CSTRING::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CSTRING CSTRING::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CSTRING dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

void CSTRING::MakeUpper()
{
	CopyBeforeWrite();
	::CharUpper(m_pchData);
}

void CSTRING::MakeLower()
{
	CopyBeforeWrite();
	::CharLower(m_pchData);
}

void CSTRING::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CSTRING::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CSTRING conversion helpers (these use the current system locale)

int REMAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int REMAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR REMAFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
//lts	VERIFY(MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars));
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
}

LPSTR REMAFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
//lts	VERIFY(WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL));
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CSTRING::LoadString(HINSTANCE hInstance, UINT nID)
{
	// try buffer size of 256, then larger size until entire string is retrieved
	int nSize = -1;
	int nLen;
	do
	{
		nSize += 256;
		nLen = ::LoadString(hInstance, nID, GetBuffer(nSize), nSize+1);
	} while (nLen == nSize);
	ReleaseBuffer();

	return nLen > 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\centwnd.cpp ===
#include "precomp.h"
#include <oprahcom.h>


/*  C E N T E R  W I N D O W */
/*-------------------------------------------------------------------------
	%%Function: CenterWindow

	Center a window over another window.
-------------------------------------------------------------------------*/
VOID NMINTERNAL CenterWindow(HWND hwndChild, HWND hwndParent)
{
	int   xNew, yNew;
	int   cxChild, cyChild;
	int   cxParent, cyParent;
	int   cxScreen, cyScreen;
	RECT  rcChild, rcParent, rcScrn;

	// Get the Height and Width of the child window
	GetWindowRect(hwndChild, &rcChild);
	cxChild = rcChild.right - rcChild.left;
	cyChild = rcChild.bottom - rcChild.top;

	// Get the display limits
	GetWindowRect(GetDesktopWindow(), &rcScrn);
	cxScreen = rcScrn.right - rcScrn.left;
	cyScreen = rcScrn.bottom - rcScrn.top;

	if(hwndParent != NULL )
	{
	    // Get the Height and Width of the parent window
	    GetWindowRect(hwndParent, &rcParent);
	    cxParent = rcParent.right - rcParent.left;
	    cyParent = rcParent.bottom - rcParent.top;
	}
    else
    {
		// No parent - center on desktop
		cxParent = cxScreen;
		cyParent = cyScreen;
		SetRect(&rcParent, 0, 0, cxScreen, cyScreen);
    }

	// Calculate new X position, then adjust for screen
	xNew = rcParent.left + ((cxParent - cxChild) / 2);
	if (xNew < 0)
		xNew = 0;
	else if ((xNew + cxChild) > cxScreen)
		xNew = cxScreen - cxChild;

	// Calculate new Y position, then adjust for screen
	yNew = rcParent.top  + ((cyParent - cyChild) / 2);
	if (yNew < 0)
		yNew = 0;
	else if ((yNew + cyChild) > cyScreen)
		yNew = cyScreen - cyChild;

	SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0,
		SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\debspew.cpp ===
// File: DebSpew.cpp

#include "precomp.h"
#include <confreg.h>
#include <RegEntry.h>


#ifdef DEBUG /* THE WHOLE FILE! */

#if defined (_M_IX86)
#define _DbgBreak()  __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

/* Types
 ********/

PCSTR g_pcszSpewModule = NULL;

/* debug flags */

typedef enum _debugdebugflags
{
   DEBUG_DFL_ENABLE_TRACE_MESSAGES  = 0x0001,

   DEBUG_DFL_LOG_TRACE_MESSAGES     = 0x0002,

   DEBUG_DFL_ENABLE_CALL_TRACING    = 0x0008,

   DEBUG_DFL_INDENT                 = 0x2000,

   ALL_DEBUG_DFLAGS                 = (DEBUG_DFL_ENABLE_TRACE_MESSAGES |
                                       DEBUG_DFL_LOG_TRACE_MESSAGES |
                                       DEBUG_DFL_ENABLE_CALL_TRACING |
                                       DEBUG_DFL_INDENT)
}
DEBUGDEBUGFLAGS;


/* Global Variables
 *******************/


#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* parameters used by SpewOut() */

DWORD g_dwSpewFlags = 0;
UINT g_uSpewSev = 0;
UINT g_uSpewLine = 0;
PCSTR g_pcszSpewFile = NULL;

HDBGZONE  ghDbgZone = NULL;


/* TLS slot used to store stack depth for SpewOut() indentation */

#ifdef _DBGSTACK
DWORD s_dwStackDepthSlot = TLS_OUT_OF_INDEXES;

/* hack stack depth counter used until s_dwStackDepthSlot is not available */

ULONG_PTR s_ulcHackStackDepth = 0;
#endif

/* debug flags */

DWORD s_dwDebugModuleFlags = 0;

#pragma data_seg()



/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

BOOL IsValidSpewSev(UINT);


/*
** IsValidSpewSev()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL IsValidSpewSev(UINT uSpewSev)
{
   BOOL bResult;

   switch (uSpewSev)
   {
      case SPEW_TRACE:
      case SPEW_CALLTRACE:
      case SPEW_WARNING:
      case SPEW_ERROR:
      case SPEW_FATAL:
         bResult = TRUE;
         break;

      default:
         ERROR_OUT(("IsValidSpewSev(): Invalid debug spew severity %u.",
                    uSpewSev));
         bResult = FALSE;
         break;
   }

   return(bResult);
}


/****************************** Public Functions *****************************/


DWORD NMINTERNAL GetDebugOutputFlags(VOID)
{
	return s_dwDebugModuleFlags;
}

VOID NMINTERNAL SetDebugOutputFlags(DWORD dw)
{
	ASSERT(FLAGS_ARE_VALID(dw, ALL_DEBUG_DFLAGS));
	s_dwDebugModuleFlags = dw;

	// Save changed data back to registry
	RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);
	re.SetValue(REGVAL_DBG_SPEWFLAGS, dw);
}


/*
** InitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL NMINTERNAL InitDebugModule(PCSTR pcszSpewModule)
{
	RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);

	s_dwDebugModuleFlags = re.GetNumber(REGVAL_DBG_SPEWFLAGS, DEFAULT_DBG_SPEWFLAGS);


   g_pcszSpewModule = pcszSpewModule;

#ifdef _DBGSTACK

   ASSERT(s_dwStackDepthSlot == TLS_OUT_OF_INDEXES);

   s_dwStackDepthSlot = TlsAlloc();

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      EVAL(TlsSetValue(s_dwStackDepthSlot, (PVOID)s_ulcHackStackDepth));

      TRACE_OUT(("InitDebugModule(): Using thread local storage slot %lu for debug stack depth counter.",
                 s_dwStackDepthSlot));
   }
   else
	{
      WARNING_OUT(("InitDebugModule(): TlsAlloc() failed to allocate thread local storage for debug stack depth counter."));
	}
#endif

	if (NULL == ghDbgZone)
	{
		PSTR rgsz[4];
		rgsz[0] = (PSTR) pcszSpewModule;

		ASSERT(0 == ZONE_WARNING);
		rgsz[1+ZONE_WARNING]  = "Warning";

		ASSERT(1 == ZONE_TRACE);
		rgsz[1+ZONE_TRACE]    = "Trace";

		ASSERT(2 == ZONE_FUNCTION);
		rgsz[1+ZONE_FUNCTION] = "Function";

		// Initialize standard debug settings with warning enabled by default
		DbgInitEx(&ghDbgZone, rgsz, 3, 0x01);
	}

	return TRUE;
}


/*
** ExitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void NMINTERNAL ExitDebugModule(void)
{
#ifdef _DBGSTACK

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      s_ulcHackStackDepth = ((ULONG_PTR)TlsGetValue(s_dwStackDepthSlot));

      /* Leave s_ulcHackStackDepth == 0 if TlsGetValue() fails. */

      EVAL(TlsFree(s_dwStackDepthSlot));
      s_dwStackDepthSlot = TLS_OUT_OF_INDEXES;
   }
#endif
	g_pcszSpewModule = NULL;
	DBGDEINIT(&ghDbgZone);
}


/*
** StackEnter()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void NMINTERNAL StackEnter(void)
{
#ifdef _DBGSTACK

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      ULONG_PTR ulcDepth;

      ulcDepth = ((ULONG_PTR)TlsGetValue(s_dwStackDepthSlot));

      ASSERT(ulcDepth < ULONG_MAX);

      EVAL(TlsSetValue(s_dwStackDepthSlot, (PVOID)(ulcDepth + 1)));
   }
   else
   {
      ASSERT(s_ulcHackStackDepth < ULONG_MAX);
      s_ulcHackStackDepth++;
   }
#endif
   return;
}


/*
** StackLeave()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void NMINTERNAL StackLeave(void)
{
#ifdef _DBGSTACK

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      ULONG_PTR ulcDepth;

      ulcDepth = ((ULONG_PTR)TlsGetValue(s_dwStackDepthSlot));

      if (EVAL(ulcDepth > 0))
         EVAL(TlsSetValue(s_dwStackDepthSlot, (PVOID)(ulcDepth - 1)));
   }
   else
   {
      if (EVAL(s_ulcHackStackDepth > 0))
         s_ulcHackStackDepth--;
   }
#endif
   return;
}


/*
** GetStackDepth()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
ULONG_PTR NMINTERNAL GetStackDepth(void)
{
   ULONG_PTR ulcDepth = 0;
#ifdef _DBGSTACK

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
      ulcDepth = (ULONG)((ULONG_PTR)TlsGetValue(s_dwStackDepthSlot));
   else
      ulcDepth = s_ulcHackStackDepth;
#endif
   return(ulcDepth);
}



/*  _  D B G  Z  P R I N T  M S G  */
/*-------------------------------------------------------------------------
    %%Function: _DbgZPrintMsg

-------------------------------------------------------------------------*/
static VOID _DbgZPrintMsg(UINT iZone, PSTR pszFormat, va_list arglist)
{
	PCSTR pcszSpewPrefix;
	char  szModule[128];

    if (g_pcszSpewModule)
    {
    	switch (iZone)
	 	{
        	case ZONE_TRACE:
		        pcszSpewPrefix = "Trace";
        		break;
        	case ZONE_FUNCTION:
		        pcszSpewPrefix = "Func ";
        		break;
        	case ZONE_WARNING:
		        pcszSpewPrefix = "Warn ";
        		break;
        	default:
		        pcszSpewPrefix = "?????";
        		break;
		}

    	wsprintfA(szModule, "%s:%s", g_pcszSpewModule, pcszSpewPrefix);
    }
    else
    {
        // No module nonsense, empty prefix
        *szModule = 0;
    }

	if (IS_FLAG_CLEAR(s_dwDebugModuleFlags, DEBUG_DFL_INDENT))
	{
		// Don't indent output
		DbgPrintf(szModule, pszFormat, arglist);
	}
	else
	{
		PCSTR pcszIndent;
		ULONG_PTR ulcStackDepth;
		char  szFormat[512];
		static char _szSpewLeader[] = "                                                                                ";

		ulcStackDepth = GetStackDepth();
		if (ulcStackDepth > sizeof(_szSpewLeader))
			ulcStackDepth = sizeof(_szSpewLeader);

		pcszIndent = _szSpewLeader + sizeof(_szSpewLeader) - ulcStackDepth;

		wsprintfA(szFormat, "%s%s", pcszIndent, pszFormat);
		DbgPrintf(szModule, szFormat, arglist);
	}
}


VOID WINAPI DbgZPrintError(PSTR pszFormat,...)
{
    va_list v1;
    va_start(v1, pszFormat);

    _DbgZPrintMsg(ZONE_WARNING, pszFormat, v1);
    va_end(v1);

    _DbgBreak();
}


VOID WINAPI DbgZPrintWarning(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghDbgZone) & ZONE_WARNING_FLAG)
	{
		va_list v1;
		va_start(v1, pszFormat);
		
		_DbgZPrintMsg(ZONE_WARNING, pszFormat, v1);
		va_end(v1);
	}
}

VOID WINAPI DbgZPrintTrace(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghDbgZone) & ZONE_TRACE_FLAG)
	{
		va_list v1;
		va_start(v1, pszFormat);
		_DbgZPrintMsg(ZONE_TRACE, pszFormat, v1);
		va_end(v1);
	}
}

VOID WINAPI DbgZPrintFunction(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghDbgZone) & ZONE_FUNCTION_FLAG)
	{
		va_list v1;
		va_start(v1, pszFormat);
		_DbgZPrintMsg(ZONE_FUNCTION, pszFormat, v1);
		va_end(v1);
	}
}



#endif   /* DEBUG */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\dbg.cpp ===
/* dbg.cpp */

#include "precomp.h"
#include <oprahcom.h>
#include <cstring.hpp>
#include <regentry.h>
#include <confreg.h>
#include <confdbg.h>

#include <avUtil.h>


PSECURITY_DESCRIPTOR CreateSd( VOID);
BOOL CreateSids(  PSID *BuiltInAdministrators, PSID *PowerUsers, PSID *AuthenticatedUsers);

#ifdef NM_DEBUG  /* Almost the whole file */

// Special Debugbreak macro
#if defined (_M_IX86)
#define _DbgBreak()  __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

// Special Mutex Macros
#define ACQMUTEX(hMutex)	WaitForSingleObject(hMutex, INFINITE)
#define RELMUTEX(hMutex)	ReleaseMutex(hMutex)

// Constant for GlobalAddAtom
const int CCHMAX_ATOM = 255;

// Local Variables
static PNMDBG    _gpDbg = NULL;            // Shared data in mmf after zone info
static HANDLE    _ghMutexFile = NULL;      // Mutex for writing to file
static PZONEINFO _gprgZoneInfo = NULL;     // the address in which the zone is mapped,points to an array of zones
static HANDLE    _ghDbgZoneMap = NULL;     // the handle of the memory mapped file for zones
static HANDLE    _ghDbgZoneMutex = NULL;   // Mutex for accessing Zone information
static long      _gLockCount = 0;

VOID DbgCurrentTime(PCHAR psz);


/*  _  D B G  P R I N T F  */
/*-------------------------------------------------------------------------
    %%Function: _DbgPrintf

    The main, low level, debug output routine.
-------------------------------------------------------------------------*/
static VOID WINAPI _DbgPrintf(LPCSTR pszFile, PCSTR pszPrefix, PCSTR pszFormat, va_list ap)
{
	CHAR  szOutput[1024];
	PCHAR pszOutput = szOutput;
	UINT  cch;

	if (NULL == _gprgZoneInfo)
		return;

	if (DBG_FMTTIME_NONE != _gpDbg->uShowTime)
	{
		DbgCurrentTime(pszOutput);
		pszOutput += lstrlenA(pszOutput);
	}

	if (_gpDbg->fShowThreadId)
	{
		wsprintfA(pszOutput, "[%04X] ", GetCurrentThreadId());
		pszOutput += lstrlenA(pszOutput);
	}

	if (_gpDbg->fShowModule)
	{
		CHAR szFile[MAX_PATH];

		if ((NULL == pszPrefix) || ('\0' == *pszPrefix))
		{
			GetModuleFileNameA(NULL, szFile, sizeof(szFile));
			pszPrefix = ExtractFileNameA(szFile);
		}

		lstrcpyA(pszOutput, pszPrefix);
		pszOutput += lstrlenA(pszOutput);
		lstrcpyA(pszOutput, " ");
		pszOutput += 1;
	}

	wvsprintfA(pszOutput, pszFormat, ap);


	// Append carriage return, if necessary
	// WARNING: This code is not DBCS-safe.
	cch = lstrlenA(szOutput);
	if (szOutput[cch-1] == '\n')
	{
		if (szOutput[cch-2] != '\r')
		{
			lstrcpyA(&szOutput[cch-1], "\r\n");
			cch++;
		}
	}
	else
	{
		lstrcpyA(&szOutput[cch], "\r\n");
		cch += 2;
	}


	// Output to debug handler
	if (_gpDbg->fOutputDebugString)
	{
		OutputDebugStringA(szOutput);
	}


	// Output to File
	if (_gpDbg->fFileOutput || (NULL != pszFile))
	{
		HANDLE hFile;
		DWORD dw;

		// Lock access to file
		ACQMUTEX(_ghMutexFile);

		if (NULL == pszFile)
			pszFile = _gpDbg->szFile;

		// open a log file for appending. create if does not exist
		hFile = CreateFileA(pszFile, GENERIC_WRITE, 0, NULL,
			OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			// seek to end of file
			dw = SetFilePointer(hFile, 0, NULL, FILE_END);

#ifdef TEST /* Test/Retail version truncates at 40K */
			if (dw > 0x040000)
			{
				CloseHandle(hFile);
				hFile = CreateFileA(pszFile, GENERIC_WRITE, 0, NULL,
					TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
			}										
			if (INVALID_HANDLE_VALUE != hFile)
#endif
			{
				WriteFile(hFile, szOutput, lstrlenA(szOutput), &dw, NULL);
				CloseHandle(hFile);
			}
		}

		// Unlock access to file
		RELMUTEX(_ghMutexFile);
	}

	// Output to viewer.  This is at the end of the function because
	// we potentially truncate szOutput.
	if ((_gpDbg->fWinOutput) && (NULL != _gpDbg->hwndCtrl))
	{
		// Make sure that the string doesn't exceed the maximum atom size.
		// WARNING: This code is not DBCS-safe.
		static const CHAR szTruncatedSuffix[] = "...\r\n";
		static const int cchTruncatedSuffix = ARRAY_ELEMENTS(szTruncatedSuffix) - 1;

		if (CCHMAX_ATOM < cch)
		{
			lstrcpyA(&szOutput[CCHMAX_ATOM - cchTruncatedSuffix], szTruncatedSuffix);
		}

		ATOM aDbgAtom = GlobalAddAtomA(szOutput);

		if (aDbgAtom)
		{
			if (!PostMessage(_gpDbg->hwndCtrl, _gpDbg->msgDisplay, (WPARAM)aDbgAtom, 0L))
			{
				// Unable to post Message, so free the atom
				GlobalDeleteAtom(aDbgAtom);
			}
		}
	}

}


PSTR WINAPI DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...)
{
	CHAR sz[MAXSIZE_OF_MODULENAME+MAXSIZE_OF_ZONENAME+1];
	PCHAR psz;
	va_list v1;
	va_start(v1, pszFormat);

	if ((NULL != hZone) && (iZone < MAXNUM_OF_ZONES))
	{
	    wsprintfA(sz, "%hs:%hs", ((PZONEINFO) hZone)->pszModule, ((PZONEINFO) hZone)->szZoneNames[iZone]);
	    psz = sz;
	}
	else
	{
		psz = NULL;
	}


	if ((NULL != hZone) && ('\0' != ((PZONEINFO) hZone)->szFile[0]))
	{
		// Use the private module output filename, if specified
		_DbgPrintf(((PZONEINFO) hZone)->szFile, psz, pszFormat, v1);
	}
	else
	{
		_DbgPrintf(NULL, psz, pszFormat, v1);
	}
	
	va_end(v1);
	return pszFormat;
}


PSTR WINAPI DbgZVPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat, va_list ap)
{
	CHAR sz[MAXSIZE_OF_MODULENAME+MAXSIZE_OF_ZONENAME+1];
	PCHAR psz;

	if ((NULL != hZone) && (iZone < MAXNUM_OF_ZONES))
	{
	    wsprintfA(sz, "%hs:%hs", ((PZONEINFO) hZone)->pszModule, ((PZONEINFO) hZone)->szZoneNames[iZone]);
	    psz = sz;
	}
	else
	{
		psz = NULL;
	}


	if ((NULL != hZone) && ('\0' != ((PZONEINFO) hZone)->szFile[0]))
	{
		// Use the private module output filename, if specified
		_DbgPrintf(((PZONEINFO) hZone)->szFile, psz, pszFormat, ap);
	}
	else
	{
		_DbgPrintf(NULL, psz, pszFormat, ap);
	}
	
	return pszFormat;
}


VOID WINAPI DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap)
{
	_DbgPrintf(NULL, pszPrefix, pszFormat, ap);
}


VOID NMINTERNAL DbgInitEx(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZones, long ulZoneDefault)
{
	UINT i;
	HDBGZONE hDbgZone;
	DBGZONEINFO dbgZoneParm;

	//DbgMsg("Module %s (%d zones)", *psz, cZones);

	InterlockedIncrement( &_gLockCount );

	InitDbgZone();

	if (cZones > MAXNUM_OF_ZONES)
		cZones = MAXNUM_OF_ZONES;


	ZeroMemory(&dbgZoneParm, sizeof(dbgZoneParm));
	
	// First string is the module name
	lstrcpynA(dbgZoneParm.pszModule, *psz, CCHMAX(dbgZoneParm.pszModule));

	// Copy the zone names
	for (i = 0; i < cZones; i++)
	{
		lstrcpynA(dbgZoneParm.szZoneNames[i], psz[1+i], CCHMAX(dbgZoneParm.szZoneNames[0]));
	}

	// Get the detault zone settings
	{
		RegEntry reZones(ZONES_KEY, HKEY_LOCAL_MACHINE);
		dbgZoneParm.ulZoneMask = reZones.GetNumber(CUSTRING(dbgZoneParm.pszModule), ulZoneDefault);
	}

	hDbgZone = NmDbgCreateZone(dbgZoneParm.pszModule);
	if (NULL == hDbgZone)
	{
		OutputDebugStringA("DbgInit: Failed to create zones!\r\n");
		return;
	}

	NmDbgSetZone(hDbgZone, &dbgZoneParm);
	*phDbgZone = hDbgZone;
}


VOID NMINTERNAL DbgDeInit(HDBGZONE * phDbgZone)
{
	if (NULL == phDbgZone)
		return;

	if (NULL == *phDbgZone)
		return;

	//DbgMsg("Freeing Zone [%s]",((PZONEINFO)(*phDbgZone))->pszModule);

	NmDbgDeleteZone("", *phDbgZone);
	*phDbgZone = NULL;

    if( 0 == InterlockedDecrement( &_gLockCount ) )
    {
        UnMapDebugZoneArea();

        if( _ghMutexFile )
        {
            CloseHandle( _ghMutexFile );
            _ghMutexFile = NULL;
        }

        if( _ghDbgZoneMutex )
        {
            CloseHandle( _ghDbgZoneMutex );
            _ghDbgZoneMutex = NULL;
        }
    }
}




//////////////////////////////////////////////////////////////////////////////////
// from dbgzone.cpp



/***************************************************************************

	Name      :	NmDbgCreateZones

	Purpose   :	A module calls this to allocate/initialize the zone area for debugging
				purposes.

	Parameters:	pszName - the name of the module

	Returns   :	

	Comment   :	

***************************************************************************/
HDBGZONE WINAPI NmDbgCreateZone(LPSTR pszName)
{

	PZONEINFO pZoneInfo=NULL;

 	if (!(pZoneInfo = FindZoneForModule(pszName)))
	 	pZoneInfo = AllocZoneForModule(pszName);
	return ((HDBGZONE)pZoneInfo);
}


/***************************************************************************

	Name      :	NmDbgDeleteZones

	Purpose   :	

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
void WINAPI NmDbgDeleteZone(LPSTR pszName, HDBGZONE hDbgZone)
{
	//decrement reference count
	PZONEINFO pZoneInfo = (PZONEINFO)hDbgZone;

    ASSERT( _ghDbgZoneMutex );

	ACQMUTEX(_ghDbgZoneMutex);

	if (pZoneInfo)
	{
		pZoneInfo->ulRefCnt--;
		if (pZoneInfo->ulRefCnt == 0)
		{
			pZoneInfo->bInUse = FALSE;
			pZoneInfo->ulSignature = 0;
		}
	}

	RELMUTEX(_ghDbgZoneMutex);
}



/***************************************************************************

	Name      :	NmDbgSetZones

	Purpose   :	

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
BOOL WINAPI NmDbgSetZone(HDBGZONE hDbgZone, PDBGZONEINFO pZoneParam)
{
	PZONEINFO pZoneInfo = (PZONEINFO)hDbgZone;

	if (!pZoneInfo)
		return FALSE;
	
	if (lstrcmpA(pZoneInfo->pszModule,pZoneParam->pszModule))
		return FALSE;

	pZoneInfo->ulZoneMask = pZoneParam->ulZoneMask;
	CopyMemory(pZoneInfo->szZoneNames, pZoneParam->szZoneNames,
		(sizeof(CHAR) * MAXNUM_OF_ZONES * MAXSIZE_OF_ZONENAME));
	return(TRUE);
}



/***************************************************************************

	Name      :	NmDbgGetZoneParams

	Purpose   :	

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
BOOL WINAPI NmDbgGetAllZoneParams(PDBGZONEINFO *plpZoneParam,LPUINT puCnt)
{
	UINT		ui;
	PZONEINFO	pCurZone;

	if ((NULL == plpZoneParam) || (NULL == puCnt))
		return FALSE;
		
	ACQMUTEX(_ghDbgZoneMutex);

	*puCnt = 0;
	for (pCurZone = _gprgZoneInfo, ui=0;
		ui<MAXNUM_OF_MODULES && pCurZone!=NULL;
		ui++,pCurZone++)
	{
	 	if ((pCurZone->bInUse) && (pCurZone->ulSignature == ZONEINFO_SIGN))
		{
			(*puCnt)++;
		}
	}

	*plpZoneParam = _gprgZoneInfo;
	
	RELMUTEX(_ghDbgZoneMutex);
	return TRUE;
}


BOOL WINAPI NmDbgFreeZoneParams(PDBGZONEINFO pZoneParam)
{
	return TRUE;
}


PZONEINFO NMINTERNAL FindZoneForModule(LPCSTR pszModule)
{
	int i;
	PZONEINFO pCurZone;

	for (pCurZone = _gprgZoneInfo,i=0;i<MAXNUM_OF_MODULES && pCurZone!=NULL;i++,pCurZone++)
	{
	 	if ((pCurZone->bInUse) && (pCurZone->ulSignature == ZONEINFO_SIGN)
			&& (!lstrcmpA(pCurZone->pszModule,pszModule)))
		{
			ACQMUTEX(_ghDbgZoneMutex);		
			pCurZone->ulRefCnt++;
			RELMUTEX(_ghDbgZoneMutex);
			return pCurZone;
		}
	}
	return NULL;

}




/***************************************************************************

	Name      :	AllocZoneForModule

	Purpose   :	Allocates the

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
PZONEINFO NMINTERNAL AllocZoneForModule(LPCSTR pszModule)
{
	int i;
	PZONEINFO pCurZone;
	PZONEINFO pZoneForMod=NULL;

	ACQMUTEX(_ghDbgZoneMutex);
	for (pCurZone = _gprgZoneInfo,i=0;
		(i<MAXNUM_OF_MODULES && pCurZone!=NULL);
		i++,pCurZone++)
	{
	 	if (!(pCurZone->bInUse))
		{
			pCurZone->bInUse = TRUE;
			pCurZone->ulSignature = ZONEINFO_SIGN;
			pCurZone->ulRefCnt = 1;
			lstrcpyA(pCurZone->pszModule, pszModule);
			pZoneForMod = pCurZone;
			break;
		}
	}
	
	RELMUTEX(_ghDbgZoneMutex);
	return(pZoneForMod);

}


VOID NMINTERNAL SetDbgFlags(void)
{
	PTSTR psz;
	RegEntry reDebug(DEBUG_KEY, HKEY_LOCAL_MACHINE);

	_gpDbg->fOutputDebugString = reDebug.GetNumber(REGVAL_DBG_OUTPUT, DEFAULT_DBG_OUTPUT);
	_gpDbg->fWinOutput = reDebug.GetNumber(REGVAL_DBG_WIN_OUTPUT, DEFAULT_DBG_NO_WIN);
	_gpDbg->fFileOutput = reDebug.GetNumber(REGVAL_DBG_FILE_OUTPUT, DEFAULT_DBG_NO_FILE);

	_gpDbg->uShowTime = reDebug.GetNumber(REGVAL_DBG_SHOW_TIME, DBG_FMTTIME_NONE);
	_gpDbg->fShowThreadId = reDebug.GetNumber(REGVAL_DBG_SHOW_THREADID, 0);
	_gpDbg->fShowModule = reDebug.GetNumber(REGVAL_DBG_SHOW_MODULE, 0);

	psz = reDebug.GetString(REGVAL_DBG_FILE);
	if (0 != lstrlen(psz))
	{
		lstrcpyA(_gpDbg->szFile, CUSTRING(psz));
	}
	else
	{
		UINT cchFile;

		cchFile = GetWindowsDirectoryA(_gpDbg->szFile, CCHMAX(_gpDbg->szFile));
		_gpDbg->szFile[cchFile++] = '\\';
		lstrcpyA(_gpDbg->szFile + cchFile, CUSTRING(DEFAULT_DBG_FILENAME));
	}
}


VOID InitZoneMmf(PZONEINFO prgZoneInfo)
{
	ZeroMemory(prgZoneInfo, CBMMFDBG);

	SetDbgFlags();
}


PZONEINFO NMINTERNAL MapDebugZoneArea(void)
{
	PZONEINFO prgZoneInfo = NULL;
	BOOL	  fCreated;
	PSECURITY_DESCRIPTOR    sd = NULL;
	SECURITY_ATTRIBUTES     sa;

	// Obtain a true NULL security descriptor (so if running as a service, user processes can access it)
	
//	InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
//	SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);  // NULL DACL = wide open

    sd = CreateSd();

	FillMemory(&sa, sizeof(sa), 0);
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = sd;

	//create a memory mapped object that is backed by paging file	
	_ghDbgZoneMap = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE,
		0, CBMMFDBG, SZ_DBG_MAPPED_ZONE);

	if (_ghDbgZoneMap)
	{

		fCreated = (0 == GetLastError());
	   	prgZoneInfo = (PZONEINFO) MapViewOfFile(_ghDbgZoneMap, FILE_MAP_READ|FILE_MAP_WRITE, 0,0,0);
	   	if (NULL != prgZoneInfo)
	   	{
	   		// Grab pointer to shared data area
	   		_gpDbg = (PNMDBG) (((PBYTE) prgZoneInfo) + (MAXNUM_OF_MODULES * sizeof(ZONEINFO)));
	   		if (fCreated)
	   			InitZoneMmf(prgZoneInfo);
		}

	}

	if(sd)
	{
		HeapFree(GetProcessHeap(), 0, sd);
	}
	
	return prgZoneInfo;
}


VOID NMINTERNAL UnMapDebugZoneArea(void)
{
	if (_gprgZoneInfo)
	{
		UnmapViewOfFile(_gprgZoneInfo);
		_gprgZoneInfo = NULL;
	}

	ClosePh(&_ghDbgZoneMap);
}


VOID NMINTERNAL InitDbgZone(void)
{
	if (NULL != _gprgZoneInfo)
		return; // already initialized

	_gprgZoneInfo = MapDebugZoneArea();

	// Create log file data
	PSECURITY_DESCRIPTOR    sd = NULL;
	SECURITY_ATTRIBUTES     sa;

	// Obtain a true NULL security descriptor (so if running as a service, user processes can access it)
	
//	InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
//	SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);  // NULL DACL = wide open
    sd = CreateSd();

	FillMemory(&sa, sizeof(sa), 0);
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = sd;

	_ghMutexFile = CreateMutex(&sa, FALSE, SZ_DBG_FILE_MUTEX);
	_ghDbgZoneMutex = CreateMutex(&sa, FALSE, SZ_DBG_ZONE_MUTEX);

	if (_gpDbg != NULL && _gpDbg->fFileOutput)
	{
		HANDLE  hFile;
    	DWORD dw;
    	CHAR sz[MAX_PATH];
		SYSTEMTIME  systime;


    	hFile = CreateFileA(_gpDbg->szFile,
    		GENERIC_WRITE | GENERIC_WRITE, 0, &sa,
    		CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    	if (INVALID_HANDLE_VALUE == hFile)
		{
			_gpDbg->fFileOutput = FALSE;
			goto cleanup;
		}

		GetLocalTime(&systime);

		wsprintfA(sz,
	     	"\r\n======== TRACE Started: %hu/%hu/%hu (%hu:%hu)\r\n",
	     	systime.wMonth, systime.wDay, systime.wYear, systime.wHour, systime.wMinute);

		SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile(hFile, sz, lstrlenA(sz), &dw, NULL);

		CloseHandle(hFile);
	}

cleanup:
	if (sd)
	{
		HeapFree(GetProcessHeap(), 0, sd);
	}
	
}


///////////////////////////////////////
// Routines for controlling debug output

BOOL WINAPI NmDbgRegisterCtl(HWND hwnd, UINT uDisplayMsg)
{
	if ((NULL == _gpDbg) || (NULL != _gpDbg->hwndCtrl))
		return FALSE;

	_gpDbg->msgDisplay = uDisplayMsg;
	_gpDbg->hwndCtrl = hwnd;
	return TRUE;
}

BOOL WINAPI NmDbgDeregisterCtl(HWND hwnd)
{
	if ((NULL == _gpDbg) || (hwnd != _gpDbg->hwndCtrl))
		return FALSE;

	_gpDbg->hwndCtrl = NULL;
	_gpDbg->msgDisplay = 0;
	return TRUE;
}

BOOL WINAPI NmDbgSetLoggingOptions(HWND hwnd, UINT uOptions)
{
	return FALSE;
}

PNMDBG WINAPI GetPNmDbg(void)
{
	return _gpDbg;
}

VOID WINAPI NmDbgSetZoneFileName(HDBGZONE hZone, LPCSTR pszFile)
{
	PSTR pszZoneFile;

	if (IsBadWritePtr((PVOID) hZone, sizeof(ZONEINFO)))
		return;

	if (((PZONEINFO) hZone)->ulSignature != ZONEINFO_SIGN)
		return;

	pszZoneFile =  &(((PZONEINFO) hZone)->szFile[0]);

	if (NULL == pszFile)
	{
    	*pszZoneFile = '\0';
    }
    else
    {
    	lstrcpynA(pszZoneFile, pszFile, CCHMAX(((PZONEINFO) hZone)->szFile));
    }
}

/*  D B G  C U R R E N T  T I M E  */
/*-------------------------------------------------------------------------
    %%Function: DbgCurrentTime

    Format the current time
-------------------------------------------------------------------------*/
VOID DbgCurrentTime(PCHAR psz)
{
	if (DBG_FMTTIME_TICK == _gpDbg->uShowTime)
	{
		wsprintfA(psz, "[%04X] ", GetTickCount());
	}
	else
	{
		SYSTEMTIME sysTime;
		GetLocalTime(&sysTime);

		switch (_gpDbg->uShowTime)
			{
		default:
		case DBG_FMTTIME_FULL:
			wsprintfA(psz, "[%04d/%02d/%02d %02d:%02d:%02d.%03d] ",
				sysTime.wYear, sysTime.wMonth, sysTime.wDay,
				sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
			break;
		case DBG_FMTTIME_DAY:
			wsprintfA(psz, "[%02d:%02d:%02d.%03d] ",
				sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
			break;
			}
	}
}




/*  P S Z  P R I N T F  */
/*-------------------------------------------------------------------------
    %%Function: PszPrintf

	Utility function to wsprintf a string for debug.
-------------------------------------------------------------------------*/
PSTR PszPrintf(PCSTR pszFormat,...)
{
	PSTR psz = (PSTR) LocalAlloc(LMEM_FIXED, MAX_PATH);
	if (NULL != psz)
	{
	    va_list v1;
		va_start(v1, pszFormat);
	    wvsprintfA(psz, pszFormat, v1);
		va_end(v1);
	}
	return psz;
}


/*  D E B U G  T R A P  F N  */
/*-------------------------------------------------------------------------
    %%Function: DebugTrapFn
-------------------------------------------------------------------------*/
VOID NMINTERNAL DebugTrapFn(VOID)
{
	_DbgBreak();
}


VOID DebugPrintfTraceMem(LPCSTR pszFormat,...)
{
    // DO NOTHING
	va_list arglist;

	va_start(arglist, pszFormat);
	va_end(arglist);
}



#endif /* NM_DEBUG - almost the whole file */
/*************************************************************************/


const int RPF_UNKNOWN  = 0;
const int RPF_ENABLED  = 1;
const int RPF_DISABLED = 2;

static int gRpf = RPF_UNKNOWN;
static TCHAR gszRetailOutputFilename[MAX_PATH];    // retail trace filename


/*  F  E N A B L E D  R E T A I L  P R I N T F  */
/*-------------------------------------------------------------------------
    %%Function: FEnabledRetailPrintf

    Return TRUE if retail output is enabled.
-------------------------------------------------------------------------*/
BOOL FEnabledRetailPrintf(VOID)
{
	if (RPF_UNKNOWN == gRpf)
	{
		RegEntry reDebug(DEBUG_KEY, HKEY_LOCAL_MACHINE);
		gRpf = reDebug.GetNumber(REGVAL_RETAIL_LOG, RPF_DISABLED);
		if ((RPF_ENABLED != gRpf) ||
			   (!GetInstallDirectory(gszRetailOutputFilename)) )
		{
			gRpf = RPF_DISABLED;
		}
		else
		{
			lstrcat(gszRetailOutputFilename, RETAIL_LOG_FILENAME);
		}

	}

	return (RPF_ENABLED == gRpf);
}


/*  R E T A I L  P R I N T F  T R A C E  */
/*-------------------------------------------------------------------------
    %%Function: RetailPrintfTrace

    Print retail information to a file
-------------------------------------------------------------------------*/
VOID WINAPI RetailPrintfTrace(LPCSTR pszFormat,...)
{
	HANDLE  hFile;
	va_list v1;
	CHAR    szOutput[1024];

	if (!FEnabledRetailPrintf())
		return;  // Retail output is disabled

	va_start(v1, pszFormat);


#ifdef DEBUG
	// Also use normal output mechanism for debug builds
	_DbgPrintf(NULL, "Retail:PrintfTrace", pszFormat, v1);
#endif

	wvsprintfA(szOutput, pszFormat, v1);

	// Always append the CRLF
	ASSERT(lstrlenA(szOutput) < (CCHMAX(szOutput)-2));
	lstrcatA(szOutput, "\r\n");


	// open a log file for appending. create if does not exist
	hFile = CreateFile(gszRetailOutputFilename, GENERIC_WRITE,
		0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		// seek to end of file
		DWORD dw = SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile(hFile, szOutput, lstrlenA(szOutput), &dw, NULL);
		CloseHandle(hFile);
	}
	
	va_end(v1);
}



//
// CreateSids
//
// Create 3 Security IDs
//
// Caller must free memory allocated to SIDs on success.
//
// Returns: TRUE if successfull, FALSE if not.
//


BOOL
CreateSids(
    PSID                    *BuiltInAdministrators,
    PSID                    *PowerUsers,
    PSID                    *AuthenticatedUsers
)
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  BuiltInAdministrators)) {

        // error

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         2,            // 2 sub-authorities
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_POWER_USERS,
                                         0,0,0,0,0,0,
                                         PowerUsers)) {

        // error

        FreeSid(*BuiltInAdministrators);
        *BuiltInAdministrators = NULL;

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_AUTHENTICATED_USER_RID,
                                         0,0,0,0,0,0,0,
                                         AuthenticatedUsers)) {

        // error

        FreeSid(*BuiltInAdministrators);
        *BuiltInAdministrators = NULL;

        FreeSid(*PowerUsers);
        *PowerUsers = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


//
// CreateSd
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.  Modify the code to
// change. 
//
// Caller must free the returned buffer if not NULL.
//

PSECURITY_DESCRIPTOR
CreateSd(
    VOID
)
{
    PSID                    AuthenticatedUsers;
    PSID                    BuiltInAdministrators;
    PSID                    PowerUsers;

    if (!CreateSids(&BuiltInAdministrators,
                    &PowerUsers,
                    &AuthenticatedUsers)) {

        // error

    } else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        PSECURITY_DESCRIPTOR    Sd = NULL;
        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(AuthenticatedUsers) +
            GetLengthSid(BuiltInAdministrators) +
            GetLengthSid(PowerUsers);

        Sd = (PSECURITY_DESCRIPTOR) HeapAlloc(GetProcessHeap(), 0, SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

        if (!Sd) {

            // error

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                // error

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ,
                                            AuthenticatedUsers)) {

                // Failed to build the ACE granting "Authenticated users"
                // (SYNCHRONIZE | GENERIC_READ) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                            PowerUsers)) {

                // Failed to build the ACE granting "Power users"
                // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            BuiltInAdministrators)) {

                // Failed to build the ACE granting "Built-in Administrators"
                // GENERIC_ALL access.

            } else if (!InitializeSecurityDescriptor(Sd,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                // error

            } else if (!SetSecurityDescriptorDacl(Sd,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                // error

            } else {
                FreeSid(AuthenticatedUsers);
                FreeSid(BuiltInAdministrators);
                FreeSid(PowerUsers);

                return Sd;
            }

            HeapFree(GetProcessHeap(), 0, Sd);
        }

        FreeSid(AuthenticatedUsers);
        FreeSid(BuiltInAdministrators);
        FreeSid(PowerUsers);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\edittext.cpp ===
// File: BitmapButton.cpp

#include "precomp.h"

#include "GenControls.h"

#include <windowsx.h>

CEditText::CEditText() : m_hbrBack(NULL), m_pNotify(NULL)
{
}

CEditText::~CEditText()
{
	SetColors(NULL, 0, 0);
	SetFont(NULL);

	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}
}

BOOL CEditText::Create(
	HWND hWndParent,			// Parent of the edit control
	DWORD dwStyle,				// Edit control style
	DWORD dwExStyle,			// Extended window style
	LPCTSTR szTitle,			// Initial text for the edit control
	IEditTextChange *pNotify	// Object to notify of changes
	)
{
	if (!CFillWindow::Create(
		hWndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMEditText"),	// Window name
		0,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		dwExStyle|WS_EX_CONTROLPARENT		// Extended window style
		))
	{
		return(FALSE);
	}

	// Create the actual edit control and save it away
	m_edit = CreateWindowEx(0, TEXT("edit"), szTitle,
		WS_CHILD|WS_VISIBLE|WS_TABSTOP|dwStyle,
		0, 0, 10, 10, GetWindow(), 0,
		reinterpret_cast<HINSTANCE>(GetWindowLongPtr(hWndParent, GWLP_HINSTANCE)),
		NULL);

	HWND edit = GetEdit();
	FORWARD_WM_SETFONT(edit, m_hfText, TRUE, ::SendMessage);

	m_pNotify = pNotify;
	if (NULL != m_pNotify)
	{
		m_pNotify->AddRef();
	}

	return(TRUE);
}

// Not actually implemented yet; should use the font to determine a size
void CEditText::GetDesiredSize(SIZE *ppt)
{
	CFillWindow::GetDesiredSize(ppt);
}

// HACKHACK georgep: This object now owns the brush
void CEditText::SetColors(HBRUSH hbrBack, COLORREF back, COLORREF fore)
{
	// Store off the colors and brush
	if (NULL != m_hbrBack)
	{
		DeleteObject(m_hbrBack);
	}
	m_hbrBack = hbrBack;
	m_crBack = back;
	m_crFore = fore;

	InvalidateRect(GetEdit(), NULL, TRUE);
}

// HACKHACK georgep: This object now owns the font
void CEditText::SetFont(HFONT hf)
{
	if (NULL != m_hfText)
	{
		DeleteObject(m_hfText);
	}
	m_hfText = hf;

	// Tell the edit control the font to use
	HWND edit = GetEdit();
	if (NULL != edit)
	{
		FORWARD_WM_SETFONT(edit, hf, TRUE, ::SendMessage);
	}
}

LRESULT CEditText::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(GetWindow(), WM_CTLCOLOREDIT, OnCtlColor);
		HANDLE_MSG(GetWindow(), WM_COMMAND     , OnCommand);
		HANDLE_MSG(GetWindow(), WM_NCDESTROY   , OnNCDestroy);
	}

	return(CFillWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

HBRUSH CEditText::OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
{
	// Do default processing if there is no brush
	if (NULL == m_hbrBack)
	{
		return(FORWARD_WM_CTLCOLOREDIT(hwnd, hdc, hwndChild, CFillWindow::ProcessMessage));
	}

	// Set the colors in the DC, and return the brush
	SetBkColor(hdc, m_crBack);
	SetTextColor(hdc, m_crFore);
	return(m_hbrBack);
}

// Sets the text for the control
void CEditText::SetText(
	LPCTSTR szText	// The text to set
	)
{
	SetWindowText(GetChild(), szText);
}

// Gets the text for the control; returns the total text length
int CEditText::GetText(
	LPTSTR szText,	// Where to put the text
	int nLen		// The length of the buffer
	)
{
	GetWindowText(GetChild(), szText, nLen);
	return(GetWindowTextLength(GetChild()));
}

void CEditText::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (codeNotify)
	{
	case EN_UPDATE:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnTextChange(this);
		}
		break;

	case EN_SETFOCUS:
		SetHotControl(this);
	case EN_KILLFOCUS:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnFocusChange(this, EN_SETFOCUS==codeNotify);
		}
		break;
	}

	FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, CFillWindow::ProcessMessage);
}

void CEditText::OnNCDestroy(HWND hwnd)
{
	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}

	FORWARD_WM_NCDESTROY(hwnd, CFillWindow::ProcessMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\dllutil.cpp ===
// File: dllutil.cpp

#include <precomp.h>
#include "dllutil.h"
#include "oprahcom.h"


/*  F  C H E C K  D L L  V E R S I O N  V E R S I O N  */
/*-------------------------------------------------------------------------
    %%Function: FCheckDllVersionVersion

    Make sure the dll is at least the specified version.
-------------------------------------------------------------------------*/
BOOL FCheckDllVersionVersion(LPCTSTR pszDll, DWORD dwMajor, DWORD dwMinor)
{
	DLLVERSIONINFO dvi;
	if (FAILED(HrGetDllVersion(pszDll, &dvi)))
		return FALSE;

	if (dwMajor > dvi.dwMajorVersion)
		return FALSE;

	if (dwMajor == dvi.dwMajorVersion)
	{
		if (dwMinor > dvi.dwMinorVersion)
			return FALSE;
	}

	// TODO: Add Platform check (DLLVER_PLATFORM_WINDOWS vs _NT)
	return TRUE;
}



/*  H R  G E T  D L L  V E R S I O N  */
/*-------------------------------------------------------------------------
    %%Function: HrGetDllVersion
    
    Return the version information for the DLL.
-------------------------------------------------------------------------*/
HRESULT HrGetDllVersion(LPCTSTR pszDll, DLLVERSIONINFO * pDvi)
{
	HRESULT hr;

	InitStruct(pDvi);

	HINSTANCE hInst = LoadLibrary(pszDll);
	if (NULL == hInst)
	{
		hr = E_FILE_NOT_FOUND; // file not found
	}
	else
	{
		DLLGETVERSIONPROC pDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hInst, "DllGetVersion");
		if (NULL == pDllGetVersion)
		{
			hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
		}
		else
		{
			hr = (*pDllGetVersion)(pDvi);

			WARNING_OUT(("Loaded %s (%d.%d.%d) %s", pszDll,
				pDvi->dwMajorVersion, pDvi->dwMinorVersion, pDvi->dwBuildNumber,
				(DLLVER_PLATFORM_NT == pDvi->dwPlatformID) ? "for NT" : "" ));
		}
		FreeLibrary(hInst);
	}

	return hr;
}


/*  H R  I N I T  L P F N  */
/*-------------------------------------------------------------------------
    %%Function: HrInitLpfn

    Attempt to load the library and the functions declared in the table.
-------------------------------------------------------------------------*/
HRESULT HrInitLpfn(APIFCN *pProcList, int cProcs, HINSTANCE* phLib, LPCTSTR pszDllName)
{
	bool bWeLoadedLibrary = false;

	if (NULL != pszDllName)
	{
		*phLib = LoadLibrary(pszDllName);
		if (NULL != *phLib)
		{
			bWeLoadedLibrary = true;
		}
	}

	if (NULL == *phLib)
	{
		return E_FILE_NOT_FOUND;
	}

	for (int i = 0; i < cProcs; i++)
	{
		*pProcList[i].ppfn = (LPVOID) GetProcAddress(*phLib, pProcList[i].szApiName);

		if (NULL == *pProcList[i].ppfn)
		{
			if (bWeLoadedLibrary)
			{
				FreeLibrary(*phLib);
			}
			return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
		}
	}

	return S_OK;
}


/*  N M  L O A D  L I B R A R Y  */
/*-------------------------------------------------------------------------
    %%Function: NmLoadLibrary
    
-------------------------------------------------------------------------*/
HINSTANCE  NmLoadLibrary(LPCTSTR pszModule, BOOL bSystemLibrary)
{
	HINSTANCE hInstance = NULL;
	TCHAR szPath[MAX_PATH];

	if(bSystemLibrary)
	{
		// Get the system directory and account for "\0"
		int cbytes = GetSystemDirectory(szPath,(MAX_PATH - 2));
		if(cbytes == 0)
		{
			return NULL;
		}
		else
		{
			szPath[cbytes] = '\\';
			szPath[cbytes+1] = 0;
		}


	}
	else
	{
		if (!GetInstallDirectory(szPath))
		{
			return NULL;
		}
	}


	int cch = lstrlen(szPath);
	int cch2 = lstrlen(pszModule);
	if((cch + cch2) >=MAX_PATH)
	{
		return NULL;
	}
	
	lstrcpyn(szPath+cch, pszModule, CCHMAX(szPath) - cch);

	hInstance = ::LoadLibraryEx(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
	ASSERT(hInstance);
	return hInstance;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\hash.cpp ===
// HASH.CPP
//
// Hash utility functions for use in NetMeeting components.

#include "precomp.h"
#include <oprahcom.h>
#include "nb30.h"
#include "regentry.h"
#include "confreg.h"


CHash::CHash() : m_hProv(0), m_hHash(0), m_pbHashedData(NULL), m_cbHashedData(0), m_fReady(FALSE)
{
	if (!CryptAcquireContext(&m_hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
	{
		// Create new if can not get default 
		if (!CryptAcquireContext(&m_hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET)) 
		{
			goto ErrorExit;	
		}
	}

	m_fReady = TRUE;
	return;
ErrorExit:
	m_fReady = FALSE;
}


CHash::~CHash()
{
	if (m_pbHashedData) delete []m_pbHashedData;
	CryptAcquireContext(&m_hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET);
	if (m_hHash) CryptDestroyHash(m_hHash);
	if (m_hProv) CryptReleaseContext(m_hProv, 0);
}

DWORD CHash::GetHashedData(PBYTE pbData, DWORD cbData, void ** ppvHashedData)
{
	ASSERT(NULL != ppvHashedData);
	ASSERT(NULL != pbData);
	DWORD dwCount;
	RegEntry re(WINDOWS_KEY, HKEY_LOCAL_MACHINE);

	if (FALSE == m_fReady)
	{
		goto ErrorExit;
	}
	if (0 == cbData) {
		goto ErrorExit;
	}
	if (m_hHash) CryptDestroyHash(m_hHash);
	if (!CryptCreateHash(m_hProv, CALG_MD5, 0, 0, &m_hHash))
	{
		ERROR_OUT(("CHash::GetHashData() - Error creating crypt hash object."));
		goto ErrorExit;
	}
	if (!CryptHashData(m_hHash, pbData, cbData, 0))
	{
		ERROR_OUT(("CHash::GetHashData() - Error hashing data."));
		goto ErrorExit;
	}

	if (!CryptHashData(m_hHash, (PBYTE) re.GetString(REGVAL_REGISTERED_USER),
			lstrlen(re.GetString(REGVAL_REGISTERED_USER)), 0))
	{
		ERROR_OUT(("CHash::GetHashData() - Error hashing extra data."));
		goto ErrorExit;
	}

	NCB ncb;
	BYTE buf[sizeof(NCB) + 256];

	ZeroMemory ( &ncb, sizeof(ncb));
	ncb.ncb_command = NCBASTAT;
	ncb.ncb_buffer = buf;
	ncb.ncb_length = sizeof(buf);
	memcpy ( (PBYTE)ncb.ncb_callname, (PBYTE)"*              ", NCBNAMSZ );

	if ( NRC_GOODRET == Netbios(&ncb) )
	{
		//
		// NOTE: the buffer filled by the Netbios ASTAT command starts
		// with a 6-byte encoded adapter address: just use the raw
		// buffer rather than casting back to PBYTE
		//

		if (!CryptHashData(m_hHash, buf, 6, 0 ))
		{
			ERROR_OUT(("CHash::GetHashData() - Error hashing ncb data."));
			goto ErrorExit;
		}
	}
	else
	{
		WARNING_OUT(("CHash::GetHashData: Netbios failed %x", ncb.ncb_retcode));
	}
	
	dwCount = sizeof(DWORD);
	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE *)&m_cbHashedData, &dwCount, 0)) 
	{
		goto ErrorExit;
	}
	if (m_pbHashedData) delete [] m_pbHashedData;
	if (NULL == (m_pbHashedData = new BYTE[m_cbHashedData]))
	{
		goto ErrorExit;
	}
	if (!CryptGetHashParam(m_hHash, HP_HASHVAL, m_pbHashedData, &m_cbHashedData, 0)) {
		goto ErrorExit;
	}
	*ppvHashedData = m_pbHashedData;
	return m_cbHashedData;
ErrorExit:
	return 0;     // Hash data failed 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\genwindow.cpp ===
// File: GenWindow.cpp

#include "precomp.h"

#include "GenWindow.h"
#include "GenContainers.h"

#include <windowsx.h>

// We need a different tooltip window for each top level window, or the tooltip
// will get hidden behind the window
struct TT_TopWindow
{
	HWND hwndTop;
	HWND hwndTooltip;
} ;

class CTopWindowArray
{
private:
	enum { InitSize = 4 } ;

	TT_TopWindow *m_pArray;
	UINT m_nArrayLen;

	int FindIndex(HWND hwndTop)
	{
		if (NULL == m_pArray)
		{
			return(-1);
		}

		// Just a linear search
		int i;
		for (i=m_nArrayLen-1; i>=0; --i)
		{
			if (m_pArray[i].hwndTop == hwndTop)
			{
				break;
			}
		}

		return(i);
	}

public:
	CTopWindowArray() :
		m_pArray(NULL)
	{
	}

	~CTopWindowArray()
	{
		delete[] m_pArray;
	}

	static HWND GetTopFrame(HWND hwnd)
	{
		HWND hwndParent;
		while (NULL != (hwndParent = GetParent(hwnd)))
		{
			hwnd = hwndParent;
		}

		return(hwnd);
	}

	void GrowArray()
	{
		if (NULL == m_pArray)
		{
			m_nArrayLen = InitSize;
			m_pArray = new TT_TopWindow[m_nArrayLen];
			ZeroMemory(m_pArray, m_nArrayLen*sizeof(TT_TopWindow));
			return;
		}

		// Grow exponentially
		TT_TopWindow *pArray = new TT_TopWindow[m_nArrayLen*2];
		if (NULL == pArray)
		{
			// very bad
			return;
		}

		CopyMemory(pArray, m_pArray, m_nArrayLen*sizeof(TT_TopWindow));
		ZeroMemory(pArray+m_nArrayLen, m_nArrayLen*sizeof(TT_TopWindow));

		delete[] m_pArray;
		m_pArray = pArray;
		m_nArrayLen *= 2;
	}

	void Add(HWND hwndTop, HWND hwndTooltip)
	{
		hwndTop = GetTopFrame(hwndTop);

		// I'm going to allow multiple adds of the same thing, but then you
		// must have the corresponding number of removes

		int i = FindIndex(NULL);
		if (i < 0)
		{
			GrowArray();
			i = FindIndex(NULL);

			if (i < 0)
			{
				// Very bad
				return;
			}
		}

		m_pArray[i].hwndTop = hwndTop;
		m_pArray[i].hwndTooltip = hwndTooltip;
	}

	void Remove(HWND hwndTop)
	{
		hwndTop = GetTopFrame(hwndTop);

		int i = FindIndex(hwndTop);
		if (i >= 0)
		{
			// LAZYLAZY  georgep: I'm never going to shrink the array
			m_pArray[i].hwndTop = NULL;
			m_pArray[i].hwndTooltip = NULL;
		}
	}

	HWND Find(HWND hwndTop)
	{
		hwndTop = GetTopFrame(hwndTop);

		int i = FindIndex(hwndTop);
		if (i >= 0)
		{
			return(m_pArray[i].hwndTooltip);
		}
		return(NULL);
	}

	int GetCount()
	{
		if (NULL == m_pArray)
		{
			return(0);
		}

		int c = 0;
		for (int i=m_nArrayLen-1; i>=0; --i)
		{
			if (NULL != m_pArray[i].hwndTop)
			{
				++c;
			}
		}

		return(c);
	}
} ;

static inline BOOL TT_AddToolInfo(HWND hwnd, TOOLINFO *pti)
{
	return (BOOL)(SendMessage(hwnd, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(pti)) != 0);
}

static inline void TT_DelToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_DELTOOL, 0, reinterpret_cast<LPARAM>(pti));
}

static inline BOOL TT_GetToolInfo(HWND hwnd, TOOLINFO *pti)
{
	return (BOOL)(SendMessage(hwnd, TTM_GETTOOLINFO, 0, reinterpret_cast<LPARAM>(pti)) != 0);
}

static inline void TT_SetToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_SETTOOLINFO, 0, reinterpret_cast<LPARAM>(pti));
}

static inline int TT_GetToolCount(HWND hwnd)
{
	return (int)(SendMessage(hwnd, TTM_GETTOOLCOUNT, 0, 0));
}

CGenWindow *CGenWindow::g_pCurHot = NULL;

const DWORD IGenWindow::c_msgFromHandle = RegisterWindowMessage(_TEXT("NetMeeting::FromHandle"));

IGenWindow *IGenWindow::FromHandle(HWND hwnd)
{
	return(reinterpret_cast<IGenWindow*>(SendMessage(hwnd, c_msgFromHandle, 0, 0)));
}

// HACKHACK georgep: Need to make this larger than the largest DM_ message
enum
{
	GWM_LAYOUT = WM_USER + 111,
	GWM_CUSTOM,
} ;

CGenWindow::CGenWindow()
: m_hwnd(NULL), m_lUserData(0)
{
	// Init the ref count to 1
	REFCOUNT::AddRef();
	// This marks this object for deletion when the ref count goes to 0.
	REFCOUNT::Delete();
}

CGenWindow::~CGenWindow()
{
	// I don't think the HWND can still exist, since the window proc does an AddRef
	ASSERT(!m_hwnd);
}

HRESULT STDMETHODCALLTYPE CGenWindow::QueryInterface(REFGUID riid, LPVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((__uuidof(IGenWindow) == riid) || (IID_IUnknown == riid))
	{
		*ppv = dynamic_cast<IGenWindow *>(this);
	}
	else if (__uuidof(CGenWindow) == riid)
	{
		*ppv = this;
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

BOOL CGenWindow::Create(
	HWND hWndParent,		// Window parent
	LPCTSTR szWindowName,	// Window name
	DWORD dwStyle,			// Window style
	DWORD dwEXStyle,		// Extended window style
	int x,					// Window pos: x
	int y,					// Window pos: y
	int nWidth,				// Window size: width
	int nHeight,			// Window size: height
	HINSTANCE hInst,		// The hInstance to create the window on
	HMENU hmMain,			// Window menu
	LPCTSTR szClassName		// The class name to use
	)
{
	if (NULL != m_hwnd)
	{
		// Alread created
		return(FALSE);
	}

	if (NULL == szClassName)
	{
		szClassName = TEXT("NMGenWindowClass");
	}

	if (!InitWindowClass(szClassName, hInst))
	{
		// Couldn't init the window class
		return(FALSE);
	}

	BOOL ret = (NULL != CreateWindowEx(dwEXStyle, szClassName, szWindowName, dwStyle,
		x, y, nWidth, nHeight, hWndParent, hmMain,
		hInst, (LPVOID)this));

#ifdef DEBUG
	if (!ret)
	{
		GetLastError();
	}
#endif // DEBUG

	return(ret);
}

BOOL CGenWindow::Create(
	HWND hWndParent,		// Window parent
	INT_PTR nId,				// ID of the child window
	LPCTSTR szWindowName,	// Window name
	DWORD dwStyle,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
	DWORD dwEXStyle			// Extended window style
	)
{
	ASSERT(NULL != hWndParent);

	// Child windows should default to visible
	return(Create(
		hWndParent,		// Window parent
		szWindowName,	// Window name
		dwStyle|WS_CHILD|WS_VISIBLE,			// Window style
		dwEXStyle,		// Extended window style
		0,					// Window pos: x
		0,					// Window pos: y
		10,				// Window size: width
		10,			// Window size: height
		reinterpret_cast<HINSTANCE>(GetWindowLongPtr(hWndParent, GWLP_HINSTANCE)),
		reinterpret_cast<HMENU>(nId)			// Window menu
	));
}

BOOL CGenWindow::InitWindowClass(LPCTSTR szClassName, HINSTANCE hThis)
{
	WNDCLASS wc;

	// See if the class is already registered
	if (GetClassInfo(hThis, szClassName, &wc))
	{
		ASSERT(RealWindowProc == wc.lpfnWndProc);

		// Already registered
		return(TRUE);
	}

	// If not, attempt to register it
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	// BUGBUG georgep: Hard-coding the background color for now
	// wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
	// wc.hbrBackground = CreateSolidBrush(RGB(0xA9, 0xA9, 0xA9));
	wc.hbrBackground = NULL;
	wc.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
	wc.hIcon = NULL;
	wc.hInstance = hThis;
	wc.lpfnWndProc = RealWindowProc;
	wc.lpszClassName = szClassName;
	wc.lpszMenuName = NULL;
	wc.style = CS_DBLCLKS;

	return(RegisterClass(&wc));
}

LRESULT CALLBACK CGenWindow::RealWindowProc(
	HWND hWnd,
	UINT message,
	WPARAM wParam,
	LPARAM lParam
	)
{
	// Handle the WM_CREATE message
	if (WM_NCCREATE == message)
	{
		HANDLE_WM_NCCREATE(hWnd, wParam, lParam, OnNCCreate);
	}

	// Get the "this" pointer and call the ProcessMessage virtual method
	LRESULT ret = 0;
	CGenWindow* pWnd = reinterpret_cast<CGenWindow*>(GetWindowLongPtr(hWnd, GWLP_USERDATA));

	// 'pWnd' won't be valid for any messages that come before WM_NCCREATE or after WM_NCDESTROY
	if(NULL != pWnd)
	{
		// Messages after WM_NCCREATE:
		ret = pWnd->ProcessMessage(hWnd, message, wParam, lParam);
	}
	else
	{
		// Messages before WM_CREATE:
		ret = DefWindowProc(hWnd, message, wParam, lParam);
	}

	// Clean up on WM_NCDESTROY
	if (WM_NCDESTROY == message && NULL != pWnd)
	{
		SetWindowLongPtr(hWnd, GWLP_USERDATA, 0);
		pWnd->m_hwnd = NULL;

		pWnd->OnMouseLeave();
		pWnd->Release();
	}

	return(ret);
}

void CGenWindow::OnShowWindow(HWND hwnd, BOOL fShow, int fnStatus)
{
	OnDesiredSizeChanged();
}

LRESULT CGenWindow::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_SIZE      , OnSize);
		HANDLE_MSG(hwnd, WM_ERASEBKGND, OnEraseBkgnd);
		HANDLE_MSG(hwnd, WM_MOUSEMOVE , OnMouseMove);
		HANDLE_MSG(hwnd, WM_SHOWWINDOW, OnShowWindow);

	case WM_MOUSELEAVE:
		OnMouseLeave();
		break;

	case GWM_LAYOUT:
		Layout();
		break;

	case GWM_CUSTOM:
		reinterpret_cast<InvokeProc>(lParam)(this, wParam);
		break;

	case WM_DESTROY:
		RemoveTooltip();
		break;

	default:
		if (c_msgFromHandle == message)
		{
			// Return the IGenWindow* for this object, as specified by the
			// IGenWindow interface
			return(reinterpret_cast<LRESULT>(dynamic_cast<IGenWindow*>(this)));
		}
	}

	return(DefWindowProc(hwnd, message, wParam, lParam));
}

void CGenWindow::ScheduleLayout()
{
	HWND hwnd = GetWindow();

	MSG msg;
	// I don't know why we are getting messages for windows other than our own,
	// but it seems to happen for top level windows
	if (PeekMessage(&msg, hwnd, GWM_LAYOUT, GWM_LAYOUT, PM_NOREMOVE|PM_NOYIELD)
		&& (msg.hwnd == hwnd))
	{
		// Message already posted
		return;
	}

	if (!PostMessage(hwnd, GWM_LAYOUT, 0, 0))
	{
		Layout();
	}
}

BOOL CGenWindow::AsyncInvoke(InvokeProc proc, WPARAM wParam)
{
	return(!PostMessage(GetWindow(), GWM_CUSTOM, wParam, reinterpret_cast<LPARAM>(proc)));
}

void CGenWindow::OnSize(HWND hwnd, UINT state, int cx, int cy)
{
	// Call the virtual Layout, and then forward to DefWindowProc
	ScheduleLayout();

	// Update the Tooltip info
	TOOLINFO ti;
	TCHAR szTip[MAX_PATH];
	BOOL bExist = InitToolInfo(&ti, szTip);
	if (bExist)
	{
		GetClientRect(hwnd, &ti.rect);

		HWND hwndTooltip = g_pTopArray->Find(hwnd);
		TT_SetToolInfo(hwndTooltip, &ti);
	}

	FORWARD_WM_SIZE(hwnd, state, cx, cy, DefWindowProc);
}

BOOL CGenWindow::OnEraseBkgnd(HWND hwnd, HDC hdc)
{
	HBRUSH hErase = GetBackgroundBrush();
	if (NULL == hErase)
	{
		return(FORWARD_WM_ERASEBKGND(hwnd, hdc, DefWindowProc));
	}

	HPALETTE hOldPal = NULL;
	HPALETTE hPal = GetPalette();
	if (NULL != hPal)
	{
		hOldPal = SelectPalette(hdc, hPal, TRUE);
		RealizePalette(hdc);
	}

	RECT rc;
	GetClientRect(hwnd, &rc);

	HBRUSH hOld = (HBRUSH)SelectObject(hdc, hErase);
	PatBlt(hdc, 0, 0, rc.right, rc.bottom, PATCOPY);
	SelectObject(hdc, hOld);

	if (NULL != hOldPal)
	{
		SelectPalette(hdc, hOldPal, TRUE);
	}

	return(TRUE);
}

void CGenWindow::OnMouseLeave()
{
	if (dynamic_cast<IGenWindow*>(this) == g_pCurHot)
	{
		SetHotControl(NULL);
	}
}

void CGenWindow::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
	SetHotControl(this);
	FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, DefWindowProc);
}

// REVIEW georgep: Should this loop until it gets an IGenWindow?
HBRUSH CGenWindow::GetBackgroundBrush()
{
	HWND parent = GetParent(GetWindow());
	if (NULL == parent)
	{
		return(GetStandardBrush());
	}

	IGenWindow *pParent = FromHandle(parent);
	if (pParent == NULL)
	{
		return(GetStandardBrush());
	}
	return(pParent->GetBackgroundBrush());
}

// REVIEW georgep: Should this loop until it gets an IGenWindow?
HPALETTE CGenWindow::GetPalette()
{
	HWND parent = GetParent(GetWindow());
	if (NULL == parent)
	{
		return(GetStandardPalette());
	}

	IGenWindow *pParent = FromHandle(parent);
	if (pParent == NULL)
	{
		return(GetStandardPalette());
	}
	return(pParent->GetPalette());
}

BOOL CGenWindow::OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
	// Store away the "this" pointer ahnd save off the window handle
	CGenWindow* pWnd = NULL;
	
	pWnd = (CGenWindow*) lpCreateStruct->lpCreateParams;
	ASSERT(pWnd);

	SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pWnd);
	pWnd->AddRef();

	TRACE_OUT(("CGenWindow::OnNCCreate"));

	ASSERT(NULL == pWnd->m_hwnd);
	pWnd->m_hwnd = hwnd;

	return(TRUE);
}

void CGenWindow::GetDesiredSize(SIZE *ppt)
{
	HWND hwnd = GetWindow();

	RECT rcTemp = { 0, 0, 0, 0 };
	AdjustWindowRectEx(&rcTemp, GetWindowLong(hwnd, GWL_STYLE), FALSE,
		GetWindowLong(hwnd, GWL_EXSTYLE));

	ppt->cx = rcTemp.right  - rcTemp.left;
	ppt->cy = rcTemp.bottom - rcTemp.top;
}

void CGenWindow::OnDesiredSizeChanged()
{
	HWND parent = GetParent(GetWindow());
	if (NULL != parent)
	{
		IGenWindow *pParent = FromHandle(parent);
		if (NULL != pParent)
		{
			pParent->OnDesiredSizeChanged();
		}
	}

	// Do this after telling the parents about the change, so their layouts
	// will happen before this one
	ScheduleLayout();
}

class GWTrackMouseLeave
{
private:
	enum { DefIdTimer = 100 };
	enum { DefTimeout = 500 };

	static HWND m_hwnd;
	static UINT_PTR m_idTimer;
	static DWORD m_dwWhere;

	static void CALLBACK OnTimer(HWND hwnd, UINT uMsg, UINT_PTR idTimer, DWORD dwTime)
	{
		RECT rc;
		GetWindowRect(m_hwnd, &rc);

		DWORD dwPos = GetMessagePos();

		// If the mouse has not moved since this timer started, then leave it hot
		// This allows a reasonable keyboard-only interface
		if (m_dwWhere == dwPos)
		{
			return;
		}

		POINT ptPos = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };

		if (!PtInRect(&rc, ptPos))
		{
			PostMessage(m_hwnd, WM_MOUSELEAVE, 0, 0);
		}
	}

public:
	GWTrackMouseLeave() {}

	static void Track(HWND hwnd, BOOL bTrack)
	{
		if (!bTrack)
		{
			if (NULL != m_hwnd && hwnd == m_hwnd)
			{
				KillTimer(NULL, m_idTimer);
				m_hwnd = NULL;
			}

			return;
		}

		// Stop any previous tracking
		Track(m_hwnd, FALSE);

		m_hwnd = hwnd;
		m_dwWhere = GetMessagePos();
		m_idTimer = SetTimer(NULL, DefIdTimer, DefTimeout, OnTimer);
	}
} ;

HWND GWTrackMouseLeave::m_hwnd = NULL;
DWORD GWTrackMouseLeave::m_dwWhere = 0;
UINT_PTR GWTrackMouseLeave::m_idTimer;

static void GWTrackMouseEvent(HWND hwnd, BOOL bTrack)
{
	// I need to set up a timer to handle this
	GWTrackMouseLeave::Track(hwnd, bTrack);
}

// Set the global Hot control
void CGenWindow::SetHotControl(CGenWindow *pHot)
{
	CGenWindow *pGenWindow = NULL;

	if (NULL != pHot)
	{
		for (HWND hwndHot=pHot->GetWindow(); ; hwndHot=GetParent(hwndHot))
		{
			if (NULL == hwndHot)
			{
				break;
			}

			IGenWindow *pWindow = FromHandle(hwndHot);
			if (NULL == pWindow)
			{
				continue;
			}

			if (SUCCEEDED(pWindow->QueryInterface(__uuidof(CGenWindow),
				reinterpret_cast<LPVOID*>(&pGenWindow)))
				&& NULL != pGenWindow)
			{
				pGenWindow->SetHot(TRUE);

				// Not all windows may care about the hot state
				BOOL bIsHot = pGenWindow->IsHot();
				pGenWindow->Release();

				if (bIsHot)
				{
					break;
				}
			}

			pGenWindow = NULL;
		}
	}

	if (g_pCurHot != pGenWindow)
	{
		if (NULL != g_pCurHot)
		{
			g_pCurHot->SetHot(FALSE);
			GWTrackMouseEvent(g_pCurHot->GetWindow(), FALSE);

			ULONG uRef = g_pCurHot->Release();
		}

		g_pCurHot = pGenWindow;
		if (NULL!= g_pCurHot)
		{
			ULONG uRef = g_pCurHot->AddRef();

			// Now we need to track the mouse leaving
			GWTrackMouseEvent(g_pCurHot->GetWindow(), TRUE);
		}
	}
}

// Set this control to be hot
void CGenWindow::SetHot(BOOL bHot)
{
}

// Is this control currently hot
BOOL CGenWindow::IsHot()
{
	return(FALSE);
}

LPARAM CGenWindow::GetUserData()
{
	return(m_lUserData);
}

HPALETTE CGenWindow::g_hPal = NULL;
BOOL     CGenWindow::g_bNeedPalette = TRUE;
HBRUSH   CGenWindow::g_hBrush = NULL;
CTopWindowArray *CGenWindow::g_pTopArray = NULL;

// Not particularly robust: we give out our internal palette and trust everybody
// not to delete it
HPALETTE CGenWindow::GetStandardPalette()
{
	#include "indeopal.h"

	if (!g_bNeedPalette || NULL != g_hPal)
	{
		return(g_hPal);
	}

	HDC hDC = ::GetDC(NULL);
	if (NULL != hDC)
	{
		// Use the Indeo palette
		// Check out the video mode. We only care about 8 bit mode.
		if (8 == ::GetDeviceCaps(hDC, BITSPIXEL) * ::GetDeviceCaps(hDC, PLANES))
		{
#ifndef HALFTONE_PALETTE
			LOGPALETTE_NM gIndeoPalette = gcLogPaletteIndeo;
			if (SYSPAL_NOSTATIC != ::GetSystemPaletteUse(hDC))
			{
				// Preserve the static colors
				int nStaticColors = ::GetDeviceCaps(hDC, NUMCOLORS) >> 1;

				if (nStaticColors <= 128)
				{
					// Get the 10 first entries
					::GetSystemPaletteEntries(      hDC,
												0,
												nStaticColors,
												&gIndeoPalette.aEntries[0]);

					// Get the 10 last entries
					::GetSystemPaletteEntries(      hDC,
												256 - nStaticColors,
												nStaticColors,
												&gIndeoPalette.aEntries[256 - nStaticColors]);

					// Hammer the peFlags
					for (; --nStaticColors + 1;)
					{
						gIndeoPalette.aEntries[nStaticColors].peFlags = 0;
						gIndeoPalette.aEntries[255 - nStaticColors].peFlags = 0;
					}
				}
			}

			// Build a palette
			g_hPal = ::CreatePalette((LOGPALETTE *)&gIndeoPalette);

#else  // HALFTONE_PALETTE
			g_hPal = ::CreateHalftonePalette(hDC);
#endif // HALFTONE_PALETTE
		}
		::ReleaseDC(NULL, hDC);
	}

	g_bNeedPalette = (NULL != g_hPal);
	return(g_hPal);
}

void CGenWindow::DeleteStandardPalette()
{
	if (NULL != g_hPal)
	{
		DeleteObject(g_hPal);
		g_hPal = NULL;
	}
}

// Get the standard palette for drawing
HBRUSH CGenWindow::GetStandardBrush()
{
	return(GetSysColorBrush(COLOR_3DFACE));
}

// Delete the standard palette for drawing
void CGenWindow::DeleteStandardBrush()
{
}

// Returns TRUE if the TT exists
BOOL CGenWindow::InitToolInfo(TOOLINFO *pti, LPTSTR pszText)
{
	TCHAR szText[MAX_PATH];
	if (NULL == pszText)
	{
		pszText = szText;
	}

	HWND hwnd = GetWindow();
	HWND hwndTooltip = NULL == g_pTopArray ? NULL : g_pTopArray->Find(hwnd);

	TOOLINFO &ti = *pti;

	ti.cbSize = sizeof(TOOLINFO);
	ti.hwnd = hwnd;
	ti.hinst = GetWindowInstance(hwnd);
	ti.lpszText = pszText;

	GetClientRect(hwnd, &ti.rect);

	ti.uId = reinterpret_cast<UINT_PTR>(hwnd);
	ti.uFlags = TTF_SUBCLASS;

	GetSharedTooltipInfo(&ti);

	// HACKHACK georgep: The flags keep getting messed up by the tooltip window
	UINT uFlags = ti.uFlags;

	BOOL bExist = NULL == hwndTooltip ? FALSE : TT_GetToolInfo(hwndTooltip, &ti);

	ti.uFlags = uFlags;
	if (ti.lpszText == szText)
	{
		ti.lpszText = NULL;
	}

	return(bExist);
}

void CGenWindow::SetWindowtext(LPCTSTR pszTip)
{
	HWND hwnd = GetWindow();
	if(NULL != hwnd)
	{
		HWND child = (GetTopWindow(hwnd));
		if (NULL != child)
		{
		    ::SetWindowText(child,pszTip);
		}
	}
}

// Set the tooltip for this window
void CGenWindow::SetTooltip(LPCTSTR pszTip)
{
	HWND hwnd = GetWindow();

	if (NULL == g_pTopArray)
	{
		g_pTopArray = new CTopWindowArray;
		if (NULL == g_pTopArray)
		{
			return;
		}
	}

	HWND hwndTop = CTopWindowArray::GetTopFrame(hwnd);
	HWND hwndTooltip = g_pTopArray->Find(hwndTop);

	if (NULL == hwndTooltip)
	{
		hwndTooltip = CreateWindowEx(0,
											TOOLTIPS_CLASS,
											NULL,
											0, // styles
											CW_USEDEFAULT,
											CW_USEDEFAULT,
											CW_USEDEFAULT,
											CW_USEDEFAULT,
											hwndTop,
											(HMENU) NULL,
											GetWindowInstance(hwnd),
											NULL);
		if (NULL == hwndTooltip)
		{
			// Couldn't create the tooltip window
			return;
		}

		g_pTopArray->Add(hwndTop, hwndTooltip);
	}

	TOOLINFO ti;
	BOOL bExist = InitToolInfo(&ti);

	ti.lpszText = const_cast<LPTSTR>(pszTip);

	if (bExist)
	{
		TT_SetToolInfo(hwndTooltip, &ti);
	}
	else
	{
		TT_AddToolInfo(hwndTooltip, &ti);
	}
}

// Remove the tooltip for this window
void CGenWindow::RemoveTooltip()
{
	if  (NULL == g_pTopArray)
	{
		// Nothing to do
		return;
	}

	HWND hwndTop = CTopWindowArray::GetTopFrame(GetWindow());
	HWND hwndTooltip = g_pTopArray->Find(hwndTop);

	BOOL bIsWindow = NULL != hwndTooltip && IsWindow(hwndTooltip);

	TOOLINFO ti;
	BOOL bExist = bIsWindow && InitToolInfo(&ti);

	if (bExist)
	{
		TT_DelToolInfo(hwndTooltip, &ti);
	}

	if (NULL != hwndTooltip && (!bIsWindow || 0 == TT_GetToolCount(hwndTooltip)))
	{
		if (bIsWindow)
		{
			DestroyWindow(hwndTooltip);
		}
		g_pTopArray->Remove(hwndTop);

		if (0 == g_pTopArray->GetCount())
		{
			delete g_pTopArray;
			g_pTopArray = NULL;
		}
	}
}

// Get the info necessary for displaying a tooltip
void CGenWindow::GetSharedTooltipInfo(TOOLINFO *pti)
{
}

// Just makes the first child fill the client area
void CFillWindow::Layout()
{
	HWND child = GetChild();
	if (NULL != child)
	{
		RECT rc;
		GetClientRect(GetWindow(), &rc);
		SetWindowPos(child, NULL, 0, 0, rc.right, rc.bottom, SWP_NOZORDER);
	}
}

void CFillWindow::GetDesiredSize(SIZE *psize)
{
	CGenWindow::GetDesiredSize(psize);
	HWND child = GetChild();

	if (NULL != child)
	{
		IGenWindow *pChild = FromHandle(child);
		if (NULL != pChild)
		{
			SIZE sizeTemp;
			pChild->GetDesiredSize(&sizeTemp);
			psize->cx += sizeTemp.cx;
			psize->cy += sizeTemp.cy;
		}
	}
}

// Get the info necessary for displaying a tooltip
void CFillWindow::GetSharedTooltipInfo(TOOLINFO *pti)
{
	CGenWindow::GetSharedTooltipInfo(pti);

	// Since the child covers this whole area, we need to change the HWND to
	// hook
	pti->hwnd = GetChild();
}

CEdgedWindow::CEdgedWindow() :
	m_hMargin(0),
	m_vMargin(0),
	m_pHeader(NULL)
{
}

CEdgedWindow::~CEdgedWindow()
{
	SetHeader(NULL);
}

BOOL CEdgedWindow::Create(HWND hwndParent)
{
	return(CGenWindow::Create(
		hwndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMEdgedWindow"),	// Window name
		WS_CLIPCHILDREN,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
	));
}

HWND CEdgedWindow::GetContentWindow()
{
	// If we are hosting an IGenWindow, add on its desired size
	HWND child = GetFirstChild(GetWindow());
	if (NULL == child)
	{
		return(NULL);
	}
	if (NULL != m_pHeader && child == m_pHeader->GetWindow())
	{
		child = ::GetWindow(child, GW_HWNDNEXT);
	}

	return(child);
}

static const int LeftIndent = 20;

// Just makes the first child fill the client area - the border
void CEdgedWindow::Layout()
{
	int nBorder = GetBorderWidth();

	int hBorder = m_hMargin + nBorder;
	int vBorder = m_vMargin + nBorder;

	HWND hwnd = GetWindow();
	RECT rc;
	GetClientRect(hwnd, &rc);

	CGenWindow *pHeader = GetHeader();
	if (NULL != pHeader)
	{
		SIZE sizeTemp;
		pHeader->GetDesiredSize(&sizeTemp);

		SetWindowPos(pHeader->GetWindow(), NULL, rc.left+LeftIndent, rc.top,
			sizeTemp.cx, sizeTemp.cy, SWP_NOZORDER|SWP_NOACTIVATE);

		rc.top += sizeTemp.cy;
	}

	HWND child = GetContentWindow();
	if (NULL != child)
	{
		SetWindowPos(child, NULL, rc.left+hBorder, rc.top+vBorder,
			rc.right-rc.left-2*hBorder, rc.bottom-rc.top-2*vBorder, SWP_NOZORDER|SWP_NOACTIVATE);
	}
}

void CEdgedWindow::GetDesiredSize(SIZE *psize)
{
	int nBorder = GetBorderWidth();

	int hBorder = m_hMargin + nBorder;
	int vBorder = m_vMargin + nBorder;

	CGenWindow::GetDesiredSize(psize);
	psize->cx += 2*hBorder;
	psize->cy += 2*vBorder;

	// If we are hosting an IGenWindow, add on its desired size
	HWND child = GetContentWindow();
	if (NULL == child)
	{
		return;
	}
	IGenWindow *pChild = FromHandle(child);
	if (NULL == pChild)
	{
		return;
	}

	SIZE size;
	pChild->GetDesiredSize(&size);
	psize->cx += size.cx;
	psize->cy += size.cy;

	CGenWindow *pHeader = GetHeader();
	if (NULL != pHeader)
	{
		SIZE sizeTemp;
		pHeader->GetDesiredSize(&sizeTemp);
		psize->cy += sizeTemp.cy;
		psize->cx = max(psize->cx, sizeTemp.cx+LeftIndent+hBorder);
	}
}

void CEdgedWindow::OnPaint(HWND hwnd)
{
	PAINTSTRUCT ps;
	HDC hdc = BeginPaint(hwnd, &ps);

	RECT rc;
	GetClientRect(hwnd, &rc);

	CGenWindow *pHeader = GetHeader();
	if (NULL != pHeader)
	{
		SIZE sizeTemp;
		pHeader->GetDesiredSize(&sizeTemp);

		// Make the etch go through the middle of the header
		rc.top += (sizeTemp.cy-GetBorderWidth()) / 2;
	}

	DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT);

	EndPaint(hwnd, &ps);
}

LRESULT CEdgedWindow::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_PAINT, OnPaint);

	case WM_DESTROY:
		SetHeader(NULL);
		break;

	case WM_SIZE:
		// Need to invalidate if we bacame larger to redraw the border in the
		// right place
		InvalidateRect(hwnd, NULL, TRUE);
		break;
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

void CEdgedWindow::SetHeader(CGenWindow *pHeader)
{
	if (NULL != m_pHeader)
	{
		m_pHeader->Release();
	}

	m_pHeader = pHeader;
	if (NULL != m_pHeader)
	{
		m_pHeader->AddRef();
	}
}

BOOL CFrame::Create(
	HWND hWndOwner,			// Window owner
	LPCTSTR szWindowName,	// Window name
	DWORD dwStyle,			// Window style
	DWORD dwEXStyle,		// Extended window style
	int x,					// Window pos: x
	int y,					// Window pos: y
	int nWidth,				// Window size: width
	int nHeight,			// Window size: height
	HINSTANCE hInst,		// The hInstance to create the window on
	HICON hIcon,		// The icon for the window
	HMENU hmMain,		// Window menu
	LPCTSTR szClassName	// The class name to use
	)
{
	if (!CFillWindow::Create(hWndOwner, szWindowName, dwStyle, dwEXStyle,
		x, y, nWidth, nHeight, hInst, hmMain, szClassName))
	{
		return(FALSE);
	}

	if (NULL != hIcon)
	{
		SendMessage(GetWindow(), WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(hIcon));
	}

	return(TRUE);
}

void CFrame::Resize()
{
	Resize(this, 0);
}

void CFrame::Resize(CGenWindow *pThis, WPARAM wParam)
{
	SIZE size;
	pThis->GetDesiredSize(&size);
	SetWindowPos(pThis->GetWindow(), NULL, 0, 0, size.cx, size.cy,
		SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
}

void CFrame::OnDesiredSizeChanged()
{
	// I should probably look at the window style and only do this if it is
	// not resizable. But then that would be wrong sometimes too, so just
	// override this if you want different behavior.
	AsyncInvoke(Resize, 0);
}

LRESULT CFrame::ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		HANDLE_MSG(hwnd, WM_PALETTECHANGED , OnPaletteChanged);
		HANDLE_MSG(hwnd, WM_QUERYNEWPALETTE, OnQueryNewPalette);
	}

	return(CFillWindow::ProcessMessage(hwnd, uMsg, wParam, lParam));
}

void CFrame::OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange)
{
	SelAndRealizePalette(TRUE);
	::RedrawWindow(GetWindow(), NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
}

BOOL CFrame::SelAndRealizePalette(BOOL bBackground)
{
	BOOL bRet = FALSE;

	HPALETTE hPal = GetPalette();
	if (NULL == hPal)
	{
		return(bRet);
	}

	HWND hwnd = GetWindow();

	HDC hdc = ::GetDC(hwnd);
	if (NULL != hdc)
	{
		::SelectPalette(hdc, hPal, bBackground);
		bRet = (GDI_ERROR != ::RealizePalette(hdc));

		::ReleaseDC(hwnd, hdc);
	}

	return bRet;
}

BOOL CFrame::OnQueryNewPalette(HWND hwnd)
{
	return(SelAndRealizePalette(FALSE));
}

BOOL CFrame::SetForeground()
{
	BOOL bRet = FALSE;

	HWND hwnd = GetWindow();

	if (NULL != hwnd)
	{
		WINDOWPLACEMENT wp;
		wp.length = sizeof(wp);

		if (::GetWindowPlacement(hwnd, &wp) &&
			((SW_MINIMIZE == wp.showCmd) || (SW_SHOWMINIMIZED == wp.showCmd)))
		{
			// The window is minimized - restore it:
			::ShowWindow(hwnd, SW_RESTORE);
		}
		else
		{
			::ShowWindow(hwnd, SW_SHOW);
		}

		// Bring it to the foreground
		SetForegroundWindow(hwnd);
		bRet = TRUE;
	}

	return bRet;
}

void CFrame::MoveEnsureVisible(int x, int y)
{
	static const int MinVis = 16;

	RECT rcThis;
	GetWindowRect(GetWindow(), &rcThis);
	// Change to width and height
	rcThis.right -= rcThis.left;
	rcThis.bottom -= rcThis.top;

	RECT rcDesktop;
	SystemParametersInfo(SPI_GETWORKAREA, 0, &rcDesktop, 0);

	if ((x+rcThis.right < rcDesktop.left+MinVis) || (x > rcDesktop.right-MinVis))
	{
		x = (rcDesktop.left + rcDesktop.right - rcThis.right) / 2;
	}

	if ((y+rcThis.bottom < rcDesktop.top+MinVis) || (y > rcDesktop.bottom-MinVis))
	{
		y = (rcDesktop.top + rcDesktop.bottom - rcThis.bottom) / 2;
	}

	SetWindowPos(GetWindow(), NULL, x, y, 0, 0, SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
}

BOOL IsWindowActive(HWND hwnd)
{
	HWND hwndFocus = GetFocus();

	while (NULL != hwndFocus)
	{
		if (hwndFocus == hwnd)
		{
			return(TRUE);
		}

		HWND hwndParent = GetParent(hwndFocus);
		if (NULL == hwndParent)
		{
			hwndFocus = GetWindow(hwndFocus, GW_OWNER);
		}
		else
		{
			hwndFocus = hwndParent;
		}
	}

	return(FALSE);
}

static BOOL ShouldTry(HWND child)
{
	return((WS_VISIBLE) == (GetWindowStyle(child) & (WS_DISABLED|WS_VISIBLE)));
}

static BOOL IsTabbable(HWND child)
{
	return((WS_TABSTOP|WS_VISIBLE) == (GetWindowStyle(child) & (WS_TABSTOP|WS_DISABLED|WS_VISIBLE)));
}


HWND NextControl(HWND hwndTop, HWND hwndFocus)
{
	// Loop detection stuff
	BOOL bGotToTop = FALSE;

	// We'll loop to avoid really deep recursion
	while (TRUE)
	{
		// First try the children of hwndFocus
		if (hwndFocus == hwndTop || ShouldTry(hwndFocus))
		{
			HWND next = GetFirstChild(hwndFocus);
			if (NULL != next)
			{
				if (IsTabbable(next))
				{
					return(next);
				}

				hwndFocus = next;
				continue;
			}
		}

		if (hwndFocus == hwndTop)
		{
			// Apparently hwndTop has no children
			return(NULL);
		}

		HWND next;
		while (NULL == (next = GetNextSibling(hwndFocus)))
		{
			hwndFocus = GetParent(hwndFocus);
			if (NULL == hwndFocus)
			{
				// Invalid params
				return(NULL);
			}

			if (hwndTop == hwndFocus)
			{
				break;
			}
		}

		if (hwndTop == hwndFocus)
		{
			// Detect if we have looped back to the top again
			if (bGotToTop)
			{
				return(NULL);
			}

			bGotToTop = TRUE;
			continue;
		}

		if (IsTabbable(next))
		{
			return(next);
		}

		hwndFocus = next;
	}

	// We looped back to the beginning, so I guess nobody can take the focus
	return(NULL);
}

// Determine the previous control in the tab order
HWND PrevControl(HWND hwndTop, HWND hwndFocus)
{
	// In case hwndFocus is not focusable for some reason, we still need to
	// detect the loop
	HWND hwndStart = NextControl(hwndTop, hwndFocus);

	// HACK for combo boxes: go from the edit control to the combo box control
	while (NULL != hwndFocus
		&& hwndTop != hwndFocus
		&& !IsTabbable(hwndFocus)
		)
	{
		hwndFocus = GetParent(hwndFocus);
	}

	HWND ret = hwndStart;
	while (TRUE)
	{
		HWND next = NextControl(hwndTop, ret);
		if (NULL == next)
		{
			// Oops!
			return(NULL);
		}

		if (hwndFocus == next
			|| hwndStart == next
			)
		{
			break;
		}

		ret = next;
	}

	return(ret);
}


void ShiftFocus(HWND hwndTop, BOOL bForward)
{
	HWND hwndFocus = GetFocus();

	if (!IsWindowActive(hwndTop))
	{
		hwndFocus = hwndTop;
	}

	HWND next = bForward ? NextControl(hwndTop, hwndFocus) : PrevControl(hwndTop, hwndFocus);
	if (NULL != next)
	{
		SetFocus(next);
	}
	else
	{
		MessageBeep(MB_ICONHAND);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\hextostr.cpp ===
// HEXTOSTR.CPP
//
// Utility functions to convert hexadecimal numbers into equivalent string
// representations.
//
// Note:  These functions are in their own file, rather than in STRUTIL.CPP,
// because they use a const array.  The current implementation of the linker
// pulls this array into binaries if they use any function in the source file,
// not just the functions which reference this array.

#include "precomp.h"
#include <strutil.h>


const CHAR rgchHexNumMap[] =
{
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

//
// QWordToHexString()
//
// Converts a ULARGE_INTEGER to an ANSI string (not prefixed with 0x or 0X)
//
// NOTE: pszString must point to a buffer of at least CCHMAX_ULARGE_INTEGER chars
//
// Returns the number of characters written (not including the NULL terminator)

int NMINTERNAL QWordToHexStringA(ULARGE_INTEGER qw, LPSTR pszString)
{
	ASSERT(!IsBadWritePtr(pszString, sizeof(*pszString)*CCHMAX_HEX_ULARGE_INTEGER));

	LPSTR pszCurrent = pszString;
	DWORD dwQwParts[] = {qw.HighPart, qw.LowPart};
	int i;

	// Walk the QWORD four bits at a time, mapping them to the appropriate
	// char and storing them in the caller-supplied buffer.

	// We loop through the QWORD twice, working on each DWORD separately
	for (i = 0; i < ARRAY_ELEMENTS(dwQwParts); i++)
	{
		DWORD dwQwPart = dwQwParts[i];

		// Optimization:  We only need to look at this DWORD part if it's
		// non-zero or we've already put chars in our buffer.
		if (dwQwPart || pszCurrent != pszString)
		{
			// <j> is the zero-based index of the low bit of the four-bit
			// range on which we're operating.
			int j;
			DWORD dwMask;

			for (j = BITS_PER_HEX_CHAR * (CCH_HEX_DWORD - 1),
					dwMask = 0xFL << j;
				 j >= 0;
				 j -= BITS_PER_HEX_CHAR,
					dwMask >>= BITS_PER_HEX_CHAR)
			{
				DWORD iDigit = (dwQwPart & dwMask) >> j;

				ASSERT(0xF >= iDigit);

				// We use this test to skip leading zeros
				if (pszCurrent != pszString || iDigit)
				{
					*pszCurrent++ = rgchHexNumMap[iDigit];
				}
			}
		}
	}

	// If the number was zero, we need to set it explicitly
	if (pszCurrent == pszString)
	{
		*pszCurrent++ = '0';
	}

	// Null terminate the string
	*pszCurrent = '\0';

	// Return the number of chars, not counting the null terminator
	return (int)(pszCurrent - pszString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\evtlog.cpp ===
#include "precomp.h"
#include <evtlog.h>

#define SRVC_NAME TEXT("mnmsrvc")
//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(WORD wType, WORD wCategory, DWORD dwEvtId, LPTSTR lpszMsg)
{
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];
    int     cSz = 0;

    hEventSource = RegisterEventSource(NULL, SRVC_NAME);

    if (NULL != lpszMsg)
    {
        cSz = 1;
        lpszStrings[0] = lpszMsg;
    }

    if (hEventSource != NULL) {
        ReportEvent(hEventSource, // handle of event source
                    wType,                // event type
                    wCategory,            // event category
                    dwEvtId,              // event ID
                    NULL,                 // current user's SID
                    (WORD)cSz,            // strings in lpszStrings
                    0,                    // no bytes of raw data
                    0 == cSz ? NULL : (LPCTSTR*)lpszStrings, // array of error strings
                    NULL);                // no raw data

        (VOID) DeregisterEventSource(hEventSource);
    }
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\mappedfile.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation

// Memory mapped file routines

#include "precomp.h"
#include "mappedfile.h"

BOOL CMemMappedFile::Open(
    LPCTSTR szName,         // name of the mapped file
    unsigned long ulMemSize // size of the mapped file
    )
{
    // assumption: the code isn't going to call Open twice w/different szName
    if (!m_hMappedFile)
    {
        // Create the mapped file from system page file.  If it has been created
        // previously, then CreateFileMapping acts like OpenFileMapping.

        m_hMappedFile = CreateFileMapping(
            INVALID_HANDLE_VALUE,    // Current file handle. 
            NULL,                    // Default security. 
            PAGE_READWRITE,          // Read/write permission. 
            0,                       // Hi-order DWORD of file size
            ulMemSize,               // Lo-order DWORD of file size
            szName);                 // Name of mapping object. 

        if (!m_hMappedFile) 
        {
            return FALSE;
        }

        // Note if this is the first open for the file?
        m_fFirstOpen = (GetLastError() == ERROR_SUCCESS)?TRUE:FALSE;
    }

    return TRUE;
}

BOOL CMemMappedFile::AccessMem(
    void **ppvMappedAddr    // returned pointer into memory
    )
{
    if (IsBadWritePtr(ppvMappedAddr, sizeof(void *)))
        return FALSE;

    if (!m_hMappedFile)
        return FALSE;

    // Get a pointer to the mapped memory if we don't already have it

    if (!m_pvMappedAddr)
    {
        m_pvMappedAddr = MapViewOfFile(
            m_hMappedFile,           // Handle to mapping object. 
            FILE_MAP_ALL_ACCESS,     // Read/write permission 
            0,                       // Max. object size. 
            0,                       // Size of hFile. 
            0);                      // Map entire file. 

        *ppvMappedAddr = m_pvMappedAddr;
    }

    if (NULL == m_pvMappedAddr) 
    {
        return FALSE;
    }

    return TRUE;
}

void CMemMappedFile::Close()
{
    if (m_pvMappedAddr)
    {
        UnmapViewOfFile(m_pvMappedAddr);
	    m_pvMappedAddr = 0;
    }

    if (m_hMappedFile)
    {
        CloseHandle(m_hMappedFile);
        m_hMappedFile = 0;
    }

    m_fFirstOpen = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\mlzdbg.cpp ===
#include "precomp.h"

#if defined(_DEBUG) && ! defined(_UNICODE)

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>

HDBGZONE g_hDbgZones;

void WINAPI MLZ_DbgInit(PSTR *apszZones, UINT cZones)
{
    // if registry is empty, set warning flag as default
    DbgInitEx(&g_hDbgZones, apszZones, cZones, ZONE_WARNING_FLAG);

    // if the warning flag is not set, then set it as default
    if (g_hDbgZones != NULL)
    {
        ((PZONEINFO) g_hDbgZones)->ulZoneMask |= ZONE_WARNING_FLAG;
    }
}

void WINAPI MLZ_DbgDeInit(void)
{
    DbgDeInit(&g_hDbgZones);
}

void WINAPIV MLZ_WarningOut(PSTR pszFormat, ...)
{
	if (g_hDbgZones != NULL &&
        IS_ZONE_ENABLED(g_hDbgZones, ZONE_WARNING_FLAG))
	{
		va_list args;
		va_start(args, pszFormat);
		DbgPrintf(NULL, pszFormat, args);
		va_end(args);
	}
}

BOOL WINAPI MLZ_TraceZoneEnabled(int iZone)
{
	return (g_hDbgZones != NULL &&
            IS_ZONE_ENABLED(g_hDbgZones, ZONE_TRACE_FLAG) &&
	        IS_ZONE_ENABLED(g_hDbgZones, ZONE_FLAG(iZone)));
}

void WINAPIV MLZ_TraceOut(PSTR pszFormat, ...)
{
	va_list args;
	va_start(args, pszFormat);
	DbgPrintf(NULL, pszFormat, args);
	va_end(args);
}

void WINAPI MLZ_EntryOut(int iZone, PSTR pszFunName)
{
	if (g_hDbgZones != NULL &&
        IS_ZONE_ENABLED(g_hDbgZones, ZONE_FUNCTION_FLAG) &&
	    IS_ZONE_ENABLED(g_hDbgZones, ZONE_FLAG(iZone)))
	{
        MLZ_TraceOut("%s() entered.", pszFunName);
    }
}

void WINAPI MLZ_ExitOut(int iZone, PSTR pszFunName, RCTYPE eRetCodeType, DWORD_PTR dwRetCode)
{
	if (g_hDbgZones != NULL &&
        IS_ZONE_ENABLED(g_hDbgZones, ZONE_FUNCTION_FLAG) &&
	    IS_ZONE_ENABLED(g_hDbgZones, ZONE_FLAG(iZone)))
	{
        PSTR pszRetCode;
        char szFormat[64];

        lstrcpyA(&szFormat[0], "%s() exiting...");
        pszRetCode = &szFormat[0] + lstrlenA(&szFormat[0]);

        if (eRetCodeType != RCTYPE_VOID)
        {
            lstrcpyA(pszRetCode, " rc=");
            pszRetCode += lstrlenA(pszRetCode);

    	    switch (eRetCodeType)
    	    {
    	    case RCTYPE_BOOL:
    	        lstrcpyA(pszRetCode, dwRetCode ? "TRUE" : "FALSE");
    	        break;
    	    case RCTYPE_DWORD:
    	    case RCTYPE_HRESULT:
    	        wsprintf(pszRetCode, "0x%lx", (DWORD)dwRetCode);
    	        break;
    	    case RCTYPE_INT:
    	        wsprintf(pszRetCode, "%ld", (LONG) dwRetCode);
    	        break;
    	    case RCTYPE_ULONG:
    	        wsprintf(pszRetCode, "%lu", (ULONG) dwRetCode);
    	        break;
    	    case RCTYPE_PTR:
    	        wsprintf(pszRetCode, "%p", (LPVOID) dwRetCode);
    	        break;
    	    default:
    	        ASSERT(0);
    	        break;
    	    }
        }
        MLZ_TraceOut(&szFormat[0], pszFunName);
    }
}

#endif // _DEBUG && ! _UNICODE


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\intlutil.cpp ===
// File: intlutil.cpp

#include <precomp.h>
#include <shlwapi.h>

#include <confreg.h>
#include <regentry.h>
#include <oprahcom.h>

#include "intlutil.h"

static const TCHAR g_szSHLWAPI[] = TEXT("shlwapi.dll");
const LPCSTR c_szMLLoadLibraryA = (LPCSTR)377;
const LPCSTR c_szMLLoadLibraryW = (LPCSTR)378;
const LPCSTR c_szDllGetVersion = "DllGetVersion";
const LPCSTR c_szPathRemoveFileSpecA = "PathRemoveFileSpecA";
const LPCSTR c_szPathRemoveFileSpecW = "PathRemoveFileSpecW";

const DWORD SHLWAPI_MAJOR_VERSION = 5;
const DWORD SHLWAPI_MINOR_VERSION = 0;
const DWORD SHLWAPI_BUILD_NUMBER = 1000;

typedef HINSTANCE (STDAPICALLTYPE * PFN_MLLoadLibraryA)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
typedef HINSTANCE (STDAPICALLTYPE * PFN_MLLoadLibraryW)(LPCWSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
typedef BOOL (STDAPICALLTYPE * PFN_PathRemoveFileSpecA)(LPSTR pszPath);
typedef BOOL (STDAPICALLTYPE * PFN_PathRemoveFileSpecW)(LPWSTR pszPath);

#ifdef UNICODE
#define c_szMLLoadLibrary c_szMLLoadLibraryW
#define PFN_MLLoadLibrary PFN_MLLoadLibraryW
#define c_szPathRemoveFileSpec c_szPathRemoveFileSpecW
#define PFN_PathRemoveFileSpec PFN_PathRemoveFileSpecW
#else
#define c_szMLLoadLibrary c_szMLLoadLibraryA
#define PFN_MLLoadLibrary PFN_MLLoadLibraryA
#define c_szPathRemoveFileSpec c_szPathRemoveFileSpecA
#define PFN_PathRemoveFileSpec PFN_PathRemoveFileSpecA
#endif

BOOL g_fUseMLHelp = FALSE;

#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))

inline BOOL CheckShlwapiVersion(HINSTANCE hShlwapiDll)
{
	BOOL fVersionOk = FALSE;

	DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hShlwapiDll, c_szDllGetVersion);
	if(pfnDllGetVersion)
	{
		DLLVERSIONINFO    dvi;
		HRESULT           hr;

		ZeroMemory(&dvi, sizeof(dvi));
		dvi.cbSize = sizeof(dvi);

		hr = (*pfnDllGetVersion)(&dvi);
		if (SUCCEEDED(hr))
		{
			if (dvi.dwMajorVersion > SHLWAPI_MAJOR_VERSION)
			{
				fVersionOk = TRUE;
			}
			else if (dvi.dwMajorVersion == SHLWAPI_MAJOR_VERSION)
			{
				if (dvi.dwMinorVersion > SHLWAPI_MINOR_VERSION)
				{
					fVersionOk = TRUE;
				}
				else if (dvi.dwMinorVersion == SHLWAPI_MINOR_VERSION)
				{
					if (dvi.dwBuildNumber >= SHLWAPI_BUILD_NUMBER)
					{
						fVersionOk = TRUE;
					}
				}
			}
		}
	}
	return fVersionOk;
}



/*  L O A D  N M  R E S  */
/*-------------------------------------------------------------------------
    %%Function: LoadNmRes

    Load the international resource dll.
-------------------------------------------------------------------------*/
HINSTANCE NMINTERNAL LoadNmRes(LPCTSTR pszFile)
{
	HINSTANCE hInst = NULL;

	if (NULL == pszFile)
	{
		// Use the default file name
		pszFile = TEXT("nmres.dll");
	}

	RegEntry reConf(CONFERENCING_KEY, HKEY_LOCAL_MACHINE);
	if (!reConf.GetNumber(REGVAL_DISABLE_PLUGGABLE_UI, 0))
	{
		HINSTANCE hLib = NmLoadLibrary(g_szSHLWAPI,TRUE);
		if (hLib)
		{
			if (CheckShlwapiVersion(hLib))
			{
				PFN_MLLoadLibrary pfnMLLoadLibrary =
						(PFN_MLLoadLibrary)GetProcAddress(hLib, c_szMLLoadLibrary);
				PFN_PathRemoveFileSpec pfnPathRemoveFileSpec =
						(PFN_PathRemoveFileSpec)GetProcAddress(hLib, c_szPathRemoveFileSpec);
				if ((NULL != pfnMLLoadLibrary) && (NULL != pfnPathRemoveFileSpec))
				{
					hInst = pfnMLLoadLibrary(pszFile, GetModuleHandle(NULL), 0);
					if (hInst)
					{
						// check to see if the Resource DLL was loaded from the ML Satellite
						// if not, don't use ML for Help

						TCHAR szThis[MAX_PATH];
						TCHAR szResource[MAX_PATH];

						if (GetModuleFileName(NULL, szThis, SIZEOF_ARRAY(szThis)) &&
							pfnPathRemoveFileSpec(szThis) &&
							GetModuleFileName(hInst, szResource, SIZEOF_ARRAY(szThis)) &&
							pfnPathRemoveFileSpec(szResource) &&
							(0 != lstrcmp(szThis, szResource)) )
						{
							g_fUseMLHelp = TRUE;
						}
					}
				}
			}

            FreeLibrary(hLib);
		}
	}

	if (!hInst)
	{
		hInst = NmLoadLibrary(pszFile,FALSE);
		if (NULL == hInst)
		{
			ERROR_OUT(("Unable to load resource file [%s]", pszFile));
		}
	}

	return hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\memory.cpp ===
//
// File: memory.cpp
//
// Debug memory tracking per-module

#include "precomp.h"


static BOOL   s_fZeroInit = FALSE;




#if defined(DEBUG)

#define DBG_NAME_LENGTH     16
typedef struct tagMemTag
{
    DWORD       dwSignature;
    BOOL        fActive;
    LPVOID      callerAddress;
    CHAR        szFileName[DBG_NAME_LENGTH];
    UINT        nLineNumber;
    UINT        cbSize;
    struct tagMemTag *next;
}
MEM_TAG;

static MEM_TAG *s_pDbgActiveMemPool = NULL;
#define CLEAN_BYTE  ((BYTE) 0xCD)

static UINT   s_cDbgActiveMemAlloc = 0;
static UINT   s_cbDbgActiveMem = 0;
const DWORD MEM_TAG_SIGNATURE = 0x12345678UL;

static CRITICAL_SECTION s_DbgCritSect;
static char  s_szDbgModuleName[DBG_NAME_LENGTH] = { 0 };
static void _GetFileName(LPSTR pszTarget, LPSTR pszSrc);
static void _DbgGetFileLine(LPSTR *, UINT *);

#define DBG_MEM_TRACK_DUMP_ALL      ((UINT) -1)





//
// DbgMemTrackReverseList()
//
void WINAPI DbgMemTrackReverseList(void)
{
    EnterCriticalSection(&s_DbgCritSect);
    if (NULL != s_pDbgActiveMemPool && NULL != s_pDbgActiveMemPool->next)
    {
        MEM_TAG *p, *q, *r;;

        for (q = (p = s_pDbgActiveMemPool)->next, r = q; // make sure r is not null in the beginning
             NULL != r;
             p = q, q = r)
        {
            r = q->next;
            q->next = p;
        }

        s_pDbgActiveMemPool->next = NULL;
        s_pDbgActiveMemPool = p;
    }
    LeaveCriticalSection(&s_DbgCritSect);
}


//
// DbgMemTrackDumpCurrent()
//
void WINAPI DbgMemTrackDumpCurrent(void)
{
    MEM_TAG *p;
    int i;
    char szBuf[128];

    EnterCriticalSection(&s_DbgCritSect);
    for (p = s_pDbgActiveMemPool, i = 0; p; p = p->next, i++)
    {
        if (p->callerAddress)
        {
            // No file/line, just caller
            wsprintfA(szBuf, "%s: mem leak [%u]: caller address=0x%p, size=%u, ptr=0x%p\r\n",
                s_szDbgModuleName, i,
                p->callerAddress, p->cbSize, (p+1));
        }
        else
        {
            // File & line number
            wsprintfA(szBuf, "%s: mem leak [%u]: file=%s, line=%u, size=%u, ptr=0x%p\r\n",
                s_szDbgModuleName, i,
                p->szFileName, p->nLineNumber, p->cbSize, (p+1));
        }
        OutputDebugStringA(szBuf);
    }
    LeaveCriticalSection(&s_DbgCritSect);
}


//
// DbgMemTrackFinalCheck()
//
// Dumps any left-around (leaked) memory blocks.  Call this on
// DLL_PROCESS_DETACH from your .DLL or at the end of WinMain of your .EXE
//
void WINAPI DbgMemTrackFinalCheck(void)
{
    DbgMemTrackReverseList();
    DbgMemTrackDumpCurrent();
    if (NULL != s_pDbgActiveMemPool ||
        NULL != s_cDbgActiveMemAlloc ||
        NULL != s_cbDbgActiveMem)
    {
        DebugBreak();
    }

    DeleteCriticalSection(&s_DbgCritSect);
}


//
// _GetFileName()
//
static void _GetFileName(LPSTR pszTarget, LPSTR pszSrc)
{
    LPSTR psz = pszSrc;
    while (*psz != '\0')
    {
        if (*psz++ == '\\')
        {
            pszSrc = psz;
        }
    }
    lstrcpynA(pszTarget, pszSrc, DBG_NAME_LENGTH);
}


//
// DbgMemAlloc()
//
// Debug memory allocation
//
LPVOID WINAPI DbgMemAlloc
(
    UINT    cbSize,
    LPVOID  callerAddress,
    LPSTR   pszFileName,
    UINT    nLineNumber
)
{
    MEM_TAG *p;
    UINT cbToAlloc;

    cbToAlloc = sizeof(MEM_TAG) + cbSize;

    EnterCriticalSection(&s_DbgCritSect);

    p = (MEM_TAG *) LocalAlloc(LPTR, cbToAlloc);
    if (p != NULL)
    {
        p->dwSignature = MEM_TAG_SIGNATURE;
        p->fActive = TRUE;
        p->callerAddress = callerAddress;

        if (pszFileName)
        {
            _GetFileName(p->szFileName, pszFileName);
            p->nLineNumber = nLineNumber;
        }

        p->cbSize = cbSize;
        p->next = s_pDbgActiveMemPool;
        s_pDbgActiveMemPool = p;
        s_cDbgActiveMemAlloc++;
        s_cbDbgActiveMem += p->cbSize;
        p++;

        //
        // If no zero-init, fill with clean byte
        //
        if (!s_fZeroInit)
        {
            FillMemory(p, cbSize, CLEAN_BYTE);
        }
    }

    LeaveCriticalSection(&s_DbgCritSect);

    return (LPVOID) p;
}


//
// DbgMemFree()
//
// Debug memory free
//
void WINAPI DbgMemFree(LPVOID ptr)
{
    if (ptr != NULL)
    {
        MEM_TAG *p = (MEM_TAG *) ptr;
        p--;
        if (! IsBadWritePtr(p, sizeof(MEM_TAG)) &&
            (p->dwSignature == MEM_TAG_SIGNATURE))
        {
            if (! p->fActive)
            {
                //
                // This memory has been freed already.
                //
                ERROR_OUT(("DbgMemFree called with invalid pointer 0x%08x", p));
                return;
            }

            MEM_TAG *q, *q0;
            EnterCriticalSection(&s_DbgCritSect);
            for (q = s_pDbgActiveMemPool; q != NULL; q = (q0 = q)->next)
            {
                if (q == p)
                {
                    if (q == s_pDbgActiveMemPool)
                    {
                        s_pDbgActiveMemPool = p->next;
                    }
                    else
                    {
                        q0->next = p->next;
                    }
                    s_cDbgActiveMemAlloc--;
                    s_cbDbgActiveMem -= p->cbSize;
                    p->fActive = FALSE;

                    //
                    // Fill app pointer data with CLEAN_BYTE, to see if
                    // anybody tries later to access it after it's been
                    // freed.
                    //
                    FillMemory(p+1, p->cbSize, CLEAN_BYTE);
                    break;
                }
            }
            LeaveCriticalSection(&s_DbgCritSect);
        }
        else
        {
            ERROR_OUT(("DbgMemFree called with invalid pointer 0x%08x", p));
            return;
        }

        LocalFree(p);
    }
}


//
// DbgMemReAlloc()
//
// Debug memory reallocate
//
LPVOID WINAPI DbgMemReAlloc(LPVOID ptr, UINT cbSize, UINT uFlags, LPSTR pszFileName, UINT nLineNumber)
{
    MEM_TAG *p;
    void *q;

    if (ptr == NULL)
        return DbgMemAlloc(cbSize, 0, pszFileName, nLineNumber);

    p = (MEM_TAG *) ptr;
    p--;

    if (IsBadWritePtr(p, sizeof(MEM_TAG)) ||
        p->dwSignature != MEM_TAG_SIGNATURE)
    {
        DebugBreak();
        return LocalReAlloc(ptr, cbSize, uFlags);
    }

    q = DbgMemAlloc(cbSize, 0, pszFileName, nLineNumber);
    if (q != NULL)
    {
        CopyMemory(q, ptr, p->cbSize);
        DbgMemFree(ptr);
    }

    return q;
}


typedef struct
{
    DWORD    dwThreadID;
    LPSTR    pszFileName;
    UINT    nLineNumber;
}
DBG_THREAD_FILE_LINE;

#define DBG_MAX_THREADS     32
static DBG_THREAD_FILE_LINE s_aThreadFileLine[DBG_MAX_THREADS] = { 0 };

void WINAPI DbgSaveFileLine(LPSTR pszFileName, UINT nLineNumber)
{
    DWORD dwThreadID = GetCurrentThreadId();

    EnterCriticalSection(&s_DbgCritSect);
    UINT c = DBG_MAX_THREADS;
    DBG_THREAD_FILE_LINE *p;
    for (p = s_aThreadFileLine; c--; p++)
    {
        if (p->dwThreadID == 0)
        {
            p->dwThreadID = dwThreadID;
            p->pszFileName = pszFileName;
            p->nLineNumber = nLineNumber;
            break;
        }
        else
        if (p->dwThreadID == dwThreadID)
        {
            p->pszFileName = pszFileName;
            p->nLineNumber = nLineNumber;
            break;
        }
    }
    LeaveCriticalSection(&s_DbgCritSect);
}

void WINAPI DbgGetFileLine(LPSTR *ppszFileName, UINT *pnLineNumber)
{
    *ppszFileName = NULL;
    *pnLineNumber = 0;

    DWORD dwThreadID = GetCurrentThreadId();

    EnterCriticalSection(&s_DbgCritSect);
    UINT c = DBG_MAX_THREADS;
    DBG_THREAD_FILE_LINE *p;
    for (p = s_aThreadFileLine; c--; p++)
    {
        if (p->dwThreadID == 0)
        {
            break;
        }
        else if (p->dwThreadID == dwThreadID)
        {
            *ppszFileName = p->pszFileName;
            *pnLineNumber = p->nLineNumber;
            p->pszFileName = NULL;
            p->nLineNumber = 0;
            break;
        }
    }
    LeaveCriticalSection(&s_DbgCritSect);
}



LPVOID __cdecl ::operator new(size_t uObjSize)
{
    LPVOID  callerAddress;
    LPSTR   pszFileName;
    UINT    nLineNumber;

    DbgGetFileLine(&pszFileName, &nLineNumber);

    if (pszFileName)
    {
        callerAddress = NULL;
    }
    else
    {
#ifdef _X86_
        LPVOID * lpParams;

        //
        // LAURABU HACK:  This doesn't work for alpha.  But it's not bad
        // for normal debugging.  We're going to grab the return address
        // of whomever called new()
        //
        lpParams = (LPVOID *)&uObjSize;
        callerAddress = *(lpParams - 1);
#else
        callerAddress = NULL;
#endif // _X86_
    }

    return(DbgMemAlloc(uObjSize, callerAddress, pszFileName, nLineNumber));
}

#else       // RETAIL


LPVOID __cdecl ::operator new(size_t uObjSize)
{
    if (s_fZeroInit)
    {
        return(LocalAlloc(LPTR, uObjSize));
    }
    else
    {
        return(LocalAlloc(LMEM_FIXED, uObjSize));
    }
}

#endif // defined(DEBUG)



//
// delete() is the same for both debug and retail
//
void __cdecl  ::operator delete(LPVOID pObj)
{
    MemFree(pObj);
}


//
// DbgInitMemTrack()
//
// Initialize debug memory tracking.  Call this on DLL_PROCESS_ATTACH in
// your .DLL or at beginning of WinMain of your .EXE
//
void WINAPI DbgInitMemTrack(HINSTANCE hDllInst, BOOL fZeroInit)
{
    s_fZeroInit = fZeroInit;

#if defined(DEBUG)
    InitializeCriticalSection(&s_DbgCritSect);

    char szPath[MAX_PATH];
    if (0 != GetModuleFileNameA(hDllInst, szPath, MAX_PATH))
    {
        _GetFileName(s_szDbgModuleName, szPath);
        LPSTR psz = s_szDbgModuleName;
        while (*psz != '\0')
        {
            if (*psz == '.')
            {
                *psz = '\0';
                break;
            }
            psz++;
        }
    }
    else
    {
        lstrcpyA(s_szDbgModuleName, "unknown");
    }
#endif // DEBUG
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\oblist.cpp ===
// ChrisPi: This is a quick attempt to create a list class that uses the
// same member functions and parameters as MFC's CObList.  Only the members
// used in DCL's master objects are implemented.

#include "precomp.h"
#include <oblist.h>

#ifdef DEBUG
VOID* COBLIST::GetHead()
{
	ASSERT(m_pHead);

	return m_pHead->pItem;
}
#endif // ifdef DEBUG
   
VOID* COBLIST::GetTail()
{
	ASSERT(m_pTail);

	return m_pTail->pItem;
}

VOID* COBLIST::GetNext(POSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* COBLIST::RemoveAt(POSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;

			if (NULL == m_pHead)
			{
				// Removing the only element!
				m_pTail = NULL;
			}
		}
		else
		{
			POSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

POSITION COBLIST::AddTail(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pTail)
	{
		if (m_pTail->pNext = new COBNODE)
		{
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
		}
	}

	return m_pTail;
}

void COBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}

COBLIST::~COBLIST()
{
    ASSERT(IsEmpty());
}

#ifdef DEBUG

#if 0
VOID* COBLIST::RemoveTail()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pTail);
}
#endif

VOID* COBLIST::RemoveHead()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pHead);
}

void * COBLIST::GetFromPosition(POSITION Pos)
{
    void * Result = SafeGetFromPosition(Pos);
	ASSERT(Result);
	return Result;
}
#endif /* if DEBUG */

POSITION COBLIST::GetPosition(void* _pItem)
{
    // For potential efficiency of lookup (if we switched to 
    // a doubly linked list), users should really store the POSITION
    // of an item. For those that don't, this method is provided.

    POSITION    Position = m_pHead;

    while (Position) {
        if (Position->pItem == _pItem) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

POSITION COBLIST::Lookup(void* pComparator)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Compare(Position->pItem, pComparator)) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

void * COBLIST::SafeGetFromPosition(POSITION Pos)
{
	// Safe way to validate that an entry is still in the list,
	// which ensures bugs that would reference deleted memory,
	// reference a NULL pointer instead
	// (e.g. an event handler fires late/twice).
	// Note that versioning on entries would provide an additional 
	// safeguard against re-use of a position.
	// Walk	list to find entry.

	POSITION PosWork = m_pHead;
	
	while (PosWork) {
		if (PosWork == Pos) {
			return Pos->pItem;
		}
		GetNext(PosWork);
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\nmdsprv.cpp ===
// Utility code for Mapping a WAVE device ID to a DirectSound GUID
// Added - August 24, 1998

// original code in \av\utils\wav2ds

// this code will return an error on Win95
// (although it may work for a future version of DX)



/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.c
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *  08/24/98    jselbie	Streamlined up for lightweight use in NetMeeting
 *
 ***************************************************************************/


#include "precomp.h"

#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include <dsound.h>

// DirectSound Private Component GUID {11AB3EC0-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(CLSID_DirectSoundPrivate, 0x11ab3ec0, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);


//
// Property Sets
//

// DirectSound Device Properties {84624F82-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(DSPROPSETID_DirectSoundDevice, 0x84624f82, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);


typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE,
} DSPROPERTY_DIRECTSOUNDDEVICE;


typedef enum
{
    DIRECTSOUNDDEVICE_DATAFLOW_RENDER,
    DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE
} DIRECTSOUNDDEVICE_DATAFLOW;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA
{
    LPSTR                       DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA;



/***************************************************************************
 *
 *  DirectSoundPrivateCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundPrivate object.
 *
 *  Arguments:
 *      LPKSPROPERTYSET * [out]: receives IKsPropertySet interface to the
 *                               object.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT 
DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *       ppKsPropertySet
)
{
    typedef HRESULT (STDAPICALLTYPE *LPFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);

    HINSTANCE               hLibDsound              = NULL;
    LPFNGETCLASSOBJECT      pfnDllGetClassObject    = NULL;
    LPCLASSFACTORY          pClassFactory           = NULL;
    LPKSPROPERTYSET         pKsPropertySet          = NULL;
    HRESULT                 hr                      = DS_OK;

    hLibDsound = 
        GetModuleHandle
        (
            TEXT("dsound.dll")
        );


    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DllGetClassObject
    if(SUCCEEDED(hr))
    {
        pfnDllGetClassObject = (LPFNDLLGETCLASSOBJECT)
            GetProcAddress
            (
                hLibDsound, 
                "DllGetClassObject"
            );

        if(!pfnDllGetClassObject)
        {
            hr = DSERR_GENERIC;
        }
    }

    // Create a class factory object    
    if(SUCCEEDED(hr))
    {
        hr = 
            pfnDllGetClassObject
            (
                CLSID_DirectSoundPrivate, 
                IID_IClassFactory, 
                (LPVOID *)&pClassFactory
            );
    }

    // Create the DirectSoundPrivate object and query for an IKsPropertySet
    // interface
    if(SUCCEEDED(hr))
    {
        hr = 
            pClassFactory->CreateInstance
            (
                NULL, 
                IID_IKsPropertySet, 
                (LPVOID *)&pKsPropertySet
            );
    }

    // Release the class factory
    if(pClassFactory)
    {
        pClassFactory->Release();
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppKsPropertySet = pKsPropertySet;
    }

    return hr;
}


/***************************************************************************
 *
 *  DsprvGetWaveDeviceMapping
 *
 *  Description:
 *      Gets the DirectSound device id (if any) for a given waveIn or
 *      waveOut device description.  This is the description given by
 *      waveIn/OutGetDevCaps (szPname).
 *
 *  Arguments:
 *      LPCSTR [in]: wave device description.  (WAVEOUTCAPS.szPname or WAVEINCAPS.szPname)
 *      BOOL [in]: TRUE if the device description refers to a waveIn device.
 *      LPGUID [out]: receives DirectSound device GUID.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

extern "C" HRESULT __stdcall
DsprvGetWaveDeviceMapping
(
	LPCSTR                                              pszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA Data;
    HRESULT                                             hr;
    IKsPropertySet                                      *pKsPropertySet=NULL;
    HINSTANCE                                           hLibDsound= NULL;


	hLibDsound = NmLoadLibrary(TEXT("dsound.dll"),TRUE);
	if (hLibDsound == NULL)
	{
		return E_FAIL;
	}


	hr = DirectSoundPrivateCreate(&pKsPropertySet);
	if (SUCCEEDED(hr))
	{

	    Data.DeviceName = (LPSTR)pszWaveDevice;
		Data.DataFlow = fCapture ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

	    hr =
		    pKsPropertySet->Get
			(
				DSPROPSETID_DirectSoundDevice,
	            DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING,
		        NULL,
			    0,
				&Data,
	            sizeof(Data),
		        NULL
			);

	    if(SUCCEEDED(hr))
		{
			*pguidDeviceId = Data.DeviceId;
	    }
		else
		{
			ZeroMemory(pguidDeviceId, sizeof(GUID));
		}

	}

	if (pKsPropertySet)
		pKsPropertySet->Release();

	FreeLibrary(hLibDsound);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\nmhelp.cpp ===
// File: nmhelp.cpp

#include <precomp.h>

#ifndef UNICODE

#include <nmhelp.h>
#include <htmlhelp.h>
#include <strutil.h>
#include <intlutil.h>

extern BOOL g_fUseMLHelp;

// The main NetMeeting Help file
static const TCHAR s_cszWinHelpFile[]  = TEXT("conf.hlp");

static const TCHAR g_pszHHCtrl[] = TEXT("hhctrl.ocx");

static const TCHAR g_szSHLWAPI[] = TEXT("shlwapi.dll");
const LPCSTR szMLWinHelpA = (LPCSTR)395;
const LPCSTR szMLHtmlHelpA = (LPCSTR)396;
const LPCSTR szMLWinHelpW = (LPCSTR)397;
const LPCSTR szMLHtmlHelpW = (LPCSTR)398;

typedef BOOL (WINAPI * PFN_MLWinHelpA)(HWND hwndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
typedef HWND (WINAPI * PFN_MLHtmlHelpA)(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
typedef BOOL (WINAPI * PFN_MLWinHelpW)(HWND hwndCaller, LPCWSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
typedef HWND (WINAPI * PFN_MLHtmlHelpW)(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);

#ifdef UNICODE
#define szMLWinHelp szMLWinHelpW
#define szMLHtmlHelp szMLHtmlHelpW
#define PFN_MLWinHelp PFN_MLWinHelpW
#define PFN_MLHtmlHelp PFN_MLHtmlHelpW
#else
#define szMLWinHelp szMLWinHelpA
#define szMLHtmlHelp szMLHtmlHelpA
#define PFN_MLWinHelp PFN_MLWinHelpA
#define PFN_MLHtmlHelp PFN_MLHtmlHelpA
#endif

extern "C"
HWND HtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
	static HMODULE g_hmodHHCtrl = NULL;
	static HWND (WINAPI *g_pHtmlHelpA)(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData);

	if (NULL == g_hmodHHCtrl)
	{
		g_hmodHHCtrl = NmLoadLibrary(g_pszHHCtrl,TRUE);
		if (NULL == g_hmodHHCtrl)
		{
			return NULL;
		}
	}

#ifndef _WIN64
	if (NULL == g_pHtmlHelpA)
	{
		(FARPROC&)g_pHtmlHelpA = GetProcAddress(g_hmodHHCtrl, ATOM_HTMLHELP_API_ANSI);
		if (NULL == g_pHtmlHelpA)
		{
			return NULL;
		}
	}

	return g_pHtmlHelpA(hwndCaller, pszFile, uCommand, dwData);
#else
	return NULL;
#endif
}


/*  N M  W I N  H E L P  */
/*-------------------------------------------------------------------------
    %%Function: NmWinHelp

-------------------------------------------------------------------------*/
BOOL NmWinHelp(HWND hWndMain, LPCTSTR lpszHelp, UINT uCommand, DWORD_PTR dwData)
{
	static PFN_MLWinHelp s_pfnMLWinHelp = NULL;

	if (g_fUseMLHelp && (NULL == s_pfnMLWinHelp))
	{
		HINSTANCE hLib = NmLoadLibrary(g_szSHLWAPI,TRUE);
		if (hLib)
		{
			s_pfnMLWinHelp = (PFN_MLWinHelp)GetProcAddress(hLib, szMLWinHelp);
			if (NULL == s_pfnMLWinHelp)
			{
				// must be wrong version of shlwapi.dll
				FreeLibrary(hLib);
				g_fUseMLHelp = FALSE;
			}
		}
		else
		{
			// cannot find shlwapi.dll
			g_fUseMLHelp = FALSE;
		}
	}

	if (NULL != s_pfnMLWinHelp)
	{
		return s_pfnMLWinHelp(hWndMain, lpszHelp, uCommand, dwData);
	}
	else
	{
		return ::WinHelp(hWndMain, lpszHelp, uCommand, dwData);
	}
}


/*  N M  H T M L  H E L P  */
/*-------------------------------------------------------------------------
    %%Function: NmHtmlHelp

-------------------------------------------------------------------------*/
HWND NmHtmlHelp(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
	static PFN_MLHtmlHelp s_pfnMLHtmlHelp = NULL;

	if (g_fUseMLHelp && (NULL == s_pfnMLHtmlHelp))
	{
		HINSTANCE hLib = NmLoadLibrary(g_szSHLWAPI,TRUE);
		if (hLib)
		{
			s_pfnMLHtmlHelp = (PFN_MLHtmlHelp)GetProcAddress(hLib, szMLHtmlHelp);
			if (NULL == s_pfnMLHtmlHelp)
			{
				// must be wrong version of shlwapi.dll
				FreeLibrary(hLib);
				g_fUseMLHelp = FALSE;
			}
		}
		else
		{
			// cannot find shlwapi.dll
			g_fUseMLHelp = FALSE;
		}
	}

	if (NULL != s_pfnMLHtmlHelp)
	{
		return s_pfnMLHtmlHelp(hwndCaller, pszFile, uCommand, dwData, 0);
	}
	else
	{
		return ::HtmlHelp(hwndCaller, pszFile, uCommand, dwData);
	}
}



static const TCHAR s_cszHtmlHelpApiMarshalerWndClass[] = TEXT("NmUtil_HtmlHelpMarshalWnd");


	// HtmlHelp api cannot be called from multiple threads... that is, HtmlHelp must be
	// called from the same thread in which the DLL is loaded... This is the non-threadsafe
	// entry point to HtmlHelp... this must allways be called in the same thread that
	// InitHtmlHelpMarshaller was called....

	// This is the window procedure that we use to marshall calls to
	// HtmlHelp via calls to ShowNmHelp from arbitrary threads
static LRESULT CALLBACK HtmlHelpWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uMsg )
	{
		case WM_USER:
		{
			LPCTSTR lpcszHelpFile = reinterpret_cast<LPCTSTR>(lParam);
			NmHtmlHelp(NULL, lpcszHelpFile, HH_DISPLAY_TOPIC, 0);
			return(TRUE);
		}
	}

	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

	// the html help Apis are not threadsafe...
	// In fact, they call CoInitialize in the DLLProcessAttatch...
	// So essentially we are going to marshal all calls to HtmlHelp
	// Into the context of the first thread to call InitHtmlHelpMarshaller
HRESULT InitHtmlHelpMarshaler(HINSTANCE hInst)
{
	HRESULT hr = S_OK;

	WNDCLASS wc;
	ZeroMemory( &wc, sizeof( wc ) );

	wc.lpfnWndProc = HtmlHelpWndProc;
	wc.hInstance = hInst;
	wc.lpszClassName = s_cszHtmlHelpApiMarshalerWndClass;

	if( RegisterClass( &wc ) )
	{
		HWND hWnd = CreateWindow(s_cszHtmlHelpApiMarshalerWndClass, NULL, 0, 0, 0, 0, NULL, NULL, NULL, hInst, 0 );
		if( NULL == hWnd )
		{
			ERROR_OUT(("CreateWindow failed in InitHtmlHelpMarshaler"));
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}


VOID ShowNmHelp(LPCTSTR lpcszHtmlHelpFile)
{
	HWND hWnd = FindWindow( s_cszHtmlHelpApiMarshalerWndClass, NULL );
	if( hWnd )
	{
		SendMessage( hWnd, WM_USER, 0, reinterpret_cast<LPARAM>(lpcszHtmlHelpFile) );
	}
	else
	{
		ERROR_OUT(("Could not find the Help Marshaller Window... Has InitHtmlHelpMarshaller been called yet?"));
	}
}


/*  D O  N M  H E L P  */
/*-------------------------------------------------------------------------
    %%Function: DoNmHelp

    Generic routine to display the normal WinHelp information.
-------------------------------------------------------------------------*/
VOID DoNmHelp(HWND hwnd, UINT uCommand, DWORD_PTR dwData)
{
	NmWinHelp(hwnd, s_cszWinHelpFile, uCommand, dwData);
}

// "WM_HELP" context menu handler (requires HIDC_* entry on the controls)
VOID DoHelp(LPARAM lParam)
{
	LPHELPINFO phi = (LPHELPINFO) lParam;
	ASSERT(phi->iContextType == HELPINFO_WINDOW);
	DoNmHelp((HWND) phi->hItemHandle, HELP_CONTEXTPOPUP, phi->dwContextId);
}

// "WM_HELP" handler (with control-to-help id map)
VOID DoHelp(LPARAM lParam, const DWORD * rgId)
{
	HWND hwnd = (HWND)(((LPHELPINFO)lParam)->hItemHandle);
	DoNmHelp(hwnd, HELP_WM_HELP, (DWORD_PTR) rgId);
}

// "WM_CONTEXTMENU" handler (with control-to-help id map)
VOID DoHelpWhatsThis(WPARAM wParam, const DWORD * rgId)
{
	HWND hwnd = (HWND)wParam;
	DoNmHelp(hwnd, HELP_CONTEXTMENU, (DWORD_PTR) rgId);
}


VOID ShutDownHelp(void)
{
	DoNmHelp(NULL, HELP_QUIT, 0);
	// REVIEW: Do we shut down HTML help as well?
}


#endif /* UNICODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\olevalid.c ===
/*
 * olevalid.c - OLE validation functions module.
 *
 * Taken from URL code 
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"


/****************************** Public Functions *****************************/


#ifdef DEBUG

BOOL IsValidPCGUID(PCGUID pcguid)
{
   /* All values are valid GUIDs. */

   return(IS_VALID_READ_PTR(pcguid, CGUID));
}


BOOL IsValidPCCLSID(PCCLSID pcclsid)
{
   return(IS_VALID_STRUCT_PTR(pcclsid, CGUID));
}


BOOL IsValidPCIID(PCIID pciid)
{
   return(IS_VALID_STRUCT_PTR(pciid, CGUID));
}


BOOL IsValidPCDVTARGETDEVICE(PCDVTARGETDEVICE pcdvtd)
{
   /* BUGBUG: Validate remaining fields here. */

   return(IS_VALID_READ_PTR(&(pcdvtd->tdSize), DWORD) &&
          IS_VALID_READ_BUFFER_PTR(pcdvtd, DVTARGETDEVICE, pcdvtd->tdSize));
}


BOOL IsValidPCFORMATETC(PCFORMATETC pcfe)
{
   /* BUGBUG: Validate structure fields. */

   return(IS_VALID_READ_PTR(pcfe, CFORMATETC));
}


BOOL IsValidStgMediumType(DWORD tymed)
{
   BOOL bResult;

   switch (tymed)
   {
      case TYMED_HGLOBAL:
      case TYMED_FILE:
      case TYMED_ISTREAM:
      case TYMED_ISTORAGE:
      case TYMED_GDI:
      case TYMED_MFPICT:
      case TYMED_ENHMF:
      case TYMED_NULL:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidStgMediumType(): Invalid storage medium type %lu.",
                    tymed));
         break;
   }

   return(bResult);
}


BOOL IsValidPCSTGMEDIUM(PCSTGMEDIUM pcstgmed)
{
   /* BUGBUG: Validate u union field. */

   return(IS_VALID_READ_PTR(pcstgmed, CSTGMEDIUM) &&
          IsValidStgMediumType(pcstgmed->tymed) &&
          (! pcstgmed->pUnkForRelease ||
           IS_VALID_INTERFACE_PTR(pcstgmed->pUnkForRelease, IUnknown)));
}


BOOL IsValidREFIID(REFIID riid)
{
   return(IS_VALID_STRUCT_PTR(riid, CIID));
}


BOOL IsValidREFCLSID(REFCLSID rclsid)
{
   return(IS_VALID_STRUCT_PTR(rclsid, CCLSID));
}


BOOL IsValidPCINTERFACE(PCVOID pcvi)
{
   return(IS_VALID_READ_PTR((FARPROC *)pcvi, FARPROC) &&
          IS_VALID_CODE_PTR(*((FARPROC *)pcvi), Method));
}


BOOL IsValidPCIAdviseSink(PCIAdviseSink pcias)
{
   return(IS_VALID_READ_PTR(pcias, CIAdviseSink) &&
          IS_VALID_READ_PTR(pcias->lpVtbl, sizeof(*(pcias->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcias, IUnknown) &&
          IS_VALID_METHOD(pcias, OnDataChange) &&
          IS_VALID_METHOD(pcias, OnViewChange) &&
          IS_VALID_METHOD(pcias, OnRename) &&
          IS_VALID_METHOD(pcias, OnSave) &&
          IS_VALID_METHOD(pcias, OnClose));
}


BOOL IsValidPCIClassFactory(PCIClassFactory pcicf)
{
   return(IS_VALID_READ_PTR(pcicf, CIClassFactory) &&
          IS_VALID_READ_PTR(pcicf->lpVtbl, sizeof(*(pcicf->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcicf, IUnknown) &&
          IS_VALID_METHOD(pcicf, CreateInstance) &&
          IS_VALID_METHOD(pcicf, LockServer));
}


BOOL IsValidPCIDataObject(PCIDataObject pcido)
{
   return(IS_VALID_READ_PTR(pcido, CIDataObject) &&
          IS_VALID_READ_PTR(pcido->lpVtbl, sizeof(*(pcido->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcido, IUnknown) &&
          IS_VALID_METHOD(pcido, GetData) &&
          IS_VALID_METHOD(pcido, GetDataHere) &&
          IS_VALID_METHOD(pcido, QueryGetData) &&
          IS_VALID_METHOD(pcido, GetCanonicalFormatEtc) &&
          IS_VALID_METHOD(pcido, SetData) &&
          IS_VALID_METHOD(pcido, EnumFormatEtc) &&
          IS_VALID_METHOD(pcido, DAdvise) &&
          IS_VALID_METHOD(pcido, DUnadvise) &&
          IS_VALID_METHOD(pcido, EnumDAdvise));
}


BOOL IsValidPCIDropSource(PCIDropSource pcids)
{
   return(IS_VALID_READ_PTR(pcids, CIDataObject) &&
          IS_VALID_READ_PTR(pcids->lpVtbl, sizeof(*(pcids->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcids, IUnknown) &&
          IS_VALID_METHOD(pcids, QueryContinueDrag) &&
          IS_VALID_METHOD(pcids, GiveFeedback));
}


BOOL IsValidPCIDropTarget(PCIDropTarget pcidt)
{
   return(IS_VALID_READ_PTR(pcidt, CIDataObject) &&
          IS_VALID_READ_PTR(pcidt->lpVtbl, sizeof(*(pcidt->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcidt, IUnknown) &&
          IS_VALID_METHOD(pcidt, DragEnter) &&
          IS_VALID_METHOD(pcidt, DragOver) &&
          IS_VALID_METHOD(pcidt, DragLeave) &&
          IS_VALID_METHOD(pcidt, Drop));
}


BOOL IsValidPCIEnumFORMATETC(PCIEnumFORMATETC pciefe)
{
   return(IS_VALID_READ_PTR(pciefe, CIEnumFORMATETC) &&
          IS_VALID_READ_PTR(pciefe->lpVtbl, sizeof(*(pciefe->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciefe, IUnknown) &&
          IS_VALID_METHOD(pciefe, Next) &&
          IS_VALID_METHOD(pciefe, Skip) &&
          IS_VALID_METHOD(pciefe, Reset) &&
          IS_VALID_METHOD(pciefe, Clone));
}


BOOL IsValidPCIEnumSTATDATA(PCIEnumSTATDATA pciesd)
{
   return(IS_VALID_READ_PTR(pciesd, CIDataObject) &&
          IS_VALID_READ_PTR(pciesd->lpVtbl, sizeof(*(pciesd->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciesd, IUnknown) &&
          IS_VALID_METHOD(pciesd, Next) &&
          IS_VALID_METHOD(pciesd, Skip) &&
          IS_VALID_METHOD(pciesd, Reset) &&
          IS_VALID_METHOD(pciesd, Clone));
}


BOOL IsValidPCIMalloc(PCIMalloc pcimalloc)
{
   return(IS_VALID_READ_PTR(pcimalloc, CIMalloc) &&
          IS_VALID_READ_PTR(pcimalloc->lpVtbl, sizeof(*(pcimalloc->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcimalloc, IUnknown) &&
          IS_VALID_METHOD(pcimalloc, Alloc) &&
          IS_VALID_METHOD(pcimalloc, Realloc) &&
          IS_VALID_METHOD(pcimalloc, Free) &&
          IS_VALID_METHOD(pcimalloc, GetSize) &&
          IS_VALID_METHOD(pcimalloc, DidAlloc) &&
          IS_VALID_METHOD(pcimalloc, HeapMinimize));
}


BOOL IsValidPCIMoniker(PCIMoniker pcimk)
{
   return(IS_VALID_READ_PTR(pcimk, CIMoniker) &&
          IS_VALID_READ_PTR(pcimk->lpVtbl, sizeof(*(pcimk->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersistStream)pcimk, IPersistStream) &&
          IS_VALID_METHOD(pcimk, BindToObject) &&
          IS_VALID_METHOD(pcimk, BindToStorage) &&
          IS_VALID_METHOD(pcimk, Reduce) &&
          IS_VALID_METHOD(pcimk, ComposeWith) &&
          IS_VALID_METHOD(pcimk, Enum) &&
          IS_VALID_METHOD(pcimk, IsEqual) &&
          IS_VALID_METHOD(pcimk, Hash) &&
          IS_VALID_METHOD(pcimk, IsRunning) &&
          IS_VALID_METHOD(pcimk, GetTimeOfLastChange) &&
          IS_VALID_METHOD(pcimk, Inverse) &&
          IS_VALID_METHOD(pcimk, CommonPrefixWith) &&
          IS_VALID_METHOD(pcimk, RelativePathTo) &&
          IS_VALID_METHOD(pcimk, GetDisplayName) &&
          IS_VALID_METHOD(pcimk, ParseDisplayName) &&
          IS_VALID_METHOD(pcimk, IsSystemMoniker));
}


BOOL IsValidPCIPersist(PCIPersist pcip)
{
   return(IS_VALID_READ_PTR(pcip, CIUnknown) &&
          IS_VALID_READ_PTR(pcip->lpVtbl, sizeof(*(pcip->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcip, IUnknown) &&
          IS_VALID_METHOD(pcip, GetClassID));
}


BOOL IsValidPCIPersistFile(PCIPersistFile pcipfile)
{
   return(IS_VALID_READ_PTR(pcipfile, CIPersistFile) &&
          IS_VALID_READ_PTR(pcipfile->lpVtbl, sizeof(*(pcipfile->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersist)pcipfile, IPersist) &&
          IS_VALID_METHOD(pcipfile, IsDirty) &&
          IS_VALID_METHOD(pcipfile, Load) &&
          IS_VALID_METHOD(pcipfile, Save) &&
          IS_VALID_METHOD(pcipfile, SaveCompleted) &&
          IS_VALID_METHOD(pcipfile, GetCurFile));
}


BOOL IsValidPCIPersistStorage(PCIPersistStorage pcipstg)
{
   return(IS_VALID_READ_PTR(pcipstg, CIPersistStorage) &&
          IS_VALID_READ_PTR(pcipstg->lpVtbl, sizeof(*(pcipstg->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersist)pcipstg, IPersist) &&
          IS_VALID_METHOD(pcipstg, IsDirty) &&
          IS_VALID_METHOD(pcipstg, InitNew) &&
          IS_VALID_METHOD(pcipstg, Load) &&
          IS_VALID_METHOD(pcipstg, Save) &&
          IS_VALID_METHOD(pcipstg, SaveCompleted) &&
          IS_VALID_METHOD(pcipstg, HandsOffStorage));
}


BOOL IsValidPCIPersistStream(PCIPersistStream pcipstr)
{
   return(IS_VALID_READ_PTR(pcipstr, CIPersistStream) &&
          IS_VALID_READ_PTR(pcipstr->lpVtbl, sizeof(*(pcipstr->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersist)pcipstr, IPersist) &&
          IS_VALID_METHOD(pcipstr, IsDirty) &&
          IS_VALID_METHOD(pcipstr, Load) &&
          IS_VALID_METHOD(pcipstr, Save) &&
          IS_VALID_METHOD(pcipstr, GetSizeMax));
}


BOOL IsValidPCIStorage(PCIStorage pcistg)
{
   return(IS_VALID_READ_PTR(pcistg, CIStorage) &&
          IS_VALID_READ_PTR(pcistg->lpVtbl, sizeof(*(pcistg->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcistg, IUnknown) &&
          IS_VALID_METHOD(pcistg, CreateStream) &&
          IS_VALID_METHOD(pcistg, OpenStream) &&
          IS_VALID_METHOD(pcistg, CreateStorage) &&
          IS_VALID_METHOD(pcistg, OpenStorage) &&
          IS_VALID_METHOD(pcistg, CopyTo) &&
          IS_VALID_METHOD(pcistg, MoveElementTo) &&
          IS_VALID_METHOD(pcistg, Commit) &&
          IS_VALID_METHOD(pcistg, Revert) &&
          IS_VALID_METHOD(pcistg, EnumElements) &&
          IS_VALID_METHOD(pcistg, DestroyElement) &&
          IS_VALID_METHOD(pcistg, RenameElement) &&
          IS_VALID_METHOD(pcistg, SetElementTimes) &&
          IS_VALID_METHOD(pcistg, SetClass) &&
          IS_VALID_METHOD(pcistg, SetStateBits) &&
          IS_VALID_METHOD(pcistg, Stat));
}


BOOL IsValidPCIStream(PCIStream pcistr)
{
   return(IS_VALID_READ_PTR(pcistr, CIStorage) &&
          IS_VALID_READ_PTR(pcistr->lpVtbl, sizeof(*(pcistr->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcistr, IUnknown) &&
          IS_VALID_METHOD(pcistr, Read) &&
          IS_VALID_METHOD(pcistr, Write) &&
          IS_VALID_METHOD(pcistr, Seek) &&
          IS_VALID_METHOD(pcistr, SetSize) &&
          IS_VALID_METHOD(pcistr, CopyTo) &&
          IS_VALID_METHOD(pcistr, Commit) &&
          IS_VALID_METHOD(pcistr, Revert) &&
          IS_VALID_METHOD(pcistr, LockRegion) &&
          IS_VALID_METHOD(pcistr, UnlockRegion) &&
          IS_VALID_METHOD(pcistr, Stat) &&
          IS_VALID_METHOD(pcistr, Clone));
}


BOOL IsValidPCIUnknown(PCIUnknown pciunk)
{
   return(IS_VALID_READ_PTR(pciunk, CIUnknown) &&
          IS_VALID_READ_PTR(pciunk->lpVtbl, sizeof(*(pciunk->lpVtbl))) &&
          IS_VALID_METHOD(pciunk, QueryInterface) &&
          IS_VALID_METHOD(pciunk, AddRef) &&
          IS_VALID_METHOD(pciunk, Release));
}


#ifdef __INTSHCUT_H__

BOOL IsValidPCIUniformResourceLocator(
                                             PCIUniformResourceLocator pciurl)
{
   return(IS_VALID_READ_PTR(pciurl, CIUniformResourceLocator) &&
          IS_VALID_READ_PTR(pciurl->lpVtbl, sizeof(*(pciurl->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciurl, IUnknown) &&
          IS_VALID_METHOD(pciurl, SetURL) &&
          IS_VALID_METHOD(pciurl, GetURL) &&
          IS_VALID_METHOD(pciurl, InvokeCommand));
}

#endif   /* __INTSHCUT_H__ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\procutil.cpp ===
#include "precomp.h"
#include <oprahcom.h>
#include <regentry.h>
#include "mperror.h"
#include <sehcall.h>
#define LEGACY_DIVISOR	8

extern "C" WORD _cdecl is_cyrix(void);
extern "C" DWORD _cdecl get_nxcpu_type(void);


#ifndef _M_IX86
DWORD WINAPI CallWithSEH(EXCEPTPROC pfn, void *pv, INEXCEPTION InException)
{
	// we don't have a native version of SEH for the alpha,
	// use __try and __except
	pfn(pv);
    return 0;
}
#endif



#ifdef _M_IX86

DWORD NMINTERNAL FindTSC (LPVOID pvRefData)
{
	   _asm
	   {
		   mov     eax,1
		   _emit   00Fh     ;; CPUID
		   _emit   0A2h

    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family
		   mov     ecx,pvRefData
		   mov     [ecx],edx
		   mov	   [ecx][4],eax
	   }

	   return 1;
}

DWORD NMINTERNAL NoCPUID (LPEXCEPTION_RECORD per,PCONTEXT pctx)
{
    return 0;
}
//
//  GetProcessorSpeed(dwFamily)
//
//  get the processor speed in MHz, only works on Pentium or better
//  machines.
//
//  Will put 3, or 4 in dwFamily for 386/486, but no speed.
//  returns speed and family for 586+
//
//  - thanks to toddla, modified by mikeg
//

int NMINTERNAL GetProcessorSpeed(int *pdwFamily)
{
    SYSTEM_INFO si;
    __int64	start, end, freq;
    int 	flags,family;
    int 	time;
    int 	clocks;
    DWORD	oldclass;
    HANDLE      hprocess;
    int     pRef[2];

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel) {
	*pdwFamily=si.wProcessorLevel;
    }else {
    	//Ok, we're on Win95
    	switch (si.dwProcessorType) {
    	       case PROCESSOR_INTEL_386:
    		   *pdwFamily=3;
    		   break;

    	       case PROCESSOR_INTEL_486:
    		   *pdwFamily=4;
    		   break;
    	       default:
    		   *pdwFamily=0;
    		   break;
    	}
    		
    }

    //
    // make sure this is a INTEL Pentium (or clone) or higher.
    //
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return 0;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return 0;

    //
    // see if this chip supports rdtsc before using it.
    //
    if (!CallWithSEH (FindTSC, pRef, NoCPUID))     {
        flags=0;
    } else {
    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family. Pull them out and use them
        flags=pRef[0];
        family=pRef[1];
    }

    if (!(flags & 0x10))
        return 0;


    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*pdwFamily)) {
       *pdwFamily=(family& 0x0F00) >> 8;
    }


    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass(hprocess);
    SetPriorityClass(hprocess, REALTIME_PRIORITY_CLASS);
    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    _asm
    {
        _emit   0Fh     ;; RDTSC
        _emit   31h
        mov     ecx,100000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        _emit   0Fh     ;; RDTSC
        _emit   31h
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);
    SetPriorityClass(hprocess, oldclass);

    time = MulDiv((int)(end-start),1000000,(int)freq);

    return (clocks + time/2) / time;
}



HRESULT NMINTERNAL GetNormalizedCPUSpeed (int *pdwNormalizedSpeed, int *dwFamily)
{
   int dwProcessorSpeed;

   dwProcessorSpeed=GetProcessorSpeed (dwFamily);

   *pdwNormalizedSpeed=dwProcessorSpeed;

   if (*dwFamily > 5) {
       //Ok, TWO things.
       // ONE DO NOT DO FP!
       // Two for the same Mhz assume a 686 is 1.3 times as fast as a 586 and a 786 is 1.6 times, etc.
       *pdwNormalizedSpeed=(ULONG) (((10+3*(*dwFamily-5))*dwProcessorSpeed)/10);
   }

   if (*dwFamily < 5) {
	  //bugbug until we have 386/486 timing code, assume
	  //486=50,386=37
      if (*dwFamily > 3) {
           //Cyrix, (5x86)? check before making default assignment
           if (is_cyrix()) {
               if (*pdwNormalizedSpeed==0) {
                   *dwFamily=5;
                   *pdwNormalizedSpeed=100;
                   return hrSuccess;
               }
           }
      }

	  *pdwNormalizedSpeed= (*dwFamily*100)/LEGACY_DIVISOR;

      if (get_nxcpu_type ()) {
        //Double the perceived value on a NexGen
        *pdwNormalizedSpeed *=2;
      }


   }



   return hrSuccess;
}
#endif //_M_IX86





BOOL WINAPI IsFloatingPointEmulated(void)
{
	long lRegValue;
	SYSTEM_INFO si;
	OSVERSIONINFO osi;
	BOOL fEmulation, bNT;
	

	// are we a Pentium
	ZeroMemory(&si, sizeof(si));
	GetSystemInfo(&si);
	if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) 
	{
		return FALSE;
	}

	// Which OS: NT or 95 ?
	ZeroMemory(&osi, sizeof(osi));
	osi.dwOSVersionInfoSize = sizeof(osi);
	GetVersionEx(&osi);
	bNT = (osi.dwPlatformId == VER_PLATFORM_WIN32_NT);

	// Windows NT
	if (bNT)
	{
		RegEntry re(TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
		            HKEY_LOCAL_MACHINE, FALSE);

		// try to get a definitive answer from the registry
		lRegValue = re.GetNumber(TEXT("ForceNpxEmulation"), -1);

		// registry: 0: no 
		//           1: conditional (not definitive!)
		//           2: yes

		if (lRegValue == 2)
		{
			return TRUE;
		}

		// we could load "IsProcessorFeaturePresent from kernel32.dll,
		// but the version that shipped with NT 4 has a bug in it that
		// returns the exact opposite of what it should be.  It was
		// fixed in NT 5. Since this API isn't the same across platforms,
		// we won't use it.

		return FALSE;
	}

	// Windows 95 - to be added later
	return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\oprahcom.cpp ===
#include "precomp.h"
#include <RegEntry.h>
#include <ConfReg.h>
#include <oprahcom.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

BOOL NMINTERNAL CanShellExecHttp()
{
	RegEntry re(CLASSES_HTTP_KEY, HKEY_LOCAL_MACHINE, FALSE);
	return (re.GetError() == ERROR_SUCCESS);
}

BOOL NMINTERNAL CanShellExecMailto()
{
	RegEntry re(CLASSES_MAILTO_KEY, HKEY_LOCAL_MACHINE, FALSE);
	return (re.GetError() == ERROR_SUCCESS);
}



/*  G E T  I N S T A L L  D I R E C T O R Y */
/*----------------------------------------------------------------------------
    %%Function: GetInstallDirectory
 
	Return TRUE if the installation directory was read from the registry.
	The string is set empty if the function fails and returns FALSE.
	The buffer pointed to by psz is assumed to be at least MAX_PATH characters.
	Note that the name is always terminated with a final backslash.
----------------------------------------------------------------------------*/
BOOL NMINTERNAL GetInstallDirectory(LPTSTR psz)
{
	RegEntry reInstall(CONFERENCING_KEY, HKEY_LOCAL_MACHINE);

	ASSERT(NULL != psz);
	lstrcpyn(psz, reInstall.GetString(REGVAL_INSTALL_DIR), MAX_PATH);
	if (_T('\0') == *psz)
		return FALSE; // No registry entry was found

	// Make sure the directory name has a trailing '\'
	// BUGBUG - Don't call CharNext twice in each iteration
	for ( ; _T('\0') != *psz; psz = CharNext(psz))
	{
		if ((_T('\\') == *psz) && (_T('\0') == *CharNext(psz)) )
		{
			// The path already ends with a backslash
			return TRUE;
		}
	}

	// Append a trailing backslash
	// BUGBUG - Can't we just append the char in place with an assignment?
	lstrcat(psz, _TEXT("\\"));
	return TRUE;
}



/*  F  F I L E  E X I S T S */
/*-------------------------------------------------------------------------
	%%Function: FFileExists

	Return TRUE if the file exists and can be read & written.
-------------------------------------------------------------------------*/
BOOL NMINTERNAL FFileExists(LPCTSTR szFile)
{
	HANDLE hFile;

	if ((NULL == szFile) || (_T('\0') == *szFile))
		return FALSE;

	UINT uErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
	hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	SetErrorMode(uErrorMode); // Restore error mode

	if (hFile == INVALID_HANDLE_VALUE)
		return FALSE;

	CloseHandle(hFile);
	return TRUE;
}


/*  F  D I R  E X I S T S  */
/*-------------------------------------------------------------------------
    %%Function: FDirExists

    Return TRUE if the directory exists.
-------------------------------------------------------------------------*/
BOOL NMINTERNAL FDirExists(LPCTSTR szDir)
{
	UINT uErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
	DWORD dwFa = GetFileAttributes(szDir);
	SetErrorMode(uErrorMode); // Restore error mode

	if (0xFFFFFFFF == dwFa)
		return FALSE;

	return (0 != (dwFa & FILE_ATTRIBUTE_DIRECTORY));
}


/*  F  E N S U R E  D I R  E X I S T S */
/*-------------------------------------------------------------------------
	%%Function: FEnsureDirExists

	Ensure the Directory exists, creating the entire path if necessary.
	Returns FALSE if there was a problem.
-------------------------------------------------------------------------*/
BOOL NMINTERNAL FEnsureDirExists(LPCTSTR szDir)
{
	TCHAR   szPath[MAX_PATH+1];
	TCHAR * pszDirEnd;
	TCHAR * pszDirT;

	ASSERT(lstrlen(szDir) < MAX_PATH);

	if (FDirExists(szDir))
		return TRUE;  // Nothing to do - already exists

	// Work with a copy of the path
	lstrcpy(szPath, szDir);

	for(pszDirT = szPath, pszDirEnd = &szPath[lstrlen(szPath)];
		pszDirT <= pszDirEnd;
		pszDirT = CharNext(pszDirT))
	{
		if ((*pszDirT == _T('\\')) || (pszDirT == pszDirEnd))
		{
			*pszDirT = _T('\0');
			if (!FDirExists(szPath))
			{
				UINT uErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
				BOOL fOk = CreateDirectory(szPath, NULL);
				SetErrorMode(uErrorMode); // Restore error mode
				if (!fOk)
					return FALSE;
			}
			*pszDirT = _T('\\');
		}
	}

	TRACE_OUT(("Created Directory [%s]", szDir));
	return TRUE;
}



/*  E X T R A C T  F I L E  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: ExtractFileName, ExtractFileNameA

	Extracts the file name from a path name.
	Returns a pointer to file name in path string.
-------------------------------------------------------------------------*/
LPCTSTR NMINTERNAL ExtractFileName(LPCTSTR pcszPathName)
{
	LPCTSTR pcszLastComponent;
	LPCTSTR pcsz;

	ASSERT(IS_VALID_STRING_PTR(pcszPathName, CSTR));

	for (pcszLastComponent = pcsz = pcszPathName;
		*pcsz;
		pcsz = CharNext(pcsz))
	{
		if (IS_SLASH(*pcsz) || *pcsz == COLON)
			pcszLastComponent = CharNext(pcsz);
	}

	ASSERT(IsValidPath(pcszLastComponent));

	return(pcszLastComponent);
}

#if defined(UNICODE)
LPCSTR NMINTERNAL ExtractFileNameA(LPCSTR pcszPathName)
{
	LPCSTR pcszLastComponent;
	LPCSTR pcsz;

	ASSERT(IS_VALID_STRING_PTR_A(pcszPathName, CSTR));

	for (pcszLastComponent = pcsz = pcszPathName;
		*pcsz;
		pcsz = CharNextA(pcsz))
	{
		if (IS_SLASH(*pcsz) || *pcsz == COLON)
			pcszLastComponent = CharNextA(pcsz);
	}

	ASSERT(IsValidPathA(pcszLastComponent));

	return(pcszLastComponent);
}
#endif // defined(UNICODE)

/*  S A N I T I Z E  F I L E  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: SanitizeFileName

-------------------------------------------------------------------------*/
BOOL NMINTERNAL SanitizeFileName(LPTSTR psz)
{
	if (NULL == psz)
		return FALSE;

	while (*psz)
	{
		switch (*psz)
			{
		case _T('\\'):
		case _T('\"'):
		case _T('/'):
		case _T(':'):
		case _T('*'):
		case _T('?'):
		case _T('<'):
		case _T('>'):
		case _T('|'):
			*psz = _T('_');
		default:
			break;
			}

		psz = ::CharNext(psz);
	}

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////

/*  C R E A T E  N E W  F I L E */
/*----------------------------------------------------------------------------
    %%Function: CreateNewFile

	Attempt to create a new file.
	Note this returns either 0 (success)
	or the result from GetLastError (usually ERROR_FILE_EXISTS)
----------------------------------------------------------------------------*/
DWORD CreateNewFile(LPTSTR pszFile)
{
	DWORD  errRet;
	HANDLE hFile;

	if (lstrlen(pszFile) >= MAX_PATH)
	{
		// don't allow long path/filenames
		return 1;
	}

	SetLastError(0);

	UINT uErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
	hFile = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE, 0,
		NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
	SetErrorMode(uErrorMode); // Restore error mode

	errRet = GetLastError();

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
	}

	return errRet;
}



/*  F  C R E A T E  N E W  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: FCreateNewFile

    Create a new file in a directory, with a name and extension.
   	Returns the full path name in the buffer.
-------------------------------------------------------------------------*/
BOOL FCreateNewFile(LPCTSTR pcszPath, LPCTSTR pcszName, LPCTSTR pcszExt, LPTSTR pszResult, int cchMax)
{
	TCHAR szFile[MAX_PATH*2];

	lstrcpyn(szFile, pcszPath, ARRAYSIZE(szFile));
	if (!FEnsureDirName(szFile))
		return FALSE;
	
	LPTSTR psz = szFile + lstrlen(szFile);
	lstrcpyn(psz, pcszName, (int)(ARRAYSIZE(szFile) - (psz - szFile)));
	SanitizeFileName(psz);

	if(lstrlen(psz) + lstrlen(pcszExt) < (ARRAYSIZE(szFile) - 1))
	{
	    lstrcat(psz, pcszExt);
	}
	else
	{
	    return FALSE;
	}

	DWORD dwErr = CreateNewFile(szFile);
	if (0 != dwErr)
	{
		// Create a duplicate filename
		psz += lstrlen(pcszName);
		for (int iFile = 2; iFile < 999; iFile++)
		{
			wsprintf(psz, TEXT(" (%d).%s"), iFile, pcszExt);
			if (ERROR_FILE_EXISTS != (dwErr = CreateNewFile(szFile)) )
				break;
		}

		if (0 != dwErr)
		{
			WARNING_OUT(("Unable to create duplicate filename (err=%d)", dwErr));
			return FALSE;
		}
	}

	if (cchMax > lstrlen(szFile))
	{
		lstrcpy(pszResult, szFile);
	}
	else
	{
		// try and make the full name fit within the buffer
		dwErr = GetShortPathName(szFile, pszResult, cchMax);
		if ((0 == dwErr) || (dwErr >= MAX_PATH))
			return FALSE;
	}

	return TRUE;
}


/*  F  E N S U R E  D I R  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FEnsureDirName
    
-------------------------------------------------------------------------*/
BOOL FEnsureDirName(LPTSTR pszPath)
{
	if (NULL == pszPath)
		return FALSE;

	LPTSTR pszCurr = pszPath;

	// Make sure the directory name has a trailing '\'
	for ( ; ; )
	{
		LPTSTR pszNext = CharNext(pszCurr);
		if (*pszNext == _T('\0'))
		{
			if (_T('\\') != *pszCurr)
			{
				*pszNext++ = _T('\\');
				*pszNext = _T('\0');
			}
			break;
		}
		pszCurr = pszNext;
	}

	return FEnsureDirExists(pszPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\ping.cpp ===
#include "precomp.h"
#include "ping.h"
#include "avutil.h"	// for RtStrToInt


const CHAR  g_cszPingData[] = "NetMeetingPing";
const int   PING_BUFFERSIZE = 1024;
const DWORD PING_TIMEOUT    = 4000; // 4 seconds
const DWORD PING_RETRIES    = 4;
const TCHAR g_cszICMPDLLName[] = _TEXT("icmp.dll");

//
// CPing::Ping()
//
// Return value:
//   E_FAIL:   Function failed
//   S_FALSE:  Function succeeded, ping failed
//   S_OK:     Function succeeded, ping succeeded
//

HRESULT CPing::Ping(DWORD dwAddr, DWORD dwTimeout, DWORD dwRetries)
{
	DebugEntry(CPing::Ping);
	HRESULT hr = E_FAIL;

	if (0 != dwAddr)
	{
		if (NULL == m_hICMPDLL)
		{
			m_hICMPDLL = NmLoadLibrary(g_cszICMPDLLName,TRUE);
		}
		if (NULL != m_hICMPDLL)
		{
			m_pfnCreateFile = (PFNIcmpCreateFile)
								::GetProcAddress(m_hICMPDLL, "IcmpCreateFile");
			m_pfnCloseHandle = (PFNIcmpCloseHandle)
								::GetProcAddress(m_hICMPDLL, "IcmpCloseHandle");
			m_pfnSendEcho = (PFNIcmpSendEcho)
								::GetProcAddress(m_hICMPDLL, "IcmpSendEcho");
			if ((NULL != m_pfnCreateFile) &&
				(NULL != m_pfnCloseHandle) &&
				(NULL != m_pfnSendEcho))
			{
				HANDLE hPing = m_pfnCreateFile();
				if (NULL != hPing)
				{
					BYTE buffer[PING_BUFFERSIZE];
					for (DWORD dwTry = 0; dwTry < dwRetries; dwTry++)
					{
						DWORD dwStatus = m_pfnSendEcho(	hPing,
														dwAddr,
														(LPVOID) g_cszPingData,
														(WORD) CCHMAX(g_cszPingData),
														NULL,
														buffer,
														sizeof(buffer),
														dwTimeout);
						if (0 != dwStatus)
						{
							if (((PICMP_ECHO_REPLY)buffer)->Status == IP_SUCCESS)
							{
								TRACE_OUT(("ping: %d.%d.%d.%d succeeded",
											((LPBYTE)&dwAddr)[0],
											((LPBYTE)&dwAddr)[1],
											((LPBYTE)&dwAddr)[2],
											((LPBYTE)&dwAddr)[3]));
								hr = S_OK;    // function succeeded - ping succeeded
							}
							else
							{
								TRACE_OUT(("ping: %d.%d.%d.%d failed",
											((LPBYTE)&dwAddr)[0],
											((LPBYTE)&dwAddr)[1],
											((LPBYTE)&dwAddr)[2],
											((LPBYTE)&dwAddr)[3]));
								hr = S_FALSE; // function succeeded - ping failed
							}
							break;
						}
						else
						{
							TRACE_OUT(("ping: %d.%d.%d.%d did not respond",
										((LPBYTE)&dwAddr)[0],
										((LPBYTE)&dwAddr)[1],
										((LPBYTE)&dwAddr)[2],
										((LPBYTE)&dwAddr)[3]));
						}
					}
					m_pfnCloseHandle(hPing);
				}
				else
				{
					ERROR_OUT(("IcmpCreateFile() failed"));
				}
			}
			else
			{
				ERROR_OUT(("Could not find icmp.dll entry points"));
			}
		}
		else
		{
			ERROR_OUT(("Could not load icmp.dll"));
		}
	}

	DebugExitHRESULT(CPing::Ping, hr);
	return hr;
}



BOOL CPing::IsAutodialEnabled ( VOID )
{
	// Figure out the os platform if not done so
	//
	if (m_dwPlatformId == PLATFORM_UNKNOWN)
	{
		OSVERSIONINFO osvi;
		ZeroMemory (&osvi, sizeof (osvi));
		osvi.dwOSVersionInfoSize = sizeof (osvi);
		if (GetVersionEx (&osvi))
		{
			m_dwPlatformId = osvi.dwPlatformId;
		}
		else
		{
			return FALSE;
		}
	}

	// Check autodial enabling for either platform
	//
	BOOL fEnabled;
	switch (m_dwPlatformId)
	{
	case VER_PLATFORM_WIN32_WINDOWS: // 1, Windows 95
		fEnabled = IsWin95AutodialEnabled ();
		break;
	case VER_PLATFORM_WIN32_NT: // 2, Windows NT
		fEnabled = IsWinNTAutodialEnabled ();
		break;
	case VER_PLATFORM_WIN32s: // 0, Windows 3.1
	default: // unknown
		ASSERT (FALSE);
		fEnabled = FALSE;
		break;
	}

	return fEnabled;
}


#define c_szWin95AutodialRegFolder		TEXT ("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define c_szWin95AutodialRegKey			TEXT ("EnableAutodial")

BOOL CPing::IsWin95AutodialEnabled ( VOID )
{
	// Always check the registry
	//
	BOOL fEnabled = FALSE;

	// Need to check the registry setting.
	// In case of error, report no autodial.
	//
	HKEY hKey;
	if (RegOpenKeyEx (	HKEY_CURRENT_USER,
						c_szWin95AutodialRegFolder,
						0,
						KEY_READ,
						&hKey) == NOERROR)
	{
		TCHAR szValue[16];
		ZeroMemory (&szValue[0], sizeof (DWORD));

		ULONG cb = sizeof (szValue);
		DWORD dwType;
		if (RegQueryValueEx (hKey, c_szWin95AutodialRegKey, NULL,
							&dwType, (BYTE *) &szValue[0], &cb)
			== NOERROR)
		{
			switch (dwType)
			{
			case REG_DWORD:
			case REG_BINARY:
				fEnabled = (BOOL) *(LONG *) &szValue[0];
				break;
#if 0 // do not need to worry about this case, IE must maintain backward compatibility
			case REG_SZ:
				fEnabled = (BOOL) RtStrToInt (&szValue[0]);
				break;
#endif // 0
			default:
				ASSERT (FALSE);
				break;
			}
		}

		RegCloseKey (hKey);
	}

	return fEnabled;
}


// RAS only runs on NT 4.0 or later, as a result, WINVER must be 0x401 or larger
//
#if (WINVER < 0x401)
#undef WINVER
#define WINVER 0x401
#endif

#include <ras.h>

// DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );	// defined in <ras.h>
// DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );	// defined in <ras.h>
typedef DWORD (APIENTRY *PFN_RasGetAutodialParam) ( DWORD, LPVOID, LPDWORD );
#define c_szRasGetAutodialParam		"RasGetAutodialParamW"
#define c_szRasApi32Dll				TEXT ("rasapi32.dll")


BOOL CPing::IsWinNTAutodialEnabled ( VOID )
{
	// Decide if we want to check autodial registry setting
	//
	BOOL fEnabled = FALSE;
	if (m_fWinNTAutodialEnabled == AUTODIAL_UNKNOWN)
	{
		// We do not want to have initialization error
		//
		UINT uErrMode = SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

		// Load the library rasapi32.dll from the system directory
		//
		HINSTANCE hRasApi32Dll = NmLoadLibrary (c_szRasApi32Dll,TRUE);
		if (hRasApi32Dll != NULL)
		{
			// Get the proc address for RasGetAutodialParam()
			//
			PFN_RasGetAutodialParam pfn = (PFN_RasGetAutodialParam)
						GetProcAddress (hRasApi32Dll, c_szRasGetAutodialParam);
			if (pfn != NULL)
			{
				// Query RAS if it disables autodial
				//
				DWORD dwVal, dwSize = sizeof (DWORD);
				DWORD dwErr = (*pfn) (RASADP_LoginSessionDisable, &dwVal, &dwSize);
				if (dwErr == 0)
				{
					// Set the autodial flag only when everything succeeds
					//
					fEnabled = (dwVal == 0);
				}
			}

			FreeLibrary (hRasApi32Dll);
		}

		// Restore error mode
		//
		SetErrorMode (uErrMode);

		m_fWinNTAutodialEnabled = fEnabled;
	}
	else
	{
		// Do not need to check the registry setting.
		// Simply use the cached one.
		//
		fEnabled = m_fWinNTAutodialEnabled;
	}

	return fEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <tchar.h>
#include <limits.h>
#include <shlobj.h>
#include <wincrypt.h>

#include "memtrack.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "stock.h"
#include "olestock.h"

#ifdef DEBUG

#include "inifile.h"
#include "resstr.h"

#endif /* DEBUG */

#include "confdbg.h"
#include "debspew.h"
#include "valid.h"
#include "olevalid.h"
#include <dllutil.h>



#ifdef __cplusplus
}
#endif /* __cplusplus */


#endif /* _PRECOMP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\referenc.cpp ===
#include "precomp.h"
#include "referenc.h"

REFCOUNT::REFCOUNT() :
	NumRefs(0),
	bMarkedForDelete(FALSE),
	bOnStack(FALSE)
{
}

REFCOUNT::~REFCOUNT()
{
	// Objects being destroyed should have no
	// outstanding references to them and should
	// have been explicitly deleted.

	ASSERT(NumRefs == 0);
	ASSERT(bOnStack || bMarkedForDelete);
}

DWORD REFCOUNT::AddRef()
{
	NumRefs++;
	return(NumRefs);
}

DWORD REFCOUNT::Release()
{
	ASSERT(NumRefs);

    DWORD   CurrentNumRefs = --NumRefs; // Save because object may be deleted

	if(!CurrentNumRefs) {
		if(bMarkedForDelete) {
            if (!bOnStack) {
			    delete this;
            }
		}
	}
    return CurrentNumRefs;
}

DWORD REFCOUNT::Delete()
{
    DWORD   CurrentNumRefs = NumRefs; // Save because object may be deleted
	REFERENCE	r(this);

	bMarkedForDelete = TRUE;
    return(CurrentNumRefs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\purecall.cpp ===
#include "precomp.h"

// Handle errors referencing an object's virtual function table.
// This should never happen!

int _cdecl _purecall(void)
{
	ASSERT(FALSE);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\regentry.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1995-1996			**/
/*****************************************************************/

/*
	regentry.cpp
	registry access classes

	This file contains classes which enable
    convenient access the registry for entries.

	FILE HISTORY:
		lens	10/15/95	Created
		ChrisPi	6/21/96		Added GetBinary(), SetValue() for binary
*/

#include "precomp.h"
#include <regentry.h>
#include <strutil.h>

RegEntry::RegEntry(LPCTSTR pszSubKey, HKEY hkey, BOOL fCreate, REGSAM samDesired)
 : m_pbValueBuffer(NULL),
   m_cbValueBuffer(0),
   m_fValuesWritten(FALSE),
   m_szNULL('\0')
{
	// Open with desired access if it is specified explicitly; otherwise, use
	// the default access.
	if (samDesired) {
		if (fCreate) {
			DWORD dwDisposition;

			m_error = ::RegCreateKeyEx(hkey, 
									pszSubKey, 
									0, 
									NULL, 
									REG_OPTION_NON_VOLATILE,
									samDesired, 
									NULL, 
									&m_hkey, 
									&dwDisposition);
		}
		else {
			m_error = ::RegOpenKeyEx(hkey, pszSubKey, 0, samDesired, &m_hkey);
		}
	}
	else {
		if (fCreate) {
			m_error = ::RegCreateKey(hkey, pszSubKey, &m_hkey);
		}
		else {
			m_error = ::RegOpenKey(hkey, pszSubKey, &m_hkey);
		}
	}

	m_fhkeyValid = (m_error == ERROR_SUCCESS);
}


RegEntry::~RegEntry()
{
	ChangeKey(NULL);
	delete [] m_pbValueBuffer;
}


VOID RegEntry::ChangeKey(HKEY hNewKey)
{
	// hNewKey assumed to be valid or never used
	// (as in destructor).

	if (m_fValuesWritten) {
		FlushKey();		
	}
    if (m_fhkeyValid) {
        ::RegCloseKey(m_hkey); 
    }
	m_hkey = hNewKey;	
}

VOID RegEntry::UpdateWrittenStatus()
{
	if (m_error == ERROR_SUCCESS) {
		m_fValuesWritten = TRUE;
	}
}

long RegEntry::SetValue(LPCTSTR pszValue, LPCTSTR string)
{
    if (m_fhkeyValid) {
    	m_error = ::RegSetValueEx(m_hkey, pszValue, 0, REG_SZ,
    				(LPBYTE)string, (lstrlen(string)+1) * sizeof(*string));
		UpdateWrittenStatus();
    }
	return m_error;
}

long RegEntry::SetValue(LPCTSTR pszValue, unsigned long dwNumber)
{
    if (m_fhkeyValid) {
    	m_error = ::RegSetValueEx(m_hkey, pszValue, 0, REG_BINARY,
    				(LPBYTE)&dwNumber, sizeof(dwNumber));
		UpdateWrittenStatus();
    }
	return m_error;
}

long RegEntry::SetValue(LPCTSTR pszValue,
						void* pData,
						DWORD cbLength)
{
    if (m_fhkeyValid) {
    	m_error = ::RegSetValueEx(	m_hkey,
								pszValue,
								0,
								REG_BINARY,
    							(LPBYTE) pData,
								cbLength);
		UpdateWrittenStatus();
    }
	return m_error;
}

long RegEntry::DeleteValue(LPCTSTR pszValue)
{
    if (m_fhkeyValid) {
    	m_error = ::RegDeleteValue(m_hkey, pszValue);
		UpdateWrittenStatus();
	}
	return m_error;
}

long RegEntry::GetNumber(LPCTSTR pszValue, long dwDefault)
{
 	DWORD 	dwType = REG_BINARY;
 	long	dwNumber = 0L;
 	DWORD	dwSize = sizeof(dwNumber);

    if (m_fhkeyValid) {
    	m_error = ::RegQueryValueEx(m_hkey, pszValue, 0, &dwType, (LPBYTE)&dwNumber,
    				&dwSize);
	}
	
	// If the call succeeded, make sure that the returned data matches our
	// expectations.
	ASSERT(m_error != ERROR_SUCCESS || 
			(REG_BINARY == dwType && sizeof(dwNumber) == dwSize) ||
			REG_DWORD == dwType);

	if (m_error != ERROR_SUCCESS)
		dwNumber = dwDefault;
	
	return dwNumber;
}


// The GetNumberIniStyle method performs the same function as GetNumber,
// but in a style compatible with the old GetPrivateProfileInt API.
// Specfically it means:
// - If the value is stored in the registry as a string, it attempts to
//   convert it to an integer.
// - If the value is negative, it returns 0.

ULONG RegEntry::GetNumberIniStyle(LPCTSTR pszValueName, ULONG dwDefault)
{
	DWORD 	dwType = REG_BINARY;
 	ULONG	dwNumber = 0L;
    DWORD   cbLength = m_cbValueBuffer;

    if (m_fhkeyValid) {
    	m_error = ::RegQueryValueEx(m_hkey, 
								pszValueName, 
								0, 
								&dwType, 
								m_pbValueBuffer,
								&cbLength);

		// Try again with a larger buffer if the first one is too small,
		// or if there wasn't already a buffer allocated.
		if ((ERROR_SUCCESS == m_error && NULL == m_pbValueBuffer)
			|| ERROR_MORE_DATA == m_error) {
			
			ASSERT(cbLength > m_cbValueBuffer);

			ResizeValueBuffer(cbLength);

        	m_error = RegQueryValueEx( m_hkey,
									  pszValueName,
									  0,
									  &dwType,
									  m_pbValueBuffer,
									  &cbLength );
		}

		if (ERROR_SUCCESS == m_error) {
			switch(dwType) {
				case REG_DWORD:
				case REG_BINARY:
					ASSERT(sizeof(dwNumber) == cbLength);

					dwNumber = * (LPDWORD) m_pbValueBuffer;
					break;

				case REG_SZ:
				{
					LONG lNumber = RtStrToInt((LPCTSTR) m_pbValueBuffer);

					// Convert negative numbers to zero, to match 
					// GetPrivateProfileInt's behavior.
					dwNumber = lNumber < 0 ? 0 : lNumber;
				}

					break;

				default:
					ERROR_OUT(("Invalid value type (%lu) returned by RegQueryValueEx()",
								dwType));
					break;
			}
		}
	}

	if (m_error != ERROR_SUCCESS) {
		dwNumber = dwDefault;
	}
	
	return dwNumber;
}


LPTSTR RegEntry::GetString(LPCTSTR pszValueName)
{
	DWORD 	dwType = REG_SZ;
    DWORD   length = m_cbValueBuffer;

    if (m_fhkeyValid) {
        m_error = ::RegQueryValueEx( m_hkey,
                                  pszValueName,
                                  0,
                                  &dwType,
                                  m_pbValueBuffer,
                                  &length );
		// Try again with a larger buffer if the first one is too small,
		// or if there wasn't already a buffer allocated.
		if ((ERROR_SUCCESS == m_error && NULL == m_pbValueBuffer)
			|| ERROR_MORE_DATA == m_error) {
			
			ASSERT(length > m_cbValueBuffer);

			ResizeValueBuffer(length);

        	m_error = ::RegQueryValueEx( m_hkey,
									  pszValueName,
									  0,
									  &dwType,
									  m_pbValueBuffer,
									  &length );
		}
		if (m_error == ERROR_SUCCESS) {
			if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) {
				m_error = ERROR_INVALID_PARAMETER;
			}
		}
	}
    if ((m_error != ERROR_SUCCESS) || (length == 0)) {
		return &m_szNULL;
    }
	return (LPTSTR) m_pbValueBuffer;
}

DWORD RegEntry::GetBinary(	LPCTSTR pszValueName,
							void** ppvData)
{
	ASSERT(ppvData);
	DWORD 	dwType = REG_BINARY;
    DWORD   length = m_cbValueBuffer;

    if (m_fhkeyValid) {
        m_error = ::RegQueryValueEx( m_hkey,
                                  pszValueName,
                                  0,
                                  &dwType,
                                  m_pbValueBuffer,
                                  &length );
		// Try again with a larger buffer if the first one is too small,
		// or if there wasn't already a buffer allocated.
		if ((ERROR_SUCCESS == m_error && NULL == m_pbValueBuffer)
			|| ERROR_MORE_DATA == m_error) {
			
			ASSERT(length > m_cbValueBuffer);

			ResizeValueBuffer(length);

        	m_error = ::RegQueryValueEx( m_hkey,
									  pszValueName,
									  0,
									  &dwType,
									  m_pbValueBuffer,
									  &length );
		}
		if (m_error == ERROR_SUCCESS) {
			if (dwType != REG_BINARY) {
				m_error = ERROR_INVALID_PARAMETER;
			}
		}
	}
    if ((m_error != ERROR_SUCCESS) || (length == 0)) {
		*ppvData = NULL;
		length = 0;
    }
	else
	{
		*ppvData = m_pbValueBuffer;
	}
	return length;
}

// BUGBUG - Use LocalReAlloc instead of new/delete?
VOID RegEntry::ResizeValueBuffer(DWORD length)
{
	LPBYTE pbNewBuffer;

    if ((m_error == ERROR_SUCCESS || m_error == ERROR_MORE_DATA)
		&& (length > m_cbValueBuffer)) {
        pbNewBuffer = new BYTE[length];
        if (pbNewBuffer) {
			delete [] m_pbValueBuffer;
			m_pbValueBuffer = pbNewBuffer;
			m_cbValueBuffer = length;
		}
		else {
            m_error = ERROR_NOT_ENOUGH_MEMORY;
        }
	}
}

// BUGBUG - Support other OpenKey switches from constructor
VOID RegEntry::MoveToSubKey(LPCTSTR pszSubKeyName)
{
    HKEY	_hNewKey;

    if (m_fhkeyValid) {
        m_error = ::RegOpenKey ( m_hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (m_error == ERROR_SUCCESS) {
			ChangeKey(_hNewKey);
        }
    }
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : m_pRegEntry(pReqRegEntry),
   m_iEnum(0),
   m_pchName(NULL),
   m_pbValue(NULL)
{
    m_error = m_pRegEntry->GetError();
    if (m_error == ERROR_SUCCESS) {
        m_error = ::RegQueryInfoKey (m_pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &m_cEntries,         // Number of value entries
                                   &m_cMaxValueName,    // Longest value name
                                   &m_cMaxData,         // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (m_error == ERROR_SUCCESS) {
        if (m_cEntries != 0) {
            m_cMaxValueName++;	// REG_SZ needs one more for null
            m_cMaxData++;		// REG_SZ needs one more for null
            m_pchName = new TCHAR[m_cMaxValueName];
            if (!m_pchName) {
                m_error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (m_cMaxData) {
                    m_pbValue = new BYTE[m_cMaxData];
                    if (!m_pbValue) {
                        m_error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete m_pchName;
    delete m_pbValue;
}

long RegEnumValues::Next()
{
    if (m_error != ERROR_SUCCESS) {
        return m_error;
    }
    if (m_cEntries == m_iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = m_cMaxValueName;

    m_dwDataLength = m_cMaxData;
    m_error = ::RegEnumValue ( m_pRegEntry->GetKey(), // Key
                            m_iEnum,               // Index of value
                            m_pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &m_dwType,             // Data type
                            m_pbValue,             // Address of buffer for value data
                            &m_dwDataLength );     // Address for size of data
    m_iEnum++;
    return m_error;
}

RegEnumSubKeys::RegEnumSubKeys(RegEntry *pReqRegEntry)
 : m_pRegEntry(pReqRegEntry),
   m_iEnum(0),
   m_pchName(NULL)
{
    m_error = m_pRegEntry->GetError();
    if (m_error == ERROR_SUCCESS) {
        m_error = ::RegQueryInfoKey ( m_pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   &m_cEntries,           // Number of subkeys
                                   &m_cMaxKeyName,        // Longest subkey name
                                   NULL,                // Longest class string
                                   NULL,                // Number of value entries
                                   NULL,                // Longest value name
                                   NULL,                // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (m_error == ERROR_SUCCESS) {
        if (m_cEntries != 0) {
            m_cMaxKeyName = m_cMaxKeyName + 1; // needs one more for null
            m_pchName = new TCHAR[m_cMaxKeyName];
            if (!m_pchName) {
                m_error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
}

RegEnumSubKeys::~RegEnumSubKeys()
{
    delete m_pchName;
}

long RegEnumSubKeys::Next()
{
    if (m_error != ERROR_SUCCESS) {
        return m_error;
    }
    if (m_cEntries == m_iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = m_cMaxKeyName;

    m_error = ::RegEnumKey ( m_pRegEntry->GetKey(), // Key
                          m_iEnum,               // Index of value
                          m_pchName,             // Address of buffer for subkey name
                          cchName);            // Size of buffer
    m_iEnum++;
    return m_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\resstr.cpp ===
/*
 * resstr.c - Return code to string translation routines.
 *
 * Taken from URL code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "uls2.h"

/* Macros
 *********/

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = #val; break


/****************************** Public Functions *****************************/


#ifdef DEBUG

PCSTR GetINTString(int n)
{
   static char s_rgchINT[] = "-2147483646";

   wsprintfA(s_rgchINT, "%d", n);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchINT, CSTR));

   return(s_rgchINT);
}


PCSTR GetINT_PTRString(INT_PTR n)
{
   static char s_rgchINT[] = "-2147483646xxxxxxxxxx";

   wsprintfA(s_rgchINT, "%Id", n);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchINT, CSTR));

   return(s_rgchINT);
}


PCSTR GetULONGString(ULONG ul)
{
   static char s_rgchULONG[] = "4294967295";

   wsprintfA(s_rgchULONG, "%lx", ul);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchULONG, CSTR));

   return(s_rgchULONG);
}


PCSTR GetBOOLString(BOOL bResult)
{
   PCSTR pcsz;

   pcsz = bResult ? "TRUE" : "FALSE";

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}


PCSTR GetPVOIDString(PVOID ptr)
{
   static char s_rgchPVOID[] = "0xffff0000ffff0000";

   wsprintfA(s_rgchPVOID, "0x%p", ptr);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchPVOID, CSTR));

   return(s_rgchPVOID);
}

PCSTR GetClipboardFormatNameString(UINT ucf)
{
   PCSTR pcsz;
   static char s_szCFName[MAX_PATH];

   switch (ucf)
   {
      STRING_CASE(CF_TEXT);
      STRING_CASE(CF_BITMAP);
      STRING_CASE(CF_METAFILEPICT);
      STRING_CASE(CF_SYLK);
      STRING_CASE(CF_DIF);
      STRING_CASE(CF_TIFF);
      STRING_CASE(CF_OEMTEXT);
      STRING_CASE(CF_DIB);
      STRING_CASE(CF_PALETTE);
      STRING_CASE(CF_PENDATA);
      STRING_CASE(CF_RIFF);
      STRING_CASE(CF_WAVE);
      STRING_CASE(CF_UNICODETEXT);
      STRING_CASE(CF_ENHMETAFILE);
      STRING_CASE(CF_HDROP);
      STRING_CASE(CF_LOCALE);
      STRING_CASE(CF_MAX);
      STRING_CASE(CF_OWNERDISPLAY);
      STRING_CASE(CF_DSPTEXT);
      STRING_CASE(CF_DSPBITMAP);
      STRING_CASE(CF_DSPMETAFILEPICT);
      STRING_CASE(CF_DSPENHMETAFILE);

      default:
         if (! GetClipboardFormatNameA(ucf, s_szCFName, sizeof(s_szCFName)))
            lstrcpyA(s_szCFName, "UNKNOWN CLIPBOARD FORMAT");
         pcsz = s_szCFName;
         break;
   }

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}


PCSTR GetCOMPARISONRESULTString(COMPARISONRESULT cr)
{
   PCSTR pcsz;

   switch (cr)
   {
      STRING_CASE(CR_FIRST_SMALLER);
      STRING_CASE(CR_FIRST_LARGER);
      STRING_CASE(CR_EQUAL);

      default:
         ERROR_OUT(("GetCOMPARISONRESULTString() called on unknown COMPARISONRESULT %d.",
                    cr));
         pcsz = "UNKNOWN COMPARISONRESULT";
         break;
   }

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}

PCSTR GetHRESULTString(HRESULT hr)
{
   PCSTR pcsz;
   static char s_rgchHRESULT[] = "0x12345678";

   switch (hr)
   {
      STRING_CASE(S_OK);
      STRING_CASE(S_FALSE);

      STRING_CASE(DRAGDROP_S_CANCEL);
      STRING_CASE(DRAGDROP_S_DROP);
      STRING_CASE(DRAGDROP_S_USEDEFAULTCURSORS);

      STRING_CASE(E_UNEXPECTED);
      STRING_CASE(E_NOTIMPL);
      STRING_CASE(E_OUTOFMEMORY);
      STRING_CASE(E_INVALIDARG);
      STRING_CASE(E_NOINTERFACE);
      STRING_CASE(E_POINTER);
      STRING_CASE(E_HANDLE);
      STRING_CASE(E_ABORT);
      STRING_CASE(E_FAIL);
      STRING_CASE(E_ACCESSDENIED);

      STRING_CASE(CLASS_E_NOAGGREGATION);

      STRING_CASE(CO_E_NOTINITIALIZED);
      STRING_CASE(CO_E_ALREADYINITIALIZED);
      STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

      STRING_CASE(DV_E_DVASPECT);
      STRING_CASE(DV_E_LINDEX);
      STRING_CASE(DV_E_TYMED);
      STRING_CASE(DV_E_FORMATETC);

#ifdef __INTSHCUT_H__

      STRING_CASE(E_FLAGS);

      STRING_CASE(URL_E_INVALID_SYNTAX);
      STRING_CASE(URL_E_UNREGISTERED_PROTOCOL);

      STRING_CASE(IS_E_EXEC_FAILED);

      STRING_CASE(E_FILE_NOT_FOUND);
      STRING_CASE(E_PATH_NOT_FOUND);

#endif

		//  ULS error codes
		//
		STRING_CASE(ILS_E_SERVER_SERVICE);
		STRING_CASE(ILS_E_SERVER_NAME);
		STRING_CASE(ILS_E_TIMEOUT);
		STRING_CASE(ILS_E_BIND);
		STRING_CASE(ILS_E_THREAD);
		STRING_CASE(ILS_E_SERVER_EXEC);
		STRING_CASE(ILS_E_WINSOCK);
		STRING_CASE(ILS_E_NO_MORE);
		STRING_CASE(ILS_E_NOT_INITIALIZED);
		STRING_CASE(ILS_E_NOTIFY_ID);
		STRING_CASE(ILS_E_NO_SUCH_OBJECT);
		STRING_CASE(ILS_E_NEED_RELOGON);
		STRING_CASE(ILS_E_NAME_CONFLICTS);

		//  LDAP specific error codes
		//
		STRING_CASE(ILS_E_LDAP_OPERATIONS_ERROR);
		STRING_CASE(ILS_E_LDAP_PROTOCOL_ERROR);
		STRING_CASE(ILS_E_LDAP_TIMELIMIT_EXCEEDED);
		STRING_CASE(ILS_E_LDAP_SIZELIMIT_EXCEEDED);
		STRING_CASE(ILS_E_LDAP_COMPARE_FALSE);
		STRING_CASE(ILS_E_LDAP_COMPARE_TRUE);
		STRING_CASE(ILS_E_LDAP_AUTH_METHOD_NOT_SUPPORTED);
		STRING_CASE(ILS_E_LDAP_STRONG_AUTH_REQUIRED);
		STRING_CASE(ILS_E_LDAP_REFERRAL_V2);
		STRING_CASE(ILS_E_LDAP_PARTIAL_RESULTS);
		STRING_CASE(ILS_E_LDAP_REFERRAL);
		STRING_CASE(ILS_E_LDAP_ADMIN_LIMIT_EXCEEDED);
		STRING_CASE(ILS_E_LDAP_UNAVAILABLE_CRIT_EXTENSION);
		STRING_CASE(ILS_E_LDAP_NO_SUCH_ATTRIBUTE);
		STRING_CASE(ILS_E_LDAP_UNDEFINED_TYPE);
		STRING_CASE(ILS_E_LDAP_INAPPROPRIATE_MATCHING);
		STRING_CASE(ILS_E_LDAP_CONSTRAINT_VIOLATION);
		STRING_CASE(ILS_E_LDAP_ATTRIBUTE_OR_VALUE_EXISTS);
		STRING_CASE(ILS_E_LDAP_INVALID_SYNTAX);
		STRING_CASE(ILS_E_LDAP_ALIAS_PROBLEM);
		STRING_CASE(ILS_E_LDAP_INVALID_DN_SYNTAX);
		STRING_CASE(ILS_E_LDAP_IS_LEAF);
		STRING_CASE(ILS_E_LDAP_ALIAS_DEREF_PROBLEM);
		STRING_CASE(ILS_E_LDAP_INAPPROPRIATE_AUTH);
		STRING_CASE(ILS_E_LDAP_INVALID_CREDENTIALS);
		STRING_CASE(ILS_E_LDAP_INSUFFICIENT_RIGHTS);
		STRING_CASE(ILS_E_LDAP_BUSY);
		STRING_CASE(ILS_E_LDAP_UNAVAILABLE);
		STRING_CASE(ILS_E_LDAP_UNWILLING_TO_PERFORM);
		STRING_CASE(ILS_E_LDAP_LOOP_DETECT);
		STRING_CASE(ILS_E_LDAP_NAMING_VIOLATION);
		STRING_CASE(ILS_E_LDAP_OBJECT_CLASS_VIOLATION);
		STRING_CASE(ILS_E_LDAP_NOT_ALLOWED_ON_NONLEAF);
		STRING_CASE(ILS_E_LDAP_NOT_ALLOWED_ON_RDN);
		STRING_CASE(ILS_E_LDAP_NO_OBJECT_CLASS_MODS);
		STRING_CASE(ILS_E_LDAP_RESULTS_TOO_LARGE);
		STRING_CASE(ILS_E_LDAP_AFFECTS_MULTIPLE_DSAS);
		STRING_CASE(ILS_E_LDAP_OTHER);
		STRING_CASE(ILS_E_LDAP_SERVER_DOWN);
		STRING_CASE(ILS_E_LDAP_LOCAL_ERROR);
		STRING_CASE(ILS_E_LDAP_ENCODING_ERROR);
		STRING_CASE(ILS_E_LDAP_DECODING_ERROR);
		STRING_CASE(ILS_E_LDAP_TIMEOUT);
		STRING_CASE(ILS_E_LDAP_AUTH_UNKNOWN);
		STRING_CASE(ILS_E_LDAP_FILTER_ERROR);
		STRING_CASE(ILS_E_LDAP_USER_CANCELLED);
		STRING_CASE(ILS_E_LDAP_NO_MEMORY);

      default:
         wsprintfA(s_rgchHRESULT, "%#lx", hr);
         pcsz = s_rgchHRESULT;
         break;
   }

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\toolbar.cpp ===
// File: Toolbar.cpp

#include "precomp.h"

#include "GenContainers.h"
#include "GenControls.h"

#include <windowsx.h>

// Minimum size for children;
// BUGBUG georgep; Should probably set this to 0 after debugging
const static int MinSize = 10;

// Default m_gap
const static int HGapSize = 4;
// Default m_hMargin
const static int HMargin = 0;
// Default m_vMargin
const static int VMargin = 0;

// Init m_uRightIndex and m_uCenterIndex to very large numbers
CToolbar::CToolbar() :
	m_gap(HGapSize),
	m_hMargin(HMargin),
	m_vMargin(VMargin),
	m_nAlignment(TopLeft),
	m_uRightIndex(static_cast<UINT>(-1)),
	m_bHasCenterChild(FALSE),
	m_bReverseOrder(FALSE),
	m_bMinDesiredSize(FALSE),
	m_bVertical(FALSE)
{
}

BOOL CToolbar::Create(
	HWND hWndParent,	// The parent of the toolbar window
	DWORD dwExStyle		// The extended style of the toolbar window
	)
{
	return(CGenWindow::Create(
		hWndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMToolbar"),	// Window name
		WS_CLIPCHILDREN,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		dwExStyle|WS_EX_CONTROLPARENT		// Extended window style
		));
}

// Get the desired size for a child, and make sure it is big enough
static void GetWindowDesiredSize(HWND hwnd, SIZE *ppt)
{
	ppt->cx = ppt->cy = 0;

	IGenWindow *pWnd = CGenWindow::FromHandle(hwnd);
	if (NULL != pWnd)
	{
		pWnd->GetDesiredSize(ppt);
	}

	ppt->cx = max(ppt->cx, MinSize);
	ppt->cy = max(ppt->cy, MinSize);
}

BOOL IsChildVisible(HWND hwndChild)
{
	return((GetWindowLong(hwndChild, GWL_STYLE)&WS_VISIBLE) == WS_VISIBLE);
}

/** Get the total desired size of the child windows: max of heights and sum of
 * widths or vice versa for vertical windows.
 * @param hwndParent The window whose children are to be examined
 * @param size The returned total size
 * @param bVertical Whether to flow vertical or horizontal
 * @returns The number of visible child windows
 */
static int GetChildTotals(HWND hwndParent, SIZE *size, BOOL bVertical)
{
	int nChildren = 0;
	int xMax=0, xTot=0;
	int yMax=0, yTot=0;

	for (HWND hwndChild=::GetWindow(hwndParent, GW_CHILD); NULL!=hwndChild;
		hwndChild=::GetWindow(hwndChild, GW_HWNDNEXT))
	{
		if (!IsChildVisible(hwndChild))
		{
			continue;
		}
		++nChildren;

		SIZE pt;
		GetWindowDesiredSize(hwndChild, &pt);

		xTot += pt.cx;
		yTot += pt.cy;
		if (xMax < pt.cx) xMax = pt.cx;
		if (yMax < pt.cy) yMax = pt.cy;
	}

	if (bVertical)
	{
		size->cx = xMax;
		size->cy = yTot;
	}
	else
	{
		size->cx = xTot;
		size->cy = yMax;
	}

	return(nChildren);
}

// Returns the total children desired size, plus the gaps and margins.
void CToolbar::GetDesiredSize(SIZE *ppt)
{
	int nChildren = GetChildTotals(GetWindow(), ppt, m_bVertical);

	if (nChildren > 1 && !m_bMinDesiredSize)
	{
		if (m_bVertical)
		{
			ppt->cy += (nChildren-1) * m_gap;
		}
		else
		{
			ppt->cx += (nChildren-1) * m_gap;
		}
	}

	ppt->cx += m_hMargin * 2;
	ppt->cy += m_vMargin * 2;

	SIZE sizeTemp;
	CGenWindow::GetDesiredSize(&sizeTemp);
	ppt->cx += sizeTemp.cx;
	ppt->cy += sizeTemp.cy;
}

void CToolbar::AdjustPos(POINT *pPos, SIZE *pSize, UINT width)
{
	pPos->x = pPos->y = 0;

	switch (m_nAlignment)
	{
	default:
	case TopLeft:
		// Nothing to do
		break;

	case Center:
		if (m_bVertical)
		{
			pPos->x = (width - pSize->cx)/2;
		}
		else
		{
			pPos->y = (width - pSize->cy)/2;
		}
		break;

	case BottomRight:
		if (m_bVertical)
		{
			pPos->x = (width - pSize->cx);
		}
		else
		{
			pPos->y = (width - pSize->cy);
		}
		break;

	case Fill:
		if (m_bVertical)
		{
			pSize->cx = width;
		}
		else
		{
			pSize->cy = width;
		}
		break;
	}
}

// Get the first child to layout
HWND CToolbar::GetFirstKid()
{
	HWND ret = ::GetWindow(GetWindow(), GW_CHILD);
	if (m_bReverseOrder && NULL != ret)
	{
		ret = ::GetWindow(ret, GW_HWNDLAST);
	}

	return(ret);
}

// Get the next child to layout
HWND CToolbar::GetNextKid(HWND hwndCurrent)
{
	return(::GetWindow(hwndCurrent, m_bReverseOrder ? GW_HWNDPREV : GW_HWNDNEXT));
}

extern HDWP SetWindowPosI(HDWP hdwp, HWND hwndChild, int left, int top, int width, int height);

// Flow child windows according to the fields
void CToolbar::Layout()
{
	RECT rc;
	GetClientRect(GetWindow(), &rc);

	// First see how much extra space we have
	SIZE sizeTotal;
	int nChildren = GetChildTotals(GetWindow(), &sizeTotal, m_bVertical);
	if (0 == nChildren)
	{
		// No children, so nothing to layout
		return;
	}

	// Add on the margins
	sizeTotal.cx += 2*m_hMargin;
	sizeTotal.cy += 2*m_vMargin;

	if (nChildren > 1 || !m_bHasCenterChild)
	{
		// Don't layout with children overlapping
		rc.right  = max(rc.right , sizeTotal.cx);
		rc.bottom = max(rc.bottom, sizeTotal.cy);
	}

	// Calculate the total gaps between children
	int tGap = m_bVertical ? rc.bottom - sizeTotal.cy : rc.right - sizeTotal.cx;
	int maxGap = (nChildren-1)*m_gap;
	if (tGap > maxGap) tGap = maxGap;
	tGap = max(tGap, 0); // This can happen if only a center child

	// If we fill, then children in a vertical toolbar go from the left to the
	// right margin, and similar for a horizontal toolbar
	int fill = m_bVertical ? rc.right-2*m_hMargin : rc.bottom-2*m_vMargin;

	// Speed up layout by deferring it
	HDWP hdwp = BeginDeferWindowPos(nChildren);

	HWND hwndChild;
	UINT nChild = 0;

	// Iterate through the children
	UINT uCenterIndex = m_bHasCenterChild ? m_uRightIndex-1 : static_cast<UINT>(-1);
	// We need to keep track of whether the middle was skipped in case the
	// center control or the first right-aligned control is hidden
	BOOL bMiddleSkipped = FALSE;

	// Do left/top-aligned children
	// The starting point for laying out children
	int left = m_hMargin;
	int top  = m_vMargin;

	for (hwndChild=GetFirstKid(); NULL!=hwndChild;
		hwndChild=GetNextKid(hwndChild), ++nChild)
	{
		if (!IsChildVisible(hwndChild))
		{
			continue;
		}

		SIZE size;
		GetWindowDesiredSize(hwndChild, &size);

		if (nChild == uCenterIndex)
		{
			// Take the window size, subtract all the gaps, and subtract the
			// desired size of everybody but this control. That should give
			// the "extra" area in the middle
			if (m_bVertical)
			{
				size.cy = rc.bottom - tGap - (sizeTotal.cy - size.cy);
			}
			else
			{
				size.cx = rc.right  - tGap - (sizeTotal.cx - size.cx);
			}

			bMiddleSkipped = TRUE;
		}
		else if (nChild >= m_uRightIndex && !bMiddleSkipped)
		{
			// Skip the "extra" room in the middle; if there is a centered
			// control, then we have already done this
			if (m_bVertical)
			{
				top += rc.bottom - tGap - sizeTotal.cy;
			}
			else
			{
				left += rc.right - tGap - sizeTotal.cx;
			}

			bMiddleSkipped = TRUE;
		}

		POINT pos;
		AdjustPos(&pos, &size, fill);

		// Move the window
		hdwp = SetWindowPosI(hdwp, hwndChild, pos.x+left, pos.y+top, size.cx, size.cy);

		// calculate the gap; don't just use a "fixed" gap, since children
		// would move in chunks
		int gap = (nChildren<=1) ? 0 : ((tGap * (nChild+1))/(nChildren-1) - (tGap * nChild)/(nChildren-1));

		// Update the pos of the next child
		if (m_bVertical)
		{
			top += gap + size.cy;
		}
		else
		{
			left += gap + size.cx;
		}
	}

	// Actually move all the windows now
	EndDeferWindowPos(hdwp);
}

LRESULT CToolbar::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

void CToolbar::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	FORWARD_WM_COMMAND(GetParent(hwnd), id, hwndCtl, codeNotify, SendMessage);
}

static HWND FindControl(HWND hwndParent, int nID)
{
	if (GetWindowLong(hwndParent, GWL_ID) == nID)
	{
		return(hwndParent);
	}

	for (hwndParent=GetWindow(hwndParent, GW_CHILD); NULL!=hwndParent;
		hwndParent=GetWindow(hwndParent, GW_HWNDNEXT))
	{
		HWND ret = FindControl(hwndParent, nID);
		if (NULL != ret)
		{
			return(ret);
		}
	}

	return(NULL);
}

IGenWindow *CToolbar::FindControl(int nID)
{
	HWND hwndRet = ::FindControl(GetWindow(), nID);
	if (NULL == hwndRet)
	{
		return(NULL);
	}

	return(FromHandle(hwndRet));
}

CSeparator::CSeparator() :
	m_iStyle(Normal)
{
	m_desSize.cx = m_desSize.cy = 2;
}

BOOL CSeparator::Create(
	HWND hwndParent, UINT iStyle
	)
{
	m_iStyle = iStyle;
	return(CGenWindow::Create(
		hwndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMSeparator"),	// Window name
		WS_CLIPCHILDREN,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
	));
}

void CSeparator::GetDesiredSize(SIZE *ppt)
{
	*ppt = m_desSize;

	// Make sure there's room for the child
	HWND child = GetFirstChild(GetWindow());
	if (NULL == child)
	{
		// Nothing to do
		return;
	}
	IGenWindow *pChild = FromHandle(child);
	if (NULL == pChild)
	{
		// Don't know what to do
		return;
	}

	SIZE size;
	pChild->GetDesiredSize(&size);

	ppt->cx = max(ppt->cx, size.cx);
	ppt->cy = max(ppt->cy, size.cy);
}

void CSeparator::SetDesiredSize(SIZE *psize)
{
	m_desSize = *psize;
	OnDesiredSizeChanged();
}

void CSeparator::Layout()
{
	HWND hwnd = GetWindow();

	HWND child = GetFirstChild(hwnd);
	if (NULL == child)
	{
		// Nothing to do
		return;
	}
	IGenWindow *pChild = FromHandle(child);
	if (NULL == pChild)
	{
		// Don't know what to do
		return;
	}

	// Center the child horizontally and vertically
	SIZE size;
	pChild->GetDesiredSize(&size);

	RECT rcClient;
	GetClientRect(hwnd, &rcClient);

	rcClient.left += (rcClient.right-rcClient.left-size.cx)/2;
	rcClient.top  += (rcClient.bottom-rcClient.top-size.cy)/2;

	SetWindowPos(child, NULL, rcClient.left, rcClient.top, size.cx, size.cy,
		SWP_NOZORDER|SWP_NOACTIVATE);
}

void CSeparator::OnPaint(HWND hwnd)
{
	PAINTSTRUCT ps;
	HDC hdc = BeginPaint(hwnd, &ps);

	RECT rc;
	GetClientRect(hwnd, &rc);

	int nFlags = BF_LEFT;
	if (rc.right < rc.bottom)
	{
		// this is a vertical separator
		// center the drawing
		rc.left  += (rc.right-rc.left)/2 - 1;
		rc.right = 4;
	}
	else
	{
		// this is a horizontal separator
		nFlags = BF_TOP;
		// center the drawing
		rc.top    += (rc.bottom-rc.top)/2 - 1;
		rc.bottom = 4;
	}

	if (Normal == m_iStyle)
	{
		DrawEdge(hdc, &rc, EDGE_ETCHED, nFlags);
	}

	EndPaint(hwnd, &ps);
}

LRESULT CSeparator::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

BOOL CLayeredView::Create(
	HWND hwndParent,	// The parent of this window
	DWORD dwExStyle		// The extended style
	)
{
	return(CGenWindow::Create(
        hwndParent,
        0,
        TEXT("NMLayeredView"),
        WS_CLIPCHILDREN,
        dwExStyle));
}

void CLayeredView::GetDesiredSize(SIZE *psize)
{
	CGenWindow::GetDesiredSize(psize);

	HWND child = GetFirstChild(GetWindow());
	if (NULL == child)
	{
		return;
	}

	SIZE sizeContent;

	IGenWindow *pChild;
	pChild = FromHandle(child);
	if (NULL != pChild)
	{
		// Make sure we can always handle the first window
		pChild->GetDesiredSize(&sizeContent);
	}

	for (child=::GetWindow(child, GW_HWNDNEXT); NULL!=child;
		child=::GetWindow(child, GW_HWNDNEXT))
	{
		if (IsChildVisible(child))
		{
			pChild = FromHandle(child);
			if (NULL != pChild)
			{
				SIZE sizeTemp;
				pChild->GetDesiredSize(&sizeTemp);

				sizeContent.cx = max(sizeContent.cx, sizeTemp.cx);
				sizeContent.cy = max(sizeContent.cy, sizeTemp.cy);

				break;
			}
		}
	}

	psize->cx += sizeContent.cx;
	psize->cy += sizeContent.cy;
}

void CLayeredView::Layout()
{
	HWND hwndThis = GetWindow();

	RECT rcClient;
	GetClientRect(hwndThis, &rcClient);

	// Just move all the children
	for (HWND child=GetFirstChild(hwndThis); NULL!=child;
		child=::GetWindow(child, GW_HWNDNEXT))
	{
		switch (m_lStyle)
		{
		case Center:
		{
			IGenWindow *pChild = FromHandle(child);
			if (NULL != pChild)
			{
				SIZE size;
				pChild->GetDesiredSize(&size);
				SetWindowPos(child, NULL,
					(rcClient.left+rcClient.right-size.cx)/2,
					(rcClient.top+rcClient.bottom-size.cy)/2,
					size.cx, size.cy, SWP_NOZORDER|SWP_NOACTIVATE);
				break;
			}
		}

		// Fall through
		case Fill:
		default:
			SetWindowPos(child, NULL,
				rcClient.left, rcClient.top,
				rcClient.right-rcClient.left,
				rcClient.bottom-rcClient.top,
				SWP_NOZORDER|SWP_NOACTIVATE);
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\strtohex.cpp ===
// STRTOHEX.CPP
//
// Utility functions to convert string representations of hexadecimal numbers
// into the numbers themselves.
//
// Note:  These functions are in their own file, rather than in STRUTIL.CPP, 
// because they use a const array.  The current implementation of the linker
// pulls this array into binaries if they use any function in the source file,
// not just the functions which reference this array.

#include "precomp.h"
#include <strutil.h>


// This array maps ASCII chars in the range '0' - 'f' to their hex equivalent.
// INVALID_CHAR_ID is used to mark slots that don't correspond to a valid
// hex char.
const BYTE INVALID_CHAR_ID = (BYTE) -1;

const BYTE rgbHexCharMap[] =
{	
	// ASCII 0x30 - 0x3f
	0, 1, 2, 3, 
	4, 5, 6, 7, 
	8, 9, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	// ASCII 0x40 - 0x4f
	INVALID_CHAR_ID, 0xA, 0xB, 0xC, 
	0xD, 0xE, 0xF, INVALID_CHAR_ID, 
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	// ASCII 0x50 - 0x5f
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	// ASCII 0x60 - 0x67
	INVALID_CHAR_ID, 0xa, 0xb, 0xc, 
	0xd, 0xe, 0xf, INVALID_CHAR_ID
};

const int cbHexCharMap = ARRAY_ELEMENTS(rgbHexCharMap);


//
// HexStringToQWordA()
//
// Converts a hex ANSI string (without 0x or 0X prefix) to a ULARGE_INTEGER
//
// NOTE: The a-f characters can be lowercase or uppercase
//
// Returns TRUE if successful (the string contained all valid characters)
// Returns FALSE otherwise
//

BOOL NMINTERNAL HexStringToQWordA(LPCSTR pcszString, ULARGE_INTEGER* pqw)
{
	BOOL bRet;
	ASSERT(pcszString);
	ASSERT(pqw);
	pqw->QuadPart = 0ui64;
	int cchStr = lstrlenA(pcszString);
	if (cchStr <= CCH_HEX_QWORD)
	{
		bRet = TRUE;
		PDWORD pdwCur = (cchStr < CCH_HEX_DWORD) ? &(pqw->LowPart) : &(pqw->HighPart);
		for (int i = 0; i < cchStr; i++)
		{
			// NOTE: DBCS characters are not allowed
			ASSERT(! IsDBCSLeadByte(pcszString[i]));

			if (CCH_HEX_DWORD == (cchStr - i))
			{
				pdwCur = &(pqw->LowPart);
			}
			DWORD dwDigit = (DWORD) INVALID_CHAR_ID;
			int iDigit = pcszString[i] - '0';

			if (iDigit >= 0 && iDigit < cbHexCharMap)
			{
				dwDigit = (DWORD) rgbHexCharMap[iDigit];
			}

			if (INVALID_CHAR_ID != dwDigit)
			{
				*pdwCur = ((*pdwCur) << BITS_PER_HEX_CHAR) + dwDigit;
			}
			else
			{
				bRet = FALSE;
				break;
			}
		}
	}
	else
	{
		bRet = FALSE;
	}
	return bRet;
}


/*  D W  F R O M  H E X  */
/*-------------------------------------------------------------------------
    %%Function: DwFromHex

    Return the DWORD from the hex string.
-------------------------------------------------------------------------*/
DWORD DwFromHex(LPCTSTR pchHex)
{
	TCHAR ch;
	DWORD dw = 0;

	while (_T('\0') != (ch = *pchHex++))
	{

		DWORD dwDigit = (DWORD) INVALID_CHAR_ID;
		int iDigit = ch - _T('0');

		if (iDigit >= 0 && iDigit < cbHexCharMap)
		{
			dwDigit = (DWORD) rgbHexCharMap[iDigit];
		}

		if (INVALID_CHAR_ID != dwDigit)
		{
			dw = (dw << 4) + dwDigit;
		}
		else
			break;
	}

	return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\utf8str.cpp ===
#include "precomp.h"
#include "utf8str.h"

CUTF8String::~CUTF8String()
{
	if (ALLOC_UNICODE & m_eAlloc)
	{
		delete m_pwszUnicode;
	}
	else if (ALLOC_UTF8 & m_eAlloc)
	{
		delete m_pszUTF8;
	}
}

CUTF8String::operator LPWSTR()
{ 
	if ((NULL == m_pwszUnicode) && (NULL != m_pszUTF8))
	{
		DecodeUTF8();
	}
	return m_pwszUnicode;
}

CUTF8String::operator LPSTR()
{ 
	if ((NULL == m_pszUTF8) && (NULL != m_pwszUnicode))
	{
		EncodeUTF8();
	}
	return m_pszUTF8;
}

VOID CUTF8String::EncodeUTF8()
{
	DebugEntry(CUTF8String::EncodeUTF8);
	m_hr = S_OK;
	ASSERT(NULL != m_pwszUnicode);
	int cchUTF8 = 1; // always include a NULL terminator

	// First make a pass to see how many characters we will be converting.
	LPWSTR pwsz = m_pwszUnicode;
	while (L'\0' != *pwsz)
	{
		WCHAR wch = *pwsz++;
		if (wch < 0x80)
		{
			cchUTF8 += 1;
		}
		else if (wch < 0x800)
		{
			cchUTF8 += 2;
		}
		else
		{
			cchUTF8 += 3;
		}
	}

	ASSERT(NULL == m_pszUTF8);
	m_pszUTF8 = new CHAR[cchUTF8];
	if (NULL != m_pszUTF8)
	{
		ASSERT(ALLOC_NONE == m_eAlloc);
		m_eAlloc = ALLOC_UTF8;
		// Start encoding here:
		const BYTE cUtf8FirstSignal[4] = {0x00, 0x00, 0xC0, 0xE0};
		const BYTE cMask   = 0xBF;
		const BYTE cSignal = 0x80;
		LPSTR pszStop = m_pszUTF8 + cchUTF8;
		LPSTR pszDst = m_pszUTF8;
		pwsz = m_pwszUnicode;
		while (pszDst < pszStop)
		{
			WCHAR wch = *pwsz++;
#ifdef DEBUG
			if (L'\0' == wch)
			{
				ASSERT(pszDst == pszStop - 1);
			}
#endif // DEBUG
			int cchTotal;
			if (wch < 0x80)
			{
				cchTotal = 1;
			}
			else if (wch < 0x800)
			{
				cchTotal = 2;
			}
			else
			{
				cchTotal = 3;
			}

			pszDst += cchTotal;
			switch (cchTotal)
			{
				case 3:
					*--pszDst = (wch | cSignal) & cMask;
					wch >>= 6;
					// FALL THROUGH
				case 2:
					*--pszDst = (wch | cSignal) & cMask;
					wch >>= 6;
					// FALL THROUGH
				case 1:
					*--pszDst = (wch | cUtf8FirstSignal[cchTotal]);
			}
			pszDst += cchTotal;
		}
		m_hr = S_OK;
	}
	else
	{
		m_hr = E_OUTOFMEMORY;
	}
	DebugExitVOID(CUTF8String::EncodeUTF8);
}

VOID CUTF8String::DecodeUTF8()
{
	DebugEntry(CUTF8String::DecodeUTF8);
	m_hr = S_OK;
	ASSERT(NULL != m_pszUTF8);
	int cchUnicode = 1; // always include a NULL terminator

	LPSTR psz = m_pszUTF8;
	// First determine the destination size (cchUnicode)
	while ('\0' != *psz)
	{
		int cbChar = 0;
		BYTE bFirst = (BYTE) *psz;
		while (bFirst & 0x80)
		{
			cbChar++;
			ASSERT(cbChar < 8);
			bFirst <<= 1;
		}

		cbChar = max(1, cbChar);
		psz += cbChar;
		cchUnicode++;
	}

	ASSERT(NULL == m_pwszUnicode);
	m_pwszUnicode = new WCHAR[cchUnicode];
	if (NULL != m_pwszUnicode)
	{
		ASSERT(ALLOC_NONE == m_eAlloc);
		m_eAlloc = ALLOC_UNICODE;
		// Start decoding here:
		LPWSTR pwszStop = m_pwszUnicode + cchUnicode;
		LPWSTR pwszDst = m_pwszUnicode;
		psz = m_pszUTF8;
		while (pwszDst < pwszStop)
		{
			int cbChar = 0;
			BYTE bFirst = (BYTE) *psz;
			while (bFirst & 0x80)
			{
				cbChar++;
				ASSERT(cbChar < 8);
				bFirst <<= 1;
			}

			BOOL fValid = TRUE;
			WCHAR wch = L'\0';
			switch (cbChar)
			{
				case 6: psz++; // FALLTHROUGH               // we don't handle
				case 5: psz++; // FALLTHROUGH               // UCS-4; skip first
				case 4: psz++; // FALLTHROUGH               // three bytes
				case 3:
					wch = WCHAR(*psz++ & 0x0f) << 12;      // 0x0800 - 0xffff
					fValid = fValid && ((*psz & 0xc0) == 0x80);
					// FALLTHROUGH
				case 2:
					wch |= WCHAR(*psz++ & 0x3f) << 6;       // 0x0080 - 0x07ff
					fValid = fValid && ((*psz & 0xc0) == 0x80);
					wch |= WCHAR(*psz++ & 0x3f);
					break;

				case 0:
					wch = WCHAR(*psz++);                    // 0x0000 - 0x007f
					break;

				default:
					ERROR_OUT(("CUTF8String::DecodeUTF8 found invalid UTF-8 lead byte"));
					wch = L'?';
					psz += cbChar;
					break;
			}

			if (FALSE == fValid)
			{
				ERROR_OUT(("CUTF8String::DecodeUTF8 found bad UTF-8 sequence"));
				*pwszDst = L'\0';
				m_hr = E_FAIL;
				break;
			}
#ifdef DEBUG
			cchUnicode--;
#endif // DEBUG

			*pwszDst++ = wch;
		}
		ASSERT(0 == cchUnicode);
	}
	else
	{
		m_hr = E_OUTOFMEMORY;
	}
	DebugExitVOID(CUTF8String::DecodeUTF8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\strutil.cpp ===
// STRUTIL.CPP
//
// Assorted string utility functions for use in NetMeeting components.
// Derived from STRCORE.CPP.

#include "precomp.h"
#include <oprahcom.h>
#include <cstring.hpp>

// global helper functions for Unicode support in a DBCS environment

int NMINTERNAL UnicodeCompare(PCWSTR s, PCWSTR t)
{ 
	// Treat NULL pointers like empty strings
	// at the bottom of the collating order.

	if (IsEmptyStringW(t)) {
		if (IsEmptyStringW(s)) {
			return 0;
		}
		else {
			return 1;
		}
	}

	// Done with empty string cases, 
	// so now do real compare.

	for ( ; *s == *t; s++, t++) {
		if (!*s) {
			return 0;
		}
	}
	return (*s > *t) ? 1 : -1;
}

PWSTR NMINTERNAL NewUnicodeString(PCWSTR _wszText)
{
	PWSTR wszText = NULL;
	UINT nChar;

	if (_wszText) {
		nChar = lstrlenW(_wszText) + 1;
		wszText = new WCHAR[nChar];
		if (wszText) {
			CopyMemory((void *)wszText, 
						_wszText, 
						nChar * sizeof(WCHAR));
		}
	}
	return wszText;
}

PWSTR NMINTERNAL DBCSToUnicode(UINT uCodePage, PCSTR szText)
{
	int		nChar;
	PWSTR	wszText = NULL;

	if (szText) {
		nChar = MultiByteToWideChar(uCodePage,
									0,		// character-type options
									szText,
									-1,		// NULL terminated string
									NULL,	// return buffer (not used)
									0);		// getting length of Unicode string
		if (nChar) {
			wszText = new WCHAR[nChar];
			if (wszText) {
				nChar = MultiByteToWideChar(uCodePage,
											0,			// character-type options
											szText,
											-1,			// NULL terminated string
											wszText,	// return buffer
											nChar);		// length of return buffer
				if (!nChar) {
					delete [] wszText;
					wszText = NULL;
				}
			}
		}
	}
	return wszText;
}

PSTR NMINTERNAL UnicodeToDBCS(UINT uCodePage, PCWSTR wszText)
{
	int		nChar;
	PSTR	szText = NULL;

	if (wszText) {
		nChar = WideCharToMultiByte(uCodePage,
									0,		// character-type options
									wszText,
									-1,		// NULL terminated string
									NULL,	// return buffer (not used)
									0,		// getting length of DBCS string
									NULL,
									NULL);
		if (nChar) {
			szText = new CHAR[nChar];
			if (szText) {
				nChar = WideCharToMultiByte(uCodePage,
											0,			// character-type options
											wszText,
											-1,			// NULL terminated string
											szText,		// return buffer
											nChar,		// length of return buffer
											NULL,
											NULL);
				if (!nChar) {
					delete [] szText;
					szText = NULL;
				}
			}
		}
	}
	return szText;
}


BOOL NMINTERNAL UnicodeIsNumber(PCWSTR wszText)
{
	// If there are no characters, then treat it as not being a number.

	if (!wszText || !*wszText) {
		return FALSE;
	}

	// If any characters are not digits, then return FALSE.

	do {
		if ((*wszText < L'0') || (*wszText > L'9')) {
			return FALSE;
		}
	} while(*++wszText);

	// Got here so all characters are digits.

	return TRUE;
}


/*  G U I D  T O  S Z */
/*----------------------------------------------------------------------------
    %%Function: GuidToSz

	Convert the guid to a special hex string.
	Assumes lpchDest has space for at least sizeof(GUID)*2 +6 chars.
	LENGTH_SZGUID_FORMATTED is 30 and includes space for the null terminator.

	Note the difference between this and UuidToString (or StringFromGUID2)

	GUID Format: {12345678-1234-1234-1234567890123456}
----------------------------------------------------------------------------*/
VOID NMINTERNAL GuidToSz(GUID * pguid, LPTSTR lpchDest)
{
	ASSERT(NULL != pguid);
	ASSERT(NULL != lpchDest);

	wsprintf(lpchDest, TEXT("{%08X-%04X-%04X-%02X%02X-"),
		pguid->Data1, pguid->Data2, pguid->Data3, pguid->Data4[0], pguid->Data4[1]);
	lpchDest += 1+8+1+4+1+4+1+2+2+1;

	for (int i = 2; i < 8; i++)
	{
		wsprintf(lpchDest, TEXT("%02X"), pguid->Data4[i]);
		lpchDest += 2;
	}
	lstrcpy(lpchDest, TEXT("}") );
}


/*  S Z  F I N D  L A S T  C H */
/*----------------------------------------------------------------------------
    %%Function: SzFindLastCh

	Returns a pointer to the ch within the lpsz or NULL if not found
----------------------------------------------------------------------------*/
LPTSTR NMINTERNAL SzFindLastCh(LPTSTR lpsz, TCHAR ch)
{
	LPTSTR lpchRet;

	for (lpchRet = NULL; *lpsz; lpsz = CharNext(lpsz))
	{
		if (ch == *lpsz)
			lpchRet = lpsz;
	}

	return lpchRet;
}



/*  T R I M  S Z  */
/*-------------------------------------------------------------------------
    %%Function: TrimSz

    Trim the whitespace around string.
    Returns the number of characters in the string.
    (chars/bytes in ANSI and DBCS, WCHARs/words in UNICODE)
-------------------------------------------------------------------------*/
UINT NMINTERNAL TrimSz(PTCHAR psz)
{
    UINT   ich;        // character index into rgwCharType
    PTCHAR pchFirst;
    PTCHAR pchLast;
    PTCHAR pchCurr;
    WORD   rgwCharType[MAX_PATH];

	if ((NULL == psz) || (0 == lstrlen(psz)))
	{
		return 0;
	}

	if (!GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, psz, -1, rgwCharType))
	{
		WARNING_OUT(("TrimSz: Problem with GetStringTypeEx"));
		return 0;
	}

	// search for first non-space
	pchFirst = psz;
	ich = 0;
	while (_T('\0') != *pchFirst)
	{
		if (!(C1_SPACE & rgwCharType[ich]))
			break;
		pchFirst = CharNext(pchFirst);
		ich++;
	}

	if (_T('\0') == *pchFirst)
	{
		// The entire string is empty!
		*psz = _T('\0');
		return 0;
	}
	
	// search for last non-space
	pchCurr = pchFirst;
	pchLast = pchCurr;
	while (_T('\0') != *pchCurr)
	{
		if (!(C1_SPACE & rgwCharType[ich]))
		{
			pchLast = pchCurr;
		}
		pchCurr = CharNext(pchCurr);
		ich++;
	}

	ASSERT(_T('\0') != *pchLast);
	// Null terminate the string
	pchLast = CharNext(pchLast);
	*pchLast = _T('\0');

	// Update the original string
	lstrcpy(psz, pchFirst);

	// Return the new length
	return lstrlen(psz);
}


// Implement lstrcpyW when not on a Unicode platform

#if !defined(UNICODE)
/*  L  S T R  C P Y  W  */
/*-------------------------------------------------------------------------
    %%Function: LStrCpyW
    
-------------------------------------------------------------------------*/
LPWSTR NMINTERNAL LStrCpyW(LPWSTR pszDest, LPWSTR pszSrc)
{
	ASSERT(NULL != pszDest);
	ASSERT(NULL != pszSrc);

	if ((NULL != pszDest) && (NULL != pszSrc))
	{
		LPWSTR pszT = pszDest;
		while (0 != (*pszT++ = *pszSrc++))
			;

	}
	return pszDest;
}


/*  L  S T R  C P Y N W  */
/*-------------------------------------------------------------------------
    %%Function: LStrCpyNW
    
-------------------------------------------------------------------------*/
LPWSTR NMINTERNAL LStrCpyNW(LPWSTR pszDest, LPCWSTR pszSrc, INT iMaxLength)
{
	ASSERT(NULL != pszDest);
	ASSERT(NULL != pszSrc);

	if ((NULL != pszDest) && (NULL != pszSrc))
	{
		LPWSTR pszT = pszDest;
		while ((--iMaxLength > 0) && 
				(0 != (*pszT++ = *pszSrc++)))
		{
			/*EXPLICIT */ ;
		}

		if (0 == iMaxLength)
		{
			*pszT = L'\0';
		}
	}
	return pszDest;
}

#endif // !defined(UNICODE)

/*  _ S T R C H R  */
/*-------------------------------------------------------------------------
    %%Function: _StrChr
    
-------------------------------------------------------------------------*/
LPCTSTR NMINTERNAL _StrChr ( LPCTSTR pcsz, TCHAR c )
{
    LPCTSTR pcszFound = NULL;

    if (pcsz)
    {
        while (*pcsz)
        {
            if (*pcsz == c)
            {
                pcszFound = pcsz;
                break;
            }

            pcsz = CharNext(pcsz);
        }
    }

    return pcszFound;
}


/*  _ S T R C M P N  */
/*-------------------------------------------------------------------------
    %%Function: _StrCmpN
    This does a case-sensitive compare of two strings, pcsz1 and pcsz2, of
    at most cchMax characters.  If we reach the end of either string, we
    also stop, and the strings match if the other string is also at its end.

    This function is NOT DBCS safe.
    
-------------------------------------------------------------------------*/
int NMINTERNAL _StrCmpN(LPCTSTR pcsz1, LPCTSTR pcsz2, UINT cchMax)
{
    UINT ich;

    for (ich = 0; ich < cchMax; ich++)
    {
        if (*pcsz1 != *pcsz2)
        {
            // No match.
            return((*pcsz1 > *pcsz2) ? 1 : -1);
        }

        //
        // Are we at the end (if we're here, both strings are at the
        // end.  If only one is, the above compare code kicks in.
        //
        if ('\0' == *pcsz1)
            return 0;

        pcsz1++;
        pcsz2++;
    }

    // If we get here, cchMax characters matched, so success.
    return 0;
}

/*  _ S T R S T R  */
/*-------------------------------------------------------------------------
    %%Function: _StrStr
    
-------------------------------------------------------------------------*/
// BUGBUG - This function is *not* DBCS-safe
LPCTSTR NMINTERNAL _StrStr (LPCTSTR pcsz1, LPCTSTR pcsz2)
{
	PTSTR pszcp = (PTSTR) pcsz1;
	PTSTR pszs1, pszs2;

	if ( !*pcsz2 )
		return pcsz1;

	while (*pszcp)
	{
		pszs1 = pszcp;
		pszs2 = (PTSTR) pcsz2;

		while ( *pszs1 && *pszs2 && !(*pszs1-*pszs2) )
			pszs1++, pszs2++;

		if (!*pszs2)
			return pszcp;

		pszcp++;
	}

	return NULL;
}

/*  _ S T R S T R  */
/*-------------------------------------------------------------------------
    %%Function: _StrStr
    
-------------------------------------------------------------------------*/
// BUGBUG - This function is *not* DBCS-safe
LPCWSTR _StrStrW(LPCWSTR pcsz1, LPCWSTR pcsz2)
{
	PWSTR pszcp = (PWSTR) pcsz1;

	while (*pszcp)
	{
		PWSTR psz1 = pszcp;
		PWSTR psz2 = (PWSTR) pcsz2;

		while ( *psz1 && *psz2 && !(*psz1-*psz2) )
		{
			psz1++;
			psz2++;
		}

		if (!*psz2)
			return pszcp;

		pszcp++;
	}

	return NULL;
}

/*  _ S T R P B R K  */
/*-------------------------------------------------------------------------
    %%Function: _StrPbrkA, _StrPbrkW

    Private, DBCS-safe version of CRT strpbrk function.  Like strchr but 
	accepts more than one character for which to search.  The ANSI version 
	does not support searching for DBCS chars.

	In the Unicode version, we do a nested search.  In the ANSI version,
	we build up a table of chars and use this to scan the string.
-------------------------------------------------------------------------*/
LPSTR NMINTERNAL _StrPbrkA(LPCSTR pcszString, LPCSTR pcszSearch)
{
	ASSERT(NULL != pcszString && NULL != pcszSearch);

	BYTE rgbSearch[(UCHAR_MAX + 1) / CHAR_BIT];

	ZeroMemory(rgbSearch, sizeof(rgbSearch));

	// Scan the search string
	while ('\0' != *pcszSearch)
	{
		ASSERT(!IsDBCSLeadByte(*pcszSearch));

		// Set the appropriate bit in the appropriate byte
		rgbSearch[*pcszSearch / CHAR_BIT] |= (1 << (*pcszSearch % CHAR_BIT));

		pcszSearch++;
	}

	// Scan the source string, compare to the bits in the search array
	while ('\0' != *pcszString)
	{
		if (rgbSearch[*pcszString / CHAR_BIT] & (1 << (*pcszString % CHAR_BIT)))
		{
			// We have a match
			return (LPSTR) pcszString;
		}

		pcszString = CharNextA(pcszString);
	}

	// If we get here, there was no match
	return NULL;
}


LPWSTR NMINTERNAL _StrPbrkW(LPCWSTR pcszString, LPCWSTR pcszSearch)
{
	ASSERT(NULL != pcszString && NULL != pcszSearch);

	// Scan the string, matching each character against those in the search string
	while (L'\0' != *pcszString)
	{
		LPCWSTR pcszCurrent = pcszSearch;

		while (L'\0' != *pcszCurrent)
		{
			if (*pcszString == *pcszCurrent)
			{
				// We have a match
				return (LPWSTR) pcszString;
			}

			// pcszCurrent = CharNextW(pcszCurrent);
			pcszCurrent++;
		}

		// pcszString = CharNextW(pcszString);
		pcszString++;
	}

	// If we get here, there was no match
	return NULL;
}


// BUGBUG - Are DecimalStringToUINT and StrToInt the same?

/*  D E C I M A L  S T R I N G  T O  U  I  N  T  */
/*-------------------------------------------------------------------------
    %%Function: DecimalStringToUINT
    
-------------------------------------------------------------------------*/
UINT NMINTERNAL DecimalStringToUINT(LPCTSTR pcszString)
{
	ASSERT(pcszString);
	UINT uRet = 0;
	LPTSTR pszStr = (LPTSTR) pcszString;
	while (_T('\0') != pszStr[0])
	{
		ASSERT((pszStr[0] >= _T('0')) &&
				(pszStr[0] <= _T('9')));
		uRet = (10 * uRet) + (BYTE) (pszStr[0] - _T('0'));
		pszStr++; // NOTE: DBCS characters are not allowed!
	}
	return uRet;
}


/****************************************************************************
    
	FUNCTION:	StrToInt

    PURPOSE:	The atoi equivalent, to avoid using the C runtime lib

	PARAMETERS: lpSrc - pointer to a source string to convert to integer

	RETURNS:	0 for failure, the integer otherwise
				(what if the string was converted to 0 ?)

****************************************************************************/
int WINAPI RtStrToInt(LPCTSTR lpSrc)       // atoi()
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == _T('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    while (((*lpSrc) >= _T('0') && (*lpSrc) <= _T('9')))
    {
        n *= 10;
        n += *lpSrc - _T('0');
        lpSrc++;
    }
    return bNeg ? -n : n;
}

/*  _ S T R L W R W  */
/*-------------------------------------------------------------------------
    %%Function: _StrLwrW
    
-------------------------------------------------------------------------*/
// BUGBUG - This function does *not* handle all UNICODE character sets

LPWSTR NMINTERNAL _StrLwrW(LPWSTR pwszSrc)
{
	for (PWSTR pwszCur = pwszSrc; (L'\0' != *pwszCur); pwszCur++)
	{
		if ( (*pwszCur >= L'A') && (*pwszCur <= L'Z') )
		{
			*pwszCur = *pwszCur - L'A' + L'a';
		}
	}
	return pwszSrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\sources.inc ===
# SOURCES.INC
#
# Common portions of SOURCES files used in both the Ansi and Unicode
# subdirectories of NMUTIL.
#
# The SOURCES_SUBDIR variable must be defined in the including SOURCES
# file for this INC file to work.

!ifndef SOURCES_SUBDIR
!error Your .\sources. file must define the SOURCES_SUBDIR= macro
!endif

!include $(DEVROOT)\common.inc

MAJORCOMP=common
MINORCOMP=$(SOURCES_SUBDIR)

TARGETNAME=$(SOURCES_SUBDIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY

C_DEFINES=$(C_DEFINES) -DOS_WIN95
ASM_DEFINES=$(ASM_DEFINES)

386_STDCALL=1

# Always enable intrinsics
USER_C_FLAGS=/Oi

#
# MIDL-generated header file
#

USER_INCLUDES=uls2.h

#
# Parameters for MIDL
#

IDL_TYPE=ole
PASS0_HEADERDIR = $(ROOT)\nmutil\$(SOURCES_SUBDIR)\$(O)
PASS0_SOURCEDIR = $(ROOT)\nmutil\$(SOURCES_SUBDIR)\$(O)
MIDL_UUIDDIR    = $(ROOT)\nmutil\$(SOURCES_SUBDIR)\$(O)

#
# List of sources
#

SOURCES=uls2.idl        \
        ..\bstring.cpp  \
		..\borderwindow.cpp \
		..\button.cpp   \
        ..\centwnd.cpp  \
		..\combobox.cpp \
        ..\cstring.cpp  \
        ..\custring.cpp \
        ..\dbg.cpp      \
        ..\debspew.cpp  \
        ..\dllutil.cpp  \
		..\edittext.cpp \
		..\genwindow.cpp \
		..\intlutil.cpp \
        ..\mappedfile.cpp \
        ..\memory.cpp   \
        ..\nmdsprv.cpp  \
        ..\nmhelp.cpp   \
        ..\oblist.cpp   \
        ..\olevalid.c   \
        ..\oprahcom.cpp \
        ..\ping.cpp     \
        ..\procutil.cpp \
        ..\purecall.cpp \
        ..\referenc.cpp \
        ..\regentry.cpp \
        ..\resstr.cpp   \
        ..\strutil.cpp  \
        ..\strtohex.cpp \
		..\toolbar.cpp  \
        ..\hextostr.cpp \
        ..\utf8str.cpp  \
        ..\valid.cpp    \
        ..\mlzdbg.cpp   \
        ..\evtlog.cpp   \
        ..\hash.cpp     \
	..\bestintf.cpp

i386_SOURCES=\
        ..\i386\procid.asm \
        ..\i386\seh.c

#
# Precompiled specs
#

PRECOMPILED_INCLUDE = ..\precomp.h
PRECOMPILED_PCH = precomp.pch
PRECOMPILED_OBJ = precomp.obj
PRECOMPILED_CXX = 1

CONDITIONAL_INCLUDES = \
subwtype.h	\
macocidl.h	\
macwin32.h	\
rpcerr.h	\
rpcmac.h	\
winwlm.h	\
macname1.h	\
macname2.h	\
macpub.h	\
macapi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\valid.cpp ===
/*
 * valid.c - Validation functions module.
 *
 * Taken from URL code 
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"


/****************************** Public Functions *****************************/


BOOL IsValidHWND(HWND hwnd)
{
   /* Ask User if this is a valid window. */

   return(IsWindow(hwnd));
}


#ifdef DEBUG

BOOL IsValidHANDLE(HANDLE hnd)
{
   return(EVAL(hnd != INVALID_HANDLE_VALUE));
}


BOOL IsValidHEVENT(HANDLE hevent)
{
   return(IsValidHANDLE(hevent));
}


BOOL IsValidHFILE(HANDLE hf)
{
   return(IsValidHANDLE(hf));
}


BOOL IsValidHGLOBAL(HGLOBAL hg)
{
   return(IsValidHANDLE(hg));
}


BOOL IsValidHMENU(HMENU hmenu)
{
   return(IsValidHANDLE(hmenu));
}


BOOL IsValidHINSTANCE(HINSTANCE hinst)
{
   return(IsValidHANDLE(hinst));
}


BOOL IsValidHICON(HICON hicon)
{
   return(IsValidHANDLE(hicon));
}


BOOL IsValidHKEY(HKEY hkey)
{
   return(IsValidHANDLE(hkey));
}


BOOL IsValidHMODULE(HMODULE hmod)
{
   return(IsValidHANDLE(hmod));
}


BOOL IsValidHPROCESS(HANDLE hprocess)
{
   return(IsValidHANDLE(hprocess));
}


BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES pcsa)
{
   /* BUGBUG: Fill me in. */

   return(IS_VALID_READ_PTR(pcsa, CSECURITY_ATTRIBUTES));
}


BOOL IsValidFileCreationMode(DWORD dwMode)
{
   BOOL bResult;

   switch (dwMode)
   {
      case CREATE_NEW:
      case CREATE_ALWAYS:
      case OPEN_EXISTING:
      case OPEN_ALWAYS:
      case TRUNCATE_EXISTING:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidFileCreationMode(): Invalid file creation mode %#lx.",
                    dwMode));
         break;
   }

   return(bResult);
}


BOOL IsValidHTEMPLATEFILE(HANDLE htf)
{
   return(IsValidHANDLE(htf));
}


BOOL IsValidPCFILETIME(PCFILETIME pcft)
{
   /* dwLowDateTime may be any value. */
   /* dwHighDateTime may be any value. */

   return(IS_VALID_READ_PTR(pcft, CFILETIME));
}


BOOL IsValidPCPOINT(PCPOINT pcpt)
{

   /* x may be any value. */
   /* y may be any value. */

   return(IS_VALID_READ_PTR(pcpt, CPOINT));
}


BOOL IsValidPCPOINTL(PCPOINTL pcptl)
{

   /* x may be any value. */
   /* y may be any value. */

   return(IS_VALID_READ_PTR(pcptl, CPOINTL));
}


BOOL IsValidPCWIN32_FIND_DATA(PCWIN32_FIND_DATA pcwfd)
{
   /* BUGBUG: Fill me in. */

   return(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
}


BOOL IsValidShowCmd(int nShow)
{
   BOOL bResult;

   switch (nShow)
   {
      case SW_HIDE:
      case SW_SHOWNORMAL:
      case SW_SHOWMINIMIZED:
      case SW_SHOWMAXIMIZED:
      case SW_SHOWNOACTIVATE:
      case SW_SHOW:
      case SW_MINIMIZE:
      case SW_SHOWMINNOACTIVE:
      case SW_SHOWNA:
      case SW_RESTORE:
      case SW_SHOWDEFAULT:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidShowCmd(): Invalid show command %d.",
                    nShow));
         break;
   }

   return(bResult);
}


BOOL IsValidPath(LPCTSTR pcszPath)
{
   /* BUGBUG: Beef up path validation. */

   return(IS_VALID_STRING_PTR(pcszPath, CSTR) &&
          EVAL((UINT)lstrlen(pcszPath) < MAX_PATH));
}

#if defined(UNICODE)
BOOL IsValidPathA(PCSTR pcszPath)
{
   /* BUGBUG: Beef up path validation. */

   return(IS_VALID_STRING_PTR_A(pcszPath, CSTR) &&
          EVAL((UINT)lstrlenA(pcszPath) < MAX_PATH));
}
#endif // defined(UNICODE)

BOOL IsValidPathResult(HRESULT hr, LPCTSTR pcszPath,
                                   UINT ucbPathBufLen)
{
   return((hr == S_OK &&
           EVAL(IsValidPath(pcszPath)) &&
           EVAL((UINT)lstrlen(pcszPath) < ucbPathBufLen)) ||
          (hr != S_OK &&
           EVAL(! ucbPathBufLen ||
                ! pcszPath ||
                ! *pcszPath)));
}


BOOL IsValidExtension(LPCTSTR pcszExt)
{
   return(IS_VALID_STRING_PTR(pcszExt, CSTR) &&
          EVAL(lstrlen(pcszExt) < MAX_PATH) &&
          EVAL(*pcszExt == PERIOD));
}


BOOL IsValidIconIndex(HRESULT hr, LPCTSTR pcszIconFile,
                                  UINT ucbIconFileBufLen, int niIcon)
{
   return(EVAL(IsValidPathResult(hr, pcszIconFile, ucbIconFileBufLen)) &&
          EVAL(hr == S_OK ||
               ! niIcon));
}


BOOL IsValidRegistryValueType(DWORD dwType)
{
   BOOL bResult;

   switch (dwType)
   {
      case REG_NONE:
      case REG_SZ:
      case REG_EXPAND_SZ:
      case REG_BINARY:
      case REG_DWORD:
      case REG_DWORD_BIG_ENDIAN:
      case REG_LINK:
      case REG_MULTI_SZ:
      case REG_RESOURCE_LIST:
      case REG_FULL_RESOURCE_DESCRIPTOR:
      case REG_RESOURCE_REQUIREMENTS_LIST:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidRegistryValueType(): Invalid registry value type %lu.",
                    dwType));
         break;
   }

   return(bResult);
}


BOOL IsValidHotkey(WORD wHotkey)
{
   /* BUGBUG: Beef up hotkey validation. */

   return(wHotkey != 0);
}


#ifdef _COMPARISONRESULT_DEFINED_

BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT cr)
{
   BOOL bResult;

   switch (cr)
   {
      case CR_FIRST_SMALLER:
      case CR_EQUAL:
      case CR_FIRST_LARGER:
         bResult = TRUE;
         break;

      default:
         WARNING_OUT(("IsValidCOMPARISONRESULT(): Unknown COMPARISONRESULT %d.",
                      cr));
         bResult = FALSE;
         break;
   }

   return(bResult);
}

#endif   /* _COMPARISONRESULT_DEFINED_ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\inf\en\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\inf\sources.inc ===
!ifndef SOURCES_SUBDIR
!error Your .\sources. file must define the SOURCES_SUBDIR= macro
!endif

!ifndef ROOT
ROOT=$(MAKEDIR:\setup\inf=)
!endif

!include $(DEVROOT)\common.inc

MAJORCOMP=common
MINORCOMP=$(SOURCES_SUBDIR)

MAJORCOMP=common
MINORCOMP=setup

TARGETNAME=$(SOURCES_SUBDIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY

SOURCES=

NTTARGETFILE0=$(O)\msnetmtg.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\i386\seh.c ===
/*****************************************************************************
 *
 *  Seh.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Structured exception handling.
 *
 *****************************************************************************/
#ifdef _M_IX86
#include <windows.h>
#include <sehcall.h>

typedef void *PV;

/*****************************************************************************
 *
 *      SEHFRAME
 *
 *      Special stack frame used by lightweight structured exception
 *      handling.
 *
 *****************************************************************************/

typedef struct SEHFRAME {

    PV      pvSEH;              /* Link to previous frame   */
    FARPROC Handler;            /* MyExceptionFilter        */
    FARPROC sehTarget;          /* Where to jump on error   */
    INEXCEPTION InException;    /* In-exception handler     */

} SEHFRAME, *PSEHFRAME;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | _MyExceptionFilter |
 *
 *          My tiny exception filter.
 *
 *  @parm   LPEXCEPTION_RECORD | pExceptionRecord |
 *
 *          Exception record describing why we were called.
 *
 *  @parm   PV | EstablisherFrame |
 *
 *          The exception frame (pNext, pHandler)
 *          on the stack which is being handled.  This is used so that
 *          the handler can access its local variables and knows how
 *          far to smash the stack if the exception is being eaten.
 *
 *  @parm   PCONTEXT | pContextRecord |
 *
 *          Client context at time of exception.
 *
 *  @parm   PV | DispatcherContext |
 *
 *          Not used.  Which is good, because I don't know what it means.
 *
 ***************************************************************************/

#define EXCEPTION_UNWINDING     0x00000002
#define EXCEPTION_EXIT_UNWIND   0x00000004

WINBASEAPI void WINAPI
RtlUnwind(PV TargetFrame, PV TargetIp, PEXCEPTION_RECORD per, PV ReturnValue);

EXCEPTION_DISPOSITION
__cdecl
_MyExceptionFilter(
    LPEXCEPTION_RECORD pExceptionRecord,
    PV EstablisherFrame,
    PCONTEXT pContextRecord,
    PV DispatcherContext
)
{
    DispatcherContext;
    pContextRecord;

    /* Don't interfere with an unwind */
    if ((pExceptionRecord->ExceptionFlags &
            (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) == 0) {
        PSEHFRAME pseh = EstablisherFrame;
        BOOL fRc = pseh->InException(pExceptionRecord, pContextRecord);

        /*
         *  RtlUnwind will tell all exception frames that may have
         *  been created underneath us that they are about to be
         *  blown away and should do their __finally handling.
         *
         *  On return, the nested frames have been unlinked.
         */
        RtlUnwind(EstablisherFrame, 0, 0, 0);

        /*
         *  And jump back to the caller.  It is the caller's
         *  responsibility to restore nonvolatile registers!
         *
         *  We also assume that the caller has nothing on the
         *  stack beneath the exception record!
         *
         *  And the handler address is right after the exception
         *  record!
         */
        __asm {
            mov     eax, fRc;               /* Get return value */
            mov     esp, EstablisherFrame;  /* Restore ESP */
//            jmp     [esp].sehTarget;        /* Back to CallWithSEH */

//We should be doing the above, but it faults VC4.2. Gotta love it.

            jmp     DWORD ptr [esp+8]
        }

    }

    /*
     *  We are unwinding.  Don't interfere.
     */
    return EXCEPTION_CONTINUE_SEARCH;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CallWithSEH |
 *
 *          Call the function with an exception frame active.
 *
 *          If the procedure raises an exception, then call
 *          InException and propagate whatever InException returns.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

__declspec(naked) DWORD WINAPI
CallWithSEH(EXCEPTPROC pfn, PV pv, INEXCEPTION InException)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;                       /* To keep C compiler happy */
        push    ebx;
        push    edi;
        push    esi;

        /*
         *  Build a SEHFRAME.
         */
        push    InException;                    /* What to handle */
        push    offset Exit;                    /* Where to go on error */

        xor     edx, edx;                       /* Keep zero handy */
        push    offset _MyExceptionFilter;      /* My handler */
        push    dword ptr fs:[edx];             /* Build frame */
        mov     fs:[edx], esp;                  /* Link in */
    }

        pfn(pv);                                /* Call the victim */

    __asm {
        /*
         *  The validation layer jumps here (all registers in a random
         *  state except for ESP) if something went wrong.
         *
         *  We don't need to restore nonvolatile registers now;
         *  that will be done as part of the procedure exit.
         */
Exit:;

        xor     edx, edx;                       /* Keep zero handy */
        pop     dword ptr fs:[edx];             /* Remove frame */

        /*
         *  Discard MyExceptionFilter, Exit, and InException.
         */
        add     esp, 12;

        pop     esi;
        pop     edi;
        pop     ebx;
        pop     ebp;
        ret     12;
    }

}

#pragma warning(default:4035)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\inf\makefile.inc ===
# Makefile for NetMeeting Setup INF files
#
# Generates different INF files for different installations of NetMeeting
#     FULL - Standalone, web-based installation of NetMeeting.
#     ADD-ON - Web-based, IE add-on release of NetMeeting.
#     MEMPHIS - Release of NetMeeting to be released as part of Windows 98 (MEMPHIS)
#     NT5 - Release of NetMeeting to be released as part of NT5
#
#     Separate targets are available to build the debug and retail versions
#     of these components.
#
# HISTORY:
#     20Jun96 dannygl   Created
#     24Sep96 dannygl   Renamed IE3 and IE4 to "FULL" and "ADD-ON",
#                           respectively.
#                       Condense install and remove into a single INF.
#      2Oct96 dannygl   Add NT add-on INF support
#     13Dec96 dannygl   Add temporary support for a Windows 95 version with
#                           32-bit application sharing components.
#     06May97 laurabu   Make 32-bit app sharing components the Win95 default.
#     03Jun97 dannygl   Condense Win95 and NT/x86 targets
#     07Aug97 hammer    Rename "osr2" to "memphis"
#     05Feb98 hammer    Added NT5
#


# Suffixes used by this makefile
.SUFFIXES : .inx .inf

!if "$(BUILD_PRODUCT)" == "NT"
!include $(NTMAKEENV)\makefile.plt
!include $(NTMAKEENV)\$(TARGET_DIRECTORY)mk.inc
CPU=$(TARGET_DIRECTORY)
!endif

# Definitions
# Target directories for INF files
MEMPHISDIR=memphis
NT5DIR=nt5
FULLDIR=full
ADDONDIR=addon

# Base switches for C preprocessor
#
# /EP - Run through the preprocessor only
# /W4 - Warning level 4
# /nologo - Don't display compiler logo
# /c - Don't build an EXE
CFLAGS_BASE=/EP /W4 /nologo /c

# add /DCHAT_MSCHAT to build w/ Microsoft Chat instead of CB32
CFLAGS_FULL=/DIEX_INSTALL
CFLAGS_ADDON=/DIEX_INSTALL /DIE_ADDON

CFLAGS_MEMPHIS=/DWIN_OPTION
CFLAGS_NT5=/DWINNT_INSTALL

CFLAGS_FAREAST=/DFAREAST

CFLAGS_DEBUG=/DDEBUG
CFLAGS_RETAIL=
!if $(FREEBUILD)
CFLAGS_EXTRA=$(CFLAGS_RETAIL)
!else
CFLAGS_EXTRA=$(CFLAGS_DEBUG)
!endif

# All of the INF files that are built in this makefile
ALLINFS= \
!if "$(CPU)"=="I386"
    $(FULLDIR)\$(CPU)\retail\cc32.inf \
    $(FULLDIR)\$(CPU)\debug\cc32.inf \
    $(FULLDIR)\$(CPU)\fareast\cc32.inf \
    $(FULLDIR)\$(CPU)\fareast\msnetmtg.inf \
    $(MEMPHISDIR)\retail\msnetmtg.inf \
    $(MEMPHISDIR)\debug\msnetmtg.inf \
!endif
    $(NT5DIR)\$(CPU)\retail\msnetmtg.inf \
    $(NT5DIR)\$(CPU)\debug\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\retail\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\debug\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\retail\nmrk.inf \
    $(FULLDIR)\$(CPU)\debug\nmrk.inf \
    $(ADDONDIR)\$(CPU)\retail\msnetmtg.inf \
    $(ADDONDIR)\$(CPU)\debug\msnetmtg.inf

# Inference rules
$(O)\msnetmtg.inf: msnetmtg.inx
    $(C_PREPROCESSOR_NAME) $(CFLAGS_NT5) $(CFLAGS_EXTRA) $(C_PREPROCESSOR_FLAGS) $** > $(O)\$**.tmp
    cleaninf -w $(O)\$**.tmp $@
    del $(O)\$**.tmp

{.}.inx{$(FULLDIR)\$(CPU)\retail}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_FULL) $(CFLAGS_RETAIL) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(FULLDIR)\$(CPU)\debug}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_FULL) $(CFLAGS_DEBUG) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(ADDONDIR)\$(CPU)\retail}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_ADDON) $(CFLAGS_RETAIL) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(ADDONDIR)\$(CPU)\debug}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_ADDON) $(CFLAGS_DEBUG) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(MEMPHISDIR)\retail}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_MEMPHIS) $(CFLAGS_RETAIL) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(MEMPHISDIR)\debug}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_MEMPHIS) $(CFLAGS_DEBUG) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(NT5DIR)\$(CPU)\retail}.inf:
!if "$(BUILD_PRODUCT)" == "NT"
         $(C_PREPROCESSOR_NAME) $(CFLAGS_NT5) $(CFLAGS_RETAIL) $(C_PREPROCESSOR_FLAGS) $< > $*.tmp
    cleaninf -w $*.tmp $@
!else
         $(CC) $(CFLAGS_BASE) $(CFLAGS_NT5) $(CFLAGS_RETAIL) $< > $*.tmp
    uniq -u $*.tmp > $@
!endif
    del $*.tmp

{.}.inx{$(NT5DIR)\$(CPU)\debug}.inf:
!if "$(BUILD_PRODUCT)" == "NT"
	 $(C_PREPROCESSOR_NAME) $(CFLAGS_NT5) $(CFLAGS_DEBUG) $(C_PREPROCESSOR_FLAGS) $< > $*.tmp
    cleaninf -w $*.tmp $@
!else
         $(CC) $(CFLAGS_BASE) $(CFLAGS_NT5) $(CFLAGS_DEBUG) $< > $*.tmp
    uniq -u $*.tmp > $@
!endif
    del $*.tmp

!if "$(CPU)"=="I386"
{.}.inx{$(FULLDIR)\$(CPU)\fareast}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_FULL) $(CFLAGS_RETAIL) $(CFLAGS_FAREAST) $< >$*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp
!endif

# BUILD TARGETS

# Default build target -- MUST BE FIRST
default: all

$(ALLINFS): ..\..\..\h\version.h ..\common.inx

all: \
!if "$(BUILD_PRODUCT)" != "NT"
    full \
    addon \
    memphis \
!endif

full: fulldirs fullretail fulldebug

addon: addondirs addonretail addondebug

!if "$(CPU)"=="I386"
memphis: memphisdirs memphisretail memphisdebug
!else
memphis:
!endif

alldirs: fulldirs addondirs memphisdirs nt5dirs

retail: alldirs fullretail addonretail memphisretail

debug: alldirs fulldebug addondebug memphisdebug

nt5: nt5dirs nt5retail nt5debug

fulldirs:
    -md $(FULLDIR)
    -md $(FULLDIR)\$(CPU)
!if "$(CPU)"=="I386"
    -md $(FULLDIR)\$(CPU)\fareast
!endif
    -md $(FULLDIR)\$(CPU)\retail
    -md $(FULLDIR)\$(CPU)\debug

addondirs:
    -md $(ADDONDIR)
    -md $(ADDONDIR)\$(CPU)
    -md $(ADDONDIR)\$(CPU)\retail
    -md $(ADDONDIR)\$(CPU)\debug

memphisdirs:
	-md $(MEMPHISDIR)
	-md $(MEMPHISDIR)\retail
	-md $(MEMPHISDIR)\debug

nt5dirs:
	-md $(NT5DIR)
	-md $(NT5DIR)\$(CPU)
	-md $(NT5DIR)\$(CPU)\retail
	-md $(NT5DIR)\$(CPU)\debug

fullretail: fulldirs \
!if "$(CPU)"=="I386"
    $(FULLDIR)\$(CPU)\fareast\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\fareast\cc32.inf \
    $(FULLDIR)\$(CPU)\retail\cc32.inf \
!endif
    $(FULLDIR)\$(CPU)\retail\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\retail\nmrk.inf

fulldebug: fulldirs \
!if "$(CPU)"=="I386"
    $(FULLDIR)\$(CPU)\debug\cc32.inf \
!endif
    $(FULLDIR)\$(CPU)\debug\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\debug\nmrk.inf

addonretail: addondirs $(ADDONDIR)\$(CPU)\retail\msnetmtg.inf

addondebug: addondirs $(ADDONDIR)\$(CPU)\debug\msnetmtg.inf

memphisretail: memphisdirs $(MEMPHISDIR)\retail\msnetmtg.inf

memphisdebug: memphisdirs $(MEMPHISDIR)\debug\msnetmtg.inf

nt5retail: nt5dirs $(NT5DIR)\$(CPU)\retail\msnetmtg.inf

nt5debug: nt5dirs $(NT5DIR)\$(CPU)\debug\msnetmtg.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\nmutil\i386\procid.asm ===
;*  Procdi.asm - Processor Identification routines
;*
;*      (C) Copyright Microsoft Corp., 1995
;*
;*      Processor ID
;*
;*  Origin:
;*
;*  Change history:
;*
;*  Date       Who        Description
;*  ---------  ---------  -------------------------------------------------
;*  12-Oct-95  MikeG      Created
;*

.386p
.387

.model  flat


;************************** Include Files ************************

;    include winbase.inc
;    include winerror.inc
;    include kernel32.inc
;    include segs.inc
;    include regstr.inc
;******************** Data Declerations **************************

.data
_DATA SEGMENT
CPU_ID  macro
        db      0fh, 0a2h
        endm

NONE            equ     0
PRESENT         equ     1
Nx586           equ     5
UNKNOWN         equ     0


_nxcpu          db      NONE                    ;default to none
_cputype        db      UNKNOWN                 ;default to unknown
_cpuid_flag     db      NONE                    ;default to no CPUID
_vendor_id      db      "************"
_cpu_signature  dd      0
_features_ecx   dd      0
_features_edx   dd      0
_features_ebx   dd      0
NexGen_id       db      "NexGenDriven"



;*********************** Prototypes ******************************


;************************** Code *********************************

.code

_TEXT	SEGMENT
;==========================================================================
; _get_nxcpu_type
;       This routine identifies NexGen's processor type in following steps:
;
;       if (no AC flag) {       //current Nx586 does not support AC flag
;               set ZF=1;
;               execute DIV to result a none zero value;
;               if (ZF=0) {     //ZF is changed
;                       not a NexGen processor;
;                       exit;
;               } else {        //Nx586 does not change ZF on DIV instruction
;                       if (ID bit not writeable) {
;                               CPU is Nx586 with no CPUID support
;                       } else {                //Nx586 with CPUID support
;                               execute CPUID instruction;
;                               save CPU information;
;                       }
;               }
;       } else {
;               if (ID bit not writeable) {
;                       not a NexGen processor;
;               } else {        //NexGen future processors support CPUID
;                       execute CPUID instruction;
;                       save CPU information;
;               }
;       }
;
;==========================================================================
get_nxcpu_type proc  C cdecl:DWORD
        push    ebx
        push    esi
        push    edi
        mov     byte ptr _nxcpu,PRESENT ; default to present

; test AC bit on EFLAGS register
        mov     bx,sp           ; save the current stack pointer
        and     sp,not 3        ; align the stack to avoid AC fault
        pushfd                  ;
        pop     eax             ; get the original EFLAGS
        mov     ecx,eax         ; save original flag
        xor     eax,40000h      ; flip AC bit in EFLAGS
        push    eax             ; save for EFLAGS
        popfd                   ; copy it to EFLAGS
        pushfd                  ;
        pop     eax             ; get the new EFLAGS value
        mov     sp,bx           ; restore stack pointer
        xor     eax,ecx         ; if the AC bit is unchanged
        je      test_zf         ;       goto second step
        jmp     nx_future_cpu

test_zf:
; test ZF on DIV instruction
        mov     ax,5555h        ; init AX with a non-zero value
        xor     dx,dx           ; set ZF=1
        mov     cx,2
        div     cx              ; Nx586 processor does not modify ZF on DIV
        jnz     not_nx_cpu      ; not a NexGen processor if ZF=0 (modified)

test_cpuid:
; test if CPUID instruction is available
; new Nx586 or future CPU supports CPUID instruction
        pushfd                  ; get EFLAGs
        pop     eax
        mov     ecx,eax         ; save it
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jnz     cpuid_present   ; yes

        mov     byte ptr _cputype,Nx586 ; no, current Nx586
	mov	eax,1		; set return code == true
        jz      cpuid_exit      ; stop testing

nx_future_cpu:
; all NexGen's future processors feature a CPUID instruction
        mov     eax,ecx         ; get original EFLAGS
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jz      not_nx_cpu      ; no, not a NexGen processor

cpuid_present:
; execute CPUID instruction to get vendor name, stepping and feature info
        xor     eax,eax
        CPU_ID
        mov     dword ptr _vendor_id,ebx
        mov     dword ptr _vendor_id[+4],edx
        mov     dword ptr _vendor_id[+8],ecx

        mov     bx,ds
        mov     es,bx
        mov     esi,offset _vendor_id
        mov     edi,offset NexGen_id
        mov     cx,12
        cld
        repe    cmpsb           ; compare vendor ID string
        jne     not_nx_cpu

        mov     byte ptr _cpuid_flag,PRESENT
        cmp     eax,1           ; check highest level
        jl      cpuid_exit

        mov     eax,1
        CPU_ID
        mov     _cpu_signature,eax
        mov     _features_ecx,ecx
        mov     _features_edx,edx
        mov     _features_ebx,ebx
        shr     eax,8
        and     al,0fh
        mov     _cputype,al
        jmp     cpuid_exit
not_nx_cpu:
        mov     byte ptr _nxcpu,NONE
        xor     eax,eax
cpuid_exit:
        pop     edi
        pop     esi
        pop     ebx
        ret
get_nxcpu_type endp

;**************************************************************************
;       Function:       int is_cyrix ()
;
;       Purpose:        Determine if Cyrix CPU is present
;       Technique:      Cyrix CPUs do not change flags where flags change
;                        in an undefined manner on other CPUs
;       Inputs:         none
;       Output:         ax == 1 Cyrix present, 0 if not
;**************************************************************************
is_cyrix proc C __cdecl:WORD
           .486
           push  bx
           xor   ax, ax         ; clear ax
           sahf                 ; clear flags, bit 1 is always 1 in flags
           mov   ax, 5
           mov   bx, 2
           div   bl             ; do an operation that does not change flags
           lahf                 ; get flags
           cmp   ah, 2          ; check for change in flags
           jne   not_cyrix      ; flags changed not Cyrix
           mov   ax, 1          ; TRUE Cyrix CPU
           jmp   done

not_cyrix:
           mov  ax, 0           ; FALSE NON-Cyrix CPU
done:
           pop  bx
           ret
is_cyrix   endp
_TEXT ends
      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\nmmigrat\nmmigrat.h ===
// File: nmmigrat.h

#include <windows.h>

// from windows.h
UINT    WINAPI DeletePathname(LPCSTR);      /* ;Internal */

// From setupx.h

// Migration DLLs
#define SU_MIGRATE_PREINFLOAD    0x00000001	// before the setup INFs are loaded
#define SU_MIGRATE_POSTINFLOAD   0x00000002	// after the setup INFs are loaded
#define SU_MIGRATE_DISKSPACE     0x00000010	// request for the amount of additional diskspace needed
#define SU_MIGRATE_PREQUEUE      0x00000100	// before the INFs are processed and files are queued
#define SU_MIGRATE_POSTQUEUE     0x00000200	// after INFs are processed
#define SU_MIGRATE_REBOOT        0x00000400	// just before we are going to reboot for the 1st time
#define SU_MIGRATE_PRERUNONCE    0x00010000	// before any runonce items are processed
#define SU_MIGRATE_POSTRUNONCE   0x00020000	// after all runonce items are processed

// temporary setup directory used by setup, this is only valid durring
// regular install and contains the INF and other binary files.  May be
// read-only location.
#define LDID_SETUPTEMP  2   // temporary setup dir for install

#define LDID_INF        17  // destination Windows *.INF dir.

// RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );
UINT WINAPI CtlGetLddPath(UINT, LPSTR);

#define Reference(x)      { if (x) ; }

// Prototype for exported function
DWORD FAR PASCAL NmMigration(DWORD dwStage, LPSTR lpszParams, LPARAM lParam);

#ifndef MAX_PATH
#define MAX_PATH  260
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\nmmigrat\nmmigrat.c ===
// File: NmMigrat.c
//
// 16-bit Windows 98 Migration DLL for NetMeeting 3.0

#include "NmMigrat.h"
#include "stdio.h"

// Win98 ships with NM 2.1 build 2203 and will force it to be installed
static const char * g_pcszInfNm   =  "msnetmtg.inf";
static const char * g_pcszVersion = "; Version 4,3,0,2203";
static const char * g_pcszHeader  = ";msnetmtg.inf (removed by NmMigrat.dll)\r\n[Version]\r\nsignature=\"$CHICAGO$\"\r\nSetupClass=Base\r\nLayoutFile=layout.inf, layout1.inf, layout2.inf\r\n";


// In Win98's subase.inf, under [winother.oldlinks] there is a bogus line
static const char * g_pcszInfSubase = "subase.inf";
static const char * g_pcszWinOther  = "[winother.oldlinks]";
static const char * g_pcszNukeLink  = "setup.ini, groupPrograms,, \"\"\"%Old_NetMeeting_DESC%\"\"\"";


///////////////////////////////////////////////////////////////////////

typedef struct {
	HFILE hf;             // File Handle
	LONG  lPos;           // current position in the file
	int   ichCurr;        // current character position in rgch
	int   cchRemain;      // number of remaining chars in rgch
	char  rgch[8*1024];   // a really large buffer!
} FD; // File Data


///////////////////////////////////////////////////////////////////////
// Debug Utilities

#ifdef DEBUG
VOID ErrMsg2(LPCSTR pszFormat, LPVOID p1, LPVOID p2)
{
	char szMsg[1024];
	OutputDebugString("NmMigration: ");
	wsprintf(szMsg, pszFormat, p1, p2);
	OutputDebugString(szMsg);
	OutputDebugString("\r\n");
}
VOID ErrMsg1(LPCSTR pszFormat, LPVOID p1)
{
	ErrMsg2(pszFormat, p1, NULL);
}
#else
#define ErrMsg1(psz, p1)
#define ErrMsg2(psz, p1, p2)
#endif /* DEBUG */

///////////////////////////////////////////////////////////////////////


/*  L I B  M A I N  */
/*-------------------------------------------------------------------------
    %%Function: LibMain
    
-------------------------------------------------------------------------*/
int FAR PASCAL LibMain(HANDLE hInst, WORD wDataseg, WORD wHeapsize, LPSTR lpszcmdl)
{
	Reference(hInst);
	Reference(wDataseg);
	Reference(wHeapsize);
	Reference(lpszcmdl);

    return 1;
}



/*  F  O P E N  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: FOpenFile

    Open the file from the temporary Win98 INF directory.
-------------------------------------------------------------------------*/
BOOL FOpenFile(LPCSTR pszFile, FD * pFd, BOOL fCreate)
{
	char szPath[MAX_PATH];

	// LDID_SETUPTEMP = temp INF directory "C:\WININST0.400"
	UINT retVal = CtlGetLddPath(LDID_SETUPTEMP, szPath);
	if (0 != retVal)
	{
		ErrMsg1("CtlGetLddPath(TEMP) failed. Err=%d", (LPVOID) retVal);
		return FALSE;
	}

	// Nuke the temporary 2.1 inf so it doesn't get installed
	lstrcat(szPath, "\\");
	lstrcat(szPath, pszFile);

	if (fCreate)
	{
		pFd->hf = _lcreat(szPath, 0); // read/write
	}
	else
	{
		pFd->hf = _lopen(szPath, OF_READWRITE);
	}
	
	if (HFILE_ERROR == pFd->hf)
	{
		ErrMsg2("Unable to open [%s]  Error=%d", szPath, (LPVOID) GetLastError());
		return FALSE;
	}

	pFd->lPos = 0;
	pFd->ichCurr = 0;
	pFd->cchRemain = 0;

	ErrMsg1("Opened [%s]", szPath);
	return TRUE;
}


/*  R E A D  L I N E  */
/*-------------------------------------------------------------------------
    %%Function: ReadLine

    Read a line (up to MAX_PATH chars) from the buffered file.
    Returns the number of characters read.
-------------------------------------------------------------------------*/
int ReadLine(char * pchDest, FD * pFd)
{
	int cch;

	for (cch = 0; cch < MAX_PATH; cch++)
	{
		if (0 == pFd->cchRemain)
		{
			pFd->cchRemain = _lread(pFd->hf, pFd->rgch, sizeof(pFd->rgch));
			if (HFILE_ERROR == pFd->cchRemain)
			{
				ErrMsg1("End of file reached at pos=%d", (LPVOID) pFd->lPos);
				break;
			}
			pFd->ichCurr = 0;
		}

		pFd->lPos++;
		pFd->cchRemain--;
		*pchDest = pFd->rgch[pFd->ichCurr++];
		if ('\n' == *pchDest)
		{
			break;
		}
		if ('\r' != *pchDest)
		{
			 pchDest++;
		}
	}

	*pchDest = '\0';  // Always null terminate the string
	return cch;
}

	

/*  R E M O V E  I N F  */
/*-------------------------------------------------------------------------
    %%Function: RemoveInf

    Remove the NM2.1 inf from Win98's list of inf's
-------------------------------------------------------------------------*/
void RemoveInf(void)
{
	FD fd;

	if (!FOpenFile(g_pcszInfNm, &fd, FALSE))
	{
		return;
	}

	for ( ; ; )  // Find the version comment before the first section
	{
		char szLine[MAX_PATH];
		if (0 == ReadLine(szLine, &fd))
		{
			break;
		}

		if ('[' == szLine[0])
		{
			ErrMsg1("No version number found?", 0);
			break;
		}

		// Must match build 2203 since a Win98 update or an OEM
		// could ship a newer version than NM 2.11, which we would
		// want to upgrade us.
		if (0 == lstrcmp(szLine, g_pcszVersion))
		{
			// Re-write the older MSNETMTG.INF with a empty header
			_lclose(fd.hf);

			if (FOpenFile(g_pcszInfNm, &fd, TRUE))
			{
				_llseek(fd.hf, 0, 0);
				_lwrite(fd.hf, (LPCSTR) g_pcszHeader, lstrlen(g_pcszHeader)+1);
				ErrMsg1("Removed older NetMeeting INF", 0);
			}
			break;
		}
	}

	_lclose(fd.hf);
}



/*  F I X  S U B A S E  */
/*-------------------------------------------------------------------------
    %%Function: FixSubase

    Delete the line from subase.inf that deletes the NetMeeting link.
    See NM4DB bug 5937, Win98 bug 65154.
    This code shouldn't be necessary with Win98 SP1 and later.
-------------------------------------------------------------------------*/
void FixSubase(void)
{
	FD    fd;
	char  szLine[MAX_PATH];

	if (!FOpenFile(g_pcszInfSubase, &fd, FALSE))
		return;

	for ( ; ; )  // Find the section 
	{
		if (0 == ReadLine(szLine, &fd))
		{
			break;
		}

		if (('[' == szLine[0]) && (0 == lstrcmp(szLine, g_pcszWinOther)))
		{
			ErrMsg1("Found the section at pos=%d", (LPVOID) fd.lPos);
			break;
		}
	}

	for ( ; ; )  // Find the line
	{
		LONG lPosPrev = fd.lPos; // Remember the start of the line

		if (0 == ReadLine(szLine, &fd))
		{
			break;
		}

		if (0 == lstrcmp(szLine, g_pcszNukeLink))
		{
			// comment out the line
			_llseek(fd.hf, lPosPrev, 0 /* FILE_BEGIN */);
			_lwrite(fd.hf, (LPCSTR) ";", 1);
			ErrMsg1("Commented out line at pos=%d", (LPVOID) lPosPrev);
			break;				
		}

		if ('[' == szLine[0])
		{
			ErrMsg1("End of section? at pos=%d", (LPVOID) lPosPrev);
			break;
		}
	}

	_lclose(fd.hf);
}



/*  N M  M I G R A T I O N  */
/*-------------------------------------------------------------------------
    %%Function: NmMigration

    This is called by the Windows 98 setup system.
-------------------------------------------------------------------------*/
DWORD FAR PASCAL NmMigration(DWORD dwStage, LPSTR lpszParams, LPARAM lParam)
{
	Reference(lpszParams);
	Reference(lParam);

	ErrMsg2("NM Build=[%s] stage=%08X", lpszParams, (LPVOID) dwStage);

	switch (dwStage)
	{
	case SU_MIGRATE_PREINFLOAD:
	{
		RemoveInf();
		FixSubase();
		break;
	}

	default:
		break;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\nmmigrat\makefile.inc ===
#
# makefile.inc for 16-bit components
#

C16_NAME = $(DEVROOT)\bin\c816\i386\cl -nologo
C16_FLAGS = $(C16_FLAGS) -I$(DEVROOT)\inc16 -I$(DEVROOT)\inc -Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
ASM_NAME = $(DEVROOT)\bin\masm611\ml
ASM_FLAGS = -c -W2 $(ASM_FLAGS)

!IF "$(BUILD_ALT_DIR)" == "d"
C16_FLAGS = $(C16_FLAGS) -Zi -DDEBUG
ASM_FLAGS = $(ASM_FLAGS) -Zi -DDEBUG=1
LINK16_FLAGS = $(LINK16_FLAGS) /LI
!ENDIF

{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ASM_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(ASM_FLAGS)
<<NOKEEP
    @$(ASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(ASM_FLAGS)
<<NOKEEP

{}.c{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(C16_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(C16_FLAGS)
<<NOKEEP
    @$(C16_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(C16_FLAGS: =
)
<<NOKEEP


$(O)\$(TARGETNAME).res: $(TARGETNAME).rc
    $(DEVROOT)\bin\c816\i386\rc -r -I $(DEVROOT)\inc16 -I $(ROOT)\h -fo $@ $(TARGETNAME).rc

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib:	$(TARGETNAME).def
	@echo skipping creation of $(TARGETNAME).lib

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp:	$(TARGETNAME).def
	@echo skipping createion of $(TARGETNAME).exp

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).dll: $(OBJECTS) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(O)\$(TARGETNAME).res
	$(DEVROOT)\bin\c816\i386\link @<<
	$(OBJECTS) /align:0x1000 /nodefaultlib /NOE/MAP/NOD/AL:16/NOPACKC/ONERROR:NOEXE $(LINK16_FLAGS),
	$(TARGET),
	$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).map,
	$(TARGETLIBS),
	$(TARGETNAME).def
<<
    $(DEVROOT)\bin\c816\i386\rc $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).res $(TARGET)
    $(SPLITSYM_CMD)
    $(TARGETCOPY_CMD)
    $(PDBCOPY_CMD)
    $(DBGCOPY_CMD)
    $(MAPSYM_CMD)
    $(MAPCOPY_CMD)
    $(SYMCOPY_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\nmmigrat\setupx.h ===
//**********************************************************************
//
// SETUPX.H
//
//  Copyright (c) 1993 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Setup services.
//
// 12/1/93      DONALDM     Added LPCLASS_INFO, and function protos for         ;Internal
//                          exports in SETUP4.DLL                               ;Internal
// 12/4/943     DONALDM     Moved SHELL.H include and Chicago specific          ;Internal
//                          helper functions to SETUP4.H                        ;Internal
// 1/11/94      DONALDM     Added members to DEVICE_INFO to better handle       ;Internal
//                          ClassInstaller load/unload.                         ;Internal
// 1/11/94      DONALDM     Added some new DIF_ messages for Net guys.          ;Internal
// 2/25/94      DONALDM     Fixed a bug with the DIREG_ flags                   ;Internal
//**********************************************************************

#ifndef SETUPX_INC
#define SETUPX_INC   1                   // SETUPX.H signature

/***************************************************************************/
// setup PropertySheet support
// NOTE:  Always include PRST.H because it is needed later for Class Installer
// stuff, and optionally define the SU prop sheet stuff.
/***************************************************************************/
#include <prsht.h>
#ifndef NOPRSHT
HPROPSHEETPAGE  WINAPI SUCreatePropertySheetPage(LPCPROPSHEETPAGE lppsp);
BOOL            WINAPI SUDestroyPropertySheetPage(HPROPSHEETPAGE hPage);
int             WINAPI SUPropertySheet(LPCPROPSHEETHEADER lppsh);
#endif // NOPRSHT

typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code

#define IP_ERROR       (100)    // Inf parsing
#define TP_ERROR       (200)    // Text processing module
#define VCP_ERROR      (300)    // Virtual copy module
#define GEN_ERROR      (400)    // Generic Installer
#define DI_ERROR       (500)    // Device Installer

// err2ids mappings
enum ERR_MAPPINGS {
    E2I_VCPM,           // Maps VCPM to strings
    E2I_SETUPX,         // Maps setupx returns to strings
    E2I_SETUPX_MODULE,  // Maps setupx returns to appropriate module
    E2I_DOS_SOLUTION,   // Maps DOS Extended errors to solutions
    E2I_DOS_REASON,     // Maps DOS extended errors to strings.
    E2I_DOS_MEDIA,      // Maps DOS extended errors to media icon.
};

#ifndef NOVCP

/***************************************************************************/
//
// Logical Disk ID definitions
//
/***************************************************************************/

// DECLARE_HANDLE(VHSTR);           /* VHSTR = VirtCopy Handle to STRing */
typedef UINT VHSTR;         /* VirtCopy Handle to String */

VHSTR   WINAPI vsmStringAdd(LPCSTR lpszName);
int WINAPI vsmStringDelete(VHSTR vhstr);
VHSTR   WINAPI vsmStringFind(LPCSTR lpszName);
int WINAPI vsmGetStringName(VHSTR vhstr, LPSTR lpszBuffer, int cbBuffer);
int WINAPI vsmStringCompare(VHSTR vhstrA, VHSTR vhstrB);
LPCSTR  WINAPI vsmGetStringRawName(VHSTR vhstr);
void    WINAPI vsmStringCompact(void);

typedef UINT LOGDISKID;          /* ldid */

// Logical Disk Descriptor: Structure which describes the physical attributes
// of a logical disk. Every logical disk is assigned a logical disk
// identifier (LDID), and is described by a logical disk descriptor (LDD).
//
// The cbSize structure member must always be set to sizeof(LOGDISKDESC_S),
// but all other unused structure members should be NULL or 0. No validation
// is performed on the size of string arrays; all string pointers, if
// non-NULL and they are to receive a string, must point at string arrays
// whose sizes are as follows:
//      sizeof( szPath )    = MAX_PATH_LEN
//      sizeof( szVolLabel) = MAX_FILENAME_LEN
//      sizeof( szName )    = MAX_STRING_LEN
#define MAX_PATH_LEN        260     // Max. path length.
#define MAX_FILENAME_LEN    20      // Max. filename length. ( > sizeof( "x:\\12345678.123" )


typedef struct _LOGDISKDESC_S { /* ldd */
    WORD        cbSize;                 // Size of this structure (bytes)
    LOGDISKID   ldid;                   // Logical Disk ID.
    LPSTR       pszPath;                // Ptr. to associated Path string.
    LPSTR       pszVolLabel;            // Ptr. to Volume Label string.
    LPSTR       pszDiskName;            // Ptr. to Disk Name string.
    WORD        wVolTime;               // Volume label modification time.
    WORD        wVolDate;               // Volume label modification date.
    DWORD       dwSerNum;               // Disk serial number.
    WORD        wFlags;                 // Flags.
} LOGDISKDESC_S, FAR *LPLOGDISKDESC;



// Range for pre-defined LDIDs.
#define LDID_PREDEF_START   0x0001  // Start of range
#define LDID_PREDEF_END     0x7FFF  // End of range

// Range for registry-assigned LDIDs
#define LDID_VAR_START  0x7000
#define LDID_VAR_END    0x7FFF

// Range for dynamically-assigned LDIDs.
#define LDID_ASSIGN_START   0x8000  // Start of range
#define LDID_ASSIGN_END     0xBFFF  // End of range

// Pre-defined Logical Disk Identifiers (LDID).
//
#define LDID_NULL       0               // Null (undefined) LDID.
#define LDID_ABSOLUTE   ((UINT)-1)      // Absolute path

// source path of windows install, this is typically A:\ or a net drive
#define LDID_SRCPATH    1   // source of instilation
// temporary setup directory used by setup, this is only valid durring
// regular install and contains the INF and other binary files.  May be
// read-only location.
#define LDID_SETUPTEMP  2   // temporary setup dir for install
// path to uninstall location, this is where we backup files that will
// be overwritten
#define LDID_UNINSTALL  3   // uninstall (backup) dir.
// backup path for the copy engine, this should not be used
#define LDID_BACKUP     4   // BUGBUG: backup dir for the copy engine, not used
// temporary setup directory used by setup, this is only valid durring
// regular install and is guarenteed to be a read/write location for
// scratch space.
#define LDID_SETUPSCRATCH  5   // temporary setup dir for scratch space.

// windows directory, this is the destinatio of the insallation
#define LDID_WIN        10  // destination Windows dir (just user files).
#define LDID_SYS        11  // destination Windows System dir.
#define LDID_IOS        12  // destination Windows Iosubsys dir.
#define LDID_CMD        13  // destination Windows Command (DOS) dir.
#define LDID_CPL        14  // destination Windows Control Panel dir.
#define LDID_PRINT      15  // destination Windows Printer dir.
#define LDID_MAIL       16  // destination Mail dir.
#define LDID_INF        17  // destination Windows *.INF dir.
#define LDID_HELP       18  // destination Windows Help dir.
#define LDID_WINADMIN   19  // admin stuff.

#define LDID_FONTS      20  // destination Windows Font dir.
#define LDID_VIEWERS    21  // destination Windows Viewers dir.
#define LDID_VMM32      22  // destination Windows VMM32 dir.
#define LDID_COLOR      23  // destination Windows Color dir.

#define LDID_APPS       24  // Applications folder location.

// Shared dirs for net install.
#define LDID_SHARED     25  // Bulk of windows files.
#define LDID_WINBOOT    26  // guarenteed boot device for windows.
#define LDID_MACHINE    27  // machine specific files.
#define LDID_HOST_WINBOOT   28

// boot and old win and dos dirs.
#define LDID_BOOT       30  // Root dir of boot drive
#define LDID_BOOT_HOST  31  // Root dir of boot drive host
#define LDID_OLD_WINBOOT    32  // Subdir off of Root (optional)
#define LDID_OLD_WIN    33  // old windows directory (if it exists)
#define LDID_OLD_DOS    34  // old dos directory (if it exists)

#define LDID_OLD_NET    35  // old network root directory, only valid during
                            // network GenUpgrade

#define LDID_MOUSE      36  // path to MOUSE env. variable if set or same as LDID_WIN
                            // only valid after mouse class installer.
#define LDID_PATCH      37  // path to Patch related files
#define LDID_WIN3XIE    38  // install path of Internet Explorer on Windows 3.1
                            // Only defined during system install

// Convert Ascii drive letter to Integer drive number ('A'=1, 'B'=2, ...).
#define DriveAtoI( chDrv )      ((int)(chDrv & 31))

// Convert Integer drive number to Ascii drive letter (1='A', 2='B', ...).
#define DriveItoA( iDrv )       ((char) (iDrv - 1 + 'A'))


// BUGBUG: change the names of these

RETERR WINAPI CtlSetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlGetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlFindLdd    ( LPLOGDISKDESC );
RETERR WINAPI CtlAddLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlDelLdd     ( LOGDISKID  );
RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );
RETERR WINAPI CtlSetLddPath ( LOGDISKID, LPSTR );


// Constants that determine ranking of device compatibility
#define FIRST_CID_RANK_FROM_INF		1000
#define FIRST_CID_RANK_FROM_DEVICE	2000
#define BAD_DRIVER_RANK             4000

/***************************************************************************/
//
// Virtual File Copy definitions
//
/***************************************************************************/


typedef DWORD LPEXPANDVTBL;         /* BUGBUG -- clean this up */

enum _ERR_VCP
{
    ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
    ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
    ERR_VCP_NOMEM,                          // Insufficient memory to comply
    ERR_VCP_QUEUEFULL,                      // Trying to add a node to a maxed-out queue
    ERR_VCP_NOVHSTR,                        // No string handles available
    ERR_VCP_OVERFLOW,                       // Reference count would overflow
    ERR_VCP_BADARG,                         // Invalid argument to function
    ERR_VCP_UNINIT,                         // String library not initialized
    ERR_VCP_NOTFOUND ,                      // String not found in string table
    ERR_VCP_BUSY,                           // Can't do that now
    ERR_VCP_INTERRUPTED,                    // User interrupted operation
    ERR_VCP_BADDEST,                        // Invalid destination directory
    ERR_VCP_SKIPPED,                        // User skipped operation
    ERR_VCP_IO,                             // Hardware error encountered
    ERR_VCP_LOCKED,                         // List is locked
    ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
    ERR_VCP_CHANGEMODE,                     //
    ERR_VCP_LDDINVALID,                     // Logical Disk ID Invalid.
    ERR_VCP_LDDFIND,                        // Logical Disk ID not found.
    ERR_VCP_LDDUNINIT,                      // Logical Disk Descriptor Uninitialized.
    ERR_VCP_LDDPATH_INVALID,
    ERR_VCP_NOEXPANSION,                    // Failed to load expansion dll
    ERR_VCP_NOTOPEN,                        // Copy session not open
    ERR_VCP_NO_DIGITAL_SIGNATURE_CATALOG,   // Catalog is not digitally signed
    ERR_VCP_NO_DIGITAL_SIGNATURE_FILE,      // A file is not digitally signed
};


/*****************************************************************************
 *              Structures
 *****************************************************************************/

/*---------------------------------------------------------------------------*
 *                  VCPPROGRESS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPPROGRESS { /* prg */
    DWORD   dwSoFar;            /* Number of units copied so far */
    DWORD   dwTotal;            /* Number of units to copy */
} VCPPROGRESS, FAR *LPVCPPROGRESS;

/*---------------------------------------------------------------------------*
 *                  VCPDISKINFO
 *---------------------------------------------------------------------------*/

/* BUGBUG -- I currently don't use wVolumeTime, wVolumeDate or     ;Internal
 *  dwSerialNumber.  We may not want to use dwSerialNumber because ;Internal
 *  it means that any disk other than the factory originals will be;Internal
 *  suspected of being tampered with, since the serial number      ;Internal
 *  won't match.  Similar with the time/date stamp on the          ;Internal
 *  volume label.  Or maybe that's what we want to do.             ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */

typedef struct tagVCPDISKINFO {
    WORD        cbSize;         /* Size of this structure in bytes */
    LOGDISKID   ldid;           /* Logical disk ID */
    VHSTR       vhstrRoot;      /* Location of root directory */
    VHSTR       vhstrVolumeLabel;/* Volume label */
    VHSTR       vhstrDiskName;  // Printed name on the disk.
    WORD        wVolumeTime;    /* Volume label modification time */
    WORD        wVolumeDate;    /* Volume label modification date */
    DWORD       dwSerialNumber; /* Disk serial number */
    WORD        fl;             /* Flags */
    LPARAM      lparamRef;      /* Reference data for client */

    VCPPROGRESS prgFileRead;    /* Progress info */
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

} VCPDISKINFO, FAR *LPVCPDISKINFO;

#define VDIFL_VALID     0x0001  /* Fields are valid from a prev. call */
#define VDIFL_EXISTS    0x0002  /* Disk exists; do not format */

RETERR WINAPI DiskInfoFromLdid(LOGDISKID ldid, LPVCPDISKINFO lpdi);


/*---------------------------------------------------------------------------*
 *                  VCPFILESPEC
 *---------------------------------------------------------------------------*/

typedef struct tagVCPFILESPEC { /* vfs */
    LOGDISKID   ldid;           /* Logical disk */
    VHSTR       vhstrDir;       /* Directory withing logical disk */
    VHSTR       vhstrFileName;  /* Filename within directory */
} VCPFILESPEC, FAR *LPVCPFILESPEC;

/*---------------------------------------------------------------------------*
 *              VCPFATTR
 *---------------------------------------------------------------------------*/

/*
 * BUGBUG -- explain diffce between llenIn and llenOut wrt compression.
 */
typedef struct tagVCPFATTR {
    UINT    uiMDate;            /* Modification date */
    UINT    uiMTime;            /* Modification time */
    UINT    uiADate;            /* Access date */
    UINT    uiATime;            /* Access time */
    UINT    uiAttr;             /* File attribute bits */
    DWORD   llenIn;             /* Original file length */
    DWORD   llenOut;            /* Final file length */
                                /* (after decompression) */
} VCPFATTR, FAR *LPVCPFATTR;

typedef struct tagVCPFILESTAT
{
    UINT    uDate;
    UINT    uTime;
    DWORD   dwSize;
} VCPFILESTAT, FAR *LPVCPFILESTAT;

/*---------------------------------------------------------------------------*
 *                  VIRTNODEEX
 *---------------------------------------------------------------------------*/
typedef struct tagVIRTNODEEX
{    /* vnex */
    HFILE           hFileSrc;
    HFILE           hFileDst;
    VCPFATTR        fAttr;
    WORD            dosError;   // The first/last error encountered
    VHSTR           vhstrFileName;  // The original destination name.
    WPARAM          vcpm;   // The message that was being processed.
} VIRTNODEEX, FAR *LPCVIRTNODEEX, FAR *LPVIRTNODEEX ;


/*---------------------------------------------------------------------------*
 *                  VIRTNODE
 *---------------------------------------------------------------------------*/

/* WARNING!                                                        ;Internal
 *  All fields through but not including                           ;Internal
 *  fl are memcmp'd to determine if we have a duplicate copy       ;Internal
 *  request.                                                       ;Internal
 *                                                                 ;Internal
 *  Do not insert fields before fl unless you want them to be      ;Internal
 *  compared; conversely, if you add a new field that needs to     ;Internal
 *  be compared, make sure it goes before fl.                      ;Internal
 *                                                                 ;Internal
 *  And don't change any of the fields once Windows 4.0 ships.     ;Internal
 *                                                                 ;Internal
 *  The vFileStat and vhstrCatalogFile fields were added at the    ;Internal
 *  end of the structure after Windows 95 shipped to support driver;Internal
 *  cetification.  Offsets of pre-Win95 fields remain the same.    ;Internal
 *  vFileStat duplicates information in lpvnex, but lpvnex was left;Internal
 *  alone for backcompatibility's sake.                            ;Internal
 *                                                                 ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */
typedef struct tagVIRTNODE {    /* vn */
    WORD            cbSize;
    VCPFILESPEC     vfsSrc;
    VCPFILESPEC     vfsDst;
    WORD            fl;
    LPARAM          lParam;
    LPEXPANDVTBL    lpExpandVtbl;
    LPVIRTNODEEX    lpvnex;
    VHSTR           vhstrDstFinalName;
    VCPFILESTAT     vFileStat;
} VIRTNODE, FAR *LPCVIRTNODE, FAR *LPVIRTNODE ;


/*---------------------------------------------------------------------------*
 *              VCPDESTINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDESTINFO { /* destinfo */
    WORD    flDevAttr;          /* Device attributes */
    LONG    cbCapacity;         /* Disk capacity */
    WORD    cbCluster;          /* Bytes per cluster */
    WORD    cRootDir;           /* Size of root directory */
} VCPDESTINFO, FAR *LPVCPDESTINFO;

#define DIFL_FIXED      0x0001  /* Nonremoveable media */
#define DIFL_CHANGELINE 0x0002  /* Change line support */

// Now also used by the virtnode as we dont have copy nodes any more.
// #define CNFL_BACKUP             0x0001  /* This is a backup node */
#define CNFL_DELETEONFAILURE    0x0002  /* Dest should be deleted on failure */
#define CNFL_RENAMEONSUCCESS    0x0004  /* Dest needs to be renamed */
#define CNFL_CONTINUATION       0x0008  /* Dest is continued onto difft disk */
#define CNFL_SKIPPED            0x0010  /* User asked to skip file */
#define CNFL_IGNOREERRORS       0x0020  // An error has occured on this file already
#define CNFL_RETRYFILE          0x0040  // Retry the file (error ocurred)
#define CNFL_COPIED             0x0080  // Node has already been copied.

// BUGBUG: verify the use and usefullness of these flags
// #define VNFL_UNIQUE          0x0000  /* Default */
#define VNFL_MULTIPLEOK         0x0100  /* Do not search PATH for duplicates */
#define VNFL_DESTROYOLD         0x0200  /* Do not back up files */
// #define VNFL_NOW             0x0400  /* Use by vcp Flush */
// To deternime what kind of node it is.
#define VNFL_COPY               0x0000  // A simple copy node.
#define VNFL_DELETE             0x0800  // A delete node
#define VNFL_RENAME             0x1000  // A rename node
#define VNFL_NODE_TYPE          ( VNFL_RENAME|VNFL_DELETE|VNFL_COPY )
    /* Read-only flag bits */
#define VNFL_CREATED            0x2000  /* VCPM_NODECREATE has been sent */
#define VNFL_REJECTED           0x4000  /* Node has been rejected */

#define VNFL_DEVICEINSTALLER    0x8000     /* Node was added by the Device Installer */

#define VNFL_VALIDVQCFLAGS      0xff00  /* ;Internal */

/*---------------------------------------------------------------------------*
 *                  VCPSTATUS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPSTATUS {   /* vstat */
    WORD    cbSize;             /* Size of this structure */

    VCPPROGRESS prgDiskRead;
    VCPPROGRESS prgFileRead;
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgDiskWrite;
    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

    LPVCPDISKINFO lpvdiIn;      /* Current input disk */
    LPVCPDISKINFO lpvdiOut;     /* Current output disk */
    LPVIRTNODE    lpvn;            /* Current file */

} VCPSTATUS, FAR *LPVCPSTATUS;

/*---------------------------------------------------------------------------*
 *                  VCPVERCONFLICT
 *---------------------------------------------------------------------------*/

typedef struct tagVCPVERCONFLICT {

    LPCSTR  lpszOldFileName;
    LPCSTR  lpszNewFileName;
    DWORD   dwConflictType;     /* Same values as VerInstallFiles */
    LPVOID  lpvinfoOld;         /* Version information resources */
    LPVOID  lpvinfoNew;
    WORD    wAttribOld;         /* File attributes for original */
    LPARAM  lparamRef;          /* Reference data for callback */

} VCPVERCONFLICT, FAR *LPVCPVERCONFLICT;

/*****************************************************************************
 *              Callback functions
 *****************************************************************************/

typedef LRESULT (CALLBACK *VIFPROC)(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

LRESULT CALLBACK vcpDefCallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

// callback for default UI.
// lparamRef --> a VCPUIINFO structure
LRESULT CALLBACK vcpUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);


/*---------------------------------------------------------------------------*
 *                  VCPUIINFO
 *
 * This structure is passed in as the lparamRef of vcpUICallbackProc.
 *
 * on using vcpUICallbackProc:
 * - to use, have vcpUICallbackProc as the callback for vcpOpen with
 *   an appropriately filled in VCPUIINFO structure as the lparamRef.
 *
 * - based on flags, hwndProgress is created and maintained
 * - lpfnStatCallback is called with only status messages
 *     returning VCPM_ABORT indicates that the copy should be aborted
 * - if hwndProgress is non-NULL, the control with idProgress will
 *     receive progress gauge messages as appropriate
 *
 *---------------------------------------------------------------------------*/
#define VCPUI_CREATEPROGRESS 0x0001 // callback should create and manage progress gauge dialog
#define VCPUI_NOBROWSE       0x0002 // no browse button in InsertDisk
#define VCPUI_RENAMEREQUIRED 0x0004 // as a result of a file being in use at copy, reboot required
#define VCPUI_BACKUPVER      0x0008 // backup version conflicts instead of displaying UI

typedef struct {
    UINT flags;
    HWND hwndParent;            // window of parent
    HWND hwndProgress;          // window to get progress updates (nonzero ids)
    UINT idPGauge;              // id for progress gauge
    VIFPROC lpfnStatCallback;   // callback for status info (or NULL)
    LPARAM lUserData;           // caller definable data
    LOGDISKID ldidCurrent;      // reserved.  do not touch.
} VCPUIINFO, FAR *LPVCPUIINFO;

/******************************************************************************
 *          Callback notification codes
 *****************************************************************************/

    /* BUGBUG -- VCPN_ABORT should match VCPERROR_INTERRUPTED */

#define VCPN_OK         0       /* All is hunky-dory */
#define VCPN_PROCEED        0   /* The same as VCPN_OK */

#define VCPN_ABORT      (-1)    /* Cancel current operation */
#define VCPN_RETRY      (-2)    /* Retry current operation */
#define VCPN_IGNORE     (-3)    /* Ignore error and continue */
#define VCPN_SKIP       (-4)    /* Skip this file and continue */
#define VCPN_FORCE      (-5)    /* Force an action */
#define VCPN_DEFER      (-6)    /* Save the action for later */
#define VCPN_FAIL       (-7)    /* Return failure back to caller */
#define VCPN_RETRYFILE  (-8)    // An error ocurred during file copy, do it again.

/*****************************************************************************
 *          Callback message numbers
 *****************************************************************************/

#define VCPM_CLASSOF(uMsg)  HIBYTE(uMsg)
#define VCPM_TYPEOF(uMsg)   (0x00FF & (uMsg))   // LOBYTE(uMsg)

/*---------------------------------------------------------------------------*
 *          ERRORs
 *---------------------------------------------------------------------------*/

#define VCPM_ERRORCLASSDELTA    0x80
#define VCPM_ERRORDELTA         0x8000      /* Where the errors go */

/*---------------------------------------------------------------------------*
 *          Disk information callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_DISKCLASS      0x01
#define VCPM_DISKFIRST      0x0100
#define VCPM_DISKLAST       0x01FF

enum tagVCPM_DISK {

    VCPM_DISKCREATEINFO = VCPM_DISKFIRST,
    VCPM_DISKGETINFO,
    VCPM_DISKDESTROYINFO,
    VCPM_DISKPREPINFO,

    VCPM_DISKENSURE,
    VCPM_DISKPROMPT,

    VCPM_DISKFORMATBEGIN,
    VCPM_DISKFORMATTING,
    VCPM_DISKFORMATEND,

    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          File copy callbacks
 *---------------------------------------------------------------------------*/

// BUGBUG: this needs to be merged back with other internal errors
#define VCPERROR_IO         (VCP_ERROR - ERR_VCP_IO)            /* Hardware error encountered */

#define VCPM_FILEINCLASS    0x02
#define VCPM_FILEOUTCLASS   0x03
#define VCPM_FILEFIRSTIN    0x0200
#define VCPM_FILEFIRSTOUT   0x0300
#define VCPM_FILELAST       0x03FF

enum tagVCPM_FILE {
    VCPM_FILEOPENIN = VCPM_FILEFIRSTIN,
    VCPM_FILEGETFATTR,
    VCPM_FILECLOSEIN,
    VCPM_FILECOPY,
    VCPM_FILENEEDED,

    VCPM_FILEOPENOUT = VCPM_FILEFIRSTOUT,
    VCPM_FILESETFATTR,
    VCPM_FILECLOSEOUT,
    VCPM_FILEFINALIZE,
    VCPM_FILEDELETE,
    VCPM_FILERENAME,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VIRTNODE callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_NODECLASS  0x04
#define VCPM_NODEFIRST  0x0400
#define VCPM_NODELAST   0x04FF

enum tagVCPM_NODE {
    VCPM_NODECREATE = VCPM_NODEFIRST,
    VCPM_NODEACCEPT,
    VCPM_NODEREJECT,
    VCPM_NODEDESTROY,
    VCPM_NODECHANGEDESTDIR,
    VCPM_NODECOMPARE,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          TALLY callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_TALLYCLASS     0x05
#define VCPM_TALLYFIRST     0x0500
#define VCPM_TALLYLAST      0x05FF

enum tagVCPM_TALLY {
    VCPM_TALLYSTART = VCPM_TALLYFIRST,
    VCPM_TALLYEND,
    VCPM_TALLYFILE,
    VCPM_TALLYDISK,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VER callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VERCLASS       0x06
#define VCPM_VERFIRST       0x0600
#define VCPM_VERLAST        0x06FF

enum tagVCPM_VER {
    VCPM_VERCHECK = VCPM_VERFIRST,
    VCPM_VERCHECKDONE,
    VCPM_VERRESOLVECONFLICT,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VSTAT callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VSTATCLASS     0x07
#define VCPM_VSTATFIRST     0x0700
#define VCPM_VSTATLAST      0x07FF

enum tagVCPM_VSTAT {
    VCPM_VSTATSTART = VCPM_VSTATFIRST,
    VCPM_VSTATEND,
    VCPM_VSTATREAD,
    VCPM_VSTATWRITE,
    VCPM_VSTATNEWDISK,

    VCPM_VSTATCLOSESTART,       // Start of VCP close
    VCPM_VSTATCLOSEEND,         // upon leaving VCP close
    VCPM_VSTATBACKUPSTART,      // Backup is beginning
    VCPM_VSTATBACKUPEND,        // Backup is finished
    VCPM_VSTATRENAMESTART,      // Rename phase start/end
    VCPM_VSTATRENAMEEND,
    VCPM_VSTATCOPYSTART,        // Acutal copy phase
    VCPM_VSTATCOPYEND,
    VCPM_VSTATDELETESTART,      // Delete phase
    VCPM_VSTATDELETEEND,
    VCPM_VSTATPATHCHECKSTART,   // Check for valid paths
    VCPM_VSTATPATHCHECKEND,
    VCPM_VSTATCERTIFYSTART,     // Certify phase
    VCPM_VSTATCERTIFYEND,
    VCPM_VSTATUSERABORT,        // User wants to quit.
    VCPM_VSTATYIELD,            // Do a yield.
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          Destination info callbacks
 *---------------------------------------------------------------------------*/

/* BUGBUG -- find a reasonable message range for this */
#define VCPM_PATHCLASS      0x08
#define VCPM_PATHFIRST      0x0800
#define VCPM_PATHLAST       0x08FF

enum tagVCPM_PATH{
    VCPM_BUILDPATH = VCPM_PATHFIRST,
    VCPM_UNIQUEPATH,
    VCPM_CHECKPATH,
};

// #define VCPM_BUILDPATH      0x83

/*--------------------------------------------------------------------------*
 *          Patch processing callbacks
 *---------------------------------------------------------------------------*/

/* BUGBUG -- find a reasonable message range for this */
#define VCPM_PATCHCLASS      0x09
#define VCPM_PATCHFIRST      0x0900
#define VCPM_PATCHLAST       0x09FF

// filepatchbefore -- try to patch before the copy action
// filepatchafter  -- try to patch after the copy action

enum tagVCPM_PATCH{

    VCPM_FILEPATCHBEFORECPY = VCPM_PATCHFIRST,
    VCPM_FILEPATCHAFTERCPY,
    VCPM_FILEPATCHINFOPEN,
    VCPM_FILEPATCHINFCLOSE,
};

/*--------------------------------------------------------------------------*
 *         Certificate processing callbacks
 *---------------------------------------------------------------------------*/

/* BUGBUG -- find a reasonable message range for this */
#define VCPM_CERTCLASS      0x0A
#define VCPM_CERTFIRST      0x0A00
#define VCPM_CERTLAST       0x0AFF

// filepatchbefore -- try to patch before the copy action
// filepatchafter  -- try to patch after the copy action

enum tagVCPM_CERT{

    VCPM_FILECERTIFY = VCPM_CERTFIRST,
    VCPM_FILECERTIFYWARN,
};

/*****************************************************************************/
void WINAPI VcpAddMRUPath( LPCSTR lpszPath );
#define SZ_INSTALL_LOCATIONS "InstallLocationsMRU"


RETERR WINAPI VcpOpen(VIFPROC vifproc, LPARAM lparamMsgRef);

RETERR WINAPI VcpClose(WORD fl, LPCSTR lpszBackupDest);

RETERR WINAPI VcpFlush(WORD fl, LPCSTR lpszBackupDest);

#define VCPFL_ABANDON           0x0000  /* Abandon all pending file copies */
#define VCPFL_BACKUP            0x0001  /* Perform backup */
#define VCPFL_COPY              0x0002  /* Copy files */
#define VCPFL_BACKUPANDCOPY     (VCPFL_BACKUP | VCPFL_COPY)
#define VCPFL_INSPECIFIEDORDER  0x0004  /* Do not sort before copying */
#define VCPFL_DELETE            0x0008
#define VCPFL_RENAME            0x0010
#define VCPFL_ALL               (VCPFL_COPY | VCPFL_DELETE | VCPFL_RENAME )

typedef int (CALLBACK *VCPENUMPROC)(LPVIRTNODE lpvn, LPARAM lparamRef);

int WINAPI vcpEnumFiles(VCPENUMPROC vep, LPARAM lparamRef);

enum tag_VCPM_EXPLAIN{
    VCPEX_SRC_DISK,
    VCPEX_SRC_CABINET,
    VCPEX_SRC_LOCN,
    VCPEX_DST_LOCN,
    VCPEX_SRC_FILE,
    VCPEX_DST_FILE,
    VCPEX_DST_FILE_FINAL,
    VCPEX_DOS_ERROR,
    VCPEX_MESSAGE,
    VCPEX_DOS_SOLUTION,
    VCPEX_SRC_FULL,
    VCPEX_DST_FULL,
    VCPEX_DST_FULL_FINAL
};

LPCSTR WINAPI VcpExplain( LPVIRTNODE lpVn, DWORD dwWhat );

/* Flag bits that can be set via VcpQueueCopy */
// Various Lparams for files
#define VNLP_SYSCRITICAL    0x0001  // This file should not be skipped
#define VNLP_SETUPCRITICAL  0x0002  // This file cannot be skipped
#define VNLP_NOVERCHECK     0x0004  // This file must not be VerResolved.
#define VNLP_FORCETEMP      0x0008  // This file must left as a temp name
#define VNLP_IFEXISTS       0x0010  // File skipped if already on machine
#define VNLP_KEEPNEWER      0x0020  // If the dest file is newer - keep it (frosting)
#define VNLP_PATCHIFEXIST   0x0040  // patch only the file exists, if file not there,
#define VNLP_NOPATCH        0x0080  // per file base turn on/off patch option (default patch on)
#define VNLP_CATALOGCERT    0x0100  // This file is a catalog certificate.
#define VNLP_NEEDCERTIFY    0x0200  // This file need to be certified.
#define VNLP_COPYIFEXISTS   0x0400  // if dest file exists, copy it.

// VcpEnumFiles Flags.

#define VEN_OP      0x00ff      /* Operation field */

#define VEN_NOP     0x0000      /* Do nothing */
#define VEN_DELETE  0x0001      /* Delete current item */
#define VEN_SET     0x0002      /* Change value of current item */
#define VEN_ADVANCE 0x0003      /* Move to head of list */      /* ;Internal */

#define VEN_FL      0xff00      /* Flags field */

#define VEN_STOP    0x0100      /* Stop enumeration after this item */
#define VEN_ERROR   0x8000      /* Stop enumeration after this item
                                 * and ignore the OP field */

// BUGBUG: add the other VCP stuff necessary to use this

// BUGBUG: remove the lpsz*Dir fields, make overload the LDID with them

RETERR WINAPI VcpQueueCopy(LPCSTR lpszSrcFileName, LPCSTR lpszDstFileName,
                LPCSTR lpszSrcDir, LPCSTR lpszDstDir,
                LOGDISKID ldidSrc, LOGDISKID ldidDst,
                LPEXPANDVTBL lpExpandVtbl, WORD fl,
                LPARAM lParam);

RETERR WINAPI VcpQueueDelete( LPCSTR lpszDstFileName,
                              LPCSTR lpszDstDir,
                              LOGDISKID ldidDst,
                              LPARAM lParamRef );

RETERR WINAPI VcpQueueRename( LPCSTR      lpszSrcFileName,
                            LPCSTR      lpszDstFileName,
                            LPCSTR      lpszSrcDir,
                            LPCSTR      lpszDstDir,
                            LOGDISKID   ldidSrc,
                            LOGDISKID   ldidDst,
                            LPARAM      lParam );
                            
RETERR WINAPI vcpRegisterSourcePath( LPCSTR lpszKey, LPARAM lpExtra,
                                                LPCSTR lpszPath );
RETERR WINAPI vcpGetSourcePath( LPCSTR lpszKey, LPARAM lpExtra,
                                        LPSTR lpszBuf, UINT uBufSize );
                                        
#endif // NOVCP

#ifndef NOINF
/***************************************************************************/
//
// Inf Parser API declaration and definitions
//
/***************************************************************************/

enum _ERR_IP
{
    ERR_IP_INVALID_FILENAME = (IP_ERROR + 1),
    ERR_IP_ALLOC_ERR,
    ERR_IP_INVALID_SECT_NAME,
    ERR_IP_OUT_OF_HANDLES,
    ERR_IP_INF_NOT_FOUND,
    ERR_IP_INVALID_INFFILE,
    ERR_IP_INVALID_HINF,
    ERR_IP_INVALID_FIELD,
    ERR_IP_SECT_NOT_FOUND,
    ERR_IP_END_OF_SECTION,
    ERR_IP_PROFILE_NOT_FOUND,
    ERR_IP_LINE_NOT_FOUND,
    ERR_IP_FILEREAD,
    ERR_IP_TOOMANYINFFILES,
    ERR_IP_INVALID_SAVERESTORE,
    ERR_IP_INVALID_INFTYPE
};

#define INFTYPE_TEXT                0
#define INFTYPE_EXECUTABLE          1

#define MAX_SECT_NAME_LEN    32

typedef struct _INF NEAR * HINF;
typedef struct _INFLINE FAR * HINFLINE;            // tolken to inf line

RETERR  WINAPI IpOpen(LPCSTR pszFileSpec, HINF FAR * lphInf);
RETERR  WINAPI IpOpenEx(LPCSTR pszFileSpec, HINF FAR * lphInf, UINT InfType);
RETERR  WINAPI IpOpenAppend(LPCSTR pszFileSpec, HINF hInf);
RETERR  WINAPI IpOpenAppendEx(LPCSTR pszFileSpec, HINF hInf, UINT InfType);
RETERR  WINAPI IpSaveRestorePosition(HINF hInf, BOOL bSave);
RETERR  WINAPI IpClose(HINF hInf);
RETERR  WINAPI IpGetLineCount(HINF hInf, LPCSTR lpszSection, int FAR * lpCount);
RETERR  WINAPI IpFindFirstLine(HINF hInf, LPCSTR lpszSect, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextLine(HINF hInf, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextMatchLine(HINF hInf, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpGetProfileString(HINF hInf, LPCSTR lpszSec, LPCSTR lpszKey, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetFieldCount(HINF hInf, HINFLINE hInfLine, int FAR * lpCount);
RETERR  WINAPI IpGetFileName(HINF hInf, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetIntField(HINF hInf, HINFLINE hInfLine, int iField, int FAR * lpVal);
RETERR  WINAPI IpGetLongField(HINF hInf, HINFLINE hInfLine, int iField, long FAR * lpVal);
RETERR  WINAPI IpGetStringField(HINF hInf, HINFLINE hInfLine, int iField, LPSTR lpBuf, int iBufSize, int FAR * lpuCount);
RETERR  WINAPI IpGetVersionString(LPSTR lpszInfFile, LPSTR lpszValue, LPSTR lpszBuf, int cbBuf, LPSTR lpszDefaultValue);
RETERR  WINAPI IpOpenValidate( LPCSTR lpszInfFile, HINF FAR * lphInf,
                                 DWORD dwVer, DWORD dwFlags) ;
RETERR WINAPI IpGetDriverDate
(
    LPSTR       lpszInfName,
    UINT        infType,
    LPSTR       lpszSectionName,
    LPWORD      lpwDate
);

RETERR WINAPI IpGetDriverVersion
(
    LPSTR       lpszInfName,
    UINT        infType,
    LPSTR       lpszSectionName,
    LPSTR       lpszVersion,
    WORD        cbVersion
);

#endif // NOINF



#ifndef NOTEXTPROC
/***************************************************************************/
//
// Text processing API declaration and definitions
//
/***************************************************************************/

/* Relative/absolute positioning */
#define SEC_SET 1       // Absolute positioning (relative to the start)
#define SEC_END 2       // Realtive to the end
#define SEC_CUR 3       // Relative to the current line.

#define SEC_OPENALWAYS          1   // Always open a section, no error if it does not exist
#define SEC_OPENEXISTING        2   // Open an existing section, an error given if it does not exist.
#define SEC_OPENNEWALWAYS       3   // Open a section (present or not) and discard its contents.
#define SEC_OPENNEWEXISTING     4   // Open an existing section (discarding its contents). Error if not existing

// Flags for TP_OpenFile().
//
  // Use autoexec/config.sys key delimiters
  //
#define TP_WS_KEEP      1

  // If TP code running under SETUP, the foll. flag specifies whether
  // to cache this file or not! Use this, if you want to read a whole
  // file in when doing the TpOpenSection()!
  //
#define TP_WS_DONTCACHE 2

// The following are simple errors
enum {
    ERR_TP_NOT_FOUND = (TP_ERROR + 1),  // line, section, file etc.
                    // not necessarily terminal
    ERR_TP_NO_MEM,      // couldn't perform request - generally terminal
    ERR_TP_READ,        // could not read the disc - terminal
    ERR_TP_WRITE,       // could not write the data - terminal.
    ERR_TP_INVALID_REQUEST, // Multitude of sins - not necessarily terminal.
    ERR_TP_INVALID_LINE         // Invalid line from DELETE_LINE etc.
};

/* Data handles */
DECLARE_HANDLE(HTP);
typedef HTP FAR * LPHTP;

/* File handles */
DECLARE_HANDLE(HFN);
typedef HFN FAR * LPHFN;

typedef UINT TFLAG;
typedef UINT LINENUM, FAR * LPLINENUM;

#define MAX_REGPATH     256     // Max Registry Path Length
#define LINE_LEN        256     // BUGBUG: max line length?
#define SECTION_LEN     32      // BUGBUG: max length of a section name?
#define MAX_STRING_LEN  512     // BUGBUG: review this

/* Function prototypes */
RETERR  WINAPI TpOpenFile(LPCSTR Filename, LPHFN phFile, TFLAG Flag);
RETERR  WINAPI TpCloseFile(HFN hFile);
RETERR  WINAPI TpOpenSection(HFN hfile, LPHTP phSection, LPCSTR Section, TFLAG flag);
RETERR  WINAPI TpCloseSection(HTP Section);
RETERR  WINAPI TpCommitSection(HFN hFile, HTP hSection, LPCSTR Section, TFLAG flag);
LINENUM WINAPI TpGetLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, LPLINENUM lpLineNum );
LINENUM WINAPI TpGetNextLine(HTP hSection, LPCSTR key, LPCSTR value, LPLINENUM lpLineNum );
RETERR  WINAPI TpInsertLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpReplaceLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpDeleteLine(HTP hSection, int rel, int orig,TFLAG flag);
RETERR  WINAPI TpMoveLine(HTP hSection, int src_rel, int src_orig, int dest_rel, int dest_orig, TFLAG flag);
RETERR  WINAPI TpGetLineContents(HTP hSection, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize,int rel, int orig, TFLAG flag);

// UINT    WINAPI TpGetWindowsDirectory(LPSTR lpDest, UINT size);
// UINT    WINAPI TpGetSystemDirectory(LPSTR lpDest, UINT size);

int  WINAPI TpGetPrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize, LPCSTR lpszFile);
int  WINAPI TpWritePrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszString, LPCSTR lpszFile);
int  WINAPI TpGetProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize);
BOOL WINAPI TpWriteProfileString(LPCSTR lpszSect , LPCSTR lpszKey , LPCSTR lpszString);

#endif // NOTEXTPROC



#ifndef NOGENINSTALL
/***************************************************************************/
//
// Generic Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_GENERIC
{
    ERR_GEN_LOW_MEM = GEN_ERROR+1,  // Insufficient memory.
    ERR_GEN_INVALID_FILE,           // Invalid INF file.
    ERR_GEN_LOGCONFIG,              // Can't process LogConfig=.
    ERR_GEN_CFGAUTO,                // Can't process CONFIG.SYS/AUTOEXEC.BAT
    ERR_GEN_UPDINI,                 // Can't process UpdateInis=.
    ERR_GEN_UPDINIFIELDS,           // Can't process UpdateIniFields=.
    ERR_GEN_ADDREG,                 // Can't process AddReg=.
    ERR_GEN_DELREG,                 // Can't process DelReg=.
    ERR_GEN_INI2REG,                // Can't process Ini2Reg=.
    ERR_GEN_FILE_COPY,              // Can't process CopyFiles=.
    ERR_GEN_FILE_DEL,               // Can't process DelFiles=.
    ERR_GEN_FILE_REN,               // Can't process RenFiles=.
    ERR_GEN_REG_API,                // Error returned by Reg API.
    ERR_GEN_DO_FILES,               // can't do Copy, Del or RenFiles.
    ERR_GEN_ADDIME,                 // Can't process AddIme=.
    ERR_GEN_DELIME,                 // Can't process DelIme=.
    ERR_GEN_PERUSER,                // Can't process PerUserInstall=.
    ERR_GEN_BITREG,                 // Can't process BitReg=.
};

// The cbSize field will always be set to sizeof(GENCALLBACKINFO_S).
// All unused fields (for the operation) will be not be initialized.
// For example, when the operation is GENO_DELFILE, the Src fields will
// not have any sensible values (Dst fields will be set correctly) as
// VcpQueueDelete only accepts Dst parameters.
//
/***************************************************************************
 * GenCallbackINFO structure passed to GenInstall CallBack functions.
 ***************************************************************************/
typedef struct _GENCALLBACKINFO_S { /* gen-callback struc */
    WORD         cbSize;                 // Size of this structure (bytes).
    WORD         wOperation;             // Operation being performed.
    LOGDISKID    ldidSrc;                // Logical Disk ID for Source.
    LPCSTR       pszSrcSubDir;           // Source sub-dir off of the LDID.
    LPCSTR       pszSrcFileName;         // Source file name (base name).
    LOGDISKID    ldidDst;                // Logical Disk ID for Dest.
    LPCSTR       pszDstSubDir;           // Dest. sub-dir off of the LDID.
    LPCSTR       pszDstFileName;         // Dest. file name (base name).
    LPEXPANDVTBL lpExpandVtbl;           // BUGBUG needed? NULL right now!
    WORD         wflags;                 // flags for VcpQueueCopy.
    LPARAM       lParam;                 // LPARAM to the Vcp API.
} GENCALLBACKINFO_S, FAR *LPGENCALLBACKINFO;

/***************************************************************************
 * GenCallback notification codes -- callback proc returns 1 of foll. values.
 ***************************************************************************/
#define GENN_OK         0       /* All is hunky-dory. Do the VCP operation */
#define GENN_PROCEED    0       /* The same as GENN_OK */

#define GENN_ABORT      (-1)    /* Cancel current GenInstall altogether */
#define GENN_SKIP       (-2)    /* Skip this file and continue */

/***************************************************************************
 * VCP Operation being performed by GenInstall() -- wOperation values in
 * GENCALLBACKINFO structure above.
 ***************************************************************************/
#define GENO_COPYFILE   1       /* VCP copyfile being done */
#define GENO_DELFILE    2       /* VCP delfile being done */
#define GENO_RENFILE    3       /* VCP renfile being done */
#define GENO_WININITRENAME 4    /* VCP wininit rename being added */

typedef LRESULT (CALLBACK *GENCALLBACKPROC)(LPGENCALLBACKINFO lpGenInfo,
                                                            LPARAM lparamRef);

RETERR WINAPI GenInstall( HINF hinfFile, LPCSTR szInstallSection, WORD wFlags );
RETERR WINAPI GenInstallEx( HINF hInf, LPCSTR szInstallSection, WORD wFlags,
                                HKEY hRegKey, GENCALLBACKPROC CallbackProc,
                                LPARAM lparam);

RETERR WINAPI GenWinInitRename(LPCSTR szNew, LPSTR szOld, LOGDISKID ldid);
RETERR WINAPI GenCopyLogConfig2Reg(HINF hInf, HKEY hRegKey,
                                                LPCSTR szLogConfigSection);
void   WINAPI GenFormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc,
                                                                HINF hInf ) ;
RETERR WINAPI GenInitSrcPathsInReg(HINF hInf);

// Flags for GenAddReg() from INf /GenSURegSetValueEx()
//
// (updated from setupapi.h, with unsupported features commented out)
//
#define FLG_ADDREG_BINVALUETYPE         ( 0x00000001 )
#define FLG_ADDREG_NOCLOBBER            ( 0x00000002 )
#define FLG_ADDREG_DELVAL               ( 0x00000004 )
//#define FLG_ADDREG_APPEND             ( 0x00000008 ) // Currently supported only
//                                                     // for REG_MULTI_SZ values.
#define FLG_ADDREG_KEYONLY              ( 0x00000010 ) // Just create the key, ignore value
#define FLG_ADDREG_OVERWRITEONLY        ( 0x00000020 ) // Set only if value already exists
#define FLG_ADDREG_TYPE_REPLACEIFEXISTS ( 0x00000040 )

#define FLG_ADDREG_TYPE_MASK            ( 0xFFFF0000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_SZ              ( 0x00000000                           )
//#define FLG_ADDREG_TYPE_MULTI_SZ      ( 0x00010000                           )
//#define FLG_ADDREG_TYPE_EXPAND_SZ     ( 0x00020000                           )
#define FLG_ADDREG_TYPE_BINARY          ( 0x00000000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_DWORD           ( 0x00010000 | FLG_ADDREG_BINVALUETYPE )
//#define FLG_ADDREG_TYPE_NONE          ( 0x00020000 | FLG_ADDREG_BINVALUETYPE )

// Flags for GenBitReg()
//
#define FLG_BITREG_CLEAR            ( 0x00000000 )
#define FLG_BITREG_SET              ( 0x00000001 )
#define FLG_BITREG_TYPE_BINARY      ( 0x00000000 )
#define FLG_BITREG_TYPE_DWORD       ( 0x00000002 )


RETERR WINAPI GenSURegSetValueEx(HKEY hkeyRoot, LPCSTR szSubKey,
                         LPCSTR lpszValueName, DWORD dwValType,
                         LPBYTE lpszValue, DWORD dwValSize, UINT uFlags );

// A devnode is just a DWORD and this is easier than
// having to include configmg.h for everybody
RETERR WINAPI GenInfLCToDevNode(ATOM atInfFileName, LPSTR lpszSectionName,
                                BOOL bInstallSec, UINT InfType,
                                DWORD dnDevNode);

// Bit fields for GenInstall() (for wFlags parameter) -- these can be OR-ed!

#define GENINSTALL_DO_REGSRCPATH    64

// Remove temporarily because of incompatibilities with INET16.DLL #define GENINSTALL_DO_FILES    (1 | GENINSTALL_DO_REGSRCPATH)
#define GENINSTALL_DO_FILES     1
#define GENINSTALL_DO_INI       2
#define GENINSTALL_DO_REG       4
#define GENINSTALL_DO_INI2REG   8
#define GENINSTALL_DO_CFGAUTO   16
#define GENINSTALL_DO_LOGCONFIG 32
//
// careful:  64 is already used above
//
#define GENINSTALL_DO_IME       128
#define GENINSTALL_DO_PERUSER   256

#define GENINSTALL_DO_INIREG    (GENINSTALL_DO_INI | \
                                 GENINSTALL_DO_REG | \
                                 GENINSTALL_DO_INI2REG)

#define GENINSTALL_DO_ALL       (GENINSTALL_DO_FILES | \
                                    GENINSTALL_DO_INIREG | \
                                    GENINSTALL_DO_CFGAUTO | \
                                    GENINSTALL_DO_LOGCONFIG | \
                                    GENINSTALL_DO_REGSRCPATH | \
                                    GENINSTALL_DO_IME | \
                                    GENINSTALL_DO_PERUSER)

#endif // NOGENINSTALL



#ifndef NODEVICENSTALL
/***************************************************************************/
//
// Device Installer prototypes and definitions
//
/***************************************************************************/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @typee    _ERR_DEVICE_INSTALL | Error return codes for Device Installation
*   APIs.
*
*   @emem ERR_DI_INVALID_DEVICE_ID | Incorrectly formed device ID.
*
*   @emem ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST | Invalid compatible device list.
*
*   @emem ERR_DI_REG_API | Error returned by one of the registry API.
*
*   @emem ERR_DI_LOW_MEM | Insufficient memory to complete.
*
*   @emem ERR_DI_BAD_DEV_INFO | A passed in DEVICE_INFO struct is invalid.
*
*   @emem ERR_DI_INVALID_CLASS_INSTALLER | The class installer is listed incorrecrly
*   in the registry, or points to an invalid class installer.
*
*   @emem ERR_DI_DO_DEFAULT | Do the default action for the requested operation.
*
*   @emem ERR_DI_USER_CANCEL | The user cancelled the operation.
*
*   @emem ERR_DI_NOFILECOPY | No need to copy files (in install).
*
*   @emem ERR_DI_BAD_CLASS_INFO | A passed in CLASS_INFO struct is invalid.
*
*   @emem ERR_DI_BAD_INF | An invalid INF file was encountered.
*
*   @emem ERR_DI_BAD_MOVEDEV_PARAMS | A passed in MOVEDEVICE_PARAMS struct was
*   invalid.
*
*   @emem ERR_DI_NO_INF | No INF found on supplied OEM path.
*
*   @emem ERR_DI_BAD_PROPCHANGE_PARAMS | A passed in PROPCHANGE_PARMS struct was
*   invalid.
*
*   @emem ERR_DI_BAD_SELECTDEVICE_PARAMS | A passed in SELECTEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_REMOVEDEVICE_PARAMS | A passed in REMOVEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_UNREMOVEDEVICE_PARAMS | A passed in UNREMOVEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_ENABLECLASS_PARAMS | A passed in ENABLECLASS_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_FAIL_QUERY | The queried action should not take place.
*
*   @emem ERR_DI_API_ERROR | One of the Device installation APIs was called
*   incorrectly or with invalid parameters.
*
*   @emem ERR_DI_BAD_PATH | An OEM path was specified incorrectly.
*
*   @emem ERR_DI_NOUPDATE | No Drivers Were updated
*
*   @emem ERR_DI_NODATE    | A driver's date/time stamp in the INF could not be found
*
*   @emem ERR_DI_NOVERSION | A driver's version the INF could not be found
*
*
*******************************************************************************/
enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,                         // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,                    // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,         // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,                      // Take default action
    ERR_DI_USER_CANCEL,                     // the user cancelled the operation
    ERR_DI_NOFILECOPY,                      // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,                  // Class Info Struct invalid
    ERR_DI_BAD_INF,                         // Bad INF file encountered
    ERR_DI_BAD_MOVEDEV_PARAMS,              // Bad Move Device Params struct
    ERR_DI_NO_INF,                          // No INF found on OEM disk
    ERR_DI_BAD_PROPCHANGE_PARAMS,           // Bad property change param struct
    ERR_DI_BAD_SELECTDEVICE_PARAMS,         // Bad Select Device Parameters
    ERR_DI_BAD_REMOVEDEVICE_PARAMS,         // Bad Remove Device Parameters
    ERR_DI_BAD_ENABLECLASS_PARAMS,          // Bad Enable Class Parameters
    ERR_DI_FAIL_QUERY,                      // Fail the Enable Class query
    ERR_DI_API_ERROR,                       // DI API called incorrectly
    ERR_DI_BAD_PATH,                        // An OEM path was specified incorrectly
    ERR_DI_BAD_UNREMOVEDEVICE_PARAMS,       // Bad Unremove Device Parameters
    ERR_DI_NOUPDATE,                        // No Drivers Were updated
    ERR_DI_NODATE,                          // The driver does not have a Date stamp in the INF
    ERR_DI_NOVERSION,                       // There is not version string in the INF
    ERR_DI_DONT_INSTALL,                    // Don't upgrade the current driver
    ERR_DI_NO_DIGITAL_SIGNATURE_CATALOG,    // Catalog is not digitally signed
    ERR_DI_NO_DIGITAL_SIGNATURE_INF,        // Inf is not digitally signed
    ERR_DI_NO_DIGITAL_SIGNATURE_FILE,       // A file is not digitally signed
};

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_INFO | This structure contains the information necessary
*   to present the user with a select device dialog.
*
*   @field WORD | cbSize | Size of this structure in bytes.
*
*   @field struct _DRIVER_INFO FAR | *lpNextInfo | Pointer to the next DRIVER_INFO
*   struct in a linked list.
*
*   @field LPSTR | lpszDescription | Pointer to the description of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszMfgName | Pointer to the name of the manufacture of this
*   driver.
*
*   @field LPSTR | lpszProviderName | Pointer to provider of this driver if the
*   lpdi->Flags has the DI_MULTMFGS flag set.
*
*   @field WORD | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0
*   is the most compatible.
*
*   @field DWORD | dwFlags | Flags that control the use of this driver node.  These
*   are the same as the flags defined for a DRIVER_NODE.
*       @flag DNF_DUPDESC           | This driver has the same device description
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CLASS_DRIVER      | Set if this driver is in the class driver list
*       @flag DNF_COMPATIBLE_DRIVER | Set if this driver is in the compatible driver list
*       @flag DNF_INET_DRIVER       | Set if this driver is being installed from the Internet
*       @flag DNF_CURRENT_DRIVER    | Set if this driver is the one currently being used.
*       @flag DNF_CLASS_DRIVER      | Set if this driver is in the class driver list
*       @flag DNF_COMPATIBLE_DRIVER | Set if this driver is in the compatible driver list
*       @flag DNF_INET_DRIVER       | Set if this driver is being installed from the Internet
*       @flag DNF_CURRENT_DRIVER    | Set if this driver is the one currently being used.
*
*   @field LPARAM | lpReserved | Reserved for use by the Device Installer.
*
*   @field DWORD | dwPrivateData | Reserved for use by the Device Installer.
*
*******************************************************************************/
typedef struct _DRIVER_INFO
{
    WORD                        cbSize;                     // Size of this structure in bytes
    struct _DRIVER_INFO FAR*    lpNextInfo;
    LPSTR                       lpszDescription;
    LPSTR                       lpszMfgName;
    LPSTR                       lpszProviderName;           // ONLY valid if DI_MULTMFGS is set in the LPDI
    WORD                        Rank;
    DWORD                       dwFlags;
    LPARAM                      lpReserved;
    DWORD                       dwPrivateData;
    WORD                        wDate;                      // Driver Date
    LPSTR                       lpszVersion;
} DRIVER_INFO, *PDRIVER_INFO, FAR *LPDRIVER_INFO;

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_NODE | This strucure represents a driver which can be
*   installed for a specific device.
*
*   @field struct _DRIVER_NODE FAR* | lpNextDN | Pointer to the next driver node
*   in a list.
*
*   @field UINT | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0
*   is the most compatible.
*
*   @field UINT | InfType | Type of INF this driver cam from.  This will
*   be either INFTYPE_TEXT or INFTYPE_EXECUTABLE
*
*   @field unsigned | InfDate | DOS date stamp of the INF file.
*
*   @field LPSTR | lpszDescription | Pointer to a the descriptrion of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszSectionName | Pointer to the name of INF install section for
*   this driver.
*
*   @field ATOM  | atInfFileName | Global ATOM containing the name of the INF file.
*
*   @field ATOM  | atMfgName | Global ATOM containing the name of this driver's
*   manufacture.
*
*   @field ATOM  | atProviderName | Global ATOM containing the name of this driver's
*   provider.
*
*   @field DWORD | Flags | Flags that control functions using this DRIVER_NODE
*       @flag DNF_DUPDESC           | This driver has the same device description
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CONVERTEDLPINFO   | Set if this Driver Node was converted from an Info Node.
*       Setting this flag will cause the cleanup functions to explicitly delete it.
*
*   @field DWORD | dwPrivateData | Reserved
*
*   @field LPSTR | lpszDrvDescription | Pointer to a driver description.
*
*   @field LPSTR | lpszHardwareID | Pointer to a list of Plug-and-Play hardware IDs for
*   this driver.
*
*   @field LPSTR | lpszCompatIDs | Pointer to a list of Plug-and-Play compatible IDs for
*   this driver.
*
*******************************************************************************/
typedef struct _DRIVER_NODE {
    struct _DRIVER_NODE FAR* lpNextDN;
    UINT    Rank;
    UINT    InfType;
    unsigned    InfDate;
    LPSTR   lpszDescription;        // Compatibility: Contains the Device Desc.
    LPSTR   lpszSectionName;
    ATOM    atInfFileName;
    ATOM    atMfgName;
    ATOM    atProviderName;
    DWORD   Flags;
    DWORD   dwPrivateData;
    LPSTR   lpszDrvDescription;     // New contains an driver description
    LPSTR   lpszHardwareID;
    LPSTR   lpszCompatIDs;
    unsigned    DriverDate;
    LPSTR   lpszInfPath;
    LPARAM  lpReserved;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC             0x00000001   // Multiple providers have same desc
#define DNF_OLDDRIVER           0x00000002   // Driver node specifies old/current driver
#define DNF_EXCLUDEFROMLIST     0x00000004
#define DNF_NODRIVER            0x00000008   // if we want to install no driver e.g no mouse drv

#define DNF_CONVERTEDLPINFO     0x00000010  // Set if the Driver Node is a Converted Info Node

#define DNF_CLASS_DRIVER        0x00000020  // Driver node represents a class driver
#define DNF_COMPATIBLE_DRIVER   0x00000040  // Driver node represents a compatible driver
#define DNF_INET_DRIVER         0x00000080  // Driver comes from an Inetnet source
#define DNF_CURRENT_DRIVER      0x00000100  // Driver is the current one for a device
#define DNF_INDEXED_DRIVER      0x00000200  // Driver is specified in the Windows Driver Index file

// possible types of "INF" files
#define INFTYPE_WIN4        1
#define INFTYPE_WIN3        2
#define INFTYPE_COMBIDRV    3
#define INFTYPE_PPD         4
#define INFTYPE_WPD     5
#define INFTYPE_CLASS_SPEC1 6
#define INFTYPE_CLASS_SPEC2 7
#define INFTYPE_CLASS_SPEC3 8
#define INFTYPE_CLASS_SPEC4 9


#define MAX_CLASS_NAME_LEN   32
#define MAX_DRIVER_INST_LEN  10
#define MAX_GUID_STR 50                     // Big enough to hold a GUID string

// NOTE:  Keep this in sync with confimg.h in \DDK\INC
#define MAX_DEVNODE_ID_LEN  256

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DEVICE_INFO | This is the basic data structure for most Device
*   installation APIs.  A DEVICE_INFO represents a device that is being installed
*   on the system, or an installed device that is being modified in some way.
*
*   @field UINT | cbSize | Size of the DEVICE_INFO struct.
*
*   @field struct _DEVICE_INFO FAR | *lpNextDi | Pointer to the next DEVICE_INFO struct
*   in a linked list.
*
*   @field char | szDescription[LINE_LEN] | Buffer containing the description of the
*   device.
*
*   @field DWORD | dnDevnode | If set, this contains the address of the DevNode associated
*   with the device.
*
*   @field HKEY | hRegKey | An opened registry key that contains the device's registry
*   subkey.  This is usually HKEY_LOCAL_MACHINE.
*
*   @field char | szRegSubkey[MAX_DEVNODE_ID_LEN] | Buffer containing the device's
*   hardware registry subkey.  This is key is rooted in hRegKey, and is ususally some
*   place in the \\ENUM branch.
*
*   @field char | szClassName[MAX_CLASS_NAME_LEN] | Buffer containing the device's
*   class name. (Can be a GUID str)
*
*   @field DWORD | Flags | Flags for controlling installation and U/I functions. Some
*   flags can be set prior to calling device installer APIs, and other are set
*   automatically during the processing of some APIs.
*       @flag DI_SHOWOEM                  | Set if OEM disk support should be allowed
*       @flag DI_SHOWCOMPAT               | Will be set if only a compatible driver list
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWCLASS                | Will be set if only a Class driver list is
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWALL                  | Will be set if both a compatible driver list
*       and a class driver list are being shown by DiSelectDevice.
*       @flag DI_NOVCP                    | Set if no VCP (Virtual Copy Procedure) is
*       desired during DiInstallDevice.
*       @flag DI_DIDCOMPAT                | Will be set if DiBuildCompatDrvList has been
*       done, and lpCompatDrvList points to this device's compatible driver list.
*       @flag DI_DIDCLASS                 | Will be set if DiBuildClassDrvList has been
*       done, and lpClassDrvList points to this device's class driver list.
*       @flag DI_AUTOASSIGNRES            | Unused.
*       @flag DI_NEEDRESTART              | Will be set if the device requires a restart
*       of Windows after installation or a state change.
*       @flag DI_NEEDREBOOT               | Will be set if the device requires a reboot
*       of the machine after installation or a state change.
*       @flag DI_NOBROWSE                 | Set to diable browsing when selecting an OEM
*       disk path.
*       @flag DI_MULTMFGS                 | Will be set if a class driver list, or class
*       info list contains multiple manufactures.
*       @flag DI_DISABLED                 | Unused.
*       @flag DI_GENERALPAGE_ADDED        | Set by a property page provider if a general
*       properties page has been added to the device's property sheet.
*       @flag DI_RESOURCEPAGE_ADDED       | Set by a property page provider if a resource
*       properties page has been added to the device's property sheet.
*       @flag DI_PROPERTIES_CHANGE        | Set if a device's properties have been changed
*       and require an update of the Device Manager's U/I.
*       @flag DI_INF_IS_SORTED            | Set if the INF containing drivers for this
*       device is in sorted order.
*       @flag DI_ENUMSINGLEINF            | Set if DiBuildCompatDrvList and
*       DiBuildlassDrvList should only search the INF file specificed by atDriverPath.
*       @flag DI_DONOTCALLCONFIGMG        | Set if the configuration manager should not
*       be called during DiInstallDevice.
*       @flag DI_INSTALLDISABLED          | Set if the device should be installed in a
*       disabled state by default.
*       @flag DI_CLASSONLY                | Set if this DEVICE_INFO struct contains only
*       a class name.
*       @flag DI_CLASSINSTALLPARAMS       | Set if the lpClassIntallParams field points to
*       a class install parameter block.
*       @flag DI_NODI_DEFAULTACTION       | Set if DiCallClassInstaller should not
*       perform any default action if the class installer return ERR_DI_DO_DEFAULT, or
*       there is not class installer.
*       @flag DI_QUIETINSTALL             | Set if device install API should be as
*       silent as possible using default choices whereever possible.
*       @flag DI_NOFILECOPY               | Set if DiInstallDevice should skip file
*       copying.
*       @flag DI_FORCECOPY                | Set if DiInstallDevice should always
*       copy file, even if they are present on the system.
*       @flag DI_DRIVERPAGE_ADDED         | Set by a property page provider if a driver
*       properties page has been added to the device's property sheet.
*       @flag DI_USECI_SELECTSTRINGS      | Set if class installer provided strings
*       should be used during DiSelectDevice.
*       @flag DI_OVERRIDE_INFFLAGS        | Unused.
*       @flag DI_PROPS_NOCHANGEUSAGE      | Set if there should be no Enable/Disable
*       capability on the device's general property page.
*       @flag DI_NOSELECTICONS            | Set if no small icons should be used during
*       DiSelectDevice.
*       @flag DI_NOWRITE_IDS              | Set if DiInstallDevice should not write
*       the device's hardware and compatible IDs to the registry.
*
*   @field HWND | hwndParent | Window handle that will own U/I dialogs related to this
*   device.
*
*   @field LPDRIVER_NODE | lpCompatDrvList | Pointer to a linked list of DRIVER_NODES
*   representing the compatible drivers for this device.
*
*   @field LPDRIVER_NODE | lpClassDrvList | Pointer to a linked list of DRIVER_NODES
*   representing all drivers of this device's class.
*
*   @field LPDRIVER_NODE | lpSelectedDriver | Pointer to a single DRIVER_NODE that
*   has been selected as the driver for this device.
*
*   @field ATOM | atDriverPath | Global ATOM containing the path to this device's INF
*   file.  This is set only of the driver came from an OEM INF file.  This will be
*   0 if the INF is a standard Windows INF file.
*
*   @field ATOM | atTempInfFile | Global ATOM containing the name of a temporary INF
*   file for this device's drivers.  This is set if the drivers came from an old style
*   INF file and have been converted.
*
*   @field HINSTANCE | hinstClassInstaller | Class installer module instance.
*
*   @field HINSTANCE | hinstClassPropProvidor | Class Property Providor module instance.
*
*   @field HINSTANCE | hinstDevicePropProvidor | Device Property Providor module instance.
*
*   @field HINSTANCE | hinstBasicPropProvidor | Basic Property Providor module instance.
*
*   @field FARPROC | fpClassInstaller | Procedure address of class install function.
*
*   @field FARPROC | fpClassEnumPropPages | Procedure address of the Class property
*   provider page enumeration function.
*
*   @field FARPROC | fpDeviceEnumPropPages | Procedure address of the Device property
*   provider page enumeration function.
*
*   @field FARPROC | fpEnumBasicProperties | Procedure address of the Basic device
*   property provider page enumeration function.
*
*   @field DWORD | dwSetupReserved | Reserved for use by Setup.
*
*   @field DWORD | dwClassInstallReserved | Reserved for use by Class Installers.
*
*   @field GENCALLBACKPROC | gicpGenInstallCallBack | Procedure address of a GenInstall
*   call back function.  This would be set if the class installer wanted to handle
*   GenInstall callbacks during DiInstallDevice.
*
*   @field LPARAM | gicplParam | lParam for the GenInstall Callback.
*
*   @field UINT | InfType | The type of INF file being used.  This will be INFTYPE_TEXT
*   or INFTYPE_EXECUTABLE.
*
*   @field HINSTANCE | hinstPrivateProblemHandler | Module handle for the device's
*   private problem procedure.
*
*   @field FARPROC | fpPrivateProblemHandler | Procedure address of the device's
*   private problem handler.
*
*   @field LPARAM | lpClassInstallParams | Pointer to a class install parameter block.
*   Class installer parameters are specific to the class install functions.
*
*   @field struct _DEVICE_INFO FAR | *lpdiChildList | Pointer to a linked list of
*   DRIVER_INFO structs representing children of this device.
*
*   @field DWORD | dwFlagsEx | Additional control flags.
*       @flag DI_FLAGSEX_USEOLDINFSEARCH  | Set if INF Search functions should not use
*       indexed searching.
*       @flag DI_FLAGSEX_AUTOSELECTRANK0  | Set if DiSelectDevice should automatically
*       select rank 0 match drivers.
*       @flag DI_FLAGSEX_CI_FAILED        | Will be set internally if there was a
*       failure to load or call a class installer.
*       @flag DI_FLAGSEX_DIDINFOLIST      | Will be set if DiBuildCompatDrvInfoList has
*       been called, and this device's compatible driver Info list has been built.
*       @flag DI_FLAGSEX_DIDCOMPATINFO    | Will be set if DiBuildClassDrvInfoList has
*       been called, and this device's class driver Info list has been built.
*       @flag DI_FLAGSEX_FILTERCLASSES    | If set, DiBuildClassDrvList, and
*       DiBuildClassDrvInfoList will check for Class inclusion filters.  This means
*       devices will not be included in the list, if their class is marked as a
*       NoInstallClass class.
*       @flag DI_FLAGSEX_SETFAILEDINSTALL | If set, then if DiInstallDevice installs
*       a NULL driver, it will also set the FAILEDINSTALL config flag
*       @flag DI_FLAGSEX_DEVICECHANGE | If set, the device manager will rebuild it
*       tree of devices after the device property sheet is closed.
*       @flag DI_FLAGSEX_ALWAYSWRITEIDS | If set, and the flag, DI_NOWRITE_ID is clear
*       (ie that flag takes higher precedance) then always write Hardare and Compat
*       ids, even if they allready exist
*       @flag DI_FLAGSEX_ALLOWEXCLUDEDDRVS | If set, DiSelectDevice will display drivers
*       that have the Exlude From Select state
*       @flag DI_FLAGSEX_NOUIONQUERYREMOVE | If setup, DiInstallDevice will prevent
*       U/I warnings during a query removal.  Any U/I wanings that would have been
*       displayed will be silently failed.
*   @field LPDRIVER_INFO | lpCompatDrvInfoList | Pointer to a linked list of
*   DRIVER_INFO structs that are compatible with this device.
*
*   @field LPDRIVER_INFO | lpClassDrvInfoList | Pointer to a linked list of
*   DRIVER_INFO structs representing all drivers for this device's class.
*
*******************************************************************************/
typedef struct _DEVICE_INFO
{
    UINT                        cbSize;
    struct _DEVICE_INFO FAR     *lpNextDi;
    char                        szDescription[LINE_LEN];
    DWORD                       dnDevnode;
    HKEY                        hRegKey;
    char                        szRegSubkey[MAX_DEVNODE_ID_LEN];
    char                        szClassName[MAX_CLASS_NAME_LEN];
    DWORD                       Flags;
    HWND                        hwndParent;
    LPDRIVER_NODE               lpCompatDrvList;
    LPDRIVER_NODE               lpClassDrvList;
    LPDRIVER_NODE               lpSelectedDriver;
    ATOM                        atDriverPath;
    ATOM                        atTempInfFile;
    HINSTANCE                   hinstClassInstaller;
    HINSTANCE                   hinstClassPropProvidor;
    HINSTANCE                   hinstDevicePropProvidor;
    HINSTANCE                   hinstBasicPropProvidor;
    FARPROC                     fpClassInstaller;
    FARPROC                     fpClassEnumPropPages;
    FARPROC                     fpDeviceEnumPropPages;
    FARPROC                     fpEnumBasicProperties;
    DWORD                       dwSetupReserved;
    DWORD                       dwClassInstallReserved;
    GENCALLBACKPROC             gicpGenInstallCallBack;

    LPARAM                      gicplParam;
    UINT                        InfType;

    HINSTANCE                   hinstPrivateProblemHandler;
    FARPROC                     fpPrivateProblemHandler;
    LPARAM                      lpClassInstallParams;
    struct _DEVICE_INFO FAR     *lpdiChildList;
    DWORD                       dwFlagsEx;
    LPDRIVER_INFO               lpCompatDrvInfoList;
    LPDRIVER_INFO               lpClassDrvInfoList;
    char                        szClassGUID[MAX_GUID_STR];
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)

typedef struct _CLASS_INFO
{
    UINT        cbSize;
    struct _CLASS_INFO FAR* lpNextCi;
    LPDEVICE_INFO   lpdi;
    char                szDescription[LINE_LEN];
    char        szClassName[MAX_CLASS_NAME_LEN];
} CLASS_INFO, FAR * LPCLASS_INFO, FAR * FAR * LPLPCLASS_INFO;
#define ASSERT_CI_STRUC(lpci) if (lpci->cbSize != sizeof(CLASS_INFO)) return (ERR_DI_BAD_CLASS_INFO)


// flags for device choosing (InFlags)
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L
#define DI_NOVCP                    0x00000008L     // Don't do vcpOpen/vcpClose.
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES            0x00000040L    // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART              0x00000080L     // Restart required to take effect
#define DI_NEEDREBOOT               0x00000100L     // Reboot required to take effect

// flags for device installation
#define DI_NOBROWSE                 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildClassDrvList
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in
                                                    // class driver list
// Flag indicates that device is disabled
#define DI_DISABLED                 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED        0x00001000L
#define DI_RESOURCEPAGE_ADDED       0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE        0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED            0x00008000L

#define DI_ENUMSINGLEINF            0x00010000L

// The following flags can be used to install a device disabled
// and to prevent CONFIGMG being called when a device is installed
#define DI_DONOTCALLCONFIGMG        0x00020000L
#define DI_INSTALLDISABLED          0x00040000L

// This flag is set of this LPDI is really just an LPCI, ie
// it only contains class info, NO DRIVER/DEVICE INFO
#define DI_CLASSONLY                0x00080000L

// This flag is set if the Class Install params are valid
#define DI_CLASSINSTALLPARAMS       0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// return ERR_DI_DO_DEFAULT
#define DI_NODI_DEFAULTACTION       0x00200000L

// BUGBUG. This is a hack for M6 Net setup.  Net Setup does not work correctly
// if we process devnode syncronously.  This WILL be removed for M7 when
// Net setup is fixed to work with DiInstallDevice
#define DI_NOSYNCPROCESSING         0x00400000L

// flags for device installation
#define DI_QUIETINSTALL             0x00800000L     // don't confuse the user with
                                                    // questions or excess info
#define DI_NOFILECOPY               0x01000000L     // No file Copy necessary
#define DI_FORCECOPY                0x02000000L     // Force files to be copied from install path
#define DI_DRIVERPAGE_ADDED         0x04000000L     // Prop providor added Driver page.
#define DI_USECI_SELECTSTRINGS      0x08000000L     // Use Class Installer Provided strings in the Select Device Dlg
#define DI_OVERRIDE_INFFLAGS        0x10000000L     // Override INF flags
#define DI_PROPS_NOCHANGEUSAGE      0x20000000L     // No Enable/Disable in General Props

#define DI_NOSELECTICONS        0x40000000L     // No small icons in select device dialogs

#define DI_NOWRITE_IDS          0x80000000L     // Don't write HW & Compat IDs on install

#define DI_FLAGSEX_USEOLDINFSEARCH  0x00000001L  // Inf Search functions should not use Index Search
#define DI_FLAGSEX_AUTOSELECTRANK0  0x00000002L  // DiSelectDevice doesn't propmt user if rank 0 match
#define DI_FLAGSEX_CI_FAILED        0x00000004L  // Failed to Load/Call class installer

#define DI_FLAGSEX_DIDINFOLIST      0x00000010L  // Did the Class Info List
#define DI_FLAGSEX_DIDCOMPATINFO    0x00000020L  // Did the Compat Info List

#define DI_FLAGSEX_FILTERCLASSES        0x00000040L
#define DI_FLAGSEX_SETFAILEDINSTALL     0x00000080L
#define DI_FLAGSEX_DEVICECHANGE         0x00000100L
#define DI_FLAGSEX_ALWAYSWRITEIDS       0x00000200L
#define DI_FLAGSEX_ALLOWEXCLUDEDDRVS    0x00000800L
#define DI_FLAGSEX_NOUIONQUERYREMOVE    0x00001000L
#define DI_FLAGSEX_RESERVED1            0x00002000L // Reserved for setupapi
#define DI_FLAGSEX_RESERVED2            0x00004000L // Reserved for setupapi
#define DI_FLAGSEX_RESERVED3            0x00008000L // Reserved for setupapi
#define DI_FLAGSEX_RESERVED4            0x00010000L // Reserved for setupapi
#define DI_FLAGSEX_INET_DRIVER          0x00020000L
#define DI_FLAGSEX_RESERVED5            0x00040000L // Reserved for setupapi

// Defines for class installer functions
#define DIF_SELECTDEVICE            0x0001
#define DIF_INSTALLDEVICE           0x0002
#define DIF_ASSIGNRESOURCES         0x0003
#define DIF_PROPERTIES              0x0004
#define DIF_REMOVE                  0x0005
#define DIF_FIRSTTIMESETUP          0x0006
#define DIF_FOUNDDEVICE             0x0007
#define DIF_SELECTCLASSDRIVERS      0x0008
#define DIF_VALIDATECLASSDRIVERS    0x0009
#define DIF_INSTALLCLASSDRIVERS     0x000A
#define DIF_CALCDISKSPACE           0x000B
#define DIF_DESTROYPRIVATEDATA      0x000C
#define DIF_VALIDATEDRIVER          0x000D
#define DIF_MOVEDEVICE              0x000E
#define DIF_DETECT                  0x000F
#define DIF_INSTALLWIZARD           0x0010
#define DIF_DESTROYWIZARDDATA       0x0011
#define DIF_PROPERTYCHANGE          0x0012
#define DIF_ENABLECLASS             0x0013
#define DIF_DETECTVERIFY            0x0014
#define DIF_INSTALLDEVICEFILES      0x0015
#define DIF_UNREMOVE                0x0016
#define DIF_SELECTBESTCOMPATDRV     0x0017
#define DIF_ALLOW_INSTALL           0x0018

typedef UINT        DI_FUNCTION;    // Function type for device installer

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    ENABLECLASS_PARAMS | DIF_ENABLECLASS class install parameters
*
*   @field UINT | cbSize | Size of the ENABLECLASS_PARAMS struct.
*
*   @field LPSTR | szClass | The class that is being enabled.
*
*   @field WORD | wEnableMsg | Specifies the stage of enabling.
*   Can be one of:
*
*   @const ENABLECLASS_QUERY | The class is about to be enabled.  Return
*   ERR_DI_DO_DEFAULT to allow the class to be enabled, or ERR_DI_FAIL_QUERY
*   to prevent the class from being enabled.
*
*   @const ENABLECLASS_SUCCESS | The enabling of the class has succeeded,
*   return ERR_DI_DO_DEFAULT.
*
*   @const ENABLECLASS_FAILURE | The enabling of the class has failed,
*   return ERR_DI_DO_DEFAULT.
*
*******************************************************************************/
// DIF_ENABLECLASS parameter struct.
typedef struct _ENABLECLASS_PARAMS
{
    UINT            cbSize;
    LPSTR           szClass;
    WORD            wEnableMsg;
} ENABLECLASS_PARAMS, FAR * LPENABLECLASS_PARAMS;
#define ASSERT_ENABLECLASSPARAMS_STRUC(lpecp) if (lpecp->cbSize != sizeof(ENABLECLASS_PARAMS)) return (ERR_DI_BAD_ENABLECLASS_PARAMS)

#define ENABLECLASS_QUERY   0
#define ENABLECLASS_SUCCESS 1
#define ENABLECLASS_FAILURE 2

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    MOVEDEV_PARAMS | DIF_MOVEDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the MOVDEV_PARAMS struct.
*
*   @field LPDEVICE_INFO | lpdiOldDev  | Pointer to the device that is being
*   moved.
*
*******************************************************************************/
typedef struct _MOVEDEV_PARAMS
{
    UINT            cbSize;
    LPDEVICE_INFO   lpdiOldDev;     // References the Device Begin Moved
} MOVEDEV_PARAMS, FAR * LPMOVEDEV_PARAMS;
#define ASSERT_MOVEDEVPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(MOVEDEV_PARAMS)) return (ERR_DI_BAD_MOVEDEV_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    PROPCHANGE_PARAMS | DIF_PROPCHANGE class install parameters
*
*   @field UINT | cbSize | Size of the PROPCHANGE_PARAMS struct.
*
*   @field DWORD | dwStateChange | State change action. See DiChangeState for details.
*
*   @field DWORD | dwFlags | Flags specific to the type of state change.
*
*   @field DWORD | dwConfigID | Configuration ID for config specific changes.
*
*   @xref DiChangeState.
*
*******************************************************************************/
typedef struct _PROPCHANGE_PARAMS
{
    UINT            cbSize;
    DWORD           dwStateChange;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} PROPCHANGE_PARAMS, FAR * LPPROPCHANGE_PARAMS;
#define ASSERT_PROPCHANGEPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(PROPCHANGE_PARAMS)) return (ERR_DI_BAD_PROPCHANGE_PARAMS)

#define MAX_TITLE_LEN           60
#define MAX_INSTRUCTION_LEN     256
#define MAX_LABEL_LEN           30
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SELECTDEVICE_PARAMS | DIF_SELECTDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the SELECTDEVICE_PARAMS struct.
*
*   @field char | szTitle[MAX_TITLE_LEN] | Buffer containing a class installer
*   provided title for the Select Device dialogs.
*
*   @field char | szInstructions[MAX_INSTRUCTION_LEN] |  Buffer containing
*   class installer provided Select Device instructions.
*
*   @field char | szListLabel[MAX_LABEL_LEN] | Buffer containing a lable
*   of the Select Device list of drivers.
*
*******************************************************************************/
typedef struct _SELECTDEVICE_PARAMS
{
    UINT            cbSize;
    char            szTitle[MAX_TITLE_LEN];
    char            szInstructions[MAX_INSTRUCTION_LEN];
    char            szListLabel[MAX_LABEL_LEN];
} SELECTDEVICE_PARAMS, FAR * LPSELECTDEVICE_PARAMS;
#define ASSERT_SELECTDEVICEPARAMS_STRUC(p) if (p->cbSize != sizeof(SELECTDEVICE_PARAMS)) return (ERR_DI_BAD_SELECTDEVICE_PARAMS)

#define DI_REMOVEDEVICE_GLOBAL                  0x00000001
#define DI_REMOVEDEVICE_CONFIGSPECIFIC          0x00000002
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    REMOVEDEVICE_PARAMS | DIF_REMOVE class install parameters
*
*   @field UINT | cbSize | Size of the REMOVEDEVICE_PARAMS struct.
*
*   @field DWORD | dwFlags | Flags indicating the type of removal to perform.
*       @flag DI_REMOVEDEVICE_GLOBAL         | The device will be removed globally.
*       @flag DI_REMOVEDEVICE_CONFIGSPECIFIC | The device will be removed from only
*       the specified configuration.
*
*   @field DWORD | dwConfigID |  If DI_REMOVEDEVICE_CONFIGSPECIFIC is set, then
*   this is the configuration the device will be removed from. 0 means the current
*   config.
*
*******************************************************************************/
typedef struct _REMOVEDEVICE_PARAMS
{
    UINT            cbSize;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} REMOVEDEVICE_PARAMS, FAR * LPREMOVEDEVICE_PARAMS;
#define ASSERT_REMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(REMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_REMOVEDEVICE_PARAMS)

#define DI_UNREMOVEDEVICE_CONFIGSPECIFIC        0x00000002
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    UNREMOVEDEVICE_PARAMS | DIF_UNREMOVE class install parameters
*
*   @field UINT | cbSize | Size of the UNREMOVEDEVICE_PARAMS struct.
*
*   @field DWORD | dwFlags | Flags indicating the type of removal to perform.
*       @flag DI_UNREMOVEDEVICE_CONFIGSPECIFIC | The device will be unremoved from only
*       the specified configuration.
*
*   @field DWORD | dwConfigID |  If DI_UNREMOVEDEVICE_CONFIGSPECIFIC is set, then
*   this is the configuration the device will be removed from. 0 means the current
*   config.
*
*******************************************************************************/
typedef struct _UNREMOVEDEVICE_PARAMS
{
    UINT            cbSize;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} UNREMOVEDEVICE_PARAMS, FAR * LPUNREMOVEDEVICE_PARAMS;
#define ASSERT_UNREMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(UNREMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_UNREMOVEDEVICE_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @type NONE | Dynamic Hardware Install Wizard Constants | Constants that are
*   used when adding custom pages to the hardware install wizard.
*
*   @const MAX_INSTALLWIZARD_DYNAPAGES | The maximum number of dynamic hardware
*   installation wizard pages that can be added by a class installer.
*
*   @const IDD_DYNAWIZ_FIRSTPAGE | Resource ID for the first page that the install
*   wizard will go to after adding the class installer pages.
*
*   @const IDD_DYNAWIZ_SELECT_PREVPAGE | Resource ID for the page that the Select
*   Device page will go back to.
*
*   @const IDD_DYNAWIZ_SELECT_NEXTPAGE | Resource ID for the page that the Select
*   Device page will go forward to.
*
*   @const IDD_DYNAWIZ_ANALYZE_PREVPAGE | Resource ID for the page that the Analyze
*   page will go back to. This will only be used in the event that there is a
*   problem (i.e a conflict), and the user selects Back from the analyze page.
*
*   @const IDD_DYNAWIZ_ANALYZE_NEXTPAGE | Resource ID for the page that the Analyze
*   page will go to if it continues forward.  The wAnalyzeResult in the
*   INSTALLWIZARDDATA struct will contain the anaysis results.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE | Resource ID for that page that the
*   Install detected devices page will go back to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE | Resource ID for the page that the
*   Install detected devices page will go forward to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NODEVS | Resource ID for the page that the
*   Install detected devices page will go to in the event that no devices are
*   detected.
*
*   @const IDD_DYNAWIZ_SELECTDEV_PAGE | Resource ID of the hardware install wizard's
*   select device page.  This ID can be used to go directly to the hardware install
*   wizard's select device page.
*
*   @const IDD_DYNAWIZ_ANALYZEDEV_PAGE | Resource ID of the hardware install wizard's
*   device analysis page.  This ID can be use to go directly to the hardware install
*   wizard's analysis page.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE | Resource ID of the hardware install
*   wizard's install detected devices page.  This ID can be use to go directly to
*   the hardware install wizard's install detected devices page.
*
*   @const IDD_DYNAWIZ_SELECTCLASS_PAGE | Resource ID of the hardware install wizard's
*   select class page.  This ID can be use to go directly to the hardware install
*   wizard's select class page.
*
*******************************************************************************/
// DIF_INSTALLWIZARD  Wizard Data
#define MAX_INSTALLWIZARD_DYNAPAGES             20

// Use this ID for the first page that the install wizard should dynamically jump to.
#define IDD_DYNAWIZ_FIRSTPAGE                   10000

// Use this ID for the page that the Select Device dialog should go back to
#define IDD_DYNAWIZ_SELECT_PREVPAGE             10001

// Use this ID for the page that the Select Device dialog should go to next
#define IDD_DYNAWIZ_SELECT_NEXTPAGE             10002

// Use this ID for the page that the Analyze dialog should go back to
// This will only be used in the event that there is a problem, and the user
// selects Back from the analyze proc.
#define IDD_DYNAWIZ_ANALYZE_PREVPAGE            10003

// Use this ID for the page that the Analyze dialog should go to if it continue from
// the analyze proc.  the wAnalyzeResult in the INSTALLDATA struct will
// contain the anaysis results.
#define IDD_DYNAWIZ_ANALYZE_NEXTPAGE            10004

// This dialog will be selected if the user chooses back from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE    10006

// This dialog will be selected if the user chooses Next from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE    10007

// This is the ID of the dialog to select if detection does not
// find any new devices
#define IDD_DYNAWIZ_INSTALLDETECTED_NODEVS      10008

// This is the ID of the Select Device Wizard page.
#define IDD_DYNAWIZ_SELECTDEV_PAGE              10009

// This is the ID of the Analyze Device Wizard page.
#define IDD_DYNAWIZ_ANALYZEDEV_PAGE             10010

// This is the ID of the Install Detected Devs Wizard page.
#define IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE    10011

// This is the ID of the Select Class Wizard page.
#define IDD_DYNAWIZ_SELECTCLASS_PAGE            10012

// This flag is set if a Class installer has added pages to the
// install wizard.
#define DYNAWIZ_FLAG_PAGESADDED             0x00000001

// The following flags will control the button states when displaying
// the InstallDetectedDevs dialog.
#define DYNAWIZ_FLAG_INSTALLDET_NEXT        0x00000002
#define DYNAWIZ_FLAG_INSTALLDET_PREV        0x00000004

// Set this flag if you jump to the analyze page, and want it to
// handle conflicts for you.  NOTE.  You will not get control back
// in the event of a conflict if you set this flag.
#define DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT 0x00000008

#define ANALYZE_FACTDEF_OK      1
#define ANALYZE_STDCFG_OK       2
#define ANALYZE_CONFLICT        3
#define ANALYZE_NORESOURCES     4
#define ANALYZE_ERROR           5
#define ANALYZE_PNP_DEV         6
#define ANALYZE_PCMCIA_DEV      7

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    INSTALLWIZARDDATA | DIF_INSTALLWIZARD class install parameters. This
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field UINT | cbSize | Size of the INSTALLWIZARDDATA struct.
*
*   @field LPDEVICE_INFO | lpdiOriginal | Pointer to the Original DEVICE_INFO
*   struct at the start of the manual installation.
*
*   @field LPDEVICE_INFO | lpdiSelected | Pointer to the current DEVICE_INFO struct
*   that is being manually selected.
*
*   @field DWORD | dwFlags | Flags that control the operation of the hardware
*   installation wizard.  There are currently none defined.
*
*   @field LPVOID | lpConfigData | Pointer to configuration data for analysis to
*   determine if the selected device can be installed with no conflicts.
*
*   @field WORD | wAnalyzeResult | Results of analysis to determine if the device
*   can be installed with no problems.  The following values are defined:
*       @flag ANALYZE_FACTDEF_OK    | The device can be installed using its factory
*       default settings.
*       @flag ANALYZE_STDCFG_OK     | The device can be installed using a configuration
*       specified in one if its basic logical configurations.  The user will probably
*       have to set jumpers or switches on the hardware to match the settings determined
*       by the install wizard.
*       @flag ANALYZE_CONFLICT      | The device cannot be installed without causing a
*       conflict with another device.
*       @flag ANALYZE_NORESOURCES   | The device does not require any resources, so it
*       can be installed witth no conflicts.
*       @flag ANALYZE_ERROR         | There was an error during analysis.
*       @flag ANALYZE_PNP_DEV       | The device has a least one softsettable logical
*       configurations, allowing it to be automatically configured.  Additionally the
*       device will be enumerated by one of the standard bus enumerators, so it does
*       not require manual installation, except to pre-copy driver files.
*
*   @field HPROPSHEETPAGE | hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES] | An
*   array of property sheet page handles.  The class installer would use this array
*   to create custom wizard pages, and insert their handles into this array.
*
*   @field WORD | wNumDynaPages | The number of pages inserted into the hpsDynamicPages
*   array.
*
*   @field DWORD | dwDynaWizFlags | Flags that control the behavior of the
*   installation wizard whtn dynamic pages have been added.
*       @flag DYNAWIZ_FLAG_PAGESADDED | Will be set by the install wizard if the
*       class installer adds custom pages.
*       @flag DYNAWIZ_FLAG_INSTALLDET_NEXT | If set, the install wizard will allow
*       going forward from the detected devices page, otherwise finish will
*       be the default option for the detected devices page.
*       @flag DYNAWIZ_FLAG_INSTALLDET_PREV | If set, the install wizard will allow
*       going back from the detected devices page.
*       @flag DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT | If set, the class installer will
*       handle the case where the selected device cannot be installed because of
*       a conflict.
*
*   @field DWORD | dwPrivateFlags | Flags that may be defined and used by the class
*   installer.
*
*   @field LPARAM | lpPrivateData | Pointer to private reference data defined and
*   set by the class installer.
*
*   @field LPSTR | lpExtraRunDllParams | Pointer to a string containing extra
*   parameters passed to the hardware install rundll function.
*
*   @field HWND | hwndWizardDlg | Window handle of the install wizard top level
*   window.
*
*******************************************************************************/
typedef struct InstallWizardData_tag
{
    UINT                    cbSize;

    LPDEVICE_INFO           lpdiOriginal;
    LPDEVICE_INFO           lpdiSelected;
    DWORD                   dwFlags;
    LPVOID                  lpConfigData;
    WORD                    wAnalyzeResult;

    // The following fields are used when a Class Installer Extends the Install Wizard
    HPROPSHEETPAGE          hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
    WORD                    wNumDynaPages;
    DWORD                   dwDynaWizFlags;
    DWORD                   dwPrivateFlags;
    LPARAM                  lpPrivateData;
    LPSTR                   lpExtraRunDllParams;
    HWND                    hwndWizardDlg;
} INSTALLWIZDATA, * PINSTALLWIZDATA , FAR *LPINSTALLWIZDATA;

RETERR WINAPI DiCreateDeviceInfo(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszDescription,    // If non-null then description string
    DWORD       hDevnode,       // BUGBUG -- MAKE A DEVNODE
    HKEY        hkey,       // Registry hkey for dev info
    LPCSTR      lpszRegsubkey,  // If non-null then reg subkey string
    LPCSTR      lpszClassName,  // If non-null then class name string
    HWND        hwndParent);    // If non-null then hwnd of parent

RETERR WINAPI DiGetClassDevs(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options

RETERR WINAPI DiGetClassDevsEx(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    LPCSTR      lpszEnumerator, // Must be name of enumerator, or NULL
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options

#define DIGCF_DEFAULT           0x0001  // NOT IMPLEMENTED!
#define DIGCF_PRESENT           0x0002
#define DIGCF_ALLCLASSES        0x0004
#define DIGCF_PROFILE           0x0008

// API to return the Class name of an INF File
RETERR WINAPI DiGetINFClass(LPSTR lpszMWDPath, UINT InfType, LPSTR lpszClassName, DWORD dwcbClassName);

RETERR WINAPI PASCAL DiCreateDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    HINF        hinf,
    LPCSTR      lpszInfSection,
    int         iFlags);

RETERR WINAPI PASCAL DiDeleteDevRegKey(LPDEVICE_INFO lpdi, int  iFlags);


RETERR WINAPI PASCAL DiOpenDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    int         iFlags);

#define DIREG_DEV   0x0001      // Open/Create/Delete device key
#define DIREG_DRV   0x0002      // Open/Create/Delete driver key
#define DIREG_BOTH  0x0004      // Delete both driver and Device key

RETERR WINAPI DiReadRegLogConf
(
    LPDEVICE_INFO       lpdi,
    LPSTR               lpszConfigName,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize
);

RETERR WINAPI DiReadRegConf
(
    LPDEVICE_INFO       lpdi,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize,
    DWORD               dwFlags
);

#define DIREGLC_FORCEDCONFIG        0x00000001
#define DIREGLC_BOOTCONFIG          0x00000002

RETERR WINAPI DiCopyRegSubKeyValue
(
    HKEY    hkKey,
    LPSTR   lpszFromSubKey,
    LPSTR   lpszToSubKey,
    LPSTR   lpszValueToCopy
);

RETERR WINAPI DiDestroyClassInfoList(LPCLASS_INFO lpci);
RETERR WINAPI DiBuildClassInfoList(LPLPCLASS_INFO lplpci);

#define DIBCI_NOINSTALLCLASS        0x000000001
#define DIBCI_NODISPLAYCLASS        0x000000002

RETERR WINAPI DiBuildClassInfoListEx(LPLPCLASS_INFO lplpci, DWORD dwFlags);
RETERR WINAPI DiGetDeviceClassInfo(LPLPCLASS_INFO lplpci, LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiSelectDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiSelectOEMDrv(HWND hDlg, LPDEVICE_INFO lpdi);

// Callback for diInstallDevice vcpOpen.  Basically calls vcpUICallback for everthing
// except when DI_FORCECOPY is active, in which case copies get defaulted to
// VCPN_FORCE
LRESULT CALLBACK diInstallDeviceUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);
RETERR WINAPI DiInstallDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiInstallDriverFiles(LPDEVICE_INFO lpdi);

RETERR WINAPI DiRemoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiUnremoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAskForOEMDisk(LPDEVICE_INFO lpdi);

RETERR WINAPI DiCallClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

BOOL WINAPI DiBuildDriverIndex(BOOL bUI);
BOOL WINAPI DiAddSingleInfToDrvIdx(LPSTR lpszInfName, WORD InfType, BOOL bCreate);
BOOL WINAPI DiDeleteSingleInfFromDrvIdx(LPSTR lpszInfPath);

RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi);
LPDRIVER_NODE   WINAPI DiSelectBestCompatDrv(LPDEVICE_INFO lpdi, LPDRIVER_NODE lpdnCurrent);

// Given list of drivers returns the newest, may be used by class installers when 
// called by DiSelectBestCompatDrv.
LPDRIVER_NODE WINAPI DiPickBestDriver(LPDRIVER_NODE lpdnList); 

RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildCompatDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiDestroyDrvInfoList(LPDRIVER_INFO lpInfo);
LPDRIVER_NODE WINAPI DiConvertDriverInfoToDriverNode(LPDEVICE_INFO lpdi, LPDRIVER_INFO lpInfo);

typedef RETERR (CALLBACK *OLDINFPROC)(HINF hinf, LPCSTR lpszNewInf, LPARAM lParam);
RETERR WINAPI DiBuildClassDrvListFromOldInf(LPDEVICE_INFO lpdi, LPCSTR lpszSection, OLDINFPROC lpfnOldInfProc, LPARAM lParam);

RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpdn);

RETERR  WINAPI  DiMoveDuplicateDevNode(LPDEVICE_INFO lpdiNewDev);

// The following export will load a dll and find the specified proc name
typedef RETERR (FAR PASCAL *DIINSTALLERPROPERTIES)(LPDEVICE_INFO);

RETERR WINAPI GetFctn(HKEY hk, LPSTR lpszRegVal, LPSTR lpszDefProcName,
                      HINSTANCE FAR * lphinst, FARPROC FAR *lplpfn);

RETERR
WINAPI
DiCreateDriverNode(
    LPLPDRIVER_NODE lplpdn,
    UINT    Rank,
    UINT    InfType,
    unsigned    InfDate,
    LPCSTR  lpszDevDescription,
    LPCSTR  lpszDrvDescription,
    LPCSTR  lpszProviderName,
    LPCSTR  lpszMfgName,
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSectionName,
    DWORD   dwPrivateData);

RETERR WINAPI DiLoadClassIcon(
    LPCSTR  szClassName,
    HICON FAR *lphiLargeIcon,
    int FAR *lpiMiniIconIndex);


RETERR WINAPI DiInstallDrvSection(
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSection,
    LPCSTR  lpszClassName,
    LPCSTR  lpszDescription,
    DWORD   dwFlags);


RETERR WINAPI DiChangeState(LPDEVICE_INFO lpdi, DWORD dwStateChange, DWORD dwFlags, LPARAM lParam);

#define DICS_ENABLE                 0x00000001
#define DICS_DISABLE                0x00000002
#define DICS_PROPCHANGE         0x00000003
#define DICS_START          0x00000004
#define DICS_STOP           0x00000005

#define DICS_FLAG_GLOBAL            0x00000001
#define DICS_FLAG_CONFIGSPECIFIC    0x00000002
#define DICS_FLAG_CONFIGGENERAL     0x00000004

RETERR WINAPI DiInstallClass(LPCSTR lpszInfFileName, DWORD dwFlags);

RETERR WINAPI DiOpenClassRegKey(LPHKEY lphk, LPCSTR lpszClassName);

// support routine for dealing with class mini icons
#define DMI_MASK            0x0001
#define DMI_BKCOLOR         0x0002
#define DMI_USERECT         0x0004
int WINAPI PASCAL DiDrawMiniIcon(HDC hdc, RECT rcLine, int iMiniIcon, DWORD flags);
BOOL WINAPI DiGetClassBitmapIndex(LPCSTR lpszClass, int FAR *lpiMiniIconIndex);

// internal calls for display class
#define DISPLAY_SETMODE_SUCCESS     0x0001
#define DISPLAY_SETMODE_DRVCHANGE   0x0002
#define DISPLAY_SETMODE_FONTCHANGE  0x0004

UINT WINAPI Display_SetMode(LPDEVICE_INFO lpdi, UINT uColorRes, int iXRes, int iYRes);
RETERR WINAPI Display_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
RETERR WINAPI Display_OpenFontSizeKey(LPHKEY lphkFontSize);
BOOL WINAPI Display_SetFontSize(LPCSTR lpszFontSize);

RETERR WINAPI DiIsThereNeedToCopy(HWND hwnd, DWORD dwFlags);

#define DINTC_NOCOPYDEFAULT     0x00000001

// API for the mouse class installer
RETERR WINAPI Mouse_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
#endif // NODEVICEINSTALL

// API for determining if a Driver file is currently part of VMM32.VxD
BOOL WINAPI bIsFileInVMM32
(
    LPSTR   lpszFileName
);

// API for determining if a display is a primary or secondary
BOOL WINAPI Display_IsSecondDisplay(
    LPDEVICE_INFO lpdi
    );

// Japanese Keyboard Support
LONG _export WINAPI GetJapaneseKeyboardType();
#define JP_101KBD       0
#define JP_AXKBD        1
#define JP_106KBD       2
#define JP_003KBD       3
#define JP_001KBD       4
#define JP_TB_DESKTOP   5
#define JP_TB_LAPTOP    6
#define JP_TB_NOTEBOOK  7


#ifndef NOUSERINTERFACE
/***************************************************************************/
//
// User Interface prototypes and definitions
//
/***************************************************************************/

BOOL WINAPI UiMakeDlgNonBold(HWND hDlg);
VOID WINAPI UiDeleteNonBoldFont(HWND hDlg);

#endif

/***************************************************************************/
//
// setup reg DB calls, use just like those in kernel
//
/***************************************************************************/

DWORD WINAPI SURegOpenKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegCloseKey(HKEY hKey);
DWORD WINAPI SURegCreateKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegDeleteKey(HKEY hKey, LPCSTR lpszSubKey);
DWORD WINAPI SURegEnumKey(HKEY hKey, DWORD dwIdx, LPSTR lpszBuffer, DWORD dwBufSize);
DWORD WINAPI SURegQueryValue16(HKEY hKey, LPCSTR lpszSubKey, LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValue16(HKEY hKey, LPCSTR lpszSubKey, DWORD dwType, LPCBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegDeleteValue(HKEY hKey,LPCSTR lpszValue);
DWORD WINAPI SURegEnumValue(HKEY hKey,DWORD dwIdx, LPCSTR lpszValue, DWORD FAR *lpcbValue, DWORD FAR *lpdwReserved, DWORD FAR *lpdwType, LPBYTE lpbData, DWORD FAR *lpcbData);
DWORD WINAPI SURegQueryValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD FAR *lpdwReserved,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegSaveKey(HKEY hKey, LPCSTR lpszFileName, LPVOID lpsa);
DWORD WINAPI SURegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFileName);
DWORD WINAPI SURegUnLoadKey(HKEY hKey, LPCSTR lpszSubKey);

DWORD WINAPI SURegFlush(VOID);
DWORD WINAPI SURegInit(VOID);    // should be called before any other Reg APIs

/***************************************************************************/
// setup FormatMessage support
/***************************************************************************/
#define MB_LOG  (UINT)-1
#define MB_DBG  (UINT)-2

UINT FAR CDECL suFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    ...);
UINT WINAPI suvFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    LPVOID FAR * lpArgs);
int WINCAPI _loadds suFormatMessageBox(HINSTANCE hAppInst, HWND hwndParent, LPCSTR lpcText, LPCSTR lpcTitle,
    UINT uStyle, ...);

WORD WINAPI suErrorToIds( WORD Value, WORD Class );

/***************************************************************************/
// setup Version Conflict support
/***************************************************************************/

LPVOID WINAPI suVerConflictInit(BOOL fYesToLangMismatch);
void WINAPI suVerConflictTerm(LPVOID lpvData);
LRESULT WINAPI suVerConflict(HWND hwnd, LPVCPVERCONFLICT lpvc, BOOL bBackup, LPVOID lpvData);
int WINAPI sxCompareDosAppVer( LPCSTR lpszOldFileSpec, LPCSTR lpszNewFileSpec);


/***************************************************************************/
// setup Help support
/***************************************************************************/

BOOL WINAPI suHelp( HWND hwndApp, HWND hwndDlg );

//***************************************************************************/
// setup Emergency Boot Disk (EBD) creation fn.
//***************************************************************************/

RETERR WINAPI suCreateEBD( HWND hWnd, VIFPROC CopyCallbackProc, LPARAM lpuii );

//***************************************************************************
// Misc SETUPX.DLL support functions.
//***************************************************************************
enum  SU_ACTIONS                        // Actions msgs for Setupx()    /* ;Internal */
{                                                                       /* ;Internal */
    SUX_REGINIT,                        // Intialize registry           /* ;Internal */
    SUX_DBGLEVEL,                       // Set debug level              /* ;Internal */
    SUX_SETUPFLG,                       // Set fIsSetup flag            /* ;Internal */
    SUX_FASTSETUP,                      // Setupx => checking less mode /* ;Internal */
    SUX_FORCEREGFLUSH,                  // Call kRegFlush               /* ;Internal */
    SUX_TPSFLUSH,                       // Call TPS_Flush() fns.        /* ;Internal */
    SUX_DBGHFILE,                       // File to write messages to    /* ;Internal */
    SUX_LOADSTORELDIDS,                 // Load/store setup's LDID's    /* ;Internal */
    SUX_ENABLEREGFLUSH,                 // Enable/Disable SURegFlush() if fIsSetup  /* ;Internal */
    SUX_SETUNCPATHFUNC,                 // NOW UNUSED!!                   /* ;Internal */
    SUX_SETTRUEDISKFREEFUNC,            // Set TRUE disk free func      /* ;Internal */
    SUX_ISFLOPPYBOOT,                   // Set TRUE if floppy boot disk /* ;Internal */
    SUX_BISVER4,                        // returns bIsVer4(CHICAGO) flag/* ;Internal */
    SUX_SETCTLCALLBACKFUNC,             // Set ctlCopyCallBackProc Func /* ;Internal */
    SUX_GETCTLCALLBACKFUNC,             // Get ctlCopyCallBackProc Func /* ;Internal */
    SUX_BISMULTICFG,                    // returns SETUPX's gfMultiCfg  /* ;Internal */
    SUX_DUMPDSINFO,                     // Dumps diskspace info         /* ;Internal */
    SUX_INFCACHEOFF,                    // Turns INF file caching on/off/* ;Internal */
    SUX_SETFCDROMDRIVEEXISTS,           // Set CDRomDriveExists func    /* ;Internal */
    SUX_ALLOCRMBUFFERS,                 // Allocate real mode buffers   /* ;Internal */
    SUX_FREERMBUFFERS,                  // Free real mode buffers       /* ;Internal */
    SUX_DODOSEBDWORK                    // Do DOS EBD Work              /* ;Internal */
};                                                                      /* ;Internal */

RETERR WINAPI Setupx( UINT uMsg, WPARAM wParam, LPARAM lParam );        /* ;Internal */

RETERR WINAPI SUStoreLdidPath( LOGDISKID ldid, LPSTR lpszPath );        /* ;Internal */

BOOL WINAPI sxIsSBSServerFile( LPVIRTNODE lpVn );                       /* ;Internal */

BOOL WINAPI sxMakeUNCPath( LPSTR lpszPath );                            /* ;Internal */

typedef RETERR (CALLBACK* FBFPROC)(LPCSTR lpszFileName, LPVOID lpVoid); /* ;Internal */
RETERR WINAPI sxFindBatchFiles(HTP,int,FBFPROC,LPVOID);         /* ;Internal */

RETERR WINAPI SUGetSetSetupFlags(LPDWORD lpdwFlags, BOOL bSet);

RETERR WINAPI CfgSetupMerge( int uFlags );
BOOL WINAPI sxIsMSDOS7Running();
BOOL WINAPI IsPanEuropean();

// structure for the LPARAM argument to Setupx() for SUX_REGINIT action.    ;Internal
typedef struct _REGINIT_S { /* setupx - reg_init */                     /* ;Internal */
    LPSTR       lpszSystemFile;         // reg's base SYSTEM filename   /* ;Internal */
    LOGDISKID   ldidSystemFile;         // ldid for SYSTEM filename     /* ;Internal */
    LPSTR       lpszUserFile;           // reg's base USER filename     /* ;Internal */
    LOGDISKID   ldidUserFile;           // ldid for USER filename       /* ;Internal */
} REGINIT_S, FAR *LPREGINIT;                                            /* ;Internal */

#ifndef LPLPSTR
    typedef LPSTR (FAR *LPLPSTR);
#endif


#define         CFG_PARSE_BUFLEN 1024    // Buf sized passed line obj funcs      /* ;Internal */

LPLPSTR WINAPI  CfgParseLine( LPCSTR szLine, LPSTR Buf );                       /* ;Internal */
BOOL    WINAPI  CfgSetAutoProcess( int TrueFalse );                             /* ;Internal */
void    WINAPI  CfgObjToStr( LPLPSTR apszObj, LPSTR szLine );                   /* ;Internal */
LPLPSTR WINAPI  CfgLnToObj( HTP hSection, int Offset, int Origin, LPSTR Buf );  /* ;Internal */
LPLPSTR WINAPI  CfgObjFindKeyCmd( HTP hSec, LPCSTR szKey, LPCSTR szCmd,         /* ;Internal */
                                  int Offset, int Origin, LPSTR Buf );          /* ;Internal */
LPCSTR WINAPI   WildCardStrCmpi( LPCSTR szKey, LPCSTR szLine, LPCSTR szDelims ); /* ;Internal */
RETERR WINAPI   GenMapRootRegStr2Key( LPCSTR szRegRoot, HKEY hRegRelKey,        /* ;Internal */
                                                        HKEY FAR *lphkeyRoot ); /* ;Internal */


//***************************************************************************
//
// ENUMS for accessing config.sys/autoexec.bat line objects using the
// array returned by ParseConfigLine()..
//
//***************************************************************************

enum    CFGLINE_STRINGS                     // Config.sys/autoexec.bat objects
{
    CFG_KEYLEAD,                            // Keyword leading whitespaces
    CFG_KEYWORD,                            // Keyword
    CFG_KEYTRAIL,                           // Keyword trailing delimiters
    CFG_UMBINFO,                            // Load high info
    CFG_DRVLETTER,                          // Drive letter for cmd path
    CFG_PATH,                               // Command path
    CFG_COMMAND,                            // Command base name
    CFG_EXT,                                // Command extension including '.'
    CFG_ARGS,                               // Command arguments
    CFG_FREE,                               // Free area at end of buffer
    CFG_END
};

/*---------------------------------------------------------------------------*
 *                  SUB String Data
 *---------------------------------------------------------------------------*/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SUBSTR_DATA | Data structure used to manage substrings.
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field LPSTR | lpFirstSubstr | Pointer to the first substring in the list.
*
*   @field LPSTR | lpCurSubstr | Pointer to the current substring in the list.
*
*   @field LPSTR | lpLastSubstr | Pointer to the last substring in the list.
*
*   @xref InitSubstrData
*   @xref GetFirstSubstr
*   @xref GetNextSubstr
*
*******************************************************************************/
typedef struct _SUBSTR_DATA {
    LPSTR lpFirstSubstr;
    LPSTR lpCurSubstr;
    LPSTR lpLastSubstr;
}   SUBSTR_DATA;


typedef SUBSTR_DATA*        PSUBSTR_DATA;
typedef SUBSTR_DATA NEAR*   NPSUBSTR_DATA;
typedef SUBSTR_DATA FAR*    LPSUBSTR_DATA;

BOOL WINAPI InitSubstrData(LPSUBSTR_DATA lpSubstrData, LPSTR lpStr);
BOOL WINAPI GetFirstSubstr(LPSUBSTR_DATA lpSubstrData);
BOOL WINAPI GetNextSubstr(LPSUBSTR_DATA lpSubStrData);
BOOL WINAPI InitSubstrDataEx(LPSUBSTR_DATA lpssd, LPSTR lpString, char chDelim);  /* ;Internal */

BOOL WINAPI FirstBootMoveToDOSSTART(LPSTR lpszCmd, BOOL fRemark);
BOOL WINAPI DOSOptEnableCurCfg(LPCSTR lpszOptKey);

/*---------------------------------------------------------------------------*
 *                  Misc. Di functions
 *---------------------------------------------------------------------------*/
BOOL WINAPI DiBuildPotentialDuplicatesList
(
    LPDEVICE_INFO   lpdi,
    LPSTR           lpDuplicateList,
    DWORD           cbSize,
    LPDWORD         lpcbData,
    LPSTR           lpstrDupType
);

BOOL _loadds WINAPI WalkSubtree(DWORD dnRoot, LPSTR szDrvLet);

// PID
BOOL _loadds WINAPI PidConstruct( LPSTR lpszProductType, LPSTR lpszPID, LPSTR lpszUPI, int iAction);
BOOL _loadds WINAPI PidValidate( LPSTR lpszProductType, LPSTR lpszPID);
int _loadds WINAPI WriteDMFBootData(int iDrive, LPSTR pData, int cb);

// FirstRunScreens
RETERR WINAPI DoFirstRunScreens();

// Migration DLLs
#define SU_MIGRATE_PREINFLOAD    0x00000001	// before the setup INFs are loaded
#define SU_MIGRATE_POSTINFLOAD   0x00000002	// after the setup INFs are loaded
#define SU_MIGRATE_DISKSPACE     0x00000010	// request for the amount of additional diskspace needed
#define SU_MIGRATE_PREQUEUE      0x00000100	// before the INFs are processed and files are queued
#define SU_MIGRATE_POSTQUEUE     0x00000200	// after INFs are processed
#define SU_MIGRATE_REBOOT        0x00000400	// just before we are going to reboot for the 1st time
#define SU_MIGRATE_PRERUNONCE    0x00010000	// before any runonce items are processed
#define SU_MIGRATE_POSTRUNONCE   0x00020000	// after all runonce items are processed
DWORD WINAPI sxCallMigrationDLLs( DWORD dwStage, LPARAM lParam );
void WINAPI _loadds sxCallMigrationDLLs_RunDll(HWND, HINSTANCE, LPSTR, int);

//Count Down Dlg
int WINAPI SxShowRebootDlg(UINT, HWND);
void WINAPI _loadds SxShowRebootDlg_RunDll(HWND, HINSTANCE, LPSTR, int);

BOOL WINAPI CopyInfFile( LPSTR, LPSTR, UINT );

BOOL WINAPI IsWindowsFile( LPSTR lpszFile );

RETERR WINAPI VerifySelectedDriver(LPDEVICE_INFO lpdi, BOOL *pbYesToAll);

//Dialog positioning function and defn's(wPosFlags)
#define DLG_CENTERV         0x01
#define DLG_CENTERH         0x02
#define DLG_CENTER          DLG_CENTERV | DLG_CENTERH
#define DLG_TOP             0x04
#define DLG_BOTTOM          0x08
#define DLG_RIGHT           0x10
#define DLG_LEFT            0x20
BOOL WINAPI uiPositionDialog( HWND hwndDlg, WORD wPosFlags );

//***************************************************************************
#endif      // SETUPX_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\pgmgrp\precomp.h ===
#include <windows.h>
#include <shlobj.h>
#include <stock.h>
#include <oprahcom.h>
#include <confdbg.h>
#include <regentry.h>
#include <confreg.h>
#include <cstring.hpp>
#include <dllutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\pgmgrp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pgmgrp.rc
//
#define IDS_SETUP_RUNNING               1
#define IDS_SETUP_INCOMPATIBLE          2
#define IDS_SETUP_SUCCESS               3
#define IDS_SETUP_WIN2K                 4
#define IDS_SETUP_IE4                   5

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\setup\pgmgrp\pgmgrp.cpp ===
/*
 * NMPGMGRP - Tiny program to add and remove items from the program group.  
 * Its initial purpose is to support Windows NT common program groups, 
 * which are not supported by GRPCONV.
 *
 * Usage:
 *
 *  NMPGMGRP /add [/common] [/g:"<group name>"] /n:"<program name>" 
 *		/p:"<program path>"
 *  NMPGMGRP /delete [/common] [/g:"<group name>"] /n:"<program name>"
 *
 *  NMPGMGRP /i /n:"<src mnmdd.dll>" /p:"<dst mnmdd.dll>"   INSTALL NT DD
 *  NMPGMGRP /u /n:"<src mnmdd.dll>"                        UNINSTALL NT DD
 *
 *  NMPGMGRP /s [/q] /n:"<inf file>" /f"<friendly name>"			SETUP
 *
 *	/add is used to add a new program item.
 *	/delete is used to remove an existing program item.
 *
 *	/common indicates that this item belong in the common (as opposed to 
 *		per-user) program groups.
 *
 *	<group name> is the name of the program group, expressed as a pathname 
 *		relative to the Programs group.  For items in the Programs group, 
 *		this parameter should be omitted.
 *
 *	<program name> is the name of the program, and is also used as the name
 *		of the shortcut file itself.
 *
 *	<program path> is the full path name of the program.
 *
 *	<inf file> is the name of the installation inf.
 *
 *	<friendly name> is the text to be used for any message box title.
 *
 * Limitations:
 *
 *	Because some of these strings may contain spaces, the group name, program
 *	name, and program path MUST be enclosed in quotes.  Currently we do not
 *	support strings with quotes in them.
 *
 *	Some of the system functions used in this program are Unicode
 *	specific, so this program will require some modifications to run on
 *	Windows 95.
 *
 * Author:
 *	DannyGl, 23 Mar 97
 */

#include "precomp.h"
#include "resource.h"

#include <nmremote.h>

#pragma intrinsic(memset)

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// DEBUG only -- Define debug zone
#ifdef DEBUG
HDBGZONE ghZone = NULL;  // Node Controller Zones
static PTCHAR rgZones[] = {
	TEXT("NMPgmGrp")
};
#endif // DEBUG


// PROGRAM_ITEM_INFO structure:
//
// Intended to be passed as input to the CreateProgramItem and 
// DeleteProgramItem functions.  Fields are:
//		
//		pszProgramGroup - The full path of the program group in which the
//			item is to be stored.
//		pszProgramName - The name of the program item.
//		pszProgramPath - The full path of the program.

typedef
struct tagProgramItemInfo
{
	PTSTR pszProgramGroup;
	PTSTR pszProgramName;
	PTSTR pszProgramPath;
} PROGRAM_ITEM_INFO, *PPROGRAM_ITEM_INFO;


// Command line option data
enum tagGroupOperation
{
	GRPOP_NONE = 0,
	GRPOP_ADD,
	GRPOP_DEL,
    GRPOP_NTDDINSTALL,
    GRPOP_NTDDUNINSTALL,
    GRPOP_SETUP
} g_goAction;

BOOL g_fCommonGroup = FALSE;
PTSTR g_pszGroupName = NULL;
PTSTR g_pszProgramName = NULL;
PTSTR g_pszProgramPath = NULL;
PTSTR g_pszFriendlyName = NULL;
BOOL g_fQuietInstall = FALSE;

const TCHAR g_cszSetupDll[] = TEXT("advpack.dll");
const TCHAR g_cszSetupEntry[] = TEXT("LaunchINFSection");
typedef int (CALLBACK * PFNSETUPENTRY)(HWND hwnd, HINSTANCE hinst, LPTSTR lpszCmdLine, int nCmdShow);


// ProcessCommandLineArgs: 
//
// Get the command line and parse it into individual parameters using the
// above global variables.
//
// Return: TRUE on success, FALSE if it could not parse the command line.
BOOL
ProcessCommandLineArgs(void)
{
	PTSTR pszTemp;

	pszTemp = GetCommandLine();

	// Search for forward slashes
	pszTemp = (PTSTR) _StrChr(pszTemp, TEXT('/'));

	while (NULL != pszTemp)
	{
		PTSTR *ppszCurrentArg = NULL;

		switch(*++pszTemp)
		{
		case TEXT('S'):
		case TEXT('s'):
			ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
			g_goAction = GRPOP_SETUP;
			break;

        case TEXT('I'):
        case TEXT('i'):
            //
            // Install NT-specific display driver stuff
            //
            ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
            g_goAction = GRPOP_NTDDINSTALL;
            break;

        case TEXT('U'):
        case TEXT('u'):
            //
            // Uninstall NT-specific display driver stuff
            //
            ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
            g_goAction = GRPOP_NTDDUNINSTALL;
            break;

		case TEXT('A'):
		case TEXT('a'):
			ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
			g_goAction = GRPOP_ADD;
			break;

		case TEXT('D'):
		case TEXT('d'):
			ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
			g_goAction = GRPOP_DEL;
			break;

		case TEXT('C'):
		case TEXT('c'):
			ASSERT(! g_fCommonGroup); // Check for duplicate parameter
			g_fCommonGroup = TRUE;
			break;

		case TEXT('Q'):
		case TEXT('q'):
			g_fQuietInstall = TRUE;
			break;

		case TEXT('G'):
		case TEXT('g'):
			if (NULL == ppszCurrentArg)
			{
				ppszCurrentArg = &g_pszGroupName;
			}

			// NO break HERE -- fall through

		case TEXT('N'):
		case TEXT('n'):
			if (NULL == ppszCurrentArg)
			{
				ppszCurrentArg = &g_pszProgramName;
			}

			// NO break HERE -- fall through

		case TEXT('P'):
		case TEXT('p'):
			if (NULL == ppszCurrentArg)
			{
				ppszCurrentArg = &g_pszProgramPath;
			}

			// NO break HERE -- fall through

		case TEXT('F'):
		case TEXT('f'):
			if (NULL == ppszCurrentArg)
			{
				ppszCurrentArg = &g_pszFriendlyName;
			}

			// ***** Processing for all string parameters *****

			ASSERT(NULL == *ppszCurrentArg); // Check for duplicate parameter

			// Save the string pointer after skipping past the colon and open quote
			ASSERT(TEXT(':') == pszTemp[1] && TEXT('\"') == pszTemp[2]);
			*ppszCurrentArg = pszTemp += 3;

			// Find the closing quote and set it to null, then skip past it
			// Note that we don't handle strings with quotes in them.
			pszTemp = (PTSTR) _StrChr(pszTemp, TEXT('\"'));
			ASSERT(NULL != pszTemp);
			if (NULL != pszTemp)
			{
				*pszTemp++ = TEXT('\0');
			}
			else
			{
				return FALSE;
			}

			break;

		default:
			ERROR_OUT(("Unknown parameter begins at %s", pszTemp));
			return FALSE;

			break;
		}

		// Find the next option flag
		ASSERT(NULL != pszTemp);
		pszTemp = (PTSTR) _StrChr(pszTemp, TEXT('/'));
	}

	// Return based on minimal parameter validation:
	// 1) The program name must be specified.
	// 2) Either add or delete must be specified.
	// 3) If add is specified, the program path must be specified
    switch (g_goAction)
    {
        case GRPOP_ADD:
        case GRPOP_NTDDINSTALL:
            return((NULL != g_pszProgramName) && (NULL != g_pszProgramPath));

        case GRPOP_DEL:
        case GRPOP_NTDDUNINSTALL:
            return(NULL != g_pszProgramName);

        case GRPOP_SETUP:
            return((NULL != g_pszProgramName) && (NULL != g_pszFriendlyName));

        default:
            return(FALSE);
    }
}

// GetFolderPathname:
//
// Use the official shell interfaces to retrieve the full pathname of a
// a programs folder.
//
// Input: 
//		ptstrPath, ccPath - The pointer to a size of the buffer in
//			which to store the path.
//		nFolder - The folder to locate, expressed as a CSIDL constant.  
//			See SHGetSpecialFolderLocation for details.
//		pctstrSubFolder - A specific subfolder, can be NULL if not specified.
//			If specified, this is appended (after a backslash) to the path.
//
// Returns:
//		An HRESULT to indicate success or failure of the Shell methods.
//		The path is returned in <ptstrPath>.

HRESULT 
GetFolderPathname(
	PTSTR ptstrPath,
	UINT cchPath,
	int nFolder,
	LPCTSTR pctstrSubFolder)
{
	HRESULT hr;
	LPMALLOC pMalloc = NULL;
	LPSHELLFOLDER pDesktopFolder = NULL;
	LPITEMIDLIST pidlSpecialFolder = NULL;

	// Get the allocator object
	hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

	// Get the desktop object
	if (SUCCEEDED(hr))
	{
		hr = SHGetDesktopFolder(&pDesktopFolder);
	}

	// Get the special folder item ID
	if (SUCCEEDED(hr))
	{
		hr = SHGetSpecialFolderLocation(
				GetDesktopWindow(),
				nFolder,
				&pidlSpecialFolder);
	}

	// Retrieve the folder name
	STRRET strFolder;

	if (SUCCEEDED(hr))
	{
		strFolder.uType = STRRET_WSTR;

		hr = pDesktopFolder->GetDisplayNameOf(
				pidlSpecialFolder,
				SHGDN_FORPARSING,
				&strFolder);
	}

	if (SUCCEEDED(hr))
	{
		CUSTRING custrPath;

		switch(strFolder.uType)
		{
		case STRRET_WSTR:
			custrPath.AssignString(strFolder.pOleStr);

			break;

		case STRRET_OFFSET:
			custrPath.AssignString(((LPSTR) pidlSpecialFolder) + strFolder.uOffset);

			break;

		case STRRET_CSTR:
			custrPath.AssignString(strFolder.cStr);

			break;
		}

		if(NULL != (PTSTR) custrPath)
			lstrcpyn(ptstrPath, custrPath, cchPath);
		else
			*ptstrPath = _TEXT('\0');

		if (STRRET_WSTR == strFolder.uType)
		{
			pMalloc->Free(strFolder.pOleStr);
		}

	}

	// Append subgroup name, if it's specified
	if (SUCCEEDED(hr) && NULL != pctstrSubFolder)
	{
		// BUGBUG - We don't create this folder if it doesn't already exist

		int cchLen = lstrlen(ptstrPath);

		ASSERT((UINT) cchLen < cchPath);

		// Insert a path separator
		ptstrPath[cchLen++] = TEXT('\\');

		// Copy the subgroup
		lstrcpyn(ptstrPath + cchLen, pctstrSubFolder, cchPath - cchLen);
	}

	// Release resources
	if (pDesktopFolder)
	{
		pDesktopFolder->Release();
	}

	if (pMalloc)
	{
		if (pidlSpecialFolder)
		{
			pMalloc->Free(pidlSpecialFolder);
		}

		pMalloc->Release();
	}

	return hr;
}

// BuildLinkFileName:
//
// Inline utility function to construct the full file name of a link given its
// directory name and item name.
inline void
BuildLinkFileName(
	OUT LPWSTR wszOutputPath,
	IN LPCTSTR pcszDirectory,
	IN LPCTSTR pcszFile)
{
	// The file name is of the form <directory>\<file>.LNK

#ifdef UNICODE
	static const WCHAR wszFileFormat[] = L"%s\\%s.LNK";
#else // UNICODE
	static const WCHAR wszFileFormat[] = L"%hs\\%hs.LNK";
#endif // UNICODE
	int cchSize;

	cchSize = wsprintfW(
				wszOutputPath, 
				wszFileFormat,
				pcszDirectory,
				pcszFile);

	ASSERT(cchSize > ARRAY_ELEMENTS(wszFileFormat) - 1 && cchSize < MAX_PATH);
}


// CreateProgramItem:
//
// Use the official shell interfaces to create a shortcut to a program.
//
// Input: A pointer to a PROGRAM_ITEM_INFO structure, defined above.
//
// Returns:
//		An HRESULT to indicate success or failure of the Shell methods.

HRESULT
CreateProgramItem(
	PPROGRAM_ITEM_INFO ppii)
{
	HRESULT hr;
	IShellLink *psl = NULL;
	IPersistFile *ppf = NULL;

	// Get the shell link object
	hr = CoCreateInstance(
			CLSID_ShellLink,
			NULL,
			CLSCTX_INPROC,
			IID_IShellLink,
			(LPVOID *) &psl);

	// Fill in the fields of the program group item
	if (SUCCEEDED(hr))
	{
		hr = psl->SetDescription(ppii->pszProgramName);
	}

	if (SUCCEEDED(hr))
	{
		hr = psl->SetPath(ppii->pszProgramPath);
	}

	// Save the link as a file
	if (SUCCEEDED(hr))
	{
		hr = psl->QueryInterface(IID_IPersistFile, (LPVOID *) &ppf);
	}

	if (SUCCEEDED(hr))
	{
		WCHAR wszFileName[MAX_PATH];

		BuildLinkFileName(
			wszFileName,
			ppii->pszProgramGroup,
			ppii->pszProgramName);

		hr = ppf->Save(wszFileName, TRUE);
	}

	// Release the objects we used
	if (ppf)
	{
		ppf->Release();
	}		

	if (psl)
	{
		psl->Release();
	}

	return hr;
}


// DeleteProgramItem:
//
// Delete a shortcut to a program.
//
// Input: A pointer to a PROGRAM_ITEM_INFO structure, defined above.
//
// Returns:
//		An HRESULT to indicate success or failure of the Shell methods.

HRESULT
DeleteProgramItem(
	PPROGRAM_ITEM_INFO ppii)
{
	HRESULT hr = S_OK;

	WCHAR wszFileName[MAX_PATH];

	BuildLinkFileName(
		wszFileName,
		ppii->pszProgramGroup,
		ppii->pszProgramName);

	if (! DeleteFileW(wszFileName))
	{
		WARNING_OUT(("DeleteFile failed"));
		hr = E_FAIL;
	}

	return hr;
}


//
// NtDDInstall()
// This does NT-specific display driver install stuff, which depends on 
// whether it's NT4 or NT5
//
//
HRESULT NtDDInstall(LPTSTR pszOrigDd, LPTSTR pszNewDd)
{
    HRESULT         hr = E_FAIL;
    OSVERSIONINFO   osvi;
    RegEntry        re(NM_NT_DISPLAY_DRIVER_KEY, HKEY_LOCAL_MACHINE, FALSE);

    //
    // If NT4, set service key to disabled
    // If NT5, copy mnmdd.dll from NM dir to cur (system32) dir
    //
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (!GetVersionEx(&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed"));
        goto AllDone;        
    }

    if ((osvi.dwPlatformId == VER_PLATFORM_WIN32s) ||
        (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))
    {
        WARNING_OUT(("NT setup running on non-NT platform!"));
        goto AllDone;
    }

    if (osvi.dwMajorVersion >= 5)
    {
        //
        // This is NT5.  Always set the service key to enabled (in case
        // the end user managed to munge it) and copy mnmdd.dll to the 
        // current (system) directory.  For example, if somebody had a
        // stand-alone version of a beta, uninstalled it, then installed
        // NM 3.0 proper--or same for 2.11.
        //
        re.SetValue(REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED, NT_DRIVER_START_SYSTEM);

        if (!CopyFile(pszOrigDd, pszNewDd, FALSE))
        {
            WARNING_OUT(("CopyFile from %s to %s failed", pszOrigDd, pszNewDd));
            goto AllDone;
        }
    }
    else
    {
        // This is NT4.  Set the disabled service key
        re.SetValue(REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED, NT_DRIVER_START_DISABLED);
    }

    hr = S_OK;

AllDone:
    return(hr);
}



//
// NtDDUninstall()
// This does NT-specific display driver uninstall stuff, which depends
// on whether it's NT4 or NT5
//
HRESULT NtDDUninstall(LPTSTR pszOrigFile)
{
    HRESULT         hr = E_FAIL;
    OSVERSIONINFO   osvi;

    //
    // If NT4, set service key to disabled
    // If NT5, delete mnmdd.dll from cur (system32) dir
    //
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (!GetVersionEx(&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed"));
        goto AllDone;
    }

    if ((osvi.dwPlatformId == VER_PLATFORM_WIN32s) ||
        (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))
    {
        ERROR_OUT(("NT setup running on non-NT platform!"));
        goto AllDone;
    }

    if (osvi.dwMajorVersion >= 5)
    {
        // This is NT5.  Delete mnmdd.dll from the current (system) directory
        if (!DeleteFile(pszOrigFile))
        {
            WARNING_OUT(("DeleteFile of %s failed", pszOrigFile));
            goto AllDone;
        }
    }
    else
    {
        // This is NT4.  Set the disabled service key
		RegEntry re(NM_NT_DISPLAY_DRIVER_KEY, HKEY_LOCAL_MACHINE, FALSE);

        re.SetValue(REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED,
            NT_DRIVER_START_DISABLED);
    }

    hr = S_OK;

AllDone:
    return(hr);
}

UINT _MessageBox(HINSTANCE hInst, UINT uID, LPCTSTR lpCaption, UINT uType)
{
	TCHAR szText[512];

	if (0 != LoadString(hInst, uID, szText, CCHMAX(szText)))
	{
		return MessageBox(NULL, szText, lpCaption, uType);
	}

	return IDCANCEL;
}

#define CONF_INIT_EVENT     TEXT("CONF:Init")

BOOL FIsNetMeetingRunning()
{
    HANDLE hEvent;

    hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_STOP_EVENT);
	if (hEvent)
	{
		CloseHandle(hEvent);
		return TRUE;
	}

    hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, CONF_INIT_EVENT);
	if (hEvent)
	{
		CloseHandle(hEvent);
		return TRUE;
	}

	return FALSE;
}

BOOL FIsNT5()
{
    OSVERSIONINFO   osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (GetVersionEx(&osvi))
	{
		if ((osvi.dwPlatformId != VER_PLATFORM_WIN32s) &&
			(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS))
		{
			if (osvi.dwMajorVersion >= 5)
			{
				return TRUE;
			}
		}
	}
	else
    {
        ERROR_OUT(("GetVersionEx() failed"));
    }
	return FALSE;
}

#define IE4_KEY				TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Last Update\\IEXPLOREV4")

BOOL FIsIE4Installed()
{
    RegEntry re(IE4_KEY, HKEY_LOCAL_MACHINE, FALSE);
	if (ERROR_SUCCESS != re.GetError())
	{
		return FALSE;
	}

	return TRUE;
}

#define INTEL_KEY1			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\vphone.exe")
#define INTEL_KEY2			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\rvp.exe")
#define INTEL_KEY3			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\vp30.exe")
#define INTEL_NM_VERSION_SZ	TEXT("NetMeeting")
#define INTEL_NM_VERSION_DW	3

#define PANTHER_KEY				TEXT("CLSID\\{690968D0-418C-11D1-8E0B-00A0C95A83DA}\\Version")
#define PANTHER_VERSION_VALUE	TEXT("1.0")

#define	TRANSPORTS_KEY	TEXT("SOFTWARE\\Microsoft\\Conferencing\\Transports")

#define	REGKEY_PSTN		TEXT("PSTN")
#define	REGKEY_TCPIP	TEXT("TCPIP")
#define	REGKEY_IPX		TEXT("IPX")
#define	REGKEY_NETBIOS	TEXT("NETBIOS")
#define	REGKEY_DIRCB	TEXT("DIRCB")


long GetIntelVersion(LPCTSTR pszKey)
{
    RegEntry re(pszKey, HKEY_LOCAL_MACHINE, FALSE);
	if (ERROR_SUCCESS != re.GetError())
	{
		return -1;
	}

	return re.GetNumber(INTEL_NM_VERSION_SZ, 0);
}

BOOL FAnyBadIntelApps()
{
	long lVersion;

	lVersion = GetIntelVersion(INTEL_KEY1);
	if (0 > lVersion)
	{
		lVersion = GetIntelVersion(INTEL_KEY2);
		if (0 > lVersion)
		{
			lVersion = GetIntelVersion(INTEL_KEY3);
		}
	}

	return ((0 <= lVersion) && (3 > lVersion));
}

BOOL FAnyBadPantherApps()
{
    RegEntry re(PANTHER_KEY, HKEY_CLASSES_ROOT, FALSE);
	if (ERROR_SUCCESS != re.GetError())
	{
		return FALSE;
	}

	LPCTSTR pszVersion = re.GetString(TEXT(""));

	return 0 == lstrcmp(pszVersion, PANTHER_VERSION_VALUE);
}

BOOL FAnyUnknownTransports()
{
    RegEntry        TransportsKey(TRANSPORTS_KEY, HKEY_LOCAL_MACHINE, FALSE);
    RegEnumSubKeys  EnumTransports(&TransportsKey);

    while( 0 == EnumTransports.Next() )
	{
		LPCTSTR pszName = EnumTransports.GetName();

		if ((0 != lstrcmpi(pszName, REGKEY_PSTN)) &&
			(0 != lstrcmpi(pszName, REGKEY_TCPIP)) &&
			(0 != lstrcmpi(pszName, REGKEY_IPX)) &&
			(0 != lstrcmpi(pszName, REGKEY_NETBIOS)) &&
			(0 != lstrcmpi(pszName, REGKEY_DIRCB)))
		{
			return TRUE;
		}
    }

	return FALSE;
}

BOOL FAnyIncompatibleApps()
{
	return FAnyUnknownTransports() || FAnyBadIntelApps() || FAnyBadPantherApps();
}

HRESULT Setup(HINSTANCE hInst, LPTSTR pszInfFile, LPTSTR pszFriendlyName, BOOL fQuietInstall)
{
	if (FIsNT5())
	{
		_MessageBox(hInst, IDS_SETUP_WIN2K, pszFriendlyName, MB_OK);
		// if the SHFT-CTRL was pressed continue with the install, else exit
		if ((0 == GetAsyncKeyState(VK_CONTROL)) ||
			(0 == GetAsyncKeyState(VK_SHIFT)))
		{
			return S_FALSE;
		}
	}


	if (!FIsIE4Installed())
	{
		_MessageBox(hInst, IDS_SETUP_IE4, pszFriendlyName, MB_OK);
		return S_FALSE;
	}
	
	while (FIsNetMeetingRunning())
	{
		if (IDCANCEL == _MessageBox(hInst, IDS_SETUP_RUNNING, pszFriendlyName, MB_OKCANCEL))
		{
			return S_FALSE;
		}
	}

	if (!fQuietInstall)
	{
		if (FAnyIncompatibleApps())
		{
			if (IDNO == _MessageBox(hInst, IDS_SETUP_INCOMPATIBLE, pszFriendlyName, MB_YESNO))
			{
				return S_FALSE;
			}
		}
	}

	HRESULT hr = S_FALSE;

	HINSTANCE hLib = NmLoadLibrary(g_cszSetupDll,TRUE);
	if (NULL != hLib)
	{
		PFNSETUPENTRY pfnEntry = (PFNSETUPENTRY)GetProcAddress(hLib, g_cszSetupEntry);
		if (pfnEntry)
		{
			TCHAR szArgs[MAX_PATH];
			lstrcpyn(szArgs, pszInfFile, ARRAYSIZE(szArgs));
			if (fQuietInstall)
			{
				lstrcat(szArgs, TEXT(",,1,N"));
			}
			else
			{
				lstrcat(szArgs, TEXT(",,,N"));
			}

			int iRet = pfnEntry(NULL, GetModuleHandle(NULL), szArgs, SW_SHOWNORMAL);
			if (0 == iRet)
			{
				if (!fQuietInstall)
				{
					_MessageBox(hInst, IDS_SETUP_SUCCESS, pszFriendlyName, MB_OK);
				}

				hr = S_OK;
			}
		}
		else
		{
			ERROR_OUT(("Could not find setup DLL entry point"));
		}
		FreeLibrary(hLib);
	}
	else
	{
		ERROR_OUT(("Could not load setup DLL"));
	}

	return hr;
}


// main:
//
// The entry point of the program, it pulls everything together using the
// above utility functions.

void __cdecl
main(
    void)
{
	HRESULT hr;
    HINSTANCE hInstance;
	BOOL fErrorReported = FALSE;
	TCHAR szFolderPath[MAX_PATH];

	// Initialization
    hInstance = GetModuleHandle(NULL);
	DBGINIT(&ghZone, rgZones);
    DBG_INIT_MEMORY_TRACKING(hInstance);

	hr = CoInitialize(NULL);

	// Process the command line.
	if (SUCCEEDED(hr))
	{
		hr = ProcessCommandLineArgs() ? S_OK : E_INVALIDARG;
	}
	else if (!fErrorReported)
	{
		ERROR_OUT(("CoInitialize fails"));
		fErrorReported = TRUE;
	}

	// Retreive the path of the Programs folder
	if (SUCCEEDED(hr))
	{
        if ((g_goAction != GRPOP_NTDDINSTALL) &&
			(g_goAction != GRPOP_NTDDUNINSTALL) &&
			(g_goAction != GRPOP_SETUP))
        {
    		hr = GetFolderPathname(
	    		szFolderPath, 
		    	CCHMAX(szFolderPath), 
			    g_fCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
    			g_pszGroupName);
        }
	}
	else if (!fErrorReported)
	{
		ERROR_OUT(("Invalid command line parameters specified."));
		fErrorReported = TRUE;
	}

	// Add or delete the program item, as appropriate
	if (SUCCEEDED(hr))
	{
		PROGRAM_ITEM_INFO pii;

		switch(g_goAction)
		{
        case GRPOP_NTDDINSTALL:
            //
            // Hack:  Use program name for source mnmdd.dll
            //        Use program path for dest mnmdd.dll
            //
            hr = NtDDInstall(g_pszProgramName, g_pszProgramPath);
            break;

        case GRPOP_NTDDUNINSTALL:
            //
            // Hack:  Use program name for source mnmdd.dll
            //
            hr = NtDDUninstall(g_pszProgramName);
            break;

		case GRPOP_ADD:
			pii.pszProgramGroup = szFolderPath;
			pii.pszProgramName = g_pszProgramName;
			pii.pszProgramPath = g_pszProgramPath;

			hr = CreateProgramItem(&pii);

			break;

		case GRPOP_DEL:
			pii.pszProgramGroup = szFolderPath;
			pii.pszProgramName = g_pszProgramName;

			hr = DeleteProgramItem(&pii);

			break;

        case GRPOP_SETUP:
            hr = Setup(hInstance, g_pszProgramName, g_pszFriendlyName, g_fQuietInstall);
            break;

		default:
			ERROR_OUT(("No operation type specified"));
			hr = E_INVALIDARG;

			break;
		}			
	}
	else if (!fErrorReported)
	{
		ERROR_OUT(("GetFolderPathname returns %lu", hr));
		fErrorReported = TRUE;
	}


	// Process cleanup
	CoUninitialize();
	 
	DBG_CHECK_MEMORY_TRACKING(hInstance);	   
	DBGDEINIT(&ghZone);

	ExitProcess(SUCCEEDED(hr) ? 0 : 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\clutil.h ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _CL_UTIL_H_
#define _CL_UTIL_H_


////////////////////
// Reference Count
class RefCount
{
private:
   LONG m_cRef;

public:
   RefCount();
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount();

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};



//////////////////////
// Notification Sink
class CNotify
{
private:
    DWORD  m_dwCookie;
	IUnknown * m_pUnk;
    IConnectionPoint           * m_pcnp;
    IConnectionPointContainer  * m_pcnpcnt;
public:
    CNotify(void);
    ~CNotify();

    HRESULT Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN);
    HRESULT Disconnect(void);

    IUnknown * GetPunk() {return m_pUnk;}
};


///////////
// OBLIST

#define POSITION COBNODE*

struct COBNODE
{
	POSITION	pNext;
	void*		pItem;
};

class COBLIST
{
protected:
	POSITION m_pHead;
	POSITION m_pTail;
	int      m_cItem;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
                       { return(pItemToCompare == pComparator); }
public:
	COBLIST() : m_pHead(NULL), m_pTail(NULL), m_cItem(0) { }
    virtual         ~COBLIST();
	
	virtual void *  RemoveAt(POSITION rPos);
    void            EmptyList();
	POSITION	    AddTail(void* pItem);
	void *		    GetNext(POSITION& rPos);
    void *          SafeGetFromPosition(POSITION rPos);
    POSITION        GetPosition(void* pItem);
    POSITION        Lookup(void* pComparator);
	POSITION	    GetHeadPosition()  { return (m_pHead); }
	POSITION	    GetTailPosition()  { return (m_pTail); }
	BOOL		    IsEmpty()          { return (!m_pHead); }
	int             GetItemCount()     { return (m_cItem); }
#ifdef DEBUG
	void *		    GetHead();
	void *		    GetTail();
	void *		    RemoveHead();
	void *	        RemoveTail();
	void *		    GetFromPosition(POSITION rPos);
#else
	void *		    GetHead()          { return GetFromPosition(GetHeadPosition());}
	void *          GetTail()          { return m_pTail->pItem;}
	void *		    RemoveHead()       { return RemoveAt(m_pHead); }
	void *	        RemoveTail()       { return RemoveAt(m_pTail); }
	void *		    GetFromPosition(POSITION rPos){return(rPos->pItem);}
#endif
};

// Utility Functions
POSITION AddNode(PVOID pv, COBLIST ** ppList);
PVOID RemoveNode(POSITION * pPos, COBLIST *pList);



////////////
// BSTRING

class BSTRING
{
private:
	BSTR   m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#if !defined(UNICODE)
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // !defined(UNICODE)

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}
	inline LPBSTR GetLPBSTR(void);
};


BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		m_bstr = SysAllocString(lpcwString);
		//ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	//ASSERT(NULL == m_bstr);

	return &m_bstr;
}

class BTSTR
{
private:
	LPTSTR m_psz;

public:
	BTSTR(BSTR bstr);
	~BTSTR();

	// Cast to BSTR
	operator LPTSTR() {return (NULL == m_psz) ? TEXT("<null>") : m_psz;}
};

LPTSTR PszFromBstr(BSTR bst);


#endif  // _CL_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\cconf.h ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CCONF.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

class CMgrNotify : public RefCount, public CNotify, public INmManagerNotify, public IAppSharingNotify
{
public:
	CMgrNotify();
	~CMgrNotify();

        // IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

 	// ICNotify methods
	STDMETHODIMP Connect (IUnknown *pUnk);
	STDMETHODIMP Disconnect(void);

	// INmManagerNotify
	STDMETHODIMP NmUI(CONFN confn);
	STDMETHODIMP ConferenceCreated(INmConference *pConference);
	STDMETHODIMP CallCreated(INmCall *pNmCall);

        // IAppSharingNotify
        STDMETHODIMP OnReadyToShare(BOOL fReady);
        STDMETHODIMP OnShareStarted();
        STDMETHODIMP OnSharingStarted();
        STDMETHODIMP OnShareEnded();
        STDMETHODIMP OnPersonJoined(IAS_GCC_ID gccID);
        STDMETHODIMP OnPersonLeft(IAS_GCC_ID gccID);
        STDMETHODIMP OnStartInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnStopInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnPausedInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnUnpausedInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnControllable(BOOL fControllable);
        STDMETHODIMP OnStartControlled(IAS_GCC_ID gccControlledBy);
        STDMETHODIMP OnStopControlled(IAS_GCC_ID gccControlledBy);
        STDMETHODIMP OnPausedControlled(IAS_GCC_ID gccControlledBy);
        STDMETHODIMP OnUnpausedControlled(IAS_GCC_ID gccControlledBy);
};


class CConfNotify : public RefCount, public CNotify, public INmConferenceNotify
{
public:
	CConfNotify();
	~CConfNotify();

	// INmConferenceNotify
	HRESULT STDMETHODCALLTYPE NmUI(CONFN uNotify);
	HRESULT STDMETHODCALLTYPE StateChanged(NM_CONFERENCE_STATE uState);
	HRESULT STDMETHODCALLTYPE MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pfMember);
	HRESULT STDMETHODCALLTYPE ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);

	// ICNotify methods
	HRESULT STDMETHODCALLTYPE Connect (IUnknown *pUnk);
	HRESULT STDMETHODCALLTYPE Disconnect(void);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
};


const WM_CREATEDATA = 0x07181975;

// Global Variables
extern INmManager2 * g_pMgr;
extern INmConference * g_pConference;
extern IAppSharing * g_pAS;


// Global Functions
HRESULT InitConfMgr(void);
VOID FreeConfMgr(void);
VOID FreeConference(void);
HRESULT HookConference(INmConference * pConference);
VOID SvcSetOptions(VOID);
BOOL ServiceCtrlHandler(DWORD dwCtrlType);

#define IS_NT (g_osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
extern OSVERSIONINFO g_osvi;  					// The os version info structure global
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\dbg.cpp ===
#include "precomp.h"
#pragma hdrstop

#ifdef DEBUG /*** THIS WHOLE FILE ***/

unsigned long g_BreakAlloc = (unsigned long)-1;

/*  U P D A T E  C R T  D B G  S E T T I N G S  */
/*-------------------------------------------------------------------------
    %%Function: UpdateCrtDbgSettings

    Update the C runtime debug memory settings
-------------------------------------------------------------------------*/
VOID UpdateCrtDbgSettings(void)
{
#if 0
	// This depends on the use of the debug c runtime library
	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Always enable memory leak checking debug spew
	// tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

	// Release memory just like the retail version
	tmpFlag &= ~_CRTDBG_DELAY_FREE_MEM_DF;

	// Don't bother checking the entire heap
	tmpFlag &= ~_CRTDBG_CHECK_ALWAYS_DF;
	
	_CrtSetDbgFlag(tmpFlag);
#endif // 0
}

#if 0
int _cdecl MyAllocHook ( int allocType, void *userData,
			size_t size, int blockType,
			long requestNumber, const char *filename, int lineNumber )
{
	char buf[256];
	wsprintf(buf, "%s {%d}: %d bytes on line %d file %s\n\r",
					allocType == _HOOK_ALLOC ? "ALLOC" :
					( allocType == _HOOK_REALLOC ? "REALLOC" : "FREE" ),
					requestNumber,
					size, lineNumber, filename );
	OutputDebugString(buf);
	return TRUE;
}
#endif // 0 

/*  I N I T  D E B U G  M E M O R Y  O P T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: InitDebugMemoryOptions

    Initilize the runtime memory
-------------------------------------------------------------------------*/
BOOL InitDebugMemoryOptions(void)
{
#if 0
	// _asm int 3; chance to set _crtBreakAlloc - use debugger or uncomment
	_CrtSetBreakAlloc(g_BreakAlloc);

	UpdateCrtDbgSettings();

	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW); // create a message box on errors

	{	//  To track down memory leaks, set cAlloc to the allocation number
		LONG cAlloc = 0; // Allocation number
		if (0 != cAlloc)
			_CrtSetBreakAlloc(cAlloc);
	}

	#ifdef MNMSRVC_SETALLOCHOOK
	_CrtSetAllocHook ( MyAllocHook );
	#endif // MNMSRVC_SETALLOCHOOK
#endif // 0
	return TRUE;
}

VOID DumpMemoryLeaksAndBreak(void)
{
#if 0
	if ( _CrtDumpMemoryLeaks() )
	{
		// _asm int 3; Uncomment to break after leak spew
	}
#endif // 0
}

#endif /* DEBUG - whole file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\cconf.cpp ===
//****************************************************************************
//  File:       CCONF.CPP
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#include <precomp.h>
#include "srvccall.h"
#include "cstring.hpp"

#define ZERO_DELAY "0"

const int SERVICE_IN_CALL = 1001;
const int SERVICE_NOT_IN_CALL = 1000;

// Global Variables
INmManager2 * g_pMgr  = NULL;             // The Conference Manager
CMgrNotify * g_pMgrNotify = NULL;        // Notifications for the Manager
INmConference * g_pConference = NULL;    // The Current Conference
CConfNotify * g_pConferenceNotify =NULL; // Notifications for the Conference
INmSysInfo2 * g_pNmSysInfo     = NULL;   // Interface to SysInfo
IAppSharing * g_pAS = NULL;             // Interface to AppSharing
int g_cPersonsInConf = 0;
int g_cPersonsInShare = 0;
extern BOOL g_fInShutdown;

// UI integration
HANDLE g_hCallEvent = NULL;                // Event which is created when service is in a call

CHAR szConfName[64];
static BOOL RunScrSaver(void);

/*  I N I T  C O N F  M G R  */
/*-------------------------------------------------------------------------
    %%Function: InitConfMgr

-------------------------------------------------------------------------*/
HRESULT InitConfMgr(void)
{
    HRESULT hr;
    LPCLASSFACTORY pcf;

    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
    PBYTE pbPassword = NULL;
    DWORD cbPassword = 0;
    BSTR bstrPassword = NULL;

    if (!IS_NT)
    {
        cbPassword = reLM.GetBinary(REMOTE_REG_PASSWORD, (void **) &pbPassword);
        // Require a password
        if ( !cbPassword )
        {
            ERROR_OUT(("Attempt to launch service with no password."));
            return E_ACCESSDENIED;
        }
        
        bstrPassword = SysAllocStringByteLen((char *)pbPassword, cbPassword);
        if (NULL == bstrPassword)
        {
            ERROR_OUT(("Out of memory."));
            return E_OUTOFMEMORY;
        }
    }
        

    TRACE_OUT(("InitConfMgr"));

    // Add local atom to indicate alternate-desktop services are needed
    AddAtom("NMSRV_ATOM");

    // Parts of the CLSID_NmManager2 interface are not path-independent
    // and depend on the netmeeting install directory being on the
    // module load path. If this .exe is not in that dir, there may be
    // problems (loadlib, thunk connect, etc.) so set the current dir
    // to the netmeeting install dir.

    TCHAR szInstallDir[MAX_PATH];
    if ( GetInstallDirectory(szInstallDir))
    {
        if ( !SetCurrentDirectory(szInstallDir) )
        {
            ERROR_OUT(("Could not set current directory to %s", szInstallDir));
        }
    }
    else
    {
        ERROR_OUT(("Could not get netmeeting install directory"));
    }

    ASSERT(!g_pMgr);

    // Notify the system we want to use the conferencing services
    // by creating a conference manager object
    hr = CoGetClassObject(CLSID_NmManager2,
                          CLSCTX_INPROC,
                          NULL,
                          IID_IClassFactory,
                          (void**)&pcf);
    if (SUCCEEDED(hr))
    {
        // Get the conference manager object
        hr = pcf->CreateInstance(NULL, IID_INmManager2, (void**)&g_pMgr);
        if (SUCCEEDED(hr))
        {
            // Connect to the conference manager object
            g_pMgrNotify = new CMgrNotify();

            if (NULL != g_pMgrNotify)
            {
                hr = g_pMgrNotify->Connect(g_pMgr);
                if (SUCCEEDED(hr))
                {
                    ULONG uchCaps = CAPFLAG_DATA | CAPFLAG_H323_CC;

                    hr = g_pMgr->Initialize(NULL, &uchCaps);

                    if (FAILED(hr))
                    {
                        ERROR_OUT(("g_pMgr->Initialize failed"));
                    }
                }
                else
                    ERROR_OUT(("g_pMgrNotify->Connect failed"));
            }
            else
                ERROR_OUT(("new CMgrNotify failed"));

            // Get the INmSysInfo2
            INmSysInfo * pSysInfo = NULL;
            if (SUCCEEDED(g_pMgr->GetSysInfo(&pSysInfo)))
            {
                if (FAILED(pSysInfo->QueryInterface(IID_INmSysInfo2, (void **)&g_pNmSysInfo)))
                {
                    ERROR_OUT(("Could not get INmSysInfo3"));
                }

                pSysInfo->Release();
            }
        }
        else
            ERROR_OUT(("CreateInstance(IID_INmManager2) failed"));

        pcf->Release();
    }

    if (!g_pMgr)
    {
        ERROR_OUT(("Failed to init conference manager"));
        return hr;
    }

    // Set up INmSysInfo options
    SvcSetOptions();

    //
    // Init app sharing
    //
    //
    hr = g_pMgr->CreateASObject((IAppSharingNotify *)g_pMgrNotify, AS_SERVICE | AS_UNATTENDED, (IUnknown**)&g_pAS);
    if (FAILED(hr))
    {
        ERROR_OUT(("Failed to start AppSharing"));
        return(hr);
    }

    //
    // Make sure that sharing is enabled
    //

    if ( !g_pAS->IsSharingAvailable() )
    {
        WARNING_OUT(("MNMSRVC: sharing not enabled"));
        return E_FAIL;
    }

    // Create conference
    ASSERT(g_pConference == NULL);

    //
    // Only allow remotes to send files, they can't initiate anything else
    // themselves.

    LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_TITLE,
        szConfName, CCHMAX(szConfName));
	BSTRING bstrConfName(szConfName);

    hr = g_pMgr->CreateConferenceEx(&g_pConference, bstrConfName, bstrPassword,
        NMCH_DATA | NMCH_SHARE | NMCH_SRVC | NMCH_SECURE,
        NM_PERMIT_SENDFILES, 2);

    SysFreeString(bstrPassword);
    if (FAILED(hr))
    {
        ERROR_OUT(("Conference could not be created"));
        return hr;
    }

    hr = g_pConference->Host();

    if (FAILED(hr))
    {
        ERROR_OUT(("Could not host conference"));
        return hr;
    }

    return hr;
}


/*  F R E E  C O N F  M G R  */
/*-------------------------------------------------------------------------
    %%Function: FreeConfMgr
    
-------------------------------------------------------------------------*/
VOID FreeConfMgr(void)
{
    DebugEntry(FreeConfMgr);
    // Release conference manager notify
    if (NULL != g_pMgrNotify)
    {
        g_pMgrNotify->Disconnect();

        UINT ref = g_pMgrNotify->Release();
        TRACE_OUT(("g_pMgrNotify after Release: refcount: %d", ref));
        g_pMgrNotify = NULL;
    }

    // Release conference manager
    if (NULL != g_pMgr)
    {
        UINT ref;
        ref = g_pMgr->Release();
        TRACE_OUT(("g_pMgr after Release: refcount: %d", ref));
        g_pMgr = NULL;
    }
    DebugExitVOID(FreeConfMgr);
}


/*  F R E E  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: FreeConference
    
-------------------------------------------------------------------------*/
VOID FreeConference(void)
{
    DebugEntry(FreeConference);
    if (NULL != g_pConferenceNotify)
    {
        g_pConferenceNotify->Disconnect();
        g_pConferenceNotify->Release();
        g_pConferenceNotify = NULL;
    }

    if (NULL != g_pNmSysInfo )
    {
        UINT ref = g_pNmSysInfo->Release();
        TRACE_OUT(("g_pNmSysInfo refcount %d after release", ref));
        g_pNmSysInfo = NULL;
    }

    if (NULL != g_pConference)
    {
        UINT ref = g_pConference->Release();

        ASSERT(1 == ref); // The confmgr holds last reference

        g_pConference = NULL;
    }
    else
    {
        WARNING_OUT(("FreeConference: no conference???"));
    }

    DebugExitVOID(FreeConference);
}



//////////////////////////////////////////////////////////////////////////
//  C  C N F  M G R  N O T I F Y

CMgrNotify::CMgrNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CMgrNotify created"));
}

CMgrNotify::~CMgrNotify()
{
    TRACE_OUT(("CMgrNotify destroyed"));
}


///////////////////////////
//  CMgrNotify:IUnknown

ULONG STDMETHODCALLTYPE CMgrNotify::AddRef(void)
{
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CMgrNotify::Release(void)
{
    return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CMgrNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CMgrNotify QI'd"));

    if (riid == IID_IUnknown || riid == IID_INmManagerNotify)
    {
        *ppvObject = (INmManagerNotify *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CMgrNotify:ICNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CMgrNotify::Connect"));
    return CNotify::Connect(pUnk, IID_INmManagerNotify, (INmManagerNotify *)this);
}

HRESULT STDMETHODCALLTYPE CMgrNotify::Disconnect(void)
{
    TRACE_OUT(("CMgrNotify::Disconnect"));
    return CNotify::Disconnect();
}



//////////////////////////////////
//  CMgrNotify:INmManagerNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::NmUI(CONFN confn)
{
    TRACE_OUT(("CMgrNotify::NmUI"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::CallCreated(INmCall *pNmCall)
{
    
    new CSrvcCall(pNmCall);

    TRACE_OUT(("CMgrNotify::CallCreated"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::ConferenceCreated(INmConference *pConference)
{
    g_cPersonsInConf = 0;
    g_cPersonsInShare = 0;

    if (NULL == g_pConference)
    {
        TRACE_OUT(("CMgrNotify::ConferenceCreated"));
        HookConference(pConference);
    }
    else
    {
        ERROR_OUT(("Second conference created???"));
    }
    return S_OK;
}

// CMgrNotify::IAppSharingNotify
HRESULT STDMETHODCALLTYPE CMgrNotify::OnReadyToShare(BOOL fReady)
{
    TRACE_OUT(("CMgrNotify::OnReadyToShare"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareStarted()
{
    TRACE_OUT(("CMgrNotify::OnShareStarted"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnSharingStarted()
{
    TRACE_OUT(("CMgrNotify::OnSharingStarted"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareEnded()
{
    TRACE_OUT(("CMgrNotify::OnShareEnded"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonJoined(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonJoined"));

    ASSERT(g_pAS);
    ASSERT(g_cPersonsInShare >= 0);
    g_cPersonsInShare++;

    //
    // Once we are no longer alone in the share, invite the remote party to
    // take control of us.
    //
    if ( 2 == g_cPersonsInShare && g_pAS)
    {
        HRESULT hr;
        TRACE_OUT(("OnPersonJoined: giving control to 2nd dude %d",
            gccID));

        //
        // Give control to the remote party
        //
        hr = g_pAS->GiveControl(gccID);
        if ( S_OK != hr )
        {
            ERROR_OUT(("OnPersonJoined: GiveControl to %d failed: %x",
                gccID, hr));
        }
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonLeft(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonLeft"));

    ASSERT(g_pAS);

    g_cPersonsInShare--;
    ASSERT(g_cPersonsInShare >= 0);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartInControl"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopInControl"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CMgrNotify::OnPausedInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPausedInControl"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CMgrNotify::OnUnpausedInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnUnpausedInControl"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CMgrNotify::OnControllable(BOOL fControllable)
{
    TRACE_OUT(("CMgrNotify::OnControllable"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartControlled"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopControlled"));
    ::RunScrSaver();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPausedControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPausedControlled"));
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CMgrNotify::OnUnpausedControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnUnpausedControlled"));
    return(S_OK);
}

/*  H O O K  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: HookConference
    
-------------------------------------------------------------------------*/
HRESULT HookConference(INmConference * pConference)
{
    HRESULT hr;

    DebugEntry(HookConference);

    TRACE_OUT(("HookConference"));
    ASSERT(NULL != pConference);
    ASSERT(NULL == g_pConference);

    TRACE_OUT(("Set g_pConference in HookConference"));
    g_pConference = pConference;

    pConference->AddRef();

    // Connect to the conference object
    ASSERT(NULL == g_pConferenceNotify);
    g_pConferenceNotify = new CConfNotify();
    if (NULL == g_pConferenceNotify)
    {
        ERROR_OUT(("failed to new CConfNotify"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = g_pConferenceNotify->Connect(pConference);
        if (FAILED(hr))
        {
            ERROR_OUT(("Failed to connect to g_pConferenceNotify"));
            g_pConferenceNotify->Release();
            g_pConferenceNotify = NULL;
        }
    }

    DebugExitHRESULT(HookConference,hr);

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//  C  C N F  N O T I F Y

CConfNotify::CConfNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CConfNotify created"));
}

CConfNotify::~CConfNotify()
{
    TRACE_OUT(("CConfNotify destroyed"));
}


///////////////////////////
//  CConfNotify:IUknown

ULONG STDMETHODCALLTYPE CConfNotify::AddRef(void)
{
    TRACE_OUT(("CConfNotify::AddRef"));
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CConfNotify::Release(void)
{
    TRACE_OUT(("CConfNotify::Release"));
    return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CConfNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CConfNotify::QueryInterface"));

    if (riid == IID_IUnknown)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_IUnknown"));
        *ppvObject = (IUnknown *)this;
    }
    else if (riid == IID_INmConferenceNotify)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_INmConferenceNotify"));
        *ppvObject = (INmConferenceNotify *)this;
    }
    else
    {
        WARNING_OUT(("CConfNotify::QueryInterface bogus"));
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CConfNotify:ICNotify

HRESULT STDMETHODCALLTYPE CConfNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CConfNotify::Connect"));
    return CNotify::Connect(pUnk,IID_INmConferenceNotify,(IUnknown *)this);
}

HRESULT STDMETHODCALLTYPE CConfNotify::Disconnect(void)
{
    TRACE_OUT(("CConfNotify::Disconnect"));

    //
    // Release for Addref in HookConference before CConfNotify::Connect
    //

    if ( g_pConference )
        g_pConference->Release();

    return CNotify::Disconnect();
}


//////////////////////////////////
//  CConfNotify:IConfNotify

HRESULT STDMETHODCALLTYPE CConfNotify::NmUI(CONFN uNotify)
{
    TRACE_OUT(("CConfNotify::NmUI"));
    TRACE_OUT(("NmUI called."));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CConfNotify::StateChanged(NM_CONFERENCE_STATE uState)
{
    TRACE_OUT(("CConfNotify::StateChanged"));

    if (NULL == g_pConference)
        return S_OK; // weird

    switch (uState)
    {
    case NM_CONFERENCE_ACTIVE:
        if (IS_NT) {
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SHUTDOWN;
            SetServiceStatus(sshStatusHandle,&ssStatus);
        }
        else {        // Windows 95
            g_hCallEvent = CreateEvent(NULL,FALSE,FALSE,SERVICE_CALL_EVENT);
        }
        break;

    case NM_CONFERENCE_INITIALIZING:
        break; // can't do anything just yet

    case NM_CONFERENCE_WAITING:
        if (IS_NT) {
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
            SetServiceStatus(sshStatusHandle,&ssStatus);
        }
        else {        // Windows 95
            CloseHandle(g_hCallEvent);
        }
        break;

    case NM_CONFERENCE_IDLE:
        break;
    }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CConfNotify::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
    switch (uNotify)
    {
    case NM_MEMBER_ADDED:
    {
        TRACE_OUT(("CConfNotify::MemberChanged() Member added"));

        ASSERT( g_cPersonsInConf >= 0 );

        g_cPersonsInConf++;

        //
        // Once we are no longer alone in the conference, share the desktop
        // and allow control:
        //

        if ( 2 == g_cPersonsInConf && g_pAS )
        {
            HRESULT hr;
            TRACE_OUT(("%d parties in conf, Sharing the desktop",
                g_cPersonsInConf));

            //
            // Share out the desktop
            //
            hr = g_pAS->Share ( GetDesktopWindow(), IAS_SHARE_DEFAULT );
            if ( S_OK != hr )
            {
                ERROR_OUT(("OnPersonJoined: sharing desktop failed: %x",hr));
            }

            //
            // Allow control
            //
            hr = g_pAS->AllowControl ( TRUE );
            if ( S_OK != hr )
            {
                ERROR_OUT(("OnPersonJoined: allowing control failed: %x",hr));
            }
        }
        break;
    }
    case NM_MEMBER_REMOVED:
    {
        TRACE_OUT(("CConfNotify::MemberChanged() Member removed"));
        g_cPersonsInConf--;
        ASSERT( g_cPersonsInConf >= 0 );

        if ( 1 == g_cPersonsInConf && g_pAS )
        {
            HRESULT hr;
            TRACE_OUT(("%d parties in conf, Unsharing the desktop",
                g_cPersonsInConf));

            //
            // Disallow control
            //
            hr = g_pAS->AllowControl ( FALSE );
            if ( S_OK != hr )
            {
                ERROR_OUT(("Disallowing control failed: %x",hr));
            }

            //
            // Unshare the desktop
            //
            hr = g_pAS->Unshare ( GetDesktopWindow() );
            if ( S_OK != hr )
            {
                ERROR_OUT(("Unsharing desktop failed: %x",hr));
            }
        }
        break;
    }
    case NM_MEMBER_UPDATED:
    {
        TRACE_OUT(("CConfNotify::MemberChanged() Member updated"));
        break;
    }
    default:
        break;
    }
    
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CConfNotify::ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
    return S_OK;
}


VOID SvcSetOptions(VOID)
{
    DebugEntry(SvcSetOptions);

    //
    // We must set the bandwidth & computer name properties.
    //
    if (NULL != g_pNmSysInfo)
    {
        RegEntry reAudio(AUDIO_KEY, HKEY_LOCAL_MACHINE);
        UINT uBandwidth = reAudio.GetNumber(REGVAL_TYPICALBANDWIDTH,
                                                BW_DEFAULT);

        g_pNmSysInfo->SetOption(NM_SYSOPT_BANDWIDTH, uBandwidth);

        TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwComputerNameLength = sizeof(szComputerName);
        if ( !GetComputerName( szComputerName, &dwComputerNameLength))
        {
            lstrcpy(szComputerName,TEXT("?"));
            ERROR_OUT(("GetComputerName failed"));
        }

        g_pNmSysInfo->SetProperty(NM_SYSPROP_USER_NAME,BSTRING(szComputerName));
    }
    
    DebugExitVOID(SvcSetOptions);
}

BOOL ServiceCtrlHandler(DWORD dwCtrlType)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("ServiceCtrlHandler received %d",dwCtrlType));
    switch (dwCtrlType)
    {
    case CTRL_SHUTDOWN_EVENT:
        if (g_pConference != NULL)
        {
            TRACE_OUT(("Leaving conference in CTRL_SHUTDOWN_EVENT"));
            hr = g_pConference->Leave();

            if (FAILED(hr))
            {
                WARNING_OUT(("Service Ctrl Handler failed to leave"));
            }
        }
        else
        {
            WARNING_OUT(("g_pConference NULL in CTRL_SHUTDOWN_EVENT"));
        }

        break;
    default:
        break;
    }
    return FALSE;
}

static BOOL RunScrSaver(void)
{
    BOOL fIsScrSaverActive = FALSE;
    if (g_fInShutdown)
    {
        return FALSE;
    }
    if (!SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &fIsScrSaverActive, 0))
    {
        ERROR_OUT(("RunScrSaver: SystemParametersInfo failed"));
        return FALSE;
    }
    if (fIsScrSaverActive)
    {
        RegEntry reWinlogon(IS_NT ? WINNT_WINLOGON_KEY : WIN95_WINLOGON_KEY, HKEY_LOCAL_MACHINE);
        CSTRING strGracePeriod = reWinlogon.GetString(REGVAL_SCREENSAVER_GRACEPERIOD);
        reWinlogon.SetValue(REGVAL_SCREENSAVER_GRACEPERIOD, ZERO_DELAY);
        reWinlogon.FlushKey();
        DefWindowProc(GetDesktopWindow(), WM_SYSCOMMAND, SC_SCREENSAVE, 0);
        if (lstrlen(strGracePeriod))
        {
            int cSeconds = RtStrToInt(strGracePeriod);
            if (cSeconds > 0 && cSeconds <= 20)
            {
                Sleep(1000*cSeconds);
                reWinlogon.SetValue(REGVAL_SCREENSAVER_GRACEPERIOD, strGracePeriod);
                reWinlogon.FlushKey();
                return TRUE;
            }
        }

        Sleep(5000);
        reWinlogon.DeleteValue(REGVAL_SCREENSAVER_GRACEPERIOD);        
        reWinlogon.FlushKey();
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\precomp.h ===
#ifdef DEBUG
#define _CRTDBG_MAP_ALLOC
#endif

#include <windows.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <shellapi.h>
#include <process.h> 
#include <tchar.h> 
#include <stock.h>
#include <ConfDbg.h>
#include <debspew.h>
#include "nmmgr.h" 
#include <RegEntry.h>
#include <ConfReg.h>
#include <nmremote.h>
#include <resource.h>
#include <oprahcom.h>
#include <ias.h>
#include <evtlog.h>
#include <mtgset.h>
#include <dllutil.h>


#include "capflags.h"
#include "objidl.h"
#include "oleidl.h"
#include "ocidl.h"
#include "oaidl.h"
#include "SDKInternal.h"
#include "clutil.h"
#include "cconf.h"
#include "taskbar.h"
#include "nmevtmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\nmmgr.cpp ===
// 
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved. 
// 
//  MODULE:  nmmgr.cpp 
// 
//  PURPOSE:  Implements the body of the service. 
// 
//  FUNCTIONS: 
//            MNMServiceStart(DWORD dwArgc, LPTSTR *lpszArgv); 
//            MNMServiceStop( ); 
// 
//  COMMENTS: The functions implemented in nmmgr.c are 
//            prototyped in nmmgr.h 
//              
// 
//  AUTHOR: Claus Giloi
// 
 
#include <precomp.h>
#include <tsecctrl.h>

#define NMSRVC_TEXT "NMSrvc"

// DEBUG only -- Define debug zone
#ifdef DEBUG
HDBGZONE ghZone = NULL;
static PTCHAR rgZones[] = {
    NMSRVC_TEXT,
    "Warning",
    "Trace",
    "Function"
};
#endif // DEBUG

extern INmSysInfo2 * g_pNmSysInfo;   // Interface to SysInfo
extern BOOL InitT120Credentials(VOID);

// this event is signaled when the 
// service should end 

const int STOP_EVENT = 0;
HANDLE  hServerStopEvent = NULL; 

// this event is signaled when the 
// service should be paused or continued

const int PAUSE_EVENT = 1;
HANDLE  hServerPauseEvent = NULL; 

const int CONTINUE_EVENT = 2;
HANDLE hServerContinueEvent = NULL;

const int numEventHandles = 3;

HANDLE hServerActiveEvent = NULL;

DWORD g_dwActiveState = STATE_INACTIVE;


// 
//  FUNCTION: CreateWatcherProcess 
// 
//  PURPOSE: This launches a rundll32.exe which loads msconf.dll which will then wait for 
//           us to terminate and make sure that the mnmdd display driver was properly deactivated.
// 
//  PARAMETERS: 
// 
//  RETURN VALUE: 
// 
//  COMMENTS: 
// 
BOOL CreateWatcherProcess()
{
    BOOL bRet = FALSE;
    HANDLE hProcess;

    // open a handle to ourselves that the watcher process can inherit
    hProcess = OpenProcess(SYNCHRONIZE,
                           TRUE,
                           GetCurrentProcessId());
    if (hProcess)
    {
        TCHAR szWindir[MAX_PATH];

        if (GetSystemDirectory(szWindir, sizeof(szWindir)/sizeof(szWindir[0])))
        {
            TCHAR szCmdLine[MAX_PATH * 2];
            PROCESS_INFORMATION pi = {0};
            STARTUPINFO si = {0};

            si.cb = sizeof(si);
            
            wsprintf(szCmdLine, "\"%s\\rundll32.exe\" msconf.dll,CleanupNetMeetingDispDriver %ld", szWindir, HandleToLong(hProcess));

            if (CreateProcess(NULL,
                              szCmdLine,
                              NULL,
                              NULL,
                              TRUE, // we want the watcher to inherit hProcess, so we must set bInheritHandles = TRUE
                              0,
                              NULL,
                              NULL,
                              &si,
                              &pi))
            {
                bRet = TRUE;

                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
            }
        }

        CloseHandle(hProcess);
    }

    return bRet;
}


// 
//  FUNCTION: MNMServiceStart 
// 
//  PURPOSE: Actual code of the service 
//          that does the work. 
// 
//  PARAMETERS: 
//    dwArgc  - number of command line arguments 
//    lpszArgv - array of command line arguments 
// 
//  RETURN VALUE: 
//    none 
// 
//  COMMENTS: 
// 
VOID MNMServiceStart (DWORD dwArgc, LPTSTR *lpszArgv) 
{ 
    HRESULT hRet;
    BOOL fWaitForEvent = TRUE;
    DWORD dwResult;
    MSG msg;
    LPCTSTR lpServiceStopEvent = TEXT("ServiceStopEvent");
    LPCTSTR lpServiceBusyEvent = TEXT("ServiceBusyEvent");
    const int MaxWaitTime = 5;
    HANDLE hConfEvent; 
    DWORD dwError = NO_ERROR;
    HANDLE hShuttingDown;
    int i;
    RegEntry Re( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE );

    // Initialization
    DBGINIT(&ghZone, rgZones);
    InitDebugModule(NMSRVC_TEXT);

    DebugEntry(MNMServiceStart);

    if (!Re.GetNumber(REMOTE_REG_RUNSERVICE, DEFAULT_REMOTE_RUNSERVICE))
    {
        TRACE_OUT(("Try to start mnmsrvc without no registry setting"));
        goto cleanup;
    }
    /////////////////////////////////////////////////// 
    // 
    // Service initialization 
    // 

    // report the status to the service control manager. 
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, 30000))
    {
        ERROR_OUT(("ReportStatusToSCMgr failed"));
        dwError = GetLastError();
        goto cleanup; 
    }
    HANDLE pEventHandles[numEventHandles];
    
    // create the event object. The control handler function signals 
    // this event when it receives the "stop" control code. 
    // 
    hServerStopEvent = CreateEvent( 
        NULL,    // no security attributes 
        TRUE,    // manual reset event 
        FALSE,  // not-signalled 
        SERVICE_STOP_EVENT);  // no name 
 
    if ( hServerStopEvent == NULL) 
    {
        ERROR_OUT(("CreateEvent failed"));
        dwError = GetLastError();
        goto cleanup; 
    }
 
    pEventHandles[STOP_EVENT] = hServerStopEvent;

    hServerPauseEvent = CreateEvent(
        NULL,
        FALSE,
        FALSE,
        SERVICE_PAUSE_EVENT);

    if (hServerPauseEvent == NULL)
    {
        ERROR_OUT(("CreateEvent failed"));
        dwError = GetLastError();
        goto cleanup; 
    }

    pEventHandles[PAUSE_EVENT] = hServerPauseEvent;

    hServerContinueEvent = CreateEvent(
        NULL,
        FALSE,
        FALSE,
        SERVICE_CONTINUE_EVENT);

    if (hServerContinueEvent == NULL)
    {
        ERROR_OUT(("CreateEvent failed"));
        dwError = GetLastError();
        goto cleanup; 
    }

    pEventHandles[CONTINUE_EVENT] = hServerContinueEvent;
 
    CoInitialize(NULL);

    // 
    // End of initialization 
    // 
    //////////////////////////////////////////////////////// 
 
    // report the status to the service control manager. 
    //
    if (!ReportStatusToSCMgr( 
        SERVICE_RUNNING,        // service state 
        NO_ERROR,              // exit code 
        0))                    // wait hint 
    {
        ERROR_OUT(("ReportStatusToSCMgr failed"));
        goto cleanup; 
    }
    SetConsoleCtrlHandler(ServiceCtrlHandler, TRUE);

    CreateWatcherProcess();

    AddTaskbarIcon();

    //////////////////////////////////////////////////////// 
    // 
    // Service is now running, perform work until shutdown 
    //
    if (IS_NT)
    {
        AddToMessageLog(EVENTLOG_INFORMATION_TYPE,
                        0,
                        MSG_INF_START,
                        NULL);
    }

    //
    // Check if the service should start up activated
    //

    if ( Re.GetNumber(REMOTE_REG_ACTIVATESERVICE,
                    DEFAULT_REMOTE_ACTIVATESERVICE))
    {
        MNMServiceActivate();
    }
    else
    {
        if (!ReportStatusToSCMgr( 
            SERVICE_PAUSED,        // service state 
            NO_ERROR,              // exit code 
            0))                    // wait hint 
        {
            ERROR_OUT(("ReportStatusToSCMgr failed"));
            goto cleanup; 
        }
    }

    while (fWaitForEvent)
    {
        dwResult = MsgWaitForMultipleObjects( numEventHandles,
                                              pEventHandles,
                                              FALSE,
                                              INFINITE,
                                              QS_ALLINPUT);

        switch (dwResult)
        {
            case WAIT_OBJECT_0 + numEventHandles:
            {
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (WM_QUIT != msg.message)
                    {
                    
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    
                    }
                    else
                    {
                        TRACE_OUT(("received WM_QUIT"));
                        fWaitForEvent = FALSE;
                        break;
                    }
                }
                break;
            }
            case WAIT_OBJECT_0 + PAUSE_EVENT:
            {
                if (STATE_ACTIVE == g_dwActiveState)
                {
                    MNMServiceDeActivate();
                }
                ReportStatusToSCMgr( SERVICE_PAUSED, NO_ERROR, 0);
                break;
            }
            case WAIT_OBJECT_0 + CONTINUE_EVENT:
            {
                HANDLE hInit = OpenEvent(EVENT_ALL_ACCESS, FALSE, _TEXT("CONF:Init"));
                if (STATE_INACTIVE == g_dwActiveState && NULL == hInit)
                {
                    MNMServiceActivate();
                }
                CloseHandle(hInit);
                ReportStatusToSCMgr( SERVICE_RUNNING, NO_ERROR, 0);
                break;
            }
            case WAIT_OBJECT_0 + STOP_EVENT:
            {
                RemoveTaskbarIcon();
                if (STATE_ACTIVE == g_dwActiveState)
                {
                    MNMServiceDeActivate();
                }
                fWaitForEvent = FALSE;
                break;
            }
        }
    }

cleanup: 

    if ( STATE_ACTIVE == g_dwActiveState )
    {
        MNMServiceDeActivate();
    }
 
    if (hServerStopEvent) 
        CloseHandle(hServerStopEvent); 
    if (hServerPauseEvent) 
        CloseHandle(hServerPauseEvent); 
    if (hServerContinueEvent) 
        CloseHandle(hServerContinueEvent); 

    TRACE_OUT(("Reporting SERVICE_STOPPED"));
    ReportStatusToSCMgr( SERVICE_STOPPED, dwError, 0);

    DebugExitVOID(MNMServiceStart);

    CoUninitialize();

    DBGDEINIT(&ghZone);
    ExitDebugModule();
}
 
 
BOOL MNMServiceActivate ( VOID )
{
    DebugEntry(MNMServiceActivate);

    if ( STATE_INACTIVE != g_dwActiveState )
    {
        WARNING_OUT(("MNMServiceActivate: g_dwActiveState:%d",
                                g_dwActiveState));
        return FALSE;
    }

    g_dwActiveState = STATE_BUSY;

    if (!IS_NT)
    {
        ASSERT(NULL == hServerActiveEvent);
        hServerActiveEvent = CreateEvent(NULL, FALSE, FALSE, SERVICE_ACTIVE_EVENT);
    }
    HRESULT hRet = InitConfMgr();
    if (FAILED(hRet))
    {
        ERROR_OUT(("ERROR %x initializing nmmanger", hRet));
        FreeConfMgr();
        g_dwActiveState = STATE_INACTIVE;
        if (!IS_NT)
        {
            CloseHandle ( hServerActiveEvent );
        }
        DebugExitBOOL(MNMServiceActivate,FALSE);
        return FALSE;
    }

    if ( g_pNmSysInfo )
    {
        //
        // Attempt to initialize T.120 security, if this fails
        // bail out since we won't be able to receive any calls
        //

        if ( !InitT120Credentials() )
        {
            FreeConfMgr();
            g_dwActiveState = STATE_INACTIVE;
            if (!IS_NT)
            {
                CloseHandle ( hServerActiveEvent );
            }
            DebugExitBOOL(MNMServiceActivate,FALSE);
            return FALSE;
        }
    }
    g_dwActiveState = STATE_ACTIVE;
    DebugExitBOOL(MNMServiceActivate,TRUE);
    return TRUE;
}


BOOL MNMServiceDeActivate ( VOID )
{
    DebugEntry(MNMServiceDeActivate);

    if (STATE_ACTIVE != g_dwActiveState)
    {
        WARNING_OUT(("MNMServiceDeActivate: g_dwActiveState:%d",
                                g_dwActiveState));
        DebugExitBOOL(MNMServiceDeActivate,FALSE);
        return FALSE;
    }

    g_dwActiveState = STATE_BUSY;

    //
    // Leave Conference
    //

    if (NULL != g_pConference)
    {
        if (g_pNmSysInfo)
        {
            g_pNmSysInfo->ProcessSecurityData(UNLOADFTAPPLET,0,0,NULL);
        }
        if ( FAILED(g_pConference->Leave()))
        {
            ERROR_OUT(("Conference Leave failed"));;
        }
    }

    //
    // Free the conference
    //

    FreeConference();

    //
    // Free the AS interface
    //

    ASSERT(g_pAS);
    UINT ret = g_pAS->Release();
    g_pAS = NULL;
    TRACE_OUT(("AS interface freed, ref %d after Release", ret));

    // can we have a way not to create this event?
    HANDLE hevt = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    ASSERT(NULL != hevt);
    const DWORD dwTimeout = 1000;
    DWORD dwStartTime = ::GetTickCount();
    DWORD dwCurrTimeout = dwTimeout;
    DWORD dwRet;
    BOOL fContinue = TRUE;

    while (fContinue && WAIT_OBJECT_0 != (dwRet = ::MsgWaitForMultipleObjects(1, &hevt, FALSE, dwCurrTimeout, QS_ALLINPUT)))
    {
        if (WAIT_TIMEOUT != dwRet)
        {
            DWORD dwCurrTime = ::GetTickCount();
            if (dwCurrTime < dwStartTime + dwTimeout)
            {
                dwCurrTimeout = dwStartTime + dwTimeout - dwCurrTime;

                MSG msg;
                while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (WM_QUIT != msg.message)
                    {
                        ::TranslateMessage(&msg);
                        ::DispatchMessage(&msg);
                    }
                    else
                    {
                        ::PostQuitMessage(0);
                        fContinue = FALSE;
                    }
                }
                continue;
            }
            // timeout here
        }
        // exit the loop
        break;
    }
    ::CloseHandle(hevt);

    // not to call FreeConfMfr imediately after FreeConference to avoid
    // a bug in t120 will remove this sleep call after fix the bug in t120
    FreeConfMgr();

    // BUGBUG remove h323cc.dll should be done in nmcom. Once the bug in nmcom is fixed, this part will be removed.
    HMODULE hmodH323CC = GetModuleHandle("h323cc.dll");    
    if (hmodH323CC)
    {
        if (FreeLibrary(hmodH323CC))
        {
            TRACE_OUT(("CmdInActivate -- Unloaded h323cc.dll"));
        }
        else
        {
            WARNING_OUT(("CmdInActivate -- Failed to unload h323cc.dll %d", GetLastError()));
        }
    }
    if (!IS_NT)
    {
        ASSERT(hServerActiveEvent);
        if (hServerActiveEvent)
        {
            CloseHandle(hServerActiveEvent);
            hServerActiveEvent = NULL;
        }
    }
    g_dwActiveState = STATE_INACTIVE;
    DebugExitBOOL(MNMServiceDeActivate,TRUE);
    return TRUE;
}

// 
//  FUNCTION: MNMServiceStop 
// 
//  PURPOSE: Stops the service 
// 
//  PARAMETERS: 
//    none 
// 
//  RETURN VALUE: 
//    none 
// 
//  COMMENTS: 
//    If a ServiceStop procedure is going to 
//    take longer than 3 seconds to execute, 
//    it should spawn a thread to execute the 
//    stop code, and return.  Otherwise, the 
//    ServiceControlManager will believe that 
//    the service has stopped responding. 
//     
VOID MNMServiceStop() 
{ 
    DebugEntry(MNMServiceStop);

    RemoveTaskbarIcon();

    if ( hServerStopEvent ) 
    {
        TRACE_OUT(("MNMServiceStop: setting server stop event"));
        SetEvent(hServerStopEvent); 
    }

    if (IS_NT)
    {
        AddToMessageLog(EVENTLOG_INFORMATION_TYPE,
                        0,
                        MSG_INF_STOP,
                        NULL);
    }

    DebugExitVOID(MNMServiceStop);
}


VOID MNMServicePause()
{
    DebugEntry(MNMServicePause);

    if ( hServerPauseEvent ) 
        SetEvent(hServerPauseEvent); 

    DebugExitVOID(MNMServicePause);
}

VOID MNMServiceContinue()
{
    DebugEntry(MNMServiceContinue);

    if ( hServerContinueEvent )
        SetEvent(hServerContinueEvent);

    DebugExitVOID(MNMServiceContinue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\clutil.cpp ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.CPP
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#include "precomp.h"


///////////////////////////////////////////////////////////////////////////
// RefCount

/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(void)
{
	m_cRef = 1;
}


RefCount::~RefCount(void)
{
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   ASSERT(m_cRef >= 0);

   InterlockedIncrement(&m_cRef);

   return (ULONG) m_cRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	if (0 == InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	ASSERT(m_cRef > 0);
	return (ULONG) m_cRef;
}



///////////////////////////////////////////////////////////////////////////
// CNotify

/*  C  N O T I F Y  */
/*-------------------------------------------------------------------------
    %%Function: CNotify
    
-------------------------------------------------------------------------*/
CNotify::CNotify() :
	m_pcnpcnt(NULL),
    m_pcnp(NULL),
    m_dwCookie(0),
    m_pUnk(NULL)
{
}

CNotify::~CNotify()
{
	Disconnect(); // Make sure we're disconnected
}


/*  C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Connect

-------------------------------------------------------------------------*/
HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
{
	HRESULT hr;

	ASSERT(0 == m_dwCookie);

	// Get the connection container
	hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void **)&m_pcnpcnt);
	if (SUCCEEDED(hr))
	{
		// Find an appropriate connection point
		hr = m_pcnpcnt->FindConnectionPoint(riid, &m_pcnp);
		if (SUCCEEDED(hr))
		{
			ASSERT(NULL != m_pcnp);
			// Connect the sink object
			hr = m_pcnp->Advise((IUnknown *)pUnkN, &m_dwCookie);
		}
	}

	if (FAILED(hr))
	{
		ERROR_OUT(("MNMSRVC: CNotify::Connect failed: %x", hr));
		m_dwCookie = 0;
	}
	else
	{
    	m_pUnk = pUnk; // keep around for caller
    }

	return hr;
}



/*  D I S C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Disconnect
    
-------------------------------------------------------------------------*/
HRESULT CNotify::Disconnect (void)
{
    if (0 != m_dwCookie)
    {
        // Disconnect the sink object
        m_pcnp->Unadvise(m_dwCookie);
        m_dwCookie = 0;

        m_pcnp->Release();
        m_pcnp = NULL;

        m_pcnpcnt->Release();
        m_pcnpcnt = NULL;

        m_pUnk = NULL;
    }

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////
// COBLIST


COBLIST::~COBLIST()
{
    ASSERT(IsEmpty());
}


#ifdef DEBUG
VOID* COBLIST::GetHead()
{
	ASSERT(m_pHead);

	return m_pHead->pItem;
}
   
VOID* COBLIST::GetTail()
{
	ASSERT(m_pTail);

	return m_pTail->pItem;
}
#endif /* DEBUG */

VOID* COBLIST::GetNext(POSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* COBLIST::RemoveAt(POSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;
			m_cItem--;
			ASSERT(0 <= m_cItem);

			if (NULL == m_pHead)
			{
				// Removing the only element!
				m_pTail = NULL;
			}
		}
		else
		{
			POSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;

					m_cItem--;
					ASSERT(0 <= m_cItem);
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

POSITION COBLIST::AddTail(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pTail)
	{
		if (m_pTail->pNext = new COBNODE)
		{
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}

	return m_pTail;
}

void COBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}


#ifdef DEBUG
VOID* COBLIST::RemoveTail()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pTail);
}

VOID* COBLIST::RemoveHead()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pHead);
}

void * COBLIST::GetFromPosition(POSITION Pos)
{
    void * Result = SafeGetFromPosition(Pos);
	ASSERT(Result);
	return Result;
}
#endif /* DEBUG */

POSITION COBLIST::GetPosition(void* _pItem)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Position->pItem == _pItem) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

POSITION COBLIST::Lookup(void* pComparator)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Compare(Position->pItem, pComparator)) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

void * COBLIST::SafeGetFromPosition(POSITION Pos)
{
	// Safe way to validate that an entry is still in the list,
	// which ensures bugs that would reference deleted memory,
	// reference a NULL pointer instead
	// (e.g. an event handler fires late/twice).
	// Note that versioning on entries would provide an additional 
	// safeguard against re-use of a position.
	// Walk	list to find entry.

	POSITION PosWork = m_pHead;
	
	while (PosWork) {
		if (PosWork == Pos) {
			return Pos->pItem;
		}
		GetNext(PosWork);
	}
	return NULL;
}

/////////////////////////////
// COBLIST Utility routines

/*  A D D  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: AddNode

    Add a node to a list.
    Initializes the ObList, if necessary.
    Returns the position in the list or NULL if there was a problem.
-------------------------------------------------------------------------*/
POSITION AddNode(PVOID pv, COBLIST ** ppList)
{
	ASSERT(NULL != ppList);
	if (NULL == *ppList)
	{
		*ppList = new COBLIST();
		if (NULL == *ppList)
			return NULL;
	}

	return (*ppList)->AddTail(pv);
}


/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

    Remove a node from a list.
    Sets pPos to NULL
-------------------------------------------------------------------------*/
PVOID RemoveNode(POSITION * pPos, COBLIST *pList)
{
	if ((NULL == pList) || (NULL == pPos))
		return NULL;

	PVOID pv = pList->RemoveAt(*pPos);
	*pPos = NULL;
	return pv;
}


////////////////////////////////////////////////////////////////////////////
// BSTRING

// We don't support construction from an ANSI string in the Unicode build.
#if !defined(UNICODE)

BSTRING::BSTRING(LPCSTR lpcString)
{
	m_bstr = NULL;

	// Compute the length of the required BSTR, including the null
	int cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
	if (cWC <= 0)
		return;

	// Allocate the BSTR, including the null
	m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

	ASSERT(NULL != m_bstr);
	if (NULL == m_bstr)
	{
		return;
	}

	// Copy the string
	MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

	// Verify that the string is null terminated
	ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // !defined(UNICODE)


///////////////////////////
// BTSTR

BTSTR::BTSTR(BSTR bstr)
{
	m_psz = PszFromBstr(bstr);
}

BTSTR::~BTSTR()
{
	if (NULL != m_psz)
		LocalFree(m_psz);
}

LPTSTR PszFromBstr(BSTR bstr)
{
	if (NULL == bstr)
		return NULL;
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return NULL;

	LPTSTR psz = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (cch+1) );
	if (NULL == psz)
		return NULL;

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, cch+1, NULL, NULL);
	return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\nmmgr.h ===
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: nmmgr.h
//
//  AUTHOR: claus giloi
//
//  COMMENTS: Based on Service sample in NT SDK
//            Code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef __NTSRVC_H__
#define __NTSRVC_H__


#ifdef __cplusplus
extern "C" {
#endif

extern SERVICE_STATUS          ssStatus;       // current status of the service 
extern SERVICE_STATUS_HANDLE   sshStatusHandle;
//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            REMOTE_CONTROL_NAME
// internal name of the service
#define SZSERVICENAME        REMOTE_CONTROL_NAME
// displayed name of the service
#define SZSERVICEDISPLAYNAME REMOTE_CONTROL_DISPLAY_NAME
// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""
//////////////////////////////////////////////////////////////////////////////

#define	STATE_INACTIVE  0
#define STATE_BUSY	 	1
#define STATE_ACTIVE  	2

extern DWORD g_dwActiveState;



//////////////////////////////////////////////////////////////////////////////
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID MNMServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID MNMServiceStop();
VOID MNMServicePause();
VOID MNMServiceContinue();
BOOL MNMServiceActivate();
BOOL MNMServiceDeActivate();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


#ifdef __cplusplus
}
#endif

#endif __NTSRVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\resource.h ===
#define IDI_SM_WORLD 100
#define IDS_MNMSRVC_TITLE 101
#define IDS_MNMSRVC_DESCRIPTION 102
#define IDC_STOP_ICON	103
#define IDR_TASKBAR_POPUP 200
#define IDM_TBPOPUP_STOP 201
#define IDM_TBPOPUP_ACTIVATE 202
#define IDM_TBPOPUP_INACTIVATE 203
#define IDM_TBPOPUP_SENDFILES 204
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\rdscred.cpp ===
//
// Copyright (C) 1993-1999  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:  rdscred.cpp
//
//  PURPOSE:  Implements RDS credential management
//
//  FUNCTIONS:
//            InitT120Credentials(VOID)
//
//  COMMENTS:
//
//
//  AUTHOR: Claus Giloi
//


#include <precomp.h>
#include <wincrypt.h>
#include <tsecctrl.h>
#include <nmmkcert.h>

extern INmSysInfo2 * g_pNmSysInfo;   // Interface to SysInfo

BOOL InitT120Credentials(VOID)
{
    HCERTSTORE hStore;
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL bRet = FALSE;

    // Open the "MY" local machine certificate store. This one will be
    // used when we're running as a service
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                        X509_ASN_ENCODING,
                                        0,
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                        L"MY" );

    if ( NULL != hStore )
    {
        #ifdef DUMPCERTS
        DumpCertStore(this, "Local Machine Store MY", hStore);
        #endif // DUMPCERTS

        // Check the local machine store for a certificate - any!
        pCertContext = CertFindCertificateInStore(hStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_ANY,
                                              NULL,
                                              NULL);

        CertCloseStore( hStore, 0);
    }

    if ( NULL == pCertContext )
    {
        // Open the "_NMSTR" local machine certificate store.
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                            X509_ASN_ENCODING,
                                            0,
                                            CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                            WSZNMSTORE );
        if ( NULL != hStore )
        {
            #ifdef DUMPCERTS
            DumpCertStore(this, "Local Machine Store _NMSTR", hStore);
            #endif // DUMPCERTS

            // Check the local machine store for a certificate - any!
            pCertContext = CertFindCertificateInStore(hStore,
                                                  X509_ASN_ENCODING,
                                                  0,
                                                  CERT_FIND_ANY,
                                                  NULL,
                                                  NULL);

            CertCloseStore( hStore, 0);
        }
    }

    if ( NULL == pCertContext )
    {
        WARNING_OUT(("No service context cert found!"));
        return bRet;
    }


    DWORD dwResult = -1;

    g_pNmSysInfo->ProcessSecurityData(
                            TPRTCTRL_SETX509CREDENTIALS,
                            (DWORD_PTR)pCertContext, 0,
                            &dwResult);
    if ( !dwResult )
    {
        bRet = TRUE;
    }
    else
    {
        ERROR_OUT(("InitT120Credentials - failed in T.120"));
    }
    CertFreeCertificateContext ( pCertContext );

    return bRet;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\service.cpp ===
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    NTmain(int argc, char **argv);
//    W95main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService();
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);  // DEBUG only
//    ControlHandler ( DWORD dwCtrlType );  // DEBUG only
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );  // DEBUG only
//
//  COMMENTS:
//
//  AUTHOR: Claus Giloi (based on SDK sample)
//


#include "precomp.h"

#ifndef DEBUG
#undef _tprintf
#define _tprintf force_compile_error
#endif // !DEBUG

// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
OSVERSIONINFO g_osvi;                      // The os version info structure global
BOOL          g_fInShutdown = FALSE;

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService();
VOID CmdRemoveService();
void __cdecl NTmain(int argc, char **argv);
void __cdecl W95main(int argc, char **argv);


// Debug only functionality
#ifdef DEBUG
TCHAR                   szErr[256];
BOOL                    bDebug = FALSE;
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
extern BOOL InitDebugMemoryOptions(void);
extern VOID DumpMemoryLeaksAndBreak(void);
#endif // DEBUG

typedef BOOL (WINAPI *PFNCHANGESERVICECONFIG2)(SC_HANDLE, DWORD, LPVOID);

//
//  FUNCTION: main
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//      Get Platform type and
//    call appropriate main for platform (NT or Win95)
//
void __cdecl main(int argc, char **argv)
{
    #ifdef DEBUG
    InitDebugMemoryOptions();
    #endif // DEBUG

    // Store OS version info
    g_osvi.dwOSVersionInfoSize = sizeof(g_osvi);
    if (FALSE == ::GetVersionEx(&g_osvi))
    {
        ERROR_OUT(("GetVersionEx() failed!"));
        return;
    }

    RegEntry rePol(POLICIES_KEY, HKEY_LOCAL_MACHINE);
    if ( rePol.GetNumber( REGVAL_POL_NO_RDS, DEFAULT_POL_NO_RDS) )
    {
        WARNING_OUT(("RDS launch prevented by policy"));
        return;
    }

    if ( IS_NT )
    {
        NTmain( argc, argv );
    }
    else
    {
        W95main( argc, argv );
    }

    #ifdef DEBUG
    DumpMemoryLeaksAndBreak();
    #endif // DEBUG
}


//
//  FUNCTION: NTmain
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    NTmain() either performs the command line task, or
//    call StartServiceCtrlDispatcher to register the
//    main service thread.  When the this call returns,
//    the service has stopped, so exit.
//
void __cdecl NTmain(int argc, char **argv)
{
    SERVICE_TABLE_ENTRY dispatchTable[] =
    {
        { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
        { NULL, NULL }
    };

    if ( (argc > 1) &&
         ((*argv[1] == '-') || (*argv[1] == '/')) )
    {
        if ( lstrcmpi( "install", argv[1]+1 ) == 0 )
        {
            CmdInstallService();
        }
        else if ( lstrcmpi( "remove", argv[1]+1 ) == 0 )
        {
            CmdRemoveService();
        }
#ifdef DEBUG
        else if ( lstrcmpi( "debug", argv[1]+1 ) == 0 )
        {
            bDebug = TRUE;
            CmdDebugService(argc, argv);
        }
#endif // DEBUG
        else
        {
            goto dispatch;
        }
        exit(0);
    }

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher
    dispatch:

        #ifdef DEBUG
        // this is just to be friendly
        printf( "%s -install          to install the service\n", SZAPPNAME );
        printf( "%s -remove           to remove the service\n", SZAPPNAME );
        printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
        printf( "\nStartServiceCtrlDispatcher being called.\n" );
        printf( "This may take several seconds.  Please wait.\n" );
        #endif // DEBUG

        if (!StartServiceCtrlDispatcher(dispatchTable)) {
            AddToMessageLog(EVENTLOG_ERROR_TYPE,
                            0,
                            MSG_ERR_SERVICE,
                            TEXT("StartServiceCtrlDispatcher failed."));
        }
}

//
//  FUNCTION: W95main
//
//  PURPOSE: entrypoint for pseudo-service on Win95
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    W95main() registers as Win95 service and calls Init routine directly
//
typedef DWORD (WINAPI * REGISTERSERVICEPROC)(DWORD, DWORD);
#ifndef RSP_SIMPLE_SERVICE
#define RSP_SIMPLE_SERVICE    0x00000001
#endif

void __cdecl W95main(int argc, char **argv)
{
    HMODULE hKernel;
    REGISTERSERVICEPROC lpfnRegisterServiceProcess;
    HANDLE hServiceEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_PAUSE_EVENT);
    if (hServiceEvent != NULL) // Service is already running
    {
        return;
    }

    if ( hKernel = GetModuleHandle("KERNEL32.DLL") )
    {
        if ( lpfnRegisterServiceProcess =
            (REGISTERSERVICEPROC)GetProcAddress ( hKernel,
                                    "RegisterServiceProcess" ))
        {
            if (!lpfnRegisterServiceProcess(NULL, RSP_SIMPLE_SERVICE))
            {
                ERROR_OUT(("RegisterServiceProcess failed"));
            }
        }
        else
        {
            ERROR_OUT(("GetProcAddr of RegisterServiceProcess failed"));
        }
    }
    else
    {
        ERROR_OUT(("GetModuleHandle of KERNEL32.DLL failed"));
    }

    MNMServiceStart(argc, argv);
    CloseHandle(hServiceEvent);
}

//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined MNMServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;

    TRACE_OUT(("starting service\n\r"));

    MNMServiceStart( dwArgc, lpszArgv );

cleanup:

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        // SERVICE_STOP_PENDING should be reported before
        // setting the Stop Event - hServerStopEvent - in
        // MNMServiceStop().  This avoids a race condition
        // which may result in a 1053 - The Service did not respond...
        // error.
        case SERVICE_CONTROL_STOP:
            ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 30000);
            MNMServiceStop();
            return;

        case SERVICE_CONTROL_SHUTDOWN:
            g_fInShutdown = TRUE;
            break;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_PAUSE:
            ReportStatusToSCMgr(SERVICE_PAUSE_PENDING, NO_ERROR, 30000);
            MNMServicePause();
            return;

        case SERVICE_CONTROL_CONTINUE:
            ReportStatusToSCMgr(SERVICE_CONTINUE_PENDING, NO_ERROR, 30000);
            MNMServiceContinue();
            return;

        default:
            break;

    }
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;

    #ifdef DEBUG
    if ( bDebug )
        return TRUE;
    #endif

    if ( IS_NT ) // when debugging we don't report to the SCM
    {
        switch ( dwCurrentState )
        {
            case SERVICE_START_PENDING:
            case SERVICE_STOP_PENDING:
            case SERVICE_CONTINUE_PENDING:
            case SERVICE_PAUSE_PENDING:
                break;

            case SERVICE_PAUSED:
            case SERVICE_STOPPED:
            case SERVICE_RUNNING:
                ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                              SERVICE_ACCEPT_PAUSE_CONTINUE ;

                break;
        }

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) ||
             ( dwCurrentState == SERVICE_PAUSED  ))
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;

        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
            AddToMessageLog(EVENTLOG_ERROR_TYPE,
                            0,
                            MSG_ERR_SERVICE,
                            TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}


///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService()
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdInstallService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[MAX_PATH];
    TCHAR szSrvcDisplayName[MAX_PATH];
    DWORD dwModuleFileName = GetModuleFileName( NULL, szPath, MAX_PATH - 1 );
    szPath[MAX_PATH-1] = 0;
    if (dwModuleFileName == 0 )
    {
        #ifdef DEBUG
        _tprintf(TEXT("Unable to install %s - %s\n"),
            TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
        #endif // DEBUG
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_TITLE,
                   szSrvcDisplayName, CCHMAX(szSrvcDisplayName));
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZSERVICENAME),        // name of service
            szSrvcDisplayName, // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS, 
                                        // service type -- allow interaction with desktop
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            NULL,                       // LocalSystem account
            NULL);                     // no password

        if ( schService )
        {
            HINSTANCE hAdvApi;

            if ( IS_NT && ( hAdvApi = NmLoadLibrary ( "ADVAPI32.DLL" ,TRUE)))
            {
                #ifdef UNICODE
                #error "non-unicode assumption - entry point name"
                #endif // UNICODE

                if ( PFNCHANGESERVICECONFIG2 lpCSC = 
                    (PFNCHANGESERVICECONFIG2)GetProcAddress ( hAdvApi,
                                                "ChangeServiceConfig2A" ))
                {
                    SERVICE_DESCRIPTION ServiceDescription;
                    CHAR szDescription[1024]; // Calling A variant below

                    LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_DESCRIPTION,
                        szDescription, CCHMAX(szDescription));
                    ServiceDescription.lpDescription = szDescription;

                    (*lpCSC) ( schService,
                        SERVICE_CONFIG_DESCRIPTION,
                        (LPVOID) &ServiceDescription );
                }
                FreeLibrary ( hAdvApi );
            }

            #ifdef DEBUG
            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            #endif // DEBUG

            CloseServiceHandle(schService);
        }
        else
        {
            if ( GetLastError() == ERROR_SERVICE_EXISTS )
            {
                schService = OpenService(schSCManager, TEXT(SZSERVICENAME),
                                                        SERVICE_ALL_ACCESS);
                if (schService)
                {
                    // try to stop the service
                    if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
                    {
                        #ifdef DEBUG
                        _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                        #endif // DEBUG

                        Sleep( 1000 );

                        while( QueryServiceStatus( schService, &ssStatus ) )
                        {
                            if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                            {
                                #ifdef DEBUG
                                _tprintf(TEXT("."));
                                #endif // DEBUG

                                Sleep( 1000 );
                            }
                            else
                                break;
                        }

                        if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                        {
                            #ifdef DEBUG
                            _tprintf(TEXT("\n%s stopped.\n"),
                                    TEXT(SZSERVICEDISPLAYNAME) );
                            #endif // DEBUG
                        }
                        else
                        {
                            #ifdef DEBUG
                            _tprintf(TEXT("\n%s failed to stop.\n"),
                                    TEXT(SZSERVICEDISPLAYNAME) );
                            #endif // DEBUG
                        }
                    }

                    // now set manual startup
                    if ( ChangeServiceConfig( schService, SERVICE_NO_CHANGE,
                                SERVICE_DEMAND_START, SERVICE_NO_CHANGE,
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL))
                    {
                        #ifdef DEBUG
                        _tprintf(TEXT("%s set to manual start.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                        #endif //DEBUG
                    }
                    else
                    {
                        #ifdef DEBUG
                        _tprintf(TEXT("ChangeServiceConfig failed - %s\n"), GetLastErrorText(szErr,256));
                        #endif //DEBUG
                    }

                    CloseServiceHandle(schService);
                }
                else
                {
                    #ifdef DEBUG
                    _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
                    #endif //DEBUG
                }
            }
            else
            {
                #ifdef DEBUG
                _tprintf(TEXT("CreateService failed - %s\n"),
                                GetLastErrorText(szErr, 256));
                #endif // DEBUG
            }
        }

        CloseServiceHandle(schSCManager);
    }
    else
    {
        #ifdef DEBUG
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
        #endif //DEBUG
    }
}



//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, TEXT(SZSERVICENAME),
                                                SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                #ifdef DEBUG
                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                #endif // DEBUG

                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        #ifdef DEBUG
                        _tprintf(TEXT("."));
                        #endif // DEBUG

                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    #ifdef DEBUG
                    _tprintf(TEXT("\n%s stopped.\n"),
                            TEXT(SZSERVICEDISPLAYNAME) );
                    #endif // DEBUG
                }
                else
                {
                    #ifdef DEBUG
                    _tprintf(TEXT("\n%s failed to stop.\n"),
                            TEXT(SZSERVICEDISPLAYNAME) );
                    #endif // DEBUG
                }
            }

            // now remove the service
            if( DeleteService(schService) )
            {
                #ifdef DEBUG
                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                #endif //DEBUG
            }
            else
            {
                #ifdef DEBUG
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));
                #endif //DEBUG
            }


            CloseServiceHandle(schService);
        }
        else
        {
            #ifdef DEBUG
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
            #endif //DEBUG
        }

        CloseServiceHandle(schSCManager);
    }
    else
    {
        #ifdef DEBUG
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
        #endif //DEBUG
    }
}

#ifdef DEBUG

///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    MNMServiceStart( dwArgc, lpszArgv );
}

//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
            MNMServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\srvccall.cpp ===
// SrvcCall.cpp
// Code to implement the INmCallNotify interface for the remote control service

#include "precomp.h"
#include "srvcutil.h"
#include "srvccall.h"

CSrvcCall::CSrvcCall(INmCall * pNmCall) :
	m_pCall  (pNmCall),
	m_pszName  (NULL),
	m_pszAddr  (NULL),
	m_addrType (NM_ADDR_UNKNOWN),
	m_fSelectedConference (FALSE),
	m_pos      (NULL),
	m_cRef     (1),
	m_dwCookie (0)
{
	HRESULT hr;

	TRACE_OUT(("CSrvcCall: Created %08X (INmCall=%08X)", this, pNmCall));

	ASSERT(NULL != m_pCall);
	m_pCall->AddRef();

	// Get the display name
	BSTR  bstr;
	hr = m_pCall->GetName(&bstr);
	if (SUCCEEDED(hr))
	{
		hr = BSTR_to_LPTSTR(&m_pszName, bstr);
		SysFreeString(bstr);
	}
	if (FEmptySz(m_pszName))
	{
		// Default to "another person" if no name available in the call data
		m_pszName = TEXT("Somebody");
	}

	hr = m_pCall->GetAddr(&bstr, &m_addrType);
	if (SUCCEEDED(hr))
	{
		hr = BSTR_to_LPTSTR(&m_pszAddr, bstr);
		SysFreeString(bstr);
	}

	// These should never change
	m_fIncoming = (m_pCall->IsIncoming() == S_OK);
	m_dwTick = ::GetTickCount();

	Update();

	NmAdvise(m_pCall, this, IID_INmCallNotify, &m_dwCookie);
}

VOID CSrvcCall::RemoveCall(void)
{
	NmUnadvise(m_pCall, IID_INmCallNotify, m_dwCookie);
}

CSrvcCall::~CSrvcCall()
{
	delete m_pszName;
	delete m_pszAddr;

	ASSERT(NULL != m_pCall);
	m_pCall->Release();
}

// IUnknown methods
STDMETHODIMP_(ULONG) CSrvcCall::AddRef(void)
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSrvcCall::Release(void)
{
	ASSERT(m_cRef > 0);
	if (m_cRef > 0)
	{
		m_cRef--;
	}

	ULONG cRef = m_cRef;

	if (0 == cRef)
	{
		delete this;
	}

	return cRef;
}

STDMETHODIMP CSrvcCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCallNotify) || (riid == IID_IUnknown))
	{
		*ppv = (INmCallNotify *)this;
//		ApiDebugMsg(("CCall::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
//		ApiDebugMsg(("CCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

// INmCallNotify methods
STDMETHODIMP CSrvcCall::NmUI(CONFN uNotify)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::StateChanged(NM_CALL_STATE uState)
{
	// REVIEW: This check should be done outside of this routine
	if (uState == m_State)
	{
		// Don't bother the UI when nothing changes!
		return S_OK;
	}

	Update();

	return S_OK;
}

STDMETHODIMP CSrvcCall::Failed(ULONG uError)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::Accepted(INmConference *pConference)
{
	return S_OK;
}

// INmCallNotify3 methods
STDMETHODIMP CSrvcCall::CallError(UINT cns)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::VersionConflict(HRESULT Status, BOOL *pfContinue)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb, BOOL fIsService)
{
	return S_OK;
}

/*  U P D A T E  */
/*-------------------------------------------------------------------------
    %%Function: Update

    Update the cached information about the call
-------------------------------------------------------------------------*/
VOID CSrvcCall::Update(void)
{
	m_pCall->GetState(&m_State);
	// TRACE_OUT(("CCall: New State=%0d for call=%08X", m_State, this));

	switch (m_State)
	{
	case NM_CALL_ACCEPTED:
	case NM_CALL_REJECTED:
	case NM_CALL_CANCELED:

		RemoveCall();
		Release();
		break;

	case NM_CALL_RING:
		m_pCall->Accept();
		break;

	default:
		ERROR_OUT(("CCall::Update: Unknown state %08X", m_State));

	case NM_CALL_INVALID:
	case NM_CALL_INIT:
	case NM_CALL_SEARCH:
	case NM_CALL_WAIT:
		break;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\taskbar.h ===
#ifndef _TASKBAR_H_
#define _TASKBAR_H_

#define ID_TASKBAR_ICON	1000
const UINT WM_TASKBAR_NOTIFY =          WM_USER + 200;

BOOL AddTaskbarIcon(VOID);
BOOL RemoveTaskbarIcon(VOID);
BOOL OnRightClickTaskbar(VOID);
BOOL CmdActivate(VOID);
VOID CmdInActivate(VOID);
#endif // _TASKBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\srvcutil.cpp ===
// srvcutil.cpp

#include "precomp.h"

/*  B  S  T  R _ T O _  L  P  T  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: BSTR_to_LPTSTR
    
-------------------------------------------------------------------------*/
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr)
{
#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
	{
		ERROR_OUT(("WideCharToMultiByte failed"));
		return E_FAIL;
	}

	// cch is the number of BYTES required, including the null terminator
	*ppsz = (LPTSTR) new char[cch];
	if (*ppsz == NULL)
	{
		ERROR_OUT(("WideCharToMultiByte out of memory"));
		return E_OUTOFMEMORY;
	}

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, *ppsz, cch, NULL, NULL);
	return S_OK;
#else
	return E_NOTIMPL;
#endif // UNICODE
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Advise(pUnk, pdw);
		pCP->Release();
	}
	return hRes;
}

HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Unadvise(dw);
		pCP->Release();
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\srvccall.h ===
// File: srvccall.h

#ifndef _SRVCCALL_H_
#define _SRVCCALL_H_

class CSrvcCall : public INmCallNotify2
{
private:
	INmCall * m_pCall;
	BOOL      m_fIncoming;
	LPTSTR    m_pszName;
	LPTSTR    m_pszAddr;
	NM_ADDR_TYPE  m_addrType;
	NM_CALL_STATE m_State;
	BOOL      m_fSelectedConference;

	POSITION  m_pos;           // position in g_pCallList
	DWORD     m_dwTick;        // tick count at call start
	ULONG     m_cRef;
	DWORD     m_dwCookie;

public:
	CSrvcCall(INmCall * pCall);
	~CSrvcCall();

	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv);

	// INmCallNotify methods
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CALL_STATE uState);
	STDMETHODIMP Failed(ULONG uError);
	STDMETHODIMP Accepted(INmConference *pConference);

	// INmCallNotify2 methods
	STDMETHODIMP CallError(UINT cns);
	STDMETHODIMP VersionConflict(HRESULT Status, BOOL *pfContinue);
	STDMETHODIMP RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin);
	STDMETHODIMP RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb, BOOL fIsService);

	// Internal methods
	VOID    Update(void);
	VOID	RemoveCall(void);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\appcap.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);

/* 
 *	appcap.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CAppCap. 
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "appcap.h"
#include "clists.h"


/*
 *	CAppCap ()
 *
 *	Public Function Description:
 *		This constructor is used to create a AppCapabilityData object 
 * 		from an "API" GCCApplicationCapability list.
 */
CAppCap::CAppCap(UINT   						number_of_capabilities,
				PGCCApplicationCapability		*	capabilities_list,
				PGCCError							pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','C','a','p')),
    m_AppCapItemList(DESIRED_MAX_CAPS),
    m_cbDataSize(0)
{
	APP_CAP_ITEM    *pAppCapItem;
	UINT			i;
	GCCError        rc;

	rc = GCC_NO_ERROR;

	for (i = 0; i < number_of_capabilities; i++)
	{
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType) capabilities_list[i]->capability_class.eType);
		if (pAppCapItem != NULL)
		{
			DBG_SAVE_FILE_LINE
			pAppCapItem->pCapID = new CCapIDContainer(
			                                &capabilities_list[i]->capability_id,
			                                &rc);
			if ((pAppCapItem->pCapID != NULL) && (rc == GCC_NO_ERROR))
			{
				if (capabilities_list[i]->capability_class.eType ==
										GCC_UNSIGNED_MINIMUM_CAPABILITY)
				{
					pAppCapItem->nUnsignedMinimum =
							capabilities_list[i]->capability_class.nMinOrMax;
				}
				else if	(capabilities_list[i]->capability_class.eType 
									== GCC_UNSIGNED_MAXIMUM_CAPABILITY)
				{
					pAppCapItem->nUnsignedMaximum =
							capabilities_list[i]->capability_class.nMinOrMax;
				}

				pAppCapItem->cEntries = 1;

				/*
				 * Add this capability to the list.
				 */
				m_AppCapItemList.Append(pAppCapItem);
			}
			else if (pAppCapItem->pCapID == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
			}

			if(rc != GCC_NO_ERROR)
			{
				delete pAppCapItem;
			}
			
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}

		if (rc != GCC_NO_ERROR)
			break;
	}

    *pRetCode = rc;
}

/*
 *	~CAppCap()
 *
 *	Public Function Description
 *		The CAppCap destructor is responsible for freeing 
 *		any memory allocated to hold the capability data.
 *
 */
CAppCap::~CAppCap(void)
{
	m_AppCapItemList.DeleteList();
}

/*
 *	LockCapabilityData ()
 *
 *	Public Function Description:
 *		This routine locks the capability data and determines the amount of
 *		memory referenced by the "API" non-collapsing capability data structure.
 */
UINT CAppCap::LockCapabilityData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the list of
	 * capabilities.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		APP_CAP_ITEM    *pAppCapItem;
		/*
		 * Add the amount of memory necessary to hold the string data associated
		 * with each capability ID.
		 */
		m_AppCapItemList.Reset();

		/*
		 * Lock the data for each capability ID.  The lock call	returns the 
		 * length of the data referenced by each capability ID rounded to occupy
		 * an even multiple of four-bytes.
		 */
		while (NULL != (pAppCapItem = m_AppCapItemList.Iterate()))
		{
			m_cbDataSize += pAppCapItem->pCapID->LockCapabilityIdentifierData();
		}

		/*
		 * Add the memory to hold the application capability pointers
		 * and structures.
		 */
		m_cbDataSize += m_AppCapItemList.GetCount() * 
				(sizeof (PGCCApplicationCapability) +
				ROUNDTOBOUNDARY( sizeof(GCCApplicationCapability)) );
	}

	return m_cbDataSize;
}

/*
 *	GetGCCApplicationCapabilityList ()
 *
 *	Public Function Description:
 *		This routine retrieves the application capabilities list in the form of
 * 		a list of PGCCApplicationCapability's.	This routine is called after 
 * 		"locking" the capability data.
 */
UINT CAppCap::GetGCCApplicationCapabilityList(
						PUShort							number_of_capabilities,
						PGCCApplicationCapability  * *	capabilities_list,
						LPBYTE							memory)
{
	UINT cbDataSizeToRet = 0;

	/*
	 * If the capability data has been locked, fill in the output structure and
	 * the data referenced by the structure.
	 */ 
	if (GetLockCount() > 0)
	{
    	UINT								data_length = 0;
    	UINT								capability_id_data_length = 0;
    	USHORT								capability_count;
    	PGCCApplicationCapability			gcc_capability;
    	PGCCApplicationCapability		*	gcc_capability_list;
    	APP_CAP_ITEM                        *pAppCapItem;

		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Retrieve the number of capabilities and fill in any that are present.
		 */
		*number_of_capabilities = (USHORT) m_AppCapItemList.GetCount();

		if (*number_of_capabilities != 0)
		{
			/*
			 * Fill in the pointer to the list of application capability
			 * pointers.  The pointer list will begin at the memory location 
			 * passed into this routine.  Save the list pointer in a local 
			 * variable for convenience.
			 */
			*capabilities_list = (PGCCApplicationCapability *)memory;
			gcc_capability_list = *capabilities_list;

			/*
			 * Move the memory pointer past the list of capability pointers.
			 * This	is where the first application capability structure will be
			 * written.
			 */
			memory += (*number_of_capabilities * sizeof(PGCCApplicationCapability));

			/*
			 * Add to the data length the amount of memory necessary to hold the
			 * application capability pointers.  Go ahead and add the amount of 
			 * memory necessary to hold all of the GCCApplicationCapability 
			 * structures.
			 */
			data_length += *number_of_capabilities *
					(sizeof(PGCCApplicationCapability) + 
					ROUNDTOBOUNDARY ( sizeof(GCCApplicationCapability)) ); 

			/*
			 * Iterate through the capabilities list, building an "API"
			 * capability for each capability in the list.
			 */
			capability_count = 0;
			m_AppCapItemList.Reset();
			while (NULL != (pAppCapItem = m_AppCapItemList.Iterate()))
			{
				/*
				 * Set the application capability pointer equal to the
				 * location in memory where it will be written.
				 */
				gcc_capability = (PGCCApplicationCapability)memory;

				/*
				 * Save the pointer to the application capability in the
				 * list of application capability pointers.
				 */
				gcc_capability_list[capability_count] = gcc_capability;

				/*
				 * Advance the memory pointer past the application capability
				 * structure.  This is where the string data for the capability
				 * ID will be written.  Ensure that the memory pointer falls on 
				 * an even four-byte boundary.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationCapability));

				/*
				 * Retrieve the capability ID information from the internal 
				 * CapabilityIDData object.  The length returned by this call 
				 * will	have already been rounded to an even multiple of four 
				 * bytes.
				 */
				capability_id_data_length = pAppCapItem->pCapID->
						GetGCCCapabilityIDData(&gcc_capability->capability_id, memory);

				/*
				 * Advance the memory pointer past the string data written into 
				 * memory by the capability ID object.  Add the length of the 
				 * string data to the overall capability length.
				 */
				memory += capability_id_data_length;
				data_length += capability_id_data_length;

				/*
				 * Now fill in the rest of the capability.
				 */
				gcc_capability->capability_class.eType = pAppCapItem->eCapType;

				if (gcc_capability->capability_class.eType ==
										GCC_UNSIGNED_MINIMUM_CAPABILITY)
				{
					gcc_capability->capability_class.nMinOrMax =
						pAppCapItem->nUnsignedMinimum;
				}
				else if (gcc_capability->capability_class.eType ==
										GCC_UNSIGNED_MAXIMUM_CAPABILITY)
				{
					gcc_capability->capability_class.nMinOrMax =
						pAppCapItem->nUnsignedMaximum;
				}

				gcc_capability->number_of_entities = pAppCapItem->cEntries;

				/*
				 * Increment the capability array counter.
				 */
				capability_count++;
			}
		}
		else
		{
			cbDataSizeToRet = 0;
	  		capabilities_list = NULL;
		}
	}
	else
	{
		ERROR_OUT(("CAppCap::GetData: Error: data not locked"));
	}

	return (cbDataSizeToRet);
}

/*
 *	UnLockCapabilityData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" capability once the lock count reaches zero.
 */
void CAppCap::UnLockCapabilityData(void)
{
	if (Unlock(FALSE) == 0)
	{
		APP_CAP_ITEM    *pAppCapItem;
		/*
		 * Iterate through the list of collapsed capabilities, unlocking the
		 * data for each CapabilityIDData object associated with each 
		 * capability.
		 */
		m_AppCapItemList.Reset();
		while (NULL != (pAppCapItem = m_AppCapItemList.Iterate()))
		{
			pAppCapItem->pCapID->UnLockCapabilityIdentifierData();
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}



APP_CAP_ITEM::APP_CAP_ITEM(GCCCapabilityType eCapType)
:
	pCapID(NULL),
	eCapType(eCapType),
	cEntries(0),
	poszAppData(NULL)
{
}

APP_CAP_ITEM::APP_CAP_ITEM(APP_CAP_ITEM *p, PGCCError pError)
	:	poszAppData(NULL)
{
	//	First set up the capability id
	DBG_SAVE_FILE_LINE
	pCapID = new CCapIDContainer(p->pCapID, pError);
	if (NULL != pCapID)
	{
		//	Initialize the new capability to default values.
		eCapType = p->eCapType;

		if (p->eCapType == GCC_UNSIGNED_MINIMUM_CAPABILITY)
		{
			nUnsignedMinimum = (UINT) -1;
		}
		else if (p->eCapType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
		{
			nUnsignedMaximum = 0;
		}

		cEntries = p->cEntries;
        //
		// LONCHANC: We do not copy the entries in application data???
        //

		*pError = GCC_NO_ERROR;
	}
	else
	{
		*pError = GCC_ALLOCATION_FAILURE;
	}
}


APP_CAP_ITEM::~APP_CAP_ITEM(void)
{
    if (NULL != pCapID)
    {
        pCapID->Release();
    }

    delete poszAppData;
}


void CAppCapItemList::DeleteList(void)
{
    APP_CAP_ITEM *pAppCapItem;
    while (NULL != (pAppCapItem = Get()))
    {
        delete pAppCapItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\srvcutil.h ===
// srvcutil.h

HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\srvc\taskbar.cpp ===
// File: taskbar.cpp

#include "precomp.h"
#include "taskbar.h"
#include <iappldr.h>
#include <tsecctrl.h>

static HWND g_hwndHidden = NULL;
const TCHAR g_cszHiddenWndClassName[] = _TEXT("MnmSrvcHiddenWindow");
BOOL g_fTaskBarIconAdded = FALSE;
BOOL g_fTimerRunning = FALSE;
extern INmSysInfo2 * g_pNmSysInfo;
extern int g_cPersonsInConf;

// This routine starts a timer to periodically retry adding the taskbar icon.
// This is necessary in case the taskbar is not showing at the time the
// service is launched, or the taskbar is destroyed by a logoff-logon sequence.

VOID StartTaskbarTimer(VOID)
{
    if ( !g_fTimerRunning)
    {
        ASSERT(g_hwndHidden);
        SetTimer(g_hwndHidden, 0, 5000, NULL);
        g_fTimerRunning = TRUE;
    }
}

VOID KillTaskbarTimer(VOID)
{
    if ( g_fTimerRunning )
    {
        KillTimer ( g_hwndHidden, 0 );
        g_fTimerRunning = FALSE;
    }
}

LRESULT CALLBACK HiddenWndProc(    HWND hwnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_USERCHANGED:
        case WM_ENDSESSION:
            // A user is logging on or off... We don't know which but
            // since the desktop is changing we assume our taskbar icon
            // is toast. Start a timer to periodically try to add it back
            // until it succeeds.
            g_fTaskBarIconAdded = FALSE;
            StartTaskbarTimer();
            break;
            
        case WM_TASKBAR_NOTIFY:
        {
            if (WM_RBUTTONUP == lParam)
            {
                ::OnRightClickTaskbar();
            }
            break;
        }

        case WM_TIMER:
            AddTaskbarIcon();
            break;
        
        case WM_DESTROY:
        {
            // NULL the global variable:
            g_hwndHidden = NULL;
            return 0;
        }

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return FALSE;
}

BOOL CmdActivate(VOID)
{
    RegEntry Re( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE );
    Re.SetValue ( REMOTE_REG_ACTIVATESERVICE, (DWORD)1 );
    if (MNMServiceActivate())
    { 
        ReportStatusToSCMgr( SERVICE_RUNNING, NO_ERROR, 0);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

VOID CmdInActivate(VOID)
{
    RegEntry Re( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE );
    Re.SetValue ( REMOTE_REG_ACTIVATESERVICE, (DWORD)0 );
    if (MNMServiceDeActivate())
        ReportStatusToSCMgr( SERVICE_PAUSED, NO_ERROR, 0);
}

VOID CmdSendFiles(VOID)
{
    ASSERT(g_pNmSysInfo);
    if (g_pNmSysInfo)
    {
        g_pNmSysInfo->ProcessSecurityData(LOADFTAPPLET, 0, 0, NULL);
    }
}

VOID CmdShutdown(VOID)
{
    if (STATE_ACTIVE == g_dwActiveState)
    {
        CmdInActivate();
    }
    MNMServiceStop();
    DestroyWindow(g_hwndHidden);
}

BOOL AddTaskbarIcon(VOID)
{
    BOOL bRet = FALSE;
    
    if ( NULL == g_hwndHidden )
    {
        // Register hidden window class:
        WNDCLASS wcHidden =
        {
            0L,
            HiddenWndProc,
            0,
            0,
            GetModuleHandle(NULL),
            NULL,
            NULL,
            NULL,
            NULL,
            g_cszHiddenWndClassName
        };
        
        if (!RegisterClass(&wcHidden))
        {
            ERROR_OUT(("Could not register hidden wnd classes"));
            return FALSE;
        }

        // Create a hidden window for event processing:
        g_hwndHidden = ::CreateWindow(    g_cszHiddenWndClassName,
                                        _TEXT(""),
                                        WS_POPUP, // not visible!
                                        0, 0, 0, 0,
                                        NULL,
                                        NULL,
                                        GetModuleHandle(NULL),
                                        NULL);
    }

    if (NULL == g_hwndHidden)
    {
        ERROR_OUT(("Could not create hidden windows"));
        return FALSE;
    }

    // Place a 16x16 icon in the taskbar notification area:    
    NOTIFYICONDATA tnid;

    tnid.cbSize = sizeof(NOTIFYICONDATA);
    tnid.hWnd = g_hwndHidden;
    tnid.uID = ID_TASKBAR_ICON;
    tnid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
    tnid.uCallbackMessage = WM_TASKBAR_NOTIFY;
    tnid.hIcon = LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_SM_WORLD));

    ::LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_TITLE,
        tnid.szTip, CCHMAX(tnid.szTip));

    // Attempt to add the icon. This may fail because there is no taskbar
    // (no user desktop shown). Warn if this is so... We will retry on
    // a periodic timer.

    if (FALSE == (bRet = Shell_NotifyIcon(NIM_ADD, &tnid)))
    {
        #ifdef DEBUG
        if ( !g_fTimerRunning )
           WARNING_OUT(("Could not add notify icon!"));
        #endif // DEBUG

        // Start the taskbar timer to periodically retry until this succeeds
        StartTaskbarTimer();
    }
    else
    {
        g_fTaskBarIconAdded = TRUE;
        KillTaskbarTimer(); // Kill timer if necessary
    }

    if (NULL != tnid.hIcon)
    {
        DestroyIcon(tnid.hIcon);
    }

    return bRet;
}

BOOL RemoveTaskbarIcon(VOID)
{
    NOTIFYICONDATA tnid;
    BOOL ret;

    if ( !g_fTaskBarIconAdded || NULL == g_hwndHidden )
    {
        return FALSE;
    }

    tnid.cbSize = sizeof(NOTIFYICONDATA);
    tnid.hWnd = g_hwndHidden;
    tnid.uID = ID_TASKBAR_ICON;

    ret = Shell_NotifyIcon(NIM_DELETE, &tnid);

    g_fTaskBarIconAdded = FALSE;
    return ret;
}

BOOL OnRightClickTaskbar()
{
    TRACE_OUT(("OnRightClickTaskbar called"));

    POINT ptClick;
    if (FALSE == ::GetCursorPos(&ptClick))
    {
        ptClick.x = ptClick.y = 0;
    }
    
    // Get the menu for the popup from the resource file.
    HMENU hMenu = ::LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_TASKBAR_POPUP));
    if (NULL == hMenu)
    {
        return FALSE;
    }

    // Get the first menu in it which we will use for the call to
    // TrackPopup(). This could also have been created on the fly using
    // CreatePopupMenu and then we could have used InsertMenu() or
    // AppendMenu.
    HMENU hMenuTrackPopup = ::GetSubMenu(hMenu, 0);

    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
    BOOL fNoExit = reLM.GetNumber(REMOTE_REG_NOEXIT, DEFAULT_REMOTE_NOEXIT);
    
    ::EnableMenuItem(hMenuTrackPopup, IDM_TBPOPUP_STOP, fNoExit ? MF_GRAYED : MF_ENABLED);
    
    if (STATE_ACTIVE == g_dwActiveState)
    {
        ::EnableMenuItem(hMenuTrackPopup, IDM_TBPOPUP_INACTIVATE, fNoExit ? MF_GRAYED : MF_ENABLED);
        ::EnableMenuItem(hMenuTrackPopup, IDM_TBPOPUP_SENDFILES, (2 == g_cPersonsInConf) ? MF_ENABLED : MF_GRAYED);
    }
    else if (STATE_INACTIVE == g_dwActiveState)
    {
        HANDLE hInit = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, _TEXT("CONF:Init"));

        ::EnableMenuItem(hMenuTrackPopup, IDM_TBPOPUP_ACTIVATE, hInit ?
                                                    MF_GRAYED : MF_ENABLED);
        ::CloseHandle(hInit);
    }
    else
    {
        // Leave all menus grayed
    }

    // Draw and track the "floating" popup 
    // According to the font view code, there is a bug in USER which causes
    // TrackPopupMenu to work incorrectly when the window doesn't have the
    // focus.  The work-around is to temporarily create a hidden window and
    // make it the foreground and focus window.

    HWND hwndDummy = ::CreateWindow(_TEXT("STATIC"), NULL, 0, 
                                    ptClick.x, 
                                    ptClick.y,
                                    1, 1, HWND_DESKTOP,
                                    NULL, GetModuleHandle(NULL), NULL);
    if (NULL != hwndDummy)
    {
        HWND hwndPrev = ::GetForegroundWindow();    // to restore

        TPMPARAMS tpmp;
        tpmp.cbSize = sizeof(tpmp);
        tpmp.rcExclude.right = 1 + (tpmp.rcExclude.left = ptClick.x);
        tpmp.rcExclude.bottom = 1 + (tpmp.rcExclude.top = ptClick.y);
        
        ::SetForegroundWindow(hwndDummy);
        ::SetFocus(hwndDummy);

        int iRet = ::TrackPopupMenuEx(    hMenuTrackPopup, 
                                                TPM_RETURNCMD | TPM_HORIZONTAL | TPM_RIGHTALIGN | 
                                                TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
                                                ptClick.x, 
                                                ptClick.y,
                                                hwndDummy, 
                                                &tpmp);

        // Restore the previous foreground window (before destroying hwndDummy).
        if (hwndPrev)
        {
            ::SetForegroundWindow(hwndPrev);
        }

        ::DestroyWindow(hwndDummy);

        switch (iRet)
        {
                    case IDM_TBPOPUP_ACTIVATE:
                    {
                        CmdActivate();
                        break;
                    }
                    case IDM_TBPOPUP_INACTIVATE:
                    {
                        CmdInActivate();
                        break;
                    }
                    case IDM_TBPOPUP_SENDFILES:
                    {
                        CmdSendFiles();
                        break;
                    }
                    case IDM_TBPOPUP_STOP:
                    {
                        CmdShutdown();
                        break;
                    }
                    default:
                        break;
        }
    }

    // We are finished with the menu now, so destroy it
    ::RemoveMenu(hMenu, 0, MF_BYPOSITION);
    ::DestroyMenu(hMenuTrackPopup);
    ::DestroyMenu(hMenu);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\appenrol.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	appenrol.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class 
 *		ApplicationEnrollRequestData. 
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "appenrol.h"

/*
 *	ApplicationEnrollRequestData ()
 *
 *	Public Function Description:
 *		This constructor is used to create a ApplicationEnrollRequestData object
 *		from an ApplicationEnrollRequestMessage in preparation for serializing
 *		the application enroll request data.
 */
ApplicationEnrollRequestData::ApplicationEnrollRequestData(
				PApplicationEnrollRequestMessage		enroll_request_message,
				PGCCError								pRetCode)
{
    GCCError rc = GCC_NO_ERROR;
	Session_Key_Data = NULL;
	Non_Collapsing_Caps_Data = NULL;
	Application_Capability_Data = NULL;

	/*
	 * Save the message structure in an instance variable.  This will save all
	 * structure elements except the session key and the lists of non-collapsing
	 * and application capabilities.
	 */
	Enroll_Request_Message = *enroll_request_message;

	/*
	 * Create a CSessKeyContainer object to be used to handle the session key
	 * contained in the enroll request message.
	 */
	if (Enroll_Request_Message.session_key != NULL)
	{
		DBG_SAVE_FILE_LINE
		Session_Key_Data = new CSessKeyContainer(
										Enroll_Request_Message.session_key,
										&rc);
		if ((Session_Key_Data != NULL) && (rc == GCC_NO_ERROR))
		{
			if (Enroll_Request_Message.number_of_non_collapsed_caps != 0)
			{
				/*
				 * Create a CNonCollAppCap object to hold the non-
				 * collapsing capabilities.
				 */
				DBG_SAVE_FILE_LINE
				Non_Collapsing_Caps_Data = new CNonCollAppCap(	
							(ULONG) Enroll_Request_Message.number_of_non_collapsed_caps,
							Enroll_Request_Message.non_collapsed_caps_list,
							&rc);
				if (Non_Collapsing_Caps_Data == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
				else if (rc != GCC_NO_ERROR)
				{
				    Non_Collapsing_Caps_Data->Release();
				    Non_Collapsing_Caps_Data = NULL;
				}
			}
			else
			{
				Non_Collapsing_Caps_Data = NULL;
			}

			if ((rc == GCC_NO_ERROR) &&
				(Enroll_Request_Message.number_of_collapsed_caps != 0))
			{
				/*
				 * Create an CAppCap object to hold the
				 * application capabilities.
				 */
				DBG_SAVE_FILE_LINE
				Application_Capability_Data = new CAppCap(
							(ULONG) Enroll_Request_Message.number_of_collapsed_caps,
							Enroll_Request_Message.collapsed_caps_list,
							&rc);
				if (Application_Capability_Data == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
				else if (rc != GCC_NO_ERROR)
				{
				    Application_Capability_Data->Release();
				    Application_Capability_Data = NULL;
				}
			}
			else
			{
				Application_Capability_Data = NULL;
			}
		}
		else if (Session_Key_Data == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else
		{
		    Session_Key_Data->Release();
		    Session_Key_Data = NULL;
		}
	}
	else
	{
		Session_Key_Data = NULL;
		Application_Capability_Data = NULL;
		Non_Collapsing_Caps_Data = NULL;

		/*
		**	Note that if no session key is present there is no need to pass
		**	any capability information.
		*/
		Enroll_Request_Message.number_of_non_collapsed_caps = 0;
		Enroll_Request_Message.non_collapsed_caps_list = NULL;
		Enroll_Request_Message.number_of_collapsed_caps = 0;
		Enroll_Request_Message.collapsed_caps_list = NULL;
	}

    *pRetCode = rc;
}

/*
 *	ApplicationEnrollRequestData ()
 *
 *	Public Function Description:
 *		This constructor is used to create a ApplicationEnrollRequestData object
 *		from an ApplicationEnrollRequestMessage and the memory holding the
 *		enroll request's serialized data in preparation for deserializing
 *		the application enroll request data.
 */
ApplicationEnrollRequestData::ApplicationEnrollRequestData(
				PApplicationEnrollRequestMessage		enroll_request_message)
{
	Session_Key_Data = NULL;
	Non_Collapsing_Caps_Data = NULL;
	Application_Capability_Data = NULL;

	/*
	 * Save the message structure in an instance variable.  This will save all
	 * structure elements but not the data associated with the session key and 
	 * the lists of non-collapsing and application capabilities.
	 */
	Enroll_Request_Message = *enroll_request_message;

}

/*
 *	~ApplicationEnrollRequestData	()
 *
 *	Public Function Description
 *		The ApplicationEnrollRequestData destructor.
 *
 */
ApplicationEnrollRequestData::~ApplicationEnrollRequestData()
{
	/*
	 * Delete any internal data objects which may exist.
	 */
	if (NULL != Session_Key_Data)
	{
	    Session_Key_Data->Release();
	}

	if (NULL != Non_Collapsing_Caps_Data)
	{
	    Non_Collapsing_Caps_Data->Release();
	}

	if (NULL != Application_Capability_Data)
	{
	    Application_Capability_Data->Release();
	}
}

/*
 *	GetDataSize ()
 *
 *	Public Function Description
 *		This routine is used to determine the amount of memory necessary to
 *		hold all of the data associated with an ApplicationEnrollRequestMessage
 *		that is not held within the message strucuture.
 */
ULONG ApplicationEnrollRequestData::GetDataSize(void)
{
	ULONG data_size = 0;

	/*
	 * The first data referenced by the enroll request message is the data for
	 * the session key.  Use the internal CSessKeyContainer object to determine
	 * the length of the data referenced by the session key.  Also add the size
	 * of the actual session key structure.
	 */
	if (Session_Key_Data != NULL)
	{
		data_size += Session_Key_Data->LockSessionKeyData();
		data_size += ROUNDTOBOUNDARY (sizeof(GCCSessionKey));
	}

	/*
	 * Now determine the length of the list of non-collapsing capabilities and
	 * the length of the list of application capabilities.  This is done using
	 * the internal CNonCollAppCap and CAppCap objects.
	 */
	if (Non_Collapsing_Caps_Data != NULL)
	{
		data_size += Non_Collapsing_Caps_Data->LockCapabilityData();
	}

	if (Application_Capability_Data != NULL)
	{
		data_size += Application_Capability_Data->LockCapabilityData();
	}

	return (data_size);
}

/*
 *	Serialize ()
 *
 *	Public Function Description
 *		This routine is used to prepare an ApplicationEnrollRequest message
 *		for passing through shared memory.  The message structure is filled in
 *		and the data referenced by the structure written into the memory
 *		provided.
 */
ULONG ApplicationEnrollRequestData::Serialize(
					PApplicationEnrollRequestMessage	enroll_request_message,
	  				LPSTR								memory)
{
	ULONG	data_length;
	ULONG	total_data_length = 0;
	USHORT	app_capability_data_length;

	/*
	 * Copy the internal message structure into the output structure.  This will
	 * copy all	structure elements except the session key and the lists of 
	 * non-collapsing and application capabilities.
	 */
	*enroll_request_message = Enroll_Request_Message;

	if (Session_Key_Data != NULL)
	{
		/*
		 * Set the pointer to the session key structure.
		 */
		enroll_request_message->session_key = (PGCCSessionKey)memory;

		/*
		 * Move the memory pointer past the session key structure.
		 */
		memory += ROUNDTOBOUNDARY(sizeof(GCCSessionKey));

		/*
		 * Retrieve the session key data from the internal CSessKeyContainer 
		 * object.  It will serialize the necessary data into memory and return 
		 * the amount of data written.
		 */
		data_length = Session_Key_Data->GetGCCSessionKeyData (
								enroll_request_message->session_key, memory);

		total_data_length = data_length + ROUNDTOBOUNDARY(sizeof(GCCSessionKey));

		/*
		 * Move the memory pointer past the session key data.
		 */
		memory += data_length;
		Session_Key_Data->UnLockSessionKeyData();
	}
	else
    {
		enroll_request_message->session_key = NULL;
    }

	/*
	 * Retrieve the non-collapsing capabilities data from the internal
	 * CNonCollAppCap object.  It will serialize the necessary data
	 * into memory and return the amount of memory written.
	 */
	if (Non_Collapsing_Caps_Data != NULL)
	{
		data_length = Non_Collapsing_Caps_Data->GetGCCNonCollapsingCapsList (	
			&enroll_request_message->non_collapsed_caps_list,
			memory);
	
		total_data_length += data_length;

		/*
		 * Move the memory pointer past the non-collapsing capabilities and the
		 * associated data.
		 */
		memory += data_length;
		Non_Collapsing_Caps_Data->UnLockCapabilityData();
	}
	else
    {
		enroll_request_message->non_collapsed_caps_list = NULL;
    }
	
	if (Application_Capability_Data != NULL)
	{
		/*
		 * Retrieve the application capabilities from the internal 
		 * CAppCap object.  It will serialize the necessary data
		 * into memory and return the amount of memory written.
		 */
		total_data_length += Application_Capability_Data->
				GetGCCApplicationCapabilityList(
					&app_capability_data_length,
					&enroll_request_message->collapsed_caps_list,
					memory);
		Application_Capability_Data->UnLockCapabilityData();
	}

	diagprint1("AppEnrollReqData: Serialized %ld bytes", total_data_length);
	return (total_data_length);
}

/*
 *	Deserialize ()
 *
 *	Public Function Description
 *		This routine is used to retrieve an ApplicationEnrollRequest message
 *		after it has been passed through shared memory.
 */
void ApplicationEnrollRequestData::Deserialize(
					PApplicationEnrollRequestMessage	enroll_request_message)
{
	/*
	 * The internal structure contains the enroll request data with the pointers
	 * addressing the correct locations in memory so just copy the structure
	 * into the output parameter.
	 */
	*enroll_request_message = Enroll_Request_Message; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\capid.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	capid.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CCapIDContainer. 
 *		A CCapIDContainer object is used to maintain information about
 *		a particular capability of an application.  A capability identifier can
 *		be either a standard type or a non-standard type.  When the type is 
 *		standard, the identifier is stored internally as an integer value.  When
 *		the type is non-standard, an CObjectKeyContainer container object is used 
 *		internally to buffer the necessary data.  In this case the identifier 
 *		data may exist as an Object ID which is a series of non-negative 
 *		integers or an H221 non-standard ID which is an octet string of no fewer
 *		than four octets and no more than 255 octets. 
 *
 *	Protected Instance Variables:
 *		m_InternalCapID
 *			Structure used to hold the capability ID data internally.
 *		m_CapIDPDU
 *			Storage for the "PDU" form of the capability ID.
 *		m_fValidCapIDPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" capability ID.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCCapabilityID structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#include "capid.h"

/*
 *	CCapIDContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CCapIDContainer object 
 *		from an "API" GCCCapabilityID.
 */
CCapIDContainer::
CCapIDContainer(PGCCCapabilityID capability_id, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','a','p','I')),
    m_fValidCapIDPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	if (capability_id == NULL)
	{
		rc = GCC_INVALID_PARAMETER;
	}
	else
	{
	
		/*
		 * Save the GCCCapabilityID in the internal information structure.
		 */
		m_InternalCapID.capability_id_type = capability_id->capability_id_type;

		if (capability_id->capability_id_type == GCC_STANDARD_CAPABILITY)
		{
			m_InternalCapID.u.standard_capability = (USHORT) capability_id->standard_capability;
		}
		else
		{
			/*
			 * The object key portion of the capability ID is saved in an
			 * CObjectKeyContainer object.
			 */
			DBG_SAVE_FILE_LINE
			m_InternalCapID.u.non_standard_capability = 
					new CObjectKeyContainer(&capability_id->non_standard_capability, &rc);
			if (m_InternalCapID.u.non_standard_capability == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
			else if (rc == GCC_BAD_OBJECT_KEY)
		    {
				rc = GCC_BAD_CAPABILITY_ID;
			}
		}
	}

	*pRetCode = rc;
}

/*
 *	CCapIDContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a  CapabilityIdentifier object from
 *		a "PDU" CapabilityID.
 */
CCapIDContainer::
CCapIDContainer(PCapabilityID capability_id, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','a','p','I')),
    m_fValidCapIDPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	if (capability_id->choice == STANDARD_CHOSEN)
	{
		m_InternalCapID.capability_id_type = GCC_STANDARD_CAPABILITY;
		m_InternalCapID.u.standard_capability = capability_id->u.standard;
	}
	else
	{
		m_InternalCapID.capability_id_type = GCC_NON_STANDARD_CAPABILITY;
		DBG_SAVE_FILE_LINE
		m_InternalCapID.u.non_standard_capability =
		            new CObjectKeyContainer(&capability_id->u.capability_non_standard, &rc);
		if (m_InternalCapID.u.non_standard_capability == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else if (rc == GCC_BAD_OBJECT_KEY)
	    {
			rc = GCC_BAD_CAPABILITY_ID;
		}
	}

	*pRetCode = rc;
}

/*
 *	CCapIDContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CCapIDContainer 
 *		object from	another CCapIDContainer object.
 */
CCapIDContainer::
CCapIDContainer(CCapIDContainer *capability_id, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','a','p','I')),
    m_fValidCapIDPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	m_InternalCapID = capability_id->m_InternalCapID;

	if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
	{
		DBG_SAVE_FILE_LINE
		m_InternalCapID.u.non_standard_capability =
			new CObjectKeyContainer(capability_id->m_InternalCapID.u.non_standard_capability, &rc);
		if (m_InternalCapID.u.non_standard_capability == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else if (rc == GCC_BAD_OBJECT_KEY)
	    {
			rc = GCC_BAD_CAPABILITY_ID;
		}
	}

	*pRetCode = rc;
}

/*
 *	~CCapIDContainer()
 *
 *	Public Function Description
 *		The CCapIDContainer destructor is responsible for freeing any 
 *		memory allocated to hold the capability ID data for both the "API" and 
 *		"PDU" forms.
 *
 */
CCapIDContainer::~CCapIDContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidCapIDPDU)
		FreeCapabilityIdentifierDataPDU ();

	/* 
	 * Delete any object key data held internally.
	 */
	if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
	{
		if (NULL != m_InternalCapID.u.non_standard_capability)
		{
		    m_InternalCapID.u.non_standard_capability->Release();
		}
	}
}

/*
 *	LockCapabilityIdentifierData ()
 *
 *	Public Function Description:
 *		This routine locks the capability ID data and determines the amount of
 *		memory referenced by the "API" capability ID structure.
 */
UINT CCapIDContainer::LockCapabilityIdentifierData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the capability ID
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		m_cbDataSize = 0;

		if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
		{
			m_cbDataSize = m_InternalCapID.u.non_standard_capability->LockObjectKeyData (); 
		}
	}

	return m_cbDataSize;
}

/*
 *	GetGCCCapabilityIDData ()
 *
 *	Public Function Description:
 *		This routine retrieves capability ID data in the form of a 
 *		GCCCapabilityID.  This routine is called after "locking" the capability
 *		ID data.
 */
UINT CCapIDContainer::GetGCCCapabilityIDData(
							PGCCCapabilityID 		capability_id,
							LPBYTE					memory)
{
	UINT cbDataSizeToRet = 0;

	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output parameter which indicates the amount of memory
		 * used to hold all of the data associated with the capability ID.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the "API" capability ID from the internal structure.  If an
		 * object key exists, get the object key data by calling the "Get" 
		 * routine of the internal CObjectKeyContainer object.
		 */
		capability_id->capability_id_type = m_InternalCapID.capability_id_type;

		if (m_InternalCapID.capability_id_type == GCC_STANDARD_CAPABILITY)
		{
			capability_id->standard_capability = m_InternalCapID.u.standard_capability; 
		}
		else
		{
			/*
			 * The call to get the object key data returns the amount of data
			 * written into memory.  We do not need this value right now.
			 */
			m_InternalCapID.u.non_standard_capability->   
					GetGCCObjectKeyData( 
							&capability_id->non_standard_capability,
							memory);
		}
	}
	else
	{
		ERROR_OUT(("CCapIDContainer::GetGCCCapabilityIDData: Error data not locked"));
	}

	return (cbDataSizeToRet);
}

/*
 *	UnlockCapabilityIdentifierData ()
 *
 *	Public Function Description:
 *		This routine decrements the internal lock count and frees the memory 
 *		associated with the "API" capability ID when the lock count hits zero.
 */
void CCapIDContainer::UnLockCapabilityIdentifierData(void)
{
	if (Unlock(FALSE) == 0)
	{
		if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
		{
			m_InternalCapID.u.non_standard_capability->UnLockObjectKeyData(); 
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetCapabilityIdentifierDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the capability ID from it's internal form of an
 *		CAP_ID_STRUCT structure into the "PDU" form which can be 
 *		passed in to the ASN.1 encoder.  A pointer to a "PDU" "CapabilityID" 
 *		structure is returned.
 */
GCCError CCapIDContainer::GetCapabilityIdentifierDataPDU(PCapabilityID capability_id)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidCapIDPDU == FALSE)
	{
		m_fValidCapIDPDU = TRUE;

			if (m_InternalCapID.capability_id_type== GCC_STANDARD_CAPABILITY)
			{
				m_CapIDPDU.choice = STANDARD_CHOSEN;
				m_CapIDPDU.u.standard = m_InternalCapID.u.standard_capability;
			}
			else
			{
				m_CapIDPDU.choice = CAPABILITY_NON_STANDARD_CHOSEN;
				rc = m_InternalCapID.u.non_standard_capability->
							GetObjectKeyDataPDU(&m_CapIDPDU.u.capability_non_standard);
			}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*capability_id = m_CapIDPDU;

	return rc;
}

/*
 *	FreeCapabilityIdentifierDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the capability ID data held internally in
 *		the "PDU" form of a "CapabilityID".
 */
void CCapIDContainer::FreeCapabilityIdentifierDataPDU(void)
{
	if (m_fValidCapIDPDU)
	{
		/*
		 * Set the flag indicating that PDU session key data is no longer
		 * allocated.
		 */
		m_fValidCapIDPDU = FALSE;

		if (m_CapIDPDU.choice == CAPABILITY_NON_STANDARD_CHOSEN)
		{
			m_InternalCapID.u.non_standard_capability->FreeObjectKeyDataPDU();
		}
	}
}

/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not two Capibility ID's
 *		are equal in value.
 */
BOOL operator==(const CCapIDContainer& capability_id_1, const CCapIDContainer& capability_id_2)
{
	BOOL rc = FALSE;

	if (capability_id_1.m_InternalCapID.capability_id_type == 
						capability_id_2.m_InternalCapID.capability_id_type)
	{
		if (capability_id_1.m_InternalCapID.capability_id_type ==
														GCC_STANDARD_CAPABILITY)
		{
			if (capability_id_1.m_InternalCapID.u.standard_capability == 
					capability_id_2.m_InternalCapID.u.standard_capability)
			{
				rc = TRUE;
			}
		}
		else
		{
			if (*capability_id_1.m_InternalCapID.u.non_standard_capability == 
				*capability_id_2.m_InternalCapID.u.non_standard_capability)
			{
				rc = TRUE;
			}
		}
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\cntlist.cpp ===
#include "precomp.h"
#include "cntlist.h"


CList::CList(void)
:
    m_fQueue(FALSE),
    m_cMaxEntries(CLIST_DEFAULT_MAX_ITEMS)
{
    Init(1);
}


CList::CList(ULONG cMaxItems)
:
    m_fQueue(FALSE),
    m_cMaxEntries(cMaxItems)
{
    Init(1);
}


CList::CList(ULONG cMaxItems, ULONG cSubItems)
:
    m_fQueue(FALSE),
    m_cMaxEntries(cMaxItems)
{
    Init(cSubItems);
}


CList::CList(ULONG cMaxItems, ULONG cSubItems, BOOL fQueue)
:
    m_fQueue(fQueue),
    m_cMaxEntries(cMaxItems)
{
    Init(cSubItems);
}


CList::CList(CList *pSrc)
:
    m_fQueue(pSrc->m_fQueue),
    m_cMaxEntries(pSrc->GetCount())
{

    Init(1);

    LPVOID p;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate()))
    {
        Append(p);
    }
}


BOOL CList::Init(ULONG cSubItems)
{
    if (m_cMaxEntries < CLIST_DEFAULT_MAX_ITEMS)
    {
        m_cMaxEntries = CLIST_DEFAULT_MAX_ITEMS;
    }

    m_cEntries = 0;
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
    m_cSubItems = cSubItems;

    // it is kind of bad here because there is no way to return an error.
    // unfortunately it won't fault here and later.
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[m_cMaxEntries * m_cSubItems * sizeof(LPVOID)];
    CalcKeyArray();
    return m_aEntries ? TRUE : FALSE;
}


CList::~CList(void)
{
    delete m_aEntries;
}


void CList::CalcKeyArray(void)
{
    if (1 == m_cSubItems)
    {
        m_aKeys = NULL;
    }
    else
    {
        ASSERT(2 == m_cSubItems);
        m_aKeys = (NULL != m_aEntries) ?
                        (UINT_PTR *) &m_aEntries[m_cMaxEntries] :
                        NULL;
    }
}


BOOL CList::Expand(void)
{
    if (NULL == m_aEntries)
    {
        // it is impossible.
        ASSERT(FALSE);
        return Init(m_cSubItems);
    }

    // the current array is full
    ASSERT(m_cEntries == m_cMaxEntries);

    // remember the old array to free or to restore
    LPVOID  *aOldEntries = m_aEntries;

    // we need to allocate a bigger array to hold more data.
    // the new array has twice the size of the old one
    ULONG cNewMaxEntries = m_cMaxEntries << 1;
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[cNewMaxEntries * m_cSubItems * sizeof(LPVOID)];
    if (NULL == m_aEntries)
    {
        // we failed; we have to restore the array and return
        m_aEntries = aOldEntries;
        return FALSE;
    }

    // copy the old entries into the new array, starting from the beginning
    ULONG nIdx = m_cMaxEntries - m_nHeadOffset;
    ::CopyMemory(m_aEntries, &aOldEntries[m_nHeadOffset], nIdx * sizeof(LPVOID));
    ::CopyMemory(&m_aEntries[nIdx], aOldEntries, m_nHeadOffset * sizeof(LPVOID));

    // set the new max entries (required for the key array)
    m_cMaxEntries = cNewMaxEntries;

    if (m_cSubItems > 1)
    {
        ASSERT(2 == m_cSubItems);
        UINT_PTR *aOldKeys = m_aKeys;
        CalcKeyArray();
        ::CopyMemory(m_aKeys, &aOldKeys[m_nHeadOffset], nIdx * sizeof(UINT));
        ::CopyMemory(&m_aKeys[nIdx], aOldKeys, m_nHeadOffset * sizeof(UINT));
    }

    // Free the old array of entries
    delete aOldEntries;

    // Set the instance variables
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;

    return TRUE;
}


BOOL CList::Append(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_aEntries[(m_nHeadOffset + (m_cEntries++)) % m_cMaxEntries] = pData;

    return TRUE;
}


BOOL CList::Prepend(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_cEntries++;
    m_nHeadOffset = (0 == m_nHeadOffset) ? m_cMaxEntries - 1 : m_nHeadOffset - 1;
    m_aEntries[m_nHeadOffset] = pData;

    return TRUE;
}


BOOL CList::Find(LPVOID pData)
{
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        if (pData == m_aEntries[(m_nHeadOffset + i) % m_cMaxEntries])
        {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL CList::Remove(LPVOID pData)
{
    ULONG nIdx, nIdxSrc;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (pData == m_aEntries[nIdx])
        {
            if (! m_fQueue)
            {
                // to remove the current, we simply move the last to here.
                nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
                m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                if (m_cSubItems > 1)
                {
                    ASSERT(2 == m_cSubItems);
                    m_aKeys[nIdx] = m_aKeys[nIdxSrc];
                }
            }
            else
            {
                // to preserve the ordering
                if (0 == i)
                {
                    m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
                }
                else
                {
                    for (ULONG j = i + 1; j < m_cEntries; j++)
                    {
                        nIdx = (m_nHeadOffset + j - 1) % m_cMaxEntries;
                        nIdxSrc = (m_nHeadOffset + j) % m_cMaxEntries;
                        m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                        if (m_cSubItems > 1)
                        {
                            ASSERT(2 == m_cSubItems);
                            m_aKeys[nIdx] = m_aKeys[nIdxSrc];
                        }
                    }
                }
            }

            m_cEntries--;
            return TRUE;
        }
    }
    return FALSE;
}


LPVOID CList::Get(void)
{
    LPVOID pRet = NULL;

    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
    }
    return pRet;
}


LPVOID CList::Iterate(void)
{
    if (0 == m_cEntries)
    {
        return NULL;
    }

    if (m_nCurrOffset == CLIST_END_OF_ARRAY_MARK)
    {
        // start from the beginning
        m_nCurrOffset = 0;
    }
    else
    {
        if (++m_nCurrOffset >= m_cEntries)
        {
            // reset the iterator
            m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
            return NULL;
        }
    }

    return m_aEntries[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries];
}





CList2::CList2(CList2 *pSrc)
:
    CList(pSrc->GetCount(), 2, pSrc->m_fQueue)
{
    CalcKeyArray();

    LPVOID p;
    UINT_PTR n;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate(&n)))
    {
        Append(n, p);
    }
}


BOOL CList2::Append(UINT_PTR nKey, LPVOID pData)
{
    if (! CList::Append(pData))
    {
        return FALSE;
    }

    // after CList::append(), m_cEntries has been incremented,
    // therefore, we need decrement it again.
    m_aKeys[(m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries] = nKey;
    return TRUE;
}


BOOL CList2::Prepend(UINT_PTR nKey, LPVOID pData)
{
    if (! CList::Prepend(pData))
    {
        return FALSE;
    }

    m_aKeys[m_nHeadOffset] = nKey;
    return TRUE;
}


LPVOID CList2::Find(UINT_PTR nKey)
{
    ULONG nIdx;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            return m_aEntries[nIdx];
        }
    }
    return NULL;
}


LPVOID CList2::Remove(UINT_PTR nKey)
{
    ULONG nIdx, nIdxSrc;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            LPVOID pRet = m_aEntries[nIdx];
            if (! m_fQueue)
            {
                // to remove the current, we simply move the last to here.
                nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
                m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                m_aKeys[nIdx] = m_aKeys[nIdxSrc];
            }
            else
            {
                // to preserve the ordering
                if (0 == i)
                {
                    m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
                }
                else
                {
                    for (ULONG j = i + 1; j < m_cEntries; j++)
                    {
                        nIdx = (m_nHeadOffset + j - 1) % m_cMaxEntries;
                        nIdxSrc = (m_nHeadOffset + j) % m_cMaxEntries;
                        m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                        m_aKeys[nIdx] = m_aKeys[nIdxSrc];
                    }
                }
            }

            m_cEntries--;
            return pRet;
        }
    }
    return NULL;
}


LPVOID CList2::Get(UINT_PTR *pnKey)
{
    LPVOID pRet;
    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        *pnKey = m_aKeys[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
        *pnKey = 0;
    }
    return pRet;
}


LPVOID CList2::PeekHead(UINT_PTR *pnKey)
{
    LPVOID pRet;
    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        *pnKey = m_aKeys[m_nHeadOffset];
    }
    else
    {
        pRet = NULL;
        *pnKey = 0;
    }
    return pRet;
}


LPVOID CList2::Iterate(UINT_PTR *pnKey)
{
    LPVOID p = CList::Iterate();
    *pnKey = (NULL != p) ? m_aKeys[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries] : 0;
    return p;
}





#ifdef ENABLE_HASHED_LIST2

CHashedList2::CHashedList2(ULONG cBuckets, ULONG cInitItemsPerBucket)
:
    m_cBuckets(cBuckets),
    m_cInitItemsPerBucket(cInitItemsPerBucket),
    m_cEntries(0),
    m_nCurrBucket(0)
{
    m_aBuckets = new CList2* [m_cBuckets];
    ASSERT(NULL != m_aBuckets);
    if (NULL != m_aBuckets)
    {
        ::ZeroMemory(m_aBuckets, m_cBuckets * sizeof(CList2*));
    }
}


CHashedList2::CHashedList2(CHashedList2 *pSrc)
:
    m_cBuckets(pSrc->m_cBuckets),
    m_cInitItemsPerBucket(pSrc->m_cInitItemsPerBucket),
    m_cEntries(0),
    m_nCurrBucket(0)
{
    LPVOID p;
    UINT n;

    m_aBuckets = new CList2* [m_cBuckets];
    ASSERT(NULL != m_aBuckets);
    if (NULL != m_aBuckets)
    {
        ::ZeroMemory(m_aBuckets, m_cBuckets * sizeof(CList2*));
        pSrc->Reset();
        while (NULL != (p = pSrc->Iterate(&n)))
        {
            Insert(n, p);
        }
    }
}


CHashedList2::~CHashedList2(void)
{
    if (NULL != m_aBuckets)
    {
        for (ULONG i = 0; i < m_cBuckets; i++)
        {
            delete m_aBuckets[i];
        }
        delete [] m_aBuckets;
    }
}


BOOL CHashedList2::Insert(UINT nKey, LPVOID pData)
{
    if (NULL != m_aBuckets)
    {
        ULONG nBucket = GetHashValue(nKey);
        if (NULL == m_aBuckets[nBucket])
        {
            m_aBuckets[nBucket] = new CList2(m_cInitItemsPerBucket);
        }
        ASSERT(NULL != m_aBuckets[nBucket]);
        if (NULL != m_aBuckets[nBucket])
        {
            if (m_aBuckets[nBucket]->Append(nKey, pData))
            {
                m_cEntries++;
                return TRUE;
            }
        }
    }
    return FALSE;
}


LPVOID CHashedList2::Find(UINT nKey)
{
    if (NULL != m_aBuckets)
    {
        ULONG nBucket = GetHashValue(nKey);
        if (NULL != m_aBuckets[nBucket])
        {
            return m_aBuckets[nBucket]->Find(nKey);
        }
    }
    return NULL;
}


LPVOID CHashedList2::Remove(UINT nKey)
{
    if (NULL != m_aBuckets)
    {
        ULONG nBucket = GetHashValue(nKey);
        if (NULL != m_aBuckets[nBucket])
        {
            LPVOID pRet = m_aBuckets[nBucket]->Remove(nKey);
            if (NULL != pRet)
            {
                m_cEntries--;
                return pRet;
            }
        }
    }
    return NULL;
}


LPVOID CHashedList2::Get(UINT *pnKey)
{
    if (NULL != m_aBuckets)
    {
        if (m_cEntries)
        {
            for (ULONG i = 0; i < m_cBuckets; i++)
            {
                if (NULL != m_aBuckets[i])
                {
                    LPVOID pRet = m_aBuckets[i]->Get(pnKey);
                    if (NULL != pRet)
                    {
                        m_cEntries--;
                        return pRet;
                    }
                }
            }
        }
    }
    return NULL;
}


LPVOID CHashedList2::Iterate(UINT *pnKey)
{
    if (NULL != m_aBuckets)
    {
        for (ULONG i = m_nCurrBucket; i < m_cBuckets; i++)
        {
            if (NULL != m_aBuckets[i])
            {
                LPVOID pRet = m_aBuckets[i]->Iterate(pnKey);
                if (NULL != pRet)
                {
                    m_nCurrBucket = i;
                    return pRet;
                }
            }
        }
    }
    m_nCurrBucket = m_cBuckets; // over
    return NULL;
}


void CHashedList2::Reset(void)
{
    m_nCurrBucket = 0;

    if (NULL != m_aBuckets)
    {
        for (ULONG i = 0; i < m_cBuckets; i++)
        {
            if (NULL != m_aBuckets[i])
            {
                m_aBuckets[i]->Reset();
            }
        }
    }
}


void CHashedList2::Clear(void)
{
    m_cEntries = 0;
    m_nCurrBucket = 0;

    if (NULL != m_aBuckets)
    {
        for (ULONG i = 0; i < m_cBuckets; i++)
        {
            if (NULL != m_aBuckets[i])
            {
                m_aBuckets[i]->Clear();
            }
        }
    }
};


ULONG CHashedList2::GetHashValue(UINT nKey)
{
    const UINT PRIME_NUMBER_1 = 89;
    const UINT PRIME_NUMBER_2 = 13;
    return ((ULONG) (nKey * PRIME_NUMBER_1 + PRIME_NUMBER_2) % m_cBuckets);
}

#endif // ENABLE_HASHED_LIST2


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\ms_util.cpp ===
#include "precomp.h"


CRefCount::CRefCount(DWORD dwStampID)
:
#ifndef SHIP_BUILD
    m_dwStampID(dwStampID),
#endif
    m_cRefs(1),
    m_cLocks(0)
{
}


// though it is pure virtual, we still need to have a destructor.
CRefCount::~CRefCount(void)
{
}


LONG CRefCount::AddRef(void)
{
    ASSERT(0 < m_cRefs);
    ::InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


LONG CRefCount::Release(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    if (0 == ::InterlockedDecrement(&m_cRefs))
    {
        ASSERT(0 == m_cLocks);
        delete this;
        return 0;
    }
    return m_cRefs;
}


void CRefCount::ReleaseNow(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    m_cRefs = 0;
    delete this;
}


LONG CRefCount::Lock(void)
{
    AddRef();
    ASSERT(0 <= m_cLocks);
    ::InterlockedIncrement(&m_cLocks);
    return m_cLocks;
}


LONG CRefCount::Unlock(BOOL fRelease)
{
    ASSERT(0 < m_cLocks);
    ::InterlockedDecrement(&m_cLocks);
    LONG c = m_cLocks; // in case Release() frees the object
    if (fRelease)
    {
        Release();
    }
    return c;
}


UINT My_strlenA(LPCSTR pszSrc)
{
	UINT cch = 0;
	if (NULL != pszSrc)
	{
		cch = lstrlenA(pszSrc);
	}
	return cch;
}

#if defined(_DEBUG)
LPSTR _My_strdupA(LPCSTR pszSrc, LPSTR pszFileName, UINT nLineNumber)
#else
LPSTR My_strdupA(LPCSTR pszSrc)
#endif
{
	if (NULL == pszSrc)
	{
		return NULL;
	}

	UINT cch = lstrlenA(pszSrc) + 1;
#if defined(_DEBUG)
	LPSTR pszDst = (LPSTR) DbgMemAlloc(cch, NULL, pszFileName, nLineNumber);
#else
	LPSTR pszDst = new char[cch];
#endif
	if (NULL != pszDst)
	{
		CopyMemory(pszDst, pszSrc, cch);
	}
	return pszDst;
}

UINT My_strlenW(LPCWSTR pszSrc)
{
	UINT cch = 0;
	if (NULL != pszSrc)
	{
		cch = lstrlenW(pszSrc);
	}
	return cch;
}

#if defined(_DEBUG)
LPWSTR _My_strdupW(LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber)
#else
LPWSTR My_strdupW(LPCWSTR pszSrc)
#endif
{
	if (NULL == pszSrc)
	{
		return NULL;
	}

	UINT cch = lstrlenW(pszSrc) + 1;
#if defined(_DEBUG)
	LPWSTR pszDst = (LPWSTR) DbgMemAlloc(cch * sizeof(WCHAR), NULL, pszFileName, nLineNumber);
#else
	LPWSTR pszDst = new WCHAR[cch];
#endif
	if (NULL != pszDst)
	{
		CopyMemory(pszDst, pszSrc, cch * sizeof(WCHAR));
	}
	return pszDst;
}

//
// LONCHANC: This is to provide backward compatibility to UnicodeString
// in protocol structures. hopefully, we can remove this hack later.
//
#if defined(_DEBUG)
LPWSTR _My_strdupW2(UINT cchSrc, LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber)
#else
LPWSTR My_strdupW2(UINT cchSrc, LPCWSTR pszSrc)
#endif
{
#if defined(_DEBUG)
	LPWSTR pwsz = (LPWSTR) DbgMemAlloc((cchSrc+1) * sizeof(WCHAR), NULL, pszFileName, nLineNumber);
#else
	LPWSTR pwsz = new WCHAR[cchSrc+1];
#endif
	if (NULL != pwsz)
	{
		CopyMemory(pwsz, pszSrc, cchSrc * sizeof(WCHAR));
	}
	pwsz[cchSrc] = 0;
	return pwsz;
}

int My_strcmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
	if (NULL == pwsz1 || NULL == pwsz2)
	{
		return -1;
	}

	WCHAR ch;
	while (0 == (ch = *pwsz1 - *pwsz2) &&
			NULL != *pwsz1++ &&
			NULL != *pwsz2++)
		;

	return (int) ch;
}


#if defined(_DEBUG)
LPOSTR _My_strdupO2(LPBYTE lpbSrc, UINT cOctets, LPSTR pszFileName, UINT nLineNumber)
#else
LPOSTR My_strdupO2(LPBYTE lpbSrc, UINT cOctets)
#endif
{
#if defined(_DEBUG)
	LPOSTR poszDst = (LPOSTR) DbgMemAlloc(sizeof(OSTR) + cOctets + 1, NULL, pszFileName, nLineNumber);
#else
	LPOSTR poszDst = (LPOSTR) new char[sizeof(OSTR) + cOctets + 1];
#endif
	if (NULL != poszDst)
	{
		poszDst->length = cOctets;
		poszDst->value = (LPBYTE) (poszDst + 1);
		::CopyMemory(poszDst->value, lpbSrc, cOctets);
	}
	return poszDst;
}


INT My_strcmpO(LPOSTR posz1, LPOSTR posz2)
{
	if (NULL == posz1 || NULL == posz2)
	{
		return -1;
	}

	if (posz1->length != posz2->length)
	{
		return -1;
	}

	UINT cnt = posz1->length;
	LPBYTE lpb1 = posz1->value, lpb2 = posz2->value;
	BYTE b = 0;
	while (cnt--)
	{
		if (0 != (b = *lpb1++ - *lpb2++))
		{
			break;
		}
	}
	return (INT) b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\hash.cpp ===
/*	hash.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the implementation of a dictionary data structure.  
 *
 */

#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);

#define MyMalloc(size)	new BYTE[size]
#define MyFree(ptr)		(delete [] (BYTE *) (ptr))
#define Max(a,b)		(((a) > (b)) ? (a) : (b))


/*  Function:  Constructor
 *
 *	Parameters:
 *		num_of_buckets:		Number of buckets in the dictionary
 *		dtype:				Dictionary type
 *
 *	Return value:
 *		None
 */

DictionaryClass::DictionaryClass (ULong num_of_buckets, DictionaryType dtype) :
	Type (dtype), NumOfExternItems (0)
{
	DWORD				i;	
	PDICTIONARY_ITEM	p;	// Goes through the initially allocated dictionary items to initialize the stack

	NumOfBuckets = Max (num_of_buckets, DEFAULT_NUMBER_OF_BUCKETS);

	/* Allocate the space needed for the dictionary */
	dwNormalSize = NumOfBuckets * (4 * sizeof (PDICTIONARY_ITEM) + 3 * sizeof (DICTIONARY_ITEM));
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	/* Initialize the Buckets */
	for (i = 0; i < NumOfBuckets; i++)
		Buckets[i] = NULL;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array.
	 * This is a stack of pointers to the real dictionary items. The stack is initialized with
	 * the addresses of the dictionary items
	 */ 

	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = p++;
}


/*  Function:  Copy Constructor
 *
 *	Parameters:
 *		original:	The original dictionary to make a copy of 
 *
 *	Return value:
 *		None
 *
 *	Note:
 *		This copy constructor will work ONLY for DWORD_DICTIONARY dictionaries.
 *		It will NOT work for the string dictionary types.
 */


DictionaryClass::DictionaryClass (const DictionaryClass& original)
{
	DWORD			 i;
	PDICTIONARY_ITEM p, q, r;

	NumOfBuckets = original.NumOfBuckets;
	Type = original.Type;
	NumOfExternItems = original.NumOfExternItems;

	// Allocate the space needed for the dictionary
	dwNormalSize = original.dwNormalSize;
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array */
	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	// Traverse the whole original hash sturcture to create the copy
	// p: goes through the original items
	// q: goes through current instance's items and initializes them
	// r: remembers the previous item in the new instance so that its "next" field could be set

	q = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (q--, i = 0; i < NumOfBuckets; i++) {
		for (r = NULL, p = original.Buckets[i]; p != NULL; p = p->next) {
			
			// Check if there are unused items in the current dictionary
			if (ItemCount <= 0) {
				q = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
				if (q == NULL)
					break;
			}
			else {
				ItemCount--;
				q++;
			}

			q->value = p->value;
			q->key = p->key;
			if (p == original.Buckets[i])
				Buckets[i] = q;
			else
				r->next = q;
			r = q;
		}

		// Set the "next" field for the last item in the bucket
		if (r == NULL)
			Buckets[i] = NULL;
		else
			r->next = NULL;
	}

	// Initialize the rest of the ItemArray array
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = q++;

}


/*  Function:  Destructor
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		None
 *
 */


DictionaryClass::~DictionaryClass ()
{
	DWORD			 i;
	DWORD			 dwOffset;		// Offset of the dictionary item.  If the offset does not indicate
									// that the item is from the initially allocated array, it has to 
									// be freed.
	PDICTIONARY_ITEM p, q;

	if (Buckets != NULL) {

		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++)
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY)
					MyFree (p->key);
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset >= 0 && dwOffset < dwNormalSize)
					p = p->next;
				else {  
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
					
		MyFree (Buckets);
		Buckets = NULL;
	}
}


/*  Function:  hashFunction
 *
 *	Parameters:
 *		key:	The key value
 *
 *	Return value:
 *		An integer in the range [0..NumOfBuckets-1] that indicates the bucket used for the "key".
 *
 */


DWORD DictionaryClass::hashFunction (DWORD key) 
{
	if (Type < STRING_DICTIONARY)
		return (key % NumOfBuckets);
	else
		return (*((unsigned char *) key) % NumOfBuckets);
}


/*  Function:  LengthStrcmp
 *
 *	Parameters:
 *		DictionaryKey:	Pointer to dictionary storage that keeps a length-sensitive string (which
 *						is a length followed by a string of that length.
 *		ChallengeKey:	Pointer to the length-sensitive key that is compared with the "DictionaryKey"
 *		length:			The length of the "ChallengeKey" string
 *
 *	Return value:
 *		0 if the "DictionaryKey" and "ChallengeKey" strings are the same. 1, otherwise.
 *
 *	Note:
 *		This function is only used for dictionaries of type LENGTH_STRING_DICTIONARY.
 */

int DictionaryClass::LengthStrcmp (DWORD DictionaryKey, DWORD ChallengeKey, ULong length)
{
	ULong					 i;
	char					*pDictionaryChar;	// Goes through the dictionary key string
	char					*pChallengeChar;	// Goes through the challenge string

	// Compare the lengths first
	if (length != * (ULong *) DictionaryKey)
		return 1;

	// Now, compare the strings themselves
	pDictionaryChar	= (char *) (DictionaryKey + sizeof (ULong));
	pChallengeChar = (char *) ChallengeKey;
	for (i = 0; i < length; i++)
		if (*pDictionaryChar++ != *pChallengeChar++)
			return 1;

	return 0;
}


/*  Function:  insert
 *		Inserts (key, value) pair in the dictionary
 *
 *	Parameters:
 *		new_key:	The new key that has to be inserted in the dictionary
 *		new_value:	The value associated with the "new_key"
 *		length:		Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the new key
 *
 *	Return value:
 *		TRUE, if the operation succeeds, FALSE, otherwise.
 *
 *	Note:
 *		If the "new_key" is already in the dictionary, the (new_key, new_value) pair is NOT
 *		inserted (the dictionary remains the same), and the return value is TRUE.
 */


BOOL DictionaryClass::insert (DWORD new_key, DWORD new_value, ULong length)
{
	PDICTIONARY_ITEM	pNewItem;			// Points to the allocated new dictionary item
	PDICTIONARY_ITEM	p;					// Goes through the bucket for the "new_key", searching for "new_key"
	DWORD				hash_val;			// The bucket ID for "new_key"
	BOOL				bIsNative = TRUE;	// TRUE, if the new allocated dictionary item is from the cache, FALSE otherwise

	if (Buckets == NULL)
		return FALSE;

	// Find if the item is already in the bucket, and if it's not, where it will get added.
	p = Buckets[hash_val = hashFunction (new_key)];

	ASSERT (hash_val >= 0 && hash_val < NumOfBuckets);

	if (p != NULL) {
		switch (Type) {
#if 0
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (; lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key) && p->next != NULL; p = p->next);
			if (0 == lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
#endif
		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (; LengthStrcmp (p->key, new_key, length) && p->next != NULL; p = p->next);
			if (0 == LengthStrcmp (p->key, new_key, length)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		default:
			ASSERT (length == 0);
			for (; p->key != new_key && p->next != NULL; p = p->next);
			if (p->key == new_key) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		}
	}

	// Allocate the new item
	if (ItemCount > 0)
		pNewItem = ItemArray[--ItemCount];		// from the cache
	else {										// the cache is empty, we have to malloc the new item
		pNewItem = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
		if (pNewItem != NULL) {
			bIsNative = FALSE;
			NumOfExternItems++;
		}
		else {
			return FALSE;
		}
	}

	ASSERT (pNewItem != NULL);

	// Fill in the "key" field of the new item
	switch (Type) {
#if 0
	case STRING_DICTIONARY:
		ASSERT (length == 0);
		pNewItem->key = (DWORD) MyMalloc ((lstrlen ((LPCTSTR) new_key) + 1) * sizeof(TCHAR));
		if (pNewItem->key == (DWORD) NULL) {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		lstrcpy ((LPTSTR) pNewItem->key, (LPCTSTR) new_key);
		break;
#endif

	case LENGTH_STRING_DICTIONARY:
		ASSERT (length > 0);
		pNewItem->key = (DWORD) MyMalloc (sizeof (ULong) + length * sizeof (TCHAR));
		if (pNewItem->key != (DWORD) NULL) {
			* ((ULong *) (pNewItem->key)) = length;
			memcpy ((void *) (pNewItem->key + sizeof (ULong)), (void *) new_key, length * sizeof (TCHAR));
		}
		else {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		break;

	default:
		ASSERT (length == 0);
		pNewItem->key = new_key;
		break;
	}

	// Fill in the rest of the fields of the new item
	pNewItem->value = new_value;
	pNewItem->next = NULL;

	// Insert the item in its bucket
	if (p == NULL)
		Buckets[hash_val] = pNewItem;
	else
		p->next = pNewItem;

	return TRUE;
}


/*  Function:  remove
 *		Removes (key, value) pair from the dictionary
 *
 *	Parameters:
 *		Key:	The key that has to be removed from the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the "Key"
 *
 *	Return value:
 *		None.
 *
 */

BOOL DictionaryClass::remove (DWORD Key, ULong length)
{
	PDICTIONARY_ITEM	p, q;		// They go through the dictionary items in "Key"'s bucket.
									// p: points to the current dictionary item in the bucket
									// q: points to the previous item
	DWORD				hash_val;	// The bucket ID for "Key"
	
	if (Buckets != NULL) {

		// Find the item in the dictionary
		p = Buckets [hash_val = hashFunction (Key)];

		ASSERT (hash_val >= 0 && hash_val < NumOfBuckets);

		switch (Type) {
#if 0
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (q = NULL; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); p = (q = p)->next) ;
			break;
#endif

		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (q = NULL; p != NULL && LengthStrcmp (p->key, Key, length); p = (q = p)->next) ;
			break;

		default:
			ASSERT (length == 0);
			for (q = NULL; p != NULL && p->key != Key; p = (q = p)->next);
			break;
		}

		// Remove the item 
		if (p != NULL) {
			if (q == NULL) 
				Buckets[hash_val] = p->next;
			else
				q->next = p->next;

			// Free the item found
			ASSERT (p != NULL);

			if (Type >= STRING_DICTIONARY)
				MyFree (p->key);
			hash_val = (PBYTE) p - (PBYTE) Buckets;
			if (hash_val >= 0 && hash_val < dwNormalSize)
				ItemArray[ItemCount++] = p;
			else {
				MyFree (p);
				NumOfExternItems--;
			}
			return TRUE;
		}
	}
	return FALSE;
}


/* Function:  find
 *		Looks up the key in the dictionary
 * 
 * Parameters
 *		Key:	The key to lookup
 *		pValue: Pointer to receive the value associated with "Key"
 *				It can be NULL, if we just try to find whether "Key" is in the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of "Key"
 *
 * Return value: 
 *		FALSE, if "Key" is not found in the dictionary
 *		TRUE, otherwise.
 */

BOOL DictionaryClass::find (DWORD Key, LPDWORD pValue, ULong length)
{
	PDICTIONARY_ITEM	p;		// Goes through the dictionary items in "Key"'s bucket.

	if (Buckets != NULL) {
		// Find the item in the dictionary
		p = Buckets [hashFunction (Key)];

		switch (Type) {
#if 0
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); p = p->next) ;
			break;
#endif

		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (; p != NULL && LengthStrcmp (p->key, Key, length); p = p->next) ;
			break;

		default:
			ASSERT (length == 0);
			for (; p != NULL && p->key != Key; p = p->next);
			break;
		}

		if (p != NULL) {
			// "Key" was found
			if (pValue != NULL)
				*pValue = p->value;
			return TRUE;
		}
	}

	if (pValue != NULL)
		*pValue = 0;
	return FALSE;

}

LPVOID DictionaryClass::Find(DWORD Key, UINT length)
{
	LPVOID Val;
	return find(Key, (LPDWORD) &Val, (ULONG) length) ? Val : NULL; 
}


/* Function:  iterate
 *		Iterates through the items of a dictionary.  It remembers where it has 
 *		stopped during the last call and starts from there.
 * 
 * Parameters
 *		pValue:	Pointer to DWORD that will hold the next value from the dictionary.
 *				It can be NULL.
 *		pKey:	Pointer to DWORD or unsigned short value to receive the key associated with the value.
 *				It can be NULL.
 *
 * Return value: 
 *		FALSE, when we reach the end of the dictionary
 *		TRUE, otherwise.  Then, *pKey and *pValue are valid
 *
 */

BOOL DictionaryClass::iterate (LPDWORD pValue, LPDWORD pKey)
{

	if (Buckets != NULL) {
		if (pCurrent) {
			pCurrent = pCurrent->next;
		}
		else {
			// start from the 1st item in the dictionary
			pCurrent = Buckets[ulCurrentBucket = 0];
		}

		// Advance "pCurrent" until it's not NULL, or we reach the end of the dictionary.
		for (; ulCurrentBucket < NumOfBuckets; pCurrent = Buckets[++ulCurrentBucket]) {
			if (pCurrent != NULL) {
				// we found the next item
				if (pKey)
					*pKey = pCurrent->key;
				if (pValue)
					*pValue = pCurrent->value;
				return TRUE;
			}
		}
	}

	pCurrent = NULL;
	return FALSE;
}

LPVOID DictionaryClass::Iterate(LPDWORD pKey)
{
	LPVOID Val;
	return iterate((LPDWORD) &Val, pKey) ? Val : NULL;
}

/* Function:  isEmpty
 * 
 * Parameters
 *		None.
 *
 * Return value: 
 *		TRUE, if the dictionary is empty.  FALSE, otherwise.
 *
 */

BOOL DictionaryClass::isEmpty (void)
{
	DWORD i;

	if (Buckets != NULL) {
		for (i = 0; i < NumOfBuckets; i++)
			if (Buckets[i] != NULL)
				return FALSE;
	}
	return TRUE;
}


/* Function:  clear
 *		Clears up the dictionary.  No (key, value) pairs are left in the dictionary.
 * 
 * Parameters:
 *		None.
 *
 * Return value: 
 *		None.
 *
 */

void DictionaryClass::clear (void)
{

	DWORD			 i;			// Goes through the "Buckets" array
	DWORD			 dwOffset;	// The offset of a dictionary item is used to determine
								// whether it's a native item (that needs to be returned to the cache),
								// or not (and needs to be freed).
	PDICTIONARY_ITEM p, q;		// Go through the items in a bucket

	if (Buckets != NULL) {
		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++) {
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY) 
					MyFree (p->key);

				// Compute the offset of the current dictionary item
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset >= 0 && dwOffset < dwNormalSize)
					p = p->next;
				else {  
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
			Buckets[i] = NULL;
		}

		// Initialize the class iterator
		pCurrent = NULL;

		/* Initialize the Dictionary items array */
		ItemCount = 3 * NumOfBuckets;
		p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
		for (i = 0; i < ItemCount; i++)
			ItemArray[i] = p++;

		NumOfExternItems = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\precomp.h ===
#define INC_OLE2
#define IDS_NULL_STRING			(0)
#include <windows.h>
#include <tchar.h>

// MCSNC includes
#include <databeam.h>

#include <oprahcom.h>
#include <confdbg.h>
// end MCSNC includes

extern "C"
{
#include <t120.h>
}
#include <memmgr.h>
#include <mcattprt.h>
#include <ncmcs.h>
#include <ConfDbg.h>
#include <debspew.h>
#include <RegEntry.h>
#include <ConfReg.h>
#include <oprahcom.h>
#include <it120nc.h>

#include "fclasses.h"

#include "cntlist.h"
#include "clists.h"
#include "ms_util.h"
#include <fsdiag.h>

#include <spacket.h>
#include <packet.h>
#include <datapkt.h>
#include <cmdtar.h>
#include <attmnt.h>
#include <channel.h>
#include <tptif.h>
#include <domain.h>
#include <connect.h>
#include <user.h>

#include "pdutypes.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\memory.cpp ===
#include "precomp.h"
/*
 *	memory.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Memory class.  Instances of
 *		this class represent chunks of data that are passed through a system.
 *		This class is particularly useful in cases where a memory buffer
 *		needs to be used in several different places, none of which know
 *		about each other.  This is because this class encapsulates things
 *		like lock counts, which are useful for holding memory until
 *		everyone that needs it is through.
 *
 *		Note that this class does NOT do memory management.  It is told by
 *		a higher level memory manager where its buffers are, etc.  For this
 *		reason, this class does not do any platform specific calls.
 *
 *	IMPORTANT NOTE:
 *		This class SHOULD NEVER contain virtual member functions. This is
 *		because of the Init() member than can be called as the "constructor"
 *		of this class.
 *
 *	Private Instance Variables:
 *		Length
 *			This is the length of the reference buffer.
 *		Copy_Ptr
 *			This is the address of the allocated buffer that this object
 *			uses.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

const char *MemorySignature = "T120Memr";

/*
 *	Memory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  It just initializes
 *		all instance variable, based on the passed in values.
 */
Memory::Memory (
		PUChar			reference_ptr,
		ULong			length,
		PUChar			copy_ptr) :
Length (length), 
Copy_Ptr (copy_ptr),
lLock (1),
m_priority (HIGHEST_PRIORITY)
{
	SIGNATURE_COPY(MemorySignature);
	
	/*
	 *	If the reference pointer is a valid pointer, then the pointer type
	 *	will be set to reference (indicating that the reference data has not
	 *	yet been copied).  If the reference pointer is NULL, then this is
	 *	a memory allocation with no associated reference data, so set the
	 *	pointer type to copy.
	 */
	if (reference_ptr != NULL)
		memcpy (Copy_Ptr, reference_ptr, (Int) Length);
}


/*
 *	Init ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the initializer for the Memory class, in the cases
 *		where the space for an object has been allocated, without
 *		calling the constructor.  It just initializes
 *		all instance variable, based on the passed in values.
 *
 *	NOTE: Because of this use of the Memory class, it should NOT
 *		contain any virtual functions.
 */
Void Memory::Init (
		PUChar			reference_ptr,
		ULong			length,
		MemoryPriority	priority,
		PUChar			copy_ptr)
{

	Length = length;
	Copy_Ptr = copy_ptr;
	lLock = 1;
	m_priority = priority;
	
	SIGNATURE_COPY(MemorySignature);
	
	/*
	 *	If the reference pointer is a valid pointer, then the pointer type
	 *	will be set to reference (indicating that the reference data has not
	 *	yet been copied).  If the reference pointer is NULL, then this is
	 *	a memory allocation with no associated reference data, so set the
	 *	pointer type to copy.
	 */
	if (reference_ptr != NULL)
		memcpy (Copy_Ptr, reference_ptr, (Int) Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\t120dbg.cpp ===
// t120dbg.cpp

#include "precomp.h"

#ifdef _DEBUG

#define INIT_DBG_ZONE_DATA
#include "fsdiag.h"


VOID T120DiagnosticCreate(VOID)
{
	MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
				(sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
}

VOID T120DiagnosticDestroy(VOID)
{
	MLZ_DbgDeInit();
}

#endif /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\appcap.h ===
/*
 *	appcap.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class ApplicationaCapabilityData.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_APP_CAPABILITY_DATA_
#define	_APP_CAPABILITY_DATA_

#include "capid.h"
#include "cntlist.h"

/*
**	Below is the definition for all the capabilities related structures and
**	containers.  The ListOfCapabilitiesList definition is used to maintain
**	all of the individual capabilities list at a single node (for multiple
**	protocol entities).
*/
typedef struct APP_CAP_ITEM
{
	APP_CAP_ITEM(GCCCapabilityType eCapType);
	APP_CAP_ITEM(APP_CAP_ITEM *p, GCCError *pError);
	~APP_CAP_ITEM(void);

    // in non-collapsing case, pCapID and poszAppData are used.
    // in appcap case, all but poszAppData are used.
    // in invoklst case, pCapID, eCapType, and the union are used.
	CCapIDContainer             *pCapID;
	GCCCapabilityType			eCapType;
	UINT       					cEntries;
	LPOSTR						poszAppData;	//	For Non-Collapsing only
	union 
	{
		UINT	nUnsignedMinimum;
		UINT	nUnsignedMaximum;
	};
}
    APP_CAP_ITEM;


/*
**	Holds the list of individual capabilities for a single Application Protocol 
**	Entity.  Remember that a single APE can have many capabilities.  
*/
class CAppCapItemList : public CList
{
    DEFINE_CLIST(CAppCapItemList, APP_CAP_ITEM*)
    void DeleteList(void);
};



// LONCHANC: CAppCap and CNonCollAppCap are very similar to each.

class CAppCap : public CRefCount
{
public:

	CAppCap(UINT cCaps, PGCCApplicationCapability *, PGCCError);
	~CAppCap(void);

	UINT		GetGCCApplicationCapabilityList(USHORT *pcCaps, PGCCApplicationCapability **, LPBYTE memory);

	UINT		LockCapabilityData(void);
	void		UnLockCapabilityData(void);

protected:

	UINT			    m_cbDataSize;
	CAppCapItemList     m_AppCapItemList;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\alarm.h ===
/*
 *	alarm.h
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, Kentucky
 *
 *	Abstract:
 *		
 *	Caveats:
 *		None
 *
 *	Author:
 *		James P. Galvin, Jr.
 *
 *	Revision History:
 *		09JAN95   jpg	Original
 */
#ifndef	_ALARM_
#define	_ALARM_

/*
 *	This is the class definition for the Alarm class.
 */
class CAlarm
{
public:

	CAlarm(UINT nDuration);
	~CAlarm(void) { }

	void			Set(UINT nDuration);
	void			Reset(void);
	void			Expire(void) { m_fExpired = TRUE; }
	BOOL			IsExpired(void);

private:

	UINT			m_nDuration;
	UINT			m_nStartTime;
	BOOL			m_fExpired;
};

typedef		CAlarm		Alarm,	*PAlarm;

/*
 *	Alarm (
 *			Long			duration)
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	~Alarm ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Void	Set (
 *					Long			duration)
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Void	Reset ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Long	GetTimeRemaining ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Void	Expire ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	BOOL		IsExpired ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\objkey.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	objkey.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CObjectKeyContainer.  This class 
 *		manages the data associated with an Object Key.  Object Key's are used 
 *		to identify a particular application protocol, whether it is standard or
 *		non-standard.  When used to identify a standard protocol, the Object Key
 *		takes the form of an Object ID which is a series of non-negative 
 *		integers.  This type of Object Key is maintained internally through the
 *		use of a Memory object.  When used to identify a non-standard 
 *		protocol, the Object Key takes the form of an H221 non-standard ID which
 *		is an octet string of no fewer than four octets and no more than 255 
 *		octets.  In this case the Object Key is maintained internally by using a
 *		Rogue Wave string object. 
 *
 *	Protected Instance Variables:
 *		m_InternalObjectKey
 *			Structure used to hold the object key data internally.
 *		m_ObjectKeyPDU
 *			Storage for the "PDU" form of the object key.
 *		m_fValidObjectKeyPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" object key.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCObjectKey structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#include "objkey.h"

/*
 *	CObjectKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create an CObjectKeyContainer object from
 *		an "API" GCCObjectKey.
 */
CObjectKeyContainer::CObjectKeyContainer(PGCCObjectKey		 	object_key,
						                PGCCError				pRetCode)
:
    CRefCount(MAKE_STAMP_ID('O','b','j','K')),
    m_fValidObjectKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError                rc = GCC_NO_ERROR;
	BOOL    				object_key_is_valid = TRUE;
	UINT					object_id_size;

	m_InternalObjectKey.object_id_key = NULL;
	m_InternalObjectKey.poszNonStandardIDKey = NULL;

	/*
	 * Check to see what type of key is contained in the object key.
	 * Object ID keys will be stored internally in a Memory object and
	 * non-standard ID keys will be stored internally as Octet Strings.
	 */
	if (object_key->key_type == GCC_OBJECT_KEY)
	{
		/*
		 * The key is of type object ID.  Perform a parameter check for a legal
		 * object ID by examining the first two arcs in the object ID.
		 */
		if (object_key->object_id.long_string_length >= MINIMUM_OBJECT_ID_ARCS)
		{
			object_key_is_valid = ValidateObjectIdValues(
					object_key->object_id.long_string[0],
					object_key->object_id.long_string[1]);
		}
		else
		{
			object_key_is_valid = FALSE;
		}

		if (object_key_is_valid)
		{
			/*
			 * The key is of type Object ID.  Determine the amount of memory
			 * required to hold the Object ID and allocate it.  Copy the Object
			 * ID values from the object key passed in into the internal
			 * structure. 
			 */
			m_InternalObjectKey.object_id_length = object_key->object_id.long_string_length;
			object_id_size = m_InternalObjectKey.object_id_length * sizeof(UINT);
            DBG_SAVE_FILE_LINE
			m_InternalObjectKey.object_id_key = new BYTE[object_id_size];
			if (m_InternalObjectKey.object_id_key != NULL)
			{
				::CopyMemory(m_InternalObjectKey.object_id_key,
				             object_key->object_id.long_string,
				             object_id_size);
			}
			else
			{
				ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error allocating memory"));
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Object ID has illegal values."));
			rc = GCC_BAD_OBJECT_KEY;
		}
	}
	else
	{
		/*
		 * The key is non-standard.  Check to make sure the length of the 
		 * non-standard ID is within the allowable limits.
		 */
		if ((object_key->h221_non_standard_id.length >= 
					MINIMUM_NON_STANDARD_ID_LENGTH) &&
			(object_key->h221_non_standard_id.length <= 
					MAXIMUM_NON_STANDARD_ID_LENGTH))
		{
			/*
			 * The key is of type H221 non-standard ID.  Create a new Rogue
			 * Wave string container to hold the non-standard data.
			 */
			if (NULL == (m_InternalObjectKey.poszNonStandardIDKey = ::My_strdupO2(
				 				object_key->h221_non_standard_id.value,
				 				object_key->h221_non_standard_id.length)))
			{
				ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error creating non standard id key"));
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer:  Non standard ID is outside legal range"));
			rc = GCC_BAD_OBJECT_KEY;
		}
	}

    *pRetCode = rc;
}

/*
 *	CObjectKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create an CObjectKeyContainer object from
 *		a "PDU" Key.
 */
CObjectKeyContainer::CObjectKeyContainer(PKey				object_key,
						                PGCCError			pRetCode)
:
    CRefCount(MAKE_STAMP_ID('O','b','j','K')),
    m_fValidObjectKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError            rc = GCC_NO_ERROR;
	PSetOfObjectID		object_id_set_ptr;
	UINT               *object_id_ptr;
	UINT				object_id_size = 0;
	Int					i = 0;

	m_InternalObjectKey.object_id_key = NULL;
	m_InternalObjectKey.object_id_length = 0;
	m_InternalObjectKey.poszNonStandardIDKey = NULL;

	/*
	 * Check to see what type of key is contained in the object key.
	 * Object ID keys will be stored internally in a Memory object and
	 * non-standard ID keys will be stored internally in Rogue Wave string
	 * containers.
	 */
	if (object_key->choice == OBJECT_CHOSEN)
	{
		/*
		 * Retrieve the first object ID pointer from the "PDU" structure in
		 * preparation for determining how much memory will be needed to hold
		 * the object ID values.
		 */
		object_id_set_ptr = object_key->u.object;

		/*
		 * Loop through the ObjectID structure, adding up the size of the 
		 * string.
		 */
		while (object_id_set_ptr != NULL)
		{
			m_InternalObjectKey.object_id_length++;
			object_id_set_ptr = object_id_set_ptr->next;
		}

		object_id_size = m_InternalObjectKey.object_id_length * sizeof(UINT);

		/*
		 * Allocate the memory to be used to hold the object ID values.
		 */
		DBG_SAVE_FILE_LINE
		m_InternalObjectKey.object_id_key = new BYTE[object_id_size];
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			object_id_ptr = (UINT *) m_InternalObjectKey.object_id_key;

			/*
			 * Again retrieve the first object ID pointer from the "PDU" 
			 * structure in	order to get the values out for saving.
			 */
			object_id_set_ptr = object_key->u.object;

			/*
			 * Loop through the ObjectID structure, getting each object ID
			 * value and saving it in the allocated memory.
			 */
			while (object_id_set_ptr != NULL)
			{
				object_id_ptr[i++] = object_id_set_ptr->value;
				object_id_set_ptr = object_id_set_ptr->next;
			}
		} 
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error allocating memory."));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 * The key is of type H221 non-standard ID so create a new Rogue Wave
		 * string container to hold the data.
		 */
		if (NULL == (m_InternalObjectKey.poszNonStandardIDKey = ::My_strdupO2(
						object_key->u.h221_non_standard.value,
						object_key->u.h221_non_standard.length)))
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error creating non standard id key"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

    *pRetCode = rc;
}

/*
 *	CObjectKeyContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CObjectKeyContainer object from
 *		another CObjectKeyContainer object.
 */
CObjectKeyContainer::CObjectKeyContainer(CObjectKeyContainer	*object_key,
						                PGCCError				pRetCode)
:
    CRefCount(MAKE_STAMP_ID('O','b','j','K')),
    m_fValidObjectKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError    rc = GCC_NO_ERROR;
	UINT		object_id_size;

	m_InternalObjectKey.object_id_key = NULL;
	m_InternalObjectKey.poszNonStandardIDKey = NULL;

	/*
	 * If an object ID "key" exists for the CObjectKeyContainer to be copied,
	 * allocate memory to hold the object ID "key" information internally.
	 * Check to make sure construction of the object is successful.
	 */
	if (object_key->m_InternalObjectKey.object_id_key != NULL)
	{
		/*
		 * The key is of type Object ID.
		 */
		m_InternalObjectKey.object_id_length = object_key->m_InternalObjectKey.object_id_length;
		object_id_size = m_InternalObjectKey.object_id_length * sizeof(UINT);

        DBG_SAVE_FILE_LINE
		m_InternalObjectKey.object_id_key = new BYTE[object_id_size];
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			::CopyMemory(m_InternalObjectKey.object_id_key,
			             object_key->m_InternalObjectKey.object_id_key,
			             object_id_size);
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error allocating memory"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else if (object_key->m_InternalObjectKey.poszNonStandardIDKey != NULL)
	{
		/*
		 * If a non-standard ID "key" exists for the CObjectKeyContainer to be copied,
		 * create a new Rogue Wave string to hold the non-standard "key" 
		 * information internally.  Check to make sure construction of the
		 * object is successful.
		 */
		if (NULL == (m_InternalObjectKey.poszNonStandardIDKey = ::My_strdupO(
							object_key->m_InternalObjectKey.poszNonStandardIDKey)))
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error creating new non standard id key"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 * At least one of the internal pointers for the passed in object key 
		 * must be valid.
		 */
		ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Bad input parameters"));
		rc = GCC_BAD_OBJECT_KEY;
	}

    *pRetCode = rc;
}

/*
 *	~CObjectKeyContainer()
 *
 *	Public Function Description
 *		The CObjectKeyContainer destructor is responsible for freeing any memory
 *		allocated to hold the object key data.
 *
 */
CObjectKeyContainer::~CObjectKeyContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidObjectKeyPDU)
	{
		FreeObjectKeyDataPDU();
	}

	/* 
	 * Delete any object key data held internally.
	 */
	delete m_InternalObjectKey.object_id_key;
	delete m_InternalObjectKey.poszNonStandardIDKey;
}

/*
 *	LockObjectKeyData ()
 *
 *	Public Function Description:
 *		This routine locks the object key data and determines the amount of
 *		memory referenced by the "API" object key data structure.
 */
UINT CObjectKeyContainer::LockObjectKeyData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the object key
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Determine the amount of space required to hold the data referenced
		 * by the "API" Object Key structure.
		 */
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			/*
			 * Since the object ID is just a series of "longs" without a NULL
			 * terminator, we do not want to include a NULL terminator when 
			 * determining the length.
			 */
			m_cbDataSize = m_InternalObjectKey.object_id_length * sizeof(UINT);
		}
		else
		{
			/*
			 * The data referenced by the non-standard object key is just the
			 * length of the octet string.
			 */
			m_cbDataSize = m_InternalObjectKey.poszNonStandardIDKey->length;
		}

		/*
		 * Force the size to be on a four-byte boundary.
		 */
		m_cbDataSize = ROUNDTOBOUNDARY(m_cbDataSize);
	}

	return m_cbDataSize;
}

/*
 *	GetGCCObjectKeyData ()
 *
 *	Public Function Description:
 *		This routine retrieves object key data in the form of an "API"
 *		GCCObjectKey.  This routine is called after "locking" the object 
 *		key data.
 */
UINT CObjectKeyContainer::GetGCCObjectKeyData(
								PGCCObjectKey 		object_key,
								LPBYTE				memory)
{
	UINT	cbDataSizeToRet = 0;
	UINT   *object_id_ptr;

	/*
	 * If the object key data has been locked, fill in the output structure and
	 * the data referenced by the structure.  Otherwise, report that the object
	 * key has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		if (m_InternalObjectKey.object_id_key != NULL)
		{
			/*
			 * The object key is a standard type.  Set the object key type 
			 * and the length of the long string. The length set here does 
			 * not include a NULL terminator.
			 */
			object_key->key_type = GCC_OBJECT_KEY;
			object_key->object_id.long_string_length = (USHORT) m_InternalObjectKey.object_id_length;

			/*
			 * Set the offset for the long string equal to the memory pointer
			 * passed in since it will be the first data referenced by the 
			 * object key structure.
			 */
			object_key->object_id.long_string = (ULONG *) memory;

			/*
			 * Now retrieve the memory pointer and copy the long string data 
			 * from the internal memory object.  
			 */		
			object_id_ptr = (UINT *) m_InternalObjectKey.object_id_key;

			::CopyMemory(memory, object_id_ptr, 
						m_InternalObjectKey.object_id_length * sizeof (UINT));
		}
		else if (m_InternalObjectKey.poszNonStandardIDKey != NULL)
		{
			/*
			 * The object key is a non-standard type.  Set the object key 
			 * type and the length of the octet string.
			 */
			object_key->key_type = GCC_H221_NONSTANDARD_KEY;
			object_key->h221_non_standard_id.length =
						m_InternalObjectKey.poszNonStandardIDKey->length;

			/*
			 * Set the offset for the octet string equal to the memory pointer
			 * passed in since it will be the first data referenced by the 
			 * object key structure.
			 */
			object_key->h221_non_standard_id.value = memory;

			/*
			 * Now copy the octet string data from the internal Rogue Wave
			 * string into the object key structure held in memory.
			 */		
			::CopyMemory(memory, m_InternalObjectKey.poszNonStandardIDKey->value,
									m_InternalObjectKey.poszNonStandardIDKey->length);
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::LockObjectKeyData: Error, no valid internal data"));
		}
	}
	else
	{
		object_key = NULL;
		ERROR_OUT(("CObjectKeyContainer::GetGCCObjectKeyData: Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnLockObjectKeyData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated
 *		with the "API" object key once the lock count reaches zero.
 */
void CObjectKeyContainer::UnLockObjectKeyData(void)
{
    Unlock();
}

/*
 *	GetObjectKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the object key from it's internal form of an
 *		OBJECT_KEY structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "Key" structure is 
 *		returned.
 */
GCCError CObjectKeyContainer::GetObjectKeyDataPDU(PKey object_key)
{
	PSetOfObjectID			new_object_id_ptr;
	PSetOfObjectID			old_object_id_ptr;
	UINT                   *object_id_string;
	GCCError				rc = GCC_NO_ERROR;
	UINT					i;

	/*
	 * Set the loop pointer to NULL to avoid a compiler warning.
	 */
    old_object_id_ptr = NULL;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidObjectKeyPDU == FALSE)
	{
		m_fValidObjectKeyPDU = TRUE;

		/*
		 * Fill in the "PDU" object key after checking to see what form of 
		 * key exists in the internal structure.
		 */
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			/*
			 * The key is an object ID so set the choice accordingly and 
			 * initialize the PDU object pointer to NULL.  Get the pointer to
			 * the internal list of object key values stored in the memory
			 * object.
			 */
			m_ObjectKeyPDU.choice = OBJECT_CHOSEN;
			m_ObjectKeyPDU.u.object = NULL;

			object_id_string = (UINT *) m_InternalObjectKey.object_id_key;

			/*
			 * The "PDU" structure "ObjectID" is a linked list of unsigned
			 * longs.  Retrieve the Object ID values from the internal memory
			 * object and fill in the "ObjectID" structure. 
			 */
			for (i=0; i<m_InternalObjectKey.object_id_length; i++)
			{
				DBG_SAVE_FILE_LINE
				new_object_id_ptr = new SetOfObjectID;
				if (new_object_id_ptr != NULL)
				{
					/*
					 * The first time through the new pointer is saved in the
					 * PDU structure.  On subsequent iterations, the previous
					 * "next" pointer is set equal to the new pointer.
					 */
					if (m_ObjectKeyPDU.u.object == NULL)
                    {
						m_ObjectKeyPDU.u.object = new_object_id_ptr;
                    }
					else
                    {
						old_object_id_ptr->next = new_object_id_ptr;
                    }

                    old_object_id_ptr = new_object_id_ptr;

					/*
					 * Save the actual Object ID value.
					 */
					new_object_id_ptr->value = object_id_string[i];
					new_object_id_ptr->next = NULL;
				}
				else
				{
					ERROR_OUT(("CObjectKeyContainer::GetObjectKeyDataPDU: creating new ObjectID"));
					rc = GCC_ALLOCATION_FAILURE;
					break;
				}
			}
		}
		else if (m_InternalObjectKey.poszNonStandardIDKey != NULL)
		{
			/*
			 * The key is a non-standard ID so convert the internal Rogue Wave
			 * string into the "PDU" non-standard ID.
			 */
			m_ObjectKeyPDU.choice = H221_NON_STANDARD_CHOSEN;
			m_ObjectKeyPDU.u.h221_non_standard.length =
					m_InternalObjectKey.poszNonStandardIDKey->length;

			::CopyMemory(m_ObjectKeyPDU.u.h221_non_standard.value,
							m_InternalObjectKey.poszNonStandardIDKey->value,
							m_InternalObjectKey.poszNonStandardIDKey->length);
		}
		else
		{
			/*
			 * The constructors make sure that at least one of the internal
			 * pointers is valid so this should never be encountered.
			 */
			ERROR_OUT(("CObjectKeyContainer::GetObjectKeyDataPDU: No valid m_InternalObjectKey"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*object_key = m_ObjectKeyPDU;

	return rc;
}

/*
 *	FreeObjectKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the object key data held internally in
 *		the "PDU" form of a "Key".
 */
void CObjectKeyContainer::FreeObjectKeyDataPDU(void)
{
	PSetOfObjectID		set_of_object_id;
	PSetOfObjectID		next_set_of_object_id;

	if (m_fValidObjectKeyPDU)
	{
		/*
		 * Set the flag indicating that PDU object key data is no longer
		 * allocated.
		 */
		m_fValidObjectKeyPDU = FALSE;

		if (m_ObjectKeyPDU.choice == OBJECT_CHOSEN)
		{
            for (set_of_object_id = m_ObjectKeyPDU.u.object;
                    set_of_object_id != NULL;
					set_of_object_id = next_set_of_object_id)
            {
				next_set_of_object_id = set_of_object_id->next;
				delete set_of_object_id;
			}
		}
	}
}

/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to compare two CObjectKeyContainer objects to determine
 *		if they are equal in value.
 */
BOOL operator==(const CObjectKeyContainer& object_key_1, const CObjectKeyContainer& object_key_2)
{
	UINT       *object_id_1, *object_id_2;
	UINT		i;
	BOOL    	rc = FALSE;
	
	/*
	 * Check to make sure that both the object ID key and the non-standard
	 * ID key are equal.
	 */
	if ((object_key_1.m_InternalObjectKey.object_id_key != NULL) && 
			(object_key_2.m_InternalObjectKey.object_id_key != NULL))
	{
		if (object_key_1.m_InternalObjectKey.object_id_length == 
				object_key_2.m_InternalObjectKey.object_id_length)
		{
			object_id_1 = (UINT *) object_key_1.m_InternalObjectKey.object_id_key;
			object_id_2 = (UINT *) object_key_2.m_InternalObjectKey.object_id_key;

			/*
			 * Compare each Object ID value to make sure they are equal.
			 */
			rc = TRUE;
			for (i=0; i<object_key_1.m_InternalObjectKey.object_id_length; i++)
			{
				if (object_id_1[i] != object_id_2[i])
				{
					rc = FALSE;
					break;
				}
			}
		}
	} 
	else
	if (0 == My_strcmpO(object_key_1.m_InternalObjectKey.poszNonStandardIDKey,
						object_key_2.m_InternalObjectKey.poszNonStandardIDKey))
	{
		rc = TRUE;
	} 

	return rc;
}

/*
 *	BOOL    	ValidateObjectIdValues (	UINT		first_arc,
 *											UINT		second_arc);
 *
 *	Private member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether or not the values for the
 *		object ID component of the object key are valid.
 *
 *	Formal Parameters:
 *		first_arc			(i) The first integer value of the Object ID.
 *		second_arc			(i) The second integer value of the Object ID.
 *
 *	Return Value:
 *		TRUE				-	The first two arcs of the Object ID are valid.
 *		FALSE				- 	The first two arcs of the Object ID are not 
 *									valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CObjectKeyContainer::ValidateObjectIdValues(UINT first_arc, UINT second_arc)
{
	BOOL rc = FALSE;

	if (first_arc == ITUT_IDENTIFIER)
	{
		if (second_arc <= 4)
		{
			rc = TRUE;
		} 
	}
	else if (first_arc == ISO_IDENTIFIER)
	{
		if ((second_arc == 0L) ||
			(second_arc == 2L) ||
			(second_arc == 3L))
		{
			rc = TRUE;
		} 
	}
	else if (first_arc == JOINT_ISO_ITUT_IDENTIFIER)
	{
		/*
		 * Referring to ISO/IEC 8824-1 : 1994 (E) Annex B:
		 * Join assignment of OBJECT IDENTIFIER component values are assigned
		 * and agreed from time to time by ISO and ITU-T to identify areas of
		 * joint ISO/ITU-T standardization activity, in accordance with the
		 * procedures of .... ANSI.  So we just let them all through for now.
		 */
		rc = TRUE;
	}
	else
	{
		ERROR_OUT(("ObjectKeyData::ValidateObjectIdValues: ObjectID is invalid"));
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\appldr.h ===
#ifndef  __APPLET_LOADER_H
#define  __APPLET_LOADER_H


#include "iappldr.h"

typedef struct {
	HINSTANCE       hLibApplet;
	IAppletLoader   *pIAppLoader;
	APPLET_STATUS   eStatus;
	int				cLoads;
} AppLoaderInfo;


T120Error AppLdr_Initialize(void);
void AppLdr_Shutdown(void);


#endif // __APPLET_LOADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\appenrol.h ===
/*
 *	appenrol.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the header file for the class ApplicationEnrollRequestData.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_APPLICATION_ENROLL_REQUEST_DATA_
#define	_APPLICATION_ENROLL_REQUEST_DATA_

#include "gcctypes.h"
#include "pdutypes.h"
#include "aportmsg.h"
#include "sesskey.h"
#include "appcap.h"
#include "ncollcap.h"

class 	ApplicationEnrollRequestData;
typedef	ApplicationEnrollRequestData 	*	PApplicationEnrollRequestData;

class ApplicationEnrollRequestData
{
public:

    ApplicationEnrollRequestData(PApplicationEnrollRequestMessage, PGCCError);
	ApplicationEnrollRequestData(PApplicationEnrollRequestMessage);
	~ApplicationEnrollRequestData(void);

	ULONG		GetDataSize(void);
	ULONG		Serialize(PApplicationEnrollRequestMessage, LPSTR memory);

	void		Deserialize(PApplicationEnrollRequestMessage);

protected:

	ApplicationEnrollRequestMessage				Enroll_Request_Message;
	CSessKeyContainer   					    *Session_Key_Data;
	CNonCollAppCap				                *Non_Collapsing_Caps_Data;
	CAppCap							            *Application_Capability_Data;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\regkey.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	regkey.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CRegKeyContainer.  This 
 *		class manages the data associated with a Registry Key.  Registry Key's 
 *		are used to identify resources held in the application registry and 
 *		consist of a Session Key and a resource ID octet string.  The 
 *		CRegKeyContainer class uses a CSessKeyContainer container to maintain the 
 *		session key data internally.  A Rogue Wave string object is used to 
 *		hold the resource ID octet string. 
 *
 *	Protected Instance Variables:
 *		m_InternalRegKey
 *			Structure used to hold the registry key data internally.
 *		m_RegKeyPDU
 *			Storage for the "PDU" form of the registry key.
 *		m_fValidRegKeyPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" registry key.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCRegistryKey structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "regkey.h"


/*
 * This macro is used to ensure that the Resource ID contained in the Registry
 * Key does not violate the imposed ASN.1 constraint.
 */
#define		MAXIMUM_RESOURCE_ID_LENGTH		64


/*
 *	CRegKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CRegKeyContainer object from
 *		an "API" GCCRegistryKey.
 */
CRegKeyContainer::
CRegKeyContainer(PGCCRegistryKey registry_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','K')),
    m_fValidRegKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

    /*
	 * Initialize instance variables.
	 */
    ::ZeroMemory(&m_InternalRegKey, sizeof(m_InternalRegKey));
    ::ZeroMemory(&m_RegKeyPDU, sizeof(m_RegKeyPDU));

	/*
	 * Check to make sure the resource ID string does not violate the imposed
	 * ASN.1 constraint.
	 */
	if (registry_key->resource_id.length > MAXIMUM_RESOURCE_ID_LENGTH)
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error: resource ID exceeds allowable length"));
		rc = GCC_BAD_REGISTRY_KEY;
        goto MyExit;
	}

	/*
	 * Save the Session Key portion of the Registry Key in the internal
	 * structure by creating a new CSessKeyContainer object.  Check to make  
	 * sure the object is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalRegKey.session_key = new CSessKeyContainer(&registry_key->session_key, &rc);
	if (m_InternalRegKey.session_key == NULL)
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new CSessKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}
	else if (rc == GCC_BAD_SESSION_KEY)
	{
		rc = GCC_BAD_REGISTRY_KEY;
        goto MyExit;
	}

	/*
	 * Save the resource ID if the CSessKeyContainer was successfully created.
	 */
	if (NULL == (m_InternalRegKey.poszResourceID = ::My_strdupO2(
				 		registry_key->resource_id.value,
				 		registry_key->resource_id.length)))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating resource id"));
		rc = GCC_ALLOCATION_FAILURE;
        // goto MyExit;
	}

MyExit:

    *pRetCode = rc;
}


/*
 *	CRegKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CRegKeyContainer object from
 *		a "PDU" RegistryKey.
 */
CRegKeyContainer::
CRegKeyContainer(PRegistryKey registry_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','K')),
    m_fValidRegKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Initialize instance variables.
	 */
    ::ZeroMemory(&m_InternalRegKey, sizeof(m_InternalRegKey));
    ::ZeroMemory(&m_RegKeyPDU, sizeof(m_RegKeyPDU));

	/*
	 * Save the Session Key portion of the Registry Key in the internal 
	 * structure by creating a new CSessKeyContainer object.  Check to make sure 
	 * the object is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalRegKey.session_key = new CSessKeyContainer(&registry_key->session_key, &rc);
	if ((m_InternalRegKey.session_key == NULL) || (rc != GCC_NO_ERROR))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new CSessKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	/*
	 * Save the resource ID if the CSessKeyContainer was successfully created.
	 */
	if (NULL == (m_InternalRegKey.poszResourceID = ::My_strdupO2(
						registry_key->resource_id.value,
						registry_key->resource_id.length)))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating resource id"));
		rc = GCC_ALLOCATION_FAILURE;
        // goto MyExit;
	}

MyExit:

    *pRetCode = rc;
}


/*
 *	CRegKeyContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CRegKeyContainer object
 *		from another CRegKeyContainer object.
 */
CRegKeyContainer::
CRegKeyContainer(CRegKeyContainer *registry_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','K')),
    m_fValidRegKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Initialize instance variables.
	 */
    ::ZeroMemory(&m_InternalRegKey, sizeof(m_InternalRegKey));
    ::ZeroMemory(&m_RegKeyPDU, sizeof(m_RegKeyPDU));

	/*
	 * Copy the Session Key portion of the Registry Key using the copy 
	 * constructor of the CSessKeyContainer class.  Check to make sure the 
	 * CSessKeyContainer object is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalRegKey.session_key = new CSessKeyContainer(registry_key->m_InternalRegKey.session_key, &rc);
	if ((m_InternalRegKey.session_key == NULL) || (rc != GCC_NO_ERROR))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new CSessKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	/*
	 * Save the resource ID if the CSessKeyContainer was saved correctly.
	 * Store the resource ID in a Rogue Wave string container.
	 */
	if (NULL == (m_InternalRegKey.poszResourceID = ::My_strdupO(
								registry_key->m_InternalRegKey.poszResourceID)))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new resource id"));
		rc = GCC_ALLOCATION_FAILURE;
        // goto MyExit;
	}

MyExit:

    *pRetCode = rc;
}


/*
 *	~CRegKeyContainer()
 *
 *	Public Function Description
 *		The CRegKeyContainer destructor is responsible for freeing any memory
 *		allocated to hold the registry key data.
 *
 */
CRegKeyContainer::
~CRegKeyContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidRegKeyPDU)
	{
		FreeRegistryKeyDataPDU();
	}

	/* 
	 * Delete any registry key data held internally.
	 */
	if (NULL != m_InternalRegKey.session_key)
	{
	    m_InternalRegKey.session_key->Release();
	}
	delete m_InternalRegKey.poszResourceID;
}


/*
 *	LockRegistryKeyData ()
 *
 *	Public Function Description:
 *		This routine locks the registry key data and determines the amount of
 *		memory referenced by the "API" registry key structure.
 */
UINT CRegKeyContainer::
LockRegistryKeyData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the registry key
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Lock the data for the session key by	using the "Lock" routine of
		 * the internal CSessKeyContainer object.  Determine the amount of memory
		 * necessary to hold the data referenced by the "API" registry key
		 * structure.  The referenced data consists of data for the object key
		 * as well as data for the resource ID octet string.  The sizes for
		 * both of these memory blocks are rounded to occupy an even multiple
		 * of four-byte blocks, with the session key block being rounded at a
		 * lower level.  The pointers to the internal objects were validated in
		 * the constructor.  
		 */
		m_cbDataSize = m_InternalRegKey.session_key->LockSessionKeyData();
		m_cbDataSize += m_InternalRegKey.poszResourceID->length;
		m_cbDataSize = ROUNDTOBOUNDARY(m_cbDataSize);
	}

	return m_cbDataSize;
}


/*
 *	GetGCCRegistryKeyData ()
 *
 *	Public Function Description:
 *		This routine retrieves registry key data in the form of an "API" 
 *		GCCRegistryKey.	 This routine is called after "locking" the registry 
 *		key data.
 */
UINT CRegKeyContainer::
GetGCCRegistryKeyData(PGCCRegistryKey registry_key, LPBYTE memory)
{
	UINT cbDataSizeToRet = 0;

	/*
	 * If the registry key data has been locked, fill in the output structure
	 * and the data referenced by the structure.  Call the "Get" routine for the 
	 * SessionKey to fill in the session key data.
	 */ 
	if (GetLockCount() > 0)
	{
    	UINT		session_key_data_length;
    	LPBYTE		data_memory = memory;

		/*
		 * Fill in the output parameter which indicates the amount of memory
		 * used to hold all of the data associated with the registry key.
		 */
		cbDataSizeToRet = m_cbDataSize;

		session_key_data_length = m_InternalRegKey.session_key->
				GetGCCSessionKeyData(&registry_key->session_key, data_memory);
		data_memory += session_key_data_length;

		/*
		 * Move the memory pointer past the session key data.  The length of
		 * the session key data is rounded to a four-byte boundary by the
		 * lower level routines.  Set the resource ID octet string length
		 * and pointer and copy the octet string data into the memory block
		 * from the internal Rogue Wave string.
		 */
		registry_key->resource_id.value = data_memory;
		registry_key->resource_id.length = m_InternalRegKey.poszResourceID->length;

		::CopyMemory(data_memory, m_InternalRegKey.poszResourceID->value,
					m_InternalRegKey.poszResourceID->length);
	}
	else
	{
		ERROR_OUT(("CRegKeyContainer::GetGCCRegistryKeyData Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}


/*
 *	UnlockRegistryKeyData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" registry key once the lock count reaches zero.
 */
void CRegKeyContainer::
UnLockRegistryKeyData(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock the data associated with the internal CSessKeyContainer.
		 */
		if (m_InternalRegKey.session_key != NULL)
		{
			m_InternalRegKey.session_key->UnLockSessionKeyData();
		} 
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	GetRegistryKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the registry key from it's internal form of a
 *		REG_KEY structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "RegistryKey" structure is 
 *		returned.
 */
GCCError CRegKeyContainer::
GetRegistryKeyDataPDU(PRegistryKey registry_key)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidRegKeyPDU == FALSE)
	{
		m_fValidRegKeyPDU = TRUE;

		/*
		 * Fill in the "PDU" registry key from the internal structure.
		 */
		if (m_InternalRegKey.session_key != NULL)
		{
			/*
			 * Fill in the session key portion of the registry key by using the
			 * "Get" routine of the internal CSessKeyContainer object.
			 */
			rc = m_InternalRegKey.session_key->GetSessionKeyDataPDU(&m_RegKeyPDU.session_key);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}

		if (rc == GCC_NO_ERROR)
		{
			/*
			 * Fill in the "PDU" resource ID if no error has occurred.
			 */
			::CopyMemory(m_RegKeyPDU.resource_id.value,
					m_InternalRegKey.poszResourceID->value,
					m_InternalRegKey.poszResourceID->length);

			m_RegKeyPDU.resource_id.length = m_InternalRegKey.poszResourceID->length;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*registry_key = m_RegKeyPDU;

	return rc;
}


/*
 *	FreeRegistryKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the registry key data held internally in
 *		the "PDU" form of a "RegistryKey".
 */
void CRegKeyContainer::
FreeRegistryKeyDataPDU(void)
{
	if (m_fValidRegKeyPDU)
	{
		/*
		 * Set the flag indicating that PDU registry key data is no longer
		 * allocated.
		 */
		m_fValidRegKeyPDU = FALSE;

		if (m_InternalRegKey.session_key != NULL)
		{
			m_InternalRegKey.session_key->FreeSessionKeyDataPDU();
		}
		else
		{
			ERROR_OUT(("CRegKeyContainer::FreeRegistryKeyDataPDU: Bad internal pointer"));
		}
	}
}


GCCError CRegKeyContainer::
CreateRegistryKeyData(PGCCRegistryKey *ppRegKey)
{
    GCCError rc;

    DebugEntry(CRegKeyContainer::CreateRegistryKeyData);

    /*
    **	Here we calculate the length of the bulk data.  This
    **	includes the registry key and registry item.  These objects are
    **	"locked" in order to determine how much bulk memory they will
    **	occupy.
    */
    UINT cbKeySize = ROUNDTOBOUNDARY(sizeof(GCCRegistryKey));
    UINT cbDataSize = LockRegistryKeyData() + cbKeySize;
    LPBYTE pData;

    DBG_SAVE_FILE_LINE
    if (NULL != (pData = new BYTE[cbDataSize]))
    {
        *ppRegKey = (PGCCRegistryKey) pData;
        ::ZeroMemory(pData, cbKeySize);

        pData += cbKeySize;
        GetGCCRegistryKeyData(*ppRegKey, pData);

        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CRegKeyContainer::CreateRegistryKeyData: can't create GCCRegistryKey"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    //	UnLock the registry key since it is no longer needed
    UnLockRegistryKeyData();

    DebugExitINT(CRegKeyContainer::CreateRegistryKeyData, rc);
    return rc;
}


/*
 *	IsThisYourSessionKey ()
 *
 *	Public Function Description:
 *		This routine determines whether this registry key holds the specified
 *		session key.
 */
BOOL CRegKeyContainer::
IsThisYourSessionKey(CSessKeyContainer *session_key)
{
	BOOL			fRet = FALSE;
	CSessKeyContainer *session_key_data;
	GCCError		rc2;

	DBG_SAVE_FILE_LINE
	session_key_data = new CSessKeyContainer(session_key, &rc2);
	if ((session_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*session_key_data == *m_InternalRegKey.session_key)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CRegKeyContainer::IsThisYourSessionKey: Error creating new CSessKeyContainer"));
	}

	if (NULL != session_key_data)
	{
	    session_key_data->Release();
	}

	return fRet;
}


/*
 *	GetSessionKey ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the session key which is held within
 *		this registry key.  The session key is returned in the form of a
 *		CSessKeyContainer container object.
 */


/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not two registry keys are
 *		equal in value.
 */
BOOL operator==(const CRegKeyContainer& registry_key_1, const CRegKeyContainer& registry_key_2)
{
	BOOL fRet = FALSE;
	
	if ((registry_key_1.m_InternalRegKey.session_key != NULL) &&
		(registry_key_2.m_InternalRegKey.session_key != NULL))
	{
		if (*registry_key_1.m_InternalRegKey.session_key ==
			*registry_key_2.m_InternalRegKey.session_key)
		{
			if (0 == My_strcmpO(registry_key_1.m_InternalRegKey.poszResourceID,
							registry_key_2.m_InternalRegKey.poszResourceID))
			{
				fRet = TRUE;
			}
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\common\sesskey.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	sesskey.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CSessKeyContainer. This class 
 *		manages the data associated with a Session Key. Session Key's are used
 *		to uniquely identify an Application Protocol Session.  The Application
 *		Protocol is identified by an Object Key and the particular session
 *		identified by an optional session ID.  The CSessKeyContainer class uses an
 *		CObjectKeyContainer container to maintain the object key data internally.  An
 *		unsigned short integer is used to hold the optional session ID. 
 *
 *	Protected Instance Variables:
 *		m_InternalSessKey
 *			Structure used to hold the object key data internally.
 *		m_SessionKeyPDU
 *			Storage for the "PDU" form of the session key.
 *		m_fValidSessionKeyPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" session key.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCSessionKey structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */


#include "sesskey.h"

/*
 *	CSessKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CSessKeyContainer object from
 *		an "API" GCCSessionKey.
 */
CSessKeyContainer::
CSessKeyContainer(PGCCSessionKey session_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('S','e','s','K')),
    m_fValidSessionKeyPDU(FALSE),
    m_cbDataSize(0)
{
    GCCError rc;

	/*
	 * Save the Object Key portion of the Session Key in the internal structure
	 * by creating a new CObjectKeyContainer object.  Check to make sure the object
	 * is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalSessKey.application_protocol_key = new CObjectKeyContainer(
										&session_key->application_protocol_key,
										&rc);
	if (NULL != m_InternalSessKey.application_protocol_key && GCC_NO_ERROR == rc)
	{
    	/*
    	 * Save the session ID if the CObjectKeyContainer was saved correctly.  A zero 
    	 * value of the GCC session ID will indicate that one is not actually
    	 * present.
    	 */
    	m_InternalSessKey.session_id = session_key->session_id;
	}
	else if (GCC_BAD_OBJECT_KEY == rc)
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData1: bad session key"));
		rc = GCC_BAD_SESSION_KEY;
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData1: Error creating new CObjectKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
	}

    *pRetCode = rc;
}

/*
 *	CSessKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CSessKeyContainer object from
 *		a "PDU" SessionKey.
 */
CSessKeyContainer::
CSessKeyContainer(PSessionKey session_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('S','e','s','K')),
    m_fValidSessionKeyPDU(FALSE),
    m_cbDataSize(0)
{
    GCCError rc;

	/*
	 * Save the Object Key portion of the Session Key in the internal structure
	 * by creating a new CObjectKeyContainer object.  Check to make sure the object
	 * is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalSessKey.application_protocol_key = new CObjectKeyContainer(
										&session_key->application_protocol_key,
										&rc);
	if (NULL != m_InternalSessKey.application_protocol_key && GCC_NO_ERROR == rc)
	{
    	/*
    	 * Save the session ID if one is present and the CObjectKeyContainer was saved 
    	 * correctly.  If a session ID is not present, set the internal session ID
    	 * to zero to indicate this.
    	 */
    	if (session_key->bit_mask & SESSION_ID_PRESENT)
    	{
    		m_InternalSessKey.session_id = session_key->session_id;
    	}
    	else
    	{
    		m_InternalSessKey.session_id = 0;
    	}
	}
	else if (GCC_BAD_OBJECT_KEY == rc)
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData2: bad session key"));
		rc = GCC_BAD_SESSION_KEY;
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData2: Error creating new CObjectKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
	}

    *pRetCode = rc;
}

/*
 *	CSessKeyContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CSessKeyContainer object from
 *		another CSessKeyContainer object.
 */
CSessKeyContainer::
CSessKeyContainer(CSessKeyContainer *session_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('S','e','s','K')),
    m_fValidSessionKeyPDU(FALSE),
    m_cbDataSize(0)
{
    GCCError rc;

	/*
	 * Copy the Object Key portion of the Session Key using the copy constructor
	 * of the CObjectKeyContainer class.  Check to make sure the CObjectKeyContainer object
	 * is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalSessKey.application_protocol_key = new CObjectKeyContainer(
							session_key->m_InternalSessKey.application_protocol_key,
							&rc);
	if (NULL != m_InternalSessKey.application_protocol_key && GCC_NO_ERROR == rc)
	{
    	/*
    	 * Save the session ID if the CObjectKeyContainer was saved correctly.  A zero 
    	 * value of the GCC session ID will indicate that one is not actually
    	 * present.
    	 */
    	m_InternalSessKey.session_id = session_key->m_InternalSessKey.session_id;
	}
	else if (GCC_BAD_OBJECT_KEY == rc)
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData3: bad session key"));
		rc = GCC_BAD_SESSION_KEY;
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData3: Error creating new CObjectKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
	}

    *pRetCode = rc;
}

/*
 *	~CSessKeyContainer()
 *
 *	Public Function Description
 *		The CSessKeyContainer destructor is responsible for freeing any memory
 *		allocated to hold the session key data.
 *
 */
CSessKeyContainer::
~CSessKeyContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidSessionKeyPDU)
	{
		FreeSessionKeyDataPDU();
	}

	/* 
	 * Delete any object key data held internally.
	 */
	if (NULL != m_InternalSessKey.application_protocol_key)
	{
	    m_InternalSessKey.application_protocol_key->Release();
	}
}

/*
 *	LockSessionKeyData ()
 *
 *	Public Function Description:
 *		This routine locks the session key data and determines the amount of
 *		memory referenced by the "API" session key data structure.
 */
UINT CSessKeyContainer::
LockSessionKeyData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the session key
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Lock the data for the object key held within the session key.  The
		 * pointer to the CObjectKeyContainer object is validated in the constructor.
		 */
		m_cbDataSize = m_InternalSessKey.application_protocol_key->LockObjectKeyData();
	}

	return m_cbDataSize;
}

/*
 *	GetGCCSessionKeyData ()
 *
 *	Public Function Description:
 *		This routine retrieves session key data in the "API" form of a 
 *		GCCSessionKey.  This routine is called after "locking" the session
 *		key data.
 */
UINT CSessKeyContainer::
GetGCCSessionKeyData(PGCCSessionKey session_key, LPBYTE memory)
{
	UINT cbDataSizeToRet = 0;

	/*
	 * If the session key data has been locked, fill in the output structure and
	 * the data referenced by the structure.  Call the "Get" routine for the 
	 * ObjectKey to fill in the object key data.
	 */ 
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;
        ::ZeroMemory(memory, m_cbDataSize);

		session_key->session_id = m_InternalSessKey.session_id;

		m_InternalSessKey.application_protocol_key->GetGCCObjectKeyData(
				&session_key->application_protocol_key,
				memory);
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::GetGCCSessionKeyData: Error: data not locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnlockSessionKeyData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" session key once the lock count reaches zero.
 */
void CSessKeyContainer::
UnLockSessionKeyData(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock the data associated with the internal CObjectKeyContainer and
		 * delete this object if the "free flag" is set.
		 */
		if (m_InternalSessKey.application_protocol_key != NULL)
		{
			m_InternalSessKey.application_protocol_key->UnLockObjectKeyData(); 
		} 
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetSessionKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the session key from it's internal form of a
 *		SESSION_KEY structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "SessionKey" structure is 
 *		returned.
 */
GCCError CSessKeyContainer::
GetSessionKeyDataPDU(PSessionKey session_key)
{
	GCCError	rc = GCC_NO_ERROR;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidSessionKeyPDU == FALSE)
	{
		m_fValidSessionKeyPDU = TRUE;

		/*
		 * Initialize the "PDU" session key's bit mask to zero.
		 */
		m_SessionKeyPDU.bit_mask = 0;

		/*
		 * Fill in the "PDU" session key from the internal structure.
		 */
		if (m_InternalSessKey.application_protocol_key != NULL)
		{
			/*
			 * Fill in the object key portion of the session key by using the
			 * "GetPDU" routine of the internal CObjectKeyContainer object.
			 */
			rc = m_InternalSessKey.application_protocol_key->
					GetObjectKeyDataPDU(&m_SessionKeyPDU.application_protocol_key);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}

		/*
		 * Fill in the "PDU" session ID if one exists.  A value of zero for the
		 * internal session ID indicates that one really does not exist.
		 */
		if (m_InternalSessKey.session_id != 0)
		{
			m_SessionKeyPDU.bit_mask |= SESSION_ID_PRESENT;
			m_SessionKeyPDU.session_id = m_InternalSessKey.session_id;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*session_key = m_SessionKeyPDU;

	return rc;
}

/*
 *	FreeSessionKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the session key data held internally in
 *		the "PDU" form of a "SessionKey".
 */
void CSessKeyContainer::
FreeSessionKeyDataPDU(void)
{
	if (m_fValidSessionKeyPDU)
	{
		/*
		 * Set the flag indicating that PDU session key data is no longer
		 * allocated.
		 */
		m_fValidSessionKeyPDU = FALSE;

		if (m_InternalSessKey.application_protocol_key != NULL)
		{
			m_InternalSessKey.application_protocol_key->FreeObjectKeyDataPDU ();
		}
		else
		{
			ERROR_OUT(("CSessKeyContainer::FreeSessionKeyDataPDU: Bad internal pointer"));
		}
	}
}

/*
 *	IsThisYourApplicationKey()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified application
 *		key is held within this session key.
 */
BOOL CSessKeyContainer::
IsThisYourApplicationKey(PGCCObjectKey application_key)
{
	BOOL    		fRet = FALSE;
	CObjectKeyContainer	    *object_key_data;
	GCCError		rc2;

	DBG_SAVE_FILE_LINE
	object_key_data = new CObjectKeyContainer(application_key, &rc2);
	if ((object_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*object_key_data == *m_InternalSessKey.application_protocol_key)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::IsThisYourApplicationKey: Error creating new CObjectKeyContainer"));
	}

	if (NULL != object_key_data)
	{
	    object_key_data->Release();
	}

	return fRet;
}

/*
 *	IsThisYourApplicationKeyPDU()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified application
 *		key is held within this session key.
 */
BOOL CSessKeyContainer::
IsThisYourApplicationKeyPDU(PKey application_key)
{
	BOOL    		fRet = FALSE;
	CObjectKeyContainer	    *object_key_data;
	GCCError		rc2;

	DBG_SAVE_FILE_LINE
	object_key_data = new CObjectKeyContainer(application_key, &rc2);
	if ((object_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*object_key_data == *m_InternalSessKey.application_protocol_key)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::IsThisYourApplicationKeyPDU: Error creating new CObjectKeyContainer"));
	}

	if (NULL != object_key_data)
	{
	    object_key_data->Release();
	}

	return fRet;
}

/*
 *	IsThisYourSessionKeyPDU ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified session key
 *		is equal in value to this session key.
 */
BOOL CSessKeyContainer::
IsThisYourSessionKeyPDU(PSessionKey session_key)
{
	BOOL    			fRet = FALSE;
	CSessKeyContainer   *session_key_data;
	GCCError			rc2;

	DBG_SAVE_FILE_LINE
	session_key_data = new CSessKeyContainer(session_key, &rc2);
	if ((session_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*session_key_data == *this)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::IsThisYourSessionKeyPDU: Error creating new CSessKeyContainer"));
	}

	if (NULL != session_key_data)
	{
	    session_key_data->Release();
	}

	return fRet;
}

/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not two session keys are
 *		equal in value.
 */
BOOL operator==(const CSessKeyContainer& session_key_1, const CSessKeyContainer& session_key_2)
{
	BOOL fRet = FALSE;

	if ((session_key_1.m_InternalSessKey.application_protocol_key != NULL) &&
		(session_key_2.m_InternalSessKey.application_protocol_key != NULL))
	{
		if (*session_key_1.m_InternalSessKey.application_protocol_key ==
			*session_key_2.m_InternalSessKey.application_protocol_key)
		{
			if (session_key_1.m_InternalSessKey.session_id == 
				session_key_2.m_InternalSessKey.session_id)
			{
				fRet = TRUE;
			}
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\appsap.h ===
/*
 * appsap.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CAppSap.  CAppSap
 *		objects represent an external user application's Service Access 
 *		Point to GCC.  This object inherits from the CBaseSap class. The CAppSap 
 *		object is instantiated when GCCCreateSap is called.  From that point 
 *		forward all messages to and from that application pass through this 
 *		object.  The object is explicitly deleted when GCCDeleteSap is called 
 *		or it is implicitly deleted when GCCCleanup is called by the Node 
 *		Controller.	 
 *
 *		The primary responsibility of the CAppSap object is to route
 *		incoming GCC primitives to their appropriate destination and to convert
 *		the primitives into a form that is understandable to the objects 
 *		processing them. A secondary responsibility of the CAppSap object is to 
 *		maintain a queue for all indications and confirm messages that are sent
 *		back to the registered application.  Commands can be routed by the 
 *		CAppSap in one of two directions. Either to the controller or to a 
 *		specified conference.  Commands that are passed to the controller, are
 *		done so using owner callbacks.  Commands that are routed to conferences
 *		are done so using command target calls and are routed based on a 
 *		Conference ID.  Note that various User Application commands will only be
 *		routed to the CConf if that application has previously enrolled 
 *		with the conference.  The CAppSap receives all confirms and indications
 *		from either the Controller or a CConf object.  These messages are
 *		formatted into GCCMessages within the CAppSap and queued up for later 
 *		delivery.  Periodically, the CAppSap's message queue is flushed by the 
 *		Controller object and the messages are delivered to the appropriate 
 *		application.
 *
 *	Caveats:
 *		The message structures that are passed back to the node controller
 *		are defined in GCC.H.
 *
 *	Author:
 *		blp
 */

#ifndef _APPSAP_
#define _APPSAP_

/*
 * include files 
 */
#include "igccapp.h"
#include "sap.h"
#include "clists.h"


/*
**	This is the message base that is passed into any SAP objects that use this
**	classes Owner callback.  It will typically be the controller's 
**	responsibility to pass this message on.
*/
#define	APPLICATION_MESSAGE_BASE			0

/*
**	Class definition
*/
class CAppSap : public CBaseSap, public IGCCAppSap 
{
    friend LRESULT CALLBACK SapNotifyWndProc(HWND, UINT, WPARAM, LPARAM);

public:

    CAppSap(LPVOID pAppData, LPFN_APP_SAP_CB, PGCCError);
    ~CAppSap(void);

    GCCAPI_(void)   ReleaseInterface(void);

    /* ------ IGCCAppSap Interface ------ */

    GCCAPI  AppEnroll(GCCConfID, GCCEnrollRequest *, PGCCRequestTag);
    GCCAPI  AppInvoke(GCCConfID, GCCAppProtEntityList *, GCCSimpleNodeList *, PGCCRequestTag);

    GCCAPI  AppRosterInquire(GCCConfID, GCCSessionKey *, GCCAppSapMsg **);
    GCCAPI_(void)  FreeAppSapMsg(GCCAppSapMsg *);

    GCCAPI_(BOOL)  IsThisNodeTopProvider(GCCConfID);
    GCCAPI_(GCCNodeID) GetTopProvider(GCCConfID);
    GCCAPI  ConfRosterInquire(GCCConfID, GCCAppSapMsg **);

    GCCAPI  RegisterChannel(GCCConfID, GCCRegistryKey *, ChannelID);
    GCCAPI  RegistryAssignToken(GCCConfID, GCCRegistryKey *);
    GCCAPI  RegistrySetParameter(GCCConfID, GCCRegistryKey *, LPOSTR, GCCModificationRights);
    GCCAPI  RegistryRetrieveEntry(GCCConfID, GCCRegistryKey *);
    GCCAPI  RegistryDeleteEntry(GCCConfID, GCCRegistryKey *);
    GCCAPI  RegistryMonitor(GCCConfID, BOOL fEnableDelivery, GCCRegistryKey *);
    GCCAPI  RegistryAllocateHandle(GCCConfID, ULONG cHandles);

    GCCAPI  ConductorInquire(GCCConfID);

    /* ------ IGCCAppSapNotify Handler ------ */

    GCCError PermissionToEnrollIndication(GCCConfID, BOOL fGranted);
    GCCError AppEnrollConfirm(GCCAppEnrollConfirm *);

    GCCError RegistryAllocateHandleConfirm(GCCConfID,
                                           ULONG        cHandles,
                                           ULONG        nFirstHandle,
                                           GCCResult);

    GCCError RegistryConfirm(GCCConfID,
                             GCCMessageType,
                             CRegKeyContainer *,
                             CRegItem *,
                             GCCModificationRights,
                             GCCNodeID                  nidOwner,
                             GCCEntityID                eidOwner,
                             BOOL                       fDeliveryEnabled,
                             GCCResult);

    GCCError RegistryMonitorIndication(GCCConfID                nConfID,
                                       CRegKeyContainer         *pRegKey,
                                       CRegItem                 *pRegItem,
                                       GCCModificationRights    eRights,
                                       GCCNodeID                nidOwner,
                                       GCCEntityID              eidOwner)
    {
        return RegistryConfirm(nConfID,
                               GCC_MONITOR_INDICATION,
                               pRegKey,
                               pRegItem,
                               eRights,
                               nidOwner,
                               eidOwner,
                               FALSE,
                               GCC_RESULT_SUCCESSFUL);
    }

    GCCError ConfRosterInquireConfirm(GCCConfID,
                                      PGCCConferenceName,
                                      LPSTR                 pszConfModifier,
                                      LPWSTR                pwszConfDescriptor,
                                      CConfRoster *,
                                      GCCResult,
                                      GCCAppSapMsgEx **);

    GCCError AppRosterInquireConfirm(GCCConfID,
                                     CAppRosterMsg *,
                                     GCCResult,
                                     GCCAppSapMsgEx **);

    GCCError AppRosterReportIndication(GCCConfID, CAppRosterMsg *);

    GCCError AppInvokeConfirm(GCCConfID, CInvokeSpecifierListContainer *, GCCResult, GCCRequestTag);
    GCCError AppInvokeIndication(GCCConfID, CInvokeSpecifierListContainer *, GCCNodeID nidInvoker);

    GCCError ConductorInquireConfirm(GCCNodeID nidConductor, GCCResult, BOOL fGranted, BOOL fConducted, GCCConfID);
    GCCError ConductorPermitGrantIndication(GCCConfID,
                            UINT cGranted, GCCNodeID *aGranted,
                            UINT cWaiting, GCCNodeID *aWaiting,
                            BOOL fThisNodeIsGranted);
    GCCError ConductorAssignIndication(GCCNodeID nidConductor, GCCConfID);
    GCCError ConductorReleaseIndication(GCCConfID);


protected:

    void NotifyProc(GCCAppSapMsgEx *pAppSapMsgEx);

private:

    void PostAppSapMsg(GCCAppSapMsgEx *pAppSapMsgEx);
    void PurgeMessageQueue(void);

private:

    LPVOID              m_pAppData;        // app defined user data
    LPFN_APP_SAP_CB     m_pfnCallback;
};



/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CAppSap (
 *				UINT				owner_message_base,
 *				UINT				application_messsage_base)
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This is the constructor for the CAppSap class.  It initializes instance
 *		variables and registers with the new application.
 *
 *	Formal Parameters:
 *		owner_object		(i) A pointer to the owner of this object, namely
 *									the controller.
 *		owner_message_base	(i) The	message base offset for callbacks into the
 *									controller.
 *		application_object	(i)	A pointer to the application requesting service.
 *		application_messsage_base	(i) The message base offset for callbacks
 *											to the application.
 *		sap_handle			(i) The handle registered for this SAP.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	virtual 	~AppSap();
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This is the destructor for the CAppSap class.  It is called when the 
 *		controller marks the CAppSap to be deleted.  This occurs when either
 *		the CAppSap asks to be deleted due to an "unregister request" 
 *		issued from the client application, or when there is an error
 *		condition in the CAppSap.
 *
 *	Formal Parameters:
 *		owner_object		(i) A pointer to the owner of this object, namely
 *									the controller.
 *		owner_message_base	(i) The	message base offset for callbacks into the
 *									controller.
 *		application_object	(i)	A pointer to the application requesting service.
 *		application_messsage_base	(i) The message base offset for callbacks
 *											to the application.
 *		sap_handle			(i) The handle registered for this SAP.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource allocation error occurred.
 *		GCC_BAD_OBJECT_KEY				- An invalid object key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	AppEnroll(
 *					GCCConfID   			conference_id,
 *					PGCCSessionKey				session_key,
 *					BOOL					enroll_actively,
 *					UserID						application_user_id,
 *					BOOL					is_conducting_capable,
 *					MCSChannelType				startup_channel_type,
 *					UINT						number_of_non_collapsed_caps,
 *					PGCCNonCollapsingCapability *non_collapsed_caps_list,		
 *					UINT						number_of_collapsed_caps,
 *					PGCCApplicationCapability *	collapsed_caps_list,		
 *					BOOL					application_is_enrolled);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wants to enroll in a 
 *		conference.  The controller is notified of the enrollment request.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		session_key						(i) Key identifying the session.
 *		enroll_actively					(i) Flag indicating whether to enroll
 *												actively or inactively.
 *		application_user_id				(i) The application identifier value.
 *		is_conducting_capable			(i) Flag indicating whether this app
 *												is capable of conducting.
 *		startup_channel_type			(i) The type of channel to use. 
 *		number_of_non_collapsed_caps	(i) Number of non-collapsed capabilities
 *		non_collapsed_caps_list			(i) List of non-collapsed capabilities.
 *		number_of_collapsed_caps		(i) Number of collapsed capabilities.
 *		collapsed_caps_list				(i) List of collapsed capabilities.
 *		application_is_enrolled)		(i) Flag indicating whether or not the
 *												application wishes to enroll.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- No error.
 *		GCC_INVALID_MCS_USER_ID		- The user ID is less than the minimum value
 *		GCC_BAD_SESSION_KEY			- A NULL session key pointer is passed in.
 *		GCC_INVALID_CONFERENCE		- The conference does not exist at this node
 *		GCC_NO_SUCH_APPLICATION		- A SAP has not been registered for this app
 *		GCC_BAD_SESSION_KEY			- An invalid session key was passed in.
 *		GCC_INVALID_PARAMETER		- The node record was not found in the list.
 *		GCC_BAD_CAPABILITY_ID		- An invalid capability ID was passed in.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		RegisterChannel(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key,
 *								ChannelID			channel_id);	
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to register a 
 *		channel.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *		channel_id						(i) ID of channel to register
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		RegistryAssignToken(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to assign a 
 *		token.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError   		GCCRegistrySetParameterRequest (
 *								GCCConfID		 	conference_id,
 *								PGCCRegistryKey			registry_key,
 *								LPOSTR      			parameter_value,
 *								GCCModificationRights	modification_rights	);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to set a 
 *		parameter.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *		parameter_value					(i) String identifying the parameter
 *												to set.
 *		modification_rights				(i) Structure specifying the rights
 *												to be allowed for modifying
 *												the registry parameter.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *		GCC_INVALID_MODIFICATION_RIGHTS	- The modification rights passed in
 *											were not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryRetrieveEntryRequest(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to retrieve a registry 
 *		entry.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryDeleteEntryRequest(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to delete a registry 
 *		entry.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										 		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryMonitorRequest (
 *								GCCConfID		conference_id,
 *								BOOL			enable_delivery,
 *								PGCCRegistryKey		registry_key );
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to monitor a 
 *		particular registry entry.  The call is routed to the appropriate 
 *		conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		enable_delivery					(i) Flag indicating whether to turn
 *												monitoring on or off.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryAllocateHandleRequest (
 *								GCCConfID		conference_id,
 *								UINT				number_of_handles );
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to allocate one or 
 *		more handles.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		number_of_handles				(i) The number of handles to allocate.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_BAD_NUMBER_OF_HANDLES		- The number of handles requested is
 *												not within the allowable range.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		PermissionToEnrollIndication(
 *								GCCConfID		conference_id,
 *								PGCCConferenceName	conference_name,
 *								GCCNumericString	conference_modifier,
 *								BOOL			permission_is_granted);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called from a conference object when it wishes to send 
 *		an indication to the user application notifying it of a "permission to 
 *		enroll" event.  This does not mean that permission to enroll is
 *		necessarily granted to the application.  It may mean that permission is
 *		being revoked.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		conference_name					(i) The conference name.
 *		conference_modifier				(i) The confererence modifier.
 *		permission_is_granted			(i) Flag indicating whether or not
 *												permission to enroll is granted.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- No error.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */



/*
 *	GCCError	AppEnrollConfirm(GCCAppEnrollConfirm *);
 *								GCCConfID			conference_id,
 *								PGCCSessionKey			session_key,
 *								UINT					entity_id,
 *								UserID					node_id,
 *								GCCResult				result);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called by the CConf object when it wishes
 *		to send an enrollment confirmation to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		session_key					(i) The key identifying the session.
 *		entity_id					(i) The ID for this instance of the 
 *											application.
 *		node_id						(i) ID for this node.
 *		result						(i) Result code indicating whether or not
 *											the enrollment was successful.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_SESSION_KEY				- The session key is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegistryConfirm (
 *						GCCConfID			conference_id,
 *						GCCMessageType			message_type,
 *						CRegKeyContainer        *registry_key_data,
 *						CRegItem                *registry_item_data,
 *						GCCModificationRights	modification_rights,
 *						UserID					owner_id,
 *						EntityID				entity_id,
 *						BOOL				enable_monitoring,
 *						GCCResult				result);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send an registry confirmation to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		message_type				(i) Indicates what type of registry item
 *											confirm this is.
 *		registry_key_data			(i) Object holding the registry key.
 *		registry_item_data			(i) Object holding the registry item.
 *		modification_rights			(i) Structure specifying the rights
 *											to be allowed for modifying
 *											the registry parameter.
 *		owner_id					(i) The ID of the owner of the registry item
 *		entity_id					(i) The ID for this instance of the 
 *											application.
 *		enable_monitoring			(i) Flag indicating whether the registry
 *											item is to be monitored.
 *		result						(i) Result code indicating whether or not
 *											the registry request was successful.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegistryMonitorIndication(	
 *								GCCConfID			conference_id,
 *								CRegKeyContainer        *registry_key_data,
 *								CRegItem                *registry_item_data,
 *								GCCModificationRights	modification_rights,
 *								UserID					owner_id,
 *								EntityID				owner_entity_id);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send a Registry monitor indication to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		registry_key_data			(i) Object holding the registry key.
 *		registry_item_data			(i) Object holding the registry item.
 *		modification_rights			(i) Structure specifying the rights
 *											to be allowed for modifying
 *											the registry parameter.
 *		owner_id					(i) The ID of the owner of the registry item
 *		owner_entity_id				(i) The ID for the instance of the 
 *											application owning the registry.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegistryAllocateHandleConfirm(	
 *								GCCConfID			conference_id,
 *								UINT					number_of_handles,
 *								UINT					first_handle,
 *								GCCResult				result);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called by the CConf object when it wishes
 *		to send an enrollment confirmation to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		number_of_handles			(i) The number of handles allocated.
 *		first_handle				(i) The first handle allocated.
 *		result						(i) Result code indicating whether or not
 *											the handle allocation was successful
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\arostmsg.h ===
/*
 *	arostmsg.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_APPLICATION_ROSTER_MESSAGE_
#define	_APPLICATION_ROSTER_MESSAGE_

#include "arost.h"
#include "clists.h"

class CAppRosterMsg : public CRefCount
{
public:

	CAppRosterMsg(void);
	~CAppRosterMsg(void);

	GCCError		LockApplicationRosterMessage(void);
	void			UnLockApplicationRosterMessage(void);

	GCCError		GetAppRosterMsg(LPBYTE *ppData, ULONG *pcRosters);

    void            AddRosterToMessage(CAppRoster *);

private:

	CAppRosterList		    m_AppRosterList;
	LPBYTE					m_pMsgData;
};

#endif // _APPLICATION_ROSTER_MESSAGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\arost.h ===
/*
 *	arost.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent a single Application Roster's 
 *		information base. This includes both application record information and 
 *		capabilities information.  This is one of the most complex classes in 
 *		all of GCC.  It has a number of responsibilities and must maintain the 
 *		information in a very structured way to preserve the connection 
 *		hierarchy of the records.  This is necessary so that collapsed 
 *		capabilities lists can be calculated as changes to the roster are 
 *		propagated up to the Top Provider.
 *
 *		Similar to the CConfRoster class, the CAppRoster class 
 *		encapsulates all the functionality required to maintain the roster 
 *		information base which includes the ability to add new records, delete 
 *		records and update records. It has the ability to convert its internal 
 *		information base into a list of application records that can be used in 
 *		a GCC_APP_ROSTER_UPDATE_INDICATION callback.  It is also responsible for 
 *		converting its internal information base into Roster Update PDUs.  
 *		Basically,  this class is responsible for all operations that require 
 *		direct access to the records contained in an Application Roster.
 *
 *		The CAppRoster class is also responsible for maintaining the 
 *		capabilities list.  This includes storage as well as calculation of the 
 *		collapsed capabilities list.  This class is also responsible for 
 *		converting the internal capabilities list information base into a list 
 *		that can be used in a GCC_APP_ROSTER_UPDATE_INDICATION callback. It is 
 *		also responsible for converting its internal capabilities list 
 *		information base into the capabilities list portion of a Roster Update 
 *		PDU.  Basically,  this class is responsible for all operations that 
 *		require direct access to the capabilities list.
 *
 *		An Application Roster object has the ability to serialize its roster 
 *		data into a single contiguous memory block when it is required to send a 
 *		message to the application interface.  This serialization process is 
 *		managed externally by the CAppRosterMsg class through calls 
 *		to LockApplicationRoster(), UnLockApplicationRoster() and 
 *		GetAppRoster().  When an Application Roster is to be serialized, 
 *		a call is made to LockApplicationRoster() which causes the 
 *		CAppRoster object to increment an internal lock count and returns 
 *		the number of bytes required to hold the complete roster update.  The 
 *		Application Roster is then serialized into memory through a call to 
 *		GetAppRoster().  The CAppRoster is then unlocked to allow 
 *		it to be deleted when the free flag gets set through the 
 *		FreeApplicationRoster() function.  In the current implementation of GCC, 
 *		FreeApplicationRoster() is not used since the CAppRosterMsg 
 *		maintains the data used to deliver the message (see a more detailed 
 *		description of the lock, free and unlock mechanism in the section 
 *		describing the data containers).
 *
 *		The Application Roster class incorporates a number of Rogue Wave list to 
 *		both hold the roster record information and to maintain the connection 
 *		hierarchy.  In many cases there are lists which contain lists.  The 
 *		details of this get extremely complicated.  The Application Roster 
 *		object also is responsible for maintaining internal PDU data which is 
 *		updated whenever a change occurs to its internal information base.  This 
 *		PDU can be affected by both local request or by processing incoming 
 *		PDUs.  Higher level objects access this PDU data by calling the 
 *		Application Roster's flush routine which in turn causes the PDU to be 
 *		freed on any subsequent request that affects the rosters internal 
 *		information base.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_APPLICATION_ROSTER_
#define	_APPLICATION_ROSTER_

#include "gccpdu.h"
#include "capid.h"
#include "sesskey.h"
#include "appcap.h"
#include "igccapp.h"


typedef enum
{
	APP_ADD_RECORD,
	APP_DELETE_RECORD,
	APP_REPLACE_RECORD,
	APP_FULL_REFRESH,
	APP_NO_CHANGE
}
	APP_ROSTER_UPDATE_TYPE;

/*
**	Holds list of capabilities "list" for each protocol entity at a single node.
**	Remember that there can be multiple protocol entities with identical session
**	keys at a single node. Also remember that each of these protocol entities
**	can have multiple capabilities.
*/
class CListOfAppCapItemList2 : public CList2
{
    DEFINE_CLIST2_(CListOfAppCapItemList2, CAppCapItemList*, EntityID)
    void DeleteList(void);
};

/*
**	This is the definition for a single application record.  All the application
**	information (except collapsed capability info) is contained as part of this 
**	record.
*/
typedef struct APP_RECORD
{
	BOOL								is_enrolled_actively;
	BOOL								is_conducting_capable;
	BOOL								was_conducting_capable;
	MCSChannelType						startup_channel_type; 
	UserID								application_user_id;
	CAppCapItemList						non_collapsed_caps_list;
}
	APP_RECORD;

/*
**	This list is used to keep track of the application records at a single node.
**	Since you can have multiple "Protocol Entities" at a single node we use
**	the entity id (which is unique at a node) to index into this list.
*/
class CAppRecordList2 : public CList2
{
    DEFINE_CLIST2_(CAppRecordList2, APP_RECORD*, EntityID)
};


/*
**	This list is used to hold the application record lists for each sub-node
**	of a particular node.
*/
class CSubNodeListOfRecordList2 : public CList2
{
    DEFINE_CLIST2_(CSubNodeListOfRecordList2, CAppRecordList2*, UserID)
};

/*
**	APP_NODE_RECORD
**
**	Below are all the definitions for the application node record. An 
**	application node record holds all the application information for either the
**	local node or a directly connected node.  Note that if the node is the Top 
**	Provider the AppRosterRecordList list will contain information about every
**	"matching" application protocol entity in the entire system.  Matching here
**	means APE's that have the same session key.  
** 
**	An application "roster" record contains all of the following:
**
**	AppRecordList	- 			The list of app records for the protocol 
**								entities at this node.
**
**	ListOfAppCapItemList2 -	    This list holds the list of capabilities for
**								each protocol entity at this node.
**
**	SubNodeList2 -				This list holds the app_record_list for all the
**								nodes below this node in the connection 
**								hierarchy.
**
**	CollapsedCapList -			This holds the collapsed capabilities for
**								all the nodes below this one in the connection
**								hierarchy.  Note that the 
**					   			list_of_capabilities_list is not included in
**								this collapsed list.
**
**	Notice that there is a constructor within this structure. This is
**	needed for the two hash list dictionaries that get instantiated when
**	an AppRosterRecord structure gets instantiated.
*/
typedef struct APP_NODE_RECORD
{
	APP_NODE_RECORD(void);

	CAppRecordList2					AppRecordList;
	CListOfAppCapItemList2		    ListOfAppCapItemList2;
	CSubNodeListOfRecordList2		SubNodeList2;
	CAppCapItemList    				CollapsedCapList;
}
    APP_NODE_RECORD;


/*
**	This list holds all roster records of nodes that are directly connected to 
**	this node.  This list also includes the application records for the local 
**	Application	Protocol entities.  Note that all nodes below this node that
**	are not directly connected to this node are contained in the sub-node list 
**	of the various APP_NODE_RECORD(s) that are contained in this list.
*/
//
// LONCHANC: Can CAppNodeRecordList2 be part of CAppRoster?
// why it is separated from CAppRoster???
//
class CAppNodeRecordList2 : public CList2
{
    DEFINE_CLIST2_(CAppNodeRecordList2, APP_NODE_RECORD*, UserID)
};


class CAppRosterMgr;

class CAppRoster : public CRefCount
{
public:

	CAppRoster(
			PGCCSessionKey,
			PSessionKey,
			CAppRosterMgr *,
			BOOL			fTopProvider,
			BOOL			fLocalRoster,
			BOOL			fMaintainPduBuffer,
			PGCCError);

	~CAppRoster(void);

	/*
	 * Utilities that operate on roster update PDU strucutures.
	 */
	void		FlushRosterUpdateIndicationPDU(PSetOfApplicationInformation *);
	GCCError	BuildFullRefreshPDU(void);
	GCCError	ProcessRosterUpdateIndicationPDU(PSetOfApplicationInformation, UserID);

	/*
	 * Utilities that operate on application records.
	 */
	UINT			LockApplicationRoster(void);
	void			UnLockApplicationRoster(void);
	UINT			GetAppRoster(PGCCApplicationRoster, LPBYTE pData);

	GCCError		AddRecord(GCCEnrollRequest *, GCCNodeID, GCCEntityID);
	GCCError		RemoveRecord(GCCNodeID, GCCEntityID);
	GCCError		ReplaceRecord(GCCEnrollRequest *, GCCNodeID, GCCEntityID);

	GCCError		RemoveUserReference(UserID);

	UINT			GetNumberOfApplicationRecords(void);

	CSessKeyContainer *GetSessionKey(void) { return m_pSessionKey; }

	void			ResetApplicationRoster(void);

	BOOL			DoesRecordExist(UserID, EntityID);

	BOOL			HasRosterChanged(void) { return m_fRosterHasChanged; }

private:

	/*
	 * Utilities used to create a roster update indication PDU.
	 */
	GCCError	BuildApplicationRecordListPDU(APP_ROSTER_UPDATE_TYPE, UserID, EntityID);
	GCCError	BuildSetOfRefreshesPDU(void);
	GCCError	BuildSetOfUpdatesPDU(APP_ROSTER_UPDATE_TYPE, UserID, EntityID);
	GCCError	BuildApplicationRecordPDU(APP_RECORD *, PApplicationRecord);
	GCCError	BuildSetOfCapabilityRefreshesPDU(void);
	GCCError	BuildSetOfNonCollapsingCapabilitiesPDU(PSetOfNonCollapsingCapabilities *, CAppCapItemList *);

	/*
	 * Utilities used to Free a roster update indication PDU.
	 */
	void		FreeRosterUpdateIndicationPDU(void);
	void		FreeSetOfRefreshesPDU(void);
	void		FreeSetOfUpdatesPDU(void);
	void		FreeSetOfCapabilityRefreshesPDU(void);
	void		FreeSetOfNonCollapsingCapabilitiesPDU(PSetOfNonCollapsingCapabilities);
														
	/*
	 * Utilities used to Process roster update indications.
	 */
	GCCError	ProcessSetOfRefreshesPDU(PSetOfApplicationRecordRefreshes, UserID uidSender);
	GCCError	ProcessSetOfUpdatesPDU(PSetOfApplicationRecordUpdates, UserID uidSender);
	GCCError	ProcessApplicationRecordPDU(APP_RECORD *, PApplicationRecord);
	GCCError	ProcessSetOfCapabilityRefreshesPDU(PSetOfApplicationCapabilityRefreshes, UserID uidSender);
	GCCError	ProcessNonCollapsingCapabilitiesPDU(CAppCapItemList *non_collapsed_caps_list,
					                                PSetOfNonCollapsingCapabilities set_of_capabilities);

	/*
	 * Utilities used to operate on conference roster reports.
	 */
	UINT		GetApplicationRecords(PGCCApplicationRoster, LPBYTE memory);
	UINT		GetCapabilitiesList(PGCCApplicationRoster, LPBYTE memory);
	UINT		GetNonCollapsedCapabilitiesList(PGCCApplicationRecord, CAppCapItemList *, LPBYTE memory);
	void		FreeApplicationRosterData(void);
	GCCError	AddCollapsableCapabilities(CAppCapItemList *, UINT cCaps, PGCCApplicationCapability *);
	GCCError	AddNonCollapsedCapabilities(CAppCapItemList *, UINT cCaps, PGCCNonCollapsingCapability *);
	GCCError	ClearNodeRecordFromList(UserID);
	void		ClearNodeRecordList(void);
	GCCError	DeleteRecord(UserID, EntityID, BOOL clear_empty_records);
	void		DeleteApplicationRecordData(APP_RECORD *);
	GCCError	MakeCollapsedCapabilitiesList(void);
	GCCError	AddCapabilityToCollapsedList(APP_CAP_ITEM *);
	BOOL		DoCapabilitiesListMatch(UserID, EntityID, UINT cCapas, PGCCApplicationCapability *);

private:

	UINT							m_nInstance;

	CAppRosterMgr					*m_pAppRosterMgr;
	UINT							m_cbDataMemory;
	BOOL							m_fTopProvider;
	BOOL							m_fLocalRoster;
	CSessKeyContainer			    *m_pSessionKey;

	BOOL							m_fRosterHasChanged;
	BOOL							m_fPeerEntitiesAdded;
	BOOL							m_fPeerEntitiesRemoved;
	BOOL							m_fCapabilitiesHaveChanged;

	CAppNodeRecordList2				m_NodeRecordList2;
//
// LONCHANC: What is the difference between m_NodeRecordList2.CollapsedCapList and
// the following m_CollapsedCapListForAllNodes?
//
// LONCHANC: m_CollapsedCapListForAllNodes is a complete list of collapsed capability list across
// the entire node record list.
//
	CAppCapItemList					m_CollapsedCapListForAllNodes;

	BOOL							m_fMaintainPduBuffer;
	BOOL							m_fPduIsFlushed;
	SetOfApplicationInformation		m_SetOfAppInfo;
	PSetOfApplicationRecordUpdates	m_pSetOfAppRecordUpdates;
};


#endif // _APPLICATION_ROSTER_


/*
 *	CAppRoster(	PGCCSessionKey				session_key,
 *						UINT        				owner_message_base,
 *						BOOL    					is_top_provider,
 *						BOOL    					is_local_roster,
 *						BOOL    					maintain_pdu_buffer,
 *						PGCCError					return_value)
 *
 *	Public Function Description
 *		This is the application roster constructor used when the session key is
 *		made available through local means (not PDU data). It is responsible for
 *		initializing all the instance variables used by this class.
 *
 *	Formal Parameters:
 *		session_key			-	(i) The session key associated with this roster.
 *		owner_object		-	(i)	Pointer to the object that owns this object.
 *		owner_message_base	-	(i) Message base to add to all owner callbacks. 
 *		is_top_provider		-	(i)	Flag indicating if this is a top provider.
 *		is_local_roster		-	(i)	Flag indicating if this is a local roster.
 *		maintain_pdu_buffer	-	(i)	Flag indicating if PDU should be maintained.
 *		return_value		-	(o)	Return value for constructor.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CAppRoster(	PSessionKey					session_key,
 *						UINT        				owner_message_base,
 *						BOOL    					is_top_provider,
 *						BOOL    					is_local_roster,
 *						BOOL    					maintain_pdu_buffer,
 *						PGCCError					return_value)
 *
 *	Public Function Description
 *		This is the application roster constructor used when the session key is
 *		made available through a PDU. It is responsible for initializing all the 
 *		instance variables used by this class.
 *
 *	Formal Parameters:
 *		session_key			-	(i) The session key associated with this roster.
 *		owner_object		-	(i)	Pointer to the object that owns this object.
 *		owner_message_base	-	(i) Message base to add to all owner callbacks. 
 *		is_top_provider		-	(i)	Flag indicating if this is a top provider.
 *		is_local_roster		-	(i)	Flag indicating if this is a local roster.
 *		maintain_pdu_buffer	-	(i)	Flag indicating if PDU should be maintained.
 *		return_value		-	(o)	Return value for constructor.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~ApplicationRoster()
 *
 *	Public Function Description
 *		This is the application roster destructor. It is responsible for
 *		freeing up all the internal memory used by this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	FlushRosterUpdateIndicationPDU (
 *        				PSetOfApplicationInformation  *		indication_pdu)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application roster.  PDU data is queued whenever
 *		a request is made to the application roster that affects its
 *		internal information base. 
 *
 *	Formal Parameters:
 *		indication_pdu		-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The PDU data returned by this routine is automatically freed the next 
 *		time a request is made to this roster object that affects its internal
 *		databease.
 */

/*
 *	GCCError	BuildFullRefreshPDU (void)
 *
 *	Public Function Description
 *		This routine is responsible for generating a full application roster 
 *		refresh PDU.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU (
 *       					   PSetOfApplicationInformation indication_pdu,
 *       					   UserID						sender_id);
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially changes the application roster object's internal database
 *		based on the information in the structure.
 *
 *	Formal Parameters:
 *		indication_pdu		-	(i) This is a pointer to a structure that
 *									holds the decoded PDU data.
 *		sender_id			-	(i)	The user ID of the node that sent the PDU.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	UINT		LockApplicationRoster()
 *
 *	Public Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCApplicationRoster structure
 *		which is filled in on a call to GetAppRoster.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetAppRoster.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GetAppRoster 
 *		structure provided as an output parameter to the GetAppRoster 
 *		call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeApplicationRoster.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  An ApplicatonRoster
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeApplicationRoster call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CAppRoster object will automatically delete itself when
 *		the FreeApplicationRoster call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */

/*
 *	void			UnLockApplicationRoster ();
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeApplicationRoster.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks an CAppRoster
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CAppRoster 
 *		object,	it should assume the object to be invalid thereafter.
 */

/*
 *  UINT		GetAppRoster(
 *							PGCCApplicationRoster 		pGccAppRoster,
 *							LPSTR						pData)
 *
 *	Public Function Description:
 *		This routine is used to retrieve the conference roster data from 
 *		the CAppRoster object in the "API" form of a 
 *		GCCApplicationRoster.
 *
 *	Formal Parameters:
 *		application_roster	(o)	The GCCApplicationRoster structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError		AddRecord(	
 *							PGCCApplicationRecord		application_record,
 *							USHORT						number_of_capabilities,
 *							PGCCApplicationCapability * capabilities_list,
 *							UserID						user_id,
 *							EntityID					entity_id)
 *
 *	Public Function Description:
 *		This routine is used to add a single nodes conference record to the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		application_record		(i)	Pointer to the "API" record	structure to 
 *									add.
 *		number_of_capabilities	(i)	Number of capabilities contained in the
 *									passed in list.
 *		capabilities_list		(i)	List of collapsed capabilities.
 *		user_id					(i)	Node ID associated with record being added.	
 *		entity_id				(i)	Entity ID associated with record being 
 *									added.	
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Bad non-collapsed capabilities.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveRecord(	UserID			node_id)
 *								EntityID		entity_id)
 *
 *	Public Function Description:
 *		This routine is used to remove a single APEs application record from the
 *		application roster object's internal list of records.
 *
 *	Formal Parameters:
 *		node_id				(i)	Node ID of record to be removed.
 *		entity_id			(i)	Entity ID of record to be removed.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ReplaceRecord(		
 *							PGCCApplicationRecord		application_record,
 *							USHORT						number_of_capabilities,
 *							PGCCApplicationCapability * capabilities_list,
 *							UserID						user_id,
 *							EntityID					entity_id)
 *
 *	Public Function Description:
 *		This routine is used to replace a single APEs application record in the
 *		application roster object's internal list of records.
 *
 *	Formal Parameters:
 *		application_record		(i)	Conference record to use as the replacement.
 *		number_of_capabilities	(i)	Number of capabilities contained in the
 *									passed in list.
 *		capabilities_list		(i)	List of collapsed capabilities.
 *		user_id					(i)	Node ID of record to be replaced.
 *		entity_id				(i)	Entity ID of record to be replaced.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Bad non-collapsed capabilities.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveUserReference (
 *							UserID					detached_node)
 *
 *	Public Function Description:
 *		This routine removes all records associated with the specified node
 *		id.
 *
 *	Formal Parameters:
 *		detached_node		(i)	Node reference to remove.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_PARAMETER		-	No records associated with this node
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	USHORT	GetNumberOfApplicationRecords ();
 *
 *	Public Function Description:
 *		This routine returns the total number of application roster records
 *		contained in the objects conference roster record list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of records in the application roster list.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CSessKeyContainer *GetSessionKey ()
 *
 *	Public Function Description:
 *		This routine returns a pointer to the session key associated with this
 *		application roster.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The session key associated with this roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void		ResetApplicationRoster ()
 *
 *	Public Function Description:
 *		This routine takes care of resetting all the internal flags that are
 *		used to convey the current state of the application roster.  Should be
 *		called after the roster is flushed and any roster update messages have
 *		been delivered (after a change to the roster occurs).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	DBBoolean	DoesRecordExist (
 *							UserID						node_id,
 *							EntityID					entity_id)
 *
 *	Public Function Description:
 *		This routine informs the caller if the specified application record 
 *		exists or not.
 *
 *	Formal Parameters:
 *		node_id			-	(i)	Node ID of APE record to check.
 *		entity_id		-	(i)	Entity ID of APE record to check.
 *
 *	Return Value:
 *		TRUE		-	record exist.
 *		FALSE		-	record does not exist.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	DBBoolean		HasRosterChanged ();
 *
 *	Public Function Description:
 *		This routine informs the caller if the roster has changed since the
 *		last time it was reset.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE		-	If roster has changed
 *		FALSE		-	If roster has not changed
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\channel.h ===
/*
 *	channel.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Channel class.  This class represents
 *		both static and assigned channels within an MCS domain.  This class is
 *		also the base class for all other types of channels in MCS.  It defines
 *		the default behavior that can be inherited by these other classes.
 *
 *		Instances of the Channel class have three primary responsibilities:
 *		managing the join/leave process; sending data; and issuing merge
 *		requests during a domain merger.
 *
 *		When a user tries to join a channel, the request is sent to the Channel
 *		object that represents the channel.  The Channel object can then decide
 *		whether or not to allow the join.  By overriding the appropriate
 *		member functions, derived classes can change the criteria by which
 *		this decision is made.
 *
 *		All Channel objects maintain an internal list of which attachments are
 *		joined to the channel they represent.  When data is sent on the channel,
 *		the request is sent to the Channel object, who then knows how to route
 *		the data.  The data is sent to all the appropriate attachments.
 *
 *		During a domain information base merger, all Channel objects will be
 *		asked to issue a merge request upward toward the new top provider.  The
 *		merge request will be built using information contained in the Channel
 *		object.
 *
 *		All public member functions of this class are declared as virtual, so
 *		that they can be overridden in case a derived class has to modify the
 *		behavior.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef _CHANNEL_
#define _CHANNEL_


/*
 *	This is a dictionary of channels that exist within the current domain.
 *	The key to the dictionary is the channel ID, by which channels are
 *	identified.  The value is a pointer to an object of class Channel.  By
 *	definition, if a channel is in the list, then it exists and knows how
 *	to respond to channel related activity.  If a channel is not in the
 *	list, then it does not exist (from the point-of-view of this MCS
 *	provider).
 */

/*
 *	This is the class definition for class Channel.
 */
class Channel
{
public:

	Channel (
			ChannelID			channel_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	Channel (
			ChannelID			channel_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			PConnection         pConn);
	virtual					~Channel ();

    void    SetTopProvider(PConnection top_provider) { m_pConnToTopProvider = top_provider; }
    BOOL    IsTopProvider(void) { return (NULL == m_pConnToTopProvider); }

	virtual Channel_Type	GetChannelType ();
	virtual	BOOL    		IsValid ();
    virtual CAttachment *GetAttachment(void) { return NULL; }
	virtual	Void			IssueMergeRequest ();
	virtual Void			ChannelJoinRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id);
	Void			ChannelJoinConfirm (
									CAttachment        *originator,
									Result				result,
									UserID				uidInitiator,
									ChannelID			requested_id,
									ChannelID			channel_id);
	Void			ChannelLeaveRequest (
									CAttachment        *originator,
									CChannelIDList     *channel_id_list);
	virtual Void			SendDataRequest (
									CAttachment        *originator,
									UINT				type,
									PDataPacket			data_packet);
	Void			SendDataIndication (
									PConnection         originator,
									UINT				type,
									PDataPacket			data_packet);

protected:
	ChannelID				Channel_ID;
	PDomain                 m_pDomain;
	PConnection             m_pConnToTopProvider;
	CChannelList2          *m_pChannelList2;
	CAttachmentList        *m_pAttachmentList;
	CAttachmentList         m_JoinedAttachmentList;
};

/*
 *	Channel (
 *			ChannelID			channel_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the normal constructor for the Channel class.  It simply
 *		initializes the instance variables that identify the channel, the local
 *		provider, and the top provider.  The attachment list is empty by
 *		default.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		local_provider (i)
 *			This is the identity of the local provider.  A Channel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Channel object when it needs to issue a request to the Top
 *			Provider.  If NULL, then this is the top provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel (
 *			ChannelID			channel_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			PCommandTarget		attachment)
 *
 *	Functional Description:
 *		This is a secondary version of the constructor that is used only during
 *		merge operations.  The only difference between this one and the one
 *		above is that this one allows the specification of an initial
 *		attachment.  This allows a Channel object to be constructed with an
 *		existing attachment, without the transmission of a ChannelJoinConfirm.
 *
 *		Remember that if a Channel object is constructed, and then a join
 *		request is used to add an attachment, a Channel object automatically
 *		issues a join confirm.  This constructor allows that to be bypassed
 *		during a merger when a join confirm is inappropriate.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		local_provider (i)
 *			This is the identity of the local provider.  A Channel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Channel object when it needs to issue a request to the Top
 *			Provider.  If NULL, then this is the top provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *		attachment (i)
 *			This is the initial attachment for the channel.  A channel join
 *			confirm is NOT issued to the attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Channel ()
 *
 *	Functional Description:
 *		This is the Channel class destructor.  It clears the joined attachment
 *		list, sending channel leave indications to any user that is locally
 *		attached.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SetTopProvider (
 *						PConnection		top_provider)
 *
 *	Functional Description:
 *		This member function is used to change the identity of the Top Provider
 *		in an existing channel.  The only time this will really occur is when
 *		a provider that used to be the Top Provider merges into another
 *		domain, and therefore ceases to be the Top Provider.
 *
 *	Formal Parameters:
 *		top_provider (i)
 *			This is a pointer to the new Top Provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel_Type	GetChannelType ()
 *
 *	Functional Description:
 *		This virtual member function returns the type of the channel.  For this
 *		class it will be either STATIC_CHANNEL or ASSIGNED_CHANNEL, depending
 *		on the value of the channel ID.
 *
 *		This member function should be overridden by all classes that inherit
 *		from this one so that they return a different type.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		STATIC_CHANNEL if the channel ID is 1000 or less.
 *		ASSIGNED_CHANNEL if the channel ID is greater than 1000.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL	IsValid ()
 *
 *	Functional Description:
 *		This function returns TRUE if the channel is still valid, and FALSE if
 *		it is ready for deletion.  This is a virtual function allowing derived
 *		classes to change the way this decision is made.
 *
 *		This function will use the information in the domain's channel and
 *		attachment lists to validate its own existence.  For example, if a
 *		channel is owned by a user, and that user detaches, the channel will
 *		ask to be deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if channel still valid.
 *		FALSE if channel needs to be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CAttachment *GetAttachment ()
 *
 *	Functional Description:
 *		This function returns a pointer to the attachment that leads to the
 *		owner of the channel.  Since STATIC and ASSIGNED channels do not have
 *		owners, this function will always return NULL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		IssueMergeRequest ()
 *
 *	Functional Description:
 *		This member function causes the Channel object to issue a merge request
 *		to the top provider.  It will pack the appropriate local information
 *		into the command.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to join the channel
 *		associated with a Channel object.  The originator will be added to
 *		the attachment list if it is not already there.
 *
 *		If the user ID passed in is valid (not 0), then a channel join confirm
 *		will be issued to the user.  Setting the user ID to 0 (zero), inhibits
 *		this.
 *
 *		Derived classes can override this member function to provide more
 *		stringent rules about who can join a channel.  This class lets anyone
 *		join, as specified in MCS for static and assigned channels.
 *
 *	Formal Parameters:
 *		originator
 *			This is the attachment of the user wishing to join the channel.
 *		uidInitiator
 *			This is the user ID of the user joining the channel.  This can
 *			be used for security checking in derived classes if desired.
 *		channel_id
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						UserID				requested_id,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function performs essentially the same operation as JoinRequest
 *		above.  The only difference is that the user ID cannot be set to 0
 *		to inhibit the re-transmission of the join confirm to the user who
 *		is joining the channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment of the user wishing to join the channel.
 *		result (i)
 *			This is the result of the previous join request.
 *		uidInitiator (i)
 *			This is the user ID of the user joining the channel.  This can
 *			be used for security checking in derived classes if desired.
 *		requested_id (i)
 *			This is the ID of the channel that the user originally asked to
 *			join.  The only time this will be different from the channel ID
 *			below is if the user asked for channel 0, which is interpreted as
 *			a request for an assigned channel.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This member function is used when an attachment needs to be removed
 *		from a channel.  A leave request will only be received from a lower
 *		provider when all attachments at that level have left (this means that
 *		the data for the channel no longer needs to be sent downward).
 *
 *		If this request results in an empty attachment list a
 *		ChannelLeaveRequest will be sent upward to the next higher provider in
 *		the domain (unless this is the Top Provider).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment to be removed from the channel.
 *		channel_id_list (i)
 *			This is the list of channels being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SendDataRequest (
 *						PCommandTarget		originator,
 *						UINT				type, 
 *						PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This function is called when it is necessary to send data through the
 *		channel that this Channel object represents.  All rules for
 *		non-uniform data apply.  The data will be forwarded upward toward
 *		the Top Provider (unless this is the Top Provider).  Data will also
 *		be sent immediately downward to all attachments who are joined to
 *		the channel, except for the attachment from which the data came.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data came.
 *		type (i)
 *			Simple or uniform send data request.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SendDataIndication (
 *						PCommandTarget		originator,
 *						UINT				type,
 *						PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This function is called when it is necessary to send data through the
 *		channel that this Channel object represents.  The data will be sent
 *		downward to all attachments joined to the channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data came.
 *		type (i)
 *			normal or uniform indication.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\clists.h ===
#ifndef _CLISTS_H_
#define _CLISTS_H_

#define DESIRED_MAX_APP_SAP_ITEMS       6

#define DESIRED_MAX_CONFS               CLIST_DEFAULT_MAX_ITEMS
#define DESIRED_MAX_CONF_ITEMS          DESIRED_MAX_CONFS

#define DESIRED_MAX_CAPS                8
#define DESIRED_MAX_CAP_LISTS           CLIST_DEFAULT_MAX_ITEMS

#define DESIRED_MAX_APP_RECORDS         DESIRED_MAX_APP_SAP_ITEMS
#define DESIRED_MAX_NODES               CLIST_DEFAULT_MAX_ITEMS
#define DESIRED_MAX_NODE_RECORDS        DESIRED_MAX_NODES

#define DESIRED_MAX_CALLBACK_MESSAGES   8

#define DESIRED_MAX_USER_DATA_ITEMS     8

#define DESIRED_MAX_CONN_HANDLES        CLIST_DEFAULT_MAX_ITEMS


// to hold all the non-default session application rosters
class CAppRosterList : public CList
{
    DEFINE_CLIST(CAppRosterList, CAppRoster*)
    void DeleteList(void);
};

// to hold all the application roster managers
class CAppRosterMgrList : public CList
{
    DEFINE_CLIST(CAppRosterMgrList, CAppRosterMgr*)
    void DeleteList(void);
};

// to hold a list of conferences
class CConfList : public CList
{
    DEFINE_CLIST(CConfList, CConf*)
    void DeleteList(void);
};

// to hold all the conferences indexed by conference id
class CConfList2 : public CList2
{
    DEFINE_CLIST2(CConfList2, CConf*, GCCConfID)
    void DeleteList(void);
};

// to hold a list of application sap
class CAppSapList : public CList
{
    DEFINE_CLIST(CAppSapList, CAppSap*)
    void DeleteList(void);
};

// to hold all application sap indexed by entity id
class CAppSapEidList2 : public CList2
{
    DEFINE_CLIST2_(CAppSapEidList2, CAppSap*, GCCEntityID)
    void DeleteList(void);
};

// to hold a list of user id or node id.
class CUidList : public CList
{
    DEFINE_CLIST_(CUidList, UserID)
    void BuildExternalList(PSetOfUserIDs *);
};

// to hold a list of entity id
class CEidList : public CList
{
    DEFINE_CLIST_(CEidList, GCCEntityID)
};

// to hold a list of channel id
class CChannelIDList : public CList
{
    DEFINE_CLIST_(CChannelIDList, ChannelID)
    void BuildExternalList(PSetOfChannelIDs *);
};

// to hold a list of token id
class CTokenIDList : public CList
{
    DEFINE_CLIST_(CTokenIDList, TokenID)
    void BuildExternalList(PSetOfTokenIDs *);
};

// simple packet queue
class CSimplePktQueue : public CQueue
{
    DEFINE_CQUEUE(CSimplePktQueue, PSimplePacket)
};

// remote connection list (aka remote attachment list)
class CConnectionList : public CList
{
    DEFINE_CLIST(CConnectionList, PConnection)
};

class CConnectionQueue : public CQueue
{
    DEFINE_CQUEUE(CConnectionQueue, PConnection)
};

class CTokenList2 : public CList2
{
    DEFINE_CLIST2_(CTokenList2, PToken, TokenID)
};

class CDomainList2 : public CList2
{
    DEFINE_CLIST2(CDomainList2, PDomain, GCCConfID)
};



class CChannelList2 : public CHashedList2
{
    DEFINE_HLIST2_(CChannelList2, PChannel, ChannelID)
};

class CConnectionList2 : public CHashedList2
{
    DEFINE_HLIST2_(CConnectionList2, PConnection, ConnectionHandle)
};

#endif // _CLISTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\capid.h ===
/*
 *	capid.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CCapIDContainer.  A
 *		CCapIDContainer object is used to maintain information about
 *		a particular capability of an application.  A capability identifier can
 *		be either a standard type or a non-standard type.  When the type is 
 *		standard, the identifier is stored internally as an integer value.  When
 *		the type is non-standard, an CObjectKeyContainer container object is used 
 *		internally to buffer the necessary data.  In this case the identifier 
 *		data may exist as an Object ID which is a series of non-negative 
 *		integers or an H221 non-standard ID which is an octet string of no fewer
 *		than four octets and no more than 255 octets.   
 * 
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_CAPABILITY_IDENTIFIER_DATA_
#define	_CAPABILITY_IDENTIFIER_DATA_

#include "objkey.h"

/*
 * This is the typedef for the structure used to hold the capability identifier
 * data	internally.
 */
typedef struct
{
    GCCCapabilityIDType		capability_id_type;

    union
    {
        USHORT			  	standard_capability;
        CObjectKeyContainer *non_standard_capability;
    } u;
}
    CAP_ID_STRUCT;

/*
 * Class definition:
 */
class CCapIDContainer : public CRefCount
{
public:

	CCapIDContainer(PGCCCapabilityID, PGCCError);
	CCapIDContainer(PCapabilityID, PGCCError);
	CCapIDContainer(CCapIDContainer *, PGCCError);

	~CCapIDContainer(void);

	UINT		LockCapabilityIdentifierData(void);
	void		UnLockCapabilityIdentifierData(void);

	UINT		GetGCCCapabilityIDData(PGCCCapabilityID, LPBYTE memory);
	GCCError	GetCapabilityIdentifierDataPDU(PCapabilityID);
	void		FreeCapabilityIdentifierDataPDU(void);

friend BOOL 	operator== (const CCapIDContainer&, const CCapIDContainer&);

protected:

	CAP_ID_STRUCT	                m_InternalCapID;
	UINT							m_cbDataSize;

	CapabilityID					m_CapIDPDU;
	BOOL    						m_fValidCapIDPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CCapIDContainer (	PGCCCapabilityID	capability_id,
 *								PGCCError			return_value);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the constructor for the CCapIDContainer class which 
 *		takes as input the "API" version of capability ID data, GCCCapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(i)	The capability ID data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_CAPABILITY_ID			-	An invalid capability ID passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CCapIDContainer (	PCapabilityID		capability_id,
 *								PGCCError			return_value);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the constructor for the CCapIDContainer class which 
 *		takes as input the "PDU" version of capability ID data, CapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(i)	The capability ID data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_CAPABILITY_ID			-	An invalid capability ID passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CCapIDContainer(CCapIDContainer *capability_id,
 *			PGCCError						return_value);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CCapIDContainer class 
 *		which takes as input another CCapIDContainer object.
 *
 *	Formal Parameters:
 *		capability_id		(i)	The CCapIDContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_CAPABILITY_ID			-	An invalid CCapIDContainer
 *												passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CapabilityIdentifierData();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the destructor for the CCapIDContainer class.  It is 
 *		used to	clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT			LockCapabilityIdentifierData ();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCCapabilityID structure
 *		which is filled in on a call to GetGCCCapabilityIDData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCCapabilityIDData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCCapabilityID structure
 *		provided as an output parameter to the GetGCCCapabilityIDData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeCapabilityIdentifierData.  This
 *		allows other objects to lock this object and be sure that it remains 
 *		valid until they call UnLock which will decrement the internal lock 
 *		count.  A typical usage scenerio for this object would be:  A
 *		CCapIDContainer object is constructed and then passed off to 
 *		any interested parties through a function call.  On return from the 
 *		function call, the FreeCapabilityIdentifierData call is made which will
 *		set the internal "free"	flag.  If no other parties have locked the 
 *		object with a Lock call, then the CCapIDContainer object will 
 *		automatically delete itself when the FreeCapabilityIdentifierData call
 *		is made.  If, however, any number of other parties has locked the 
 *		object, it will remain in existence until each of them has unlocked the
 *		object through a call to UnLock.
 */


/*
 *	UINT			GetGCCCapabilityIdentifierData (	
 *							PGCCCapabilityID 		capability_id,
 *							LPSTR					memory);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the capability ID data from the
 *		CCapIDContainer object in the "API" form of a GCCCapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(o)	The GCCCapabilityID structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockCapabilityIdentifierData ();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeCapabilityIdentifierData.  If so, the object will automatically 
 *		delete itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a 
 *		CCapIDContainer object by calling Lock to also unlock the 
 *		object with a call to UnLock.  If the party calling UnLock did not 
 *		construct the CCapIDContainer object,	it should assume the 
 *		object to be invalid thereafter.
 */


/*
 *	GCCError		GetCapabilityIdentifierDataPDU (	
 *							PCapabilityID 		capability_id);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the capability ID data from the
 *		CCapIDContainer object in the "PDU" form of a CapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(o)	The CapabilityID structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	One of the internal pointers has
 *												been corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeCapabilityIdentifierDataPDU ();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a CapabilityID structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeCapabilityIdentifierDataPDU has been made.
 */


/*
 *	friend BOOL	operator== (
 *					const CCapIDContainer& 		capability_id_1, 
 *					const CCapIDContainer& 		capability_id_2);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CCapIDContainer objects 
 *		to determine whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		capability_id_1			(i)	The first CCapIDContainer object 
 *										to compare.
 *		capability_id_2			(i)	The other CCapIDContainer object 
 *										to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\arostmgr.h ===
/*
 *	arostmgr.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		A single instance of this class represents the owner of all the 
 *		Application Roster objects for a single "Application Protocol Key". The 
 *		CAppRosterMgr takes care of both the "Local" and "Global" 
 *		rosters for all the Sessions that exists which use the same Application 
 *		Protocol Key (peer applications).  Organizing ApplicationRosters this 
 *		way enables GCC to meet some of the requirements specified by the T.GAT 
 *		recommendation.  Specifically,  it enables GCC to deliver multiple 
 *		application rosters that a particular application might be interested in 
 *		a single application roster update indication.  It also hides much of 
 *		the complexity required to manage application rosters from the 
 *		CConf object.
 *
 *		To understand the responsibilities of the CAppRosterMgr it is 
 *		important to understand the meaning of a "Session" within the context 
 *		of GCC.  A "Session" is a logical entity that is used by a set of peer 
 *		Application Protocol Entities (APEs see T.GAT) to communicate.  When an 
 *		application enrolls with GCC it must specify the session it wishes to 
 *		enroll with by specifying a GCCSessionKey.  This session key includes an 
 *		Application Protocol Key and a session ID.  The enrolling application 
 *		must include an Application Protocol Key that is unique for that 
 *		particular APE (Application Protocol Entity see T.GAT).  When other APEs 
 *		in the conference enroll with the same GCCSessionKey, they all show up 
 *		in the same Application Roster.  This makes it possible for all the APEs 
 *		enrolled in the same session to determine who it is talking to who.
 *
 *		Note that it is possible for the same APE to be enrolled in multiple 
 *		sessions at the same time.  Typically the session that does not include 
 *		a session ID is considered the "Default" session for a particular APE.  
 *		The industry seems to be leaning toward using this default session to do 
 *		administrative task like announcing your capabilities to other APEs or 
 *		as a place to enroll inactively until you have time to join the channels 
 *		associated with the real session you want to enroll with.
 *
 *		An obvious requirement of the CAppRosterMgr is that it must 
 *		have the ability to deliver all the related rosters (the rosters 
 *		associated with all the sessions in existence for a particular APE) to 
 *		the enrolled User Application SAPs and to the Control SAP.  It must also 
 *		be able to manage the flow of PDU traffic to and from the application 
 *		rosters it manages.  Below is a more detailed description of the 
 *		responsibilities of the CAppRosterMgr.
 *
 *		The rules for when an CAppRosterMgr exist in a CConf object are 
 *		quite a bit more complex than with the CConfRosterMgr.  In the 
 *		later case, every node is explicitly required to maintain either a 
 *		single "Global" CConfRoster Manager (if it is a Top Provider node) 
 *		or both a "Local" and "Global" CConfRoster Manager (if it is a 
 *		subordinate node).  The existence of an CAppRosterMgr depends 
 *		entirely on an application being enrolled with the conference.  If no 
 *		applications are enrolled there are no ApplicationRosterManagers.  It 
 *		gets much more complicated if some nodes are servicing enrolled 
 *		applications while others are not.  This is often the case when a 
 *		dedicated MCU is in use.  Since an Application Roster's information base 
 *		is distributed throughout the CConf, this sometimes requires that 
 *		CAppRosterMgr objects exist at nodes that contain no enrolled 
 *		applications.
 *
 *		An CAppRosterMgr maintains both "Global" and "Local" rosters.  
 *		A "Local" CAppRoster consist of all the Application Roster 
 *		Records at its local node and below it in the connection hierarchy.  
 *		The CAppRosterMgr does not communicate any changes made to 
 *		"Local" ApplicationRosters to the CAppSap objects.  Its only input is 
 *		from either primitive calls at the local node or from Roster Update PDUs 
 *		received from subordinate nodes. A "Local" CAppRoster can only 
 *		exist at nodes that are not the Top Provider.  
 *
 *		A "Global" CAppRoster has a dual set of responsibilities 
 *		depending on whether or not it is at a Top Provider.  A "Global" roster 
 *		at a Top Provider is responsible for maintaining an Application Roster 
 *		that includes a record entry for every application in the CConf 
 *		that is enrolled with the same Application Protocol Key.  It is also 
 *		responsible for sending full application roster refreshes to all of its 
 *		subordinate nodes when changes to the roster occur.  All 
 *		ApplicationRosterManagers managing "Global" rosters (regardless of 
 *		location within the connection hierarchy) have the ability to send 
 *		Roster Update indications to their local enrolled CAppSap objects.  
 *		Pointers to CAppSap objects that have enrolled with the conference are 
 *		maintained in a list of enrolled ApplicationSaps.  These pointers are 
 *		passed in to this object whenever a new APE enrolls with an Application 
 *		Roster through a GCC primitive at the local node. Application Rosters 
 *		are propagated up to the enrolled applications through Command Target 
 *		calls to the ApplicationSap object.  The CAppRosterMgr also 
 *		maintains a pointer to the CControlSAP object.  Remember all roster 
 *		updates are directed to both the appropriate application SAPs and to the 
 *		Control SAP.  
 *
 *		ApplicationRosterManagers are also responsible for receiving full 
 *		refreshes of the Application Roster from the Top Provider and passing 
 *		them on to the appropriate "Global" CAppRoster object it 
 *		maintains.  It also sends (as mentioned above) Roster Update indications 
 *		to the enrolled Application SAP objects and the Control SAP via 
 *		CAppRosterMsg objects.
 *
 *		All PDUs and messages are delivered when the CAppRosterMgr is 
 *		flushed.  This is a very important concept in that it allows an 
 *		CAppRosterMgr to process a number of request and PDUs before 
 *		actually being flushed.  The CAppRoster itself will queue up 
 *		changes to a PDU that can consist of either multiple updates or a single 
 *		refresh and will not free it until after it is flushed.  Therefore, when 
 *		processing a roster update PDU that consists of changes to the 
 *		conference roster as well as multiple application rosters, a roster 
 *		refresh PDU can be held back until all the roster managers have had a 
 *		chance to process their portion of the roster update.  Once complete, a 
 *		single PDU can be built by flushing the CConfRosterMgr and all 
 *		the affected ApplicationRosterManagers.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_APPLICATION_ROSTER_MANAGER_
#define	_APPLICATION_ROSTER_MANAGER_

#include "gccpdu.h"
#include "mcsuser.h"
// #include "gcmdtar.h"
#include "arost.h"
#include "sesskey.h"
#include "clists.h"


class CAppRosterMgr : public CRefCount
{
public:

	CAppRosterMgr(PGCCSessionKey,
            		PSessionKey, // PDU
            		GCCConfID,
            		PMCSUser,
            		CConf *,
            		PGCCError);

	~CAppRosterMgr(void);

    GCCError    EnrollRequest(GCCEnrollRequest *, GCCEntityID, GCCNodeID, CAppSap *);
	GCCError	UnEnrollRequest(PGCCSessionKey, GCCEntityID);

	GCCError	ProcessRosterUpdateIndicationPDU(PSetOfApplicationInformation, UserID uidSender);

	PSetOfApplicationInformation    FlushRosterUpdateIndication(PSetOfApplicationInformation *, PGCCError);
	PSetOfApplicationInformation    GetFullRosterRefreshPDU(PSetOfApplicationInformation *, PGCCError);
					
	BOOL	IsThisYourSessionKey(PGCCSessionKey pSessKey) { return IsThisSessionKeyValid(pSessKey); }
	BOOL	IsThisYourSessionKeyPDU(PSessionKey pSessKey) { return IsThisSessionKeyPDUValid(pSessKey); }

	GCCError	RemoveEntityReference(GCCEntityID);
	GCCError	RemoveUserReference(UserID uidDetached);
					
	GCCError	ApplicationRosterInquire(PGCCSessionKey, CAppRosterMsg *);

	BOOL		IsEntityEnrolled(GCCEntityID);
	BOOL		IsAPEEnrolled(GCCNodeID, GCCEntityID);
	BOOL		IsAPEEnrolled(CSessKeyContainer *, GCCNodeID, GCCEntityID);
	BOOL		IsEmpty(void);

    void    DeleteRosterRecord(GCCNodeID, GCCEntityID);

private:

	GCCError	SendRosterReportMessage(void);
	
	CAppRoster	*GetApplicationRoster(PGCCSessionKey, CAppRosterList *);
	CAppRoster	*GetApplicationRosterFromPDU(PSessionKey, CAppRosterList *);

	BOOL	IsThisSessionKeyValid(PGCCSessionKey pSessKey)
		{ return m_pSessionKey->IsThisYourApplicationKey(&pSessKey->application_protocol_key); }

	BOOL	IsThisSessionKeyPDUValid(PSessionKey pSessKey)
		{ return m_pSessionKey->IsThisYourApplicationKeyPDU(&pSessKey->application_protocol_key); }

	void				CleanupApplicationRosterLists(void);

private:

	GCCConfID   					m_nConfID;
	BOOL							m_fTopProvider;
	PMCSUser						m_pMcsUserObject;
	CAppSapEidList2 			    m_AppSapEidList2;
	CConf							*m_pConf;
	CAppRosterList					m_GlobalRosterList;
	CAppRosterList					m_LocalRosterList;
	CAppRosterList					m_RosterDeleteList;
	CSessKeyContainer			    *m_pSessionKey;
};


#endif // _APPLICATION_ROSTER_MANAGER_

/*
 *	CAppRosterMgr	(
 *                     	PGCCSessionKey					session_key,
 *						GCCConfID   					conference_id,
 *						PMCSUser						user_object,
 *						UINT        					owner_message_base,
 *						CControlSAP				        *pControlSap,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from local API data.
 *
 *	Formal Parameters:
 *		session_key			-	(i)	"API" Session Key used to establish the 
 *									application protocol key for this session.
 *		conference_id		-	(i)	Conference ID associated with this roster
 *									maanger.
 *		user_object			-	(i)	Pointer to the user attachment object used
 *									by this class.
 *		owner_object		-	(i)	Pointer to the owner object.
 *		owner_message_base	-	(i)	Message base to add to all the owner 
 *									callbacks.
 *		control_sap			-	(i)	Pointer to the node controller SAP object.
 *		return_value		-	(o)	Pointer to error value to be returned.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No resource error occured.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CAppRosterMgr	(
 *						PSessionKey						session_key,
 *						GCCConfID   					conference_id,
 *						PMCSUser						user_object,
 *						UINT        					owner_message_base,
 *						CControlSAP				        *pControlSap,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from remote PDU data.
 *
 *		This constructor handles a number of different possiblities:
 *			For Non Top Providers:
 *				1)	A refresh received from the top provider.
 *				2)	An update from a node below this one.
 *
 *			For the Top Provider:
 *				1)	An Update from a lower node
 *
 *	Formal Parameters:
 *		session_key			-	(i)	"PDU" Session Key used to establish the 
 *									application protocol key for this session.
 *		conference_id		-	(i)	Conference ID associated with this roster
 *									maanger.
 *		user_object			-	(i)	Pointer to the user attachment object used
 *									by this class.
 *		owner_object		-	(i)	Pointer to the owner object.
 *		owner_message_base	-	(i)	Message base to add to all the owner 
 *									callbacks.
 *		control_sap			-	(i)	Pointer to the node controller SAP object.
 *		return_value		-	(o)	Pointer to error value to be returned.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No resource error occured.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~ApplicationRosterManager ()
 *
 *	Public Function Description
 *		This is the application roster manager destructor.  It is used to
 *		free up all memory associated with this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	EnrollRequest (
 *                      PGCCSessionKey					session_key,
 *	        			PGCCApplicationRecord			application_record,
 *						EntityID						entity_id,
 *						UINT							number_of_capabilities,
 *						PGCCApplicationCapability	*	capabilities_list)
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to enroll with the
 *		conference in a specific session.  This routine can be used to
 *		either add a new record or replace a currently existing record.
 *
 *	Formal Parameters:
 *		session_key				-	(i)	Session to enroll with.
 *		application_record		-	(i)	Application record to enroll with.
 *		entity_id				-	(i)	Entity ID of enrolling APE.
 *		number_of_capabilities	-	(i)	Number of capabilities in caps list.
 *		capabilities_list		-	(i)	list of capabilities that the APE is
 *										enrolling with.
 *		command_target			-	(i)	Pointer to APE SAP that is enrolling.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_BAD_SESSION_KEY				-	Session key passed in is invalid.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Bad non-collapsed capabilities.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	UnEnrollRequest (
 *                     	PGCCSessionKey					session_key,
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to unenroll from the
 *		conference (or a specific session).
 *
 *	Formal Parameters:
 *		session_key				-	(i)	Session to unenroll from.
 *		entity_id				-	(i)	Entity ID of unenrolling APE.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_BAD_SESSION_KEY				-	Session key passed in is invalid.
 *		GCC_APP_NOT_ENROLLED			-	APE is not enrolled with this
 *											session..
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU(
 *						PSetOfApplicationInformation	set_of_application_info,
 *						UserID							sender_id)
 *
 *	Public Function Description
 *		This routine processes an incomming roster update PDU.  It is
 *		responsible for passing the PDU on to the right application roster.
 *
 *	Formal Parameters:
 *		set_of_application_info	-	(i)	PDU data to process
 *		sender_id				-	(i)	Node ID that sent the update.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_BAD_SESSION_KEY				-	Session key passed in is invalid.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	PSetOfApplicationInformation	FlushRosterUpdateIndication (
 *						PSetOfApplicationInformation *	set_of_information,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application rosters managed by this application
 *		roster manager.  It also is responsible for flushing any queued 
 *		roster update messages if necessary.
 *
 *	Formal Parameters:
 *		set_of_information	-	(o)	Pointer PDU to fill in.
 *		return_value		-	(o)	Error return here.
 *
 *	Return Value
 *		Pointer to the new set of application information.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	PSetOfApplicationInformation	GetFullRosterRefreshPDU (
 *						PSetOfApplicationInformation *	set_of_information,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This routine is used to obtain a complete roster refresh of all the
 *		rosters maintained by this roster manger.
 *
 *	Formal Parameters:
 *		set_of_information	-	(o)	Pointer PDU to fill in.
 *		return_value		-	(o)	Error return here.
 *
 *	Return Value
 *		Pointer to the new set of application information.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsThisYourSessionKey(
 *						PGCCSessionKey					session_key)
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "API" session key is
 *		associated with this application roster manager.
 *
 *	Formal Parameters:
 *		session_key		-	(i)	"API" session key to test.
 *
 *	Return Value
 *		TRUE	-	If session key is associated with this manager.
 *		FALSE	-	If session key is NOT associated with this manager.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsThisYourSessionKeyPDU(
 *						PSessionKey						session_key);
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "PDU" session key is
 *		associated with this application roster manager.
 *
 *	Formal Parameters:
 *		session_key		-	(i)	"PDU" session key to test.
 *
 *	Return Value
 *		TRUE	-	If session key is associated with this manager.
 *		FALSE	-	If session key is NOT associated with this manager.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RemoveEntityReference(
 *						EntityID						application_entity)
 *
 *	Public Function Description
 *		This routine is used to remove the specified APE entity from the 
 *		session it is enrolled with.  Note that this routine is only used
 *		to remove local entity references.
 *
 *	Formal Parameters:
 *		application_entity	-	(i)	Entity reference to remove.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	Entity was removed.
 *		GCC_INVALID_PARAMETER	-	Entity does not exist here.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RemoveUserReference(
 *						UserID							detached_user)
 *
 *	Public Function Description
 *		This routine is used to remove all references associated with the
 *		node defined by the detached user.
 *
 *	Formal Parameters:
 *		detached_user	-	(i)	User reference to remove.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	User reference was removed.
 *		GCC_INVALID_PARAMETER	-	No records associated with this node.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsEntityEnrolled(
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine informs the caller if the specified entity is enrolled
 *		with any sessions managed by this application roster manager.
 *
 *	Formal Parameters:
 *		entity_id	-	(i)	Entity to test.
 *
 *	Return Value
 *		TRUE	-	Entity is enrolled.
 *		FALSE	-	Entity is not enrolled.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ApplicationRosterInquire (
 *						PGCCSessionKey					session_key,
 *						CAppRosterMsg					*roster_message)
 *
 *	Public Function Description
 *		This routine inserts the appropriate application rosters into the
 *		roster message that is passed in.  If the specified session key is set
 *		to NULL or a session ID of zero is passed in, all the global rosters 
 *		managed by this object will be returned.  Otherwise, only the
 *		specified session roster will be returned.
 *
 *	Formal Parameters:
 *		session_key		- (i) Session key defining roster being inquired about.
 *		roster_message 	- (o) Roster message to fill in.	
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsAPEEnrolled(
 *						UserID							node_id,
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine determines if the specified APE is enrolled with one
 *		of the sessions managed by this application roster manager.
 *
 *	Formal Parameters:
 *		node_id		- (i) Node ID of APE to test.
 *		entity_id 	- (i) Entity ID of APE to test.	
 *
 *	Return Value
 *		TRUE	-	APE is enrolled here.
 *		FALSE	-	APE is not enrolled here.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsAPEEnrolled(
 *						CSessKeyContainer			    *session_key_data,
 *						UserID							node_id,
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine determines if the specified APE is enrolled with the
 *		specified session.
 *
 *	Formal Parameters:
 *		session_key_data	- (i) Session Key of roster to check.
 *		node_id				- (i) Node ID of APE to test.
 *		entity_id 			- (i) Entity ID of APE to test.	
 *
 *	Return Value
 *		TRUE	-	APE is enrolled with this session.
 *		FALSE	-	APE is not enrolled with this session.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsEmpty(void)
 *
 *	Public Function Description
 *		This routine determines if this application roster managfer contains
 *		any application rosters.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	Application Roster Manager is empty.
 *		FALSE	-	Application Roster Manager is NOT empty.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\attmnt.h ===
#ifndef __MCS_ATTACHMENT_H__
#define __MCS_ATTACHMENT_H__

typedef enum
{
    USER_ATTACHMENT,        // local attachment
    CONNECT_ATTACHMENT      // remote attachment
}
    ATTACHMENT_TYPE;


class CAttachmentList : public CList
{
    DEFINE_CLIST(CAttachmentList, CAttachment*)

    PUser IterateUser(void);
    PConnection IterateConn(void);

    BOOL FindUser(PUser pUser) { return Find((CAttachment *) pUser); }
    BOOL FindConn(PConnection pConn) { return Find((CAttachment *) pConn); }

    BOOL AppendUser(PUser pUser) { return Append((CAttachment *) pUser); }
    BOOL AppendConn(PConnection pConn) { return Append((CAttachment *) pConn); }
};

class CAttachmentQueue : public CQueue
{
    DEFINE_CQUEUE(CAttachmentQueue, CAttachment*)

    PUser IterateUser(void);
    PConnection IterateConn(void);

    BOOL FindUser(PUser pUser) { return Find((CAttachment *) pUser); }
    BOOL FindConn(PConnection pConn) { return Find((CAttachment *) pConn); }

    BOOL AppendUser(PUser pUser) { return Append((CAttachment *) pUser); }
    BOOL AppendConn(PConnection pConn) { return Append((CAttachment *) pConn); }
};



class CAttachment
{
public:

    CAttachment(ATTACHMENT_TYPE eAttmntType) : m_eAttmntType(eAttmntType) { }
    // ~CAttachment(void) { }

    ATTACHMENT_TYPE GetAttachmentType(void) { return m_eAttmntType; }
    BOOL            IsUserAttachment(void) { return (USER_ATTACHMENT == m_eAttmntType); }
    BOOL            IsConnAttachment(void) { return (CONNECT_ATTACHMENT == m_eAttmntType); }


    virtual void PlumbDomainIndication(ULONG height_limit) = 0;
    virtual void PurgeChannelsIndication(CUidList *, CChannelIDList *) = 0;
    virtual void PurgeTokensIndication(PDomain, CTokenIDList *) = 0;
    virtual void DisconnectProviderUltimatum(Reason) = 0;
    virtual void AttachUserConfirm(Result, UserID uidInitiator) = 0;
    virtual void DetachUserIndication(Reason, CUidList *) = 0;
    virtual void ChannelJoinConfirm(Result, UserID uidInitiator, ChannelID requested_id, ChannelID) = 0;
    virtual void ChannelConveneConfirm(Result, UserID uidInitiator, ChannelID) = 0;
    virtual void ChannelDisbandIndication(ChannelID) = 0;
    virtual void ChannelAdmitIndication(UserID uidInitiator, ChannelID, CUidList *) = 0;
    virtual void ChannelExpelIndication(ChannelID, CUidList *) = 0;
    virtual void SendDataIndication(UINT message_type, PDataPacket data_packet) = 0;
    virtual void TokenGrabConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenInhibitConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenGiveIndication(PTokenGiveRecord) = 0;
    virtual void TokenGiveConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenReleaseConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenPleaseIndication(UserID uidInitiator, TokenID) = 0;
    virtual void TokenTestConfirm(UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void MergeDomainIndication(MergeStatus) = 0;

private:

    ATTACHMENT_TYPE     m_eAttmntType;
};



#endif // __MCS_ATTACHMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\cnpcoder.h ===
/*
 *	ogcccode.h
 *
 *	Copyright (c) 1999 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the interface file for the CNPCoder class.  This
 *		class is used to encode and decode CNP Protocol Data Units (PDU's)
 *		to and from ASN.1 compliant byte streams using the ASN.1 toolkit.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Xin Liu
 *
 */
#ifndef	_CCNPCODER_
#define	_CCNPCODER_

#include "pktcoder.h"
#include "cnppdu.h"

/*
 *	This is the class definition for class CCNPCoder
 */
class	CCNPCoder : public PacketCoder
{
 public:
    CCNPCoder ();
    BOOL                Init ( void );
    virtual             ~CCNPCoder ();
    virtual	BOOL	Encode (LPVOID                  pdu_structure,
                                int                     pdu_type,
                                UINT                    rules_type,
                                LPBYTE			*encoding_buffer,
                                UINT			*encoding_buffer_length);
    
    virtual BOOL	Decode (LPBYTE			encoded_buffer,
                                UINT			encoded_buffer_length,
                                int                     pdu_type,
                                UINT			rules_type,
                                LPVOID			*decoding_buffer,
                                UINT			*decoding_buffer_length);
    
    virtual void	FreeEncoded (LPBYTE encoded_buffer);
    
    virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer);
    
    virtual BOOL     IsMCSDataPacket (	LPBYTE,	UINT		) { return FALSE; };
    
 private:
    //    BOOL    		IsObjectIDCompliant (PKey	t124_identifier);
    ASN1encoding_t  m_pEncInfo;    // ptr to encoder info
    ASN1decoding_t  m_pDecInfo;    // ptr to decoder info
};

typedef CCNPCoder *		PCCNPCoder;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\conf.h ===
/*
 *	conf.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CConf class.  This class
 *		is where most of the inteligence within GCC lies.  The class
 *		manages the GCC databases and routes the messages and PDUs.
 *
 *		CConf objects represent the true heart of GCC.  Each CConf
 *		object represents one logical conference within a GCC provider.  This
 *		class encapsulates the conference information base which is the focal
 *		point for all GCC traffic.  This information base consists of several
 *		Rogue Wave containers, including:
 *		-	a dictionary of enrolled applications (indexed by application SAP
 *			handles).
 *		-	a list of application roster managers.
 *		-	a list of downward MCS connections.
 *		-	a list of outstanding sequence numbers (used during conference
 *			establishment).
 *		-	a list of outstanding join requests.
 *
 *		In order to simplify the CConf class as much as possible, there are
 *		some things that CConf objects do not worry about.  First and
 *		foremost is Conference and Application Roster management.  This is
 *		handled by two separate classes.  Next is the Application Registry.
 *		CConf objects don't maintain the Application Registry information
 *		base.  CConf objects also do not worry about memory management.
 *		They merely pass Packet objects around, which contain the user data
 *		being handled.  A CConf object has absolutely no responsibility
 *		for protocol data associated with an enrolled application. Below is
 *		more detail about what a conference is responsible for.
 *
 *		When a CConf object is first created, its information base is
 *		empty.  It has no enrolled applications, it has not established any MCS
 *		connections and it has no user attachment to MCS.  There is a period of
 *		time that will be referred to as the Conference Establishment Process
 *		where the CConf object is progressing through the steps defined by
 *		the T.124 specification to join or create a conference.  This process
 *		varies depending on the request that initiated the creation of the
 *		conference.  A CConf Object must know if it is a Top Provider.
 *		Many of the establishment procedures and normal operating procedures
 *		vary depending on this.  A CConf object learns of its type through
 *		the initial requests that are made to it.  For example,  if a
 *		CConf receives a ConferenceCreateRequest where the conference is
 *		to be created locally it knows it is the Top Provider.
 *
 *		The establishment process involves three main steps that all nodes go
 *		through when creating a new conference.  The first is establishing the
 *		MCS connection either through a ConnectProviderRequest or a
 *		ConnectProviderResponse call  (note that this step is skipped when
 *		creating a local conference).  If this step is successful, the
 *		CConf object will create an MCSUser object which progresses through
 *		a number of its own internal steps which include creating an MCS User
 *		Attachment and joining the appropriate channels (which are handled by
 *		the MCSUser object). Finally, when the above two steps have successfully
 *		completed, the conference creates an Application Registry and the
 *		CConfRosterMgr objects and informs the Controller that the
 *		conference is established.  A conference cannot respond to any request
 *		during this establishment process.  For instance, a conference will not
 *		show up in a Conference Query descriptor list during the establishment
 *		phase.
 *
 *		A note about the creation of the CConfRosterMgr objects.
 *		A CConf object that is not the Top Provider will instantiate both
 *		a Local and a Global CConfRosterMgr while the Top Provider
 *		only maintains a Global Conference Roster Manager.  A Local manager
 *		maintains a Conference Roster which holds the local nodes conference
 *		record and the conference records for all nodes below it in the
 *		connection hierarchy.  A Global manager maintains a Conference Roster
 *		which includes the conference records for every node that has announced
 *		its presence with the conference.
 *
 *		After the above establishment process is complete the Owner Object is
 *		notified through an owner callback that the conference is ready for
 *		action.  When the node controller receives a
 *		GCC_PERMIT_TO_ANNOUNCE_PRESENCE indication it must respond with a call
 *		to GCCAnnouncePresenceRequest().  This is when the node controller
 *		passes its conference record (which contains all the pertinent
 *		information about the node) to the newly created conference.  This
 *		request travels through the CControlSAP directly to the conference
 *		through a GCCCommandTarget call.  Remember that the CConf class
 *		inherits from the GCCCommandTarget class.  Whenever a call is made
 *		directly to a CConf object from either a CControlSAP or an CAppSap
 *		object, it is made through a command target call.
 *
 *		When an application receives a GCC_PERMIT_TO_ENROLL_INDICATION it must
 *		respond by calling AppEnrollRequest() to inform the
 *		CConf object whether or not it wants to enroll with the conference.
 *		When an application enroll request is received by a CConf
 *		object a number of things happen, some of which depend on whether the
 *		CConf object is a Top Provider or a subordinate node.  First the
 *		CConf determines if the application is enrolling.  If it isn't,  a
 *		GCC_APPLICATION_ENROLL_CONFIRM is sent to the application that made the
 *		request and no further action is taken.  If the application is
 *		enrolling, the CConf object first registers itself with the CAppSap
 *		making the request.  This allows future application requests to travel
 *		directly to the CConf object through command target calls.  The
 *		CConf then establishes the Application Roster Manager
 *		(if necessary) for this particular application.
 *
 *		After the above establishment and enrollment process is completed a
 *		CConf object sits idle waiting to service requests or process
 *		incoming PDUs.  These include RosterUpdateIndications as well as
 *		CRegistry requests.
 *
 *		A CConf object can be deleted in a number of different ways.  If a
 *		resource error occurs, a conference can Terminate itself by sending an
 *		error TERMINATE indication to its owner through an owner callback.
 *		The node controller can terminate a conference object by calling
 *		GCCConferenceDisconnectRequest() or GCCConferenceTerminateRequest().  A
 *		CConf object can also be terminated if it loses its parent
 *		connection or if it is set up to automatically terminate after all its
 *		subordinate nodes disconnect.  These types of Terminates are initiated
 *		through owner callbacks to the Owner Object.
 *
 *	Portable:
 *		Yes
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_CONFERENCE_
#define	_CONFERENCE_

#include "arostmgr.h"
#include "sap.h"
#include "pktcoder.h"
#include "mcsdllif.h"
#include "password.h"
#include "netaddr.h"
#include "privlist.h"
#include "crostmgr.h"
#include "registry.h"
#include "appsap.h"
#include "csap.h"

//	Message bases
#define		USER_ATTACHMENT_MESSAGE_BASE	100
#define		APP_ROSTER_MGR_MESSAGE_BASE		200
#define		CONF_ROSTER_MGR_MESSAGE_BASE	300


enum
{
    CONF_FLUSH_ROSTER_DATA      = CONFMSG_BASE + 1,
};


typedef struct
{
	GCCConfID		conference_id;
	GCCReason		reason;
}
    CONF_TERMINATE_INFO;


typedef struct
{
	ConnectionHandle	connection_handle;
	TagNumber			invite_tag;
	CUserDataListContainer *user_data_list;
}
    INVITE_REQ_INFO;


/*	This structure is used to hold all of an APEs enrollment information.
**	Every APE enrolled with a conference will have a single one of these
**	info structures defined for it.
*/
//
// LONCHANC: We should merge the following to another structure or class
// because it has 2 dwords and we need to allocate memory for it.
//
typedef struct
{
	CAppSap             *pAppSap;
	CSessKeyContainer	*session_key;
}
    ENROLLED_APE_INFO;

/*
**	Lists/Dictionaries used by the CConf Object
*/

//	This list is used to keep track of the outstanding join responses
class CJoinRespNamePresentConnHdlList2 : public CList2
{
    // use TRUE_PTR and FALSE_PTR
    DEFINE_CLIST2_(CJoinRespNamePresentConnHdlList2, BOOL_PTR, ConnectionHandle)
};

//	This list is used to keep track of the enrolled APEs
class CEnrolledApeEidList2 : public CList2
{
    DEFINE_CLIST2_(CEnrolledApeEidList2, ENROLLED_APE_INFO*, GCCEntityID)
};

//	This list is keeps up with the child node connection handles
class CConnHandleList : public CList
{
    DEFINE_CLIST_(CConnHandleList, ConnectionHandle)
};

//	This list is used to match outstanding user IDs
typedef	TagNumber	        UserIDTagNumber; // unsigned long
class CConnHdlTagNumberList2 : public CList2
{
    DEFINE_CLIST2(CConnHdlTagNumberList2, ConnectionHandle, UserIDTagNumber)
};

//	This list is used to hold all the outstanding invite request
class CInviteRequestList : public CList
{
    DEFINE_CLIST(CInviteRequestList, INVITE_REQ_INFO*)
};

//	This list is used to hold all the outstanding ejects
class CEjectedNodeConfirmList : public CList
{
    DEFINE_CLIST_(CEjectedNodeConfirmList, GCCNodeID)
};

//	This list is a queue of outstanding conductor token test
class CConductorTestList : public CList
{
    DEFINE_CLIST(CConductorTestList, CBaseSap*)
};

// this list is a queue of outstanding "add" request
class CNetAddrTagNumberList2 : public CList2
{
    DEFINE_CLIST2(CNetAddrTagNumberList2, CNetAddrListContainer*, TagNumber)
};

class CTagNumberTagNumberList2 : public CList2
{
    DEFINE_CLIST2__(CTagNumberTagNumberList2, TagNumber)
};

// this list holds the NetMeeting version numbers of all nodes in the conference
class CNodeVersionList2 : public CList2
{
	DEFINE_CLIST2_(CNodeVersionList2, DWORD_PTR, GCCNodeID)
};


// Conference specification parameters
typedef struct
{
	BOOL						fClearPassword;
	BOOL						fConfLocked;
	BOOL						fConfListed;
	BOOL						fConfConductable;
	GCCTerminationMethod		eTerminationMethod;
	PGCCConferencePrivileges	pConductPrivilege;
	PGCCConferencePrivileges	pConductModePrivilege;
	PGCCConferencePrivileges	pNonConductPrivilege;
	LPWSTR						pwszConfDescriptor;
}
	CONF_SPEC_PARAMS;

//	The class definition
class CConf : public CRefCount
{
    friend class MCSUser;

public:

	CConf
	(
		PGCCConferenceName			conference_name,
		GCCNumericString			conference_modifier,
		GCCConfID				    conference_id,
		CONF_SPEC_PARAMS			*pConfSpecParams,
		UINT						cNetworkAddresses,
		PGCCNetworkAddress 			*pLocalNetworkAddress,
		PGCCError					return_value
	);

	~CConf(void);

	/*
	**	Public Member Functions : should only be called
	**	by the owner object
	*/
	GCCError		ConfCreateRequest(
						TransportAddress		calling_address,
						TransportAddress		called_address,
						BOOL					fSecure,
						CPassword               *convener_password,
						CPassword               *password,
						LPWSTR					pwszCallerID,
						PDomainParameters		domain_parameters,
						CUserDataListContainer  *user_data_list,
						PConnectionHandle		connection_handle);

	GCCError		ConfCreateResponse(
						ConnectionHandle		connection_handle,
						PDomainParameters		domain_parameters,
						CUserDataListContainer  *user_data_list);

	GCCError		ConfJoinRequest
					(
						GCCNumericString		called_node_modifier,
						CPassword               *convener_password,
						CPassword               *password_challenge,
						LPWSTR					pwszCallerID,
						TransportAddress		calling_address,
						TransportAddress		called_address,
						BOOL					fSecure,
						PDomainParameters 		domain_parameters,
						CUserDataListContainer  *user_data_list,
						PConnectionHandle		connection_handle
					);

	GCCError		ForwardConfJoinRequest
					(
						CPassword               *convener_password,
						CPassword               *password_challange,
						LPWSTR					pwszCallerID,
						CUserDataListContainer  *user_data_list,
						BOOL					numeric_name_present,
						ConnectionHandle		connection_handle
					);

	GCCError		ConfJoinIndResponse
					(
						ConnectionHandle		connection_handle,
						CPassword               *password_challenge,
						CUserDataListContainer  *user_data_list,
						BOOL					numeric_name_present,
						BOOL					convener_is_joining,
						GCCResult				result
					);

	GCCError		ConfInviteResponse(
						UserID					parent_user_id,
						UserID					top_user_id,
						TagNumber				tag_number,
						ConnectionHandle		connection_handle,
						BOOL					fSecure,
						PDomainParameters		domain_parameters,
						CUserDataListContainer  *user_data_list);

	GCCError		RegisterAppSap(CAppSap *);
	GCCError		UnRegisterAppSap(CAppSap *);
	GCCError		DisconnectProviderIndication(ConnectionHandle);
	GCCError		ConfRosterInquireRequest(CBaseSap *, GCCAppSapMsgEx **);
	GCCError		AppRosterInquireRequest(GCCSessionKey *, CAppRosterMsg **);
	BOOL			FlushOutgoingPDU(void);

    GCCConfID GetConfID ( void ) { return m_nConfID; }
    ConferenceNodeType GetConfNodeType ( void ) { return m_eNodeType; }

    GCCNodeID GetParentNodeID(void) { return (m_pMcsUserObject ? m_pMcsUserObject->GetParentNodeID() : 0); }

    BOOL IsConfTopProvider ( void )
    {
        return ((m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE) ||
                (m_eNodeType == TOP_PROVIDER_NODE));
    }

    GCCNodeID GetTopProvider(void) { return (m_pMcsUserObject ? m_pMcsUserObject->GetTopNodeID() : 0); }

    BOOL DoesConvenerExists ( void ) { return (m_nConvenerNodeID != 0); }
    BOOL IsConfListed ( void ) { return m_fConfListed; }
    BOOL IsConfPasswordInTheClear ( void ) { return m_fClearPassword; }
    BOOL IsConfLocked ( void ) { return m_fConfLocked; }
    BOOL IsConfEstablished ( void ) { return m_fConfIsEstablished; }
    BOOL IsConfConductible ( void ) { return m_fConfConductible; }
    BOOL IsConfSecure ( void ) { return m_fSecure; }

    LPSTR GetNumericConfName ( void ) { return m_pszConfNumericName; }
    LPWSTR GetTextConfName ( void ) { return m_pwszConfTextName; }
    LPSTR GetConfModifier ( void ) { return m_pszConfModifier; }
    LPWSTR GetConfDescription ( void ) { return m_pwszConfDescription; }
    CNetAddrListContainer *GetNetworkAddressList ( void ) { return m_pNetworkAddressList; }
    void ConfIsOver ( void ) { m_fConfIsEstablished = FALSE; }

    CRegistry *GetRegistry ( void ) { return m_pAppRegistry; }

	/*
	**	These are Command Targets
	*/

	GCCError			ConfJoinReqResponse(
							UserID				    receiver_id,
							CPassword               *password_challenge,
							CUserDataListContainer  *user_data_list,
							GCCResult			    result);

	GCCError			ConfInviteRequest(
							LPWSTR					pwszCallerID,
							TransportAddress		calling_address,
							TransportAddress		called_address,
							BOOL					fSecure,
							CUserDataListContainer  *user_data_list,
							PConnectionHandle		connection_handle);

	GCCError			ConfLockResponse(UserID uidRequester, GCCResult);

	GCCError 			ConfEjectUserRequest(UserID uidEjected, GCCReason reason);
	GCCError			ConfAnnouncePresenceRequest(PGCCNodeRecord node_record);
	GCCError			ConfDisconnectRequest(void);

	GCCError			AppEnrollRequest(CAppSap *, GCCEnrollRequest *, GCCRequestTag);

#ifdef JASPER
	GCCError			ConfLockRequest(void);
	GCCError			ConfUnlockRequest(void);
	GCCError			ConfUnlockResponse(UserID uidRequester, GCCResult result);
	GCCError			ConfTerminateRequest(GCCReason reason);
#endif // JASPER

	/******************** Registry calls **************************/

	GCCError			RegistryRegisterChannelRequest(
							PGCCRegistryKey			registry_key,
							ChannelID				channel_id,
							CAppSap *);
					
	GCCError			RegistryAssignTokenRequest(
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistrySetParameterRequest (
							PGCCRegistryKey			registry_key,
							LPOSTR			        parameter_value,
							GCCModificationRights	modification_rights,
							CAppSap *);

	GCCError			RegistryRetrieveEntryRequest(
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistryDeleteEntryRequest(
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistryMonitorRequest(
							BOOL					enable_delivery,
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistryAllocateHandleRequest(
							UINT					number_of_handles,
							CAppSap *);
								
	/******************** Conductorship calls **************************/

	GCCError 			ConductorGiveResponse(GCCResult result);

#ifdef JASPER
	GCCError 			ConductorAssignRequest(void);
	GCCError 			ConductorReleaseRequest(void);
	GCCError 			ConductorPleaseRequest(void);
	GCCError 			ConductorGiveRequest(UserID recipient_node_id);
	GCCError 			ConductorPermitAskRequest(BOOL grant_permission);
    GCCError 			ConductorPermitGrantRequest(
							UINT					number_granted,
							PUserID					granted_node_list,
							UINT					number_waiting,
							PUserID					waiting_node_list);
#endif // JASPER

	GCCError 			ConductorInquireRequest(CBaseSap *);

	/********************************************************************/

	//	Miscelaneous calls
	GCCError		ConferenceTimeRemainingRequest (
							UINT			time_remaining,
							UserID			node_id);

    GCCError 		AppInvokeRequest(
						CInvokeSpecifierListContainer*,
                        GCCSimpleNodeList *,
              			CBaseSap *,
              			GCCRequestTag);

	GCCError		UpdateNodeVersionList(PGCCPDU	roster_update,
										  UserID	sender_id);

	DWORD_PTR	GetNodeVersion(UserID   nodeId) { return m_NodeVersionList2.Find(nodeId); }
						
    BOOL            HasNM2xNode(void);


#ifdef JASPER
	GCCError 		ConfTimeInquireRequest(BOOL time_is_conference_wide);
	GCCError		ConfExtendRequest (
							UINT			extension_time,
							BOOL		 	time_is_conference_wide);
	GCCError		ConfAssistanceRequest(
							UINT			number_of_user_data_members,
							PGCCUserData *	user_data_list);
	GCCError 		TextMessageRequest (
						LPWSTR				pwszTextMsg,
						UserID				destination_node );
	GCCError		ConfTransferRequest (
						PGCCConferenceName	destination_conference_name,
						GCCNumericString	destination_conference_modifier,
						CNetAddrListContainer *network_address_list,
						UINT				number_of_destination_nodes,
						PUserID				destination_node_list,
						CPassword           *password);
	GCCError		ConfAddRequest (	
						CNetAddrListContainer   *network_address_container,
						UserID				    adding_node,
						CUserDataListContainer  *user_data_container);
#endif // JASPER

	GCCError		ConfAddResponse (	
						GCCResponseTag		    add_response_tag,
						UserID				    requesting_node,
						CUserDataListContainer	*user_data_container,
						GCCResult			    result);


    void  WndMsgHandler(UINT);

	//	Routines called from the mcs interface
	void			ProcessConnectProviderConfirm(PConnectProviderConfirm connect_provider_confirm);

    // Callback from conf roster manager

    void ConfRosterReportIndication ( CConfRosterMsg * );

    void CancelInviteRequest(ConnectionHandle);

protected:

    //
    // Routines called from the user object via owner callbacks
    //

	void			ProcessConferenceCreateResponsePDU(
								PConferenceCreateResponse	create_response,
								PConnectProviderConfirm		connect_provider_confirm);

	void			ProcessConferenceJoinResponsePDU(
								PConferenceJoinResponse		join_response,
								PConnectProviderConfirm		connect_provider_confirm);

	void 			ProcessConferenceInviteResponsePDU(
								PConferenceInviteResponse	invite_response,
								PConnectProviderConfirm		connect_provider_confirm);

	void   			ProcessUserIDIndication(
								TagNumber			tag_number,
								UserID				user_id);

	void			ProcessUserCreateConfirm(
								UserResultType		result,
								UserID				user_id);

	void			ProcessRosterUpdatePDU(
								PGCCPDU				roster_update,
								UserID				sender_id);

	void			ProcessRosterRefreshPDU(
								PGCCPDU				roster_update,
								UserID				sender_id);

	GCCError		ProcessAppRosterIndicationPDU(	
								PGCCPDU					roster_update,
								UserID					sender_id);
						
	void			ProcessDetachUserIndication(
								UserID					detached_user,
								GCCReason				reason);

								
	void			ProcessTerminateRequest(
								UserID					requester_id,
								GCCReason				reason);

	void			ProcessTerminateIndication(GCCReason reason);
	void			ProcessEjectUserRequest(PUserEjectNodeRequestInfo eject_node_request);
	void			ProcessEjectUserIndication(GCCReason reason);
  	void			ProcessEjectUserResponse(PUserEjectNodeResponseInfo eject_node_response);
	void			ProcessConferenceLockRequest(UserID requester_id);
	void			ProcessConferenceUnlockRequest(UserID requester_id);
	void			ProcessConferenceLockIndication(UserID source_id);
	void			ProcessConferenceUnlockIndication(UserID source_id);

    void            ProcessConfJoinResponse(PUserJoinResponseInfo);
    void            ProcessAppInvokeIndication(CInvokeSpecifierListContainer *, UserID);
#ifdef JASPER
    void            ProcessConductorPermitAskIndication(PPermitAskIndicationInfo);
#endif // JASPER
    void            ProcessConfAddResponse(PAddResponseInfo);


	/***************** Conductorship calls ***********************/

	void			ProcessConductorGrabConfirm(GCCResult result);
	void			ProcessConductorAssignIndication(UserID uidNewConductor, UserID uidSender);
	void			ProcessConductorReleaseIndication(UserID uidSender);
	void			ProcessConductorGiveIndication(UserID uidGiver);
	void			ProcessConductorGiveConfirm(GCCResult);
	void			ProcessConductorPermitGrantInd(PUserPermissionGrantIndicationInfo, UserID uidSender);
	void			ProcessConductorTestConfirm(GCCResult);

    void			ProcessConferenceTransferRequest(
								UserID				requesting_node_id,
								PGCCConferenceName	destination_conference_name,
								GCCNumericString	destination_conference_modifier,
								CNetAddrListContainer *destination_address_list,
								UINT				number_of_destination_nodes,
 								PUserID				destination_node_list,
								CPassword           *password);
								
	void			ProcessConferenceTransferIndication(
								PGCCConferenceName	destination_conference_name,
								GCCNumericString	destination_conference_modifier,
								CNetAddrListContainer *destination_address_list,
								CPassword               *password);

	void			ProcessConferenceAddRequest(
								CNetAddrListContainer *network_address_list,
								CUserDataListContainer *user_data_list,
								UserID				adding_node,
								TagNumber			add_request_tag,
								UserID				requesting_node);

	void			InitiateTermination(GCCReason, UserID uidRequester);

    // look for this node ID in the roster's record set.
    BOOL            IsThisNodeParticipant(GCCNodeID);

private:

	/*************************************************************/

	CAppRosterMgr		*GetAppRosterManager(PGCCSessionKey session_key);
	TagNumber			GetNewUserIDTag(void);
	void				GetConferenceNameAndModifier(PGCCConferenceName, PGCCNumericString pszConfModifier);
	BOOL				DoesRequesterHavePrivilege(UserID uidRequester, ConferencePrivilegeType);
	GCCError			SendFullRosterRefresh(void);
	GCCError			UpdateNewConferenceNode(void);

	/*
	**	This group of routines operates on the enrolled APE list.
	*/
	GCCError			GetEntityIDFromAPEList(CAppSap *, PGCCSessionKey, GCCEntityID *);
	GCCError			GenerateEntityIDForAPEList(CAppSap *, PGCCSessionKey, GCCEntityID *);
	void				RemoveSAPFromAPEList(CAppSap *);
	ENROLLED_APE_INFO	*GetEnrolledAPEbySap(CAppSap *, GCCEntityID *);
	GCCError			FlushRosterData(void);
	GCCError			AsynchFlushRosterData(void);
	void				DeleteEnrolledAPE(GCCEntityID);
	BOOL				IsReadyToSendAppRosterUpdate(void);
	void				DeleteOutstandingInviteRequests(void);
    void                DeleteInviteRequest(INVITE_REQ_INFO *);

    BOOL	DoesSAPHaveEnrolledAPE(CAppSap *pAppSap)
	{
		return (BOOL) (UINT_PTR) GetEnrolledAPEbySap(pAppSap, NULL);
	}


	// Yikang:  This method checks whether the roster update PDU
	// contains the applet. The refreshonly argument indicates
	// whether or not to check the record updates.
	BOOL	DoesRosterPDUContainApplet(PGCCPDU  roster_update,
				const struct Key *obj_key, BOOL  refreshonly = TRUE);

    void    AddNodeVersion(UserID, NodeRecord*);


private:

	CAppRosterMgrList				    m_AppRosterMgrList;
	CAppSapList                         m_RegisteredAppSapList;
	CEnrolledApeEidList2			    m_EnrolledApeEidList2;

    CNetAddrListContainer               *m_pNetworkAddressList;
	CUserDataListContainer		        *m_pUserDataList;

	CConnHandleList     			    m_ConnHandleList;
	CConnHdlTagNumberList2				m_ConnHdlTagNumberList2;

    CJoinRespNamePresentConnHdlList2	m_JoinRespNamePresentConnHdlList2;
	CInviteRequestList				    m_InviteRequestList;
	CEjectedNodeConfirmList			    m_EjectedNodeConfirmList;
	CConductorTestList   	            m_ConductorTestList;
	CNetAddrTagNumberList2				m_AddRequestList;
	CTagNumberTagNumberList2			m_AddResponseList;
	CNodeVersionList2					m_NodeVersionList2;
	
	PMCSUser						m_pMcsUserObject;

	LPSTR							m_pszConfNumericName;
	LPWSTR							m_pwszConfTextName;
	LPWSTR							m_pwszConfDescription;
	LPSTR							m_pszConfModifier;
	LPSTR							m_pszRemoteModifier;

	GCCConfID   					m_nConfID;
	UserID							m_nConvenerNodeID;

	BOOL							m_fConfLocked;
	BOOL							m_fConfListed;
	BOOL							m_fConfConductible;
	BOOL							m_fClearPassword;
	BOOL							m_fConfIsEstablished;
	BOOL							m_fConfDisconnectPending;
	BOOL							m_fConfTerminatePending;
    BOOL                            m_fTerminationInitiated;
	BOOL							m_fSecure;

	BOOL							m_fWBEnrolled;
	BOOL							m_fFTEnrolled;
	BOOL							m_fChatEnrolled;

	GCCTerminationMethod			m_eTerminationMethod;
	GCCReason						m_eConfTerminateReason;

	PDomainParameters 				m_pDomainParameters;

	ConferenceNodeType				m_eNodeType;

	UserIDTagNumber					m_nUserIDTagNumber;
	UserIDTagNumber					m_nConvenerUserIDTagNumber;
	TagNumber						m_nParentIDTagNumber;
	TagNumber						m_nConfAddRequestTagNumber;

    ConnectionHandle				m_hParentConnection;
	ConnectionHandle				m_hConvenerConnection;

	PAlarm							m_pConfTerminateAlarm;
	PAlarm							m_pConfStartupAlarm;

	PPrivilegeListData				    m_pConductorPrivilegeList;
	PPrivilegeListData				    m_pConductModePrivilegeList;
	PPrivilegeListData				    m_pNonConductModePrivilegeList;

    GCCResponseTag					m_nConfAddResponseTag;
	CConfRosterMgr					*m_pConfRosterMgr;
	CRegistry                       *m_pAppRegistry;
	UserID							m_nConductorNodeID;
	UserID							m_nPendingConductorNodeID;
	BOOL							m_fConductorGrantedPermission;
	BOOL							m_fConductorGiveResponsePending;
	BOOL							m_fConductorAssignRequestPending;
	EntityID						m_nAPEEntityID;
    //
    // LONCHANC; m_cPermittedEnrollment is the number of
	// GCC-Application-Permit-to-Enroll. we need to wait for all
	// the corresponding GCC-Application-Enroll-Request come in.
	// then, we will send out a single
	// GCC-Application-Roster-Update-Indication to the wire.
    //
    int								m_cEnrollRequests; // LONCHANC: must be signed
	BOOL							m_fFirstAppRosterSent;
};
typedef	CConf 		*			PConference;

#endif

/*
 *	CConf(		PGCCConferenceName			conference_name,
 *					GCCNumericString			conference_modifier,
 *					GCCConfID   				conference_id,
 *					BOOL						use_password_in_the_clear,
 *					BOOL						conference_locked,
 *					BOOL						conference_listed,
 *					BOOL						conference_conductable,
 *					GCCTerminationMethod		termination_method,
 *					PGCCConferencePrivileges	conduct_privilege_list,
 *					PGCCConferencePrivileges	conduct_mode_privilege_list,
 *					PGCCConferencePrivileges	non_conduct_privilege_list,
 *					LPWSTR						pwszConfDescriptor,
 *					UINT						number_of_network_addresses,
 *					PGCCNetworkAddress 		*	local_network_address_list,
 *					CControlSAP					*control_sap,
 *					UINT						owner_message_base,
 *					PGCCError					return_value);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used when the
 *		CConf specification parameters such as termination	
 *		method or known in advance of conference creation.  This is
 *		the case for a convenor node and a top provider.  It is not
 *		used for joining nodes.
 *
 *	Formal Parameters:
 *		conference_name		(i)	Structure pointer that holds the confernce name.
 *		conference_modifier	(i)	Pointer to the conference modifier.
 *		conference_id		(i)	The assigned conference ID.
 *		use_password_in_the_clear	
 *							(i)	Flag specifying if the password is in the clear.
 *		conference_locked	(i)	Flag specifying if the conference is locked.
 *		conference_listed	(i)	Flag specifying if the conference is listed.
 *		conference_conductable
 *							(i)	Flag specifying if conference is conductable.
 *		termination_method	(i)	Flag specifying the termination method.
 *		conduct_privilege_list
 *							(i)	Privilege list used by the conductor.
 *		conduct_mode_privilege_list
 *							(i)	Privilege list used in conducted mode.
 *		non_conduct_privilege_list
 *							(i) Privilege list used when not in conducted mode.
 *		conference_descriptor
 *							(i)	Pointer to the conference descriptor.
 *		number_of_network_addresses
 *							(i)	Number of network addresses in list.
 *		local_network_address_list
 *							(i) List of local network addresses.
 *		mcs_interface		(i)	Pointer to the MCS interface object.
 *		control_sap			(i) Pointer to the Node Controller SAP.
 *		owner_object		(i)	Pointer to the object that created this object.
 *		owner_message_base	(i) The number added to all owner callback messages.
 *		packet_coder		(i)	Pointer to the Packet Coder object used for PDUs
 *		return_value		(o)	Errors that occur are returned here.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	Resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CConf(		PGCCConferenceName	  		conference_name,
 *					GCCNumericString			conference_modifier,
 *					GCCConfID   				conference_id,
 *					UINT						number_of_network_addresses,
 *					PGCCNetworkAddress 	*		local_network_address_list,
 *					CControlSAP					*control_sap,
 *					UINT								owner_message_base,
 *					PGCCError					return_value);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used by nodes that
 *		do not know the CConf specification parameters such as
 *		termination	method in advance of conference creation.  This is
 *		the case for joining nodes.
 *
 *	Formal Parameters:
 *		conference_name		(i)	Structure pointer that holds the confernce name.
 *		conference_modifier	(i)	Pointer to the conference modifier.
 *		conference_id		(i)	The assigned conference ID.
 *		number_of_network_addresses
 *							(i)	Number of local network addresses in list.
 *		local_network_address_list
 *							(i) List of local network addresses.
 *		control_sap			(i) Pointer to the Node Controller SAP.
 *		packet_coder		(i)	Pointer to the Packet Coder object used for PDUs
 *		return_value		(o)	Errors that occur are returned here.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	Resource error occured.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfCreateRequest(
 *							TransportAddress		calling_address,
 *							TransportAddress		called_addrescs,
 *							CPassword               *convener_password,
 *							CPassword               *password,
 *							LPWSTR					pwszCallerID,
 *							PDomainParameters		domain_parameters,
 *							CUserDataListContainer  *user_data_list,
 *							PConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Create Request PDU is to be
 *		issued.  Note that a local conference can be created by setting the
 *		called address to NULL.
 *
 *	Formal Parameters:
 *		calling_address		(i)	Address of the calling node.
 *		called_address		(i)	Address of the called node. Null for local conf.
 *		convener_password	(i)	Password used by convener to get back priviliges
 *		password			(i)	Password needed to join the conference.
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *		connection_handle	(o)	The logical connection handle is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		Passing in NULL for the called address will create a local conference.
 */

/*
 *	GCCError	ConfCreateResponse(
 *							ConnectionHandle		connection_handle,
 *							PDomainParameters		domain_parameters,
 *							CUserDataListContainer  *user_data_list)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Create Response PDU is to be
 *		issued.  It should only be issued in response to a
 *		ConferenceCreateRequest. The connection handle is used to match the
 *		request with the response.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Connection handled specified in the request.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 * 	GCCError	ConfJoinRequest(
 *							GCCNumericString		called_node_modifier,
 *							CPassword               *convener_password,
 *							CPassword               *password_challenge,
 *							LPWSTR					pwszCallerID,
 *							TransportAddress		calling_address,
 *							TransportAddress		called_address,
 *							PDomainParameters 		domain_parameters,
 *							CUserDataListContainer  *user_data_list,
 *							PConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Join Request PDU is to be
 *		issued.  The second constructor defined above should have been
 *		used to create the conference object before the routine is called.
 *
 *	Formal Parameters:
 *		called_node_modifier(i)	The conference modifier at the node being joined
 *		convener_password	(i)	Password used by convener to get back priviliges
 *		password_challenge	(i) Password used to join a conference.
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		calling_address		(i)	Address of the calling node.
 *		called_address		(i)	Address of the called node.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *		connection_handle	(o)	The logical connection handle is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ForwardConfJoinRequest (
 *							CPassword               *convener_password,
 *							CPassword               *password_challange,
 *							LPWSTR					pwszCallerID,
 *							CUserDataListContainer  *user_data_list,
 *							BOOL					numeric_name_present,
 *							ConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Join Request is to be
 *		forwarded to the Top Provider.  This call will be made after an
 *		intermediate node calls Join Response with a successful result
 *		value.
 *
 *	Formal Parameters:
 *		convener_password	(i)	Password used by convener to get back priviliges
 *		password_challenge	(i) Password used to join a conference.
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		user_data_list		(i) Pointer to a User data list object.
 *		numeric_name_present(i) This flag states that the numeric portion of
 *								the conference name was specified in the
 *								request.  Therefore, the text name is returned
 *								in the response.
 *		connection_handle	(i)	The logical connection handle defined by the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_CONFERENCE			- Returned if this node is the Top
 *										  Provider
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfJoinIndResponse(
 *							ConnectionHandle		connection_handle,
 *							CPassword               *password_challenge,
 *							CUserDataListContainer  *user_data_list,
 *							BOOL					numeric_name_present,
 *							BOOL					convener_is_joining,
 *							GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Join Response PDU is to be
 *		issued.  It is called in response to a ConferenceJoinRequest being
 *		received.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Connection handled specified in the request.
 *		password_challenge	(i) Password used when joining a conference.
 *		user_data_list		(i) Pointer to a User data list object.
 *		numeric_name_present(i) This flag states that the numeric portion of
 *								the conference name was specified in the
 *								request.  Therefore, the text name is returned
 *								in the response.
 *		convener_is_joining	(i)	Flag stating that the convener is rejoining
 *								the conference.
 *		result				(i)	Result code to be returned in the response.
 *
 *	Return Value
 *		GCC_NO_ERROR:						- No error
 *		GCC_ALLOCATION_FAILURE				- Resource error occured
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		If the GCC_DOMAIN_PARAMETERS_UNACCEPTABLE error is returned from this
 *		routine, MCS will automatically reject the connection sending a
 *		result to the other side stating the the Domain Parameters were
 *		unacceptable.
 */

/*
 *	GCCError	ConfInviteResponse(
 *							UserID					parent_user_id,
 *							UserID					top_user_id,
 *							TagNumber				tag_number,
 *							ConnectionHandle		connection_handle,
 *							PDomainParameters		domain_parameters,
 *							CUserDataListContainer  *user_data_list)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Invite Response PDU is to be
 *		issued.  It is called in response to an Invite request.
 *
 *	Formal Parameters:
 *		parent_user_id		(i)	The MCS user ID of the parent node.
 *		top_user_id			(i) The MCS user ID of the Top Provider.
 *		tag_number			(i) Tag the matches the request with the response.
 *		connection_handle	(i)	Connection handled specified in the request.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *
 *	Return Value
 *		GCC_NO_ERROR:						- No error
 *		GCC_ALLOCATION_FAILURE				- Resource error occured
 *		GCC_FAILURE_ATTACHING_TO_MCS		- Failure creating MCS user
 *											  attachment
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CConf::RegisterAppSap(CAppSap *pAppSap)
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes a candidate for Enrollment.  This will happen whenever
 *		Applications SAPs exists at the same time a conference becomes
 *		established.  It will also be called whenever a conference exists
 *		and a new application SAP is created.
 *
 *	Formal Parameters:
 *		pAppSap		(i)	Pointer to the application SAP object associated
 *								with the registering Application.
 *		hSap
 *							(i) SAP handle of the registering Application.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CConf::UnRegisterAppSap(CAppSap *pAppSap)
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes unavailable due to whatever reason.  This routine is
 *		responsible for unenrolling any APEs from any rosters that it might have
 *		used this SAP to enroll with.
 *
 *	Formal Parameters:
 *		application_sap_handle
 *							(i) SAP handle of the unregistering Application.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_APPLICATION_NOT_REGISTERED	- The application was not registered.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	DisconnectProviderIndication(
 *							ConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called whenever a disconnect indication is received
 *		by GCC.  It is used to inform the conference of any logical connections
 *		it that might have gone down.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Logical connection handle that was disconnected
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_PARAMETER			- This connection handle is not used
 *										  by this conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	DisconnectProviderIndication(
 *							ConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called whenever a disconnect indication is received
 *		by GCC.  It is used to inform the conference of any logical connections
 *		it that might have gone down.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Logical connection handle that was disconnected
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_PARAMETER			- This connection handle is not used
 *										  by this conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfRosterInquireRequest(CBaseSap *)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is used to obtain a conference roster.  The conference
 *		roster is delivered to the requesting command target in a Conference
 *		Roster inquire confirm.
 *
 *	Formal Parameters:
 *		command_target	(i)	Pointer to object that made the request.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AppRosterInquireRequest(GCCSessionKey *, CAppRosterMsg **)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is used to obtain a list of application rosters.  This
 *		list is delivered to the requesting SAP through an	Application Roster
 *		inquire confirm message.
 *
 *	Formal Parameters:
 *		session_key		(i)	Session Key of desired roster.  If NULL is
 *							specified then all the available application rosters
 *							are delivered in the confirm.
 *		command_target	(i)	Pointer to object that made the request.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL		FlushOutgoingPDU ();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is used by the owner object to flush any PDUs queued
 *		by the conference object.  This routine will all flush PDUs queued
 *		by the User Attachment object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the conference message queue
 *		FALSE, if all the msgs in the conference msg queue were processed.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfEstablished();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		Function informs whether the conference has completed its
 *		establishment process.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	Establishment is complete.
 *		FALSE	-	Establishment is still in process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL		IsConfTopProvider();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		Function informs whether this node is the Top Provider of the
 *		conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	This node is the Top Provider.
 *		FALSE	-	This node is NOT the Top Provider.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL		DoesConvenerExists();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or not the convener is still joined to
 *		this conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	There is a convener node joined to the conference.
 *		FALSE	-	There is NOT a convener node joined to the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPSTR	GetNumericConfName();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to a LPSTR string
 *		that holds the numeric conference name.  This string should not be
 *		altered by the requesting module.  It should also not be used after
 *		the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the numeric string portion of the Conference Name.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPWSTR	GetTextConfName();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the unicode string
 *		that holds the text portion of the conference name.  This string should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the text string portion of the Conference Name.
 *		NULL if no text conference name exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPSTR	GetConfModifier();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the LPSTR string
 *		that holds the conference name modifier.  This string should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the Conference Name modifier.
 *		NULL if no modifier exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPWSTR	GetConfDescription()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the unicode string
 *		that holds the conference descriptor.  This string should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the Conference Descriptor.
 *		NULL if no descriptor exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CNetAddrListContainer *GetNetworkAddressList()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the object that holds the
 *		list of local network addresses.  This object should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the Local network address list.
 *		NULL if no descriptor exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCConfID		GetConfID()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns the conference ID for this conference object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The conference ID
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfListed();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or NOT the conference is listed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	The conference is listed
 *		FALSE	-	This conference is NOT listed
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfPasswordInTheClear();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or NOT the conference is using an
 *		in the clear password.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	The conference is using a Password in the clear
 *		FALSE	-	The conference is NOT using a Password in the clear
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfLocked();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or NOT the conference is locked.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	The conference is locked.
 *		FALSE	-	The conference is NOT locked.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */


/*
 *	These routines live in conf2.cpp
 */

/*
 *		GCCError		ConfJoinReqResponse(
 *									UserID				receiver_id,
 *									CPassword           *password_challenge,
 *									CUserDataListContainer *user_data_list,
 *									GCCResult			result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used when the join request was delivered
 *		through an intermediate node.  In this case, the join response is sent
 *		back through the intermediate node.
 *
 *	Formal Parameters:
 *		receiver_id		- (i)	The user ID of the intermediate node that
 *								forwarded the join request.  This user ID is
 *								used to match the join request with the join
 *								response.
 *		password_challenge
 *						- (i)	The password challenge to be delivered to the
 *								joining node.  NULL if none should be delivered.
 *		user_data_list	- (i)	Pointer to a user data object to be delivered
 *								to joiner.  NULL if none should be delivered.
 *		result			- (i)	Result of the join request.
 *
 *	Return Value
 *		GCC_NO_ERROR		-	No error.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfInviteRequest(
 *								LPWSTR					pwszCallerID,
 *								TransportAddress		calling_address,
 *								TransportAddress		called_address,
 *								CUserDataListContainer  *user_data_list,
 *								PConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue an invite request.  This
 *		can be a command target because the conference at the requesting node
 *		should already be established before the request comes in.
 *
 *	Formal Parameters:
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		calling_address		(i)	Address of the calling node.
 *		called_address		(i)	Address of the called node.
 *		user_data_list		(i) Pointer to a User data list object.
 *		connection_handle	(o)	The logical connection handle is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfLockRequest ()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue a lock request to
 *		the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfLockResponse (
 *								UserID					requesting_node,
 *								GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue a lock response.  It
 *		is called in response to a lock request.
 *
 *	Formal Parameters:
 *		requesting_node		-	(i)	Node ID of node the issued the lock request.
 *		result				-	(i)	Result of lock request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfUnlockRequest ()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue an unlock request to
 *		the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfUnlockResponse (
 *								UserID					requesting_node,
 *								GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue an unlock response.  It
 *		is called in response to an unlock request.
 *
 *	Formal Parameters:
 *		requesting_node		-	(i)	ID of node the issued the unlock request.
 *		result				-	(i)	Result of unlock request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	ConfEjectUserRequest (
 *									UserID					ejected_node_id,
 *									GCCReason				reason)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to eject a user from the
 *		conference.  Note that the user must have the appropriate priviliges
 *		to perform the eject.
 *
 *	Formal Parameters:
 *		ejected_node_id		-	(i)	ID of node to be ejected.
 *		reason				-	(i)	Reason for ejection
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfAnnouncePresenceRequest(
 *									PGCCNodeRecord		node_record)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the Node Controller
 *		announces its presence with the conference.  This request will
 *		generate a roster report PDU and indication.
 *
 *	Formal Parameters:
 *		node_record		-	(i)	Structure containing the complete node
 *								record for the requesting node controller.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_NETWORK_ADDRESS			- If an invalid network address is
 *										  passed in as part of the record.	
 *		GCC_BAD_USER_DATA				- If an invalid user data list is
 *										  passed in as part of the record.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfDisconnectRequest(void)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the Node Controller
 *		wishes to disconnect the node from the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		If this node is the Top Provider the conference will be terminated
 *		on all nodes.
 */

/*
 *	GCCError		ConfTerminateRequest(
 *									GCCReason			reason)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the Node Controller
 *		wishes to terminate the conference.  This will eventually cause
 *		the object to be deleted if successful.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AppEnrollRequest(
 *							CAppSap     *			pAppSap,
 *							PGCCSessionKey			session_key,
 *							PGCCApplicationRecord	application_record,
 *							BOOL					application_enrolled,
 *							UINT					number_of_capabilities,
 *							PGCCApplicationCapability	FAR *
 *													capabilities_list)
 *
 *	Public Function Description
 *		This function is called when a User Application wishes to enroll with
 *		the conference (or wishes to UnEnroll with it).  This call will
 *		initiate a roster update if the conference is established.
 *
 *	Formal Parameters:
 *		application_sap_handle
 *							(i) SAP handle of the enrolling Application.  Used
 *								for the entity ID.
 *		session_key			(i) Session key of the enrolling application
 *		application_record	(i)	Structure that defines the Application
 *								attributes.
 *		application_enrolled
 *							(i)	Is the application enrolling or unenrolling?
 *		number_of_capabilities
 *							(i) Number of Application capabilities in list.
 *		capabilities_list	(i)	Actual list of capabilities.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryRegisterChannelRequest(
 *									PGCCRegistryKey			registry_key,
 *									ChannelID				channel_id,
 *									CAppSap                  *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		register a channel with the conference.	Here the application must
 *		supply the channel.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		channel_id		-	(i)	Channel ID to be registered.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryAssignTokenRequest(
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		register a token with the conference.  Here the token is supplied by
 *		the conference.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		RegistrySetParameterRequest (
 *								PGCCRegistryKey			registry_key,
 *								LPOSTR                  parameter_value,
 *								GCCModificationRights	modification_rights,
 *								CAppSap		            *app_sap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		register a parameter with the conference.  Here the token is supplied by
 *		the conference.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		parameter_value	-	(i)	Parameter to be registered
 *		modification_rights-(i)	Modification rights on the parameter.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryRetrieveEntryRequest(
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		retrieve a registry entry.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryDeleteEntryRequest(
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		delete a registry entry.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryMonitorRequest(
 *									BOOL					enable_delivery,
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		delete a registry entry.
 *
 *	Formal Parameters:
 *		enable_delivery -	(i)	Toggle used to turn on and off monitoring of
 *								an entry.
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryAllocateHandleRequest(
 *									UINT					number_of_handles,
 *									CAppSap		            *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application that needs
 *		to allocate a certain number of parameters.
 *
 *	Formal Parameters:
 *		number_of_handles -	(i) Number of handles to allocate.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 			ConductorAssignRequest();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to become
 *		the conductor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	ConductorReleaseRequest()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to give up
 *		conductorship.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	ConductorPleaseRequest()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to request
 *		the conductorship token from another node.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConductorGiveRequest(
 *								UserID					recipient_node_id)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to give
 *		the conductorship token to another node.  Usually called in response
 *		to a please request.
 *
 *	Formal Parameters:
 *		recipient_node_id	-	(i)	User ID of node to give conductorship to.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConductorGiveResponse(
 *									GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called after a node has received a
 *		give indication.  This response informs the conference of whether or
 *		not this node is accepting the conductorship token.
 *
 *	Formal Parameters:
 *		result		-	(i)	If the node is accepting conductorship the result
 *							will be set to GCC_RESULT_SUCCESSFUL.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_NO_GIVE_RESPONSE_PENDING	- A give indication was never issued.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConductorPermitAskRequest(
 *							BOOL					grant_permission)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants permission
 *		from the conductor.  The definition of permission may vary from
 *		application to application.
 *
 *	Formal Parameters:
 *		grant_permission -	(i)	Flag stating whether permission is being
 *								requested or given up.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 				ConductorPermitGrantRequest(
 *									UINT					number_granted,
 *									PUserID					granted_node_list,
 *									UINT					number_waiting,
 *									PUserID					waiting_node_list);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by the conductor when
 *		permission is being granted to a node or list of nodes.
 *
 *	Formal Parameters:
 *		number_granted 		-	(i)	The number of nodes granted permission.
 *		granted_node_list 	-	(i)	List of nodes granted permission.
 *		number_waiting		-	(i)	The number of nodes waiting for permission.
 *		waiting_node_list 	-	(i)	List of nodes waiting for permission.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *		GCCError ConductorInquireRequest(CBaseSap *pSap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when conductorship information
 *		is required by a SAP.
 *
 *	Formal Parameters:
 *		pSap 	-	(i)	SAP making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTimeRemainingRequest (
 *									UINT			time_remaining,
 *									UserID			node_id)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called to inform all the nodes in
 *		the conference how much time is left in the conference.
 *
 *	Formal Parameters:
 *		time_remaining 	-	(i)	Time in miliseconds left in the conference.
 *		node_id		 	-	(i)	node_id of node to deliver time remaining
 *								indication. NULL if it should go to all nodes.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConfTimeInquireRequest (
 *									BOOL			time_is_conference_wide)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by a node that wants to
 *		know how much time is remaining in a timed conference.
 *
 *	Formal Parameters:
 *		time_is_conference_wide	-	(i)	TRUE if time is for entire conference.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfExtendRequest (
 *									UINT			extension_time,
 *									BOOL		 	time_is_conference_wide)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the time left in the
 *		conference is to be extended.
 *
 *	Formal Parameters:
 *		extension_time			-	(i)	Extension time.
 *		time_is_conference_wide	-	(i)	TRUE if time is for entire conference.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfAssistanceRequest(
 *									UINT			number_of_user_data_members,
 *									PGCCUserData *	user_data_list)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to request
 *		assistance.
 *
 *	Formal Parameters:
 *		number_of_user_data_members	-	(i)	number of user data members in list.
 *		user_data_list				-	(i)	list of user data members.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AppInvokeRequest(
 *							CInvokeSpecifierListContainer	*invoke_list,
 *							UINT			number_of_destination_nodes,
 *							UserID			*list_of_destination_nodes,
 *                 			CBaseSap        *pSap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to invoke
 *		a list of applications on remote node or nodes.
 *
 *	Formal Parameters:
 *		invoke_list					-	(i)	list of applications to invoke.
 *		number_of_destination_nodes	-	(i)	number of nodes in destination list
 *		list_of_destination_nodes	-	(i)	list of destination user IDs
 *		command_target				-	(i)	Command Target that made the request
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	TextMessageRequest (
 *							LPWSTR				pwszTextMsg,
 *							UserID				destination_node )
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to deliver
 *		a text message to a remote node.
 *
 *	Formal Parameters:
 *		pwszTextMsg				-	(i)	the actual text message in unicode.
 *		destination_node		-	(i)	Node ID of node receiving message
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfTransferRequest (
 *							PGCCConferenceName	destination_conference_name,
 *							GCCNumericString	destination_conference_modifier,
 *							CNetAddrListContainer *network_address_list,
 *							UINT				number_of_destination_nodes,
 *	 						PUserID				destination_node_list,
 *							CPassword           *password)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes transfer a
 *		list of nodes to another conference.
 *
 *	Formal Parameters:
 *		destination_conference_name	-	(i)	Name of conference to transfer to.
 *		destination_conference_modifier-(i)	Name of modifier to transfer to.
 *		network_address_list		-	(i)	Address list of new conference.
 *		number_of_destination_nodes	-	(i)	Number of nodes to transfer
 *		destination_node_list		-	(i)	List of nodes to transfer.
 *		password					-	(i)	Password needed to join new conf.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfAddRequest (	
 *							CNetAddrListContainer *network_address_container,
 *							UserID				adding_node,
 *							CUserDataListContainer *user_data_container)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes add a new
 *		node to the conference.
 *
 *	Formal Parameters:
 *		network_address_container	-	(i)	Address of node to add.
 *		adding_node					-	(i)	Node to perform the invite. If
 *											zero then Top Provider does the
 *											invite.
 *		user_data_container			-	(i)	Container holding user data to be
 *											passed in the add request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfAddResponse (	
 *							GCCResponseTag		add_response_tag,
 *							UserID				requesting_node,
 *							CUserDataListContainer *user_data_container,
 *							GCCResult			result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to respond
 *		to an add request.  This response should be done after the invite
 *		sequence is complete (unless result is not successful).
 *
 *	Formal Parameters:
 *		add_response_tag		-	(i)	Tag used to match request with response.
 *		requesting_node			-	(i)	Node that made the original add request.
 *		user_data_container		-	(i)	Container holding user data to be
 *										passed in the add response.
 *		result					-	(i)	The result of the Add request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *		GCC_INVALID_ADD_RESPONSE_TAG	- There was no match of the response tag
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\cntlist.h ===
#ifndef _CONTAINED_LIST_H_
#define _CONTAINED_LIST_H_


#define CLIST_DEFAULT_MAX_ITEMS   4
#define CLIST_END_OF_ARRAY_MARK   ((UINT) -1)


class CList
{
public:

    CList(void);
    CList(ULONG cMaxItems);
    CList(ULONG cMaxItems, ULONG cSubItems);
    CList(ULONG cMaxItems, ULONG cSubItems, BOOL fQueue);

    CList(CList *pSrc);

    ~CList(void);

    BOOL Append(LPVOID pData);
    BOO