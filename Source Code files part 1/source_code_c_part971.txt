5a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};


DWORD UpdateCRC32(
    LPBYTE  pSrc,               // Points to buffer
    int     nBytes,             // Number of bytes to compute
    DWORD   dwOldCrc            // Must be 0xFFFFFFFF if no previous CRC
    )
{
    if(nBytes == 0)
        return dwOldCrc;

    DWORD dwNewCrc = 0;

    for (int n = 0; n < nBytes; n++)
    {
        dwNewCrc = CrcTable[ BYTE(dwOldCrc ^ DWORD(pSrc[n]))] 
            ^ ((dwOldCrc >> 8) & 0x00FFFFFF);
        dwOldCrc = dwNewCrc;            
    }
    
    return dwNewCrc;
}
    

/*
void main(int argc, char **argv)
{
    if (argc < 2)
    {
        return;
    }

    FILE *f = fopen(argv[1], "rb");
    
    DWORD dwCrc = STARTING_CRC32_VALUE;
    
    int nBytes = 0;

    while (1)
    {
        BYTE Buf[256];
        
        int nRes = fread(Buf, 1, 256, f);

        nBytes += nRes;

        if (nRes == 0)
            break;
            
        if (nRes != 0)
        {
            dwCrc = UpdateCRC32(Buf, nRes, dwCrc);
        }
    }        

    FINALIZE_CRC32(dwCrc);
    
    fclose(f);

    printf("Bytes = %d\n", nBytes);
        
    printf("CRC32 is 0x%X\n", dwCrc);
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wdmshell.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "wmicom.h"
#include "wdmshell.h"
#include "wmimof.h"
#include "wmimap.h"
#include <stdlib.h>
#include <winerror.h>

//=============================================================================================================
//*************************************************************************************************************
//
//  Determine if a hi perf class or not
//
//*************************************************************************************************************
//=============================================================================================================
BOOL CWMIClassType::IsHiPerfClass(WCHAR * wcsClass, IWbemServices * pServices)
{
    BOOL fRc = FALSE;
    IWbemClassObject * p = NULL;
	CBSTR cbsClass(wcsClass);
    HRESULT hr = pServices->GetObject(cbsClass,0,NULL,&p, NULL);
    if( SUCCEEDED(hr))
    {
        IWbemQualifierSet * pIWbemQualifierSet = NULL;
        hr = p->GetQualifierSet(&pIWbemQualifierSet);
        if( SUCCEEDED(hr))
        {
            long lType = 0L;
            CVARIANT vQual;
		
	    	hr = pIWbemQualifierSet->Get(L"HiPerf", 0, &vQual,&lType);
            if( SUCCEEDED(hr))
            {
                fRc = vQual.GetBool();
            }
        }
        SAFE_RELEASE_PTR(pIWbemQualifierSet);
    }
    SAFE_RELEASE_PTR(p);
    return fRc;
}
//=============================================================================================================
//*************************************************************************************************************
//
//
//  CWMIStandardShell
//
//
//*************************************************************************************************************
//=============================================================================================================
CWMIStandardShell::CWMIStandardShell() 
{
	m_pClass = NULL;
	m_pWDM = NULL;
	m_fInit = FALSE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWMIStandardShell::~CWMIStandardShell()
{
	SAFE_DELETE_PTR(m_pWDM);
	SAFE_DELETE_PTR(m_pClass);
	m_fInit = FALSE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::Initialize(WCHAR * wcsClass, BOOL fInternalEvent, CHandleMap * pList,
									  BOOL fUpdate, ULONG uDesiredAccess, 
									  IWbemServices   __RPC_FAR * pServices, 
                                      IWbemObjectSink __RPC_FAR * pHandler, 
									  IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_E_FAILED;

	if( !m_fInit )
	{
		m_pClass = new CWMIProcessClass(0);
		if( m_pClass )
		{
			hr = m_pClass->Initialize();
			if( S_OK == hr )
			{
				m_pClass->WMI()->SetWMIPointers(pList,pServices,pHandler,pCtx);
				m_pClass->SetHiPerf(FALSE);
				if( !fInternalEvent )
				{
					if( wcsClass )
					{
						hr = m_pClass->SetClass(wcsClass);
						if( SUCCEEDED(hr))
						{
							if( !m_pClass->ValidClass())
							{
								hr = WBEM_E_INVALID_OBJECT;
							}
						}
					}
				}
				else
				{
					if( wcsClass )
					{
						hr = m_pClass->SetClassName(wcsClass);
					}
				}

				if( hr == S_OK )
				{
					m_pWDM = new CProcessStandardDataBlock();
					if( m_pWDM )
					{
						m_pWDM->SetDesiredAccess(uDesiredAccess);
						m_pWDM->SetClassProcessPtr(m_pClass);
						m_pWDM->UpdateNamespace(fUpdate);

						m_fInit = TRUE;
					}
				}
			}
		}
	}
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::SetGuidForEvent( WORD wType, WCHAR * wcsGuid)
{
   HRESULT hRes = WBEM_E_FAILED;
   if( m_fInit )
   {
   
		// ==============================================
		// Inform the WMI we want to register for the
		// event
		// ==============================================
		memset(wcsGuid,NULL,GUID_SIZE);

		switch( wType ){
			case MOF_ADDED:
				hRes = S_OK;
				m_pClass->SetHardCodedGuidType(wType);
				wcscpy( wcsGuid,WMI_RESOURCE_MOF_ADDED_GUID);
				break;

			case MOF_DELETED:
				hRes = S_OK;
				m_pClass->SetHardCodedGuidType(wType);
				wcscpy( wcsGuid,WMI_RESOURCE_MOF_REMOVED_GUID);
				break;

			case STANDARD_EVENT:
				hRes = m_pClass->GetQualifierString( NULL, L"guid", wcsGuid,GUID_SIZE);
				break;
		}
   }
    return hRes;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ProcessSingleInstance( WCHAR * wcsInstanceName/*, PWNODE_SINGLE_INSTANCE pwSingle */)
{
   HRESULT hr = WBEM_E_FAILED;
   if( m_fInit )
   {

		//======================================================
		//  If we are not working with a specific guy, then
		//  query WMI to get it, if, of course it is valid
		//======================================================
		if( m_pClass->ValidClass() ){

	/*        if( pwSingle){
				hr = m_pWDM->SetSingleInstancePtr((PWNODE_SINGLE_INSTANCE)pwSingle);
			}
			else{*/
				hr = m_pWDM->OpenWMI();
				if( hr == S_OK ){
    				hr = m_pWDM->QuerySingleInstance(wcsInstanceName);
				}
	//        }
			//======================================================
			//  If we got the data and a valid class, the process it
			//======================================================
   			if( hr == S_OK )
			{
				hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
				if( SUCCEEDED(hr))
				{
					hr = m_pClass->SendInstanceBack();
				}
			}
		}
   }
   return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ProcessAllInstances( )
{
    HRESULT hr = WBEM_E_FAILED;
    if( m_fInit )
    {

		//======================================================
		//  If we are not working with a specific guy, then
		//  query WMI to get it
		//======================================================
	 //   if( pwAllNode ){
	  //      hr = m_pWDM->SetAllInstancePtr((PWNODE_ALL_DATA)pwAllNode);
	  //  }
	   // else{
			hr = m_pWDM->OpenWMI();
			if( hr == S_OK ){
    			hr = m_pWDM->QueryAllData();
			}
	   // }
		//======================================================
		//  If we got the data then process it
		//======================================================
		if( hr == S_OK ){
			while( TRUE ){
				hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
				if( hr == S_OK ){
					hr = m_pClass->SendInstanceBack();
				}
				if( hr != S_OK ){
					break;
				}
				if( !m_pWDM->MoreToProcess() ){
					break;
				}
			}
		}
	}
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ExecuteMethod( WCHAR * wcsInstance,  WCHAR * MethodName,  IWbemClassObject * pParentClass, 
  							      IWbemClassObject * pInClassData, 
							      IWbemClassObject * pInClass, 
							      IWbemClassObject * pOutClass) 
{
	HRESULT hr = WBEM_E_FAILED;
    if( m_fInit )
    {
		CWMIProcessClass  MethodInput(0);
		CWMIProcessClass  MethodOutput(0);

		if( SUCCEEDED( MethodInput.Initialize() ) && SUCCEEDED( MethodOutput.Initialize() ) )
		{
			MethodInput.SetWMIPointers(m_pClass);
			MethodOutput.SetWMIPointers(m_pClass);


			//======================================================
			//  Initialize all of the necessary stuff and get the
			//  definition of the class we are working with
			//======================================================
			if( pInClass )
			{
				hr = MethodInput.SetClass(pInClass);
				if( hr != S_OK ){
					return hr;
				}
				pInClass->AddRef();
				MethodInput.SetClassPointerOnly(pInClassData);
			}

			if( pOutClass ){
  				hr = MethodOutput.SetClass(pOutClass);
				if( hr != S_OK ){
					return hr;
				}
				pOutClass->AddRef();
			}

		   //======================================================
			//  Notify WMI which class we are going to be executing
			//  methods on
			//======================================================
			hr = m_pWDM->OpenWMI();
			if( hr == S_OK ){

				m_pWDM->SetMethodInput(&MethodInput);
				m_pWDM->SetMethodOutput(&MethodOutput);

				m_pClass->SetClassPointerOnly(pParentClass);

				// Create in Param Block
				// ========================
				BYTE * InputBuffer=NULL;
				ULONG uInputBufferSize=0L;

				hr = m_pWDM->CreateInParameterBlockForMethods(InputBuffer,uInputBufferSize);
				if( hr == S_OK ){
				
					// Allocate Out Param Block
					// ========================
    
					ULONG WMIMethodId = m_pClass->GetMethodId(MethodName);

					//======================================================
					//  If we got the data then process it
					//======================================================
    
					hr = m_pWDM->CreateOutParameterBlockForMethods();
					if( hr == S_OK ){
						hr = m_pWDM->ExecuteMethod( WMIMethodId,wcsInstance, uInputBufferSize,InputBuffer);
					}
				}

				SAFE_DELETE_ARRAY(InputBuffer);
			}
		}
	}
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ProcessEvent( WORD wBinaryMofType, PWNODE_HEADER WnodeHeader)
{

   HRESULT hr = S_OK;
   if( m_fInit )
   {

		//===================================================
		//  If the image path is empty, it is a binary guid
		//  which we need to process
		//===================================================
		if( wBinaryMofType ){
			hr = ProcessBinaryGuidsViaEvent( WnodeHeader, wBinaryMofType );
		}
		else{
			//=======================================================
			//  Process the data event
			//=======================================================
			if( WnodeHeader->Flags & WNODE_FLAG_ALL_DATA ){
				hr = m_pWDM->SetAllInstancePtr((PWNODE_ALL_DATA)WnodeHeader);
			}
			else if( WnodeHeader->Flags & WNODE_FLAG_SINGLE_INSTANCE ){
				hr = m_pWDM->SetSingleInstancePtr((PWNODE_SINGLE_INSTANCE)WnodeHeader);
			}
			if( hr == S_OK ){	
        
				//===================================================================
				//  Process all wnodes.
				//===================================================================
				while( TRUE ){

					if( S_OK == ( hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance()) ){
						//===========================================================
						//  Now, send it to all consumers registered for this event
						//===========================================================
						hr = m_pClass->SendInstanceBack();
					}  
					//===============================================================
					//  If we errored out,we don't know that any of the pointers
					//  are ok, so get out of there.
					//===============================================================
					else{
						break;
					}

					//===============================================================
					//  Process all of the instances for this event
					//===============================================================
					if( !m_pWDM->MoreToProcess() ){
	    				break;
					}
				}
			}
		}
		//============================================================================
		// Since we never allocated anything, just used the incoming stuff,
		// for cleanliness sake, init ptrs to null
		//============================================================================
		m_pWDM->InitDataBufferToNull();
   }
   return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::FillInAndSubmitWMIDataBlob( IWbemClassObject * pIClass, int nTypeOfPut, CVARIANT & vList)
{
   HRESULT hr = WBEM_E_FAILED;
   if( m_fInit )
   {

		hr = m_pWDM->OpenWMI();
		if( hr == S_OK ){
			//  Now, work with the class we want to write
			if( SUCCEEDED(m_pClass->SetClassPointerOnly(pIClass))){
    
				if( nTypeOfPut == PUT_WHOLE_INSTANCE ){
					hr = m_pWDM->ConstructDataBlock(TRUE) ;
	 				if( S_OK == hr ){
						hr = m_pWDM->SetSingleInstance();
					}
				}
				else{
					if(m_pWDM->GetListOfPropertiesToPut(nTypeOfPut,vList)){
						hr = m_pWDM->PutSingleProperties();
					}
					else{
						hr =  WBEM_E_INVALID_CONTEXT;
					}
				}
			}
		}
   }
   return(hr);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::QueryAndProcessAllBinaryGuidInstances(CNamespaceManagement & Namespace, BOOL & fMofHasChanged,
																 KeyList * pArrDriversInRegistry)
{
	HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		CAutoWChar wcsTmpKey(MAX_PATH*3);
		if( wcsTmpKey.Valid() )
		{
			m_pClass->SetHardCodedGuidType(MOF_ADDED);
			m_pClass->GetGuid();
			hr = m_pWDM->OpenWMI();
			if( hr == S_OK )
			{
    			hr = m_pWDM->QueryAllData();
				//======================================================
				//  If we got the data then process it
				//======================================================
				if( hr == S_OK )
				{
					while( TRUE )
					{
						hr = m_pWDM->ProcessNameBlock(FALSE);
						if( hr == S_OK )
						{
 							hr = m_pWDM->ProcessBinaryMofDataBlock(CVARIANT(m_pClass->GetClassName()),wcsTmpKey);
							if( hr == S_OK )
							{
	       						Namespace.UpdateQuery(L" and Name != ",wcsTmpKey);
							}
							if( pArrDriversInRegistry )
							{
								pArrDriversInRegistry->Remove(wcsTmpKey);
							}

							if( !m_pWDM->MoreToProcess() )
							{
								break;
							}
						}
					}
				}
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ProcessBinaryGuidsViaEvent( PWNODE_HEADER WnodeHeader, WORD wType )
{
   HRESULT hr = WBEM_E_FAILED;
   if( m_fInit )
   {
		//======================================================
		//  Initialize all of the necessary stuff and get the
		//  definition of the class we are working with
		//======================================================
		m_pClass->SetHardCodedGuidType(wType);
		//==================================================================
		//  We are working with a specific guy, so we need to find out
		//  if it is a Binary Mof Guid to do a query all data on, or
		//  if it is a Resource Name and File to open up and extract
		//==================================================================
		if( WnodeHeader->Flags & WNODE_FLAG_ALL_DATA )
		{
			hr = m_pWDM->SetAllInstancePtr((PWNODE_ALL_DATA)WnodeHeader);
			if(hr == S_OK)
			{
				hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
			}
		}
		else if( WnodeHeader->Flags & WNODE_FLAG_SINGLE_INSTANCE )
		{
			hr = m_pWDM->SetSingleInstancePtr((PWNODE_SINGLE_INSTANCE)WnodeHeader);
			if( hr == S_OK )
			{
				hr = m_pWDM->ProcessDataBlock();
			}
		}
		else
		{
			hr = WBEM_E_INVALID_PARAMETER;
		}
   }
   return hr;
}

//************************************************************************************************************
//============================================================================================================
//
//   CWMIHiPerfShell
//
//============================================================================================================
//************************************************************************************************************

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWMIHiPerfShell::CWMIHiPerfShell(BOOL fAutoCleanup)
{
    m_fAutoCleanup = fAutoCleanup;
	m_pWDM = NULL;
    m_pClass = NULL;
	m_fInit = FALSE;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::Initialize(BOOL fUpdate, ULONG uDesiredAccess, CHandleMap * pList,WCHAR * wcs, IWbemServices   __RPC_FAR * pServices, 
                            IWbemObjectSink __RPC_FAR * pHandler, IWbemContext __RPC_FAR *pCtx) 
{
    HRESULT hr = WBEM_E_FAILED;

    m_pClass = new CWMIProcessClass(0);
    if( m_pClass )
    {
		hr = m_pClass->Initialize();
		if( S_OK == hr )
		{
			m_pClass->WMI()->SetWMIPointers(pList,pServices,pHandler,pCtx);
			m_pClass->SetHiPerf(TRUE);
			m_pClass->SetClass(wcs);

			m_pWDM = new CProcessHiPerfDataBlock;
			if( m_pWDM )
			{
				m_pWDM->SetDesiredAccess(uDesiredAccess);
				m_pWDM->UpdateNamespace(fUpdate);
				m_pWDM->SetClassProcessPtr(m_pClass);
				m_fInit = TRUE;
			}
			hr = S_OK;
		}
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWMIHiPerfShell::~CWMIHiPerfShell() 
{
    if( m_fAutoCleanup )
    {
        SAFE_DELETE_PTR(m_pClass);
    }
	SAFE_DELETE_PTR(m_pWDM);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::QueryAllHiPerfData()
{
	HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		//===============================================================
		//  There is only one handle for this class, so see if we can
		//  get it
		//===============================================================
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());

		HANDLE WMIHandle = 0;

		hr = m_pWDM->GetWMIHandle(WMIHandle);
		if( SUCCEEDED(hr))
		{
			// =====================================================
			//  Query for all of the objects for this class
			//  Add all the objects at once into the enumerator
			//  Handles are guaranteed to be open at this time
			//======================================================
			hr = QueryAllInstances(WMIHandle,NULL);
		}
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::RefreshCompleteList()
{
    //=======================================================================
    // Go through all the enumerators and instances to refresh everything
    //=======================================================================
    HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());
		HANDLE WMIHandle = 0;
		IWbemHiPerfEnum * pEnum = NULL;
		CWMIProcessClass * pSavedClass = m_pClass;

		//==============================================================
		// 
		//==============================================================
		hr = m_pHiPerfMap->GetFirstHandle( WMIHandle, m_pClass, pEnum);
		while( hr == S_OK )
		{
			if( WMIHandle )
			{
				m_pWDM->SetClassProcessPtr(m_pClass);
				if( pEnum )
				{
					hr = QueryAllInstances(WMIHandle,pEnum);
				}
				else
				{
					hr = QuerySingleInstance(WMIHandle);
				}

				if(SUCCEEDED(hr))
				{
					hr = m_pHiPerfMap->GetNextHandle(WMIHandle,m_pClass,pEnum);
				}
			}
			if( hr == WBEM_S_NO_MORE_DATA )
			{
				hr = S_OK;
				break;
			}
		}

		//================================================================
		m_pClass = pSavedClass;
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::HiPerfQuerySingleInstance(WCHAR * wcsInstance)
{
    HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		//======================================================
		//  Go through the list of handles and get the handles
		//  to send and how many there are, also, get the 
		//  instance names
		//======================================================
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());

		IWbemObjectAccess * pAccess  = NULL;
		CWMIProcessClass * pClass = NULL;

		HANDLE WMIHandle = 0;
		ULONG_PTR lTmp = (ULONG_PTR)pAccess;

		hr = m_pHiPerfMap->FindHandleAndGetClassPtr(WMIHandle,lTmp, pClass);
		if( SUCCEEDED(hr))
		{
			hr = QuerySingleInstance(WMIHandle);
		}
	}
    return hr;
}	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::AddAccessObjectToRefresher(IWbemObjectAccess *pAccess,
                                                    IWbemObjectAccess ** ppRefreshable,
                                                    ULONG_PTR *plId)
{
    HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		//======================================================
		//  Get the definition of the class we are working with
		//======================================================
		hr = m_pClass->SetAccess(pAccess);
		if( SUCCEEDED(hr))
		{
			CAutoBlock(m_pHiPerfMap->GetCriticalSection());

			HANDLE WMIHandle = 0;
			CLSID Guid;

			hr = m_pWDM->GetWMIHandle(WMIHandle);
			if( SUCCEEDED(hr))
			{
				// =======================================================
				// We have the WMI Handle, now add it to the hi perf map
				// for this refresher
   				// =======================================================
				if( m_pClass->GetANewAccessInstance() )
				{
					//====================================================
					//  Set the flag so we don't get a new instance for
					//  this anymore
					//====================================================
					m_pClass->GetNewInstance(FALSE);
					hr = m_pClass->SetKeyFromAccessPointer();
					if( SUCCEEDED(hr))
					{
						*ppRefreshable = m_pClass->GetAccessInstancePtr();
						*plId = (ULONG_PTR)(*ppRefreshable);

						hr = m_pHiPerfMap->Add(WMIHandle, *plId, m_pClass, NULL );
					}
				}
			}
		}
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::AddEnumeratorObjectToRefresher(IWbemHiPerfEnum* pHiPerfEnum, ULONG_PTR *plId)
{
	HRESULT hr = WBEM_E_FAILED;

	if( m_fInit )
	{
		//===============================================================
		//  There is only one handle for this class, so see if we can
		//  get it
		//===============================================================
		HANDLE WMIHandle = 0;
		CLSID Guid;
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());

		hr = m_pWDM->GetWMIHandle(WMIHandle);
		if( SUCCEEDED(hr))
		{
			*plId = (ULONG_PTR)pHiPerfEnum;
			hr = m_pHiPerfMap->Add(WMIHandle, *plId, m_pClass,pHiPerfEnum);
		}
	}
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::RemoveObjectFromHandleMap(ULONG_PTR lHiPerfId)
{
	HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		HANDLE hHandle = 0;
		CHandleMap *pHandleMap = m_pClass->WMI()->HandleMap();
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());

		//==============================================================
		// First, delete the object from the map
		//==============================================================
		hr = m_pHiPerfMap->Delete( hHandle, lHiPerfId );
		if( SUCCEEDED(hr))
		{
			//==========================================================
			//  If we got a handle back, then we know it is an access
			//  instance and we need to release the WMI Handle
			//==========================================================
			if( hHandle ){
				hr = pHandleMap->ReleaseHandle(hHandle);        
			}
		}
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  PRIVATE
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::QueryAllInstances(HANDLE WMIHandle,IWbemHiPerfEnum* pHiPerfEnum)
{
	HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		long	lCount = 0;
		HandleList ids;
		//==================================================
		//  Collect all of the WDM Handles to query all at
		//  once.
		//==================================================
		// 170635
		if(SUCCEEDED(hr = ids.Add(WMIHandle)))
		{
			// =====================================================
			//  Query for all of the objects for this class
			//  Add all the objects at once into the enumerator
			//  Handles are guaranteed to be open at this time
			//======================================================
			HANDLE * pHandles = (HANDLE*)*(ids.List());
			hr = m_pWDM->HiPerfQueryAllData(pHandles,ids.Size());
			//======================================================
			//  If we got the data then process it
			//======================================================
			if( SUCCEEDED(hr))
			{
			
				//======================================================
				//  Get the list of ptrs
				//======================================================
				AccessList AccessList;
				while( TRUE )
				{
					hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
					if( hr == S_OK )
					{
						IWbemObjectAccess * p = m_pClass->GetAccessInstancePtr();
						if(SUCCEEDED(hr = AccessList.Add(p)))
						{
							lCount++;
						}
					}
					if( hr != S_OK )
					{
						break;
					}
					if( !m_pWDM->MoreToProcess() )
					{
						break;
					}
					if( !pHiPerfEnum )
					{
						m_pClass->SendInstanceBack();
					}
				}

				//======================================================
				//  Now, once we have collected them, send them off
				//  if asked to
				//======================================================
				if( pHiPerfEnum )
				{
					if( lCount > 0 )
					{
						long * pLong = new long[lCount];
						if(pLong)
						{
							for(long l = 0; l < lCount; l++)
							{
								pLong[l] = l;
							}

							IWbemObjectAccess ** pAccess = (IWbemObjectAccess**)AccessList.List();
							// Remove all the objects in the enumerator before adding the object
							pHiPerfEnum->RemoveAll(0);
							hr = pHiPerfEnum->AddObjects( 0L, AccessList.Size(), pLong, pAccess);
							SAFE_DELETE_ARRAY(pLong);
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}
					}
				}
			}						
		}
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::QuerySingleInstance(HANDLE WMIHandle)
{
    HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		CVARIANT varName;

		hr = m_pClass->GetKeyFromAccessPointer((CVARIANT *)&varName);
		if(SUCCEEDED(hr))
		{
			WCHAR * p = varName.GetStr();
			if(p)
			{
				hr = m_pWDM->HiPerfQuerySingleInstance(&WMIHandle, &p, 1,1);
				//======================================================
				//  If we got the data, process it
				//======================================================
				if( SUCCEEDED(hr))
				{
					hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
//					if( hr == S_OK )
//					{
//					   m_pClass->SendInstanceBack();
//					}
				}                
			}
			else
			{
				hr = WBEM_E_FAILED;
			}
		}
	}
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wdmshell.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WDMSHELL_HEADER
#define _WDMSHELL_HEADER
#include "wmicom.h"
//************************************************************************************************************
//============================================================================================================
//
//   The Standard WDM Shell
//
//============================================================================================================
//************************************************************************************************************
class CWMIClassType
{
    public: 
        CWMIClassType() {}
        ~CWMIClassType(){}
        BOOL IsHiPerfClass(WCHAR * wcsClass, IWbemServices * pServices);

};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CWMIStandardShell 
{

    private:

        CWMIProcessClass          * m_pClass;
        CProcessStandardDataBlock * m_pWDM;
		BOOL					  m_fInit;

 
    public:
        CWMIStandardShell();
        ~CWMIStandardShell();      


		HRESULT Initialize(WCHAR * wcsClass, BOOL fInternalEvent, CHandleMap * pList,BOOL fUpdateNamespace, ULONG uDesiredAccess, IWbemServices   __RPC_FAR * pServices, 
                            IWbemObjectSink __RPC_FAR * pHandler, IWbemContext __RPC_FAR *pCtx);

		inline BOOL HasMofChanged()	{ return m_pWDM->HasMofChanged(); }

        //=============================================
        //  Process All and Single WMI Instances
        //=============================================
        HRESULT ProcessAllInstances();

        HRESULT ProcessSingleInstance( WCHAR * wcsInstanceName);
        //==========================================================
        //  The put instance group
        //==========================================================
        HRESULT FillInAndSubmitWMIDataBlob( IWbemClassObject * pIClass, int nTypeOfPut, CVARIANT & vList);
        	
        //=============================================
        // Event functions
        //=============================================
        HRESULT ProcessEvent(WORD wBinaryMofType, PWNODE_HEADER WnodeHeader);
        inline HRESULT  RegisterWMIEvent( WCHAR * wcsGuid, ULONG_PTR uContext, CLSID & Guid, BOOL fRegistered)
                                         { return m_pWDM->RegisterWMIEvent(wcsGuid,uContext,Guid,fRegistered);}
                                                                 

	
        //=============================================
        // method functions
        //=============================================
        HRESULT ExecuteMethod( WCHAR * wcsInstance,
                               WCHAR * MethodInstanceName,
                               IWbemClassObject * pParentClass, 
    					       IWbemClassObject * pInClassData, 
							   IWbemClassObject * pInClass, 
							   IWbemClassObject * pOutClass ) ;
        //=============================================
        // data processing functions
        //=============================================
        HRESULT GetGuid(WCHAR * pwcsGuid);

        HRESULT SetGuidForEvent( WORD wType,WCHAR * wcsGuid );
        HRESULT RegisterForWMIEvents( ULONG uContext, WCHAR * wcsGuid, BOOL fRegistered,CLSID & Guid );
        inline BOOL CancelWMIEventRegistration( GUID gGuid , ULONG_PTR uContext ) { return m_pClass->WMI()->CancelWMIEventRegistration(gGuid,uContext);}

        //=============================================
        //  The binary mof groupg
        //=============================================
        HRESULT ProcessBinaryGuidsViaEvent( PWNODE_HEADER WnodeHeader,WORD wType );
        HRESULT QueryAndProcessAllBinaryGuidInstances(CNamespaceManagement & Namespace, BOOL & fMofHasChanged, KeyList * pArrDriversInRegistry);
		//=============================================
        //  Misc
        //=============================================
        inline CLSID * GuidPtr()                  { return m_pClass->GuidPtr();}
        inline HRESULT SetErrorMessage(HRESULT hr){ return m_pClass->WMI()->SetErrorMessage(hr,m_pClass->GetClassName(),m_pWDM->GetMessage());}

};

//************************************************************************************************************
//============================================================================================================
//
//   The Hi Performance Shell
//
//============================================================================================================
//************************************************************************************************************

class CWMIHiPerfShell 
{
    private:

        CHiPerfHandleMap        * m_pHiPerfMap;
        CProcessHiPerfDataBlock * m_pWDM;
        CWMIProcessClass        * m_pClass;
        BOOL                      m_fAutoCleanup;
		BOOL					  m_fInit;

        HRESULT QueryAllInstances(HANDLE WMIHandle,IWbemHiPerfEnum* pHiPerfEnum);
        HRESULT QuerySingleInstance(HANDLE WMIHandle);

        

    public:

        CWMIHiPerfShell(BOOL fAuto);
        ~CWMIHiPerfShell();

		HRESULT Initialize(BOOL fUpdate, ULONG uDesiredAccess, CHandleMap * pList,WCHAR * wcs, IWbemServices   __RPC_FAR * pServices, 
                            IWbemObjectSink __RPC_FAR * pHandler, IWbemContext __RPC_FAR *pCtx) ;
		

        inline void SetHiPerfHandleMap(CHiPerfHandleMap * p)    { m_pHiPerfMap = p; }
        inline CCriticalSection * GetCriticalSection()          { return m_pHiPerfMap->GetCriticalSection();}
        inline CHiPerfHandleMap * HiPerfHandleMap()             { return m_pHiPerfMap;}

        HRESULT QueryAllHiPerfData();
        HRESULT HiPerfQuerySingleInstance(WCHAR * wcsInstance);
        HRESULT AddAccessObjectToRefresher(IWbemObjectAccess *pAccess, IWbemObjectAccess ** ppRefreshable, ULONG_PTR * plId);
        HRESULT AddEnumeratorObjectToRefresher(IWbemHiPerfEnum* pHiPerfEnum, ULONG_PTR * plId);
        HRESULT RemoveObjectFromHandleMap(ULONG_PTR lHiPerfId);
        HRESULT RefreshCompleteList();

        inline HRESULT SetErrorMessage(HRESULT hr){ return m_pClass->WMI()->SetErrorMessage(hr,m_pClass->GetClassName(),m_pWDM->GetMessage());}


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\wbemtime.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  wbemtime.h
//
//  Purpose: declares the WBEMTime and WBEMTimeSpan objects which are 
//  similar to the MFC CTime and CTimeSpan objects.  The WBEM versions
//  are capable of storing down to the nsec and also have functions for
//  Creating from and getting BSTRs.
//
//  Note; The current implementation of WBEMTime does not support dates 
//  before 1601;
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef WBEMTIME_HEADERFILE_IS_INCLUDED
#define WBEMTIME_HEADERFILE_IS_INCLUDED

#define INVALID_TIME 0xffffffffffffffff

#include <polarity.h>
#include <time.h>
#pragma warning( disable : 4290 ) // Ignore 'C++ Exception Specification ignored'
#include <ProvExce.h>

///////////////////////////////////////////////////////////////////////////
// WBEMTimeSpan - This class holds time span values. 

class POLARITY WBEMTimeSpan 
{
private:

    ULONGLONG m_Time;
    friend class WBEMTime;

public:

    WBEMTimeSpan ()                                             { m_Time = INVALID_TIME ; }
    WBEMTimeSpan ( const BSTR bstrDMTFFormat )                  { *this = bstrDMTFFormat ; }

    WBEMTimeSpan ( 

        int iDays , 
        int iHours , 
        int iMinutes ,  
        int iSeconds , 
        int iMSec=0 , 
        int iUSec=0, 
        int iNSec=0 
    ) ;

    WBEMTimeSpan operator+ (const WBEMTimeSpan &uAdd ) const ;
    const WBEMTimeSpan &operator+= ( const WBEMTimeSpan &uAdd ) ;

    WBEMTimeSpan operator- (const WBEMTimeSpan &uSub ) const ;
    const WBEMTimeSpan &operator-= ( const WBEMTimeSpan &uSub ) ;

    const WBEMTimeSpan &operator= ( const BSTR pDMTFFormat ) ; 

    BOOL operator== ( const WBEMTimeSpan &a ) const             { return m_Time == a.m_Time ; }
    BOOL operator!= ( const WBEMTimeSpan &a ) const             { return m_Time != a.m_Time ; }
    BOOL operator<  ( const WBEMTimeSpan &a ) const             { return m_Time < a.m_Time ; }
    BOOL operator<= ( const WBEMTimeSpan &a ) const             { return m_Time <= a.m_Time ; }
    BOOL operator>  ( const WBEMTimeSpan &a ) const             { return m_Time > a.m_Time ; }
    BOOL operator>= ( const WBEMTimeSpan &a ) const             { return m_Time >= a.m_Time ; }

    BSTR GetBSTR ( void ) const throw ( CHeap_Exception ) ;

    bool IsOk () const                                          { return m_Time != INVALID_TIME ? true : false; }
    ULONGLONG GetTime () const                                  { return m_Time ; }
    void Clear ( void )                                         { m_Time = INVALID_TIME ; }
    
    // These are all deprecated
    WBEMTimeSpan ( const FILETIME &ft ) ;
    WBEMTimeSpan ( const time_t & t ) ;
    const WBEMTimeSpan &operator= ( const FILETIME &ft ) ;
    const WBEMTimeSpan &operator= ( const time_t &t ) ;
    BOOL Gettime_t ( time_t *ptime_t ) const ;
    BOOL GetFILETIME ( FILETIME *pst ) const ;

};

///////////////////////////////////////////////////////////////////////////
// WBEMTime - This class holds time values. 

class POLARITY WBEMTime 
{
public:

    WBEMTime ()                                                 { m_uTime = INVALID_TIME ; }
    WBEMTime ( const BSTR bstrDMTFFormat )                      { *this = bstrDMTFFormat ; }
    WBEMTime ( const SYSTEMTIME &st )                           { *this = st ; }
    WBEMTime ( const FILETIME &ft )                             { *this = ft ; }
    WBEMTime ( const struct tm &tmin )                          { *this = tmin ; }
    WBEMTime ( const time_t &t )                                { *this = t ; }

    WBEMTime        operator+ ( const WBEMTimeSpan &uAdd ) const ;
    const WBEMTime &operator+=( const WBEMTimeSpan &ts ) ;

    WBEMTimeSpan    operator- ( const WBEMTime &sub ) ;

    WBEMTime        operator- ( const WBEMTimeSpan &sub ) const;
    const WBEMTime &operator-=( const WBEMTimeSpan &sub );

    const WBEMTime &operator= ( const BSTR bstrDMTFFormat ) ; 
    const WBEMTime &operator= ( const SYSTEMTIME &st ) ;
    const WBEMTime &operator= ( const FILETIME &ft ) ;
    const WBEMTime &operator= ( const struct tm &tmin ) ;
    const WBEMTime &operator= ( const time_t & t) ;

    BOOL operator== ( const WBEMTime &a ) const                 { return m_uTime == a.m_uTime ; }
    BOOL operator!= ( const WBEMTime &a ) const                 { return m_uTime != a.m_uTime ; }
    BOOL operator<  ( const WBEMTime &a ) const                 { return m_uTime < a.m_uTime ; }
    BOOL operator<= ( const WBEMTime &a ) const                 { return m_uTime <= a.m_uTime ; }
    BOOL operator>  ( const WBEMTime &a ) const                 { return m_uTime > a.m_uTime ; }
    BOOL operator>= ( const WBEMTime &a ) const                 { return m_uTime >= a.m_uTime ; }

    BSTR GetBSTR ( void ) const throw ( CHeap_Exception ) ;
    BOOL GetStructtm (struct tm *ptm ) const;
    BOOL Gettime_t ( time_t *ptime_t ) const;
    BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
    BOOL GetFILETIME ( FILETIME *pst ) const;

    BOOL SetDMTF ( const BSTR wszText ) ;
    BSTR GetDMTF ( BOOL bLocal = FALSE ) const throw ( CHeap_Exception ) ;

    BSTR GetDMTFNonNtfs(void) const ;

    void Clear ( void )                                         { m_uTime = INVALID_TIME ; }

    bool IsOk () const                                          { return m_uTime != INVALID_TIME ? true : false; }
    ULONGLONG GetTime () const                                  { return m_uTime ; }

    static LONG WINAPI GetLocalOffsetForDate(const struct tm *tmin);
    static LONG WINAPI GetLocalOffsetForDate(const SYSTEMTIME *pst);
    static LONG WINAPI GetLocalOffsetForDate(const FILETIME *pft);
    static LONG WINAPI GetLocalOffsetForDate(const time_t &t);

private:
    ULONGLONG m_uTime;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmiclass.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "precomp.h"
#include "wmicom.h"
#include "wmimap.h"
#include <stdlib.h>
#include <winerror.h>
#include <crc32.h>


////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//  THE CWbemInfoClass
//**********************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//
// NAME			GetPropertiesInID_Order
// PURPOSE		Return a WCHAR string containing the class's 
//              property names, orderd by an ID number
//				contained within the named property qualifier.
//			
// WRAPPER		Not a wrapper.  This is a standalone filter/sort 
//              utility function.
//
//**********************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
CWMI_IDOrder::CWMI_IDOrder(IWbemClassObject * pC, IWbemObjectAccess * pA) 
{ 
    m_pWMIDataIdList = NULL;
    InitMemberVars();
    m_pClass = pC;
    m_pAccess = pA;
}

///////////////////////////////////////////////////////////////////////
CWMI_IDOrder::~CWMI_IDOrder()
{
    // m_pClass & m_pAccess released elsewhere
    InitMemberVars();
}
///////////////////////////////////////////////////////////////////////
void CWMI_IDOrder::InitMemberVars()
{
    //m_pObj = NULL;  
    m_nTotal = 0;
    m_nCurrent = 0;
	m_nStartingPosition = sizeof(m_nStartingPosition);
    if( m_pWMIDataIdList )
    {
        SAFE_DELETE_ARRAY(m_pWMIDataIdList);
        m_pWMIDataIdList = NULL;
    }
}
///////////////////////////////////////////////////////////////////////
WCHAR * CWMI_IDOrder::GetFirstID()
{
	//***********************************************************
	// Since we have to deal with IDs starting at both 0, 1, or
	// whatever, we need to find out where the list starts
	// find out which way this list starts.
	// decrement the m_nCurrent count by 1 and call the GetNextId
	// function which immediately bumps it up by one.
	//***********************************************************
		m_nCurrent = m_nStartingPosition -1;
		return GetNextID();
}
///////////////////////////////////////////////////////////////////////
WCHAR * CWMI_IDOrder::GetNextID()
{
    WCHAR * pChar = NULL;

    //===================================================================
	//  Go in a loop to find the next ID
	//  Increment current first, remember, current has to stay valid at
	//  all times
    //===================================================================
	m_nCurrent++;

    //===================================================================
	// If there is no property name, then we know we are done
	// with the properties
    //===================================================================
    while( m_pWMIDataIdList[m_nCurrent].pwcsPropertyName ){

        if( m_pWMIDataIdList[m_nCurrent].fPutProperty == FALSE )
        {
			m_nCurrent++;
        }
        else
        { 
            pChar = m_pWMIDataIdList[m_nCurrent].pwcsPropertyName;
	        break;
        }
    }//End while loop

    return pChar;
}

///////////////////////////////////////////////////////////////////////
HRESULT CWMI_IDOrder::ProcessPropertyQualifiers(LPCWSTR strPropName, int nMax,BOOL fHiPerf)
{
	IWbemQualifierSet * pIWbemQualifierSet = NULL;
    CIMTYPE lType = 0; 
        
    HRESULT hr = m_pClass->GetPropertyQualifierSet(strPropName,&pIWbemQualifierSet);
	if( SUCCEEDED(hr) )
    {
		int nPosition = 0;
       	CVARIANT v;

		hr = pIWbemQualifierSet->Get(L"WmiDataId", 0, &v, 0);
		if( hr == S_OK )
        {
			nPosition = v.GetLONG();
		}
		else
        {
			hr = pIWbemQualifierSet->Get(L"ID", 0, &v, 0);
			if( hr == S_OK )
            {
				nPosition = v.GetLONG();
			    // instance ids start with 0, methods with 1, so 
			    // just force these to match our method processing.
			}
		}

		if( SUCCEEDED(hr))
        {
			if( nPosition > nMax )
            {		
				hr = WBEM_E_INVALID_PARAMETER;
			}
			else
            {
				//===================================================
				// Get the exact number and 
				// copy property name into the correct array location
				// and get all of the attributes of the property
				// we will need in the future to process it.
				//===================================================
				hr =m_pClass->Get(strPropName, 0, &v, &lType, NULL);
				if( SUCCEEDED(hr) )
                {
                    //=================================================================
                    //  If we are accumulating hi perf info, then get the handle to 
                    //  access the property instead of via property name
                    //=================================================================
                    if( fHiPerf )
                    {
                        long lHandle = 0;
                        if( S_OK == m_pAccess->GetPropertyHandle(strPropName, 0, &lHandle))
                        {
    					    m_pWMIDataIdList[nPosition].lHandle = (long)lHandle;
                        }
                    }
										
                    //=================================================================
                    //  Now, set the rest of the property information
                    //=================================================================
					m_pWMIDataIdList[nPosition].lType = (long)lType;
					m_pWMIDataIdList[nPosition].SetPropertyName((WCHAR*)strPropName);
					m_pWMIDataIdList[nPosition].fPutProperty = TRUE;

             		CVARIANT vQual;  
        			CWMIDataTypeMap MapWMIData;

            		hr = pIWbemQualifierSet->Get(L"CIMType", 0, &vQual,0);
					if( SUCCEEDED(hr))
                    {
       					CBSTR cbstrTmp(vQual.GetStr());
						MapWMIData.GetSizeAndType(cbstrTmp, &m_pWMIDataIdList[nPosition],
										          m_pWMIDataIdList[nPosition].lType, 
                                                  m_pWMIDataIdList[nPosition].nWMISize);

						m_pWMIDataIdList[nPosition].dwArraySize = GetSizeOfArray(strPropName,m_pWMIDataIdList[nPosition].lType );
            		}
					m_nStartingPosition = min( m_nStartingPosition, nPosition ); //whichever is the smallest
					m_nTotal++;
				}
			}
		}
		else
        {
			// As some properties are ok not to have WMIDataIds, we have
			// to set this to OK, need to log this in the future
			hr = S_OK;
		}
    }
	else
    {
		//  This is a system property, so it is ok
		hr = S_OK;
	}

    SAFE_RELEASE_PTR(pIWbemQualifierSet);
    return hr;
}
///////////////////////////////////////////////////////////////////////
HRESULT CWMI_IDOrder::GetPropertiesInIDOrder(BOOL fHiPerf)
{
	HRESULT  hr = WBEM_E_FAILED;
	SAFEARRAY * psaNames = NULL;
    
    //======================================================
    // Get Array boundaries
    //======================================================
//    IWbemClassObject * p = m_pObj->ClassPtr();
	hr = m_pClass->GetNames(NULL, 0, NULL, &psaNames);
    if (SUCCEEDED(hr)){
    	long lLower = 0, lUpper = 0; 

    	hr = SafeArrayGetLBound(psaNames,1,&lLower);
        if (SUCCEEDED(hr)){

            hr = SafeArrayGetUBound(psaNames,1,&lUpper);
            if (SUCCEEDED(hr)){

                //===========================================
                // Get the total number of elements, so we
                // create the right sized array of ID structs
                //===========================================
  
				int nSize = (lUpper-lLower)+2;
			    m_pWMIDataIdList = (IDOrder * ) new IDOrder[nSize];
                if( m_pWMIDataIdList )
                {
                    try
                    {
				        memset(m_pWMIDataIdList,NULL,(sizeof(IDOrder)* nSize));

				        for(long ndx = lLower; ndx <= lUpper; ndx++)
                        {
                            CBSTR cbstrPropName;
					        hr = SafeArrayGetElement(psaNames, &ndx, &cbstrPropName);
					        if (WBEM_S_NO_ERROR == hr)
                            {
	    				        hr = ProcessPropertyQualifiers( cbstrPropName, lUpper, fHiPerf);
						        if( hr != WBEM_S_NO_ERROR )
                                {
							        break;
						        }
					        }
				        }
                    }
                    catch(...)
                    { 
                        SAFE_DELETE_ARRAY(m_pWMIDataIdList);
                        hr = WBEM_E_UNEXPECTED; 
                        throw;
                    }
                }
            }
        }
	}
	if( psaNames )
    {
		SafeArrayDestroy(psaNames);
	}
	return hr;
}
////////////////////////////////////////////////////////////////////////
DWORD CWMI_IDOrder::GetSizeOfArray(LPCWSTR strProp, long lType)
{
	HRESULT hr = WBEM_E_OUT_OF_MEMORY;
	CAutoWChar pwcsArraySize(_MAX_PATH+2);
	DWORD dwCount = 0L;
	if( pwcsArraySize.Valid() )
	{
		IWbemQualifierSet * pIWbemQualifierSet = NULL;
		
		lType = lType &~  CIM_FLAG_ARRAY;
		//======================================================
		// Get the number of elements in the array from the 			
		// "ArraySize" property qualifier
		//======================================================
		hr = m_pClass->GetPropertyQualifierSet(strProp,&pIWbemQualifierSet);
		if( SUCCEEDED(hr) )
		{
			CVARIANT v;
			hr = pIWbemQualifierSet->Get(L"MAX", 0, &v, 0);
			if( SUCCEEDED(hr))
			{
				dwCount = v.GetLONG();
			}
			else
			{
				hr = pIWbemQualifierSet->Get(L"WMISizeIs", 0, &v, 0);
				if( hr == S_OK )
				{
					CVARIANT var;
					CIMTYPE lTmpType=0;
					CWMIDataTypeMap MapWMIData;
					hr = m_pClass->Get(v, 0, &var, &lTmpType,NULL);		
					if( hr == S_OK )
					{
						dwCount = MapWMIData.ArraySize(lTmpType,var);
					}
				}
			}
		}

		SAFE_RELEASE_PTR(pIWbemQualifierSet);
	}
    return dwCount;
}        
//******************************************************************
////////////////////////////////////////////////////////////////////
//  CWMIProcessClass
////////////////////////////////////////////////////////////////////
//******************************************************************
//  WbemClassInfo deals with all the pointers and info with one
//  particular wbem class
//
//******************************************************************
////////////////////////////////////////////////////////////////////
CWMIProcessClass::~CWMIProcessClass()
{
    ReleaseInstancePointers();
    SAFE_RELEASE_PTR(m_pAccess);
    SAFE_RELEASE_PTR(m_pClass );
    SAFE_DELETE_ARRAY(m_pwcsClassName);
    SAFE_DELETE_PTR(m_pCurrentProperty);
	SAFE_DELETE_PTR(m_pWMI);
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::Initialize()
{
	HRESULT hr = WBEM_E_FAILED;

	SAFE_DELETE_PTR(m_pWMI);

	m_pWMI = new CWMIManagement;
	if( m_pWMI )
	{
		hr = S_OK;
		m_fInit = TRUE;
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////
CWMIProcessClass::CWMIProcessClass(BOOL b)
{
	m_pWMI = NULL;
	m_fInit = FALSE;
    m_fGetNewInstance = TRUE;
   	m_pAccessInstance = NULL;
    m_pClassInstance = NULL;
    m_pClass = NULL;
	m_pAccess = NULL;
    m_pCurrentProperty = NULL;
    m_pwcsClassName = NULL;
    m_wHardCodedGuid = 0;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIProcessClass::GetANewAccessInstance()
{ 
    HRESULT hr = S_OK;

    hr = m_pAccess->SpawnInstance(0, &m_pClassInstance);
    m_pClassInstance->AddRef();
    if( SUCCEEDED(hr) )
    {
        hr = m_pClassInstance->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&m_pAccessInstance);

    }
    return ( hr == 0 ) ? TRUE : FALSE; 
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIProcessClass::GetANewInstance()
{ 
    HRESULT hr = S_OK;

    if( m_fGetNewInstance )
    {
        SAFE_RELEASE_PTR(m_pClassInstance);
        hr = m_pClass->SpawnInstance(0, &m_pClassInstance);
        if( SUCCEEDED(hr) )
        {
            if( m_fHiPerf )
            {
                SAFE_RELEASE_PTR(m_pAccessInstance);
                hr = m_pClassInstance->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&m_pAccessInstance);
            }
        }
    }
    return ( hr == 0 ) ? TRUE : FALSE; 
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SetKeyFromAccessPointer()
{
    CVARIANT varName;
	
    HRESULT hr  = m_pAccess->Get(L"InstanceName", 0, &varName, NULL, NULL);		
    if( SUCCEEDED(hr))
    {
        hr = m_pClassInstance->Put(L"InstanceName", 0, &varName, NULL);
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT  CWMIProcessClass::GetKeyFromAccessPointer(CVARIANT * v)
{
	return m_pAccessInstance->Get(L"InstanceName", 0, (VARIANT *)v, NULL, NULL);		
}

/////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SetHiPerfProperties(LARGE_INTEGER TimeStamp)  
{ 
    LONG lHandle = 0;

    //=========================================================================================================
    // Timestamp_PerfTime = timestamp in PerfFreq units returned by (QueryPerformanceCounter)
    //=========================================================================================================
    HRESULT hr = m_pAccess->GetPropertyHandle(L"Frequency_PerfTime", 0, &lHandle);
    if(SUCCEEDED(hr))
    {
        LARGE_INTEGER Counter;
        if( QueryPerformanceCounter(&Counter))
        {
            hr = m_pAccessInstance->WriteQWORD(lHandle, Counter.QuadPart);
        }

        //=====================================================================================================
        // Timestamp_Sys100NS = timestamp in 100 NS units/QueryPerformanceCounter()dumbed down to 100NS
        //=====================================================================================================
        if ( SUCCEEDED( hr ) )
        {
            hr = m_pAccess->GetPropertyHandle(L"Timestamp_Sys100NS", 0, &lHandle);
            if( SUCCEEDED(hr))
            {
	            LARGE_INTEGER Sys;
                Sys.QuadPart = Counter.QuadPart / 100;
                hr = m_pAccessInstance->WriteQWORD(lHandle, Sys.QuadPart);
            }
        }
    }

    //=========================================================================================================
    // Frequency_PerfTime = the value returned by QueryPerformanceFrequency
    //=========================================================================================================
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pAccess->GetPropertyHandle(L"Timestamp_PerfTime", 0, &lHandle);
        if( SUCCEEDED(hr))
        {
            LARGE_INTEGER freq;
            if( QueryPerformanceFrequency (&freq))
            {
                hr = m_pAccessInstance->WriteQWORD(lHandle, freq.QuadPart);
            }
        }
    }
     

    //=========================================================================================================
    // Timestamp_Object = (WnodeHeader)->TimeStamp
    //=========================================================================================================
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pAccess->GetPropertyHandle(L"Timestamp_Object", 0, &lHandle);
        if( SUCCEEDED(hr))
        {
            hr = m_pAccessInstance->WriteQWORD(lHandle, TimeStamp.QuadPart);
        }
    }

    //=========================================================================================================
    // Frequency_Sys100NS = 10000000
    // Frequency_Object = 10000000
    //=========================================================================================================
    if ( SUCCEEDED( hr ) )
    {
        LARGE_INTEGER Tmp;
        Tmp.QuadPart = 10000000;
        hr = m_pAccess->GetPropertyHandle(L"Frequency_Object", 0, &lHandle);
        if( SUCCEEDED(hr))
        {
            hr = m_pAccessInstance->WriteQWORD(lHandle, Tmp.QuadPart);
        }
        hr = m_pAccess->GetPropertyHandle(L"Frequency_Sys100NS", 0, &lHandle);
        if( SUCCEEDED(hr))
        {
            hr = m_pAccessInstance->WriteQWORD(lHandle, Tmp.QuadPart);
        }
    }

    
    return hr;
}
/////////////////////////////////////////////////////////////////////
void CWMIProcessClass::SetActiveProperty()  
{ 
    CVARIANT vActive; 
    vActive.SetBool(TRUE);  

    if( !m_fHiPerf )
    {
        m_pClassInstance->Put(L"Active", 0, &vActive, NULL);
    }
}

/////////////////////////////////////////////////////////////////////
void CWMIProcessClass::ReleaseInstancePointers()
{
    SAFE_RELEASE_PTR( m_pClassInstance );
    SAFE_RELEASE_PTR( m_pAccessInstance);
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SendInstanceBack()
{
    HRESULT hr = WBEM_E_FAILED;
	//===============================================
	// Send the object to the caller
	//===============================================
	if( HANDLER )
    {
        hr = HANDLER->Indicate(1,&m_pClassInstance);
        if( m_fGetNewInstance )
        {
            ReleaseInstancePointers();
	    }
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SetInstanceName(WCHAR * wName, BOOL fSetName)
{
    CVARIANT varName(wName);
    HRESULT  hr = WBEM_E_INVALID_OBJECT;

    if( fSetName )
    {
        if( m_pClassInstance )
        {
            if( !m_fHiPerf )
            {
                hr = m_pClassInstance->Put(L"InstanceName", 0, &varName, NULL);
            }
            else
            {
                hr = m_pClassInstance->Put(L"InstanceName", 0, &varName, NULL);
            }
        }
    }
    else
    {
        hr = SetClassName(wName);
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetInstanceName(WCHAR *& p)
{
    CVARIANT vValue;

    HRESULT hr = m_pClass->Get(L"InstanceName", 0, &vValue, NULL, NULL);		
	if( SUCCEEDED(hr) )
    {
		if( vValue.GetStr() )
        {	        	
			int nlen = wcslen(vValue.GetStr());
            p = new WCHAR [nlen + 4];
            if( p )
            {
                wcscpy(p,vValue.GetStr());
            }
            else
            {
                hr = WBEM_E_UNEXPECTED;
            } 
        }
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetPropertiesInIDOrder(BOOL fHiPerf)
{
    HRESULT hr = S_OK;
    //============================================
    //  If the pointer is NOT = to NULL, then this
    //  means we haven't released the previous one
    //  return FALSE, to prevent memory leaks
    //============================================
    if( !m_pCurrentProperty )
    {
	    m_pCurrentProperty = new CWMI_IDOrder(m_pClass,m_pAccess);
	    if( m_pCurrentProperty )
        {
            try
            {
			    hr = m_pCurrentProperty->GetPropertiesInIDOrder(fHiPerf);
			    if( hr != S_OK )
                {
                    SAFE_DELETE_PTR(m_pCurrentProperty);
			    }
		    }
            catch(...)
            {
                hr = WBEM_E_UNEXPECTED;
                SAFE_DELETE_PTR(m_pCurrentProperty);
                throw;
            }
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// NAME			GetQualifierString (takes a class name)
// PURPOSE		Gets a qualifier value and returns it as a wide char string
// WRAPPER		High level
//
// PARAMETERS	(1) [in] Pointer to an existing IWbemClassObject
//				(2) [in] Pointer to a Property Name string 
//				(3) [in] Pointer to a Qualifier Name 
//				(4) [in\out] Pointer to an external character buffer
//
// RETURNS		Success:  S_OK
//				Failure:  non zero value
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetQualifierString( WCHAR * ppwcsPropertyName, 
     						                WCHAR * pwcsQualifierName, 
                                            WCHAR * pwcsExternalOutputBuffer,
											int nSize )
{
	CVARIANT vQual;
	HRESULT hr = GetQualifierValue( ppwcsPropertyName, pwcsQualifierName, (CVARIANT*)&vQual);
    if (WBEM_S_NO_ERROR == hr)
    {
		if(vQual.GetType() != VT_BSTR)
        {		
    		VariantChangeType(&vQual, &vQual, 0, VT_BSTR);
		}
		int nTmp=wcslen(V_BSTR(&vQual));
		if( nTmp > nSize )
        {
			hr = WBEM_E_BUFFER_TOO_SMALL;
		}
		else
        {
	    	wcscat(pwcsExternalOutputBuffer, V_BSTR(&vQual));
		}
	}
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetQualifierValue( WCHAR * ppwcsPropertyName, WCHAR * pwcsQualifierName, CVARIANT * vQual )
{
	IWbemClassObject * pClass = NULL;
    IWbemQualifierSet * pIWbemQualifierSet = NULL;
	CBSTR cbstr(m_pwcsClassName);


	HRESULT hr = SERVICES->GetObject(cbstr, 0,CONTEXT, &pClass, NULL);
	if (WBEM_S_NO_ERROR != hr)
    {
		return WBEM_E_INVALID_PARAMETER;
    }

    if(ppwcsPropertyName)
    {
        pClass->GetPropertyQualifierSet(ppwcsPropertyName, &pIWbemQualifierSet);
    }
    else
    {
        pClass->GetQualifierSet(&pIWbemQualifierSet);
    }

	if( pIWbemQualifierSet ) 
    {
        long lType = 0L;
		hr = pIWbemQualifierSet->Get(pwcsQualifierName, 0,(VARIANT *) vQual,&lType);
	}

    SAFE_RELEASE_PTR(pIWbemQualifierSet);
    SAFE_RELEASE_PTR(pClass);

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetPrivilegesQualifer(SAFEARRAY ** psaPrivReq)
{
	IWbemClassObject * pClass = NULL;
    IWbemQualifierSet * pIWbemQualifierSet = NULL;
	CBSTR cbstr(m_pwcsClassName);


	HRESULT hr = SERVICES->GetObject(cbstr, 0,CONTEXT, &pClass, NULL);
    if(SUCCEEDED(hr))
    {
        pClass->GetQualifierSet(&pIWbemQualifierSet);
	    if( pIWbemQualifierSet ) {

		    CVARIANT vQual;
            long lType = 0L;

		    hr = pIWbemQualifierSet->Get(L"Privileges", 0, &vQual,&lType);
		    if (SUCCEEDED(hr)){

			    VARIANT *p = (VARIANT *)vQual;
			    SAFEARRAY * psa = V_ARRAY(p);

			    if( !IsBadReadPtr( psaPrivReq, sizeof(SAFEARRAY)))
                {
			        CSAFEARRAY Safe(psa);
			        *psaPrivReq = OMSSafeArrayCreate(VT_BSTR,Safe.GetNumElements());
			        hr = SafeArrayCopy(psa,psaPrivReq );
			        Safe.Unbind();
        		    // Don't need to destroy, it will be destroyed
                }
		    }
            SAFE_RELEASE_PTR(pIWbemQualifierSet);
        }
	}

    SAFE_RELEASE_PTR(pClass);
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetGuid(void)
{
	WCHAR pwcsGuidString[128];
    HRESULT hr = S_OK;

	//=======================================
	//  Initialize ptrs we will need
	//=======================================
    if( m_wHardCodedGuid ){
        wcscpy( pwcsGuidString,WMI_BINARY_MOF_GUID);
    }
    else{
        memset(pwcsGuidString,NULL,128);
	    hr = GetQualifierString( NULL, L"guid", pwcsGuidString,128);
    }
	if(SUCCEEDED(hr))
    {  
        //===========================================================
        //  Set the GUID first, before we try to open the WMI
        //  data block, if succeeds, then open WMI
	    //===========================================================
        if( !SetGuid(pwcsGuidString,m_Guid) )
        {
            hr = WBEM_E_FAILED;
        }
    }
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SetClass(WCHAR * wcsClass)
{
    HRESULT hr = WBEM_E_FAILED;
    if( wcsClass )
    {
        hr = SetClassName(wcsClass);
        if( SUCCEEDED(hr))
        {
			CBSTR cbstr(m_pwcsClassName);

            hr = m_pWMI->Services()->GetObject(cbstr,0,CONTEXT,&m_pClass, NULL);
            if( hr == S_OK )
            {
                hr = GetGuid();
				// If there is no GUID for the class then set proper error message
				if(hr == WBEM_E_NOT_FOUND)
				{
					hr = WBEM_E_NOT_SUPPORTED;
				}
                if( SUCCEEDED(hr))
                {
                    //===========================================================
                	// Get the IWbemObjectAccess interface for the object
	                // ==========================================================
                    if( m_fHiPerf )
                    {
            	        hr = m_pClass->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&m_pAccess);
                    }
                    if( SUCCEEDED(hr))
                    {
                        hr = GetPropertiesInIDOrder(m_fHiPerf);
                    }
                }
            }
        }
    }
	return hr;
}
//=============================================================
//=============================================================
HRESULT CWMIProcessClass::SetClassName(WCHAR * pIn )
{
    SAFE_DELETE_ARRAY(m_pwcsClassName); 
    return AllocAndCopy(pIn,&m_pwcsClassName);
}
//=============================================================
HRESULT CWMIProcessClass::SetClass(IWbemClassObject * pPtr)
{
    HRESULT hr = WBEM_E_FAILED;

    if( pPtr )
    {
        m_pClass = pPtr;
		CVARIANT vName;
        hr = m_pClass->Get(L"__CLASS", 0, &vName, NULL, NULL);		
        if( hr == S_OK )
        {
            hr = SetClassName(vName.GetStr());
            if( SUCCEEDED(hr))
            {
       		    hr = GetPropertiesInIDOrder(FALSE);
            }
        }
    }
	return hr;
}
//=============================================================
HRESULT CWMIProcessClass::SetAccess(IWbemObjectAccess * pPtr)
{
    HRESULT hr = WBEM_E_FAILED;

    if( pPtr )
    {
        SAFE_RELEASE_PTR(m_pAccess);
        SAFE_RELEASE_PTR(m_pClass);

        m_pAccess = pPtr;
        m_pAccess->AddRef();

        CVARIANT vName;
        hr = m_pAccess->Get(L"__CLASS", 0, &vName, NULL, NULL);		
        if( SUCCEEDED(hr))
        {
            hr = SetClassName(vName.GetStr());
            if( hr == S_OK )
            {
				CBSTR cbstr(m_pwcsClassName);

            	hr = SERVICES->GetObject(cbstr, 0,CONTEXT, &m_pClass, NULL);
                if( SUCCEEDED(hr))
                {
                    hr = GetGuid();
                    if( SUCCEEDED(hr))
                    {
       		            hr = GetPropertiesInIDOrder(TRUE);
                    }
                }
            }
        }
    }
	return hr;
}
//=============================================================
HRESULT CWMIProcessClass::SetClassPointerOnly(IWbemClassObject * pPtr)
{
    HRESULT hr = WBEM_E_FAILED;

    if( pPtr )
    {
        SAFE_RELEASE_PTR(m_pClass);
        m_pClass = pPtr;
		m_pClass->AddRef();
		hr = S_OK;
	}
    return hr;
}
//=============================================================
void CWMIProcessClass::SaveEmbeddedClass(CVARIANT & v)
{
	IDispatch * pAlterEgo = NULL;
	m_pClassInstance->QueryInterface(IID_IUnknown, (void**)&pAlterEgo);
	// VariantClear will call release()
	v.SetUnknown(pAlterEgo);
}
//=============================================================
HRESULT CWMIProcessClass::ReadEmbeddedClassInstance( IUnknown * pUnknown, CVARIANT & v )
{
    HRESULT hr = WBEM_E_FAILED;
    //=============================================
    //  Get the class
    //=============================================
	IUnknown * pUnk = NULL;
	if( pUnknown )
    {
		pUnk = pUnknown;
	}
	else
    {
		pUnk = v.GetUnknown();
	}

	IWbemClassObject * pClass = NULL;
	if( pUnk )
    {
		pUnk->QueryInterface(IID_IWbemClassObject,(void**) &pClass );
		if( pClass )
        {
            //===============================================
            // Get class definition, so we need to get the
            // class name
            CVARIANT vName;
            CAutoWChar wcsClassName(_MAX_PATH+2);
			if( wcsClassName.Valid() )
			{
				hr = pClass->Get(L"__CLASS", 0, &vName, NULL, NULL);		
				if( hr == S_OK )
				{
					wcscpy( wcsClassName,vName.GetStr());
            		hr = SetClass(wcsClassName);
					if( S_OK == hr )
					{
						hr = SetClassPointerOnly(pClass);
					}
				}
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
        }
    }
    SAFE_RELEASE_PTR( pClass );

    return hr;
}
//=======================================================================
int CWMIProcessClass::PropertyCategory()
{
  	if (!(m_pCurrentProperty->PropertyType() & CIM_FLAG_ARRAY) )
    {
		if( m_pCurrentProperty->PropertyType() == VT_UNKNOWN )
        {
            return CWMIProcessClass::EmbeddedClass;
		}
		else
        {
            return CWMIProcessClass::Data;
		}
	}
	else
    {
        return CWMIProcessClass::Array;
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::InitializeEmbeddedClass(CWMIProcessClass * p)
{
   SetWMIPointers(p);
   return SetClass(p->EmbeddedClassName());
}

//=======================================================================
HRESULT CWMIProcessClass::GetLargestDataTypeInClass(int & nSize)
{
    HRESULT hr = WBEM_E_FAILED;
    WCHAR * pwcsProperty;
    BOOL fClassContainsAnotherDataTypeBesidesAnEmbeddedClass = FALSE;
    int nNewSize = 0L;

    nSize = 0L;
    //=========================================================
    //  Get size of largest data type within the class and 
    //  align it on that, however, if the class contains an 
    //  embedded class ONLY, then get the size of the largest 
    //  datatype within that embedded class.
    //=========================================================
    pwcsProperty = FirstProperty();

    while (NULL != pwcsProperty)
    {
        switch( PropertyCategory())
        {
            case CWMIProcessClass::EmbeddedClass:
                {
                    if( !fClassContainsAnotherDataTypeBesidesAnEmbeddedClass ){
                        CWMIProcessClass EmbeddedClass(0);
						
						hr = EmbeddedClass.Initialize();
						if( S_OK == hr )
						{
							hr = EmbeddedClass.InitializeEmbeddedClass(this);
     						if( hr != S_OK ){
								break;
							}

							// embedded object
							hr = EmbeddedClass.GetLargestDataTypeInClass(nNewSize);
							if( hr != S_OK ){
								break;
							}
						}
                    }
                }
   		        break;

            case CWMIProcessClass::Array:
            case CWMIProcessClass::Data:
                fClassContainsAnotherDataTypeBesidesAnEmbeddedClass = TRUE;
           	    nNewSize = PropertySize();
	            break;
        }

		if( nNewSize == SIZEOFWBEMDATETIME ){
			nNewSize = 1;
		}

        if( nNewSize > nSize ){
            nSize = nNewSize;
        }

        pwcsProperty = NextProperty();
		hr = WBEM_S_NO_ERROR;
    }

    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetSizeOfArray(long & lType, DWORD & dwCount, BOOL & fDynamic)
{
	HRESULT  hr = WBEM_E_OUT_OF_MEMORY;
    CAutoWChar pwcsArraySize(_MAX_PATH+2);

	if( pwcsArraySize.Valid() )
	{
		dwCount = 0;
		lType = m_pCurrentProperty->PropertyType() &~  CIM_FLAG_ARRAY;
		
		pwcsArraySize[0]=NULL;
		//======================================================
		// Get the number of elements in the array from the 			
		// "ArraySize" property qualifier
		//======================================================
		hr = GetQualifierString(m_pCurrentProperty->PropertyName(), L"MAX",pwcsArraySize, MAX_PATH);
		if( hr == S_OK )
		{
			CAnsiUnicode XLate;
			char * pChar = NULL;

			if( SUCCEEDED(XLate.UnicodeToAnsi(pwcsArraySize, pChar )))
			{
				if( pChar )
				{
					dwCount = atol(pChar);
					SAFE_DELETE_ARRAY(pChar);
				}
			}	
		}
		else
		{
			hr = GetQualifierString(m_pCurrentProperty->PropertyName(),L"WMISizeIs",pwcsArraySize,MAX_PATH);
			if( hr == S_OK )
			{
				CVARIANT var;
				CIMTYPE lTmpType;
				hr = WBEM_E_FAILED;

				fDynamic = TRUE;

				if( m_pClassInstance )
				{
					hr = m_pClassInstance->Get(pwcsArraySize, 0, &var, &lTmpType,NULL);		
				}
				else
				{
					if( m_pClass )
					{
						hr = m_pClass->Get(pwcsArraySize, 0, &var, &lTmpType,NULL);
					}
				}
				if( hr == S_OK )
				{
           			CWMIDataTypeMap MapIt;
					dwCount = MapIt.ArraySize(lTmpType,var);
				}
			}
		}

		//==============================================================================
		//  If all else fails, get the size of the array from the class definition.
		//==============================================================================
		if( hr != S_OK )
		{
    		dwCount = m_pCurrentProperty->ArraySize();
			hr = S_OK;
		}
	}
    return hr;
}        
//======================================================================
HRESULT CWMIProcessClass::GetSizeOfClass(DWORD & dwSize)
{
    HRESULT hr = WBEM_E_FAILED;
    WCHAR * pwcsProperty;

    dwSize = 0;

    pwcsProperty = FirstProperty();

    while (NULL != pwcsProperty)
    {
        switch( PropertyCategory())
        {
            case CWMIProcessClass::EmbeddedClass:
                {
                    DWORD dwEmbeddedSize;
                    CWMIProcessClass EmbeddedClass(0);

					hr = EmbeddedClass.Initialize();
					if( S_OK == hr )
					{
						hr = EmbeddedClass.InitializeEmbeddedClass(this);
						if( hr != S_OK ){
							break;
						}
						// embedded object
						hr = EmbeddedClass.GetSizeOfClass(dwEmbeddedSize);
						if( hr != S_OK ){
							break;
						}
						dwSize += dwEmbeddedSize;
					}
                }
   		        break;

            case CWMIProcessClass::Array:
                {
            	    int nSize = PropertySize();
                    dwSize += (nSize *  ArraySize());
                }
	            break;

            case CWMIProcessClass::Data:
                dwSize += PropertySize();
	            break;
        }
        pwcsProperty = NextProperty();
		hr = WBEM_S_NO_ERROR;
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////

ULONG CWMIProcessClass::GetMethodId(LPCWSTR strProp)
{
	ULONG uMethodId = 0;
	IWbemQualifierSet * pIWbemQualifierSet = NULL;
	
	//======================================================
	// Get the number of elements in the array from the 			
	// "ArraySize" property qualifier
	//======================================================
    HRESULT hr = m_pClass->GetMethodQualifierSet(strProp,&pIWbemQualifierSet);
	if( SUCCEEDED(hr) )
    {
        CVARIANT v;
		hr = pIWbemQualifierSet->Get(L"WMIMethodId", 0, &v, 0);
		if( SUCCEEDED(hr))
        {
            uMethodId = v.GetLONG();
		}
        SAFE_RELEASE_PTR(pIWbemQualifierSet);
    }
    return uMethodId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmicom.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "wmicom.h"
#include "wmimof.h"
#include "wmimap.h"
#include <stdlib.h>
#include <winerror.h>
#include <TCHAR.h>

////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//  Global Utility Functions
//**********************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsBinaryMofResourceEvent(LPOLESTR pGuid, GUID gGuid)
{
	HRESULT hr;
	GUID Guid;

	hr = CLSIDFromString(pGuid,&Guid);
	if( SUCCEEDED(hr) )
    {
		if( gGuid == Guid)
        {
			return TRUE;
		}
	}

    return FALSE;
}
/////////////////////////////////////////////////////////////////////
BOOL GetParsedPropertiesAndClass( BSTR Query,WCHAR * wcsClass )
{
	ParsedObjectPath   * pParsedPath = NULL;										// stdlibrary API
	CObjectPathParser   Parser;	
    BOOL fRc = FALSE;

    if( CObjectPathParser::NoError == Parser.Parse(Query, &pParsedPath))
    {
        try
        {
			// NTRaid:136400
			// 07/12/00
            if(pParsedPath && !IsBadReadPtr( pParsedPath, sizeof(ParsedObjectPath)))
            {
            	KeyRef * pKeyRef = NULL;
        	    pKeyRef = *(pParsedPath->m_paKeys);
                if(!IsBadReadPtr( pKeyRef, sizeof(KeyRef)))
                {
                    wcscpy(wcsClass,pParsedPath->m_pClass);
                    fRc = TRUE;
                }
            }

  	        Parser.Free(pParsedPath);
        }
        catch(...)
        {
            Parser.Free(pParsedPath);
            throw;
        }
    }

    return fRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CheckIfThisIsAValidKeyProperty(WCHAR * wcsClass, WCHAR * wcsProperty, IWbemServices * p)
{
	HRESULT hr = WBEM_E_FAILED;
	IWbemClassObject * pIHCO = NULL;
    IWbemQualifierSet * pIWbemQualifierSet = NULL;
    long lType = 0L;
	BSTR strPath = NULL;


	strPath = SysAllocString(wcsClass);
	if(strPath == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		hr = p->GetObject(strPath, 0,NULL, &pIHCO, NULL);
		SysFreeString(strPath);
		if (WBEM_S_NO_ERROR != hr)
			return WBEM_E_INVALID_CLASS;

		if(wcsProperty){
			hr = pIHCO->GetPropertyQualifierSet(wcsProperty,&pIWbemQualifierSet);
			if( SUCCEEDED(hr) ){

           		CVARIANT v;
	    		hr = pIWbemQualifierSet->Get(L"key", 0, &v, 0);
				SAFE_RELEASE_PTR(pIWbemQualifierSet);
			}
			else{
				hr = WBEM_E_INVALID_OBJECT_PATH;
			}
		}

		//============================================================
		//  Cleanup
		//============================================================
		SAFE_RELEASE_PTR(pIHCO);
	}
	return hr;

}
//====================================================================
HRESULT GetParsedPath( BSTR ObjectPath,WCHAR * wcsClass, WCHAR * wcsInstance,IWbemServices * p )
{
    //============================================================
	//  Get the path and instance name and check to make sure it
    //  is valid
	//============================================================
	ParsedObjectPath   * pParsedPath = NULL;										// stdlibrary API
	CObjectPathParser   Parser;	
    HRESULT hr = WBEM_E_FAILED;

    if( 0 == Parser.Parse(ObjectPath, &pParsedPath))
    {
        try
        {
			// NTRaid:136395
			// 07/12/00
            if(pParsedPath && !IsBadReadPtr( pParsedPath, sizeof(ParsedObjectPath)))
            {
            	KeyRef * pKeyRef = NULL;
                pKeyRef = *(pParsedPath->m_paKeys);
                if( !IsBadReadPtr( pKeyRef, sizeof(KeyRef)))
                {
                    hr = CheckIfThisIsAValidKeyProperty(pParsedPath->m_pClass, pKeyRef->m_pName,p );
			        if( SUCCEEDED(hr) )
                    {
				        wcscpy(wcsClass,pParsedPath->m_pClass);
				        wcscpy(wcsInstance,pKeyRef->m_vValue.bstrVal);
			        }
                }
            }
  	        Parser.Free(pParsedPath);
        }
        catch(...)
        {
            hr = WBEM_E_UNEXPECTED;
            Parser.Free(pParsedPath);
            throw;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetUserThreadToken(HANDLE * phThreadTok)
{
    BOOL fRc = FALSE;

	HRESULT hRes = WbemCoImpersonateClient();
    if (SUCCEEDED(hRes))
    {
		// Now, let's check the impersonation level.  First, get the thread token
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, phThreadTok))
        {
            // If the CoImpersonate works, but the OpenThreadToken fails, we are running under the
            // process token (either local system, or if we are running with /exe, the rights of
            // the logged in user).  In either case, impersonation rights don't apply.  We have the
            // full rights of that user.

             if(GetLastError() == ERROR_NO_TOKEN)
             {
                // Try getting the thread token.  If it fails it's because we're a system thread and
                // we don't yet have a thread token, so just impersonate self and try again.
                if( ImpersonateSelf(SecurityImpersonation) )
                {
                    if (!OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, phThreadTok))
                    {
                        fRc = FALSE;
                    }
                    else
                    {
                        fRc = TRUE;
                    }
                }
                else
                {
                    ERRORTRACE((THISPROVIDER,"ImpersonateSelf(SecurityImpersonation)failed"));
                }
            }
         }
         else
         {
             fRc = TRUE;
         }
	}
    if( !fRc )
    {
	    ERRORTRACE((THISPROVIDER,IDS_ImpersonationFailed));
    }
    return fRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////

SAFEARRAY * OMSSafeArrayCreate( IN VARTYPE vt, IN int iNumElements)
{
    if(iNumElements < 1)
    {
        return NULL;
    }
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    return SafeArrayCreate(vt,1,rgsabound);
}
////////////////////////////////////////////////////////////////////////////////////////////////
void TranslateAndLog( WCHAR * wcsMsg )
{
    CAnsiUnicode XLate;
    char * pStr = NULL;

	if( SUCCEEDED(XLate.UnicodeToAnsi(wcsMsg,pStr)))
    {
		ERRORTRACE((THISPROVIDER,pStr));
   		ERRORTRACE((THISPROVIDER,"\n"));
        SAFE_DELETE_ARRAY(pStr);
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////
bool IsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}
////////////////////////////////////////////////////////////////////
BOOL SetGuid(WCHAR * pwcsGuidString, CLSID & Guid)
{
	BOOL fRc = FALSE;
    CAutoWChar wcsGuid(MAX_PATH+2);

	if( wcsGuid.Valid() )
	{
		fRc = TRUE;
		swprintf(wcsGuid,L"{%s}",pwcsGuidString );		

		if(FAILED(CLSIDFromString(wcsGuid, &Guid)))
		{
			if( FAILED(CLSIDFromString(pwcsGuidString, &Guid)))
			{
				fRc = FALSE;
			}
		}	
	}
    return fRc;
}
////////////////////////////////////////////////////////////////////
HRESULT AllocAndCopy(WCHAR * wcsSource, WCHAR ** pwcsDest )
{
    HRESULT hr = WBEM_E_FAILED;

    int nLen = wcslen(wcsSource);
    if( nLen > 0 )
    {
       *pwcsDest = new WCHAR[nLen + 2 ];
       if( *pwcsDest )
       {
          wcscpy(*pwcsDest,wcsSource);
          hr = S_OK;
       }
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//  Utility Classes
//**********************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////
void _WMIHandleMap::AddRef()
{
  InterlockedIncrement((long*)&RefCount);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
long _WMIHandleMap::Release()
{
  	ULONG cRef = InterlockedDecrement( (long*) &RefCount);
	if ( !cRef ){
        WmiCloseBlock(WMIHandle);
		return 0;
	}
	return cRef;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_WMIEventRequest::_WMIEventRequest()
{
    pwcsClass = NULL ;
    pHandler = NULL;
    pServices = NULL;
    pCtx = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_WMIEventRequest::~_WMIEventRequest()
{
    SAFE_RELEASE_PTR(pServices);
    SAFE_RELEASE_PTR(pCtx);
    SAFE_DELETE_ARRAY(pwcsClass);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
void _WMIEventRequest::AddPtrs( IWbemObjectSink __RPC_FAR * Handler,IWbemServices __RPC_FAR * Services,IWbemContext __RPC_FAR * Ctx)
{
    pHandler = Handler;
    pServices = Services;
    pCtx = Ctx;
    if( pServices ){
        pServices->AddRef();
    }
    if( pCtx ){
        pCtx->AddRef();
    }
    return;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_AccessList::~_AccessList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        IWbemObjectAccess * pPtr = (IWbemObjectAccess *)m_List[i];
        SAFE_RELEASE_PTR(pPtr);
    }
    m_List.Empty();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_IdList::~_IdList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        ULONG_PTR* pPtr = (ULONG_PTR*)m_List[i];
        SAFE_DELETE_PTR(pPtr);
    }
    m_List.Empty();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
_HandleList::~_HandleList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        HANDLE * pPtr = (HANDLE*)m_List[i];
        SAFE_DELETE_PTR(pPtr);
    }
    m_List.Empty();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_InstanceList::~_InstanceList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        WCHAR * p = (WCHAR*)m_List[i];
        SAFE_DELETE_ARRAY(p);
    }
    m_List.Empty();
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
_OldClassInfo::~_OldClassInfo()
{
     SAFE_DELETE_ARRAY(m_pClass);
     SAFE_DELETE_ARRAY(m_pPath);
     m_pClass = m_pPath = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_OldClassList::~_OldClassList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        OldClassInfo * p = (OldClassInfo*)m_List[i];
        SAFE_DELETE_PTR(p);
    }
    m_List.Empty();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
_WMIHiPerfHandleMap::_WMIHiPerfHandleMap(CWMIProcessClass * p, IWbemHiPerfEnum * pEnum)
{
    m_pEnum = pEnum;
    if( pEnum )
    {
        pEnum->AddRef();
    }
    m_pClass = p;
    m_fEnumerator = FALSE;
    lHiPerfId = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_WMIHiPerfHandleMap::~_WMIHiPerfHandleMap()
{
    SAFE_RELEASE_PTR(m_pEnum);
    lHiPerfId = 0;
    SAFE_DELETE_PTR(m_pClass);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Hi Perf Handle Map = Handles are addref'd and when released, then the block is closed
//  Critical Sections are handled elsewhere
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CHiPerfHandleMap::Add( HANDLE hCurrent, ULONG_PTR lHiPerfId, CWMIProcessClass * p, IWbemHiPerfEnum * pEnum)
{
    HRESULT hr = S_OK;

	WMIHiPerfHandleMap * pWMIMap = new WMIHiPerfHandleMap(p,pEnum);
    if( pWMIMap )
    {
        try
        {
    	    pWMIMap->WMIHandle = hCurrent;
            pWMIMap->lHiPerfId = lHiPerfId;
			// 170635
 	        if(CFlexArray::out_of_memory == m_List.Add(pWMIMap))
			{
				SAFE_DELETE_PTR(pWMIMap);
				hr = E_OUTOFMEMORY;
			}
        }
        catch(...)
        {
            hr = WBEM_E_UNEXPECTED;
            SAFE_DELETE_PTR(pWMIMap);
            throw;
        }
	}

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CHiPerfHandleMap::FindHandleAndGetClassPtr( HANDLE & hCurrent, ULONG_PTR lHiPerfId,CWMIProcessClass *& p)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    for( int i=0; i<m_List.Size(); i++)
    {
        //===================================================
        //
        //===================================================
        WMIHiPerfHandleMap * pMap = (WMIHiPerfHandleMap *) m_List[i];
        if( pMap->lHiPerfId == lHiPerfId )
        {
            hCurrent = pMap->WMIHandle;
            p = pMap->m_pClass;
            hr = S_OK;
        }
    }

    return hr;

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CHiPerfHandleMap::GetFirstHandle(HANDLE & hCurrent,CWMIProcessClass *& p, IWbemHiPerfEnum *& pEnum)
{
    m_nIndex=0;
    return GetNextHandle(hCurrent,p,pEnum);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CHiPerfHandleMap::GetNextHandle(HANDLE & hCurrent,CWMIProcessClass *& p, IWbemHiPerfEnum *& pEnum)
{
    HRESULT hr = WBEM_S_NO_MORE_DATA;

    if( m_nIndex < m_List.Size() )
    {
        WMIHiPerfHandleMap * pMap = (WMIHiPerfHandleMap *) m_List[m_nIndex];
        hCurrent = pMap->WMIHandle;
        p = pMap->m_pClass;
        pEnum = pMap->m_pEnum;
        m_nIndex++;
        hr = S_OK;
    }
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CHiPerfHandleMap::Delete( HANDLE & hCurrent, ULONG_PTR lHiPerfId )
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    for( int i=0; i<m_List.Size(); i++)
    {
        //===================================================
        //
        //===================================================
        WMIHiPerfHandleMap * pMap = (WMIHiPerfHandleMap *) m_List[i];
        if( pMap->lHiPerfId == lHiPerfId )
        {
            hCurrent = pMap->WMIHandle;
            SAFE_DELETE_PTR(pMap);
            m_List.RemoveAt(i);
            hr = S_OK;
            break;
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//  When this function is called, release all the handles kept
// THis function is called in the destructor of the class to release all teh WMIHiPerfHandleMap
// classes allocated
////////////////////////////////////////////////////////////////////////////////////////////////
void CHiPerfHandleMap::CloseAndReleaseHandles()
{
	//===================================
	//  Go through the handles one at
	//  a time and close them, then
	//  delete the records from the
	//  array
	//===================================

    CAutoBlock((CCriticalSection *)&m_HandleCs);

    if( m_List.Size() > 0 ){

        for(int i = 0; i < m_List.Size(); i++){
    		
		    WMIHiPerfHandleMap * pWMIMap = (WMIHiPerfHandleMap *) m_List[i];
            SAFE_DELETE_PTR(pWMIMap);
	    }

	    //==================================================
	    //  Remove it and deallocate memory
	    //==================================================
        m_List.Empty();
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Regular Handle Map = Expensize handles are always kept open - by default we, dont' know the lifetime
//  of these handles
///////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CHandleMap::Add(CLSID Guid, HANDLE hCurrent, ULONG uDesiredAccess)
{
    // Critical section is called elsewhere

    HRESULT hr = S_OK;

	WMIHandleMap * pWMIMap = new WMIHandleMap();
    if( pWMIMap )
    {
	    try
        {
            pWMIMap->AddRef();                          // Used for HiPerf counts, otherwise not referenced
    		pWMIMap->WMIHandle = hCurrent;
		    pWMIMap->Guid = Guid;
		    pWMIMap->uDesiredAccess = uDesiredAccess;

			// 170635
		    if(CFlexArray::out_of_memory == m_List.Add(pWMIMap))
			{
				hr = E_OUTOFMEMORY;
				SAFE_DELETE_PTR(pWMIMap);
			}
	    }
        catch(...)
        {
            hr = WBEM_E_UNEXPECTED;
            SAFE_DELETE_PTR(pWMIMap);
            throw;
        }
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
int CHandleMap::ExistingHandleAlreadyExistsForThisGuidUseIt(CLSID Guid,
                                                            HANDLE & hCurrentWMIHandle,
                                                            BOOL & fCloseHandle,
                                                            ULONG uDesiredAccess)
{
	int nRc = ERROR_NOT_SUPPORTED;

    // Critical section is called elsewhere

	//=====================================================
	//  Initialize stuff
	//=====================================================
	hCurrentWMIHandle = 0;
	fCloseHandle = TRUE;

    for(int i = 0; i < m_List.Size(); i++){
    		
		WMIHandleMap * pWMIMap = (WMIHandleMap*) m_List[i];
		//==================================================
		//  Compare and see if this guid already has a
		//  handle assigned for it with the access permissions
		//  that we want to use
		//==================================================
		if( pWMIMap->Guid == Guid ){
			if( pWMIMap->uDesiredAccess == uDesiredAccess ){

				hCurrentWMIHandle = pWMIMap->WMIHandle;
                pWMIMap->AddRef();                      // Used for HiPerf Handles, otherwise not needed
				nRc = ERROR_SUCCESS;
				fCloseHandle = FALSE;
				break;
			}
		}
    }

	return nRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////
//  When this function is called, we need to close all of the handles that may have been kept
//  open for accumulation purposes
////////////////////////////////////////////////////////////////////////////////////////////////
void CHandleMap::CloseAllOutstandingWMIHandles()
{
	//===================================
	//  Go through the handles one at
	//  a time and close them, then
	//  delete the records from the
	//  array
	//===================================

    CAutoBlock((CCriticalSection *)&m_HandleCs);

    if( m_List.Size() > 0 ){

        for(int i = 0; i < m_List.Size(); i++){
    		
		    WMIHandleMap * pWMIMap = (WMIHandleMap*) m_List[i];
		    //==================================================
		    //  Inform WMI we are done with this guy
		    //==================================================
            try
            {
		        WmiCloseBlock(pWMIMap->WMIHandle);
            }
            catch(...)
            {
                // don't throw
            }
            SAFE_DELETE_PTR(pWMIMap);
	    }

	    //==================================================
	    //  Remove it and deallocate memory
	    //==================================================
        m_List.Empty();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
//  Used when we know the handles lifetimes
////////////////////////////////////////////////////////////////////////////////////////////////
int CHandleMap::ReleaseHandle( HANDLE hCurrentWMIHandle )
{
	int nRc = ERROR_NOT_SUPPORTED;

    CAutoBlock((CCriticalSection *)&m_HandleCs);

    for(int i = 0; i < m_List.Size(); i++){
    		
		WMIHandleMap * pWMIMap = (WMIHandleMap*) m_List[i];

        if( pWMIMap->WMIHandle == hCurrentWMIHandle )
        {
            long RefCount = pWMIMap->Release();                      // Used for HiPerf Handles, otherwise not needed
            if( !RefCount )
            {
//                WmiCloseBlock(hCurrentWMIHandle);
                SAFE_DELETE_PTR( pWMIMap);
                m_List.RemoveAt(i);
            }
			nRc = ERROR_SUCCESS;
			break;
		}
    }

	return nRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////
int CHandleMap::GetHandle(CLSID Guid, HANDLE & hCurrentWMIHandle )
{
	int nRc = ERROR_NOT_SUPPORTED;

    CAutoBlock((CCriticalSection *)&m_HandleCs);

	//=====================================================
	//  Initialize stuff
	//=====================================================
	hCurrentWMIHandle = 0;

    for(int i = 0; i < m_List.Size(); i++){
    		
		WMIHandleMap * pWMIMap = (WMIHandleMap*) m_List[i];
		if( pWMIMap->Guid == Guid ){

			hCurrentWMIHandle = pWMIMap->WMIHandle;
            pWMIMap->AddRef();                      // Used for HiPerf Handles, otherwise not needed
			nRc = ERROR_SUCCESS;
			break;
		}
    }

	return nRc;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//  Utility Classes:  CANSIUNICODE
//**********************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CAnsiUnicode::AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW)
{
    HRESULT hr = WBEM_E_FAILED;
    pszW = NULL;

    int nSize = strlen(pstr);
    if (nSize != 0 ){

        // Determine number of wide characters to be allocated for the
        // Unicode string.
        nSize++;
		pszW = new WCHAR[nSize * 2];
		if (NULL != pszW){
    		try
            {
                // Covert to Unicode.
				MultiByteToWideChar(CP_ACP, 0, pstr, nSize,pszW,nSize);
                hr = S_OK;
	        }	
            catch(...)
            {
                SAFE_DELETE_ARRAY(pszW);
                hr = WBEM_E_UNEXPECTED;
                throw;
            }
		}
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CAnsiUnicode::UnicodeToAnsi(WCHAR * pszW, char *& pAnsi)
{
    ULONG cbAnsi, cCharacters;
    HRESULT hr = WBEM_E_FAILED;

    pAnsi = NULL;
    if (pszW != NULL){

        cCharacters = wcslen(pszW)+1;
        // Determine number of bytes to be allocated for ANSI string. An
        // ANSI string can have at most 2 bytes per character (for Double
        // Byte Character Strings.)
        cbAnsi = cCharacters*2;
		pAnsi = new char[cbAnsi];
		if (NULL != pAnsi)
        {
		    try
            {
				// Convert to ANSI.
				if (0 != WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, pAnsi, cbAnsi, NULL, NULL)){
					hr = S_OK;
	            }
		    }
            catch(...)
            {
                SAFE_DELETE_ARRAY(pAnsi);
                hr = WBEM_E_UNEXPECTED;
                throw;
            }
        }

    }
    return hr;
}
//************************************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//   CWMIManagement
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//************************************************************************************************************
CWMIManagement::CWMIManagement( )
{
    m_pHandler = NULL;
    m_pServices = NULL;
    m_pCtx = NULL;
    m_pHandleMap = NULL;
}
//////////////////////////////////////////////////////////////////////////////////////
CWMIManagement::~CWMIManagement()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIManagement::SendPrivilegeExtendedErrorObject( HRESULT hrToReturn,WCHAR * wcsClass)
{
	HRESULT hr,hRes;
	IWbemClassObject * pClass = NULL, *pInst=NULL;
    BOOL fSetStatus = FALSE;


	if( hrToReturn == WBEM_E_ACCESS_DENIED ){

		TOKEN_PRIVILEGES * ptPriv = NULL;

		hr = GetListOfUserPrivileges(ptPriv);
		if( SUCCEEDED(hr ) ){
			
			BSTR strPrivelegeStat = NULL;
			strPrivelegeStat = SysAllocString(L"Win32_PrivilegesStatus");
			if(strPrivelegeStat != NULL)
			{
				hr = m_pServices->GetObject(strPrivelegeStat, 0,m_pCtx, &pClass, NULL);
				if( hr == S_OK){	

					//=============================================================
					// Get an instance of the extended class
					//=============================================================
					hr = pClass->SpawnInstance(0,&pInst);
					SAFE_RELEASE_PTR(pClass);
			
					if( pInst ){

						CVARIANT varTmp;
						WCHAR * pwcsStr = NULL;
						CAnsiUnicode XLate;
						//=========================================================
						//  Fill in description
						//=========================================================
						XLate.AllocateAndConvertAnsiToUnicode(IDS_ImpersonationFailed,pwcsStr);
						varTmp.SetStr(pwcsStr);
						hr = pInst->Put(L"Description", 0, &varTmp, NULL);
						SAFE_DELETE_ARRAY( pwcsStr );

						//======================================================
						//  Initialize all of the necessary stuff and get the
						//  definition of the class we are working with
						//======================================================
						CWMIProcessClass ClassInfo(0);
						if( SUCCEEDED(ClassInfo.Initialize()) )
						{
							ClassInfo.WMI()->SetWMIPointers(m_pHandleMap,m_pServices,m_pHandler,m_pCtx);
							ClassInfo.SetClass(wcsClass);
							SAFEARRAY *psaPrivNotHeld=NULL;
							SAFEARRAY *psaPrivReq=NULL;

							//=========================================================
							// Get PrivilegesRequired
							// The only place to get this, if possible, is from the
							// class
							//=========================================================
					
							hRes = ClassInfo.GetPrivilegesQualifer(&psaPrivReq);
							if( hRes == WBEM_S_NO_ERROR){

								//=========================================================
								// Get PrivilegesNotHeld
								//=========================================================
								ProcessPrivileges(ptPriv,psaPrivNotHeld,psaPrivReq);
								//=========================================================
								//  Send it off
								//=========================================================
								VARIANT v;

								if( psaPrivReq ){
									VariantInit(&v);
									SAFEARRAY *pSafeArray = NULL;

									if ( SUCCEEDED ( SafeArrayCopy ((SAFEARRAY*)psaPrivReq , &pSafeArray ) ) ){
        								v.vt = VT_BSTR | VT_ARRAY;
	        							v.parray = pSafeArray;
										pInst->Put(L"PrivilegesRequired", 0, &v, NULL);
										VariantClear(&v);
									}
								}

								if( psaPrivNotHeld ){
									VariantInit(&v);
									SAFEARRAY *pSafeArray = NULL;

									if ( SUCCEEDED ( SafeArrayCopy ((SAFEARRAY*)psaPrivNotHeld , &pSafeArray ) ) ){
        								v.vt = VT_BSTR | VT_ARRAY;
	        							v.parray = pSafeArray;
										pInst->Put(L"PrivilegesNotHeld", 0, &v, NULL);
										VariantClear(&v);
									}
								}
							}
							//=========================================================
							// Now, send this guy off...
							//=========================================================
							fSetStatus = TRUE;
							hr = m_pHandler->SetStatus(0,hrToReturn,NULL,pInst);


							if (psaPrivNotHeld)
								SafeArrayDestroy(psaPrivNotHeld);
							if (psaPrivReq)
								SafeArrayDestroy(psaPrivReq);
						}

					}
					SAFE_RELEASE_PTR(pInst);
				}	
				SysFreeString(strPrivelegeStat);
			}						
		}

        SAFE_DELETE_ARRAY(ptPriv);
	}

    if( !fSetStatus ){
        hr = m_pHandler->SetStatus(0,hrToReturn,NULL,NULL);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIManagement::SetErrorMessage(HRESULT hrToReturn,WCHAR * wcsClass,WCHAR * wcsMsg)
{
	HRESULT hr;
	IWbemClassObject * pClass = NULL, *pInst=NULL;
    BOOL fSetStatus = FALSE;

    if( m_pHandler )
    {
		BSTR strExtendedStat = NULL;

	    switch( hrToReturn ){

		    case WBEM_E_ACCESS_DENIED:
			    SendPrivilegeExtendedErrorObject(hrToReturn,wcsClass);
			    break;

		    case S_OK :
		        hr = m_pHandler->SetStatus(0,hrToReturn,NULL,NULL);
			    break;

		    default:
				strExtendedStat = SysAllocString(L"__ExtendedStatus");
				if(strExtendedStat != NULL)
				{
					hr = m_pServices->GetObject(strExtendedStat, 0,m_pCtx, &pClass, NULL);
					if( hr == S_OK){	
						hr = pClass->SpawnInstance(0,&pInst);
						if( pInst ){

							CVARIANT varTmp;
							varTmp.SetStr(wcsMsg);
				
							hr = pInst->Put(L"Description", 0, &varTmp, NULL);
							hr = m_pHandler->SetStatus(0,hrToReturn,NULL,pInst);
							fSetStatus = TRUE;

							// Now log the error in the error log
							if( hrToReturn != S_OK ){
								TranslateAndLog(varTmp.GetStr());
							}
						}		
					}
					if( !fSetStatus ){
    					hr = m_pHandler->SetStatus(0,hrToReturn,NULL,NULL);
					}
					SAFE_RELEASE_PTR(pClass);
					SAFE_RELEASE_PTR(pInst);
					SysFreeString(strExtendedStat);
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			    break;
	    }
    }
    return hrToReturn;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIManagement::GetListOfUserPrivileges(TOKEN_PRIVILEGES *& ptPriv)
{
	HRESULT hr = WBEM_E_FAILED;

	//  Get the privileges this user has
	DWORD dwTokenInfoLength = 0;
	DWORD dwSize = 0;
	HANDLE hThreadTok;
	
    if (IsNT()){

		if( GetUserThreadToken(&hThreadTok) ){

		 // get information
			if (!GetTokenInformation(hThreadTok, TokenPrivileges, NULL, dwTokenInfoLength, &dwSize)){
				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER){
    				ptPriv = new TOKEN_PRIVILEGES[dwSize+2];
                    if( ptPriv )
                    {
					    try
                        {
						    dwTokenInfoLength = dwSize;
							if(GetTokenInformation(hThreadTok, TokenPrivileges, (LPVOID)ptPriv, dwTokenInfoLength, &dwSize))
                            {
								hr = WBEM_NO_ERROR;
							}
						}
                        catch(...)
                        {
                            SAFE_DELETE_ARRAY(ptPriv);
                            hr = WBEM_E_UNEXPECTED;
                            throw;
                        }
                    }
				}
			}

            // Done with this handle
            CloseHandle(hThreadTok);
 		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIManagement::ProcessPrivileges(TOKEN_PRIVILEGES *ptPriv, SAFEARRAY *& psaPrivNotHeld, SAFEARRAY * psaPrivReq )
{
	CAnsiUnicode XLate;
	BOOL fFound = FALSE;

	//==============================================================
	//  Create a temporary working array, we know the MAX can be
	//  the number of priv held + the number of priv req, so
	//  allocate it for that
	//==============================================================
	CSAFEARRAY PrivReq( psaPrivReq );
			

	long lMax = PrivReq.GetNumElements()+ptPriv->PrivilegeCount;
    psaPrivNotHeld = OMSSafeArrayCreate(VT_BSTR,lMax);	
	long nCurrentIndex = 0;

	//==============================================================
	// Get how many privs are not held
	//==============================================================
	for( long n = 0; n < PrivReq.GetNumElements(); n++ ){
		//==============================================================
		//  Now, get the privileges held array ready to put stuff in
		//==============================================================
		TCHAR * pPrivReq = NULL;
		CBSTR bstr;

        if( S_OK != PrivReq.Get(n, &bstr)){
			return;
		}
		fFound = FALSE;

#ifndef UNICODE
		XLate.UnicodeToAnsi(bstr,pPrivReq);
#else
		pPrivReq = (TCHAR *)bstr;
#endif
		// NTRaid:136384
		// 07/12/00
		if(pPrivReq)
		{

			for(int i=0;i < (int)ptPriv->PrivilegeCount;i++){
				DWORD dwPriv=128;
				TCHAR szPriv[NAME_SIZE*2];

				if( LookupPrivilegeName( NULL, &ptPriv->Privileges[i].Luid, szPriv, &dwPriv)){
						
					//==============================================
					//  If we found the privilege, then the user has
					//  it.  break out
					//==============================================
					if( _tcscmp( pPrivReq,pPrivReq ) == 0 ){
						fFound = TRUE;
						break;
					}

				}
				//==================================================
				//  If we didn't find it, then we need to add it to
				//  the list so we can notify the user
				//==================================================
				if( !fFound ){
					if( S_OK == SafeArrayPutElement(psaPrivNotHeld, &nCurrentIndex, bstr))
					{
    					nCurrentIndex++;
					}
				}
			}
		}
#ifndef UNICODE
        SAFE_DELETE_ARRAY(pPrivReq);
#else
		pPrivReq = NULL;
#endif
	}
	
	SAFEARRAYBOUND rgsabound[1];
   	rgsabound[0].lLbound = 0;
   	rgsabound[0].cElements = nCurrentIndex;
    HRESULT hr = SafeArrayRedim(psaPrivNotHeld, rgsabound);

	PrivReq.Unbind();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmimap.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "precomp.h"
#include "wmicom.h"
#include "wmimap.h"
#include <stdlib.h>
#include <CWbemTime.h>

/*
These are the types we support
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_FLAG_ARRAY	= 0x2000
*/
BOOL ValidateDateTime(WCHAR * wcsValue)
{
	BOOL fRc = FALSE;
    // Pre-test
    // ========
    	
    CAnsiUnicode XLate;
    char * psz = NULL;
    
    XLate.UnicodeToAnsi(wcsValue,psz);
    if( psz )
    {
        if(strlen(psz) == 25){

	        if(psz[14] != '.' && psz[14] != '*'){
			    goto ExitValidateTime;
		    }

		    if(psz[21] != ':' && psz[21] != '-' && psz[21] != '+' && psz[21] != '*'){
			    goto ExitValidateTime;
		    }

	        for(int i = 0; i < 25; i++){
			    if(i == 21 || i == 14)
				    continue;
			    if(psz[i] != '*' && !isdigit(psz[i])){
				    goto ExitValidateTime;
                }

	        }

		    // Passed pre-test. Check if any stars were specified
		    // ==================================================

		    if(strchr(psz, '*')) {
			    // No further checking
			    fRc = TRUE;
			    goto ExitValidateTime;
		    }

		    if(psz[21] == ':'){
            // Interval -- no checking
			    fRc = TRUE;
			    goto ExitValidateTime;
	        }

		    WCHAR wcsTmp[SIZEOFWBEMDATETIME+2];
		    wcscpy(wcsTmp,wcsValue);

		    CWbemTime Time;
		    fRc = Time.SetDMTF(wcsTmp);

	    }
    }

ExitValidateTime:

    SAFE_DELETE_ARRAY( psz );

    return fRc;
}

//=============================================================
BOOL CWMIDataTypeMap::ConvertDWORDToWMIDataTypeAndWriteItToBlock(DWORD dwLong, int nSize )
{
    BOOL fRc = FALSE;
    if( NaturallyAlignData( nSize, WRITE_IT)){
        if( nSize == sizeof(BYTE) ){
            m_pWMIBlockInfo->SetByte((BYTE)dwLong);
        }
        else if( nSize == sizeof(short)){
            m_pWMIBlockInfo->SetWord((WORD)dwLong);
        }
        else{
            m_pWMIBlockInfo->SetDWORD(dwLong);
        }
        fRc = TRUE;
    }
    return fRc;
}

//=============================================================
DWORD CWMIDataTypeMap::ConvertWMIDataTypeToDWORD(int nSize)
{
    DWORD dwLong = 0L;

    if( nSize == sizeof(BYTE) ){
        BYTE bByte;
        m_pWMIBlockInfo->GetByte(bByte);
        dwLong = (DWORD) bByte;
    }
    else if( nSize == sizeof(short)){
        WORD nInt;
        m_pWMIBlockInfo->GetWord(nInt);
        dwLong = (DWORD) nInt;
    }
    else{
        m_pWMIBlockInfo->GetDWORD(dwLong);
    }
    return dwLong;
}
//=============================================================
BOOL CWMIDataTypeMap::SetDefaultMissingQualifierValue( CVARIANT & v, long lType, CVARIANT & vToSet )
{ 
    BOOL fRc = TRUE;
    CAnsiUnicode XLate;

	switch (lType){

	//	CIM_SINT16	= 2,
	//  CIM_CHAR16
		case CIM_CHAR16:
			break;

		//	CIM_SINT8	= 16,
		case VT_I1:
		case VT_I2:		
            vToSet.Clear();
            vToSet.SetShort(v.GetShort());
            break;
			
		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		//	CIM_UINT16	= 18,
		case VT_UI2:
		case VT_I4:	
		case VT_UI4:	
            vToSet.Clear();
            vToSet.SetLONG(v.GetLONG());
            break;

		//	CIM_REAL32	= 4,
		case VT_R4:		
		case VT_R8:		
            vToSet.Clear();
            vToSet.SetDouble(v.GetDouble());
			break;

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		case VT_I8:	
		case VT_UI8:
            vToSet.Clear();
            vToSet.SetStr(v.GetStr());
			break;

		//	CIM_DATETIME	= 101,
		case CIM_DATETIME:
			break;

		//	CIM_STRING	= 8,
		//	CIM_REFERENCE	= 102,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_BSTR:
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:
            vToSet.Clear();
            vToSet.SetBool(v.GetBool());
			break;

		//	CIM_UINT8	= 17,
		case VT_UI1:	
            vToSet.Clear();
            vToSet.SetByte(v.GetByte());
			break;

        default:
			fRc = FALSE;

	}

	return fRc;
}

//=============================================================
BOOL CWMIDataTypeMap::MissingQualifierValueMatches( CSAFEARRAY * pSafe, long i, CVARIANT & v, long lType, CVARIANT & vToCompare )
{ 
    BOOL fRc = FALSE;
    CAnsiUnicode XLate;

	switch (lType){

	//	CIM_SINT16	= 2,
	//  CIM_CHAR16
		case CIM_CHAR16:
			break;

		//	CIM_SINT8	= 16,
		case VT_I1:
		case VT_I2:		
			{
				short v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (short) v.GetShort();
				}

				short v2 = (short)vToCompare.GetShort();
				if( v1 == v2){
					fRc = TRUE;
				}
				break;
			}
			
		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		//	CIM_UINT16	= 18,
		case VT_UI2:
		case VT_I4:	
		case VT_UI4:	
			{
				long v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (long)v.GetLONG();
				}
				long v2 = (long)vToCompare.GetLONG();
				if( v1 == v2){
					fRc = TRUE;
				}
				break;
			}
		//	CIM_REAL32	= 4,
		case VT_R4:		
		case VT_R8:		
			{
				double v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (double)v.GetDouble();
				}
				double v2 = (double)vToCompare.GetDouble();
				if( v1 == v2 ){
					fRc = TRUE;
				}
				break;
			}

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
 
		case VT_UI8:
			{
			    unsigned __int64 I1 = 0L, I2 = 0L;
                char * pChar1 = NULL, *pChar2 =NULL;
			
                CBSTR bstr2;
                CBSTR bstr1;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr1))
					{
                        return FALSE;
                    }
                }
                else
				{	
                    bstr1.SetStr(v.GetStr());
                }
				bstr2.SetStr(vToCompare.GetStr());

            	if( bstr1 && bstr2)
				{
					if( SUCCEEDED(XLate.UnicodeToAnsi(bstr1, pChar1 ) && XLate.UnicodeToAnsi(bstr2,pChar2)))
					{
						I1 =(unsigned __int64) _atoi64(pChar1);
						I2 =(unsigned __int64)_atoi64(pChar2);
						if( I1 == I2 ){
							fRc = TRUE;
						}
					}
                    SAFE_DELETE_ARRAY( pChar1 );
                    SAFE_DELETE_ARRAY( pChar2 );
				}

				break;
			}


		case VT_I8:	
			{
			    __int64 I1 = 0L, I2 = 0L;
                char * pChar1 = NULL, * pChar2 =NULL;
			
                CBSTR bstr2;
                CBSTR bstr1;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr1))
					{
                        return FALSE;
                    }
                }
                else
				{
                    bstr1.SetStr(v.GetStr());
                }
				bstr2.SetStr(vToCompare.GetStr());

            	if( bstr1 && bstr2)
				{
					if( SUCCEEDED(XLate.UnicodeToAnsi(bstr1, pChar1 ) && XLate.UnicodeToAnsi(bstr2,pChar2)))
					{
						I1 = _atoi64(pChar1);
						I2 = _atoi64(pChar2);
						if( I1 == I2 ){
							fRc = TRUE;
						}
					}
                    SAFE_DELETE_ARRAY( pChar1 );
                    SAFE_DELETE_ARRAY( pChar2 );
				}

				break;
			}
		
		//	CIM_DATETIME	= 101,
		case CIM_DATETIME:
			break;

		//	CIM_STRING	= 8,
		//	CIM_REFERENCE	= 102,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_BSTR:
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:
			{
				BOOL v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (BOOL)v.GetBool();
				}

				BOOL v2 = (BOOL)vToCompare.GetBool();
				if( v1 == v2 )
				{
					fRc = TRUE;
				}
				break;
			}

		//	CIM_UINT8	= 17,
		case VT_UI1:	
			{
				BYTE v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (BYTE) v.GetByte();
				}
				BYTE v2 = (BYTE)vToCompare.GetByte();
				if( v1 == v2){
					fRc = TRUE;
				}
				break;
			}

        default:
			fRc = FALSE;

	}

	return fRc;
}

//=============================================================
DWORD CWMIDataTypeMap::ArraySize(long lType,CVARIANT & var)
{
	DWORD dwCount = 0;
	switch( lType ){
		case VT_I2:	
		case VT_UI2:			
    		dwCount = (DWORD) var.GetShort();
            break;

        case VT_I4:																
        case VT_UI4:																
		case VT_R4:		
			dwCount = (DWORD) var.GetLONG();
			break;

        case VT_UI1:	
        case VT_I1:	
		    dwCount = (DWORD) var.GetByte();
            break;
	}
	return dwCount;
}
//=============================================================
BOOL CWMIDataTypeMap::SetDataInDataBlock(CSAFEARRAY * pSafe, int i, CVARIANT & v, long lType, int nSize)
{ 
    BOOL fRc = TRUE;
    CAnsiUnicode XLate;

	switch (lType){

	//	CIM_SINT16	= 2,
	//  CIM_CHAR16
		case CIM_CHAR16:
		case VT_I2:		
			{
				SHORT iShort;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &iShort)){
                        return FALSE;
                    }
                }
                else{
				    iShort = v.GetShort();
                }
                if( NaturallyAlignData( sizeof(WORD), WRITE_IT)){
                    m_pWMIBlockInfo->SetWord(iShort);
                }
				break;
			}

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		//	CIM_UINT16	= 18,
		case VT_UI2:
		case VT_I4:	
		case VT_UI4:	
            {
                DWORD dwLong = 0L;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &dwLong)){
                        return FALSE;
                    }
                }
                else{
			        dwLong = v.GetLONG();
                }
                ConvertDWORDToWMIDataTypeAndWriteItToBlock(dwLong,nSize);
		    	break;
            }

		//	CIM_REAL32	= 4,
		case VT_R4:		
			{
				float fFloat;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &fFloat)){
                        return FALSE;
                    }
                }
                else{
				    fFloat =(float) v.GetDouble();
                }
                if( NaturallyAlignData( sizeof(WORD), WRITE_IT )){
                    m_pWMIBlockInfo->SetFloat(fFloat);
                }
				break;
			}

	//	CIM_REAL64	= 5,
		case VT_R8:		
			{
				DOUBLE dDouble;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &dDouble)){
                        return FALSE;
                    }
                }
                else{
    				dDouble = v.GetDouble();
                }
                if( NaturallyAlignData( sizeof(DOUBLE),WRITE_IT)){
                    m_pWMIBlockInfo->SetDouble(dDouble);
                }
				break;
			}

		//	CIM_SINT64	= 20,
		case VT_I8:	
			{
				
				__int64 Int64 = 0L;
                char * pChar = NULL;
				
                CBSTR bstr;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr))
					{
                        return FALSE;
                    }
                }
                else
				{
                    bstr.SetStr(v.GetStr());
                }
				if( bstr )
				{
					if( SUCCEEDED(XLate.UnicodeToAnsi(bstr, pChar )))
					{

						Int64 = _atoi64(pChar);
                        SAFE_DELETE_ARRAY(pChar);
					}
				}						  

                if( NaturallyAlignData( sizeof(__int64), WRITE_IT ))
				{
                    m_pWMIBlockInfo->SetSInt64(Int64);

                }
				break;
			}
		//	CIM_UINT64	= 21,
		case VT_UI8:
			{
				unsigned __int64 Int64 = 0L;
			    char * pChar = NULL;

                CBSTR bstr;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr))
					{
                        return FALSE;
                    }
                }
                else
				{
                    bstr.SetStr(v.GetStr());
                }
				if( bstr )
				{
					if( SUCCEEDED(XLate.UnicodeToAnsi(bstr, pChar )))
					{
						Int64 = (unsigned __int64) _atoi64(pChar);
                        SAFE_DELETE_ARRAY(pChar);
					}
				}
                if( NaturallyAlignData( sizeof(unsigned __int64),WRITE_IT))
				{
                    m_pWMIBlockInfo->SetUInt64(Int64);
                }
				break;
			}
	
		//	CIM_DATETIME	= 101,
		case CIM_DATETIME:
            {
			    WORD wCount=0;
                CBSTR bstr;
				WCHAR wDateTime[SIZEOFWBEMDATETIME+2];
				memset( wDateTime,NULL,SIZEOFWBEMDATETIME+2 );
                BOOL fContinue = TRUE;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr))
					{
                        return FALSE;
                    }
                }
                else
				{
                    bstr.SetStr(v.GetStr());
                }

                //=========================================================
                //  Initialize buffer
                //=========================================================

				if( bstr != NULL )
				{
					if( ValidateDateTime(bstr))
					{
						wcscpy(wDateTime,v.GetStr());
			        }
                    else
					{
                        fContinue = FALSE;
                    }
				}
                else{
    				wcscpy(wDateTime,L"00000000000000.000000:000");
                }

                if( fContinue ){

                    if( S_OK != m_pWMIBlockInfo->GetBufferReady(SIZEOFWBEMDATETIME )){
                        return FALSE;
                    }

				    if( NaturallyAlignData( SIZEOFWBEMDATETIME, WRITE_IT)){
		                m_pWMIBlockInfo->SetString(wDateTime,SIZEOFWBEMDATETIME);
                    }
                }
			    break;
            }
		//	CIM_STRING	= 8,
		//	CIM_REFERENCE	= 102,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_BSTR:
            {
			    WORD wCount=0;
                CBSTR bstr;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr))
					{
                        return FALSE;
                    }
                }
                else{
                    bstr.SetStr(v.GetStr());
                }
				if( bstr != NULL )
				{
					wCount = (wcslen(bstr))* sizeof(WCHAR);
				}

                if( S_OK != m_pWMIBlockInfo->GetBufferReady(wCount)){
                   return FALSE;
                }

                if( NaturallyAlignData( sizeof(WORD),WRITE_IT)){
                    m_pWMIBlockInfo->SetWord(wCount);
                }
				if( bstr )
				{
				    m_pWMIBlockInfo->SetString(bstr,wCount);
					*m_pdwAccumulativeSizeOfBlock += wCount;

				}
			    break;
            }
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
			{
				BYTE bByte;

                if( pSafe ){
                    BOOL bTmp;
                    if( S_OK != pSafe->Get(i, &bTmp)){
                        return FALSE;
                    }
                    bByte = (BYTE) bTmp;
                }
                else{
    				bByte =(BYTE) v.GetBool();
                }

                if( NaturallyAlignData( sizeof(BYTE), WRITE_IT )){
                    m_pWMIBlockInfo->SetByte(bByte);
                }
				break;
			}

		//	CIM_UINT8	= 17,
		case VT_UI1:	
			{
			    BYTE bByte;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &bByte)){
                        return FALSE;
                    }
                }
                else{
    				bByte = v.GetByte();
                }

                if( NaturallyAlignData( 1, WRITE_IT )){
                    m_pWMIBlockInfo->SetByte(bByte);
                }
				break;
			}

		//	CIM_SINT8	= 16,
		case VT_I1:
			{
				short tmpShort;

                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &tmpShort)){
                        return FALSE;
                    }
                }
                else{
    				tmpShort = v.GetShort();
                }

                if( NaturallyAlignData( 1, WRITE_IT )){
					BYTE bByte = (signed char)tmpShort;
                    m_pWMIBlockInfo->SetByte(bByte);
                }
				break;
			}

        default:
			fRc = FALSE;

	}

	return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataTypeMap::GetDataFromDataBlock(IWbemObjectAccess * p, long lHandle, long lType, int nSize)
{
    HRESULT hr = S_OK;

	switch (lType){


		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:	
		case VT_UI4:			
            if( NaturallyAlignData( nSize, READ_IT )){
                hr = p->WriteDWORD(lHandle,ConvertWMIDataTypeToDWORD(nSize));
            }
		    break;
            
   		case VT_I8:	
        case VT_UI8:	
            if( NaturallyAlignData( nSize, READ_IT ))
			{
                unsigned __int64 uInt64;
                m_pWMIBlockInfo->GetQWORD(uInt64);
        		hr = p->WriteQWORD(lHandle,uInt64);
            }
			break;


		//	CIM_UINT16	= 18,
		//	CIM_SINT16	= 2,
		//	CIM_CHAR16	= 103,
		case VT_I2:		
		case VT_UI2:
		case CIM_CHAR16:
            if( NaturallyAlignData( nSize,  READ_IT )){
                WORD wWord;
                m_pWMIBlockInfo->GetWord(wWord);
                // Read but don't assign to anything
            }
			break;

            
		//	CIM_REAL32	= 4,
		case VT_R4:		
            if( NaturallyAlignData( nSize, READ_IT)){
                float fFloat;
                m_pWMIBlockInfo->GetFloat(fFloat);
                // Read but don't assign to anything
            }
			break;

		//	CIM_REAL64	= 5,
		case VT_R8:		
            if( NaturallyAlignData( nSize,  READ_IT )){
                DOUBLE dDouble;
                m_pWMIBlockInfo->GetDouble(dDouble);
                // Read but don't assign to anything
            }
			break;

		//	CIM_DATETIME	= 101, which is 25 WCHARS
		case CIM_DATETIME:
            if( NaturallyAlignData( SIZEOFWBEMDATETIME,  READ_IT )){
                WORD wSize = SIZEOFWBEMDATETIME + 4;
    			WCHAR Buffer[SIZEOFWBEMDATETIME + 4];
				m_pWMIBlockInfo->GetString(Buffer,SIZEOFWBEMDATETIME,wSize);
                // Read but don't assign to anything
            }
    		break;
			
		//	CIM_REFERENCE	= 102,
		//	CIM_STRING	= 8,
        case VT_BSTR:	
            if( NaturallyAlignData( 2,  READ_IT )){
				WORD wCount=0;
				WCHAR * pBuffer=NULL;

				//  Get the size of the string
                m_pWMIBlockInfo->GetWord(wCount);
				if( wCount > 0 )
                {
			   	    if( m_pWMIBlockInfo->CurrentPtrOk((ULONG)(wCount)) )
                    {
                        WORD wSize = wCount + 4;
						pBuffer = new WCHAR[wSize];
                        if( pBuffer )
                        {
						    try
                            {
							    m_pWMIBlockInfo->GetString(pBuffer,wCount,wSize);
                                // Read but don't assign to anything
                                SAFE_DELETE_ARRAY(pBuffer);
							    *m_pdwAccumulativeSizeOfBlock += wCount;
                            }
                            catch(...)
                            {
                                hr = WBEM_E_UNEXPECTED;
                                SAFE_DELETE_ARRAY(pBuffer);
                                throw;
                            }
						}
                    
					}
                    else
                    {
                        hr = WBEM_E_INVALID_OBJECT;
                    }
				}
            }
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
            if( NaturallyAlignData( nSize,  READ_IT )){
				BYTE bByte=0;
                m_pWMIBlockInfo->GetByte(bByte);
                // Read but don't assign to anything
			}
			break;

		//	CIM_SINT8	= 16,
		//	CIM_UINT8	= 17,
		case VT_UI1:	
		case VT_I1:
            if( NaturallyAlignData( nSize,  READ_IT )){
				BYTE bByte=0;
	            m_pWMIBlockInfo->GetByte(bByte);
                // Read but don't assign to anything
            }
			break;

		default:
			return WBEM_E_INVALID_OBJECT;									

	}

	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataTypeMap::GetDataFromDataBlock(CVARIANT & v, long lType,  int nSize )
{ 
    HRESULT hr = WBEM_E_INVALID_OBJECT;

	switch (lType){

		//	CIM_SINT16	= 2,
		//	CIM_CHAR16	= 103,
		case VT_I2:		
		case CIM_CHAR16:
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
                WORD wWord;
                m_pWMIBlockInfo->GetWord(wWord);
			    v.SetShort(wWord);
            }
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT16	= 18,
		//	CIM_UINT32	= 19,
		case VT_I4:	
		case VT_UI2:
		case VT_UI4:			
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
        		v.SetLONG(ConvertWMIDataTypeToDWORD(nSize));
            }
		    break;
            
		//	CIM_REAL32	= 4,
		case VT_R4:		
            if( NaturallyAlignData( nSize, READ_IT)){
                hr = WBEM_S_NO_ERROR;
                float fFloat;
                m_pWMIBlockInfo->GetFloat(fFloat);
		    	v.SetDouble(fFloat);
            }
			break;

		//	CIM_REAL64	= 5,
		case VT_R8:		
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
                DOUBLE dDouble;
                m_pWMIBlockInfo->GetDouble(dDouble);
		    	v.SetDouble(dDouble);
            }
			break;

		//	CIM_SINT64	= 20,
		case VT_I8:	
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
				WCHAR pwcsBuffer[256];
                memset(pwcsBuffer,NULL,256);
                m_pWMIBlockInfo->GetSInt64(pwcsBuffer);
				v.SetStr(pwcsBuffer);
            }
			break;

		//	CIM_UINT64	= 21,
		case VT_UI8:	
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
				WCHAR pwcsBuffer[256];
                memset(pwcsBuffer,NULL,256);
                m_pWMIBlockInfo->GetUInt64(pwcsBuffer);
				v.SetStr(pwcsBuffer);
            }
			break;
	
		//	CIM_DATETIME	= 101, which is 25 WCHARS
		case CIM_DATETIME:
    		v.SetStr(NULL);
            if( NaturallyAlignData( SIZEOFWBEMDATETIME,  READ_IT )){
                hr = WBEM_S_NO_ERROR;

                WORD wSize = SIZEOFWBEMDATETIME + 4;
    			WCHAR Buffer[SIZEOFWBEMDATETIME + 4];
				m_pWMIBlockInfo->GetString(Buffer,SIZEOFWBEMDATETIME,wSize);

                if( _wcsicmp(Buffer,L"00000000000000.000000:000") != 0 ){
        		   	v.SetStr(Buffer);
                }
            }
    		break;
			
		//	CIM_REFERENCE	= 102,
		//	CIM_STRING	= 8,
        case VT_BSTR:	
    		v.SetStr(NULL);

            if( NaturallyAlignData( 2,  READ_IT )){
				WORD wCount=0;
				WCHAR * pBuffer=NULL;

				//  Get the size of the string
                m_pWMIBlockInfo->GetWord(wCount);

                hr = WBEM_S_NO_ERROR;
				if( wCount > 0 ){
			   	    if( m_pWMIBlockInfo->CurrentPtrOk((ULONG)(wCount)) ){
                        WORD wSize = wCount + 4;
						pBuffer = new WCHAR[wSize];
                        if( pBuffer )
                        {
						    try
                            {
							    m_pWMIBlockInfo->GetString(pBuffer,wCount,wSize);
    						    v.SetStr(pBuffer);
                                SAFE_DELETE_ARRAY(pBuffer);
							    *m_pdwAccumulativeSizeOfBlock += wCount;
						    }
                            catch(...)
                            {
                                hr = WBEM_E_UNEXPECTED;
                                SAFE_DELETE_ARRAY(pBuffer);
                                throw;
                            }
                        }
					}
                    else{
                        hr = WBEM_E_INVALID_OBJECT;
                    }
				}
				else{
					v.SetStr(NULL);
				}
            }
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
				BYTE bByte=0;
                m_pWMIBlockInfo->GetByte(bByte);
				v.SetBool((BOOL)bByte);
			}
			break;

		//	CIM_SINT8	= 16,
		//	CIM_UINT8	= 17,
		case VT_UI1:	
		case VT_I1:
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
				BYTE bByte=0;
	            m_pWMIBlockInfo->GetByte(bByte);

				if( lType == VT_I1 ){
					v.SetShort((signed char)bByte);
				}
				else{
					v.SetByte(bByte);
				}
            }
			break;

		default:
			return WBEM_E_INVALID_OBJECT;									

	}

	return hr;
}
//////////////////////////////////////////////////////////////////////
int CWMIDataTypeMap::GetWMISize(long lType)
{
	int nWMISize = 0;

    switch(lType){
		//	CIM_SINT8	= 16,
		//	CIM_UINT8	= 17,
		case VT_I1:
		case VT_UI1:
			nWMISize = sizeof(BYTE);
			break;
    
		//	CIM_SINT16	= 2,
		//	CIM_UINT16	= 18,
		case VT_I2:
		case CIM_CHAR16:
		case VT_UI2:
			nWMISize = sizeof(short);
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:
		case VT_UI4:
			nWMISize = sizeof(DWORD);
			break;
    
		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		case VT_I8:
		case VT_UI8:
	        nWMISize = sizeof(__int64);
			break;

		//	CIM_REAL32	= 4,
		case VT_R4:
			nWMISize = sizeof(float);
			break;

	//	CIM_REAL64	= 5,
		case VT_R8:
			nWMISize = sizeof(double);
			break;

	//	CIM_BOOLEAN	= 11,
		case VT_BOOL:
	        nWMISize = sizeof(BYTE);
			break;

		case CIM_DATETIME:
			nWMISize = SIZEOFWBEMDATETIME;
			break;

		case CIM_STRING:
			nWMISize = 2;
			break;

		default:
			//	CIM_STRING	= 8,
			//	CIM_REFERENCE	= 102,
			//	CIM_OBJECT	= 13,
			//	CIM_FLAG_ARRAY	= 0x2000
 			nWMISize = 0;
	}

	return nWMISize;
}
///////////////////////////////////////////////////////////////
long CWMIDataTypeMap::GetVariantType(WCHAR * wcsType)
{
	long lType;

	//	CIM_SINT8	= 16,
	if( 0 == _wcsicmp( L"sint8",wcsType) ){
		lType = VT_I1;
    }
	//	CIM_UINT8	= 17,
	else if( 0 == _wcsicmp( L"uint8",wcsType) ){
		lType = VT_UI1;
    }
	//	CIM_CHAR16	= 103,
	else if( 0 == _wcsicmp( L"char16",wcsType) ){
		lType = VT_I2;
	}
	//	CIM_SINT16	= 2,
	else if( 0 == _wcsicmp( L"sint16",wcsType) ){
		lType = VT_I2;
    }
	//	CIM_UINT16	= 18,
	else if( 0 == _wcsicmp( L"uint16",wcsType) ){
		lType = VT_UI2;
    }
	//	CIM_SINT32	= 3,
	else if( 0 == _wcsicmp( L"sint32",wcsType) ){
		lType = VT_I4;
    }
	//	CIM_UINT32	= 19,
	else if( 0 == _wcsicmp( L"uint32",wcsType) ){
		lType = VT_UI4;
    }
	//	CIM_SINT64	= 20,
	else if( 0 == _wcsicmp( L"sint64",wcsType) ){
		lType = VT_I8;
	}
	//	CIM_UINT64	= 21,
	else if( 0 == _wcsicmp( L"uint64",wcsType) ){
		lType = VT_UI8;
	}
	//	CIM_REAL32	= 4,
	else if( 0 == _wcsicmp( L"real32",wcsType) ){
		lType = VT_R4;
	}
	//	CIM_REAL64	= 5,
	else if( 0 == _wcsicmp( L"real64",wcsType) ){
		lType = VT_R8;
	}
	//	CIM_BOOLEAN	= 11,
	else if( 0 == _wcsicmp( L"boolean",wcsType) ){
		lType = VT_BOOL;
	}
	//	CIM_DATETIME	= 101,
	else if( 0 == _wcsicmp( L"datetime",wcsType) ){
		lType = CIM_DATETIME;
	}
	//	CIM_STRING	= 8,
	//	CIM_REFERENCE	= 102,
	//	CIM_OBJECT	= 13,
	//	CIM_FLAG_ARRAY	= 0x2000
    else{
		lType = VT_BSTR;
	}
	return lType;
}
///////////////////////////////////////////////////////////////
WCHAR * CWMIDataTypeMap::SetVariantType(long lType)
{
   	if( lType & CIM_FLAG_ARRAY ){
      lType = lType &~  CIM_FLAG_ARRAY;
    }
	switch(lType){

    	//	CIM_SINT8	= 16,
        case VT_I1:
            return L"sint8";

    	//	CIM_UINT8	= 17,
        case VT_UI1:
            return L"uint8";

        //	CIM_SINT16	= 2,
        case VT_I2:
            return L"sint16";    

	    //	CIM_UINT16	= 18,
        case VT_UI2:
            return  L"uint16";

	    //	CIM_SINT32	= 3,
        case VT_I4:
            return L"sint32";

    	//	CIM_UINT32	= 19,
        case VT_UI4:
            return L"uint32";
    
    	//	CIM_SINT64	= 20,
        case VT_I8:
            return L"sint64";

	    //	CIM_UINT64	= 21,
        case VT_UI8:
            return L"uint64";

    	//	CIM_REAL32	= 4,
        case VT_R4:
            return L"real32";

	    //	CIM_REAL64	= 5,
        case VT_R8:
            return L"real64";

	    //	CIM_BOOLEAN	= 11,
        case VT_BOOL:
            return L"boolean";
	
	    //	CIM_STRING	= 8,
        case VT_BSTR:
            return L"string";

	    //	CIM_CHAR16	= 103,
        case CIM_CHAR16: 
            return L"char16";

	    //	CIM_OBJECT	= 13,
        case CIM_OBJECT: 
            return L"object";

	    //	CIM_REFERENCE	= 102,
        case CIM_REFERENCE: 
            return L"ref";

	    //	CIM_DATETIME	= 101,
        case CIM_DATETIME: 
            return L"datetime";

        default: return NULL;
    }
}

////////////////////////////////////////////////////////////////
void CWMIDataTypeMap::GetSizeAndType( WCHAR * wcsType, IDOrder * p, long & lType, int & nWMISize )
{
	BOOL fArray = FALSE;
	if( lType & CIM_FLAG_ARRAY ){
		fArray = TRUE;
	}
	if( 0 == _wcsnicmp( L"object:",wcsType,wcslen(L"object:"))){
        //============================================
        //  Extract out the object name
        //============================================
        WCHAR * pName = new WCHAR[wcslen(wcsType)];
        if( pName )
        {
            swscanf( wcsType,L"object:%s",pName);
            p->SetEmbeddedName(pName);
            SAFE_DELETE_ARRAY(pName);
		    lType = VT_UNKNOWN;
		    nWMISize =  0;
        }
	}
	else{
		lType = GetVariantType(wcsType);
		nWMISize = GetWMISize(lType);
	}
	if( fArray ){
		lType |= CIM_FLAG_ARRAY;
	}
}
/////////////////////////////////////////////////////////////////////
long CWMIDataTypeMap::ConvertType(long lType )
{
	long lConvert = lType;
	switch (lType){

	//	CIM_SINT16	= 2,
	//	CIM_UINT16	= 18,
	// CIM_SINT8
		case VT_I1:
		case VT_I2:		
			lConvert = VT_I2;
			break;

		case VT_UI2:
			lConvert = VT_I4;
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:	
		case VT_UI4:			
			lConvert = VT_I4;
			break;

		//	CIM_REAL32	= 4,
		//	CIM_REAL64	= 5,
		case VT_R4:		
		case VT_R8:		
			lConvert = VT_R8;
			break;

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		//	CIM_STRING	= 8,
		//	CIM_DATETIME	= 101,
		//	CIM_REFERENCE	= 102,
		//	CIM_CHAR16	= 103,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_I8:	
		case VT_UI8:
		case VT_BSTR:	
        case CIM_DATETIME:
			lConvert = VT_BSTR;
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
			lConvert = VT_BOOL;
			break;

		//	CIM_UINT8	= 17,
		case VT_UI1:	
			lConvert = VT_UI1;
			break;

		case VT_UNKNOWN:
			lConvert = VT_UNKNOWN;
			break;

        default:
			break;
	}
	return lConvert;

}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIDataTypeMap::PutInArray(SAFEARRAY * & psa,long * pi, long & lType, VARIANT * pVar)
{
    HRESULT hr = WBEM_E_INVALID_OBJECT;
	VARIANT v = *pVar;
	switch (lType){

	//	CIM_SINT16	= 2,
	//	CIM_UINT16	= 18,
	// CIM_SINT8
		case VT_I1:
		case VT_I2:		
			lType = V_VT(&v) = VT_I2;
			hr = SafeArrayPutElement(psa,pi,&V_I2(&v));
			break;

		case VT_UI2:
			lType = V_VT(&v) = VT_I4;
			hr = SafeArrayPutElement(psa,pi,&V_I4(&v));
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:	
		case VT_UI4:			
			lType = V_VT(&v) = VT_I4;
			hr = SafeArrayPutElement(psa,pi,&V_I4(&v));
			break;

		//	CIM_REAL32	= 4,
		//	CIM_REAL64	= 5,
		case VT_R4:		
		case VT_R8:		
			lType = V_VT(&v) = VT_R8;
			hr = SafeArrayPutElement(psa,pi,&V_R8(&v));
			break;

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		//	CIM_STRING	= 8,
		//	CIM_DATETIME	= 101,
		//	CIM_REFERENCE	= 102,
		//	CIM_CHAR16	= 103,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_I8:	
		case VT_UI8:
		case VT_BSTR:	
        case CIM_DATETIME:
			lType = V_VT(&v) = VT_BSTR; 
			hr = SafeArrayPutElement(psa,pi,V_BSTR(&v));
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
			lType = V_VT(&v) = VT_BOOL;
			hr = SafeArrayPutElement(psa,pi,&V_BOOL(&v));
			break;

		//	CIM_UINT8	= 17,
		case VT_UI1:	
			lType = V_VT(&v) = VT_UI1;
			hr = SafeArrayPutElement(psa,pi,&V_UI1(&v));
			break;

		case VT_UNKNOWN:
			lType = V_VT(&v) = VT_UNKNOWN;
			hr = SafeArrayPutElement(psa,pi,V_UNKNOWN(&v));
			break;

        default:
			break;

	}
	return hr;
}
//////////////////////////////////////////////////////////////////////
BOOL CWMIDataTypeMap::NaturallyAlignData( int nSize, BOOL fRead )
{
    BOOL fRc = FALSE;
	DWORD dwBytesToPad = 0;
	if( *m_pdwAccumulativeSizeOfBlock != 0 ){

		DWORD dwMod;
		int nNewSize = nSize;

        if( nSize == SIZEOFWBEMDATETIME ){
			nNewSize = 2;
		}

	    dwMod = *m_pdwAccumulativeSizeOfBlock % nNewSize;

		if( dwMod > 0 ){
			dwBytesToPad = (DWORD)nNewSize - dwMod;
        }
	}
    if( fRead ){
   	    if( m_pWMIBlockInfo->CurrentPtrOk((ULONG)(dwBytesToPad+nSize)) ){
            fRc = TRUE;
        }
        else{
            dwBytesToPad = 0;
        }
    }
	else{
		fRc = TRUE;
	}
    m_pWMIBlockInfo->AddPadding(dwBytesToPad);
    *m_pdwAccumulativeSizeOfBlock += nSize + dwBytesToPad;

    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmidata.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "precomp.h"
#include "wmicom.h"
#include "wmimof.h"
#include "wmimap.h"
#include <stdlib.h>
#include <winerror.h>
#include <crc32.h>

#define NO_DATA_AVAILABLE 2
#define WMI_INVALID_HIPERFPROP	3
#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))
////////////////////////////////////////////////////////////////////////////////////////////////
void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context);

#define WMIINTERFACE m_Class->GetWMIManagementPtr()
////////////////////////////////////////////////////////////////////////////////////////////////
//=============================================================
BOOL CWMIManagement::CancelWMIEventRegistration( GUID gGuid , ULONG_PTR uContext )
{ 
    BOOL fRc = FALSE;

    try
    {
        if( ERROR_SUCCESS == WmiNotificationRegistration(&gGuid, FALSE,EventCallbackRoutine,uContext, NOTIFICATION_CALLBACK_DIRECT))
        {
            fRc = TRUE;
        }
    }
    catch(...)
    {
        // don't throw
    }

    return fRc;    
}

//**********************************************************************************************
//  WMI Data block
//**********************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIDataBlock::DumpAllWnode() 
{
	//=========================================
	//   Dump Wnode All Node info 
	//=========================================
	ERRORTRACE((THISPROVIDER,"***************************************\n"));
	ERRORTRACE((THISPROVIDER,"WNODE_ALL_DATA 0x%x\n",m_pAllWnode));

	ERRORTRACE((THISPROVIDER,"  DataBlockOffset..............%x\n",m_pAllWnode->DataBlockOffset));
	ERRORTRACE((THISPROVIDER,"  InstanceCount................%x\n",m_pAllWnode->InstanceCount));
	ERRORTRACE((THISPROVIDER,"  OffsetInstanceNameOffsets....%x\n",m_pAllWnode->OffsetInstanceNameOffsets));
                      
	if( m_fFixedInstance ){
		ERRORTRACE((THISPROVIDER,"  FixedInstanceSize....%x\n",m_pAllWnode->FixedInstanceSize));
	}
	else{
		ERRORTRACE((THISPROVIDER,"  OffsetInstanceData....%x\n",m_pAllWnode->OffsetInstanceDataAndLength[0].OffsetInstanceData));
		ERRORTRACE((THISPROVIDER,"  LengthInstanceData....%x\n",m_pAllWnode->OffsetInstanceDataAndLength[0].LengthInstanceData));
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIDataBlock::DumpSingleWnode() 
{
	//=========================================
	//   Dump Wnode Single Node info 
	//=========================================
	ERRORTRACE((THISPROVIDER,"***************************************\n"));
	ERRORTRACE((THISPROVIDER,"WNODE_SINGLE_INSTANCE 0x%x\n",m_pSingleWnode));

	ERRORTRACE((THISPROVIDER,"  OffsetInstanceName....0x%x\n",m_pSingleWnode->OffsetInstanceName));
	ERRORTRACE((THISPROVIDER,"  InstanceIndex.........0x%x\n",m_pSingleWnode->InstanceIndex));
	ERRORTRACE((THISPROVIDER,"  DataBlockOffset.......0x%x\n",m_pSingleWnode->DataBlockOffset));
	ERRORTRACE((THISPROVIDER,"  SizeDataBlock.........0x%x\n",m_pSingleWnode->SizeDataBlock));

	ERRORTRACE((THISPROVIDER,"***************************************\n"));

}
////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIDataBlock::DumpWnodeMsg(char * wcsMsg) 
{
	ERRORTRACE((THISPROVIDER,"***************************************\n"));
	ERRORTRACE((THISPROVIDER,"%s\n",wcsMsg));
	ERRORTRACE((THISPROVIDER,"***************************************\n"));

}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::DumpWnodeInfo(char * wcsMsg) 
{
    HRESULT hr = WBEM_E_UNEXPECTED;
	//=========================================
	//   Dump Wnode header info first
	//=========================================
	// WNODE definition
	if( m_pHeaderWnode )
    {
    	if( !IsBadReadPtr( m_pHeaderWnode, m_pHeaderWnode->BufferSize))
        {

            DumpWnodeMsg(wcsMsg);

	        ERRORTRACE((THISPROVIDER,"WNODE_HEADER 0x%x\n",m_pHeaderWnode));
	        ERRORTRACE((THISPROVIDER,"  BufferSize........0x%x\n",m_pHeaderWnode->BufferSize));
	        ERRORTRACE((THISPROVIDER,"  ProviderId........0x%x\n",m_pHeaderWnode->ProviderId));
	        ERRORTRACE((THISPROVIDER,"  Version...........0x%x\n",m_pHeaderWnode->Version));
	        
	        if( m_pHeaderWnode->Linkage != 0 ){
		        ERRORTRACE((THISPROVIDER,"  Linkage...........%x\n",m_pHeaderWnode->Linkage));
	        }

	        ERRORTRACE((THISPROVIDER,"  TimeStamp:LowPart.0x%x\n",m_pHeaderWnode->TimeStamp.LowPart));
	        ERRORTRACE((THISPROVIDER,"  TimeStamp:HiPart..0x%x\n",m_pHeaderWnode->TimeStamp.HighPart));

	        WCHAR * pwcsGuid=NULL;

	        if( S_OK == StringFromCLSID(m_pHeaderWnode->Guid,&pwcsGuid )){
		        ERRORTRACE((THISPROVIDER,"  Guid.............."));
                TranslateAndLog(pwcsGuid);
		        ERRORTRACE((THISPROVIDER,"\n"));
                CoTaskMemFree(pwcsGuid);
            }

	        ERRORTRACE((THISPROVIDER,"  Flags.............0x%x\n",m_pHeaderWnode->Flags));

	        //==================================================================
	        // Now that we printed the header, we should print out the node 
	        // either single or all
	        //==================================================================
	        if( m_pSingleWnode ){
		        DumpSingleWnode();
	        }
	        if( m_pAllWnode ){
		        DumpAllWnode();
	        }
	        //==================================================================
	        //  Now, dump the memory
	        //==================================================================
	        DWORD dwCount;

	        if( IsBadReadPtr( m_pHeaderWnode, m_pHeaderWnode->BufferSize) == 0 )
			{
		        BYTE * pbBuffer = NULL;
		        BYTE b1,b2,b3,b4,b5,b6,b7,b8,b9,b10;
		        dwCount = m_pHeaderWnode->BufferSize;
				pbBuffer = new BYTE[dwCount+256];
				if( pbBuffer )
				{
					BYTE bDump[12];
					ERRORTRACE((THISPROVIDER,"Writing out buffer, total size to write: %ld", dwCount ));
					memset(pbBuffer,NULL,dwCount+256);
					memcpy(pbBuffer,(BYTE*)m_pHeaderWnode,dwCount);
					BYTE * pTmp = pbBuffer;
					for( DWORD i = 0; i < dwCount; i +=10)
					{
						memset(bDump, NULL, 12 );
						memcpy(bDump, pTmp, 10);
						ERRORTRACE((THISPROVIDER,"  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x  \n",bDump[0],bDump[1],bDump[2],bDump[3],bDump[4],bDump[5],bDump[6],bDump[7],bDump[8],bDump[9])); 
						pTmp+=10;
					}
					SAFE_DELETE_ARRAY(pbBuffer);
				}
            }
        }
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::MapReturnCode(ULONG uRc) 
{

	if( uRc != 0 )
	{
		ERRORTRACE((THISPROVIDER,"WDM call returned error: %lu\n", uRc));
	}
	wsprintf(m_wcsMsg,L"WDM specific return code: %lu",uRc);

	switch(uRc){

		case ERROR_WMI_GUID_NOT_FOUND:
			return WBEM_E_NOT_SUPPORTED;
			break;

		case S_OK:
			return S_OK;

		case ERROR_NOT_SUPPORTED:
		case ERROR_INVALID_FUNCTION:
			return WBEM_E_NOT_SUPPORTED;

		case ERROR_WMI_SERVER_UNAVAILABLE:
			return WBEM_E_NOT_SUPPORTED;

		case NO_DATA_AVAILABLE:
			return S_OK;

		case ERROR_INVALID_HANDLE:
			return WBEM_E_NOT_AVAILABLE;

		case ERROR_WMI_DP_FAILED:
			wcscpy(m_wcsMsg,MSG_DRIVER_ERROR);
			DumpWnodeInfo(ANSI_MSG_DRIVER_ERROR);
			return WBEM_E_INVALID_OPERATION;

		case ERROR_WMI_READ_ONLY:
			wcscpy(m_wcsMsg,MSG_READONLY_ERROR);
			return WBEM_E_READ_ONLY;

        case ERROR_INVALID_PARAMETER:
			DumpWnodeInfo(ANSI_MSG_INVALID_PARAMETER);
            return WBEM_E_INVALID_PARAMETER;

		case ERROR_INVALID_DATA:
			wcscpy(m_wcsMsg,MSG_ARRAY_ERROR);
			DumpWnodeInfo(ANSI_MSG_INVALID_DATA);
			return WBEM_E_INVALID_PARAMETER;

        case ERROR_WMI_GUID_DISCONNECTED:
			wcscpy(m_wcsMsg,MSG_DATA_NOT_AVAILABLE);
			return WBEM_E_NOT_SUPPORTED;

        case ERROR_ACCESS_DENIED:
        case ERROR_INVALID_PRIMARY_GROUP:
        case ERROR_INVALID_OWNER:
			DumpWnodeInfo(ANSI_MSG_ACCESS_DENIED);
            return WBEM_E_ACCESS_DENIED;

        case ERROR_WMI_INSTANCE_NOT_FOUND:
			wcscpy(m_wcsMsg,MSG_DATA_INSTANCE_NOT_FOUND);
            DumpWnodeMsg(ANSI_MSG_DATA_INSTANCE_NOT_FOUND);
			return WBEM_E_NOT_SUPPORTED;

	}
	return WBEM_E_FAILED;
}


//******************************************************************
////////////////////////////////////////////////////////////////////
//   CWMIDataBlock
////////////////////////////////////////////////////////////////////
//******************************************************************
////////////////////////////////////////////////////////////////////
//******************************************************************
//
//  WMIDataBlock handles the reading and writing of a WMI Data
//  block.
//
//******************************************************************
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
CWMIDataBlock::CWMIDataBlock()
{
    m_hCurrentWMIHandle = NULL;
    InitMemberVars();
	memset(m_wcsMsg,NULL,MSG_SIZE);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
CWMIDataBlock::~CWMIDataBlock()
{

	if( m_fCloseHandle )
    {
        if( m_hCurrentWMIHandle )
        {
            try
            {
		        WmiCloseBlock(m_hCurrentWMIHandle);
            }
            catch(...){
               // don't throw
            }
        }
	}

    ResetDataBuffer();
	InitMemberVars();
}
////////////////////////////////////////////////////////////////////
void CWMIDataBlock::InitMemberVars()
{
	m_fUpdateNamespace = TRUE;
	m_fMofHasChanged   = FALSE;
    m_uDesiredAccess = 0;
    m_dwDataBufferSize = 0;
	m_pbDataBuffer= NULL;
	m_fMore = 0L;
	//=======================================
	//  ptrs
	//=======================================
	m_pHeaderWnode = NULL;
	m_pSingleWnode = NULL;
	m_pAllWnode = NULL;
	m_dwAccumulativeSizeOfBlock = 0L;
	m_dwCurrentAllocSize		= 0L;

	m_uInstanceSize = 0L;
}
//====================================================================
HRESULT CWMIDataBlock::OpenWMIForBinaryMofGuid()
{
	int nRc = 0;
	HRESULT hr = WBEM_E_FAILED;
	m_fCloseHandle = TRUE;
    try
    {
        hr = m_Class->GetGuid();
        if( S_OK == hr )
        {
		    nRc = WmiOpenBlock(m_Class->GuidPtr(),m_uDesiredAccess, &m_hCurrentWMIHandle);
		    if( nRc == ERROR_SUCCESS )
            {
			    hr = S_OK;
		    }
        }
    }
    catch(...)
    {
        hr = WBEM_E_UNEXPECTED;
        // don't throw
    }
	return hr;
}
//====================================================================
int CWMIDataBlock::AssignNewHandleAndKeepItIfWMITellsUsTo()
{
	int nRc = 0;

    try
    {
	    nRc = WmiOpenBlock(m_Class->GuidPtr(),m_uDesiredAccess, &m_hCurrentWMIHandle);

	    //===========================================================
	    //  Now that we opened the block successfully, check to see
	    //  if we need to keep this guy open or not, if we do
	    //  then add it to our list, otherwise don't
	    //===========================================================
	    if( nRc == ERROR_SUCCESS )
        {
		    //=======================================================
		    //  Call WMI function here to see if we should save or
		    //  not
		    //=======================================================
		    WMIGUIDINFORMATION GuidInfo;
		    GuidInfo.Size = sizeof(WMIGUIDINFORMATION);

		    
            if( ERROR_SUCCESS == WmiQueryGuidInformation(m_hCurrentWMIHandle,&GuidInfo))
            {
			    if(GuidInfo.IsExpensive)
                {

					if( m_fUpdateNamespace )
					{
						//================================================
						//  Add it to our list of handles to keep 
						//================================================
						m_fCloseHandle = FALSE;
						WMIINTERFACE->HandleMap()->Add(*(m_Class->GuidPtr()),m_hCurrentWMIHandle,m_uDesiredAccess);
					}
			    }
		    }
	    }
    }
    catch(...)
    {
        nRc = E_UNEXPECTED;
        // don't throw
    }

	return nRc;
}
//====================================================================
HRESULT CWMIDataBlock::OpenWMI()
{
	int nRc;
	HRESULT hr = WBEM_E_FAILED;

    //=======================================================
    //  Ok, we only want to keep the handles that are flagged
	//  by WMI to be kept, otherwise, we just open the handle
	//  and then close it.  Because of this, we need to 
	//  check first and see if the Guid we are going after
	//  already has a handle open, if it does, use it
    //=======================================================
	if( m_fUpdateNamespace )
	{
		CAutoBlock(WMIINTERFACE->HandleMap()->GetCriticalSection());

			nRc = WMIINTERFACE->HandleMap()->ExistingHandleAlreadyExistsForThisGuidUseIt( *(m_Class->GuidPtr()), m_hCurrentWMIHandle, m_fCloseHandle ,m_uDesiredAccess);
			if( nRc != ERROR_SUCCESS)
			{
				nRc = AssignNewHandleAndKeepItIfWMITellsUsTo();
			}
	}
	else
	{
		nRc = AssignNewHandleAndKeepItIfWMITellsUsTo();
	}
	hr = MapReturnCode(nRc);
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessDataBlock()
{
    HRESULT hr = S_OK;
	//================================================================
    //  Data blocks can either be of fixed instance size or dynamic
    //  instance size, call this function so we can determine what
    //  type of data ptr we are working with
    //  If there are no more, then break.  Otherwise, we know
    //  we are processing at least one instance
    //============================================================
	ULONG *pMaxPtrTmp = m_pMaxPtr;
    if( NoMore != AdjustDataBlockPtr(hr)){
		
        hr = FillOutProperties();
    }
	m_pMaxPtr = pMaxPtrTmp;

	//====================================================================
	//  If we didn't succeed in processing these blocks, write it out
	//	If invalid datablock is from Hi-Perf provider, don't log the data
	//	to the file as this could be because of Embededclass or array
	//	properties in the class
	//====================================================================
	if(hr == WMI_INVALID_HIPERFPROP)
	{
		hr = WBEM_E_FAILED;
	}
	else
	if( hr != S_OK )
	{
		DumpWnodeInfo(ANSI_MSG_INVALID_DATA_BLOCK);
	}

    return hr;

}
////////////////////////////////////////////////////////////////////
int CWMIDataBlock::AdjustDataBlockPtr(HRESULT & hr)
{
    int nType = NoMore;
	//================================================================
	//   Get pointer to the data offsets
	//================================================================
	
	// INSTANCES ARE ALWAYS ALIGNED ON 8 bytes

	if( m_fFixedInstance ){
		//========================================================
	    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then 
		// FixedInstanceSize specifies the size of each data block. 
		//========================================================
		// traverse all instances of requested class
		//========================================================
        if( m_nCurrentInstance == 1 ){
            m_pbWorkingDataPtr = m_pbCurrentDataPtr;
        }
		else{
			//=============================================================================
			// make sure we adjust for the fixed instance size, then make sure that it is 
			// on an 8 byte boundary.
			// otherwise, we are going to calculate where it should go next
			//=============================================================================
		    CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
			ULONG_PTR dwSizeSoFar;

			if( m_dwAccumulativeSizeOfBlock < m_pAllWnode->FixedInstanceSize ){
				m_pbWorkingDataPtr += m_pAllWnode->FixedInstanceSize - m_dwAccumulativeSizeOfBlock;
				m_pMaxPtr = (ULONG *)OffsetToPtr(m_pbWorkingDataPtr, m_pAllWnode->FixedInstanceSize);
			}

            dwSizeSoFar = (ULONG_PTR)m_pbWorkingDataPtr - (ULONG_PTR)m_pbCurrentDataPtr;
			Map.NaturallyAlignData(8,READ_IT);
		}
        nType = ProcessOneFixedInstance;
    } 
	else {
		m_dwAccumulativeSizeOfBlock = 0L;				
		//====================================================
		//
	    // If WMI_FLAG_FIXED_DATA_SIZE is not set then 
		// OffsetInstanceData data is an array of ULONGS that 
		// specifies the offsets to the data blocks for each 
		// instance. In this case there is an array of 
		// InstanceCount ULONGs followed by the data blocks.
		//
        // struct {
        //     ULONG OffsetInstanceData;
        //     ULONG LengthInstanceData;
        // } OffsetInstanceDataAndLength[]; /* [InstanceCount] */
		//====================================================
        ULONG uOffset;
		memcpy( &uOffset, m_pbCurrentDataPtr, sizeof(ULONG) );
		if( uOffset == 0 ){
			nType = NoMore;
            hr = S_OK;
		}
        else{
		    m_pbCurrentDataPtr += sizeof( ULONG );

    		memcpy( &m_uInstanceSize, m_pbCurrentDataPtr, sizeof(ULONG) );
	    	m_pbCurrentDataPtr += sizeof( ULONG );
            m_pbWorkingDataPtr =(BYTE*) (ULONG *)OffsetToPtr(m_pAllWnode, uOffset);
            nType = ProcessUnfixedInstance;
			m_pMaxPtr = (ULONG *)OffsetToPtr(m_pbWorkingDataPtr, m_uInstanceSize);

        }
		m_dwAccumulativeSizeOfBlock = 0L;
    }

	return nType;
}
/////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessNameBlock(BOOL fSetName)
{

    HRESULT hr = WBEM_E_FAILED;
	WCHAR wName[NAME_SIZE+2];
	SHORT NameLen = 0;
	BYTE *pbData;
    ULONG * upNameOffset = NULL;

	memset(wName,NULL,NAME_SIZE+2);
	//=====================================================
	//  Either the m_pAllWnode or m_pSingleNode is Null,
	//  which ever isn't, is the type we are working with
	//=====================================================
	if( m_pAllWnode ){
		if( IsBadReadPtr( m_upNameOffsets, sizeof( ULONG *)) == 0 ){
			upNameOffset = ((ULONG *)OffsetToPtr(m_pAllWnode, *m_upNameOffsets));
		}
	}
	else{
		upNameOffset = m_upNameOffsets;
	}

	hr = WBEM_E_INVALID_OBJECT;
	if( IsBadReadPtr( upNameOffset, sizeof( ULONG *)) == 0 ){
		if((ULONG *) (upNameOffset) < m_pMaxPtr ){
    		//================================================================
			//   Get pointer to the name offsets & point to next one
			//================================================================
		
			pbData = (LPBYTE)upNameOffset;        
			if( PtrOk((ULONG*)pbData,(ULONG)0) ){
				if( pbData ){
				
    				memcpy( &NameLen, pbData, sizeof(USHORT) );
					pbData += sizeof(USHORT);

					if( NameLen > 0 ){
						if( PtrOk((ULONG*)pbData,(ULONG)NameLen) ){

    						memcpy(wName,pbData,NameLen);
							pbData+=NameLen;
						    hr = m_Class->SetInstanceName(wName,fSetName);
						}
					}
				}
			}
		}
	}
	//====================================================================
	//  If we didn't succeed in processing these blocks, write it out
	//====================================================================
	if( hr != S_OK ){
		DumpWnodeInfo(ANSI_MSG_INVALID_NAME_BLOCK);
	}

    return hr;
}

////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessBinaryMofDataBlock(CVARIANT & vResourceName,WCHAR * wcsTmp)
{
    HRESULT hr = WBEM_E_FAILED;

	ULONG *pMaxPtrTmp = m_pMaxPtr;
    AdjustDataBlockPtr(hr);
	m_pMaxPtr = pMaxPtrTmp;

    CWMIBinMof bMof;
	hr = bMof.Initialize(WMIINTERFACE,m_fUpdateNamespace);
	if( S_OK == hr )
	{

		bMof.SetBinaryMofClassName(vResourceName.GetStr(),wcsTmp);
		hr = bMof.ExtractBinaryMofFromDataBlock(m_pbWorkingDataPtr,m_uInstanceSize,wcsTmp, m_fMofHasChanged);
		if( hr != S_OK )
		{
			DumpWnodeInfo(ANSI_MSG_INVALID_DATA_BLOCK);
		}
		//===============================================
		//  Get the next node name and data ptrs ready
		//===============================================
		if( m_pAllWnode )
		{
			GetNextNode();
		}
		m_nCurrentInstance++;
	}
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::AddBinaryMof(CVARIANT & vImagePath,CVARIANT & vResourceName)
{
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;
    CAutoWChar wcsTmp(MAX_PATH*2);
	if( wcsTmp.Valid() )
	{
		 hr = WBEM_E_INVALID_OBJECT;
		//=================================================================
		// if we have an image path and resource path, then do the normal 
		// thing
		//=================================================================
		if((vResourceName.GetType() != VT_NULL ) && ( vImagePath.GetType() != VT_NULL  ))
		{
			//=============================================================
			//  If this was a mof that was being added, then add it
			//=============================================================
			CWMIBinMof bMof;
			hr = bMof.Initialize(WMIINTERFACE,m_fUpdateNamespace);
			if( S_OK == hr )
			{

 				bMof.ExtractBinaryMofFromFile(vImagePath.GetStr(),vResourceName.GetStr(),wcsTmp, m_fMofHasChanged);
			}
		}        
		else if( vResourceName.GetType() != VT_NULL ){
			//=================================================================
			// if we have a resource to query for
			//=================================================================
			CProcessStandardDataBlock * pTmp = new CProcessStandardDataBlock();
			if( pTmp )
			{
				try
				{
					pTmp->UpdateNamespace(m_fUpdateNamespace);
					pTmp->SetClassProcessPtr(m_Class);

					hr = pTmp->OpenWMIForBinaryMofGuid();
					if( hr == S_OK )
					{
						hr = pTmp->QuerySingleInstance(vResourceName.GetStr());
						if( hr == S_OK )
						{
							hr = pTmp->ProcessBinaryMofDataBlock(vResourceName,wcsTmp);
							m_fMofHasChanged = pTmp->HasMofChanged();
						}
						else
						{
                			ERRORTRACE((THISPROVIDER,"***************************************\n"));
                			ERRORTRACE((THISPROVIDER,"Instance failed for: "));
							TranslateAndLog(vResourceName.GetStr());
                			ERRORTRACE((THISPROVIDER,"***************************************\n"));
						}
					}
					SAFE_DELETE_PTR(pTmp);
				}
				catch(...)
				{
					SAFE_DELETE_PTR(pTmp);
					hr = WBEM_E_UNEXPECTED;
					throw;
				}
			}
		}
	}
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessBinaryMof()
{
	//================================================================
	//  The binary mof blocks are always going to be two strings,
	//  1).  Image Path
	//  2).  Mof resource name
	//
	//  If the image path and resource name are both filled in, then
	//  we need to go open the file and extract the binary mof as 
	//  usual.
	//  If the Imagepath is empty, then the mof resource name is going
	//  to contain the static instance name to query for, we then
	//  process that.
	//================================================================
    CVARIANT vImagePath, vResourceName;
	CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
	m_dwAccumulativeSizeOfBlock = 0;

    HRESULT hr = MapWMIData.GetDataFromDataBlock(vImagePath,VT_BSTR,0);
    if( SUCCEEDED(hr) )
	{
	    hr = MapWMIData.GetDataFromDataBlock(vResourceName,VT_BSTR,0);
        if( hr == S_OK )
		{
            if( m_Class->GetHardCodedGuidType() == MOF_ADDED )
			{
                hr = AddBinaryMof( vImagePath, vResourceName);
            }
            else
			{
                CWMIBinMof bMof;
				hr = bMof.Initialize(WMIINTERFACE,m_fUpdateNamespace);
				if( S_OK == hr )
				{
					hr = bMof.DeleteMofsFromEvent(vImagePath, vResourceName, m_fMofHasChanged);
				}
            }
        }
	}
    return hr;
}
////////////////////////////////////////////////////////////////////
BOOL CWMIDataBlock::ResetMissingQualifierValue(WCHAR * pwcsProperty, CVARIANT & vToken )
{
	BOOL fRc = FALSE;
	CVARIANT vQual;

	CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
	//============================================================
	// We are only going to support this for numerical types
	//============================================================

	HRESULT hr = m_Class->GetQualifierValue(pwcsProperty, L"MissingValue", (CVARIANT*)&vQual);
	if( hr == S_OK ){
		if( vQual.GetType() != VT_EMPTY ){
			if( Map.SetDefaultMissingQualifierValue( vQual, m_Class->PropertyType(), vToken ) ){
				fRc = TRUE;
			}
		}
    }
	return fRc;
	
}
////////////////////////////////////////////////////////////////////
BOOL CWMIDataBlock::ResetMissingQualifierValue(WCHAR * pwcsProperty, SAFEARRAY *& pSafe)
{
	BOOL fRc = FALSE;
	CVARIANT vQual;
	
	CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
	//============================================================
	// We are only going to support this for numerical types
	//============================================================

	HRESULT hr = m_Class->GetQualifierValue(pwcsProperty, L"MissingValue", (CVARIANT*)&vQual);
	if( hr == S_OK ){
		if( vQual.GetType() != VT_EMPTY )
		{
			SAFEARRAY * psa = V_ARRAY((VARIANT*)vQual);
			CSAFEARRAY Safe(psa);
			CVARIANT vElement;
            DWORD dwCount = Safe.GetNumElements();
            //============================================================
            //  Now, process it
            //============================================================

            if( dwCount > 0 ){
            	// Set each element of the array
		        for (DWORD i = 0; i < dwCount; i++){

        			if( S_OK == Safe.Get(i,&vElement) ){
                        long lType = m_Class->PropertyType();

		        		if( Map.SetDefaultMissingQualifierValue( vQual, lType, vElement ) ){
       			        	Map.PutInArray(pSafe,(long *)&i,lType,(VARIANT * )vElement);
						    fRc = TRUE;

	        			}
			        }
                }
            }
		}
    }
	return fRc;
	
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::RegisterWMIEvent( WCHAR * wcsGuid, ULONG_PTR uContext, CLSID & Guid, BOOL fRegistered)
{
    ULONG Status;
    HRESULT hr = WBEM_E_UNEXPECTED;

    if( SetGuid(wcsGuid, Guid) ){

        try
        {
            if( !fRegistered )
            {
                Status = WmiNotificationRegistration(&Guid, TRUE, EventCallbackRoutine, uContext, NOTIFICATION_CALLBACK_DIRECT);
            }
            else
            {
                Status = WmiNotificationRegistration(&Guid, TRUE, EventCallbackRoutine, uContext, NOTIFICATION_CHECK_ACCESS );
            }
       		hr = MapReturnCode(Status);
        }
        catch(...)
        {
            // don't throw
        }
    }

    if( hr != S_OK )
    {
        ERRORTRACE((THISPROVIDER,"WmiNotificationRegistration failed ...%ld\n",Status));
    }

   	return hr;
}
//=============================================================
void CWMIDataBlock::GetNextNode()
{
    BOOL fRc = FALSE;

    //============================================================================================
    //   If we still have more instances to get, then get them
    //============================================================================================
    if( m_nCurrentInstance < m_nTotalInstances ){
		m_upNameOffsets++;
        fRc = TRUE;
    }
    else{

        //========================================================================================
        //  Otherwise, lets see if we have another NODE to get, if not, then we are done.
        //========================================================================================
        if (m_pAllWnode->WnodeHeader.Linkage != 0){

            m_pAllWnode = (PWNODE_ALL_DATA)OffsetToPtr(m_pAllWnode, m_pAllWnode->WnodeHeader.Linkage);
	        m_pHeaderWnode = &(m_pAllWnode->WnodeHeader);
       	    m_nTotalInstances = m_pAllWnode->InstanceCount;
            m_nCurrentInstance = 0;
            m_upNameOffsets = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->OffsetInstanceNameOffsets); 
            if( ParseHeader() ){
	    		fRc = InitializeDataPtr();
		    }
		    fRc = TRUE;
        }
	}

	m_fMore = fRc;
}

////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ReadWMIDataBlockAndPutIntoWbemInstance()
{
	//===============================================
    //  Read the data and name blocks
    //===============================================
    HRESULT hr = ProcessDataBlock();
    if( hr == S_OK ){

		//=======================================================
		//  if this isn't a binary mof to process, then we will
		//  process the name block, otherwise we will return
		//  as binary mofs do not have any more useful info in
		//  them in the name block - we already have what we need
		//  from the data block ( at this present time anyway...)
		//=======================================================
		if( !m_Class->GetHardCodedGuidType() ){

			hr = ProcessNameBlock(TRUE);
			if( hr == S_OK ){
        		//===============================================
				//  Get the next node name and data ptrs ready
    			//===============================================
				if( m_pAllWnode ){
					GetNextNode();
				}
   				m_nCurrentInstance++;
			}
		}
    }

    return hr;
}
//=============================================================
HRESULT CWMIDataBlock::ReAllocateBuffer(DWORD dwAddOn)
{
    HRESULT hr = WBEM_E_FAILED;

    m_dwCurrentAllocSize += MEMSIZETOALLOCATE * ((dwAddOn / MEMSIZETOALLOCATE) +1);

	// save the old buffer ptr
    BYTE * pOld = m_pbDataBuffer;

	if( pOld ){
		// save the location of where we are
        ULONG_PTR dwHowmany;
        dwHowmany = (ULONG_PTR)m_pbWorkingDataPtr - (ULONG_PTR)m_pbDataBuffer;

		// get the new buffer
		m_pbDataBuffer = new BYTE[m_dwCurrentAllocSize+1];
		if( m_pbDataBuffer )
        {
		    // copy what we have so far
		    memcpy(m_pbDataBuffer,pOld,dwHowmany);

		    // Set the working ptr to the current place
		    m_pbWorkingDataPtr = m_pbDataBuffer;
		    m_pbWorkingDataPtr += dwHowmany;

		    // delete the old buffer
	        SAFE_DELETE_ARRAY(pOld);
            hr = S_OK;
        }
		else
		{
		    m_dwCurrentAllocSize -= MEMSIZETOALLOCATE * ((dwAddOn / MEMSIZETOALLOCATE) +1);
			m_pbDataBuffer = pOld;
		}
	}

	return hr;
}
//=============================================================
HRESULT CWMIDataBlock::AllocateBuffer(DWORD dwSize)
{
    HRESULT hr = WBEM_E_FAILED;
	m_pbDataBuffer = new byte[dwSize+2];
	if( m_pbDataBuffer )
    {
		hr = S_OK;
	}
    return hr;
}
//=============================================================
void CWMIDataBlock::ResetDataBuffer()
{
	if(m_dwCurrentAllocSize)
	{
		m_dwDataBufferSize = 0;
		m_dwCurrentAllocSize = 0;
		SAFE_DELETE_ARRAY(m_pbDataBuffer);
	}
}
//=============================================================
HRESULT CWMIDataBlock::SetAllInstancePtr( PWNODE_ALL_DATA pwAllNode )
{
	m_pbDataBuffer = (BYTE*)pwAllNode;
    return(SetAllInstanceInfo());
}
//=============================================================
HRESULT CWMIDataBlock::SetSingleInstancePtr( PWNODE_SINGLE_INSTANCE pwSingleNode )
{
	m_pbDataBuffer = (BYTE*)pwSingleNode;
    return(SetSingleInstanceInfo());
}
//=============================================================
HRESULT CWMIDataBlock::SetAllInstanceInfo()
{
    HRESULT hr = WBEM_E_INVALID_OBJECT;
    if( m_pbDataBuffer ){
      	m_pAllWnode = (PWNODE_ALL_DATA)m_pbDataBuffer;
	    m_upNameOffsets = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->OffsetInstanceNameOffsets); 
    	m_nCurrentInstance = 1;
	    m_nTotalInstances = m_pAllWnode->InstanceCount;
        m_pHeaderWnode = &(m_pAllWnode->WnodeHeader);
        m_pSingleWnode = NULL;
		if( m_nTotalInstances > 0 ){
			if( ParseHeader() ){
				if( InitializeDataPtr()){
	                hr = S_OK;
		        }
			}
		}
		else{
			hr = WBEM_S_NO_MORE_DATA;
		}
	}
    return hr;
}
//=============================================================
HRESULT CWMIDataBlock::SetSingleInstanceInfo()
{
    HRESULT hr = WBEM_E_INVALID_OBJECT;
    if( m_pbDataBuffer ){
    	m_pSingleWnode = (PWNODE_SINGLE_INSTANCE)m_pbDataBuffer;
	    m_upNameOffsets = (ULONG *)OffsetToPtr(m_pSingleWnode, m_pSingleWnode->OffsetInstanceName); 
	    m_nCurrentInstance = 1;
	    m_nTotalInstances = 1;
        m_pAllWnode = NULL;
        m_pHeaderWnode = &(m_pSingleWnode->WnodeHeader);
        if( ParseHeader() ){
            if( InitializeDataPtr()){
                hr = S_OK;
            }
        }
    }
    return hr;
}
//=============================================================
BOOL CWMIDataBlock::InitializeDataPtr()
{
    //=====================================================
    //  Either the m_pAllWnode or m_pSingleNode is Null,
    //  which ever isn't, is the type we are working with
    //=====================================================
    if(m_pAllWnode){
		if( m_fFixedInstance ){
			m_pbCurrentDataPtr =(BYTE*) (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->DataBlockOffset);
			//==========================================================================================
			// for the case of binary mofs, we need to know the size of the instance to calculate the
			// crc, so we need to put the whole size of the fixed instance buffer.
			//==========================================================================================
			m_uInstanceSize = m_pAllWnode->FixedInstanceSize;
		}
		else{
            m_pbCurrentDataPtr =(BYTE*)(ULONG*) m_pAllWnode->OffsetInstanceDataAndLength;
		}
		m_pMaxPtr = (ULONG *)OffsetToPtr(m_pAllWnode, m_pHeaderWnode->BufferSize);
    }
    else{
        if( m_pSingleWnode ){
		    m_fFixedInstance = TRUE;
            m_pbCurrentDataPtr = (BYTE*)(ULONG *)OffsetToPtr(m_pSingleWnode, m_pSingleWnode->DataBlockOffset);
		    m_pMaxPtr = (ULONG *)OffsetToPtr(m_pSingleWnode, m_pHeaderWnode->BufferSize);
			//==========================================================================================
			// for the case of binary mofs, we need to know the size of the instance to calculate the
			// crc, so we need to put the whole size of the fixed instance buffer.
			//==========================================================================================
			m_uInstanceSize = m_pSingleWnode->SizeDataBlock;

        }
    }
	if( (ULONG*)m_pbCurrentDataPtr > (ULONG*) m_pMaxPtr ){
		return FALSE;
	}
	if( (ULONG*) m_pbCurrentDataPtr < (ULONG*) m_pAllWnode ){
		return FALSE;
	}

	return TRUE;
}

//=============================================================
BOOL CWMIDataBlock::ParseHeader() 
{
    BOOL fRc;
	//====================================================
    // Check out class to see if it is valid first
	//====================================================
	if( !m_pHeaderWnode ){
		return FALSE;
	}
    m_ulVersion = m_pHeaderWnode->Version;

	if ((m_pHeaderWnode->BufferSize == 0)){
		fRc = FALSE;
	}
    else{
        if (m_pHeaderWnode->Flags &  WNODE_FLAG_FIXED_INSTANCE_SIZE){
		    m_fFixedInstance = TRUE;
        }
	    else{
		    m_fFixedInstance = FALSE;
	    }
    
        fRc = TRUE;
    }
    return fRc;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::WriteArrayTypes(WCHAR * pwcsProperty, CVARIANT & v)
{
    LONG lType = 0;
    DWORD dwCount = 0;
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CVARIANT vValue;
    BOOL fDynamic = FALSE;

    m_Class->GetSizeOfArray( lType,dwCount, fDynamic);
	if( fDynamic && dwCount == 0 )
	{
		return WBEM_S_NO_ERROR;
	}


	//============================================================
	//  Make sure we get a valid ptr
	//============================================================
	VARIANT *p = (VARIANT *)v;
	SAFEARRAY * psa = V_ARRAY(p);
    if( IsBadReadPtr( psa, sizeof(SAFEARRAY) != 0)){
        return hr;
    }

	CSAFEARRAY Safe(psa);
	//============================================================
	//  Make sure there is really what we expect in the array
    //  NOTE:  The MAX represents the fixed size of the array,
    //         while if it is a dynamic array, the size is determined
    //         by the property listed in the WMIDATASIZE is property.
    //         either way, the size returned above is the size the
    //         array is supposed to be, if it isn't error out.
	//============================================================
	DWORD dwNumElements = Safe.GetNumElements();
	if( dwNumElements != dwCount ){
		Safe.Unbind();
		// Don't need to destroy, it will be destroyed
		return WBEM_E_INVALID_PARAMETER;
	}

    //============================================================
    //  Set missing qualifier value to the value from the NULL
    //============================================================
    if( vValue.GetType() == VT_NULL ){
        ResetMissingQualifierValue(pwcsProperty,psa);
    }

	// if the array is not array of embedded instances
	// then check if the buffer allocated is enough
	if(lType != VT_UNKNOWN)
	{
		// This function check if enought memory is allocated and if not
		// allocates memory
		if(S_OK != GetBufferReady(m_Class->PropertySize() * (dwCount + 1)))
		{
			return WBEM_E_FAILED;
		}
	}
    //============================================================
    //  Now, process it
    //============================================================

    if( dwCount > 0 ){
		// Set each element of the array
		for (DWORD i = 0; i < dwCount; i++){
			if( lType == VT_UNKNOWN ){
				// embedded object
				IUnknown * pUnk = NULL;
				hr = Safe.Get(i, &pUnk); 
				if( pUnk ){
					hr = WriteEmbeddedClass(pUnk,vValue);
				}
				else{
					hr = WBEM_E_FAILED;
				}
			}
			else{

        		CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
                
				if(!MapWMIData.SetDataInDataBlock(&Safe,i,vValue,lType,m_Class->PropertySize()) ){
					hr = WBEM_E_FAILED;
					break;
				}
				else{
					hr = S_OK;
				}
			}
            if (WBEM_S_NO_ERROR != hr){
    		    break;
            }
 	    }
    }        
	Safe.Unbind();
	// Don't need to destroy, it will be destroyed
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessArrayTypes(VARIANT & vToken,WCHAR * pwcsProperty)
{
    LONG lConvertedType = 0, lType = 0;
    DWORD dwCount = 0;
    BOOL fDynamic = TRUE; 

    HRESULT hr = m_Class->GetSizeOfArray( lType,dwCount, fDynamic);
	if( hr != S_OK ){
		return hr;
	}


    if( dwCount > 0 )
	{
		CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
	    //======================================================
        // Allocate array with the converted data type.
		// WMI and CIM data types do not match, so use the
		// mapping class to get the correct size of the target
		// property for CIM
	    //======================================================
		lConvertedType = MapWMIData.ConvertType(lType);
        SAFEARRAY * psa = OMSSafeArrayCreate((unsigned short)lConvertedType,dwCount);
        if(psa == NULL)
		{
            return WBEM_E_FAILED;
        }

        //=======================================================   
        //  Now, get the MissingValue for each element of the 
        //  array
        //=======================================================   
		lConvertedType = lType;
		BOOL fMissingValue = FALSE;
	    CVARIANT vQual; 
		SAFEARRAY * psaMissingValue = NULL;
		long lMax = 0;

		CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
		hr = m_Class->GetQualifierValue( pwcsProperty, L"MissingValue", (CVARIANT *)&vQual );
		if( hr == S_OK )
		{
			if( vQual.GetType() != VT_EMPTY )
			{
				//============================================================
				//  Make sure we get a valid ptr
				//============================================================
				psaMissingValue = V_ARRAY((VARIANT*)&vQual);
				fMissingValue = TRUE;
				// Don't need to destroy, it will be destroyed in the deconstructor
			}
		}

		CSAFEARRAY SafeMissingValue(psaMissingValue);
		lMax = SafeMissingValue.GetNumElements();

	    for (long i = 0; i < (long)dwCount; i++)
		{
            CVARIANT v;

		    if( lType == VT_UNKNOWN )
			{
                // embedded object
                hr = ProcessEmbeddedClass(v);
				if( S_OK == hr )
				{
					MapWMIData.PutInArray(psa,(long *)&i,lConvertedType,(VARIANT * )v);
				}
		    }
		    else
			{
			    hr = MapWMIData.GetDataFromDataBlock(v,lType,m_Class->PropertySize());
				if( hr != S_OK )
				{
					wcscpy(m_wcsMsg,MSG_INVALID_BLOCK_POINTER);
				}
				else
				{
					BOOL fPutProperty = TRUE;
					if( fMissingValue )
					{
						if( i < lMax )
						{
							CVARIANT vElement;
							if( Map.MissingQualifierValueMatches( &SafeMissingValue, i, vElement, v.GetType(), v ) )
							{
								fPutProperty = FALSE;
							}
						}
					}
					if( fPutProperty )
					{
						MapWMIData.PutInArray(psa,(long *)&i,lConvertedType,(VARIANT * )v);
					}
				}
		    }
            if (WBEM_S_NO_ERROR != hr)
			{
			    break;
            }

	    }

        vToken.vt = (VARTYPE)(lConvertedType | CIM_FLAG_ARRAY);
        vToken.parray = psa;
    }        
	else{
		hr = WBEM_S_NO_MORE_DATA;
	}
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessEmbeddedClass(CVARIANT & v)
{
	HRESULT hr = WBEM_E_FAILED;

    CWMIProcessClass EmbeddedClass(0);
	hr = EmbeddedClass.Initialize();
	if( S_OK == hr )
	{
		 hr = EmbeddedClass.InitializeEmbeddedClass(m_Class);
		DWORD dwAccumulativeSize = 0;

		CAutoChangePointer p(&m_Class,&EmbeddedClass);
		if( hr == S_OK ){

			//=============================================
			//  Align the embedded class properly
			//=============================================
			int nSize = 0L;
			hr = EmbeddedClass.GetLargestDataTypeInClass(nSize);
			// NTRaid:136388
			// 07/12/00
			if( hr == S_OK && nSize > 0){

				CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
				if( Map.NaturallyAlignData(nSize, READ_IT)){
					dwAccumulativeSize = m_dwAccumulativeSizeOfBlock - nSize;
					hr = S_OK;
				}
				else{
					hr = WBEM_E_FAILED;
				}
			}
			else
			if(nSize <= 0 && hr == S_OK)
			{
				hr = WBEM_E_FAILED;
			}
		}

		//=============================================
		//  Get the class
		//=============================================
		if( hr == S_OK ){
		
			hr = FillOutProperties();
			if( hr == S_OK ){
				m_dwAccumulativeSizeOfBlock += dwAccumulativeSize;
				//=============================================
				//  Save the object
				//=============================================
				EmbeddedClass.SaveEmbeddedClass(v);
			}
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::WriteEmbeddedClass( IUnknown * pUnknown,CVARIANT & v)
{
	HRESULT hr = WBEM_E_FAILED;
    CWMIProcessClass EmbeddedClass(0);

	hr = EmbeddedClass.Initialize();
	if( S_OK == hr )
	{
		hr = EmbeddedClass.InitializeEmbeddedClass(m_Class);

		CAutoChangePointer p(&m_Class,&EmbeddedClass);

		//=============================================
		hr = EmbeddedClass.ReadEmbeddedClassInstance(pUnknown,v);
		if( hr == S_OK ){
			//=============================================
			//  Align the embedded class properly
			//=============================================
			int nSize = 0L;
			hr = EmbeddedClass.GetLargestDataTypeInClass(nSize);
			if( hr == S_OK && nSize > 0){
				CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
				if( Map.NaturallyAlignData(nSize,WRITE_IT)){
					m_dwAccumulativeSizeOfBlock -= nSize;
					hr = ConstructDataBlock(FALSE);
				}
				else{
					hr = WBEM_E_FAILED;
				}
			}
			else{
				hr = WBEM_E_FAILED;
			}
		}
	}
    return hr;
}
///////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::SetSingleItem()
{
    WCHAR * pwcsInst = NULL;
    ULONG uRc = E_UNEXPECTED;
    
    if( SUCCEEDED(m_Class->GetInstanceName(pwcsInst)))
    {

        try
        {
           uRc = WmiSetSingleItem( m_hCurrentWMIHandle, pwcsInst, m_Class->WMIDataId(), m_ulVersion, m_dwDataBufferSize, m_pbDataBuffer);
        }
        catch(...)
        {
            // don't throw
        }

        SAFE_DELETE_ARRAY(pwcsInst);
    }

	return(MapReturnCode(uRc));
}

////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::GetBufferReady(DWORD dwCount)
{
    if( (m_dwDataBufferSize + dwCount ) > m_dwCurrentAllocSize ){
		if( FAILED(ReAllocateBuffer(dwCount))){
			return WBEM_E_FAILED;
   		}
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::WriteDataToBufferAndIfSinglePropertySubmitToWMI( BOOL fInit, BOOL fPutProperty)
{
    HRESULT hr = WBEM_E_FAILED;
	CIMTYPE lType;
    WCHAR * pwcsProperty;
	CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);

    if( fInit ){
    	if( !GetDataBlockReady(MEMSIZETOALLOCATE,FALSE) ){
		    return WBEM_E_FAILED;
        }
	}

	//=============================================================
	// get first delimiter in the ordered string	
	//=============================================================
    pwcsProperty = m_Class->FirstProperty();
    
	while (NULL != pwcsProperty){

    	CVARIANT vValue;
	    vValue.Clear();
        memset(&vValue,0,sizeof(CVARIANT));
        //======================================================
	    // Get a property type and value		
	    //======================================================
        hr = m_Class->GetPropertyInInstance(pwcsProperty, vValue, lType);		

	    //======================================================
		//  We need to put in defaults if there are some 
        //  available
	    //======================================================
		if( hr == S_OK ){

           if( ( vValue.GetType() == VT_NULL )&&
                 ( m_Class->PropertyType() != CIM_STRING &&
                 m_Class->PropertyType() != CIM_DATETIME &&
                 m_Class->PropertyCategory() != CWMIProcessClass::Array))
           {
                hr = WBEM_E_INVALID_PARAMETER;
				break;
    		}
		}

	    if( SUCCEEDED(hr) ){

		    //==================================================
			//  Check to see if the buffer is big enough
			//==================================================
            if( S_OK != GetBufferReady(m_Class->PropertySize())){
   				return WBEM_E_FAILED;
		    }

            //==================================================
			//  Add the current buffer size
		    //==================================================
            switch( m_Class->PropertyCategory()){

                case CWMIProcessClass::EmbeddedClass:
				    hr = WriteEmbeddedClass((IUnknown *)NULL,vValue);
   		            break;

                case CWMIProcessClass::Array:
    		        hr = WriteArrayTypes(pwcsProperty,vValue);
	                break;

                case CWMIProcessClass::Data:
                    //============================================================
                    //  Set missing qualifier value to the value from the NULL
                    //============================================================
                    if( vValue.GetType() == VT_NULL ){
                        ResetMissingQualifierValue(pwcsProperty,vValue);
                    }

					if( !MapWMIData.SetDataInDataBlock( NULL,0,vValue,m_Class->PropertyType(),m_Class->PropertySize())){
						hr = WBEM_E_FAILED;
					}
	                break;
            }
            //=================================================
            //  If we could not set it, then get out
            //=================================================
            if( hr != S_OK ){
                break;
            }
            //=================================================
            //  If we are supposed to put the single property
            //  at this point, then write it, otherwise, keep
            //  accumulating it.  If it is == NULL, we don't
            //  want it.
            //=================================================
            if( fPutProperty ){

				//=================================================================================
				//  If we are supposed to set just this property, then do so, otherwise don't
				//=================================================================================
                m_dwDataBufferSize = m_dwAccumulativeSizeOfBlock;
				if( m_Class->GetPutProperty() ){

                    if( ( vValue.GetType() == VT_NULL )&& ( m_Class->PropertyType() != CIM_STRING && m_Class->PropertyType() != CIM_DATETIME )){
                        ERRORTRACE((THISPROVIDER,"Datatype does not support NULL values\n"));
                        hr = WBEM_E_INVALID_PARAMETER;
                   }
                    else{
						hr = SetSingleItem();
						if( hr != S_OK ){
							break;
						}
            			if( !GetDataBlockReady(MEMSIZETOALLOCATE,FALSE) ){
    						return hr;
						}
					}
				}
                m_dwAccumulativeSizeOfBlock = 0;
            }
            //=================================================
	    }
		m_dwDataBufferSize = m_dwAccumulativeSizeOfBlock;	
	    pwcsProperty = m_Class->NextProperty();
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ConstructDataBlock(BOOL fInit)
{
    return( WriteDataToBufferAndIfSinglePropertySubmitToWMI(fInit,FALSE) );
}    
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::PutSingleProperties()
{

    return( WriteDataToBufferAndIfSinglePropertySubmitToWMI(TRUE,TRUE) );
}
////////////////////////////////////////////////////////////////////////
BOOL CWMIDataBlock::GetListOfPropertiesToPut(int nWhich, CVARIANT & vList)
{
    BOOL fRc = FALSE;
    //=========================================================
    //  if nWhich == PUT_PROPERTIES_ONLY, we aren't going to
    //  do anything special, as, by default, the fPutProperty 
    //  flag on the property is set to TRUE, so, in the 
    //  processing above, we will put the properties that are
    //  not NULL.  The only problem we have now, is if 
    //  __PUT_EXT_PROPERTIES is set to TRUE, then we have to
    //  loop through all of the properties to see it they
    //  are in our __PUT_EXT_PROPERTIES list, if they are NOT
    //  then we are going to set the fPutProperty flag on that
    //  property to FALSE, so we won't process it above.
    //=========================================================
    if( nWhich == PUT_PROPERTIES_ONLY ){
        fRc = TRUE;
    }
    else{

    	//=====================================================
    	//  Make sure we get a valid ptr
    	//=====================================================
		SAFEARRAY * psa = V_ARRAY((VARIANT*)vList);
		if( IsBadReadPtr( psa, sizeof(SAFEARRAY) != 0))
		{
			return FALSE;
	    }

		CSAFEARRAY Safe(psa);
		DWORD dwCount = Safe.GetNumElements();

		// Set each element of the array
		for (DWORD i = 0; i < dwCount; i++){
            CBSTR bstrProperty;
            WCHAR * pwcsProperty = NULL;
            //=================================================
            //  Loop thru all the properties in the class and
            //  see which ones are in the list to be PUT
            //=================================================
            pwcsProperty = m_Class->FirstProperty();
            while( pwcsProperty != NULL ){

                BOOL fFound = FALSE;

    		    for (DWORD i = 0; i < dwCount; i++)
                {
                    if( S_OK != Safe.Get(i, &bstrProperty))
                    {
                        return FALSE;
                    }
                    if( _wcsicmp( bstrProperty, pwcsProperty ) == 0 )
                    {
                        fFound = TRUE;
                        break;
                    }
                }
                if( !fFound ){
                    m_Class->SetPutProperty(FALSE);
                }
				pwcsProperty = m_Class->NextProperty();
     	    }
 	    }
		Safe.Unbind();
		// Don't need to destroy, it will be destroyed
		fRc = TRUE;
    }        

    return fRc;
}
//=============================================================
BOOL CWMIDataBlock::GetDataBlockReady(DWORD dwSize,BOOL fReadingData)
{
    BOOL fRc = FALSE;

    ResetDataBuffer();
    m_dwCurrentAllocSize = dwSize;
    if( SUCCEEDED(AllocateBuffer(m_dwCurrentAllocSize)))
    {
        m_pbCurrentDataPtr = m_pbWorkingDataPtr = m_pbDataBuffer;
        //===================================================
        //  If we are writing data, we will let the size
        //  remain at 0, otherwise set it to what the max
        //  is we can read.
        //===================================================
        if(fReadingData){
            m_dwDataBufferSize = dwSize;
        }
        fRc = TRUE;
    }
	else
	{
		m_dwCurrentAllocSize = 0;
	}

	return fRc;
}
//=============================================================
void CWMIDataBlock::AddPadding(DWORD dwBytesToPad)
{
	m_pbWorkingDataPtr += dwBytesToPad;
}
//=============================================================
inline BOOL CWMIDataBlock::PtrOk(ULONG * pPtr,ULONG uHowMany)
{ 
    ULONG * pNewPtr;
	pNewPtr = (ULONG *)OffsetToPtr(pPtr,uHowMany);
	if(pNewPtr <= m_pMaxPtr){	
		return TRUE;
	}
	return FALSE;
}
//=============================================================
BOOL CWMIDataBlock::CurrentPtrOk(ULONG uHowMany)
{ 
    return(PtrOk((ULONG *)m_pbWorkingDataPtr,uHowMany));
}
//=============================================================
void CWMIDataBlock::GetWord(WORD & wWord)
{
    memcpy( &wWord,m_pbWorkingDataPtr,sizeof(WORD));
	m_pbWorkingDataPtr += sizeof(WORD);
}
//=============================================================
void CWMIDataBlock::GetDWORD(DWORD & dwWord)
{
    memcpy( &dwWord,m_pbWorkingDataPtr,sizeof(DWORD));
	m_pbWorkingDataPtr += sizeof(DWORD);
}
//=============================================================
void CWMIDataBlock::GetFloat(float & fFloat)
{
    memcpy( &fFloat,m_pbWorkingDataPtr,sizeof(float));
	m_pbWorkingDataPtr += sizeof(float);
}
//=============================================================
void CWMIDataBlock::GetDouble(DOUBLE & dDouble)
{
    memcpy( &dDouble,m_pbWorkingDataPtr,sizeof(DOUBLE));
    m_pbWorkingDataPtr += sizeof(DOUBLE);
}
	
//=============================================================
void CWMIDataBlock::GetSInt64(WCHAR * pwcsBuffer)
{
	signed __int64 * pInt64;
	pInt64 = (__int64 *)m_pbWorkingDataPtr;
	swprintf(pwcsBuffer,L"%I64d",*pInt64);		
	m_pbWorkingDataPtr += sizeof( signed __int64);
}
//=============================================================
void CWMIDataBlock::GetQWORD(unsigned __int64 & uInt64)
{
    memcpy( &uInt64,m_pbWorkingDataPtr,sizeof(unsigned __int64));
	m_pbWorkingDataPtr += sizeof(unsigned __int64);
}

//=============================================================
void CWMIDataBlock::GetUInt64(WCHAR * pwcsBuffer)
{
	unsigned __int64 * puInt64;
	puInt64 = (unsigned __int64 *)m_pbWorkingDataPtr;
	swprintf(pwcsBuffer,L"%I64u",*puInt64);		
	m_pbWorkingDataPtr += sizeof(unsigned __int64);
}
//=============================================================
void CWMIDataBlock::GetString(WCHAR * pwcsBuffer,WORD wCount,WORD wBufferSize)
{
    memset(pwcsBuffer,NULL,wBufferSize);
	memcpy(pwcsBuffer,m_pbWorkingDataPtr, wCount);		
	m_pbWorkingDataPtr += wCount;
}
//=============================================================
void CWMIDataBlock::GetByte(BYTE & bByte)
{
    memcpy( &bByte,m_pbWorkingDataPtr,sizeof(BYTE));
	m_pbWorkingDataPtr += sizeof(BYTE);
}
//=============================================================
void CWMIDataBlock::SetWord(WORD wWord)
{
    memcpy(m_pbWorkingDataPtr,&wWord,sizeof(WORD));
	m_pbWorkingDataPtr += sizeof(WORD);
}
//=============================================================
void CWMIDataBlock::SetDWORD(DWORD dwWord)
{
    memcpy(m_pbWorkingDataPtr,&dwWord,sizeof(DWORD));
	m_pbWorkingDataPtr += sizeof(DWORD);
}
//=============================================================
void CWMIDataBlock::SetFloat(float fFloat)
{
    memcpy(m_pbWorkingDataPtr,&fFloat,sizeof(float));
	m_pbWorkingDataPtr += sizeof(float);
}
//=============================================================
void CWMIDataBlock::SetDouble(DOUBLE dDouble)
{
    memcpy( m_pbWorkingDataPtr,&dDouble,sizeof(DOUBLE));
	m_pbWorkingDataPtr += sizeof(DOUBLE);
}
	
//=============================================================
void CWMIDataBlock::SetSInt64(__int64 Int64)
{
    memcpy(m_pbWorkingDataPtr,&Int64,sizeof(__int64));
	m_pbWorkingDataPtr += sizeof(__int64);									
}
//=============================================================
void CWMIDataBlock::SetUInt64(unsigned __int64 UInt64)
{
    memcpy(m_pbWorkingDataPtr,&UInt64,sizeof(unsigned __int64));
	m_pbWorkingDataPtr += sizeof(unsigned __int64);									
}
//=============================================================
void CWMIDataBlock::SetString(WCHAR * pwcsBuffer,WORD wCount)
{
	memcpy(m_pbWorkingDataPtr,pwcsBuffer, wCount);		
	m_pbWorkingDataPtr += wCount;
}
//=============================================================
void CWMIDataBlock::SetByte(byte bByte)
{
    memcpy(m_pbWorkingDataPtr,&bByte,sizeof(byte));
	m_pbWorkingDataPtr += sizeof(byte);

}
///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//
//  CProcessStandardDataBlock
//
//*************************************************************************************************

/////////////////////////////////////////////////////////////////////////////////////////////////////////
CProcessStandardDataBlock::CProcessStandardDataBlock() 
{
    m_Class = NULL;
    m_pMethodInput = NULL;
    m_pMethodOutput = NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
CProcessStandardDataBlock::~CProcessStandardDataBlock()
{

}
////////////////////////////////////////////////////////////////////
// WMIRaid:2445
HRESULT CProcessStandardDataBlock::FillOutProperties()	
{
	HRESULT hr = WBEM_E_INVALID_OBJECT;
 
    if( m_Class->GetHardCodedGuidType() )
    {
        hr = ProcessBinaryMof();
	}

    else if(m_Class->GetANewInstance()){
 
       	//=========================================================
	    // get the properties from the class and read the WMI Data
	    //=========================================================
        hr = WBEM_S_NO_ERROR;
        WCHAR * pwcsProperty=NULL;
    	CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
		m_dwAccumulativeSizeOfBlock = 0L;						

        pwcsProperty = m_Class->FirstProperty();
        while (NULL != pwcsProperty)
        {
            CVARIANT vToken;
            //=========================================================
            // See if it is an array or not
            //=========================================================
            switch( m_Class->PropertyCategory()){

                case CWMIProcessClass::EmbeddedClass:
                    hr = ProcessEmbeddedClass(vToken);
					if( hr == S_OK )
                    {
						m_Class->PutPropertyInInstance(&vToken);
					}
                    break;

                case CWMIProcessClass::Array:
                    VARIANT v;
                    VariantInit(&v);
                    hr = ProcessArrayTypes(v,pwcsProperty);
                    if( hr == WBEM_S_NO_MORE_DATA )
                    {
                        hr = S_OK;
                    }
                    else if( SUCCEEDED(hr) )
                    {
                        hr = m_Class->PutPropertyInInstance(&v);
	                }
                    VariantClear(&v);
                    break;

                case CWMIProcessClass::Data:

			        hr = MapWMIData.GetDataFromDataBlock(vToken, m_Class->PropertyType(), m_Class->PropertySize());
    	            if( SUCCEEDED(hr) )
                    {
						CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
						//============================================================
						// We are only going to support this for numerical types
						//============================================================
						CVARIANT vQual;
						hr = m_Class->GetQualifierValue( pwcsProperty, L"MissingValue", (CVARIANT *)&vQual);
						if( hr == S_OK )
						{
							if( vQual.GetType() != VT_EMPTY )
							{
								if( !(Map.MissingQualifierValueMatches( NULL, 0,vQual, vToken.GetType(), vToken ) ))
								{
			                        hr = m_Class->PutPropertyInInstance(&vToken);
								}
							}
							else
							{
								hr = m_Class->PutPropertyInInstance(&vToken);
							}
						}
						else
						{
	                        hr = m_Class->PutPropertyInInstance(&vToken);
						}
	                }
					else
                    {
						wcscpy(m_wcsMsg,MSG_INVALID_BLOCK_POINTER);
					}
                    break;
	        }
        	pwcsProperty = m_Class->NextProperty();
	    }
        //===============================================
	    // Set the active value
	    //===============================================
        m_Class->SetActiveProperty();
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CProcessStandardDataBlock::CreateOutParameterBlockForMethods()
{
    HRESULT hr = WBEM_E_FAILED;
    BOOL fRc = FALSE;

	//========================================================
	//  If we don't have a class, then we don't have to
	//  worry about creating a block
	//========================================================
	if( !m_pMethodOutput->ValidClass() ){
		ResetDataBuffer();
		return S_OK;
	}
    
    DWORD dwSize = 0L;
    hr = m_pMethodOutput->GetSizeOfClass(dwSize);
    if( hr == S_OK ){
        // Allocate space for property
	    m_dwDataBufferSize = dwSize;
        if( dwSize > 0 ){
            GetDataBlockReady(dwSize,TRUE);
        }
    }
    return hr;
}

//=============================================================
HRESULT CProcessStandardDataBlock::CreateInParameterBlockForMethods( BYTE *& Buffer, ULONG & uBufferSize)
{
    HRESULT hr = WBEM_E_FAILED;
    BOOL fRc = FALSE;

	//========================================================
	//  If we don't have a class, then we don't have to
	//  worry about creating a block
	//========================================================
	if( !m_pMethodInput->ValidClass() ){
		Buffer = NULL;
		uBufferSize = 0;
		return S_OK;
	}

    //========================================================
    // When it goes out of scope, it will reset m_Class back 
    // to what it was
    //========================================================
    CAutoChangePointer p(&m_Class,m_pMethodInput);
		ERRORTRACE((THISPROVIDER,"Constructing the data block"));

	hr = ConstructDataBlock(TRUE);
	if( S_OK == hr ){

		uBufferSize = (ULONG)m_dwDataBufferSize;
		Buffer = new byte[ uBufferSize +1];
        if( Buffer )
        {
	        try
            {
			    memcpy( Buffer, m_pbDataBuffer, uBufferSize );
			    ResetDataBuffer();
			    hr = S_OK;
            }
            catch(...)
            {
                SAFE_DELETE_ARRAY(Buffer);
                hr = WBEM_E_UNEXPECTED;
                throw;
            }
		}
    
	}

    return hr;
}
//=============================================================
HRESULT CProcessStandardDataBlock::ProcessMethodInstanceParameters()
{
	HRESULT hr = WBEM_E_FAILED;

	// Create out-param
	// ================
	m_pMaxPtr = (ULONG *)OffsetToPtr(m_pbDataBuffer, m_dwDataBufferSize);
	m_nCurrentInstance = 1;
	m_nTotalInstances = 1;
	m_pAllWnode = NULL;
	m_pHeaderWnode = NULL;
	m_pbCurrentDataPtr = m_pbWorkingDataPtr = m_pbDataBuffer;
	
    CAutoChangePointer p(&m_Class,m_pMethodOutput);

	hr = FillOutProperties();
	if( hr == S_OK )
	{
        hr = m_pMethodOutput->SendInstanceBack();
	}
    return hr;
}


//=============================================================
// NTRaid:127832
// 07/12/00
//=============================================================
HRESULT CProcessStandardDataBlock::ExecuteMethod(ULONG MethodId, WCHAR * MethodInstanceName, ULONG InputValueBufferSize, 
                                             BYTE * InputValueBuffer )
{
    ULONG uRc = E_UNEXPECTED;

    try
    {
        uRc = WmiExecuteMethod(m_hCurrentWMIHandle, MethodInstanceName, MethodId, InputValueBufferSize,
                               InputValueBuffer,&m_dwDataBufferSize,m_pbDataBuffer);
        if( uRc == ERROR_INSUFFICIENT_BUFFER )
        {
            if( GetDataBlockReady(m_dwDataBufferSize,TRUE))
            {
    	        uRc = WmiExecuteMethod(m_hCurrentWMIHandle, MethodInstanceName, MethodId, InputValueBufferSize,
                                       InputValueBuffer,&m_dwDataBufferSize,m_pbDataBuffer);
            }
        }
    }
    catch(...)
    {
        uRc = E_UNEXPECTED;
        // don't throw
    }

	if( uRc == ERROR_SUCCESS ){
        //===========================================================
        // If we have an out class, process it, otherwise, we are
        // done so set hr to success.
        //===========================================================g
        if( m_pMethodOutput->ValidClass() )
        {
            if(SUCCEEDED(ProcessMethodInstanceParameters())){
                uRc = ERROR_SUCCESS;
            }
        }
	}

    return MapReturnCode(uRc);

}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CProcessStandardDataBlock::GetDataBufferAndQueryAllData(DWORD dwSize)
{
    ULONG uRc = E_UNEXPECTED;
    if(GetDataBlockReady(dwSize,TRUE))
    {
        try
        {
            uRc = WmiQueryAllData(m_hCurrentWMIHandle, &m_dwDataBufferSize,m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
    }
    return uRc;
}
/////////////////////////////////////////////////////////////////////
HRESULT CProcessStandardDataBlock::QueryAllData()
{
    HRESULT hr = WBEM_E_FAILED;
	//============================================================
	//  Get the instances
	//============================================================
    ULONG uRc = GetDataBufferAndQueryAllData(sizeof(WNODE_ALL_DATA));
    if( uRc == ERROR_INSUFFICIENT_BUFFER )
    {
        //=================================================
        //  We just want to try one more time to get it,
        //  if it fails, then bail out. m_dwDataBufferSize
        //  should now have the correct size needed in it
        //=================================================
        uRc = GetDataBufferAndQueryAllData(m_dwDataBufferSize);
    }
    //=====================================================
    //  Ok, since we are querying for all instances, make
    //  sure the header node says that all of the instances
    //  are fine, if not reallocate
    //=====================================================
	if( uRc == ERROR_SUCCESS )
    {
        if( S_OK ==(hr = SetAllInstanceInfo()))
        {
	        if (m_pHeaderWnode->Flags &  WNODE_FLAG_TOO_SMALL)
            {
                while( TRUE )
                {
                    //==========================================================
                    //  keep on querying until we get the correct size
                    //  This error may come from the driver
                    //==========================================================
                    uRc = GetDataBufferAndQueryAllData(m_dwDataBufferSize);
                    if( uRc == ERROR_SUCCESS )
                    {
                        if( S_OK ==(hr = SetAllInstanceInfo()))
                        {
                            if (!(m_pHeaderWnode->Flags &  WNODE_FLAG_TOO_SMALL))
                            {
                                break;
        		            }
			            }
                    } // end GetDataBufferAndQueryAllData
                } // end of while
            } // end of WNODE_FLAG_TOO_SMALL test
        } // end of SetAllInstanceInfo
    }

    //==========================================================================
    //  if uRc succeeded, then the return code is already set by SetAllInstance
    //  otherwise need to map it out
    //==========================================================================
    if( uRc != ERROR_SUCCESS )
    {
        hr  = MapReturnCode(uRc);
    }
 	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CProcessStandardDataBlock::GetDataBufferAndQuerySingleInstance(DWORD dwSize,WCHAR * wcsInstanceName)
{
    ULONG uRc = E_UNEXPECTED;
    if(GetDataBlockReady(dwSize,TRUE))
    {
        try
        {
	        uRc = WmiQuerySingleInstance(m_hCurrentWMIHandle, wcsInstanceName, &m_dwDataBufferSize, m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
    }
    return uRc;
}
///////////////////////////////////////////////////////////////////////
HRESULT CProcessStandardDataBlock::QuerySingleInstance(WCHAR * wcsInstanceName)
{
    
	//============================================================
	//  Get the instances
	//============================================================
    ULONG uRc = GetDataBufferAndQuerySingleInstance(sizeof(WNODE_SINGLE_INSTANCE) + wcslen(wcsInstanceName),wcsInstanceName);
    if( uRc == ERROR_INSUFFICIENT_BUFFER )
    {
        uRc = GetDataBufferAndQuerySingleInstance(m_dwDataBufferSize,wcsInstanceName);
    }

	if( uRc == ERROR_SUCCESS )
    {
		return(SetSingleInstanceInfo());
    }

	return(MapReturnCode(uRc));
}
///////////////////////////////////////////////////////////////////////
// NTRaid : 136392
//	07/12/00
HRESULT CProcessStandardDataBlock::SetSingleInstance()
{
    ULONG uRc = S_OK;

    WCHAR * pwcsInst = NULL;
    
    if( SUCCEEDED(m_Class->GetInstanceName(pwcsInst)))
    {

        try
        {
            uRc = WmiSetSingleInstance( m_hCurrentWMIHandle, pwcsInst,1,m_dwDataBufferSize,m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
        SAFE_DELETE_ARRAY(pwcsInst);
    }
    
	return(MapReturnCode(uRc));
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************************
//
// CProcessHiPerfDataBlock
//
//*******************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::OpenHiPerfHandle()
{
    HRESULT hr = WBEM_E_FAILED;
    ULONG uRc = ERROR_SUCCESS;
    //========================================================
    //  Open the handle
    //========================================================
    try
    {
        uRc = WmiOpenBlock(m_Class->GuidPtr(),m_uDesiredAccess, &m_hCurrentWMIHandle);
        if( uRc == ERROR_SUCCESS )
        {
           // WMIINTERFACE->HandleMap()->Add(*(m_Class->GuidPtr()),m_hCurrentWMIHandle);
	    }
    }
    catch(...)
    {
        hr = E_UNEXPECTED;
        // don't throw
    }

	return MapReturnCode(uRc);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////

ULONG CProcessHiPerfDataBlock::GetDataBufferAndHiPerfQueryAllData(DWORD dwSize,WMIHANDLE * List, long lHandleCount)
{
    ULONG uRc = E_UNEXPECTED;
    if(GetDataBlockReady(dwSize,TRUE))
    {
        try
        {
            uRc = WmiQueryAllDataMultiple(List, lHandleCount, &m_dwDataBufferSize,m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
    }
    return uRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::HiPerfQueryAllData(WMIHANDLE * List,long lHandleCount)
{
    HRESULT hr = WBEM_E_FAILED;
	//============================================================
	//  Get the instances
	//============================================================
    ULONG uRc = GetDataBufferAndHiPerfQueryAllData(sizeof(WNODE_ALL_DATA)*lHandleCount,List,lHandleCount);
    if( uRc == ERROR_INSUFFICIENT_BUFFER )
    {
        //=================================================
        //  We just want to try one more time to get it,
        //  if it fails, then bail out. m_dwDataBufferSize
        //  should now have the correct size needed in it
        //=================================================
        uRc = GetDataBufferAndHiPerfQueryAllData(m_dwDataBufferSize,List,lHandleCount);
    }
    //=====================================================
    //  Ok, since we are querying for all instances, make
    //  sure the header node says that all of the instances
    //  are fine, if not reallocate
    //=====================================================
	if( uRc == ERROR_SUCCESS )
    {
        if( S_OK ==(hr = SetAllInstanceInfo()))
        {
	        if (m_pHeaderWnode->Flags &  WNODE_FLAG_TOO_SMALL)
            {
                while( TRUE )
                {
                    //==========================================================
                    //  keep on querying until we get the correct size
                    //  This error may come from the driver
                    //==========================================================
                    uRc = GetDataBufferAndHiPerfQueryAllData(m_dwDataBufferSize,List,lHandleCount);
                    if( uRc == ERROR_SUCCESS )
                    {
                        if( S_OK ==(hr = SetAllInstanceInfo()))
                        {
                            if (!(m_pHeaderWnode->Flags &  WNODE_FLAG_TOO_SMALL))
                            {
                                break;
        		            }
			            }
                    } // end GetDataBufferAndQueryAllData
                } // end of while
            } // end of WNODE_FLAG_TOO_SMALL test
        } // end of SetAllInstanceInfo
	}
    //==========================================================================
    //  if uRc succeeded, then the return code is already set by SetAllInstance
    //  otherwise need to map it out
    //==========================================================================
    if( uRc != ERROR_SUCCESS )
    {
        hr  = MapReturnCode(uRc);
    }

 	return(hr);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CProcessHiPerfDataBlock::GetDataBufferAndHiPerfQuerySingleInstance( DWORD dwSize,WMIHANDLE *List, PWCHAR * pInstances,long lHandleCount)
{
    ULONG uRc = E_UNEXPECTED;
    if(GetDataBlockReady(dwSize,TRUE))
    {
        try
        {
	        uRc = WmiQuerySingleInstanceMultiple( List, pInstances, lHandleCount, &m_dwDataBufferSize, m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
    }
    return uRc;
}

///////////////////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::HiPerfQuerySingleInstance(WMIHANDLE *List, PWCHAR * pInstances, DWORD dwInstanceNameSize, long lHandleCount)
{
 	//============================================================
	//  Get the instances
	//============================================================
    ULONG uRc = GetDataBufferAndHiPerfQuerySingleInstance((sizeof(WNODE_SINGLE_INSTANCE)*lHandleCount) + dwInstanceNameSize ,List,pInstances,lHandleCount);
    if( uRc == ERROR_INSUFFICIENT_BUFFER )
    {
        uRc = GetDataBufferAndHiPerfQuerySingleInstance(m_dwDataBufferSize,List,pInstances,lHandleCount);
    }

	if( uRc == ERROR_SUCCESS )
    {
		return(SetSingleInstanceInfo());
    }

	return(MapReturnCode(uRc));
}
////////////////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::FillOutProperties()	
{
	HRESULT hr = WBEM_E_INVALID_OBJECT;
    //=========================================================
	// get the properties from the class and read the WMI Data
	//=========================================================
    if(m_Class->GetANewInstance()){


        WCHAR * pwcsProperty=NULL;
        CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
	    m_dwAccumulativeSizeOfBlock = 0L;						

        pwcsProperty = m_Class->FirstProperty();
        while (NULL != pwcsProperty){

            //=========================================================
            // We do not support arrays or embedded classes
            //=========================================================
            if( ( CWMIProcessClass::EmbeddedClass == m_Class->PropertyCategory()) ||
                ( CWMIProcessClass::Array == m_Class->PropertyCategory() ) ){
					hr = WMI_INVALID_HIPERFPROP;
					ERRORTRACE((THISPROVIDER,"\n Class %S has embedded class or array property",m_Class->GetClassName()));
                    break;
            }

	        hr = MapWMIData.GetDataFromDataBlock(m_Class->GetAccessInstancePtr(), m_Class->GetPropertyHandle(), m_Class->PropertyType(), m_Class->PropertySize());
            if( FAILED(hr) ){
                break;
	        }

            pwcsProperty = m_Class->NextProperty();
	    }
    }

    //====================================================================
    //  Now, fill in the specific HI PERF properties
    //====================================================================
    if( hr == S_OK )
    {
         hr = m_Class->SetHiPerfProperties(m_pHeaderWnode->TimeStamp);
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  This function searches the standard HandleMap for the handle and if it isn't there, it is added.
//  The hiperf handles are added/mapped elsewhere.
///////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::GetWMIHandle(HANDLE & lWMIHandle)
{
    HRESULT hr = WBEM_E_FAILED;

    lWMIHandle = 0;
    hr = WMIINTERFACE->HandleMap()->GetHandle(*(m_Class->GuidPtr()),lWMIHandle);
    if( hr != ERROR_SUCCESS )
    {
         hr = OpenHiPerfHandle();
         if( SUCCEEDED(hr))
         {
             lWMIHandle = m_hCurrentWMIHandle;
             hr = WMIINTERFACE->HandleMap()->Add( *(m_Class->GuidPtr()), lWMIHandle,WMIGUID_QUERY );
         }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmimap.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WMIMAP_HEADER
#define _WMIMAP_HEADER

#define WRITE_IT 0
#define READ_IT  1

///////////////////////////////////////////////////////////////////////
class CWMIDataTypeMap
{

	public:
        CWMIDataTypeMap()
            { m_pWMIBlockInfo = NULL; m_pdwAccumulativeSizeOfBlock = NULL; }

        CWMIDataTypeMap(CWMIDataBlock * pBlock, DWORD * pdw)
            { m_pWMIBlockInfo = pBlock; m_pdwAccumulativeSizeOfBlock = pdw; }
		~CWMIDataTypeMap(){}

 		int  GetWMISize(long lType);

		long GetVariantType(WCHAR * wcsType);
		long ConvertType(long lType );

		void GetSizeAndType( WCHAR * wcsType, IDOrder * p,  long & lType,  int & nWMISize );
        
        DWORD ArraySize(long lType,CVARIANT & var);

		HRESULT GetDataFromDataBlock(CVARIANT & v,long lType, int nSize );
		HRESULT GetDataFromDataBlock(IWbemObjectAccess * p, long lHandle, long lType, int nSize);
		HRESULT PutInArray(SAFEARRAY * & psa,long * pi, long & lType, VARIANT * var);
        
        WCHAR * SetVariantType(long lType);

        BOOL SetDataInDataBlock(CSAFEARRAY * pSafe,int i,CVARIANT & v, long lType, int nSize);
        BOOL NaturallyAlignData( int nSize, BOOL fRead);
		BOOL MissingQualifierValueMatches( CSAFEARRAY * pSafe, long index, CVARIANT & v, long lType, CVARIANT & vToCompare );
        BOOL SetDefaultMissingQualifierValue( CVARIANT & v, long lType, CVARIANT & vToSet );

	private:
		BOOL ConvertDWORDToWMIDataTypeAndWriteItToBlock(DWORD dwLong,int nSize);
		DWORD ConvertWMIDataTypeToDWORD(int nSize);

        CWMIDataBlock   * m_pWMIBlockInfo;
        DWORD           * m_pdwAccumulativeSizeOfBlock;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmimof.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WMIMOF_HEADER
#define _WMIMOF_HEADER

#define NOT_INITIALIZED 0
#define PARTIALLY_INITIALIZED 1
#define FULLY_INITIALIZED 2

////////////////////////////////////////////////////////////////////
class CWMIBinMof 
{
    public:

		CWMIBinMof();
        ~CWMIBinMof();

        HRESULT Initialize( CWMIManagement* p, BOOL fUpdateNamespace); 
        HRESULT Initialize( CHandleMap * pList, BOOL fUpdateNamespace, ULONG uDesiredAccess, IWbemServices   __RPC_FAR * pServices,
                    IWbemObjectSink __RPC_FAR * pHandler, IWbemContext __RPC_FAR *pCtx );

        //=====================================================================
        //  Public functions
        //=====================================================================
        void ProcessListOfWMIBinaryMofsFromWMI();
		BOOL UserConfiguredRegistryToProcessStrandedClassesDuringEveryInit(void);

        BOOL UpdateMofTimestampInHMOM(WCHAR * wcsFile,ULONG & lLowDateTime, ULONG & lHighDateTime, BOOL fSuccess );
        BOOL NeedToProcessThisMof(WCHAR * wcsFileName,ULONG & lLowDateTime, ULONG & lHighDateTime);
		BOOL ThisMofExistsInRegistry(WCHAR * wcsKey,WCHAR * wcsFileName, ULONG lLowDateTime, ULONG lHighDateTime, BOOL fCompareDates);
		BOOL GetListOfDriversCurrentlyInRegistry(WCHAR * wcsKey,KeyList & ArrDriversInRegistry);
		BOOL DeleteOldDriversInRegistry(KeyList & ArrDriversInRegistry);
		BOOL CopyWDMKeyToDredgeKey();
		HRESULT AddThisMofToRegistryIfNeeded(WCHAR * wcsKey, WCHAR * wcsFileName, ULONG & lLowDateTime, ULONG & lHighDateTime, BOOL fSuccess);
		HRESULT DeleteMofFromRegistry(WCHAR * wcsFileName);
		HRESULT ProcessBinaryMofEvent(PWNODE_HEADER WnodeHeader );
		BOOL BinaryMofsHaveChanged();
		BOOL BinaryMofEventChanged(PWNODE_HEADER WnodeHeader );

        inline CWMIManagement * WMI()   { return m_pWMI; }
		HRESULT InitializePtrs(CHandleMap * pList, IWbemServices __RPC_FAR * pServices,	
								   IWbemObjectSink __RPC_FAR * pHandler, IWbemContext __RPC_FAR *pCtx);

    private:
		//======================================================
		//  For use with binary mof related items
		//======================================================
		BOOL					m_fUpdateNamespace;
        ULONG                   m_uCurrentResource;
        ULONG                   m_uResourceCount;
		int						m_nInit;
        MOFRESOURCEINFO       * m_pMofResourceInfo;
        CWMIManagement        * m_pWMI;
		IWinmgmtMofCompiler   * m_pCompiler;

		HRESULT OpenFileAndLookForItIfItDoesNotExist(TCHAR *& pFile, HANDLE & hFile );
        BOOL GetFileDateAndTime(ULONG & lLowDateTime, ULONG & lHighDateTime, WCHAR * p );
        BOOL GetPointerToBinaryResource(BYTE *& pRes,DWORD & dw, HGLOBAL & hResource, HINSTANCE & hInst,WCHAR * wcsResource, WCHAR * wcsKey);

        //==========================================================
        //  Common function
        //==========================================================
        HRESULT SendToMofComp(DWORD dwSize,BYTE * pRes,WCHAR * wcs);

        //==========================================================
        //  Locale functions
        //==========================================================
        BOOL UseDefaultLocaleId(WCHAR * wcsFile, WORD & wLocalId);
        BOOL GetNextSectionFromTheEnd(WCHAR * pwcsTempPath, WCHAR * pwcsEnd);

        //==========================================================
        //  THE BINARY MOF GROUP
        //==========================================================
        BOOL GetListOfBinaryMofs();
        BOOL GetBinaryMofFileNameAndResourceName(WCHAR * pwcsFileName, WCHAR * pwcsResource);
		
        void CreateKey(WCHAR * wcsFileName, WCHAR * wcsResource,WCHAR * wcsKey);
        BOOL ExtractFileNameFromKey(TCHAR *& pKey,WCHAR * wcsKey);
    public:
        void SetBinaryMofClassName(WCHAR * wcsIn, WCHAR * wcsOut)     { swprintf( wcsOut,L"%s-%s",wcsIn,WMI_BINARY_MOF_GUID);}	

        //==========================================================
        //  THE BINARY MOF GROUP VIA Data blocks
        //==========================================================
        HRESULT ExtractBinaryMofFromDataBlock(BYTE * pByte, ULONG m,WCHAR *, BOOL & fMofHasChanged);
        
        //==========================================================
        //  Processing Binary Mofs via file
        //==========================================================
        BOOL ExtractBinaryMofFromFile(WCHAR * wcsFile, WCHAR * wcsResource,WCHAR * wcsKey, BOOL & fMofChanged);
        BYTE * DecompressBinaryMof(BYTE * pRes);
        HRESULT DeleteMofsFromEvent(CVARIANT & vImagePath,CVARIANT & vResourceName, BOOL & fMofChanged);
};


class CNamespaceManagement
{

public:
    CNamespaceManagement(CWMIBinMof * pOwner);
    ~CNamespaceManagement();

	BOOL DeleteOldClasses(WCHAR * wcsFileName,CVARIANT & vLow, CVARIANT & vHi,BOOL fCompareDates);
    BOOL DeleteStrandedClasses();
    BOOL DeleteOldDrivers(BOOL);
	HRESULT DeleteUnusedClassAndDriverInfo(BOOL fDeleteOldClass, WCHAR * wcsPath, WCHAR * wcsClass);

    BOOL CreateInstance ( WCHAR * wcsDriver, WCHAR * wcsClass, ULONG lLowDateTime, ULONG lHighDateTime );
	void CreateClassAssociationsToDriver(WCHAR * wcsFileName, BYTE* pRes, ULONG lLowDateTime, ULONG lHighDateTime);


    void UpdateQuery( WCHAR * pQueryAddOn, WCHAR * Param );
    void UpdateQuery( WCHAR * pQueryAddOn, ULONG lLong );

    void InitQuery(WCHAR * p);
    void AddToQuery(WCHAR * p);

private:

    void RestoreQuery();
    void SaveCurrentQuery();
    HRESULT AllocMemory(WCHAR * & p);
    WCHAR * m_pwcsQuery, *m_pwcsSavedQuery;

    CWMIBinMof * m_pObj;
    int m_nSize,m_nSavedSize;
    BOOL m_fInit,m_fSavedInit;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmicom.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WMICOM_HEADER
#define _WMICOM_HEADER

#define THISPROVIDER LOG_WIMPROV

///////////////////////////////////////////////////////////////////////
// Forward declarations
///////////////////////////////////////////////////////////////////////

class CWMIManagement;
class CWMIDataBlock;
class CWMIProcessClass;
class CNamespaceManagement;

#define FROM_DATA_BLOCK 1
#define FROM_INITIALIZATION 2
#define RUNTIME_BINARY_MOFS_ADDED L"RuntimeBinaryMofsAdded"
#define RUNTIME_BINARY_MOFS_DELETED L"RuntimeBinaryMofsDeleted"

///////////////////////////////////////////////////////////////////////

//#pragma warning( disable : 4005 )				
#include <objbase.h>
//#pragma warning( default : 4005 )				
// kill warning:  "nonstandard extension ...
//#pragma warning( disable : 4200 )				
#include "wmi\wmium.h"
//#pragma warning( default : 4200 )				

#include <wbemint.h>
#include <wchar.h>
#include <wbemidl.h>
#include <GENLEX.H>
#include <OPATHLEX.H>
#include <OBJPATH.H>
#include <flexarry.h>
#include <oahelp.inl>
#include <mofcomp.h>
#include <wbemutil.h>
#include <cominit.h>



#define SERVICES m_pWMI->Services()
#define CONTEXT  m_pWMI->Context()
#define HANDLER  m_pWMI->Handler()

SAFEARRAY * OMSSafeArrayCreate( IN VARTYPE vt, IN int iNumElements);
#define WMI_BINARY_MOF_GUID L"{05901221-D566-11d1-B2F0-00A0C9062910}"




///////////////////////////////////////////////////////////////////////
//  Defines
/////////////////////////////////////////////////////////////////////
#define SAFE_DELETE_PTR(pv)  \
	{ if(pv) delete pv;  \
      pv = NULL; }

#define SAFE_RELEASE_PTR(pv)  \
{   if(pv){  pv->Release(); }  \
      pv = NULL; }

#define SAFE_DELETE_ARRAY(pv)  \
	{ if(pv) delete []pv;  \
      pv = NULL; }
#define GUID_SIZE 128
#define NAME_SIZE 256*2
#define ProcessOneFixedInstance 1
#define ProcessUnfixedInstance  2
#define NoMore                  3
#define MEMSIZETOALLOCATE       512
#define MSG_SIZE				512
#define INTERNAL_EVENT 5
#define PERMANENT_EVENT 6
#define SIZEOFWBEMDATETIME sizeof(WCHAR)*25
#define WMI_NO_MORE 0x80044001
#define PUT_WHOLE_INSTANCE           0
#define PUT_PROPERTIES_ONLY          1
#define PUT_PROPERTIES_IN_LIST_ONLY  2
#define WMI_RESOURCE_MOF_ADDED_GUID L"{B48D49A2-E777-11D0-A50C-00A0C9062910}"
#define WMI_RESOURCE_MOF_REMOVED_GUID L"{B48D49A3-E777-11d0-A50C-00A0C9062910}"

#define MSG_DATA_INSTANCE_NOT_FOUND L"The instance name passed was not recognized as valid"
#define MSG_DATA_NOT_AVAILABLE L"The WDM data block is no longer available."
#define MSG_SUCCESS L"Operation completed successfully"
#define MSG_INVALID_BLOCK_POINTER L"WDM Buffer size and actual size of data do not match"
#define MSG_DRIVER_ERROR L"WDM specific error code: 4209 (Driver specific error, driver could not complete request)"
#define MSG_READONLY_ERROR L"WDM specific error code: 4213 (The WDM data item or data block is read-only)"
#define MSG_ARRAY_ERROR L"Array is the wrong size"
#define IDS_ImpersonationFailed "Impersonation failed - Access denied"

#define ANSI_MSG_DATA_INSTANCE_NOT_FOUND "The instance name passed was not recognized as valid"
#define ANSI_MSG_DRIVER_ERROR "WDM specific error code: 4209 (Driver specific error, driver could not complete request)"
#define ANSI_MSG_INVALID_PARAMETER "Invalid Parameter"
#define ANSI_MSG_INVALID_DATA "Invalid Data"
#define ANSI_MSG_INVALID_NAME_BLOCK "Invalid Name Block"
#define ANSI_MSG_INVALID_DATA_BLOCK "Invalid Data Block"
#define ANSI_MSG_ACCESS_DENIED "Access Denied"

#define MOF_ADDED   1
#define MOF_DELETED 2
#define STANDARD_EVENT 0

//************************************************************************************************************
//============================================================================================================
//
//   The Utility Functions
//
//============================================================================================================
//************************************************************************************************************
BOOL IsBinaryMofResourceEvent(LPOLESTR pGuid, GUID gGuid);
bool IsNT(void);
BOOL GetUserThreadToken(HANDLE * phThreadTok);
void TranslateAndLog( WCHAR * wcsMsg );
BOOL SetGuid(WCHAR * wcsGuid, CLSID & Guid);
HRESULT AllocAndCopy(WCHAR * wcsSource, WCHAR ** pwcsDest );

HRESULT CheckIfThisIsAValidKeyProperty(WCHAR * wcsClass, WCHAR * wcsProperty, IWbemServices * p);
HRESULT GetParsedPath( BSTR ObjectPath,WCHAR * wcsClass, WCHAR * wcsInstance,IWbemServices * p);
BOOL GetParsedPropertiesAndClass( BSTR Query,WCHAR * wcsClass );


//************************************************************************************************************
//============================================================================================================
//
//   The Utility Classes / struct definitions
//
//============================================================================================================
//************************************************************************************************************
class CAutoWChar
{
    WCHAR * m_pStr;
public:
    CAutoWChar(int nSize)    { m_pStr = new WCHAR[nSize+1]; if( m_pStr ) memset( m_pStr,NULL,nSize+1); }
   ~CAutoWChar()             { SAFE_DELETE_ARRAY(m_pStr);}
    BOOL Valid()			 { if( !m_pStr ) return FALSE;  return TRUE; }
    operator PWCHAR()		 { return m_pStr; }
};
///////////////////////////////////////////////////////////////////////

class CCriticalSection
{
    public:		
        CCriticalSection()          {  }
        ~CCriticalSection() 	    {  }
        inline void Init()          { InitializeCriticalSection(&m_criticalsection); }
        inline void Delete()        { DeleteCriticalSection(&m_criticalsection); }
        inline void Enter()         { EnterCriticalSection(&m_criticalsection); }
        inline void Leave()         { LeaveCriticalSection(&m_criticalsection); }

    private:
	    CRITICAL_SECTION	m_criticalsection;			// standby critical section
};

///////////////////////////////////////////////////////////////////////
class CAutoBlock
{
    private:

	    CCriticalSection *m_pCriticalSection;

    public:

        CAutoBlock(CCriticalSection *pCriticalSection)
        {
	        m_pCriticalSection = NULL;
	        if(pCriticalSection)
            {
		        pCriticalSection->Enter();
            }
	        m_pCriticalSection = pCriticalSection;
        }

        ~CAutoBlock()
        {
	        if(m_pCriticalSection)
		        m_pCriticalSection->Leave();

        }
};
typedef struct _AccessList
{
    CFlexArray m_List;
    HRESULT Add(IWbemObjectAccess * pPtr)
	{
		HRESULT hr = S_OK;
		pPtr->AddRef();
		if(CFlexArray::out_of_memory == m_List.Add(pPtr))
		{
			pPtr->Release();
			hr = E_OUTOFMEMORY;
		}

		return hr;
	}
    inline long Size()                 { return m_List.Size(); }
    inline void ** List()              { return m_List.GetArrayPtr(); }

    _AccessList()   {}
    ~_AccessList(); // code elsewhere

}AccessList;

typedef struct _IdList
{
    CFlexArray m_List;
	// 170635
    HRESULT Add( ULONG_PTR l)
	{
		HRESULT hr = S_OK;
		ULONG_PTR * lp = new ULONG_PTR;
		if(lp)
		{
			*lp = l;
			if(CFlexArray::out_of_memory == m_List.Add(lp))
			{
				SAFE_DELETE_PTR(lp);
				hr = E_OUTOFMEMORY;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
		return hr;
	}

    inline long Size()               { return m_List.Size(); }
    inline void ** List()            { return m_List.GetArrayPtr(); }

    _IdList() {}
    ~_IdList();   // code elsewhere

} IdList;

typedef struct _HandleList
{
    CFlexArray m_List;
	// 170635
    HRESULT Add( HANDLE l )
	{
		HRESULT hr = S_OK;
		HANDLE * lp = new HANDLE;
		if(lp)
		{
			*lp = l;
			if(CFlexArray::out_of_memory == m_List.Add(lp))
			{
				SAFE_DELETE_PTR(lp);
				hr = E_OUTOFMEMORY;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
		return hr;
	}

    inline long Size()               { return m_List.Size(); }
    inline void ** List()            { return m_List.GetArrayPtr(); }

    _HandleList() {}
    ~_HandleList();   // code elsewhere

} HandleList;

typedef struct _KeyList
{
    CWStringArray m_List;

    // ================================================================
    // Appends a new element to the end of the array. Copies the param.
    // ================================================================
    int Add(WCHAR * pStr)
	{
		return m_List.Add( pStr );
	}

    // ================================================================
    // Locates a string or returns -1 if not found.
    // ================================================================
	int Find(WCHAR * pStr)
	{
		int nFlags = 0;
		return m_List.FindStr( pStr, nFlags );
	}

    // ================================================================
    // Removes a string
    // ================================================================
	HRESULT Remove(WCHAR * pStr)
	{
		int nIndex = Find(pStr);
		if( nIndex > -1 )
		{
			m_List.RemoveAt( nIndex );
		}
		return S_OK;
	}
    // ================================================================
    // Removes a string
    // ================================================================
	BOOL OldDriversLeftOver()
	{
		if( m_List.Size() > 0 )
		{
			return TRUE;
		}
		return FALSE;
	}

    // ================================================================
	// Get how many are in there
    // ================================================================
	int GetSize()
	{
		return m_List.Size();
	}

    // ================================================================
	// Get at a specific position
    // ================================================================
	WCHAR * GetAt(int n)
	{
		return m_List.GetAt(n);
	}
    _KeyList() {}
    ~_KeyList(){}
	
} KeyList;

typedef struct _InstanceList
{
    CFlexArray m_List;
	// 170635
    HRESULT Add( WCHAR * p )
	{
		HRESULT hr = S_OK;
		WCHAR * pNew = NULL;
		if(SUCCEEDED(hr = AllocAndCopy(p, &pNew)))
		{
			if(CFlexArray::out_of_memory == m_List.Add(pNew))
			{
				hr = E_OUTOFMEMORY;
				SAFE_DELETE_ARRAY(pNew);
			}
		}
		return hr;
	}

    inline long Size()           { return m_List.Size(); }
    inline void ** List()        { return m_List.GetArrayPtr(); }

    _InstanceList() {}
    ~_InstanceList();   // code elsewhere

} InstanceList;

typedef struct _OldClassInfo
{
    WCHAR * m_pClass;
    WCHAR * m_pPath;

    _OldClassInfo() { m_pClass = m_pPath = NULL; }
    ~_OldClassInfo();   // code elsewhere
} OldClassInfo;

typedef struct _OldClassList
{
    CFlexArray m_List;

    HRESULT Add( WCHAR * pClass, WCHAR * pPath )       
	{  
		HRESULT hr = S_OK;

		if ( !pClass )
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		if ( !pPath)
		{
			return WBEM_E_INVALID_PARAMETER;
		}

        OldClassInfo * pInfo = new OldClassInfo;
        if( pInfo )
        {
	        if(SUCCEEDED(hr = AllocAndCopy(pClass, &(pInfo)->m_pClass)))
	        {
    	        if(SUCCEEDED(hr = AllocAndCopy(pPath, &(pInfo)->m_pPath)))
	            {
    		        if(CFlexArray::out_of_memory == m_List.Add(pInfo)) 
	    	        {
		    	        hr = E_OUTOFMEMORY;
			            SAFE_DELETE_PTR(pInfo);
			        }
                }
	        }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
		return hr;
	}

    WCHAR * GetClass( int nIndex )       
	{  
		HRESULT hr = S_OK;
        OldClassInfo * pInfo = NULL;

        pInfo = (OldClassInfo *) m_List[nIndex];
        return pInfo->m_pClass;
	}

    WCHAR * GetPath( int nIndex )       
	{  
		HRESULT hr = S_OK;
        OldClassInfo * pInfo = NULL;

        pInfo = (OldClassInfo *)m_List[nIndex];
        return pInfo->m_pPath;
	}

    inline long Size()           { return m_List.Size(); }
    inline void ** List()        { return m_List.GetArrayPtr(); }

    _OldClassList() {}
    ~_OldClassList();   // code elsewhere

} OldClassList;

typedef struct _WMIEventRequest
{
    DWORD dwId;
    WCHAR wcsGuid[GUID_SIZE];
    WCHAR * pwcsClass;
	BOOL fHardCoded;
    CLSID gGuid;
    IWbemObjectSink __RPC_FAR * pHandler;
	IWbemServices __RPC_FAR *   pServices;
	IWbemContext __RPC_FAR *    pCtx;

    _WMIEventRequest();
    ~_WMIEventRequest();
    void AddPtrs( IWbemObjectSink __RPC_FAR * pHandler,IWbemServices __RPC_FAR *   pServices,IWbemContext __RPC_FAR *    pCtx);
    BOOL SetClassName( WCHAR * p )   { SAFE_DELETE_ARRAY(pwcsClass); return SUCCEEDED(AllocAndCopy( p, &pwcsClass)) ? TRUE : FALSE; }

} WMIEventRequest;

typedef struct _WMIHandleMap
{
	HANDLE              WMIHandle;
    GUID                Guid;
	ULONG	            uDesiredAccess;
    LONG                RefCount;

    void AddRef();
    LONG Release();
    _WMIHandleMap()              { WMIHandle = 0; uDesiredAccess = 0; RefCount = 0; }
    ~_WMIHandleMap()        {  }

}WMIHandleMap;

typedef struct _WMIHiPerfHandleMap
{
    WMIHANDLE           WMIHandle;
    ULONG_PTR           lHiPerfId;
    BOOL                m_fEnumerator;
    CWMIProcessClass    * m_pClass;
    IWbemHiPerfEnum     * m_pEnum;

    _WMIHiPerfHandleMap(CWMIProcessClass * p, IWbemHiPerfEnum * pEnum);
    ~_WMIHiPerfHandleMap();

}WMIHiPerfHandleMap;


typedef struct _IDOrder
{
    WCHAR * pwcsPropertyName;
    WCHAR * pwcsEmbeddedObject;
    long    lType;
    int     nWMISize;
    long    lHandle;
    DWORD   dwArraySize;
    BOOL    fPutProperty;

    _IDOrder()                          { pwcsPropertyName = NULL; pwcsEmbeddedObject = NULL; lHandle = 0; }
    ~_IDOrder()                         { SAFE_DELETE_PTR(pwcsPropertyName); SAFE_DELETE_PTR(pwcsEmbeddedObject); }
    BOOL SetPropertyName( WCHAR * p )   { SAFE_DELETE_PTR(pwcsPropertyName);  return SUCCEEDED(AllocAndCopy( p, &pwcsPropertyName)) ? TRUE : FALSE; }
    BOOL SetEmbeddedName( WCHAR * p )   { SAFE_DELETE_PTR(pwcsEmbeddedObject);return SUCCEEDED(AllocAndCopy( p, &pwcsEmbeddedObject)) ? TRUE : FALSE; }

} IDOrder;

///////////////////////////////////////////////////////////////////////
class CAnsiUnicode
{
    public:
        CAnsiUnicode()  {}
        ~CAnsiUnicode() {}
        HRESULT UnicodeToAnsi(WCHAR * pszW, char *& pAnsi);
        HRESULT AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW);
};


///////////////////////////////////////////////////////////////////////
class CAutoChangePointer
{
    private:
        CWMIProcessClass * m_pTmp;
        CWMIProcessClass ** m_pOriginal;
    public:
        CAutoChangePointer(CWMIProcessClass ** ppOriginal, CWMIProcessClass * pNew)
        { m_pTmp = *ppOriginal; m_pOriginal = ppOriginal; *ppOriginal = pNew; }

        ~CAutoChangePointer()
        { *m_pOriginal = m_pTmp; }
};

//************************************************************************************************************
//============================================================================================================
//
//   The Common Base Classes
//
//============================================================================================================
//************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Common functions regarding binary mof processing & security
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
class CHandleMap
{
    protected:

        CFlexArray           m_List;
        CCriticalSection     m_HandleCs;

    public:

        CHandleMap()    {  m_HandleCs.Init(); }
        ~CHandleMap()   {  CloseAllOutstandingWMIHandles(); m_HandleCs.Delete();}

        inline CCriticalSection * GetCriticalSection()      { return (CCriticalSection*)&m_HandleCs;}
        HRESULT Add(CLSID Guid, HANDLE hCurrent, ULONG uDesiredAccess);

        int ExistingHandleAlreadyExistsForThisGuidUseIt(CLSID Guid, HANDLE & hCurrentWMIHandle, BOOL & fCloseHandle, ULONG uDesiredAccess);
        void CloseAllOutstandingWMIHandles();
        int ReleaseHandle( HANDLE hCurrentWMIHandle );
        int GetHandle(CLSID Guid, HANDLE & hCurrentWMIHandle );
 };
///////////////////////////////////////////////////////////////////////
class CHiPerfHandleMap : public CHandleMap
{
    private:
        int m_nIndex;

    public:

        CHiPerfHandleMap() {    m_nIndex = 0; }
        ~CHiPerfHandleMap(){CloseAndReleaseHandles();}

        HRESULT Delete( HANDLE & hCurrent, ULONG_PTR lHiPerfId );
        HRESULT Add( HANDLE hCurrent, ULONG_PTR lHiPerfId, CWMIProcessClass * p, IWbemHiPerfEnum * pEnum );

        HRESULT FindHandleAndGetClassPtr( HANDLE & lWMIHandle, ULONG_PTR lHiPerfId,CWMIProcessClass *& p);
        HRESULT GetFirstHandle(HANDLE & hCurrent,CWMIProcessClass *& p, IWbemHiPerfEnum *& pEnum);
        HRESULT GetNextHandle(HANDLE & hCurrent,CWMIProcessClass *& p, IWbemHiPerfEnum *& pEnum);
		void CloseAndReleaseHandles();

};
///////////////////////////////////////////////////////////////////////
class CWMI_IDOrder
{
    private:

        int				m_nTotal;
        int				m_nCurrent;
		int             m_nStartingPosition;
//        CWMIProcessClass * m_pObj;
        IWbemObjectAccess * m_pAccess;
        IWbemClassObject *  m_pClass;

        IDOrder         * m_pWMIDataIdList;

		DWORD   GetSizeOfArray(LPCWSTR bProp, LONG lType);
        HRESULT ProcessPropertyQualifiers(LPCWSTR bstrPropName, int nMax,BOOL fHiPerf);

    public:
//       CWMI_IDOrder(CWMIProcessClass * p);
         CWMI_IDOrder(IWbemClassObject * p, IWbemObjectAccess * p2);
        ~CWMI_IDOrder();

        WCHAR * GetFirstID();
        WCHAR * GetNextID();
        void InitMemberVars();

        HRESULT ProcessMethodProperties();
        HRESULT GetPropertiesInIDOrder(BOOL HiPerf);
        inline long PropertyType()          { return m_pWMIDataIdList[m_nCurrent].lType;}
        inline int  PropertySize()          { return m_pWMIDataIdList[m_nCurrent].nWMISize;}
        inline int  ArraySize()             { return m_pWMIDataIdList[m_nCurrent].dwArraySize; }
        inline WCHAR * PropertyName()       { return m_pWMIDataIdList[m_nCurrent].pwcsPropertyName;}
        inline WCHAR * EmbeddedClassName()  { return m_pWMIDataIdList[m_nCurrent].pwcsEmbeddedObject;}
        inline ULONG WMIDataId()            { return m_nCurrent; }
        inline void SetPutProperty(BOOL fV) { m_pWMIDataIdList[m_nCurrent].fPutProperty = fV;}
        inline BOOL GetPutProperty(void)    { return m_pWMIDataIdList[m_nCurrent].fPutProperty;}
        inline LONG GetPropertyHandle()     { return m_pWMIDataIdList[m_nCurrent].lHandle;}
};
////////////////////////////////////////////////////////////////////

class CWMIManagement
{
    protected:

        IWbemObjectSink __RPC_FAR   * m_pHandler;
        IWbemServices __RPC_FAR     * m_pServices;
        IWbemContext __RPC_FAR      * m_pCtx;

 		CHandleMap *  m_pHandleMap;
		//======================================================
        //   ************** PUBLIC ********************
		//======================================================
    public:

        CWMIManagement();
        ~CWMIManagement();

        inline IWbemObjectSink __RPC_FAR    * Handler()       { return m_pHandler;}
        inline IWbemServices __RPC_FAR      * Services()      { return m_pServices;}
        inline IWbemContext __RPC_FAR       * Context()       { return m_pCtx;}
        inline CHandleMap                   * HandleMap()     { return m_pHandleMap;}

        inline void SetWMIPointers(CHandleMap * pList, IWbemServices   __RPC_FAR * pServices, IWbemObjectSink __RPC_FAR * pHandler, IWbemContext __RPC_FAR *pCtx)
                         { m_pHandleMap = pList; m_pServices = pServices; m_pHandler = pHandler; m_pCtx = pCtx; }

		//==========================================================
        //  THE Event Group
        //==========================================================
         BOOL CancelWMIEventRegistration( GUID gGuid , ULONG_PTR uContext );

		//======================================================
        //  Cleanup Group
		//======================================================
        void CloseAllOutstandingWMIHandles();

		//======================================================
        //  Error message processing/checking access
    	//======================================================

        void SendPrivilegeExtendedErrorObject(HRESULT hrToReturn,WCHAR * wcsClass);
        HRESULT SetErrorMessage(HRESULT hrToReturn, WCHAR * wcsClass, WCHAR * wcsMsg);

    	HRESULT GetListOfUserPrivileges(TOKEN_PRIVILEGES *& ptPriv);
		void ProcessPrivileges(TOKEN_PRIVILEGES *ptPriv, SAFEARRAY *& psaPrivNotHeld, SAFEARRAY * psaPrivReq );

};
////////////////////////////////////////////////////////////////////
class CWMIProcessClass
{
    protected:

        CWMIManagement      * m_pWMI;
        CWMI_IDOrder        * m_pCurrentProperty;
        WCHAR               * m_pwcsClassName;
        IWbemClassObject    * m_pClass;
	    IWbemClassObject    * m_pClassInstance;
        IWbemObjectAccess   * m_pAccess;
        IWbemObjectAccess   * m_pAccessInstance;
        CLSID                 m_Guid;
        WORD                  m_wHardCodedGuid;
        BOOL                  m_fHiPerf;
        BOOL                  m_fGetNewInstance;
		BOOL				  m_fInit;
	
         //=============================================
        //  Private functions
        //=============================================
        void InitMemberVars();
        void ReleaseInstancePointers();
        HRESULT GetPropertiesInIDOrder(BOOL fHiPerf);

    public:

        CWMIProcessClass(BOOL b);
        ~CWMIProcessClass();

        enum __PropertyCategory{  EmbeddedClass = 0,        // For the property categories
                Array = 1,
                Data = 2
        } _PropertyCategory;

		HRESULT Initialize();

         //=============================================
        // inline functions
        //=============================================
        inline BOOL SetHiPerf(BOOL f)                           { return m_fHiPerf = f;}
        inline BOOL GetNewInstance(BOOL f)                      { return m_fGetNewInstance = f;}
        inline CWMIManagement * WMI()                           { return m_pWMI;}
        inline void SetWMIPointers(CWMIProcessClass * p)
		{  if( m_pWMI ){m_pWMI->SetWMIPointers(p->WMI()->HandleMap(),p->WMI()->Services(),p->WMI()->Handler(),p->WMI()->Context()); } }

        inline CWMIManagement * GetWMIManagementPtr()           { return m_pWMI; }
        inline void SetHardCodedGuidType( WORD wValue )         { m_wHardCodedGuid= wValue; }
        inline WORD GetHardCodedGuidType()                      { return m_wHardCodedGuid;}

        inline CLSID * GuidPtr()                            { return &m_Guid;}
        inline IWbemObjectAccess * GetAccessInstancePtr()   { return m_pAccessInstance; }
        inline WCHAR * EmbeddedClassName()                  { return m_pCurrentProperty->EmbeddedClassName();}
        inline WCHAR * FirstProperty()                      { return m_pCurrentProperty->GetFirstID(); }
        inline WCHAR * NextProperty()                       { return m_pCurrentProperty->GetNextID(); }
        inline int ArraySize()                              { return m_pCurrentProperty->ArraySize(); }
        inline int PropertySize()                           { return m_pCurrentProperty->PropertySize(); }
        inline long PropertyType()                          { return m_pCurrentProperty->PropertyType(); }
        inline WCHAR * GetClassName()                       { return m_pwcsClassName;}
        inline IWbemClassObject * ClassPtr()                { return m_pClass; }
        inline long GetPropertyHandle()                     { return m_pCurrentProperty->GetPropertyHandle(); }

        //=============================================
        //  Basic class manipulation
        //=============================================
        BOOL GetANewAccessInstance();
        BOOL  GetANewInstance() ;
        inline BOOL  ValidClass()                   { if( m_pClass && m_pCurrentProperty){return TRUE;} return FALSE;}
        int   PropertyCategory();

        HRESULT SetClassName(WCHAR * wcsName);
        HRESULT SetClass(WCHAR * wcsClass);
        HRESULT SetClass(IWbemClassObject * pPtr);
        HRESULT SetAccess(IWbemObjectAccess * pPtr);
        HRESULT SetClassPointerOnly(IWbemClassObject * pPtr);
        HRESULT SetClassPointerOnly(IWbemObjectAccess * pPtr);
        HRESULT GetGuid(void);
        HRESULT SetKeyFromAccessPointer();
        HRESULT GetKeyFromAccessPointer(CVARIANT * v);
        HRESULT InitializeEmbeddedClass(CWMIProcessClass * Em );
         //=============================================
        //  Property manipulation
        //=============================================
        void SetActiveProperty();
        HRESULT SetHiPerfProperties(LARGE_INTEGER TimeStamp) ;


        inline HRESULT PutPropertyInInstance(VARIANT * vToken)
                    { return ( m_pClassInstance->Put(m_pCurrentProperty->PropertyName(), 0, vToken, NULL));}

        inline HRESULT GetPropertyInInstance(WCHAR * pwcsProperty,CVARIANT & vValue, LONG & lType)
                    {  return m_pClass->Get(pwcsProperty, 0, &vValue, &lType, NULL);}
        HRESULT GetSizeOfArray(long & lType, DWORD & dwCount, BOOL & fDynamic);


        //=============================================
        // Embedded classes
        //=============================================
        HRESULT ReadEmbeddedClassInstance( IUnknown * pUnknown, CVARIANT & v );
        HRESULT GetLargestDataTypeInClass(int & nSize);
        void SaveEmbeddedClass(CVARIANT & v);
        HRESULT GetSizeOfClass(DWORD & dwSize);


        //=============================================
        //  Send the instance back to WBEM
        //=============================================
        inline ULONG WMIDataId()            { return m_pCurrentProperty->WMIDataId();}
        inline void SetPutProperty(BOOL fV) { m_pCurrentProperty->SetPutProperty(fV);}
        inline BOOL GetPutProperty()        { return m_pCurrentProperty->GetPutProperty();}

        HRESULT SendInstanceBack();
        HRESULT SetInstanceName(WCHAR * wName,BOOL);
        HRESULT GetInstanceName(WCHAR *& p);

        //=============================================
        //  Class functions, providing access to the
        //  properties, qualifiers in a class.
        //  NOTE:  Properties are in WMI order
        //=============================================

        HRESULT GetQualifierString( WCHAR * pwcsPropertyName, WCHAR * pwcsQualifierName,
                                    WCHAR * pwcsExternalOutputBuffer,int nSize);
		HRESULT GetQualifierValue( WCHAR * pwcsPropertyName, WCHAR * pwcsQualifierName, CVARIANT * vQual);
		HRESULT GetPrivilegesQualifer(SAFEARRAY ** psaPrivReq);

        //=============================================
        //  Methods
        //=============================================
        ULONG GetMethodId(LPCWSTR bProp);
        HRESULT GetMethodProperties();
};

//=============================================================
class CWMIDataBlock
{
    protected:
		BOOL					m_fUpdateNamespace;
		BOOL					m_fMofHasChanged;

        CWMIProcessClass        * m_Class;

 		HANDLE					  m_hCurrentWMIHandle;
		BOOL					  m_fCloseHandle;

  		BYTE * m_pbDataBuffer,* m_pbCurrentDataPtr,* m_pbWorkingDataPtr;
        DWORD                   m_dwDataBufferSize;
        ULONG *                 m_upNameOffsets;
		ULONG *					m_pMaxPtr;
		ULONG 					m_ulVersion,m_uInstanceSize;
	    int                     m_nCurrentInstance;
	    int                     m_nTotalInstances;
        BOOL                    m_fFixedInstance;
        PWNODE_SINGLE_INSTANCE  m_pSingleWnode;
        PWNODE_ALL_DATA         m_pAllWnode;
        WNODE_HEADER*           m_pHeaderWnode;
		DWORD                   m_dwCurrentAllocSize;
        DWORD                   m_dwAccumulativeSizeOfBlock;
		BOOL					m_fMore;
		WCHAR                   m_wcsMsg[MSG_SIZE];
        ULONG                   m_uDesiredAccess;


		//======================================================
		//  Initializing member variables
		//======================================================
        void InitMemberVars();
        HRESULT SetAllInstanceInfo();
        HRESULT SetSingleInstanceInfo();


        //=============================================
        //  Get the data from WMI
        //=============================================
        BOOL InitializeDataPtr();
        void GetNextNode();
        BOOL ParseHeader();
        HRESULT ProcessArrayTypes(VARIANT & vToken,WCHAR * pwcsProperty);
		HRESULT WriteArrayTypes(WCHAR * pwcsProperty,CVARIANT & v);
        HRESULT FillInProperty();

        BOOL GetDataBlockReady(DWORD dwSize,BOOL );
        HRESULT ReAllocateBuffer(DWORD wCount);
        HRESULT AllocateBuffer(DWORD dwSize);
        inline BOOL PtrOk(ULONG * pPtr,ULONG uHowMany);
		int AssignNewHandleAndKeepItIfWMITellsUsTo();

		//===============================================
		//  Mapping return code and dumping out
		//  WNODE info
		//===============================================
		HRESULT MapReturnCode(ULONG uRc);
		HRESULT DumpWnodeInfo(char * pwcsMsg);
		void DumpAllWnode();
		void DumpSingleWnode();
        void DumpWnodeMsg(char * wcsMsg) ;

    public:
        CWMIDataBlock();
        ~CWMIDataBlock();

		void UpdateNamespace(BOOL fUpdate)   { m_fUpdateNamespace = fUpdate;}
		BOOL UpdateNamespace()				 { return m_fUpdateNamespace; }
		BOOL HasMofChanged()				 { return m_fMofHasChanged; }

		inline void SetClassProcessPtr(CWMIProcessClass * Class)     { m_Class = Class;}

        //=============================================
		//  Open and Close WMI ... :)
        //=============================================
		void CloseAllOutstandingWMIHandles(void);
        HRESULT OpenWMI();
		HRESULT OpenWMIForBinaryMofGuid();

        //=============================================
        //  Setting up and cancelling Events
        //  Setting ptrs to the data sent by the event
        //=============================================
        HRESULT RegisterWMIEvent( WCHAR * wcsGuid, ULONG_PTR uContext, CLSID & Guid, BOOL fRegistered);
        HRESULT SetAllInstancePtr( PWNODE_ALL_DATA pwAllNode );

        //=============================================
        // Processing the data we got back and putting
        // it into WBEM
        //=============================================
        virtual HRESULT FillOutProperties()=0;

        HRESULT ProcessBinaryMof();
        HRESULT ReadWMIDataBlockAndPutIntoWbemInstance();
		inline BOOL MoreToProcess()	        				  { return m_fMore;}

        //=============================================
        // Embedded Class
        //=============================================
        HRESULT ProcessEmbeddedClass(CVARIANT & v);

        //=====================================================
        //  The Put Instance Group
        //=====================================================
		HRESULT WriteEmbeddedClass(IUnknown * pUnknown,CVARIANT & v);

        HRESULT ConstructDataBlock(BOOL fInit);
        HRESULT WriteDataToBufferAndIfSinglePropertySubmitToWMI(BOOL fInit,BOOL fPutProperty);
        HRESULT SetSingleInstancePtr( PWNODE_SINGLE_INSTANCE pwSingleNode);
        HRESULT SetSingleItem();
        HRESULT PutSingleProperties();
        BOOL    GetListOfPropertiesToPut(int nWhich, CVARIANT & vList);
        //=====================================================
        //  Manipulate data in the data block
        //=====================================================
        void GetWord(WORD & wWord) ;
        void GetDWORD(DWORD & dwWord) ;
        void GetFloat(float & fFloat) ;
        void GetDouble(DOUBLE & dDouble) ;
        void GetSInt64(WCHAR * pwcsBuffer) ;
        void GetUInt64(WCHAR * pwcsBuffer) ;
        void GetQWORD(unsigned __int64 & uInt64);
        void GetString(WCHAR * pwcsBuffer,WORD wCount, WORD wBufferSize) ;
        void GetByte(BYTE & bByte) ;
        void SetWord(WORD wWord) ;
        void SetDWORD(DWORD dwWord) ;
        void SetFloat(float fFloat) ;
        void SetDouble(DOUBLE dDouble) ;
        void SetSInt64(__int64 Int64) ;
        void SetUInt64(unsigned __int64 UInt64) ;
        void SetString(WCHAR * pwcsBuffer,WORD wCount) ;
        void SetByte(byte bByte) ;

        void AddPadding(DWORD dwBytesToPad);
		BOOL CurrentPtrOk(ULONG uHowMany);
        HRESULT GetBufferReady(DWORD wCount);
        //=======================================================
        //  Utility functions
        //=======================================================
		inline void InitDataBufferToNull() { m_dwDataBufferSize = 0; m_pbDataBuffer = NULL;}
        BOOL ResetMissingQualifierValue(WCHAR * pwcsProperty, SAFEARRAY *& pSafe);
        BOOL ResetMissingQualifierValue(WCHAR * pwcsProperty, CVARIANT & vToken);

        HRESULT ProcessDataBlock();
        int AdjustDataBlockPtr(HRESULT & hr);
        HRESULT ProcessNameBlock(BOOL f);

        //=========================================================
        // Binary mof processing
        //=========================================================
        HRESULT ExtractImageAndResourceName(CVARIANT & vImagePath,CVARIANT & vResourceName);
        HRESULT AddBinaryMof(CVARIANT & vImagePath,CVARIANT & vResourceName);
        HRESULT DeleteBinaryMof(CVARIANT & vImagePath,CVARIANT & vResourceName);
        HRESULT ProcessBinaryMofDataBlock(CVARIANT & vResourceName, WCHAR * w);

        //=========================================================
        // Cleanup
        //=========================================================
        void ResetDataBuffer();

        //======================================================
        //  Error Message
		//======================================================

        inline WCHAR * GetMessage()                     { return m_wcsMsg; }

        inline void SetDesiredAccess(ULONG u)           { m_uDesiredAccess = u; }

};



//************************************************************************************************************
//============================================================================================================
//
//   The Standard Provider Classes
//
//============================================================================================================
//************************************************************************************************************

class CProcessStandardDataBlock : public CWMIDataBlock
{
    private:

        HRESULT FillOutProperties();
        CWMIProcessClass        * m_pMethodInput;
        CWMIProcessClass        * m_pMethodOutput;


    public:

        CProcessStandardDataBlock();
        ~CProcessStandardDataBlock() ;

        inline void SetMethodInput( CWMIProcessClass * p )  { m_pMethodInput = p;}
        inline void SetMethodOutput( CWMIProcessClass * p )  { m_pMethodOutput = p;}

        //=============================================
        // Getting the data to process in response to
        // a request for enumeration.  We either get
        // a single guy, or a bunch of guys
        //=============================================
        ULONG GetDataBufferAndQueryAllData(DWORD dwSize);
        ULONG GetDataBufferAndQuerySingleInstance(DWORD dwSize,WCHAR * wcsInstanceName);

        HRESULT QueryAllData();
        HRESULT QuerySingleInstance(WCHAR * wcsInstanceName);
        HRESULT SetSingleInstance();

        //=============================================
        //  Methods
        //=============================================
	    HRESULT ProcessMethodInstanceParameters();
        HRESULT ExecuteMethod(ULONG MethodId, WCHAR * MethodInstanceName, ULONG InputValueBufferSize,BYTE * InputValueBuffer);

        //=============================================
        //  Methods
        //=============================================
	    ULONG GetMethodId(LPCWSTR bProp);
        HRESULT CreateOutParameterBlockForMethods();
        HRESULT CreateInParameterBlockForMethods( BYTE *& Buffer, ULONG & uBufferSize);
        HRESULT AllocateBlockForMethodOutput(DWORD & dwSize,CWMIProcessClass & Class);
        HRESULT GetEmbeddedClassSize(WCHAR * wcsEmbedded, DWORD &  dwSize);

};

//************************************************************************************************************
//============================================================================================================
//
//   The Hi Performance Classes
//
//============================================================================================================
//************************************************************************************************************


class CProcessHiPerfDataBlock : public CWMIDataBlock
{
    private:

        ULONG GetDataBufferAndHiPerfQueryAllData(DWORD dwSize, WMIHANDLE * List, long lHandleCount);
        ULONG GetDataBufferAndHiPerfQuerySingleInstance( DWORD dwSize,WMIHANDLE *List, PWCHAR * pInstances, long lHandleCount);


    public:

        CProcessHiPerfDataBlock() { m_fCloseHandle = FALSE;}
        ~CProcessHiPerfDataBlock() {}

        HRESULT HiPerfQuerySingleInstance(WMIHANDLE *List, PWCHAR * pInstances, DWORD dwInstanceNameSize, long lHandleCount);
        HRESULT HiPerfQueryAllData(WMIHANDLE * List,long lHandleCount);
        HRESULT OpenHiPerfHandle();
        HRESULT GetWMIHandle(HANDLE & lWMIHandle);

        HRESULT FillOutProperties();

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmimof.cpp ===
/////////////////////////////////////////////////////////////////////

//

//  BINMOF.CPP

//

//  Module:

//  Purpose:

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////
#include "wmicom.h"
#include "wmimof.h"
#include <wchar.h>
#include <stdio.h>
#include "wdmshell.h"
#include <cregcls.h>
#include <bmof.h>
#include <mrcicode.h>
#include <mofcomp.h>
#include <crc32.h>
#include <TCHAR.h>

//#define DBG_PRINTFA( a ) { char pBuff[128]; sprintf a ; OutputDebugStringA(pBuff); }
#define WDM_REG_KEY			L"Software\\Microsoft\\WBEM\\WDM"
#define WDM_DREDGE_KEY		L"Software\\Microsoft\\WBEM\\WDM\\DREDGE"
#define DREDGE_KEY			L"DREDGE"

///////////////////////////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  void * BMOFAlloc
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This allows users to choose
//  the allocation method that is used.
//
//  PARAMETERS:
//
//  Size                Input.  Size of allocation in bytes.
//
//  RETURN VALUE:
//
//  pointer to new data.  NULL if allocation failed.
//
//***************************************************************************

void * BMOFAlloc(size_t Size)
{
    return malloc(Size);
}
//***************************************************************************
//
//  void BMOFFree
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This frees what ever was
//  allocated via BMOFAlloc.
//
//  PARAMETERS:
//
//  pointer to memory to be freed.
//
//***************************************************************************

void BMOFFree(void * pFree)
{
   free(pFree);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void ConvertStringToCTypeString( WCHAR * Out, WCHAR * In )
{
    WCHAR * token = NULL;

	if(In)
	{
		CAutoWChar tmpBuf(_MAX_PATH*2);
		if( tmpBuf.Valid() )
		{
			wcscpy((WCHAR*)tmpBuf,In);
			token = wcstok( (WCHAR*)tmpBuf, L"\\" );
			if( !token )
			{
				wcscpy(Out,In);
			}
			else
			{
				BOOL fFirst = TRUE;
				while( token != NULL )
				{
					if( fFirst )
					{
						wcscpy(Out,token);
						fFirst = FALSE;
					}
					else
					{
						wcscat(Out,L"\\\\");
						wcscat(Out,token);
					}
					token = wcstok( NULL, L"\\" );
				}
			}
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************
//  The binary mof class
//*****************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////
CWMIBinMof::CWMIBinMof()
{
	m_pCompiler	= NULL;
	m_pWMI = NULL;
	m_nInit = NOT_INITIALIZED;
	m_pMofResourceInfo = NULL;
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::InitializePtrs(CHandleMap * pList, IWbemServices __RPC_FAR * pServices,	
								   IWbemObjectSink __RPC_FAR * pHandler, IWbemContext __RPC_FAR *pCtx)
{
	HRESULT hr = WBEM_E_FAILED;

	SAFE_DELETE_PTR(m_pWMI);
	m_pWMI = new CWMIManagement;
	if( m_pWMI )
	{
		m_pWMI->SetWMIPointers(pList, pServices, pHandler, pCtx);
		m_nInit = FULLY_INITIALIZED;
		hr = S_OK;
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::Initialize(CWMIManagement * p,BOOL fUpdateNamespace)
{
	HRESULT hr = WBEM_E_FAILED;
	if( p )
	{
		hr = InitializePtrs(p->HandleMap(),p->Services(),p->Handler(),p->Context());
	}
	else
	{
		m_nInit = PARTIALLY_INITIALIZED;
		hr = S_OK;
	}
	m_fUpdateNamespace = fUpdateNamespace;
	return hr;
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::Initialize(CHandleMap * pList, BOOL fUpdateNamespace,ULONG uDesiredAccess,
						 IWbemServices __RPC_FAR * pServices,	IWbemObjectSink __RPC_FAR * pHandler, 
						 IWbemContext __RPC_FAR *pCtx)
{
	HRESULT hr = WBEM_E_FAILED;
	hr = InitializePtrs(pList,pServices,pHandler,pCtx);
	m_fUpdateNamespace = fUpdateNamespace;

	return hr;
}
/////////////////////////////////////////////////////////////////////
CWMIBinMof::~CWMIBinMof()
{
	SAFE_RELEASE_PTR(m_pCompiler);
	SAFE_DELETE_PTR(m_pWMI);
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::OpenFileAndLookForItIfItDoesNotExist(TCHAR *& pFile, HANDLE & hFile )
{
	HRESULT hr = S_OK;

	//=========================================================================
	//  Ok, hopefully CreateFile will find it 
	//=========================================================================
    hFile = CreateFile(pFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if( hFile == INVALID_HANDLE_VALUE )
	{
		hr = WBEM_E_FAILED;
		//=====================================================================
		//  CreateFile DIDN'T find it, so look in the Windows dir
		//=====================================================================
		TCHAR pszSysDir[MAX_PATH+4];
		
	    UINT uSize = GetSystemDirectory(pszSysDir, MAX_PATH);
		if( uSize > 0) 
		{
			TCHAR * pTmp = pFile;
			pFile = new TCHAR[MAX_PATH*2 + 4];
			if( pFile )
			{
				_stprintf(pFile,L"%s\\%s",pszSysDir,pTmp);
				//=============================================================
				//  Ok, now try to open again
				//=============================================================
				hFile = CreateFile(pFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
				if( hFile != INVALID_HANDLE_VALUE )
				{
					hr = S_OK;
				}
			}
			SAFE_DELETE_ARRAY(pTmp);
		}
    }
	return hr;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::GetFileDateAndTime(ULONG & lLowDateTime,ULONG & lHighDateTime,WCHAR  * wcsFileName)
{
    HANDLE hFile = NULL;
    FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime,ftLocal;
    BOOL fRc = FALSE;
    TCHAR * pFile = NULL;

    if( ExtractFileNameFromKey(pFile,wcsFileName) )
	{
		if( SUCCEEDED(OpenFileAndLookForItIfItDoesNotExist( pFile, hFile )))
		{
            if( GetFileTime( hFile, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime ))
			{
                //==========================================================
                // Pick up the path of the file while we are here....
                //==========================================================
				TCHAR sFullPath[MAX_PATH * 4];
				TCHAR *sFilename = NULL;

				if (GetFullPathName(pFile, MAX_PATH * 4, sFullPath, &sFilename) != 0)
				{

#ifndef UNICODE
					CAnsiUnicode XLate;
					WCHAR * pTmp = NULL;
					if( SUCCEEDED(XLate.AllocateAndConvertAnsiToUnicode(sFullPath,pTmp)))
					{
						wcscpy(wcsFileName,pTmp);
						SAFE_DELETE_ARRAY( pTmp );
					}
#else
						wcscpy(wcsFileName,sFullPath);
#endif
				}
				else
				{
				
					DWORD dwTest = GetLastError();
					ERRORTRACE((THISPROVIDER,"GetFullPathName FAILED for filename: \n"));
					TranslateAndLog(wcsFileName);
					ERRORTRACE((THISPROVIDER,": GetlastError returned %ld\n",dwTest));
				}

			    FileTimeToLocalFileTime( &ftLastWriteTime, &ftLocal);

	            lLowDateTime  = (ULONG)ftLocal.dwLowDateTime;
			    lHighDateTime = (ULONG)ftLocal.dwHighDateTime;

                fRc = TRUE;
            }
			else
			{
					DWORD dwTest = GetLastError();
					ERRORTRACE((THISPROVIDER,"GetFileTime FAILED for filename:\n"));
					TranslateAndLog(wcsFileName);
					ERRORTRACE((THISPROVIDER,": GetlastError returned %ld\n",dwTest));
   			}

			CloseHandle(hFile);
        }
		else
		{
			DWORD dwTest = GetLastError();
			ERRORTRACE((THISPROVIDER,"CreateFile FAILED for filename:\n"));
			TranslateAndLog(wcsFileName);
			ERRORTRACE((THISPROVIDER,": GetlastError returned %ld\n",dwTest));
		}

    }
	else
	{
		DWORD dwTest = GetLastError();
		ERRORTRACE((THISPROVIDER,"Can't extract filename: \n"));
		TranslateAndLog(wcsFileName);
		ERRORTRACE((THISPROVIDER,": GetlastError returned %ld\n",dwTest));
	}

    SAFE_DELETE_ARRAY( pFile )
    return fRc;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::NeedToProcessThisMof( WCHAR * wcsFileName,ULONG & lLowDateTime, ULONG & lHighDateTime )
{
	BOOL fNeedToProcessThisMof = TRUE;
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;
    IWbemClassObject * pClass=NULL;
	CAutoWChar wcsBuf(_MAX_PATH*4);
	CAutoWChar wcsTmp(_MAX_PATH*4);
	if( wcsTmp.Valid() && wcsBuf.Valid() )
	{

		//==================================================
		// Change all \ to \\
		//==================================================
		ConvertStringToCTypeString( wcsTmp,wcsFileName );
		swprintf(wcsBuf,L"WmiBinaryMofResource.HighDateTime=%lu,LowDateTime=%lu,Name=\"%s\"",lHighDateTime,lLowDateTime,wcsTmp);

		//==================================================
		//  Get a pointer to a IWbemClassObject object
		//  Have we ever processed this mof before?
		//  if not, then return TRUE
		//==================================================

		if( m_fUpdateNamespace )
		{
			CBSTR cbstr(wcsBuf);
			hr = SERVICES->GetObject(cbstr, 0,CONTEXT, &pClass, NULL);		
			if(WBEM_NO_ERROR == hr)
			{  
				fNeedToProcessThisMof = FALSE;
				CVARIANT vSuccess;
		
				hr = pClass->Get(L"MofProcessed", 0, &vSuccess, 0, 0);
				if( hr == WBEM_NO_ERROR )
				{
					//=========================================================================
					// make sure it is added to the registry
					//=========================================================================
					AddThisMofToRegistryIfNeeded(WDM_REG_KEY,wcsFileName,lLowDateTime,lHighDateTime,vSuccess.GetBool());
				}
				SAFE_RELEASE_PTR( pClass);
			}
			//==============================================================================
			//  Delete any old instances that might be hanging around for this driver
			//==============================================================================
			IEnumWbemClassObject* pEnum = NULL;
			CAutoWChar wcsQuery(MEMSIZETOALLOCATE);
			if( wcsQuery.Valid() )
			{
				ULONG uReturned = 0;
				swprintf(wcsQuery,L"select * from WMIBinaryMofResource where Name = \"%s\"",wcsTmp);
				CBSTR bstrTemp = wcsQuery;
				CBSTR strQryLang(L"WQL");

				hr = SERVICES->ExecQuery(strQryLang, bstrTemp, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT,&pEnum);
				if( hr == WBEM_NO_ERROR )
				{
    				IWbemClassObject * pClass = NULL;
					while( TRUE )
					{
						if( WBEM_NO_ERROR == (hr = pEnum->Next(2000, 1, &pClass, &uReturned)))
						{
							CVARIANT vPath, vDriver;
							hr = pClass->Get(L"__RELPATH", 0, &vPath, 0, 0);
							if( hr == WBEM_NO_ERROR )
							{
								if( _wcsicmp(vPath.GetStr(),wcsBuf) != 0 )
								{
									hr = SERVICES->DeleteInstance(vPath.GetStr(),WBEM_FLAG_OWNER_UPDATE,CONTEXT,NULL);
				           			ERRORTRACE((THISPROVIDER,"We have been requested to delete this mof, :%ld\n",hr));
									TranslateAndLog(vPath.GetStr());
									if( hr == WBEM_NO_ERROR )
									{
										//=====================================================
										//  Duplicate change in registry
										//=====================================================
										DeleteMofFromRegistry( vPath.GetStr() );
										//==========================================================================
										//  Gets rid of the old classes for the old versions of this driver
										//==========================================================================
										hr = pClass->Get(L"Driver", 0, &vDriver, 0, 0);
										if( hr == WBEM_NO_ERROR )
										{
											CNamespaceManagement Namespace(this);
											Namespace.DeleteOldClasses(vDriver.GetStr(),CVARIANT((long)lLowDateTime),CVARIANT((long)lHighDateTime), TRUE);
										}
									}
								}
							}
						}
						SAFE_RELEASE_PTR( pClass );
						if( hr != WBEM_NO_ERROR )
						{
							break;
						}
					}
					SAFE_RELEASE_PTR(pEnum);
					}
			}
		}
		else
		{
			if( ThisMofExistsInRegistry(WDM_DREDGE_KEY,wcsFileName, lLowDateTime, lHighDateTime, TRUE) )
			{ 
				fNeedToProcessThisMof = FALSE;
			}
		}
	}
    return fNeedToProcessThisMof;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::UpdateMofTimestampInHMOM(WCHAR * wcsKey,ULONG & lLowDateTime, ULONG & lHighDateTime, BOOL fSuccess )
{
	BOOL fRc = FALSE;
    IWbemClassObject * pNewInst = NULL;
    IWbemClassObject * pIWbemClassObject = NULL;
	//==================================================
	//  Get a pointer to a IWbemClassObject object
	//==================================================
    HRESULT hr = WBEM_NO_ERROR;
	if( m_fUpdateNamespace )
	{
		CVARIANT cvarName;
		cvarName.SetStr(L"WMIBinaryMofResource");
		hr = SERVICES->GetObject(cvarName, 0,CONTEXT, &pIWbemClassObject, NULL);		
		if(WBEM_NO_ERROR ==  hr)
		{
   			//=============================================================
			//  Spawn a new instance
			//=============================================================
			hr = pIWbemClassObject->SpawnInstance(0, &pNewInst);
			SAFE_RELEASE_PTR(pIWbemClassObject);
			if( WBEM_NO_ERROR == hr )
			{
				CVARIANT vLow, vHigh, vName, vSuccess;

				vSuccess.SetBool(fSuccess);
				vName.SetStr(wcsKey);
				vLow.SetLONG(lLowDateTime);
				vHigh.SetLONG(lHighDateTime);
			
				hr = pNewInst->Put(L"Name", 0, &vName, NULL);
				if( S_OK == hr )
				{
					hr = pNewInst->Put(L"LowDateTime", 0, &vLow, NULL);
					if( S_OK == hr )
					{
						hr = pNewInst->Put(L"HighDateTime", 0, &vHigh, NULL);
						if( S_OK == hr )
						{
							hr = pNewInst->Put(L"MofProcessed", 0, &vSuccess, NULL);
							if( S_OK == hr )
							{
								CVARIANT vActive;
								vActive.SetBool(TRUE);
								pNewInst->Put(L"Active", 0, &vActive, NULL);
							}
		
							hr = SERVICES->PutInstance(pNewInst,WBEM_FLAG_OWNER_UPDATE,CONTEXT,NULL);
							SAFE_RELEASE_PTR(pNewInst);
						}
					}
				}
			}
		}
	}

	if( hr == WBEM_NO_ERROR )
	{
		//==========================================
		//  Make sure this really is in the registry
		//  too
		//==========================================
		if( WBEM_NO_ERROR == AddThisMofToRegistryIfNeeded(WDM_REG_KEY,wcsKey,lLowDateTime,lHighDateTime,fSuccess))
		{
			fRc = TRUE;
		}
	}
    return fRc;
}
///////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::GetNextSectionFromTheEnd(WCHAR * pwcsTempPath, WCHAR * pwcsEnd )
{
    BOOL fReturn = FALSE;
    WCHAR * pc = wcsrchr(pwcsTempPath,'\\');
	if(pc)
    {
        //==================================================
        // Copy what was there and set the end to NULL
        //==================================================
        pc++;
        wcscpy( pwcsEnd, pc );
        pc--;
        *(pc) = NULL;  
        fReturn = TRUE;
    }
    return fReturn;
}
///////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::UseDefaultLocaleId(WCHAR * wcsFile, WORD & wLocalId)
{
    BOOL fLoadDefaultLocale = TRUE;

    //=============================================================
    //  Parse paths - get the locale id from paths of this format:
    //
    //  check for path beginning with %windir% and with MUI in second to last position
    //  if not found, check for fixed directory: %windir%\MUI\Fallback
    //  if not found - assume it is not MUI related and try it with FindResource
    //
     //=============================================================
    TCHAR szWindowsDir[_MAX_PATH];
    if ( GetWindowsDirectory ( szWindowsDir , sizeof ( szWindowsDir ) / sizeof(TCHAR)) )
    {
        //==========================================================
        //  if these are windows directories
        //==========================================================
        if( 0 == _wcsnicmp( szWindowsDir, wcsFile, wcslen(szWindowsDir)))
        {
            CAutoWChar wcsTempPath(_MAX_PATH);
            CAutoWChar wcsBuffer(_MAX_PATH);

			if( wcsTempPath.Valid() && wcsBuffer.Valid() )
			{
				//======================================================
				//  Find last \ in the string, and trim off filename
				//======================================================
				wcscpy(wcsTempPath,wcsFile);

				if( GetNextSectionFromTheEnd( wcsTempPath, wcsBuffer ))
				{
					//==================================================
					//  Now, get the potential locale id
					//==================================================
					if( GetNextSectionFromTheEnd( wcsTempPath, wcsBuffer ))
					{
						wLocalId = (WORD) _wtoi(wcsBuffer);
						//==============================================
						//  Now, get the next bit to see if it says MUI 
						//  or Fallback
						//==============================================
						if( GetNextSectionFromTheEnd( wcsTempPath, wcsBuffer ))
						{
							if( 0 == _wcsicmp( L"MUI", wcsBuffer ))
							{
								fLoadDefaultLocale = FALSE;
							}
							else if( 0 == _wcsicmp( L"Fallback", wcsBuffer ) )
							{
								//==============================================
								//  If it says Fallback, then check to make 
								//  sure the next bit says MUI
								//==============================================
								if( GetNextSectionFromTheEnd( wcsTempPath, wcsBuffer ))
								{
									if( 0 == _wcsicmp( L"MUI", wcsBuffer ) )
									{
										fLoadDefaultLocale = FALSE;
									}
								}
							}
						}
					}
				}
			}
        }
    }
    return fLoadDefaultLocale;
}
///////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::GetPointerToBinaryResource(BYTE *& pRes,
                                            DWORD & dwSize,
                                            HGLOBAL & hResource,
                                            HINSTANCE & hInst,
                                            WCHAR * wcsResource,
                                            WCHAR * wcsFile)

{
    TCHAR * pResource = NULL;
    BOOL fRc = FALSE;
    CAnsiUnicode xLate;
    DWORD dwError = 0;

    TCHAR * pFile = NULL;

    if( ExtractFileNameFromKey(pFile,wcsFile) ){

#ifndef UNICODE
        xLate.UnicodeToAnsi(wcsResource,pResource);
#else
		pResource = wcsResource;
#endif
        if( pResource )
        {
            hInst = LoadLibraryEx(pFile,NULL,LOAD_LIBRARY_AS_DATAFILE);
            if( hInst != NULL )
            {
		        HRSRC hSrc = NULL;
                WORD wLocaleId = 0;
                if( UseDefaultLocaleId(wcsResource, wLocaleId ))
                {
   		            hSrc = FindResource(hInst,pResource, _T("MOFDATA"));
                }
                else
                {
                    hSrc = FindResourceEx(hInst,pResource, _T("MOFDATA"),wLocaleId);
                }
                if( hSrc == NULL )
                {

                    FreeLibrary(hInst);
                    dwError = GetLastError();
                }
		        if( NULL != hSrc)
                {
			        hResource = LoadResource( hInst,hSrc);
			        if( hResource )
                    {
				        pRes = (BYTE *)LockResource(hResource);
				        dwSize = SizeofResource(hInst,hSrc);
				        fRc = TRUE;
			        }
		        }
            }
        }
#ifndef UNICODE
        SAFE_DELETE_ARRAY(pResource );
#endif
        SAFE_DELETE_ARRAY(pFile );

    }
    return fRc;
}
/////////////////////////////////////////////////////////////////////
BYTE * CWMIBinMof::DecompressBinaryMof(BYTE * pRes)
{

    DWORD dwCompType, dwCompressedSize, dwExpandedSize, dwSig, dwResSize;
    BYTE * pExpanded = NULL;

	//=========================================================
    // get the signature, compression type, and the sizes
	//=========================================================
	memcpy(&dwSig,pRes,sizeof(DWORD));
	pRes += sizeof( DWORD );

	memcpy(&dwCompType,pRes,sizeof(DWORD));
	pRes += sizeof( DWORD );

	memcpy(&dwCompressedSize,pRes,sizeof(DWORD));
	pRes += sizeof( DWORD );

	memcpy(&dwExpandedSize,pRes,sizeof(DWORD));
	pRes += sizeof( DWORD );

	//=========================================================
    // make sure the signature is valid and that the compression type is one
    // we understand!
	//=========================================================
    if(dwSig != BMOF_SIG ||dwCompType != 1){
        return NULL;
    }

	//=========================================================
    // Allocate storage for the compressed data and
    // expanded data
	//=========================================================
	try
    {
		pExpanded = (BYTE*)malloc(dwExpandedSize);
		if( pExpanded == NULL)
        {
			goto ExitDecompression;
		}
	}
	catch(...)
    {
		throw;
	}

	//=========================================================
    // Decompress the data
	//=========================================================
    CBaseMrciCompression  * pMrci = new CBaseMrciCompression;
    if( pMrci )
    {
        dwResSize = pMrci->Mrci1Decompress(pRes, dwCompressedSize, pExpanded, dwExpandedSize);
        if(dwResSize != dwExpandedSize)
        {
            SAFE_DELETE_PTR(pMrci);
		    goto ExitDecompression;
        }
        SAFE_DELETE_PTR(pMrci);
    }


	//=========================================================
	//  Now, get out of here
	//=========================================================
    return pExpanded;

ExitDecompression:
	if( pExpanded )
		free(pExpanded);

	return NULL;

}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::ExtractFileNameFromKey(TCHAR *& pKey,WCHAR * wcsKey)
{
	WCHAR *wcsToken = NULL;
	CAutoWChar wcsTmp(MAX_PATH * 4);
    BOOL fRc = FALSE;

	if( wcsTmp.Valid() )
	{
		if(wcsKey)
		{
			//======================================================
			// Get a ptr to the first [ , if there isn't one, then
			// just copy the whole thing.
			//======================================================
			wcscpy(wcsTmp,wcsKey);
			wcsToken = wcstok(wcsTmp, L"[" );
			if( wcsToken != NULL )
			{
				wcscpy(wcsTmp,wcsToken);
			}

	#ifndef UNICODE
			CAnsiUnicode XLate;

			if( SUCCEEDED(XLate.UnicodeToAnsi(wcsTmp,pKey)))
			{
			   fRc = TRUE;
			}
	#else
			pKey = new TCHAR[_tcslen(wcsTmp) + 1];
			if(pKey)
			{
				_tcscpy(pKey,wcsTmp);
				fRc = TRUE;
			}
	#endif
		}
	}
    return fRc;
}
/////////////////////////////////////////////////////////////////////
void CWMIBinMof::CreateKey(WCHAR * wcsFileName, WCHAR * wcsResource,WCHAR * wcsKey)
{
    swprintf(wcsKey,L"%s[%s]",wcsFileName, wcsResource );
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::SendToMofComp(DWORD dwSize,BYTE * pRes,WCHAR * wcsKey)
{
    HRESULT hr = WBEM_NO_ERROR;

	if(m_pCompiler == NULL)
	{
		hr = CoCreateInstance(CLSID_WinmgmtMofCompiler, 0, CLSCTX_INPROC_SERVER,IID_IWinmgmtMofCompiler, (LPVOID *) &m_pCompiler);
	}
	if(hr == WBEM_NO_ERROR)
	{

		WBEM_COMPILE_STATUS_INFO Info;
		memset(&Info,0,sizeof(WBEM_COMPILE_STATUS_INFO));
		hr = m_pCompiler->WinmgmtCompileBuffer(dwSize, pRes, 0, 65536, 0,SERVICES,CONTEXT , &Info);
		if( hr != WBEM_NO_ERROR )
		{
			ERRORTRACE((THISPROVIDER,"***************\n"));
			ERRORTRACE((THISPROVIDER,"Mofcomp of binary mof failed for:\n"));
			TranslateAndLog(wcsKey);
			ERRORTRACE((THISPROVIDER,"WinmgmtCompileBuffer return value: %ld\n",hr));
			ERRORTRACE((THISPROVIDER,"Size of Mof: %ld\n",dwSize));
			ERRORTRACE((THISPROVIDER,"***************\n"));
		}
		else
		{
			ERRORTRACE((THISPROVIDER,"***************\n"));
			ERRORTRACE((THISPROVIDER,"Binary mof succeeded for:\n"));
			TranslateAndLog(wcsKey);
			ERRORTRACE((THISPROVIDER,"***************\n"));
		}
	}
	
    return hr;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::ExtractBinaryMofFromFile(WCHAR * wcsFile, WCHAR * wcsResource,WCHAR * wcsKey, BOOL & fMofHasChanged)
{
    HRESULT hr;
    BOOL fSuccess = TRUE;
	CAutoWChar wcsTmp(MAX_PATH*4);

	if( wcsTmp.Valid() )
	{
		ULONG lLowDateTime=0,lHighDateTime=0;
		//=====================================
		//  As long as we have a list, process
		//  one at a time
		//=====================================
		lLowDateTime = 0l;
		lHighDateTime = 0L;
		fMofHasChanged = FALSE;
		//==============================================
		//  Compare the file date/timestamp the date/timestamp is different, change
		//  it.
		//==============================================
		wcscpy(wcsTmp,wcsFile);
		if( GetFileDateAndTime(lLowDateTime,lHighDateTime,wcsTmp) )
		{
			CreateKey(wcsTmp,wcsResource,wcsKey);


		   // DBG_PRINTFA((pBuff,"Event:%S\n",wcsKey));

			if( NeedToProcessThisMof(wcsKey,lLowDateTime,lHighDateTime) )
			{
				fMofHasChanged = TRUE;

				if( m_fUpdateNamespace )
				{
					DWORD dwSize = 0;
					BYTE * pRes = NULL;
					HGLOBAL  hResource = NULL;
					HINSTANCE hInst = NULL;

					if( GetPointerToBinaryResource(pRes,dwSize,hResource,hInst,wcsResource,wcsKey) )
					{
						hr = SendToMofComp(dwSize,pRes,wcsKey);
						if(hr == WBEM_S_NO_ERROR )
						{
							if( UpdateMofTimestampInHMOM(wcsKey,lLowDateTime,lHighDateTime, TRUE) )
							{
								CNamespaceManagement Namespace(this);
								Namespace.CreateClassAssociationsToDriver(wcsKey,pRes,lLowDateTime,lHighDateTime);
								Namespace.DeleteOldClasses(wcsKey,CVARIANT((long)lLowDateTime),CVARIANT((long)lHighDateTime), TRUE);
								fSuccess = TRUE;
							}
							else
							{
								UpdateMofTimestampInHMOM(wcsKey,lLowDateTime,lHighDateTime,FALSE);
							}
						}
						else
						{
							UpdateMofTimestampInHMOM(wcsKey,lLowDateTime,lHighDateTime,FALSE);
						}
						UnlockResource(hResource);
						FreeResource(hResource);
						FreeLibrary(hInst);
					}
					else
					{
						ERRORTRACE((THISPROVIDER,"***************\n"));
						ERRORTRACE((THISPROVIDER,"Could not get pointer to binary resource for file:\n"));
						TranslateAndLog(wcsKey);
						ERRORTRACE((THISPROVIDER,"***************\n"));
						UpdateMofTimestampInHMOM(wcsKey,lLowDateTime,lHighDateTime,FALSE);
					}
				}
			}
			else
			{
				fSuccess = TRUE;
			}
		}
		else
		{
					DWORD dwTest = GetLastError();
					ERRORTRACE((THISPROVIDER,"Something  FAILED for filename: %s\n",wcsFile));
					ERRORTRACE((THISPROVIDER,": GetlastError returned %ld\n",dwTest));

			ERRORTRACE((THISPROVIDER,"***************\n"));
			ERRORTRACE((THISPROVIDER,"Invalid File:\n"));
			TranslateAndLog(wcsFile);
			ERRORTRACE((THISPROVIDER,"***************\n"));
			UpdateMofTimestampInHMOM(wcsFile,lLowDateTime,lHighDateTime,FALSE);
			wcscpy(wcsKey, wcsFile);

		}
	}
    return fSuccess;
}
//////////////////////////////////////////////////////////////////////////
#define WDMPROV_REG_KEY L"Software\\Microsoft\\WBEM\\WDMProvider"
BOOL CWMIBinMof::UserConfiguredRegistryToProcessStrandedClassesDuringEveryInit(void)
{
	DWORD dwProcess = 0;
	CRegistry RegInfo ;

	DWORD dwRet = RegInfo.Open (HKEY_LOCAL_MACHINE, WDMPROV_REG_KEY, KEY_READ) ;
	if ( dwRet == ERROR_SUCCESS )
	{
		RegInfo.GetCurrentKeyValue ( L"ProcessStrandedClasses",dwProcess );
	}
	RegInfo.Close();

	return (BOOL) dwProcess;
}
///////////     //////////////////////////////////////////////////////////
void CWMIBinMof::ProcessListOfWMIBinaryMofsFromWMI()
{
    HRESULT hr = WBEM_E_FAILED;

	if( m_nInit == FULLY_INITIALIZED )
	{
		CAutoWChar wcsFileName(MAX_PATH*3);
		CAutoWChar wcsResource(MAX_PATH*3);

		if( wcsFileName.Valid() && wcsResource.Valid() )
		{
			KeyList ArrDriversInRegistry;
			//============================================================
			//  Get list of what is currently in the registry
			//============================================================
			GetListOfDriversCurrentlyInRegistry(WDM_REG_KEY,ArrDriversInRegistry);

			//======================================================================
			//  Initialize things
			//======================================================================
			BOOL fMofChanged = FALSE;
			m_fUpdateNamespace = TRUE;

			//======================================================================
			//  Allocate working classes
			//======================================================================
			CWMIStandardShell * pWMI = new CWMIStandardShell;
			if( pWMI )
			{
				hr = pWMI->Initialize(NULL,FALSE,m_pWMI->HandleMap(),m_fUpdateNamespace, WMIGUID_QUERY, m_pWMI->Services(),m_pWMI->Handler(),m_pWMI->Context());
				if( S_OK == hr )
				{

					CNamespaceManagement * pNamespace = new CNamespaceManagement(this);
					if( pNamespace )
					{
						//=========================================
						//  Query the binary guid
						//=========================================
						pNamespace->InitQuery(L"select * from WMIBinaryMofResource where Name != ");

						hr = pWMI->QueryAndProcessAllBinaryGuidInstances(*pNamespace, fMofChanged, &ArrDriversInRegistry);
						//=========================================
						//  Get a list of binary mofs from WMI
						//=========================================
						GetListOfBinaryMofs();
						ULONG nTmp=0;
						CAutoWChar wcsTmpKey(MAX_PATH*3);
						BOOL fProcessStrandedClasses = FALSE;				 
						if( wcsTmpKey.Valid() )
						{
							if( m_uResourceCount > 0 )
							{
								//===============================================================
								//  Go through and get all the resources to process one by one
								//===============================================================
								while( GetBinaryMofFileNameAndResourceName(wcsFileName,wcsResource)){

								   //============================================================
									//  Process the binary mof
									//============================================================
									if( ExtractBinaryMofFromFile(wcsFileName,wcsResource,wcsTmpKey,fMofChanged))
									{
										pNamespace->UpdateQuery(L" and Name != ",wcsTmpKey);
									}
									if( fMofChanged )			
									{								
										fProcessStrandedClasses = TRUE;	
									}							

									ArrDriversInRegistry.Remove(wcsTmpKey);
								}
							}
						}
						pNamespace->DeleteOldDrivers(FALSE);
						//===========================================================================
						//  If we are not supposed to process stranded classes, check the reg key
						//  to see if it wants us to anyway
						//===========================================================================
						if( !fProcessStrandedClasses )
						{
							fProcessStrandedClasses = UserConfiguredRegistryToProcessStrandedClassesDuringEveryInit();
						}
						if( fProcessStrandedClasses )			
						{											
							pNamespace->DeleteStrandedClasses();	
						}											
						DeleteOldDriversInRegistry(ArrDriversInRegistry);
						SAFE_DELETE_PTR(pNamespace);
					}
				}
				SAFE_DELETE_PTR(pWMI);
			}
			if( m_pMofResourceInfo )
			{
				WmiFreeBuffer( m_pMofResourceInfo );
			}
		}
	}
	ERRORTRACE((THISPROVIDER,"End of processing Binary MOFS***************\n"));
}
/////////////////////////////////////////////////////////////////////
//=============================================================
//  THE BINARY MOF GROUP
//=============================================================
BOOL CWMIBinMof::GetListOfBinaryMofs()
{
    BOOL fRc = TRUE;
    ULONG uRc;
    m_uCurrentResource = 0;

    m_pMofResourceInfo = NULL;
    m_uResourceCount = 0;

    try
    {
        uRc = WmiMofEnumerateResourcesW( 0, &m_uResourceCount, &m_pMofResourceInfo );
        if( uRc != ERROR_SUCCESS )
        {
            fRc = FALSE;
        }
    }
    catch(...)
    {
        fRc = FALSE;
        // don't throw
    }

    return fRc;
}
//=============================================================
BOOL CWMIBinMof::GetBinaryMofFileNameAndResourceName(WCHAR * pwcsFileName,WCHAR * pwcsResource)
{
    BOOL fRc = FALSE;

    //===================================================================
    //  There are a lot of tests in here, due to strange results from
    //  WDM Service under stress.
    //===================================================================
    if( m_uCurrentResource < m_uResourceCount ){

        if( m_pMofResourceInfo ){

            DWORD dwFileLen = wcslen(m_pMofResourceInfo[m_uCurrentResource].ImagePath);
            DWORD dwResourceLen = wcslen(m_pMofResourceInfo[m_uCurrentResource].ResourceName);

            if( dwFileLen <( MAX_PATH * 2) && dwResourceLen < (MAX_PATH * 2 )){

           	    if( IsBadReadPtr( m_pMofResourceInfo[m_uCurrentResource].ImagePath,dwFileLen) == 0 ){
                    wcscpy( pwcsFileName, m_pMofResourceInfo[m_uCurrentResource].ImagePath );

               	    if( IsBadReadPtr( m_pMofResourceInfo[m_uCurrentResource].ResourceName,dwResourceLen) == 0 ){
                        wcscpy( pwcsResource, m_pMofResourceInfo[m_uCurrentResource].ResourceName );
                        m_uCurrentResource++;
                        fRc = TRUE;
                    }
                }
            }
        }
    }
    return fRc;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::ExtractBinaryMofFromDataBlock(BYTE * pByte,ULONG uInstanceSize, WCHAR * wcsKey, BOOL & fMofHasChanged)
{

	HRESULT hr = WBEM_E_FAILED;
    //===================================================
    //  Get the CRC of the data buffer
    //===================================================
    DWORD dwCRC = STARTING_CRC32_VALUE;

	if( IsBadReadPtr( pByte,uInstanceSize) != 0 ){
		return WBEM_E_INVALID_OBJECT;
	}

    dwCRC = UpdateCRC32(pByte,uInstanceSize, dwCRC);
    FINALIZE_CRC32(dwCRC);
   	//=========================================================
    // get the size of the buffer to send
	//=========================================================
	DWORD dwCompressedSize;
    BYTE * pTmp = pByte;
	pTmp += sizeof( DWORD ) * 2;

	memcpy(&dwCompressedSize,pTmp,sizeof(DWORD));
	dwCompressedSize += 16;
	fMofHasChanged = FALSE;
    //===================================================
    //  See if we should process this class or not
    //===================================================
    ULONG lLow = dwCRC;
    ULONG lHigh = 0;

   // DBG_PRINTFA((pBuff,"Event:%S\n",wcsKey));

    if( NeedToProcessThisMof(wcsKey,lLow,lHigh))
	{
		if( !m_fUpdateNamespace )
		{
			fMofHasChanged = TRUE;
	        hr = WBEM_NO_ERROR;
		}
		else
		{
			hr = SendToMofComp(dwCompressedSize,pByte,wcsKey);
			if( hr == WBEM_NO_ERROR )
			{
				if( UpdateMofTimestampInHMOM(wcsKey,lLow,lHigh, TRUE))
				{
					CNamespaceManagement Namespace(this);
					Namespace.CreateClassAssociationsToDriver(wcsKey,pByte,lLow,lHigh);
					Namespace.DeleteOldClasses(wcsKey,CVARIANT((long)lLow),CVARIANT((long)lHigh),TRUE);
				}
				else
				{
					UpdateMofTimestampInHMOM(wcsKey,lLow,lHigh,FALSE);
				}
			}
			else
			{
				UpdateMofTimestampInHMOM(wcsKey,lLow,lHigh,FALSE);
			}
		}
    }
    else
	{
        hr = WBEM_NO_ERROR;
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::DeleteMofsFromEvent(CVARIANT & vImagePath,CVARIANT & vResourceName, BOOL & fMofHasChanged)
{
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;
	CAutoWChar wcsTmp(MAX_PATH*2);

	if( wcsTmp.Valid() )
	{
		hr = WBEM_E_INVALID_OBJECT;
		//=========================================
		//  Initialize stuff
		//=========================================
		fMofHasChanged = FALSE;

		//=================================================================
		// if we have an image path and resource path we are working with
		// file, otherwise it is a binary guidd
		//=================================================================
		if((vResourceName.GetType() != VT_NULL ) && ( vImagePath.GetType() != VT_NULL  )){

			CreateKey( vImagePath.GetStr(), vResourceName.GetStr(),wcsTmp );
		}
		else if( vResourceName.GetType() != VT_NULL ){

			SetBinaryMofClassName(vResourceName.GetStr(),wcsTmp);
		}

		if( m_fUpdateNamespace )
		{

			CNamespaceManagement Namespace(this);

			Namespace.InitQuery(L"select * from WMIBinaryMofResource where Name = ");
			Namespace.UpdateQuery(L"",wcsTmp);

			if( Namespace.DeleteOldDrivers(FALSE) )
			{
				hr = WBEM_NO_ERROR;
				fMofHasChanged = TRUE;
			}
		}
		else
		{
			if( ThisMofExistsInRegistry(WDM_REG_KEY,wcsTmp, 0, 0, FALSE))
			{ 
				fMofHasChanged = TRUE;
			}
			hr = WBEM_NO_ERROR;
		}
	}
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************************
//  Functions for the Dredger
//**********************************************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// format of string containing mof info is:
// "WmiBinaryMofResource.HighDateTime=9999,LowDateTime=9999,Name="Whatever"
//
//	HKLM\Software\Microsoft\WBEM\WDM\WDMBinaryMofResource
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CWMIBinMof::AddThisMofToRegistryIfNeeded(WCHAR * wcsKey, WCHAR * wcsFileName, ULONG & lLowDateTime, ULONG & lHighDateTime, BOOL fSuccess)
{
	HRESULT hr = WBEM_E_FAILED;
	CRegistry RegInfo ;

	DWORD dwRet = RegInfo.CreateOpen (HKEY_LOCAL_MACHINE, wcsKey) ;
	if ( dwRet == ERROR_SUCCESS )
	{
		CAutoWChar wcsBuf(MAX_PATH);
		if( wcsBuf.Valid() )
		{

			if( fSuccess )
			{
				swprintf(wcsBuf,L"LowDateTime:%ld,HighDateTime:%ld***Binary mof compiled successfully", lLowDateTime, lHighDateTime);
			}
			else
			{
				swprintf(wcsBuf,L"LowDateTime:%ld,HighDateTime:%ld***Binary mof failed, see WMIPROV.LOG", lLowDateTime, lHighDateTime);
			}
			CHString sTmp = wcsBuf;

			if ( RegInfo.SetCurrentKeyValue ( wcsFileName,sTmp ) == ERROR_SUCCESS )
			{
				hr = WBEM_S_NO_ERROR ;
			}
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	RegInfo.Close();
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::ThisMofExistsInRegistry(WCHAR * wcsKey,WCHAR * wcsFileName, ULONG lLowDateTime, ULONG lHighDateTime, BOOL fCompareDates)
{
	BOOL fExists = FALSE;
	CRegistry RegInfo ;

	DWORD dwRet = RegInfo.Open (HKEY_LOCAL_MACHINE, wcsKey, KEY_READ) ;
	if ( dwRet == ERROR_SUCCESS )
	{
		CHString chsValue;
		
		if ( RegInfo.GetCurrentKeyValue ( wcsFileName,chsValue ) == ERROR_SUCCESS )
		{
			if( fCompareDates )
			{
				CAutoWChar wcsIncomingValue(MAX_PATH);
				CAutoWChar wcsTmp(MAX_PATH);

				if( wcsIncomingValue.Valid() && wcsTmp.Valid() )
				{
					swprintf(wcsIncomingValue,L"LowDateTime:%ld,HighDateTime:%ld", lLowDateTime, lHighDateTime );

					WCHAR *wcsToken = NULL;
    
					//======================================================
					// Get a ptr to the first *** , if there isn't one, then
					// we have a messed up key
					//======================================================
					wcscpy(wcsTmp,(const WCHAR*)chsValue);
					wcsToken = wcstok(wcsTmp, L"*" );
					if( wcsToken != NULL )
					{
						if( _wcsicmp(wcsToken, wcsIncomingValue) == 0 )
						{
							fExists = TRUE;
						}
					}
				}
			}
			else
			{
				fExists = TRUE;
			}
		}
	}
	RegInfo.Close();
	return fExists;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::DeleteMofFromRegistry(WCHAR * wcsFileName)
{
	HRESULT hr = WBEM_E_FAILED;

	HKEY hKey;
	hr = RegOpenKey(HKEY_LOCAL_MACHINE, WDM_REG_KEY, &hKey);
    if(NO_ERROR == hr)
    {
        hr = RegDeleteValue(hKey,wcsFileName);
        CloseHandle(hKey);
    }
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::DeleteOldDriversInRegistry(KeyList & ArrDriversInRegistry)
{
	int nSize = ArrDriversInRegistry.GetSize();
	for( int i=0; i < nSize; i++ )
	{
		DeleteMofFromRegistry(ArrDriversInRegistry.GetAt(i));
	}
	return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::CopyWDMKeyToDredgeKey()
{
	BOOL fSuccess = FALSE;
	//=======================================================================
	//  Open up the WDM Dredge Key and enumerate the keys, copy them into
	//  the DredgeReg key
	//=======================================================================
	CRegistry   WDMReg;
	CRegistry   WDMDregReg;
	
	if (ERROR_SUCCESS == WDMReg.Open(HKEY_LOCAL_MACHINE, WDM_REG_KEY, KEY_READ))
	{
		//===============================================================
		//  Clean up old stuff
		//  Note:  You need to open up the parent key, so you can delete
		//  the child DREDGE key
		//===============================================================
		if( ERROR_SUCCESS == WDMDregReg.Open(HKEY_LOCAL_MACHINE, WDM_REG_KEY, KEY_READ))
		{
			CHString pchs(DREDGE_KEY);
			WDMDregReg.DeleteKey(&pchs);
			WDMDregReg.Close();
		}
		if( ERROR_SUCCESS == WDMDregReg.CreateOpen(HKEY_LOCAL_MACHINE, WDM_DREDGE_KEY))
		{
			//===============================================================
			//  Go through the loop, and copy the keys
			//===============================================================
			BYTE *pValueData = NULL ;
			WCHAR *pValueName = NULL ;
			fSuccess = TRUE;

			for(DWORD i = 0 ; i < WDMReg.GetValueCount(); i++)
			{
				DWORD dwRc = WDMReg.EnumerateAndGetValues(i, pValueName, pValueData) ;
				if( dwRc == ERROR_SUCCESS )
				{
					CHString chsKey(pValueName);
					CHString chsValue((LPCWSTR)pValueData);
					if ( !WDMDregReg.SetCurrentKeyValue ( chsKey, chsValue ) == ERROR_SUCCESS )
					{
						fSuccess = FALSE;
					}		  
					delete []pValueData;
					delete []pValueName;
				}
				else
				{
					fSuccess = FALSE;
				}
				if( !fSuccess )
				{
					break;
				}
			}

			WDMDregReg.Close();
		}
		WDMReg.Close();
	}

	return fSuccess;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::GetListOfDriversCurrentlyInRegistry(WCHAR * wcsKey, KeyList & ArrDriversInRegistry)
{
	BOOL fSuccess = TRUE;
	CRegistry RegInfo ;
	//==========================================================
    // Open the key for enumeration and go through the sub keys.
	//==========================================================
	HKEY hKey = NULL;
	HRESULT hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wcsKey, 0, KEY_READ | KEY_QUERY_VALUE,&hKey);
	if( ERROR_SUCCESS == hr )
	{	
		WCHAR wcsKeyName[MAX_PATH+2];
		DWORD dwLen = 0;
		int i = 0;
		while( ERROR_SUCCESS == hr )
		{
			dwLen = MAX_PATH+2;
			hr = RegEnumValue(hKey,i,wcsKeyName, &dwLen,0,NULL,NULL,NULL);
			// If we are successful reading the name
			//=======================================  
			if(ERROR_SUCCESS == hr ) 
			{
				ArrDriversInRegistry.Add(wcsKeyName);
				i++;
			}
			else 
			{
				break;
			}
		}
		RegCloseKey(hKey);
	}
	else
	{
		fSuccess = FALSE;
	}
	return fSuccess;
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::ProcessBinaryMofEvent(PWNODE_HEADER WnodeHeader )
{
	HRESULT hr = WBEM_E_FAILED;

	m_fUpdateNamespace = TRUE;
	if( m_nInit == FULLY_INITIALIZED )
	{
		CWMIStandardShell * pWMI = new CWMIStandardShell;
		
		if( pWMI )
		{
			//=======================================================
			//  See if a binary mof event is being added or deleted
			//=======================================================

			if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,WnodeHeader->Guid))
			{
				hr = pWMI->Initialize(RUNTIME_BINARY_MOFS_ADDED,TRUE,m_pWMI->HandleMap(),m_fUpdateNamespace, WMIGUID_QUERY, m_pWMI->Services(),m_pWMI->Handler(), m_pWMI->Context());
				if( S_OK == hr )
				{
					hr = pWMI->ProcessEvent(MOF_ADDED,WnodeHeader);
				}
			}
			else if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_REMOVED_GUID,WnodeHeader->Guid))
			{
				hr = pWMI->Initialize(RUNTIME_BINARY_MOFS_DELETED,TRUE,m_pWMI->HandleMap(),m_fUpdateNamespace, WMIGUID_QUERY, m_pWMI->Services(),m_pWMI->Handler(), m_pWMI->Context());
				if( S_OK == hr )
				{
					hr = pWMI->ProcessEvent(MOF_DELETED,WnodeHeader);
				}
			}	

			SAFE_DELETE_PTR(pWMI);
		}
	}

	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************************
//  STUFF FOR DREDGE
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************************
/////////////////////////////////////////////////////////////////////
//  DREDGE APIS - access ONLY the DREDGE KEY
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::BinaryMofEventChanged(PWNODE_HEADER WnodeHeader )
{
	BOOL fMofHasChanged = TRUE;

	if( m_nInit != NOT_INITIALIZED )
	{
		HRESULT hr = WBEM_E_NOT_FOUND;

		m_fUpdateNamespace = FALSE;
		CWMIStandardShell * pWMI = new CWMIStandardShell;

		if( pWMI )
		{
			//=======================================================
			//  See if a binary mof event is being added or deleted
			//=======================================================

			if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,WnodeHeader->Guid))
			{
				hr = pWMI->Initialize(RUNTIME_BINARY_MOFS_ADDED,
				                      TRUE, 
				                      NULL,
				                      m_fUpdateNamespace, 
				                      WMIGUID_QUERY,
									  NULL,
									  NULL,
									  NULL);
				if( S_OK == hr )
				{
					hr = pWMI->ProcessEvent(MOF_ADDED,WnodeHeader);
				}
			}
			else if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_REMOVED_GUID,WnodeHeader->Guid))
			{
				// DO NOTHING
				hr = pWMI->Initialize(RUNTIME_BINARY_MOFS_DELETED,TRUE, 
				                      NULL,
				                      m_fUpdateNamespace, 
				                      WMIGUID_QUERY,
									  NULL,
									  NULL,
									  NULL);
				if( S_OK == hr )
				{
				//	hr = pWMI->ProcessEvent(MOF_DELETED,WnodeHeader);
				}
			}

			ERRORTRACE((THISPROVIDER,"***************\n"));
			if( pWMI->HasMofChanged() )
			{
				ERRORTRACE((THISPROVIDER,"BinaryMofEventChanged returned TRUE:\n"));
			}
			else
			{
				ERRORTRACE((THISPROVIDER,"BinaryMofEventChanged returned FALSE:\n"));
			}
			fMofHasChanged = pWMI->HasMofChanged();
			SAFE_DELETE_PTR(pWMI);
		}

	}
	return fMofHasChanged;
}
/////////////////////////////////////////////////////////////////////
//  DREDGE APIS - access ONLY the DREDGE KEY
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::BinaryMofsHaveChanged()
{
	BOOL fBinaryMofHasChanged = FALSE;
	if( m_nInit != NOT_INITIALIZED )
	{
		KeyList ArrDriversInRegistry;
		HRESULT hr = WBEM_E_FAILED;
		m_fUpdateNamespace = FALSE;
		//============================================================
		//  Get list of what is currently in the registry
		//============================================================
		BOOL fRc = GetListOfDriversCurrentlyInRegistry(WDM_DREDGE_KEY,ArrDriversInRegistry);
		if( fRc )
		{
			//=====================================================================
			//  Get a list of binary mofs from WMI
			// Query WMIBinaryMofResource for list of static mofs
			//=====================================================================
			GetListOfBinaryMofs();
			if( m_uResourceCount > 0 )
			{
				//===============================================================
				//  Go through and get all the resources to process one by one
				//===============================================================
				CAutoWChar FileName(MAX_PATH*2);
				CAutoWChar Resource(MAX_PATH*2);
				CAutoWChar TmpKey(MAX_PATH*2);

				if( FileName.Valid() && Resource.Valid() && TmpKey.Valid() )
				{
					while( GetBinaryMofFileNameAndResourceName(FileName,Resource))
					{

						//============================================================
						//  Process the binary mof, keep going until one needs to
						//  be processed
						//============================================================
						ExtractBinaryMofFromFile(FileName,Resource,TmpKey, fBinaryMofHasChanged );
						if( fBinaryMofHasChanged )
						{
							break;
						}
						ArrDriversInRegistry.Remove(TmpKey);
					}
				}
			}

			if( !fBinaryMofHasChanged )
			{
				//=========================================
				//  Query the binary guid
				//=========================================
				CNamespaceManagement * pNamespace = new CNamespaceManagement(this);
				if( pNamespace )
				{
					pNamespace->InitQuery(L"select * from WMIBinaryMofResource where Name != ");
					CWMIStandardShell * pWMI = new CWMIStandardShell;

					if( pWMI )
					{
						hr = pWMI->Initialize(NULL, FALSE, NULL,m_fUpdateNamespace, WMIGUID_QUERY,NULL,NULL,NULL);
						if( S_OK == hr )
						{
							hr = pWMI->QueryAndProcessAllBinaryGuidInstances(*pNamespace, fBinaryMofHasChanged,&ArrDriversInRegistry);
						}
						SAFE_DELETE_PTR(pWMI);
					}
					SAFE_DELETE_PTR(pNamespace);
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
/*			//============================================================
			//  If there are any drivers left in the list, then we need
			//  to say that the binary mofs have changed
			//============================================================
			if( !fBinaryMofHasChanged )
			{
				if( ArrDriversInRegistry.OldDriversLeftOver() )
				{
					fBinaryMofHasChanged = TRUE;
				}
			}
*/
		}
		else
		{
			//==============================================================================================
			// there is no key, so now we need to return that the registry has changed, so the copy of the 
			// keys will be kicked off
			//==============================================================================================
			fBinaryMofHasChanged = TRUE;
		}
		if( m_pMofResourceInfo )
		{
			WmiFreeBuffer( m_pMofResourceInfo );
		}

		ERRORTRACE((THISPROVIDER,"***************\n"));
		if( fBinaryMofHasChanged )
		{
			ERRORTRACE((THISPROVIDER,"BinaryMofsHaveChanged returned TRUE:\n"));
		}
		else
		{
			ERRORTRACE((THISPROVIDER,"BinaryMofsHaveChanged returned FALSE:\n"));
		}
	}
	return fBinaryMofHasChanged;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************************
//  Namespace Management Class
//**********************************************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CNamespaceManagement::CNamespaceManagement(CWMIBinMof * pOwner)
{
    m_pObj = pOwner;
    m_nSize = 0;
    m_pwcsQuery = NULL;
    m_fInit = 0;
    m_pwcsSavedQuery = NULL;
    m_fSavedInit = 0;
    m_nSavedSize = 0;

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CNamespaceManagement::~CNamespaceManagement()
{
    SAFE_DELETE_ARRAY( m_pwcsQuery );
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define SERVICES_PTR m_pObj->WMI()->Services()
#define CONTEXT_PTR m_pObj->WMI()->Context()

/////////////////////////////////////////////////////////////////////////////////////////////////
// Delete stranded classes in the repository
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::DeleteStrandedClasses(void)
{
	BOOL fRc = TRUE;
	HRESULT hr	= WBEM_NO_ERROR;
    IEnumWbemClassObject* pEnum = NULL;
    IEnumWbemClassObject* pEnumofStrandedClasses = NULL;
	// ==================================================================================
	//  Get list of drivers
	// ==================================================================================
    InitQuery(L"select * from WMIBinaryMofResource");
	CBSTR strQryLang(L"WQL");
	CBSTR cbstrQry(m_pwcsQuery);

	hr = SERVICES_PTR->ExecQuery(strQryLang,cbstrQry, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT_PTR,&pEnum);
	if( hr == WBEM_NO_ERROR )
	{
		unsigned long uReturned = 0;
		CVARIANT vDriver, vLow, vHigh;
        IWbemClassObject * pClass = NULL;
    
        //================================================================================
        //  Initialize query for stranded classes as we go along and clean up the old 
        // classes
        //================================================================================
        InitQuery(L"select * from WDMClassesOfDriver where Driver != ");
		while ( TRUE )
		{
    		IWbemClassObject * pClass = NULL;

            if( WBEM_NO_ERROR == (hr = pEnum->Next(2000, 1, &pClass, &uReturned)))
			{
			    if( WBEM_NO_ERROR == (hr = pClass->Get(L"Name", 0, &vDriver, 0, 0)))
				{
					//============================================================
					//  Correct the query syntax for next query
					//============================================================
					UpdateQuery( L" and Driver != ",vDriver.GetStr());
                }
            }

            SAFE_RELEASE_PTR(pClass );
            if( hr != WBEM_NO_ERROR )
			{
                break;
            }
	    }
        //================================================================
        //  Ok, now go after the stranded classes, the ones that don't
        //  have any drivers for some reason
        //================================================================
		CBSTR strQryLang(L"WQL");
		CBSTR cbstr(m_pwcsQuery);

		hr = SERVICES_PTR->ExecQuery(strQryLang,cbstr, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT_PTR,&pEnumofStrandedClasses);
		if( hr == WBEM_NO_ERROR )
		{
			BOOL bDrivers = FALSE;
			while( TRUE )
			{
				if( WBEM_NO_ERROR == (hr = pEnumofStrandedClasses->Next(2000, 1, &pClass, &uReturned)))
				{
					CVARIANT vPath,vClass;
					pClass->Get(L"ClassName", 0, &vClass, 0, 0);
					if(SUCCEEDED(hr = pClass->Get(L"__RELPATH", 0, &vPath, 0, 0)))
					{
						hr = DeleteUnusedClassAndDriverInfo( TRUE, vPath.GetStr(),vClass.GetStr() );
					}
					else
					{
						fRc = FALSE;
						break;
					}
				}
				SAFE_RELEASE_PTR(pClass);
				if( hr != WBEM_NO_ERROR )
				{
					break;
				}
			}
			
			SAFE_RELEASE_PTR(pEnumofStrandedClasses);
			if(!fRc)
			{
				if( hr != E_OUTOFMEMORY)
				{
					ERRORTRACE((THISPROVIDER,"Stranded instance exist in repository"));
				}
			}

		}
	}
    SAFE_RELEASE_PTR(pEnum);
	return fRc;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::DeleteOldDrivers(BOOL fCompareDates)
{
	HRESULT hr = WBEM_E_FAILED;
    IEnumWbemClassObject* pEnum = NULL;
    BOOL fRc = TRUE;
	BSTR strQry = NULL;

	strQry = SysAllocString(m_pwcsQuery);
	if(strQry != NULL)
	{
		CBSTR strQryLang(L"WQL");

		hr = SERVICES_PTR->ExecQuery(strQryLang, strQry, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT_PTR,&pEnum);
		SysFreeString(strQry);
		strQry = NULL;
	}
	else
	{
		hr = E_OUTOFMEMORY;
		fRc = FALSE;
	}
	if( hr == WBEM_NO_ERROR )
    {
		IWbemClassObject * pClass = NULL;
		unsigned long uReturned = 0;
		CVARIANT vClass;
		hr = WBEM_NO_ERROR;

		//============================================================================================
        //  NOTE:  We only deal with drivers extracted from files here, if it is a guid as the result
        //  of an event this is handled elsewhere
		//============================================================================================
		while ( hr == WBEM_NO_ERROR )
        {
			IWbemClassObject * pClass = NULL;
			unsigned long uReturned = 0;

			hr = pEnum->Next(2000, 1, &pClass, &uReturned);
			if( hr == WBEM_NO_ERROR )
            {
				CVARIANT vLowDate, vHighDate, vName;

                if( WBEM_NO_ERROR != (hr = pClass->Get(L"Name", 0, &vName, 0, 0)))
                {
					break;
				}

                if( fCompareDates )
                {
				    vLowDate.SetLONG(0);
				    vHighDate.SetLONG(0);
			
                    if( WBEM_NO_ERROR != (hr = pClass->Get(L"LowDateTime", 0, &vLowDate, 0, 0)))
                    {
    			        break;
				    }

		            if( WBEM_NO_ERROR != (hr = pClass->Get(L"HighDateTime", 0, &vHighDate, 0, 0)))
                    {
				        break;
                    }
                }

				ERRORTRACE((THISPROVIDER,"Deleting Old Drivers"));
				if( DeleteOldClasses((WCHAR *) vName.GetStr(),vLowDate,vHighDate,fCompareDates ))
                {
					CVARIANT vPath;
	
					hr = pClass->Get(L"__RELPATH", 0, &vPath, 0, 0);
					if( hr == WBEM_NO_ERROR )
                    {
						CBSTR cbstrPath(vPath.GetStr());
						hr = SERVICES_PTR->DeleteInstance(cbstrPath,WBEM_FLAG_OWNER_UPDATE,CONTEXT_PTR,NULL);
	           			ERRORTRACE((THISPROVIDER,"We have been requested to delete this mof, it is being removed\n"));
						TranslateAndLog(cbstrPath);

					}
					if( WBEM_NO_ERROR == hr )
                    {
						m_pObj->DeleteMofFromRegistry((WCHAR *) vName.GetStr());
					}
					else
					{
						ERRORTRACE((THISPROVIDER,"Stranded instance: \n"));
                        TranslateAndLog(vPath.GetStr());

               			ERRORTRACE((THISPROVIDER,"DeleteInstance return value: %ld\n",hr));

						ERRORTRACE((THISPROVIDER,"Current query: \n"));
                        TranslateAndLog(m_pwcsQuery);
					}
                }
			}
		}
        SAFE_RELEASE_PTR(pEnum);
	}
	else
	{
		ERRORTRACE((THISPROVIDER,"Cannot delete driver. ExecQuery return value: %ld\n",hr));
		ERRORTRACE((THISPROVIDER,"Current query: \n"));
        TranslateAndLog(m_pwcsQuery);
	}

    return fRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to delete Old classes for a particular driver
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::DeleteOldClasses(WCHAR * wcsFileName,CVARIANT & vLow, CVARIANT & vHigh, BOOL fCompareDates)
{
    HRESULT hr = WBEM_E_FAILED;
	CAutoWChar wcsTranslatedKey(MAX_PATH*2);
	BOOL fRc = FALSE;
    IEnumWbemClassObject* pEnum = NULL;
    ULONG lHighDateTime = 0L;
    ULONG lLowDateTime = 0L;

	ERRORTRACE((THISPROVIDER,"Deleting Old Classes for Driver"));
	TranslateAndLog(wcsFileName);
	ERRORTRACE((THISPROVIDER,"*******\n"));
		
	if( wcsTranslatedKey.Valid() )
	{
		//================================================================================
		//  Initialize everything we need to construct the query
		//================================================================================
		if( fCompareDates )
		{
			lLowDateTime= (ULONG)vLow.GetLONG();
			lHighDateTime= (ULONG)vHigh.GetLONG();
		}

		ConvertStringToCTypeString( wcsTranslatedKey,wcsFileName );
		//================================================================================
		//  Now, pick up all the old classes for this driver
		//================================================================================
		InitQuery(L"select * from WDMClassesOfDriver where Driver = ");
		UpdateQuery(L"",wcsFileName);
		UpdateQuery(L" and (HighDateTime != ",lHighDateTime);
		UpdateQuery(L" or LowDateTime != ", lLowDateTime);
		AddToQuery(L")");

		BSTR strTmp = NULL;
		strTmp = SysAllocString(m_pwcsQuery);
		if(strTmp != NULL)
		{
			CBSTR strQryLang(L"WQL");

			hr = SERVICES_PTR->ExecQuery(strQryLang, strTmp, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT_PTR,&pEnum);
			SysFreeString(strTmp);
			strTmp = NULL;
		}
		else
		{
			hr = E_OUTOFMEMORY;
			fRc = FALSE;
		}

		if( hr == WBEM_NO_ERROR )
		{
			IWbemClassObject * pClass = NULL;
			unsigned long uReturned = 0;
			CVARIANT vClass;
			CAutoWChar wcsObjectPath(MAX_PATH*4);

			if( wcsObjectPath.Valid() )
			{
				while ( TRUE )
				{
					hr = pEnum->Next(2000, 1, &pClass, &uReturned);
					if( hr!= WBEM_NO_ERROR )
					{
						break;
					}

					hr = pClass->Get(L"ClassName", 0, &vClass, 0, 0);
					if( hr != WBEM_NO_ERROR )
					{
						break;
					}
					//===========================================================================
					//  Now, get this instance of tying the class with this  old date
					//===========================================================================
					CVARIANT vPath;
					hr = pClass->Get(L"__RELPATH", 0, &vPath, 0, 0);
					if( hr != WBEM_NO_ERROR )
					{
						break;
					}
					//==========================================================================
					//  Now, just because we get a class name here doesn't mean we delete the
					//  class, this class could have been updated, in that case we just delete
					//  the instance of the WDMClassesOfDriver.
					//  Now, we need to check to see if this class really needs to be deleted
					//  or not
					//==========================================================================
					IWbemClassObject * pTmp = NULL;
					CBSTR bTmp = vClass.GetStr();
					swprintf(wcsObjectPath,L"WDMClassesOfDriver.ClassName=\"%s\",Driver=\"%s\",HighDateTime=%lu,LowDateTime=%lu",bTmp,wcsTranslatedKey,lHighDateTime,lLowDateTime);
					CBSTR bstrQuery = wcsObjectPath;
					hr = SERVICES_PTR->GetObject(bstrQuery,0,CONTEXT_PTR,&pTmp,NULL);
					//===========================================================================
					//  this is simple, if we get an instance of WDMClassesOfDriver
					//  with the newer date, then we know it has been updated, so we don't
					//  delete the class
					//===========================================================================
					BOOL fDeleteOldClass = TRUE;
    				if( hr == WBEM_NO_ERROR )
					{
						fDeleteOldClass = FALSE;
					}

					hr = DeleteUnusedClassAndDriverInfo( fDeleteOldClass, vPath.GetStr(),vClass.GetStr() );
					//===========================================================================
					// Now, delete the WDM Instance of the Old Driver
					//===========================================================================
					SAFE_RELEASE_PTR( pTmp )
					SAFE_RELEASE_PTR( pClass );
					vClass.Clear();
				}

				SAFE_RELEASE_PTR(pEnum);
			}

		}
	
		if( hr == WBEM_NO_ERROR || hr == WBEM_S_NO_MORE_DATA || hr == WBEM_S_FALSE)
		{
			fRc = TRUE;
		}

	}
	return fRc;
}


/////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::CreateInstance ( WCHAR * wcsDriver, WCHAR * wcsClass, ULONG lLowDateTime, ULONG lHighDateTime )
{
	IWbemClassObject * pInst = NULL, * pClass = NULL;

	//==================================================
	//  Get a pointer to a IWbemClassObject object
	//==================================================
    HRESULT hr;
    CVARIANT cvarName;
    cvarName.SetStr(L"WDMClassesOfDriver");

	hr = SERVICES_PTR->GetObject(cvarName, 0,CONTEXT_PTR, &pClass, NULL);		
	if(FAILED(hr)){
		return FALSE;
	}

   	//=============================================================
	//  Spawn a new instance
	//=============================================================
	hr = pClass->SpawnInstance(0, &pInst);
	
    SAFE_RELEASE_PTR(pClass);
    if( FAILED(hr) ){
		return hr;
	}

   	//=============================================================
	//  Put the data in the instance
	//=============================================================
    CVARIANT vClass, vDriver, vLow, vHigh;

	vClass.SetStr(wcsClass);
	vDriver.SetStr(wcsDriver);
	vLow.SetLONG(lLowDateTime);
    vHigh.SetLONG(lHighDateTime);

    hr = pInst->Put(L"Driver", 0, &vDriver, NULL);
    if( hr == WBEM_S_NO_ERROR )
	{
	    hr = pInst->Put(L"ClassName", 0, &vClass, NULL);

	    hr = pInst->Put(L"LowDateTime", 0, &vLow, NULL);

		hr = pInst->Put(L"HighDateTime", 0, &vHigh, NULL);
	    if( hr == WBEM_S_NO_ERROR )
		{
		    hr = SERVICES_PTR->PutInstance(pInst,WBEM_FLAG_OWNER_UPDATE,CONTEXT_PTR,NULL);
		}
	}

    SAFE_RELEASE_PTR(pInst);
    if( WBEM_NO_ERROR == hr ){
        return TRUE;
    }
    return FALSE;

}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::CreateClassAssociationsToDriver(WCHAR * wcsFileName, BYTE* pRes, ULONG lLowDateTime, ULONG lHighDateTime)
{

    CBMOFObjList * pol;
    CBMOFObj * po;
    CAnsiUnicode XLate;

	//===========================================================================
    // Now use the helper functions from David's mofcomp stuff to extract the
	// class names we are going to add the Driver qualifier to.
    // list structure and use it to enumerate the objects.
	//===========================================================================
	BYTE * pByte = m_pObj->DecompressBinaryMof(pRes);
	if( pByte ){
		pol = CreateObjList(pByte);
		if(pol != NULL){
			ResetObjList (pol);
		    while(po = NextObj(pol)){
			    WCHAR * pName = NULL;
				if(GetName(po, &pName)){
					//===============================================================		
					//  Now, we have the name of the class in pName, we have the
					//  name of the driver, in wcsFileName
					//===============================================================		
					CreateInstance(wcsFileName, pName, lLowDateTime, lHighDateTime );
					BMOFFree(pName);
				}
				BMOFFree(po);
			}	
		    BMOFFree(pol);
		}
	}
	else{
		ERRORTRACE((THISPROVIDER,"Could not tie classes to driver for file:\n"));
        TranslateAndLog(wcsFileName);
	}
	if( pByte ){
		free(pByte);
	}

}
/////////////////////////////////////////////////////////////////////
HRESULT CNamespaceManagement::AllocMemory(WCHAR *& p)
{
    HRESULT hr = WBEM_E_FAILED;

    p = new WCHAR[m_nSize+4];
    if( p )
    {
        memset(p,NULL,m_nSize+4);
        hr = WBEM_NO_ERROR;
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::AddToQuery(WCHAR * p)
{
    int nNewSize = wcslen(p) * sizeof(WCHAR);
    int nCurrentBuf = 0;
    if( m_pwcsQuery )
    {
        nCurrentBuf = (int)(wcslen(m_pwcsQuery) + 1) * sizeof(WCHAR);
    }

    if( nNewSize >= (m_nSize - nCurrentBuf))
	{
	    int nOldSize = m_nSize;
        WCHAR * pOld = m_pwcsQuery;
        m_nSize += MEMSIZETOALLOCATE;

        if( SUCCEEDED(AllocMemory(m_pwcsQuery)))
		{
            memcpy(m_pwcsQuery,pOld,nOldSize);
        }
		SAFE_DELETE_ARRAY(pOld);
	}
    if( wcslen(m_pwcsQuery) == 0 )
	{
        wcscpy(m_pwcsQuery,p);
    }
    else
	{
        wcscat(m_pwcsQuery,p);
    }
}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::InitQuery(WCHAR * p)
{
    SAFE_DELETE_ARRAY(m_pwcsQuery);
    m_nSize = MEMSIZETOALLOCATE;
    m_fInit = TRUE;
    if(SUCCEEDED(AllocMemory(m_pwcsQuery)))
	{
        AddToQuery(p);
    }
}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::UpdateQuery( WCHAR * pQueryAddOn, WCHAR * wcsParam )
{
    CAutoWChar wcsTranslatedKey(MAX_PATH*3);
	if( wcsTranslatedKey.Valid() )
	{
		ConvertStringToCTypeString( wcsTranslatedKey,wcsParam );

		//=============================================
		// The first time only we DON'T add the query
		// add on string, otherwise, we do
		//=============================================
		if( !m_fInit )
		{
			AddToQuery(pQueryAddOn);
		}

		AddToQuery(L"\"");
		AddToQuery(wcsTranslatedKey);
		AddToQuery(L"\"");

		m_fInit = FALSE;
	}
}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::SaveCurrentQuery()
{
	m_nSavedSize = m_nSize;
    m_fSavedInit = m_fInit;
    if( SUCCEEDED(AllocMemory(m_pwcsSavedQuery))){
        memcpy(m_pwcsSavedQuery,m_pwcsQuery,m_nSize);
    }
    SAFE_DELETE_ARRAY(m_pwcsQuery);
}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::RestoreQuery()
{
    SAFE_DELETE_ARRAY(m_pwcsQuery);
	m_nSize = m_nSavedSize;
    m_fInit = m_fSavedInit;

    if( SUCCEEDED(AllocMemory(m_pwcsQuery))){
        memcpy(m_pwcsQuery, m_pwcsSavedQuery,m_nSize);
    }

    m_fSavedInit = 0;
    m_nSavedSize = 0;
    SAFE_DELETE_ARRAY(m_pwcsSavedQuery);
}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::UpdateQuery( WCHAR * pQueryAddOn, ULONG lLong )
{
    CAutoWChar wcsBuf(MAX_PATH);

	if( wcsBuf.Valid() )
	{
		AddToQuery(pQueryAddOn);
 		swprintf(wcsBuf,L"%lu",lLong);

		AddToQuery(wcsBuf);
		m_fInit = FALSE;
	}
}
/////////////////////////////////////////////////////////////////////
HRESULT CNamespaceManagement::DeleteUnusedClassAndDriverInfo(BOOL fDeleteOldClass, WCHAR * wcsPath, WCHAR * wcsClass)
{
	HRESULT	hr = WBEM_NO_ERROR;

	if( fDeleteOldClass )
	{
		CBSTR bstr(wcsClass );

		hr = SERVICES_PTR->DeleteClass(bstr,WBEM_FLAG_OWNER_UPDATE,CONTEXT_PTR,NULL);
		if( hr != WBEM_NO_ERROR )
		{
			if( WBEM_E_NOT_FOUND != hr )
			{
    			ERRORTRACE((THISPROVIDER,"Tried to delete class but couldn't, return code: %ld for class: \n",hr));
				TranslateAndLog(wcsClass);
			}
			else
			{
				hr = WBEM_NO_ERROR;
			}
		}
	}


	if( WBEM_NO_ERROR == hr )
	{
		// Ok, we may or may have not deleted the class, if it was tied to a different driver, we
		// shouldn't have deleted the class, but we want to delete the controlling instance, as
		// that driver is no longer there.
		hr = SERVICES_PTR->DeleteInstance(wcsPath,WBEM_FLAG_OWNER_UPDATE,CONTEXT_PTR,NULL);
		if( WBEM_NO_ERROR != hr )
		{
			if( hr != WBEM_E_NOT_FOUND )
			{
				ERRORTRACE((THISPROVIDER,"DeleteUnUnsedClasses Stranded instance: \n"));
				TranslateAndLog(wcsPath);
           	    ERRORTRACE((THISPROVIDER,"DeleteInstance return value: %ld\n",hr));
			}
			
   		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmi\wmiguid.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    wmiguid.h

Abstract:

    Defines GUIDs that represent data blocks that can be retrieved via WMI

Author:

    Alan Warwick (alanwar) 27-Jun-1997

Revision History:

--*/

#ifndef FAR
#define FAR
#endif

#ifndef DEFINE_GUID
#ifndef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#else // !defined(INITGUID)

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // !defined(INITGUID)
#endif // !defined(DEFINE_GUID)

//
// This is WMI guid used to return disk performance information from 
// diskperf.sys (see DISK_PERFORMANCE data structure)

DEFINE_GUID (DiskPerfGuid, 0xBDD865D1,0xD7C1,0x11d0,0xA5,0x01,0x00,0xA0,0xC9,0x06,0x29,0x10);

DEFINE_GUID ( /* 3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c */
    ProcessGuid,
    0x3d6fa8d0,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d1-fe05-11d0-9dda-00c04fd7ba7c */
    ThreadGuid,
    0x3d6fa8d1,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d2-fe05-11d0-9dda-00c04fd7ba7c */ /* Not used */
    HardFaultGuid,
    0x3d6fa8d2,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d3-fe05-11d0-9dda-00c04fd7ba7c */
    PageFaultGuid,
    0x3d6fa8d3,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d4-fe05-11d0-9dda-00c04fd7ba7c */
    DiskIoGuid,
    0x3d6fa8d4,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 68fdd900-4a3e-11d1-84f4-0000f80464e3 */
    TraceHeaderGuid,
    0x68fdd900,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );
DEFINE_GUID ( /* 90cbdc39-4a3e-11d1-84f4-0000f80464e3 */
    FileIoGuid,
    0x90cbdc39,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmi\wmistr.h ===
/*++                 

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Wmistr.h

Abstract:
    
    WMI structure definitions

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#ifndef _WMISTR_
#define _WMISTR_

//
// WNODE definition
typedef struct _WNODE_HEADER
{
    ULONG BufferSize;        // Size of entire buffer inclusive of this ULONG
    ULONG ProviderId;        // Provider Id of driver returning this buffer
    ULONG Version;           // Version number of data block
    union
    {
        ULONG Linkage;           // Linkage field reserved for WMI
        ULONG HistoricalContext; // Logger use
    };
    LARGE_INTEGER TimeStamp; // Timestamp as returned in units of 100ns
                             // since 1/1/1601
    GUID Guid;               // Guid for data block returned with results
    ULONG Reserved;          
    ULONG Flags;             // Flags, see below
} WNODE_HEADER, *PWNODE_HEADER;

//
// WNODE_HEADER flags are defined as follows
#define WNODE_FLAG_ALL_DATA        0x00000001 // set for WNODE_ALL_DATA
#define WNODE_FLAG_SINGLE_INSTANCE 0x00000002 // set for WNODE_SINGLE_INSTANCE
#define WNODE_FLAG_SINGLE_ITEM     0x00000004 // set for WNODE_SINGLE_ITEM
#define WNODE_FLAG_EVENT_ITEM      0x00000008 // set for WNODE_EVENT_ITEM

                                              // Set if data block size is 
                                              // identical for all instances 
                                              // (used with  WNODE_ALL_DATA 
                                              // only)
#define WNODE_FLAG_FIXED_INSTANCE_SIZE 0x00000010

#define WNODE_FLAG_TOO_SMALL           0x00000020 // set for WNODE_TOO_SMALL

                                 // Set when a data provider returns a 
                                 // WNODE_ALL_DATA in which the number of 
                                 // instances and their names returned
                                 // are identical to those returned from the 
                                 // previous WNODE_ALL_DATA query. Only data 
                                 // blocks registered with dynamic instance
                                 // names should use this flag.
#define WNODE_FLAG_INSTANCES_SAME  0x00000040

                                 // Instance names are not specified in 
                                 // WNODE_ALL_DATA; values specified at 
                                 // registration are used instead. Always 
                                 // set for guids registered with static 
                                 // instance names
#define WNODE_FLAG_STATIC_INSTANCE_NAMES 0x00000080

#define WNODE_FLAG_INTERNAL      0x00000100  // Used internally by WMI

                                 // timestamp should not be modified by
                                 // a historical logger
#define WNODE_FLAG_USE_TIMESTAMP 0x00000200

#define WNODE_FLAG_TRACED_GUID   0x00000400
                                 
#define WNODE_FLAG_TRACE_KERNEL  0x00000800 // Used to trace kernel

#define WNODE_FLAG_TRACE_EXTENDED 0x00001000 // Trace in extended mode

// Set for events that are WNODE_EVENT_REFERENCE
#define WNODE_FLAG_EVENT_REFERENCE 0x00002000

// Set if Instance names are ansi. Only set when returning from 
// WMIQuerySingleInstanceA and WMIQueryAllDataA
#define WNODE_FLAG_ANSI_INSTANCENAMES 0x00004000

// Set if WNODE is a method call
#define WNODE_FLAG_METHOD_ITEM     0x00008000

// Set if instance names originated from a PDO
#define WNODE_FLAG_PDO_INSTANCE_NAMES  0x00010000

// Mask for event severity level. Level 0xff is the most severe type of event
#define WNODE_FLAG_SEVERITY_MASK 0xff000000

//
// This structure is used within the WNODE_ALL_DATA when the data blocks 
// for the different instances are different lengths. If the data blocks
// for the different instances are identical lengths then 
// WNODE_FLAG_FIXED_INSTANCE_SIZE should be set and FixedInstanceSize
// set to the common data block size.
typedef struct 
{
    ULONG OffsetInstanceData;   // Offset from beginning of WNODE_ALL_DATA
                                // to Data block for instance
    ULONG LengthInstanceData;   // Length of data block for instance
} OFFSETINSTANCEDATAANDLENGTH, *POFFSETINSTANCEDATAANDLENGTH;

typedef struct tagWNODE_ALL_DATA
{
    struct _WNODE_HEADER WnodeHeader;

    ULONG DataBlockOffset;// Offset from begin of WNODE to first data block 
                      
    ULONG InstanceCount;  // Count of instances whose data follows. 

                      // Offset to an array of offsets to the instance names
    ULONG OffsetInstanceNameOffsets;

    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then 
    // FixedInstanceSize specifies the size of each data block. In this case
    // there is one ULONG followed by the data blocks.
    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is not set 
    // then OffsetInstanceDataAndLength
    // is an array of OFFSETINSTANCEDATAANDLENGTH that specifies the 
    // offsets and lengths of the data blocks for each instance. 
    union
    {
        ULONG FixedInstanceSize;
    	OFFSETINSTANCEDATAANDLENGTH OffsetInstanceDataAndLength[];
                                    /* [InstanceCount] */
    };
    
    // padding so that first data block begins on a 8 byte boundry

    // data blocks and instance names for all instances

} WNODE_ALL_DATA, *PWNODE_ALL_DATA;


typedef struct tagWNODE_SINGLE_INSTANCE
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Use when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAMES is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is set
    ULONG InstanceIndex;    // (Static Instance Names)

    ULONG DataBlockOffset;  // offset from beginning of WNODE to data block
    ULONG SizeDataBlock;    // Size of data block for instance

    UCHAR VariableData[];
    // instance names and padding so data block begins on 8 byte boundry

    // data block
} WNODE_SINGLE_INSTANCE, *PWNODE_SINGLE_INSTANCE;


typedef struct tagWNODE_SINGLE_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Examine when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset 
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG ItemId;           // Item Id for data item being set

    ULONG DataBlockOffset;  // offset from WNODE begin to data item value
    ULONG SizeDataItem;     // Size of data item
    
    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_SINGLE_ITEM, *PWNODE_SINGLE_ITEM;

typedef struct tagWNODE_METHOD_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_METHOD_ITEM
                            // to instance name. Examine when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset 
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG MethodId;         // Method id of method being called

    ULONG DataBlockOffset;  // On Entry: offset from WNODE to input data 
                            // On Return: offset from WNODE to input and 
                            //            output data blocks
    ULONG SizeDataBlock;    // On Entry: Size of input data, 0 if no input 
                            //           data
                            // On Return: Size of output data, 0 if no output
                            //            data
    
    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_METHOD_ITEM, *PWNODE_METHOD_ITEM;

typedef struct tagWNODE_EVENT_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

    // Different data could be here depending upon the flags set in the 
    // WNODE_HEADER above. If the WNODE_FLAG_ALL_DATA flag is set then the 
    // contents of a WNODE_ALL_DATA  (excluding WNODE_HEADER) is here. If the
    // WNODE_FLAG_SINGLE_INSTANCE flag is set then a WNODE_SINGLE_INSTANCE
    // (excluding WNODE_HEADER) is here. Lastly if the  WNODE_FLAG_SINGLE_ITEM
    // flag is set then a WNODE_SINGLE_ITEM (excluding WNODE_HEADER) is here.
} WNODE_EVENT_ITEM, *PWNODE_EVENT_ITEM;


//
// If a KM data provider needs to fire an event that is larger than the
// maximum size that WMI allows then it should fire a WNODE_EVENT_REFERENCE
// that specifies which guid and instance name to query for the actual data
// that should be part of the event.
typedef struct tagWNODE_EVENT_REFERENCE
{
    struct _WNODE_HEADER WnodeHeader;
    GUID TargetGuid;
    ULONG TargetDataBlockSize;
    union
    {
        ULONG TargetInstanceIndex;
        WCHAR TargetInstanceName[];
    };
} WNODE_EVENT_REFERENCE, *PWNODE_EVENT_REFERENCE;


typedef struct tagWNODE_TOO_SMALL
{
    struct _WNODE_HEADER WnodeHeader;
    ULONG SizeNeeded;                   // Size needed to build WNODE result
} WNODE_TOO_SMALL, *PWNODE_TOO_SMALL;


//
// Registration data structure definitions
typedef struct
{
    ULONG ProviderId; // Provider id (or device object pointer) of the data 
                      // provider whose instance names are to be copied.
    GUID Guid;        // Guid of data block provided by ProviderId whose 
                      // instance names are copied.
} WMIREGINSTANCEREF, *PWMIREGINSTANCEREF;

typedef struct
{
    GUID Guid;             // Guid of data block being registered or updated
    ULONG Flags;         // Flags

    ULONG InstanceCount; // Count of static instances names for the guid

    ULONG InstanceInfo;// Offset from beginning of the WMIREGINFO structure to
                     // more information about the static instance names being
                     // registered.
			     
                     // If WMIREG_FLAG_INSTANCE_LIST then this points to a
                     // list of InstanceCount counted UNICODE
                     // strings placed end to end.
			     
                     // If WMIREG_FLAG_INSTANCE_BASENAME then this points to a
                     // single counted UNICODE string that
                     // has the basename for the instance names.
                     // If WMIREG_FLAG_INSTANCE_REFERENCE then this points to 
                     // a WMIREGINSTANCEREF structure.
			     
                     // If WMIREG_FLAG_INSTANCE_PDO is set then InstanceInfo
                     // has the PDO whose device instance path will 
                     // become the instance name

} WMIREGGUIDW, *PWMIREGGUIDW;

typedef WMIREGGUIDW WMIREGGUID;
typedef PWMIREGGUIDW PWMIREGGUID;

// Set if collection must be enabled for the guid before the data provider
// can be queried for data.
#define WMIREG_FLAG_EXPENSIVE          0x00000001 

// Set if instance names for this guid are specified in a static list within
// the WMIREGINFO
#define WMIREG_FLAG_INSTANCE_LIST      0x00000004

// Set if instance names are to be static and generated by WMI using a 
// base name in the WMIREGINFO and an index
#define WMIREG_FLAG_INSTANCE_BASENAME  0x00000008

// Set if static instance names are taken by reference to another data 
// provider. This flag should only be used by kernel mode data providers.
#define WMIREG_FLAG_INSTANCE_REFERENCE 0x00000010
                                                  
							  
// Set if WMI should do automatic mapping of a PDO to device instance name
// as the instance name for the guid. This flag should only be used by
// kernel mode data providers.
#define WMIREG_FLAG_INSTANCE_PDO       0x00000020 
                                                    
// Note the flags WMIREG_FLAG_INSTANCE_LIST, WMIREG_FLAG_INSTANCE_BASENAME,
// WMIREG_FLAG_INSTANCE_REFERENCE and WMIREG_FLAG_INSTANCE_PDO are mutually
// exclusive.

//
// These flags are only valid in a response to WMI_GUID_REGUPDATE
#define WMIREG_FLAG_REMOVE_GUID       0x00010000 // Remove support for  guid
#define WMIREG_FLAG_ADD_GUID          0x00020000 // Add support for guid
#define WMIREG_FLAG_MODIFY_GUID       0x00040000 // Modify support for guid

// Set if guid is one that is written to trace log. WMI will send 
// ENABLE/DISABLE Collection to indicate whento start/stop trace logging. 
// This guid cannot be queried directly via WMI, but must be read using 
// logger apis.
#define WMIREG_FLAG_TRACED_GUID        0x00080000 

//
// Set if the guid is only used for firing events. Guids that can be queried
// and that fire events should not have this bit set.
#define WMIREG_FLAG_EVENT_ONLY_GUID    0x00000040

typedef struct
{
// Size of entire WMIREGINFO structure including this ULONG 	
// and any static instance names that follow
    ULONG BufferSize;

    ULONG NextWmiRegInfo;         // Offset to next WMIREGINFO structure

    ULONG RegistryPath; // Offset from beginning of WMIREGINFO structure to a 
                        // counted Unicode string containing
                        // the driver registry path (under HKLM\CCS\Services)
                        // This must be filled only by kernel mode data 
						// providers
							
// Offset from beginning of WMIREGINFO structure to a
// counted Unicode string containing
// the name of resource in driver file containing MOF info
    ULONG MofResourceName;

// Count of WMIREGGUID structures immediately following
    ULONG GuidCount;
    WMIREGGUIDW WmiRegGuid[];  // array of GuidCount WMIREGGUID structures
    // Variable length data including :
    //     Instance Names
} WMIREGINFOW, *PWMIREGINFOW;

typedef WMIREGINFOW WMIREGINFO;
typedef PWMIREGINFOW PWMIREGINFO;

//
// WMI request codes
typedef enum
{
#ifndef _WMIKM_
    WMI_GET_ALL_DATA = 0,
    WMI_GET_SINGLE_INSTANCE = 1,
    WMI_SET_SINGLE_INSTANCE = 2,
    WMI_SET_SINGLE_ITEM = 3,
    WMI_ENABLE_EVENTS = 4,
    WMI_DISABLE_EVENTS  = 5,
    WMI_ENABLE_COLLECTION = 6,
    WMI_DISABLE_COLLECTION = 7,
    WMI_REGINFO = 8,
    WMI_EXECUTE_METHOD = 9
#endif    
} WMIDPREQUESTCODE;

#if defined(_WINNT_) || defined(WINNT)
//
// WMI guid objects have the following rights
// WMIGUID_QUERY
// WMIGUID_SET
// WMIGUID_NOTIFICATION
// WMIGUID_READ_DESCRIPTION
// WMIGUID_EXECUTE
// TRACELOG_CREATE_REALTIME
// TRACELOG_CREATE_ONDISK
// TRACELOG_GUID_ENABLE
// TRACELOG_ACCESS_KERNEL_LOGGER

#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100

#define WMIGUID_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |     \
                            WMIGUID_QUERY |                \
                            WMIGUID_SET |                  \
                            WMIGUID_NOTIFICATION |         \
                            WMIGUID_READ_DESCRIPTION |     \
                            WMIGUID_EXECUTE |              \
                            TRACELOG_CREATE_REALTIME |     \
                            TRACELOG_CREATE_ONDISK |       \
                            TRACELOG_GUID_ENABLE |         \
                            TRACELOG_ACCESS_KERNEL_LOGGER)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmi\wmium.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Wmium.h

Abstract:

    Public headers for WMI data consumers and providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#ifndef _WMIUM_
#define _WMIUM_

#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif
#endif

#include <guiddef.h>

#include <basetsd.h>
#include <wmistr.h>

typedef PVOID WMIHANDLE, *PWMIHANDLE, MOFHANDLE, *PMOFHANDLE;


//
// When set the guid can be opened and accessed
#define MOFCI_RESERVED0  0x00000001

#define MOFCI_RESERVED1  0x00000002
#define MOFCI_RESERVED2  0x00000004

typedef struct
{
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ImagePath;        // Path to image containing MOF resource
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
#ifdef MIDL_PASS
    [size_is(0)] PDFBYTE
#else
    PUCHAR
#endif
             ResourceBuffer;    // Reserved
} MOFRESOURCEINFOW, *PMOFRESOURCEINFOW;


typedef struct
{
    LPSTR
             ImagePath;        // Path to image containing MOF resource
    LPSTR
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
    UCHAR
             *ResourceBuffer;   // Reserved
} MOFRESOURCEINFOA, *PMOFRESOURCEINFOA;

#ifdef UNICODE
typedef MOFRESOURCEINFOW MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOW PMOFRESOURCEINFO;
#else
typedef MOFRESOURCEINFOA MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOA PMOFRESOURCEINFO;
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Data consumer apis
ULONG
WMIAPI
WmiOpenBlock(
    IN GUID *Guid,
    IN ULONG DesiredAccess,
    OUT WMIHANDLE *DataBlockHandle
);

ULONG
WMIAPI
WmiCloseBlock(
    IN WMIHANDLE DataBlockHandle
);

ULONG
WMIAPI
WmiQueryAllDataA(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );


ULONG
WMIAPI
WmiQueryAllDataW(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

#ifdef UNICODE
#define WmiQueryAllData WmiQueryAllDataW
#else
#define WmiQueryAllData WmiQueryAllDataA
#endif


ULONG
WMIAPI
WmiQueryAllDataMultipleA(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQueryAllDataMultipleW(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);
#ifdef UNICODE
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleW
#else
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

ULONG
WMIAPI
WmiQuerySingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );
#ifdef UNICODE
#define WmiQuerySingleInstance WmiQuerySingleInstanceW
#else
#define WmiQuerySingleInstance WmiQuerySingleInstanceA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceMultipleW(
    IN WMIHANDLE *HandleList,
    IN PWCHAR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQuerySingleInstanceMultipleA(
    IN WMIHANDLE *HandleList,
    IN PCHAR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

#ifdef UNICODE
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleW
#else
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleA
#endif

ULONG
WMIAPI
WmiSetSingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleInstance WmiSetSingleInstanceW
#else
#define WmiSetSingleInstance WmiSetSingleInstanceA
#endif

ULONG
WMIAPI
WmiSetSingleItemA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleItemW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleItem WmiSetSingleItemW
#else
#define WmiSetSingleItem WmiSetSingleItemA
#endif

ULONG
WMIAPI
WmiExecuteMethodA(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

ULONG
WMIAPI
WmiExecuteMethodW(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCWSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

#ifdef UNICODE
#define WmiExecuteMethod WmiExecuteMethodW
#else
#define WmiExecuteMethod WmiExecuteMethodA
#endif

// Set this Flag when calling NotficationRegistration to enable or
// disable a trace logging guid
#define NOTIFICATION_TRACE_FLAG       0x00010000

// Set this flag when enabling a notification that should be delivered via
// a direct callback. Any notifications received will be given their own
// thread and the callback function called immediately.
#define NOTIFICATION_CALLBACK_DIRECT  0x00000004

//
// Set this flag (and only this flag) when you want to only check if the 
// caller has permission to receive events for the guid
//
#define NOTIFICATION_CHECK_ACCESS 0x00000008

//
// Event notification callback function prototype
typedef void (
#ifndef MIDL_PASS
WINAPI
#endif
*NOTIFICATIONCALLBACK)(
    PWNODE_HEADER Wnode,
    UINT_PTR NotificationContext
    );

#ifndef MIDL_PASS
//
// This guid is for notifications of changes to registration
// {B48D49A1-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_REGISTRATION_CHANGE_NOTIFICATION,
0xb48d49a1, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A2-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_ADDED_NOTIFICATION,
0xb48d49a2, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A3-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_REMOVED_NOTIFICATION,
0xb48d49a3, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);
#endif

ULONG
WMIAPI
WmiNotificationRegistrationA(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );

ULONG
WMIAPI
WmiNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );
#ifdef UNICODE
#define WmiNotificationRegistration WmiNotificationRegistrationW
#else
#define WmiNotificationRegistration WmiNotificationRegistrationA
#endif

void
WMIAPI
WmiFreeBuffer(
    IN PVOID Buffer
    );


ULONG
WMIAPI
WmiEnumerateGuids(
    OUT LPGUID GuidList,
    IN OUT ULONG *GuidCount
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesW(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOW *MofResourceInfo
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesA(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOA *MofResourceInfo
    );
#ifdef UNICODE
#define WmiMofEnumerateResources WmiMofEnumerateResourcesW
#else
#define WmiMofEnumerateResources WmiMofEnumerateResourcesA
#endif

ULONG
WMIAPI
WmiFileHandleToInstanceNameA(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT CHAR *InstanceNames
    );

ULONG
WMIAPI
WmiFileHandleToInstanceNameW(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT WCHAR *InstanceNames
    );
#ifdef UNICODE
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameW
#else
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameA
#endif

#define WmiInsertTimestamp(WnodeHeader) \
    GetSystemTimeAsFileTime((FILETIME *)&((PWNODE_HEADER)WnodeHeader)->TimeStamp)

ULONG
WMIAPI
WmiDevInstToInstanceNameA(
    OUT CHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN CHAR *DevInst,
    IN ULONG InstanceIndex
    );

ULONG
WMIAPI
WmiDevInstToInstanceNameW(
    OUT WCHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN WCHAR *DevInst,
    IN ULONG InstanceIndex
    );
#ifdef UNICODE
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameW
#else
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameA
#endif

typedef struct _WMIGUIDINFORMATION
{
    ULONG Size;
    BOOLEAN IsExpensive;
    BOOLEAN IsEventOnly;
} WMIGUIDINFORMATION, *PWMIGUIDINFORMATION;


ULONG
WMIAPI
WmiQueryGuidInformation(
    IN WMIHANDLE GuidHandle,
    OUT PWMIGUIDINFORMATION GuidInfo
    );

#ifdef __cplusplus
}
#endif

#endif  // _WMIUM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\wmi\wmiumkm.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    wmiumkm.h

Abstract:

    Private definitions for WMI communications between user and kernel modes

Author:

    AlanWar

Environment:

    Kernel and User modes

Revision History:


--*/

#ifndef _WMIUMKM_
#define _WMIUMKM_

//
// This defines the guid under which the default WMI security descriptor
// is maintained.
DEFINE_GUID(DefaultSecurityGuid, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#define DefaultSecurityGuidName L"00000000-0000-0000-0000000000000000"

#ifndef _WMIKM_


//
// This defines the codes used to define what a request must do. These
// definitions must match the same in wmium.h
//

typedef enum tagWMIACTIONCODE
{
    WmiGetAllData = 0,
    WmiGetSingleInstance = 1,
    WmiChangeSingleInstance = 2,
    WmiChangeSingleItem = 3,
    WmiEnableEvents = 4,
    WmiDisableEvents  = 5,
    WmiEnableCollection = 6,
    WmiDisableCollection = 7,
    WmiRegisterInfo = 8,
    WmiExecuteMethodCall = 9
} WMIACTIONCODE;

#endif

#if defined(_WINNT_) || defined(WINNT)

typedef enum
{
    WmiStartLoggerCode = 32,
    WmiStopLoggerCode = 33,
    WmiQueryLoggerCode = 34,
    WmiTraceEventCode = 35,
    WmiUpdateLoggerCode = 36
} WMITRACECODE;
#endif

typedef enum
{
    WmiReadNotifications = 64,
    WmiGetNextRegistrant = 65,
    WmiOpenGuid = 66,
    WmiNotifyUser = 67,
    WmiGetAllRegistrant = 68,
    WmiGenerateEvent = 69,
    WmiAllocInstanceIdForGuid = 70,
    WmiTranslateFileHandle = 71,
    WmiGetVersion = 73
} WMISERVICECODES;

//
// This defines the name of the WMI device that manages service IOCTLS
#define WMIServiceDeviceObjectName       L"\\Device\\WMIServiceDevice"
#define WMIServiceDeviceName TEXT("\\\\.\\WMIServiceDevice")
#define WMIServiceSymbolicLinkName TEXT("\\DosDevices\\WMIServiceDevice")

#ifdef MEMPHIS
//
// This id the name of the device that handles query/set IOCTLS. On memphis
// it is the same as the service device name.
#define WMIDataDeviceObjectName       L"\\Device\\WMIDevice"
#define WMIDataDeviceName TEXT("\\\\.\\WMIServiceDevice")
#define WMIDataSymbolicLinkName TEXT("\\DosDevices\\WMIServiceDevice")
#else
//
// This id the name of the device that handles query/set IOCTLS. On NT it is
// a different device name than the service device. On NT the service
// device is an exclusive access device that can only be opened by the
// wmi service.
#define WMIDataDeviceObjectName       L"\\Device\\WMIDataDevice"
#define WMIDataDeviceName TEXT("\\\\.\\WMIDataDevice")
#define WMIDataSymbolicLinkName TEXT("\\DosDevices\\WMIDataDevice")
#endif

//
// This IOCTL will return when a KM notification has been generated that
// requires user mode attention.
//   BufferIn - Not used
//   BufferOut - Buffer to return notification information
#define IOCTL_WMI_READ_NOTIFICATIONS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiReadNotifications, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return with the next set of unprocessed registration info
// BufferIn - Not used
// BufferOut - Buffer to return registration information
#define IOCTL_WMI_GET_NEXT_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetNextRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return a handle to a guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_OPEN_GUID \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiOpenGuid, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will perform a query for all data items of a data block
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_ALL_DATA \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllData, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will query for a single instance
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetSingleInstance, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will set a single instance
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleInstance, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will set a single item
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_ITEM \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleItem, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable an event
// BufferIn - Incoming WNODE event item to enable
#define IOCTL_WMI_ENABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable an event
// BufferIn - Incoming WNODE event item to disable
#define IOCTL_WMI_DISABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable collection
// BufferIn - Incoming WNODE describing what to enable for collection
#define IOCTL_WMI_ENABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable collection
// BufferIn - Incoming WNODE describing what to disable for collection
#define IOCTL_WMI_DISABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will return the registration information for a specific provider
// BufferIn - Provider handle
// BufferOut - Buffer to return WMI information
#define IOCTL_WMI_GET_REGINFO \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiRegisterInfo, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will execute a method on a device
// BufferIn - WNODE_METHOD_ITEM
// BufferOut - WNODE_METHOD_ITEM
#define IOCTL_WMI_EXECUTE_METHOD \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiExecuteMethodCall, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will cause a registration notification to be generated
// BufferIn - Not used
// BufferOut - Not used
#define IOCTL_WMI_NOTIFY_USER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiNotifyUser, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will return with the all registration info
// BufferIn - Not used
// BufferOut - Buffer to return all registration information
#define IOCTL_WMI_GET_ALL_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will cause certain data providers to generate events
// BufferIn - WnodeEventItem to use in firing event
// BufferOut - Not Used
#define IOCTL_WMI_GENERATE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGenerateEvent, METHOD_BUFFERED, FILE_WRITE_ACCESS)


// This IOCTL will allocate a range of instance ids for a specific guid
// BufferIn - incoming WMIALLOCINSTID structure
// BufferOut - outgoing WMIALLOCINSTID structure
#define IOCTL_WMI_ALLOCATE_INSTANCE_IDS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiAllocInstanceIdForGuid, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will translate a File Object into a device object
// BufferIn - pointer to incoming WMIFILETODEVICE structure
// BufferOut - outgoing WMIFILETODEVICE structure
#define IOCTL_WMI_TRANSLATE_FILE_HANDLE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTranslateFileHandle, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will check if the caller has desired access to the guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_CHECK_ACCESS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiCheckAccess, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will determine the version of WMI
// BufferIn - Not used
// BufferOut - WMIVERSIONINFO
#define IOCTL_WMI_GET_VERSION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetVersion, METHOD_BUFFERED, FILE_READ_ACCESS)


#if defined(_WINNT_) || defined(WINNT)
//
// This IOCTL will start an instance of a logger
// BufferIn - Logger configuration information
// BufferOut - Updated logger information when logger is started
#define IOCTL_WMI_START_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStartLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will stop an instance of a logger
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information when logger is stopped
#define IOCTL_WMI_STOP_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStopLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will update an existing logger attributes
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_UPDATE_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiUpdateLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will query a logger for its information
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_QUERY_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQueryLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will synchronize a trace record to the logger
// BufferIn - Trace record, with handle set
// BufferOut - Not used
#define IOCTL_WMI_TRACE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTraceEventCode, METHOD_NEITHER, FILE_WRITE_ACCESS)

#endif // WINNT

//
// Notifications from kernel mode WMI to user mode WMI
typedef enum
{
    RegistrationAdd,		// A new data provider is being registered
    RegistrationDelete,		// A data provider is being removed
    RegistrationUpdate,		// A data provider is being updated
    EventNotification,      // An event is fired by a data provider
    RegChangeNotification
} NOTIFICATIONTYPES;


//
// This defines the maximum number of kernel mode data providers
#define MAXKMREGISTRANTS 32


//
// This is used in IOCTL_WMI_GET_ALL_REGISTRANT to report the list of
// registered KM data providers to the WMI service
typedef struct
{
    OUT UINT_PTR ProviderId;	// Provider Id (or device object pointer)
    OUT ULONG Flags;			// REGENTRY_FLAG_*
} KMREGINFO, *PKMREGINFO;

#define REGENTRY_FLAG_NEWREGINFO 0x00000004   // Entry has new registration info
#define REGENTRY_FLAG_UPDREGINFO 0x00000008   // Entry has updated registration info


//
// This structure is used in IOCTL_WMI_ALLOCATE_INSTANCE_IDS
typedef struct
{
    IN GUID Guid;              // Guid whose instance ids are allocated for
    IN ULONG InstanceCount;    // Number of instance ids to allocate
    OUT ULONG FirstInstanceId; // First instance id for guid
} WMIALLOCINSTID, *PWMIALLOCINSTID;

//
// This structure is used in IOCTL_WMI_TRANSLATE_FILE_HANDLE
typedef struct
{
    union
    {
        IN HANDLE FileHandle;      // File handle whose instance name is needed
        OUT ULONG SizeNeeded;      // If incoming buffer too small then this
                                   // returns with number bytes needed.
    };
    OUT USHORT InstanceNameLength; // Length of instance name in bytes
    OUT WCHAR InstanceNameBase[];  // Instance name in unicode
} WMIFHTOINSTANCENAME, *PWMIFHTOINSTANCENAME;


//
// This is used in IOCTL_WMI_OPEN_GUID
typedef struct
{
    IN GUID Guid;
    IN ACCESS_MASK DesiredAccess;
    OUT HANDLE Handle;
} WMIOPENGUIDBLOCK, *PWMIOPENGUIDBLOCK;


//
// This is used to retrieve the internal version of WMI in IOCTL_WMI_GET_VERSION

#define WMI_CURRENT_VERSION 1

typedef struct
{
    ULONG Version;
} WMIVERSIONINFO, *PWMIVERSIONINFO;

#if defined(_WINNT_) || defined(WINNT)
//
// The predefined event groups or families for NT subsystems
//

#define EVENT_TRACE_GROUP_HEADER               0x0000
#define EVENT_TRACE_GROUP_IO                   0x0100
#define EVENT_TRACE_GROUP_MEMORY               0x0200
#define EVENT_TRACE_GROUP_PROCESS              0x0300
#define EVENT_TRACE_GROUP_FILE                 0x0400
#define EVENT_TRACE_GROUP_THREAD               0x0500

//
// see evntrace.h for pre-defined generic event types (0-10)
//

// The actual buffer, the first two DWORDS used for header information
// defined below.

typedef struct _WMI_TRACE_BUFFER {
    WNODE_HEADER Wnode;
    char*   CurrentPointer;    // point to free data space; offset when logged
    ULONG   EventsLost;        // used to count events lost
    char*   Data;              // this is where data is written
} WMI_TRACE_BUFFER, *PWMI_TRACE_BUFFER;

typedef struct _WMI_TRACE_PACKET {   // must be ULONG!!
    USHORT  Size;
    UCHAR   Type;
    UCHAR   Group;
} WMI_TRACE_PACKET, *PWMI_TRACE_PACKET;

//
// Trace header for kernel events -- more compact
//
typedef struct _SYSTEM_TRACE_HEADER {
    union {
        ULONG            Header;    // both sizes must be the same!
        WMI_TRACE_PACKET Packet;
    };
    UINT_PTR        ThreadId;
    LARGE_INTEGER   SystemTime;
    ULONG           KernelTime;
    ULONG           UserTime;
} SYSTEM_TRACE_HEADER, *PSYSTEM_TRACE_HEADER;

#ifndef MEMPHIS
//
// Logger configuration and running statistics. This structure is used
// by WMI.DLL to convert to UNICODE_STRING
//
typedef struct _WMI_LOGGER_INFORMATION {
    WNODE_HEADER Wnode;       // Had to do this since wmium.h comes later
//
// data provider by caller
    ULONG BufferSize;                   // size of a buffer for logging
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size
    ULONG LogFileMode;                  // sequential, circular, or newfile
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG ExtensionFlags;               // kernel subsystem extended mode

// data returned to caller
    ULONG NumberOfBuffers;              // no of buffers in use
    ULONG FreeBuffers;                  // no of buffers free
    ULONG EventsLost;                   // event records lost
    ULONG BuffersWritten;               // no of buffers written to file`
    UINT_PTR LoggerThreadId;            // thread id of Logger
    UNICODE_STRING LogFileName;         // Logfile name

// mandatory data provided by caller
    UNICODE_STRING LoggerName;          // Instance name for logger

    PVOID LoggerExtension;
} WMI_LOGGER_INFORMATION, *PWMI_LOGGER_INFORMATION;
#endif // !MEMPHIS

#endif // WINNT

#endif // _WMIUMKM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\leaktest\bvtmain.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTMain.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//#define _IOSFWD_
//#define _CSTDLIB_
//#define _CSTDIO_

#define DECLARE_GLOBALS

#include <WDMSHELL.h>
#include <wmimof.h>	
#include <wmicom.h>

#include <string.h> 
#include <comdef.h>
#include <vector>

#define DBG_PRINTFA( a ) { char pBuff[256]; sprintf a ; OutputDebugStringA(pBuff); }

////////////////////////////////////////////////////////////////////////
//
//
//  Interceptor
//
//
///////////////////////////////////////////////////////////

#ifdef INSTRUMENTED_BUILD
#ifdef  _X86_

#include <malloc.h>

struct HEAP_ENTRY {
	WORD Size;
	WORD PrevSize;
	BYTE SegmentIndex;
	BYTE Flags;
    BYTE UnusedBytes;
	BYTE SmallTagIndex;
};

#define HEAP_SLOW_FLAGS  0x7d030f60

// only the "header"

typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
} HEAP;

typedef USHORT (__stdcall * fnRtlCaptureStackBackTrace)(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

typedef ULONG (__stdcall * fnRtlRandomEx )(PULONG Seed);

typedef USHORT (__stdcall * fnRtlCaptureStackBackTrace)(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

fnRtlCaptureStackBackTrace RtlCaptureStackBackTrace;
fnRtlRandomEx RtlRandomEx;

BOOL   g_FaultHeapEnabled = FALSE;
BOOL   g_FaultFileEnabled = FALSE;
ULONG g_Seed;
ULONG g_Factor  = 100000;
ULONG g_Percent = 0x20;
//ULONG g_RowOfFailures = 10;
//LONG  g_NumFailInARow = 0;
//LONG  g_NumFailedAllocation = 0;
BOOL g_bDisableBreak = FALSE;

#define SIZE_JUMP_ADR    5
#define SIZE_SAVED_INSTR 12

void
_declspec(naked) Prolog__ReadFile(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
	}
}


BOOL _I_ReadFile(
  HANDLE hFile,               // handle to file
  LPVOID lpBuffer,            // data buffer
  DWORD nNumberOfBytesToRead, // number of bytes to read
  LPDWORD lpNumberOfBytesRead, // number of bytes read  
  LPOVERLAPPED lpOverlapped   // offset
){
	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
	    if (lpNumberOfBytesRead)
	        *lpNumberOfBytesRead = 0;
		return FALSE;
	}    
    
    _asm{
		push lpOverlapped;
        push lpNumberOfBytesRead;
		push nNumberOfBytesToRead;
		push lpBuffer;
		push hFile;
		call Prolog__ReadFile;
		mov  bRet,eax
	}

    return bRet;
}


void
_declspec(naked) Prolog__WriteFile(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
	}
}

BOOL _I_WriteFile(
  HANDLE hFile,                    // handle to file
  LPCVOID lpBuffer,                // data buffer
  DWORD nNumberOfBytesToWrite,     // number of bytes to write
  LPDWORD lpNumberOfBytesWritten,  // number of bytes written
  LPOVERLAPPED lpOverlapped        // overlapped buffer
){

	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
	    if (lpNumberOfBytesWritten)
	        *lpNumberOfBytesWritten = 0;
		return FALSE;
	}    
    
    _asm{
		push lpOverlapped;
        push lpNumberOfBytesWritten;
		push nNumberOfBytesToWrite;
		push lpBuffer;
		push hFile;
		call Prolog__WriteFile;
		mov  bRet,eax
	}

    return bRet;
}


void
_declspec(naked) Prolog__CreateEvent(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
	}
}

HANDLE _I_CreateEvent(
  LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
  BOOL bManualReset,                       // reset type
  BOOL bInitialState,                      // initial state
  LPCWSTR lpName                           // object name
)
{
	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
	HANDLE hHandle;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
		return NULL;
	}

    _asm{
		push lpName;
        push bInitialState;
		push bManualReset;
		push lpEventAttributes
		call Prolog__CreateEvent;
		mov  hHandle,eax
	}
    
	return hHandle;
}


void
_declspec(naked) Prolog__RtlFreeHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
	}
}

#define SPACE_STACK_ALLOC (4*sizeof(ULONG_PTR))

DWORD _I_RtlFreeHeap(VOID * pHeap,DWORD Flags,VOID * pBlock)
{
	
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	DWORD dwRet;

	if (pBlock && !(HEAP_SLOW_FLAGS & Flags))
	{
		HEAP_ENTRY * pEntry = (HEAP_ENTRY *)pBlock-1;

              DWORD RealSize = pEntry->Size * sizeof(HEAP_ENTRY);
		DWORD Size = RealSize - pEntry->UnusedBytes;

		ULONG_PTR * pL = (ULONG_PTR *)pBlock;

		if (0 == (pEntry->Flags & 0x01) ||0xf0f0f0f0 == pL[1] )
		{
			if (!g_bDisableBreak)
       			DebugBreak();
		}

		DWORD CanMemset = RealSize-sizeof(HEAP_ENTRY);
		memset(pBlock,0xF0,(CanMemset > SPACE_STACK_ALLOC)?CanMemset-SPACE_STACK_ALLOC:CanMemset);
				
		if (pEntry->Size >=4)
		{		    
		    RtlCaptureStackBackTrace (1,
        		                      (4 == pEntry->Size)?4:6,
                		              (PVOID *)(pEntry+2),
                        		      pLong);		
		}

	}

	_asm {
		push pBlock              ;
		push Flags               ;
		push pHeap               ;
		call Prolog__RtlFreeHeap ;
		mov  dwRet,eax           ;
	}

	return dwRet;
}

void
_declspec(naked) Prolog__RtlAllocateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // to make this distinct
	}
}



VOID * _I_RtlAllocateHeap(VOID * pHeap,DWORD Flags,DWORD Size)
{
	
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	VOID * pRet;
	DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);

/*
       if (g_FaultHeapEnabled && g_NumFailInARow)
       {
       	InterlockedDecrement(&g_NumFailInARow);
       	goto here;
       }
*/       
       
	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultHeapEnabled && (Ret%g_Factor < g_Percent))
	{
//		g_NumFailInARow = g_RowOfFailures;
//here:		
//		InterlockedIncrement(&g_NumFailedAllocation);
		return NULL;
	}
	

	_asm {
		push NewSize                 ;
		push Flags                   ;
		push pHeap                   ;
		call Prolog__RtlAllocateHeap ;
		mov  pRet,eax                ;
	}

	
	if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
	{

	   if (NewSize <= 0xffff)
       	    NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
		
	    if (!(HEAP_ZERO_MEMORY & Flags))
	    {	
		    memset(pRet,0xc0,NewSize-sizeof(HEAP_ENTRY));
	    }

	    RtlCaptureStackBackTrace(1,
	    	                                     4,
                         		               (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                        		               pLong);
	    
	}

	return pRet;
	
}

void
_declspec(naked) Prolog__RtlReAllocateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
	}
}


VOID *
_I_RtlReAllocateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD Flags,  // heap reallocation options
  LPVOID lpMem,   // pointer to memory to reallocate
  SIZE_T Size  // number of bytes to reallocate
){
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	VOID * pRet;

	DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);
	
	_asm {
		push NewSize                 ;
		push lpMem                   ;
		push Flags                 ;
		push pHeap                   ;
		call Prolog__RtlReAllocateHeap ;
		mov  pRet,eax                ;
	}

	if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
	{

	   if (NewSize <= 0xffff)
       	    NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
		
	    RtlCaptureStackBackTrace(1,
	    	                                     4,
                         		               (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                        		               pLong);
	    
	}


       return pRet;
}

void
_declspec(naked) Prolog__RtlValidateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
	}
}

BOOL
_I_RtlValidateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD dwFlags,  // heap reallocation options
  LPVOID lpMem   // pointer to memory to validate
){
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	BOOL bRet;

       g_bDisableBreak = TRUE;
	
	_asm {
		push lpMem                   ;
		push dwFlags                 ;
		push pHeap                   ;
		call Prolog__RtlValidateHeap ;
		mov  bRet,eax                ;
	}

       g_bDisableBreak = FALSE;

       return bRet;
}


void intercept2(WCHAR * Module,
			   LPSTR Function,
			   VOID * NewRoutine,
			   VOID * pPrologStorage,
			   DWORD Size)    
{
	FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

	if (OldRoutine)
	{
		MEMORY_BASIC_INFORMATION MemBI;
		DWORD dwOldProtect;
		BOOL bRet, bRet2;
		DWORD dwRet;

		dwRet = VirtualQuery(OldRoutine,&MemBI,sizeof(MemBI));

		bRet = VirtualProtect(MemBI.BaseAddress,
							  MemBI.RegionSize,
							  PAGE_EXECUTE_WRITECOPY,
							  &dwOldProtect);

		dwRet = VirtualQuery(pPrologStorage,&MemBI,sizeof(MemBI));

		bRet2 = VirtualProtect(MemBI.BaseAddress,
							  MemBI.RegionSize,
							  PAGE_EXECUTE_WRITECOPY,
							  &dwOldProtect);

		if (bRet && bRet2)
		{
			VOID * pToJump = (VOID *)NewRoutine;
			BYTE Arr[SIZE_JUMP_ADR] = { 0xe9 };
			
			LONG * pOffset = (LONG *)&Arr[1];
			* pOffset = (LONG)NewRoutine - (LONG)OldRoutine - SIZE_JUMP_ADR ;        
			// save the old code
			
			memcpy(pPrologStorage,OldRoutine,Size); 		
			// put the new code
			memset(OldRoutine,0x90,Size);
			memcpy(OldRoutine,Arr,SIZE_JUMP_ADR);
			// adjust the prolog to continue
			* pOffset = (LONG)OldRoutine + Size - (LONG)pPrologStorage - SIZE_SAVED_INSTR - SIZE_JUMP_ADR; // magic for nops
			memcpy((BYTE *)pPrologStorage+SIZE_SAVED_INSTR,Arr,SIZE_JUMP_ADR);
		}
	}
	else
	{
		OutputDebugStringA("GetProcAddress FAIL\n");
	}
}

void unintercept(WCHAR * Module,
                 LPSTR Function,
			     VOID * pPrologStorage,
			     DWORD Size)
{
    FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

	if (OldRoutine)
	{
	    memcpy((void *)OldRoutine,pPrologStorage,Size);
	}

}

#endif /*_X86_*/
#endif

HRESULT 
CleanClasses(IWbemServices * pNamespace,
			 WCHAR * pClassName)
{	
	HRESULT hr;
 	IEnumWbemClassObject * pEnum = NULL;
    BSTR StrClass = SysAllocString(pClassName);
	if (StrClass)
	{
		std::vector<_bstr_t> ArrNames;
		hr = pNamespace->CreateInstanceEnum(StrClass,0,NULL,&pEnum);
		if (SUCCEEDED(hr))
		{
			while(TRUE)
			{
				ULONG nReturned = 0;
				IWbemClassObject * pObj = NULL;
				hr = pEnum->Next(WBEM_INFINITE,1,&pObj,&nReturned);
				if (WBEM_S_FALSE == hr)
				{
					break; // end enumeratin
				}
				else if (WBEM_S_NO_ERROR == hr)
				{
					VARIANT Var;
					VariantInit(&Var);
					if (SUCCEEDED(pObj->Get(L"__RELPATH",0,&Var,0,0)) && VT_BSTR == V_VT(&Var))
					{
                        ArrNames.push_back(V_BSTR(&Var));
						VariantClear(&Var);
					}
					pObj->Release();
				}
				else
				{
					break; // fail
				}
			}

			pEnum->Release();

			DWORD i;
			DBG_PRINTFA((pBuff,"found %d instances\n",ArrNames.size()));			
			for(i=0;i<ArrNames.size();i++)
			{
				DBG_PRINTFA((pBuff,"instance %S\n",(WCHAR *)ArrNames[i]));
				pNamespace->DeleteInstance(ArrNames[i],0,NULL,NULL);
			}
		}
	}
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

bool DoWDMNamespaceInit()
{
	bool bRet = FALSE;

	IWbemLocator *pLocator = NULL;
	HRESULT hr = CoCreateInstance(CLSID_WbemLocator,NULL, CLSCTX_ALL, IID_IWbemLocator,(void**)&pLocator);
	if(SUCCEEDED(hr))
	{
		BSTR tmpStr = SysAllocString(L"root\\wmi");
		IWbemServices* pNamespace = NULL;
		hr = pLocator->ConnectServer(tmpStr, NULL, NULL, NULL, NULL, NULL, NULL, &pNamespace);
		if (SUCCEEDED(hr))
		{

			CleanClasses(pNamespace,L"WMIBinaryMofResource");

			CHandleMap	HandleMap;
			CWMIBinMof Mof;
	
			if( SUCCEEDED( Mof.Initialize(&HandleMap, TRUE, WMIGUID_EXECUTE|WMIGUID_QUERY, pNamespace, NULL, NULL)))
			{
				Mof.ProcessListOfWMIBinaryMofsFromWMI();
			}

			pNamespace->Release();
			bRet = TRUE;
		}
		SysFreeString(tmpStr);
		pLocator->Release();
	}
	return bRet;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 // this call back is needed by the wdmlib functions called by DoWDMProviderInit()
void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
	return;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
extern "C" int __cdecl wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )

{

#ifdef INSTRUMENTED_BUILD
#ifdef _X86_

	RtlCaptureStackBackTrace = (fnRtlCaptureStackBackTrace)GetProcAddress(GetModuleHandleW(L"ntdll.dll"),"RtlCaptureStackBackTrace");
	RtlRandomEx = (fnRtlRandomEx)GetProcAddress(GetModuleHandleW(L"ntdll.dll"),"RtlRandomEx");
	intercept2(L"ntdll.dll","RtlFreeHeap",_I_RtlFreeHeap,Prolog__RtlFreeHeap,7);
	intercept2(L"ntdll.dll","RtlAllocateHeap",_I_RtlAllocateHeap,Prolog__RtlAllocateHeap,5);
	intercept2(L"ntdll.dll","RtlReAllocateHeap",_I_RtlReAllocateHeap,Prolog__RtlReAllocateHeap,5);	
	intercept2(L"ntdll.dll","RtlValidateHeap",_I_RtlValidateHeap,Prolog__RtlValidateHeap,7);		
	intercept2(L"kernel32.dll","CreateEventW",_I_CreateEvent,Prolog__CreateEvent,6);
	intercept2(L"kernel32.dll","WriteFile",_I_WriteFile,Prolog__WriteFile,7);
	intercept2(L"kernel32.dll","ReadFile",_I_ReadFile,Prolog__ReadFile,7);

#endif /*_X86_*/
#endif

	Sleep(8000);

    int nRc = 0;

	// =========================================================
    // Initialize COM
	// =========================================================
    HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
	if ( SUCCEEDED( hr ) )
    {
	    // =====================================================
        // Setup default security parameters
	    // =====================================================
        hr = CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE,
			                       NULL, EOAC_NONE, NULL );
	    if ( SUCCEEDED( hr ) )
        {
			DWORD i;
            for (i=0;i<10;i++)
			{
			    DoWDMNamespaceInit();
				DBG_PRINTFA((pBuff,"-%x- DoWDMNamespaceInit\n",i));
			}
        }

   	    CoUninitialize();
	}

	DebugBreak();

	CoFreeUnusedLibrariesEx(0,0);
    CoFreeUnusedLibrariesEx(0,0);

#ifdef INSTRUMENTED_BUILD
#ifdef _X86_

	unintercept(L"ntdll.dll","RtlFreeHeap",Prolog__RtlFreeHeap,7);	
	unintercept(L"ntdll.dll","RtlAllocateHeap",Prolog__RtlAllocateHeap,5);
	unintercept(L"ntdll.dll","RtlReAllocateHeap",Prolog__RtlReAllocateHeap,5);	
	unintercept(L"ntdll.dll","RtlValidateHeap",Prolog__RtlValidateHeap,7);
	unintercept(L"kernel32.dll","CreateEventW",Prolog__CreateEvent,6);
	unintercept(L"kernel32.dll","WriteFile",Prolog__WriteFile,7);
	unintercept(L"kernel32.dll","ReadFile",Prolog__ReadFile,7);
	
#endif /*_X86_*/
#endif

    DebugBreak();

    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\assocqp.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    ASSOCQP.H

Abstract:

    WQL association query parser

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/

#ifndef _ASSOCQP_H_
#define _ASSOCQP_H_


class CAssocQueryParser : public SWbemAssocQueryInf
{

public:
    CAssocQueryParser();
   ~CAssocQueryParser();

    HRESULT Parse(LPCWSTR Query);
        // Parses both query and target object path.
        // Returns:
        //      WBEM_E_INVALID_QUERY on syntax error
        //      WBEM_E_INVALID_OBJECT_PATH if the object
        //          path is syntactically invalid.
        //      WBEM_E_OUT_OF_MEMORY
        //      WBEM_S_NO_ERROR

    LPCWSTR GetQueryText() { return m_pszQueryText; }
    LPCWSTR GetTargetObjPath() { return m_pszPath; }
    LPCWSTR GetResultClass() { return m_pszResultClass; }
    LPCWSTR GetAssocClass() { return m_pszAssocClass; }
    LPCWSTR GetRole() { return m_pszRole; }
    LPCWSTR GetResultRole() { return m_pszResultRole; }
    LPCWSTR GetRequiredQual() { return m_pszRequiredQualifier; }
    LPCWSTR GetRequiredAssocQual() { return m_pszRequiredAssocQualifier; }
    DWORD   GetQueryType() { return m_uFeatureMask; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\assocqp.cpp ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    ASSOCQP.CPP

Abstract:

    Association query parser

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.
    raymcc   11-Apr-00   Reworked for WMIUTILS

--*/

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>

#include <wmiutils.h>
#include <genlex.h>
#include <assocqp.h>
#include <wbemcli.h>
#include <helpers.h>

#define ASSOC_QUERY_VERSION     2


// ==========================================================================
//                        ASSOCIATION QUERY PARSER.
// ==========================================================================


#define QASSOC_TOK_STRING       101
#define QASSOC_TOK_IDENT        102
#define QASSOC_TOK_DOT          103
#define QASSOC_TOK_EQU          104
#define QASSOC_TOK_COLON        105

#define QASSOC_TOK_ERROR        1
#define QASSOC_TOK_EOF          0

#define ST_IDENT                13
#define ST_STRING               19
#define ST_QSTRING              26
#define ST_QSTRING_ESC          30

// DFA State Table for Assoc query tokens.
// =======================================

LexEl AssocQuery_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'{',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,

/* 4 */  L'=',   GLEX_EMPTY, 0,  QASSOC_TOK_EQU, GLEX_ACCEPT|GLEX_RETURN,
/* 5 */  L'.',   GLEX_EMPTY, 0,  QASSOC_TOK_DOT, GLEX_ACCEPT|GLEX_RETURN,
/* 6 */  L':',   GLEX_EMPTY, 0,  QASSOC_TOK_COLON, GLEX_ACCEPT|GLEX_RETURN,

/* 7 */  L' ',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 8 */  L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 9 */  L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 10 */  L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 11 */  0,      GLEX_EMPTY, 0,  QASSOC_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 12 */  GLEX_ANY, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


/* ST_IDENT */

/* 13 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 14 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 15 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 16 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 17 */  GLEX_ANY, GLEX_EMPTY,  0,  QASSOC_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

/* ST_STRING */
/* 18 */  0, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 19 */  L'"', GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
/* 20 */  L'}',  GLEX_EMPTY, 0, QASSOC_TOK_STRING, GLEX_RETURN,
/* 21 */  L' ',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 22 */  L'\r',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 23 */  L'\n',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 24 */  L'\t',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 25 */  GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

/* ST_QSTRING */
/* 26 */   0,    GLEX_EMPTY,   0, QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 27 */   L'"', GLEX_EMPTY,   ST_STRING, 0, GLEX_ACCEPT,
/* 28 */   L'\\', GLEX_EMPTY,   ST_QSTRING_ESC, 0, GLEX_ACCEPT,
/* 29 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,

/* ST_QSTRING_ESC */
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
};

/*----------------------------------------------------

References of {objpath} where
    ResultClass=XXX
    Role=YYY
    RequiredQualifier=QualifierName
    ClassDefsOnly

Associators of {objpath} where
    ResultClass=XXX
    AssocClass=YYY
    Role=PPP
    RequiredQualifier=QualifierName
    RequiredAssocQualifier=QualifierName
    ClassDefsOnly

------------------------------------------------------*/

static BOOL ParseAssocQuery(
    IN  LPWSTR  Query,
    OUT LPWSTR *pTargetObj,
    OUT LPWSTR *pResultClass,
    OUT LPWSTR *pAssocClass,
    OUT LPWSTR *pRole,
    OUT LPWSTR *pResultRole,
    OUT LPWSTR *pRequiredQualifier,
    OUT LPWSTR *pRequiredAssocQualifier,
    OUT DWORD  *pdwQueryType
    )
{
    *pTargetObj = 0;
    *pResultClass = 0;
    *pAssocClass = 0;
    *pRole = 0;
    *pResultRole = 0;
    *pRequiredQualifier = 0;
    *pRequiredAssocQualifier = 0;
    *pdwQueryType = 0;

    // TBD: Check for out-of-memory here
    CTextLexSource src(Query);
    CGenLexer Lexer(AssocQuery_LexTable, &src);

    int nTok = 0;
    BOOL bHadTokens = FALSE;

    // Get first token.
    // TBD: Check for out-of-memory
    // =============================
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_IDENT)
        goto Error;

    // REFERENCES or ASSOCIATORS
    // =========================
    if (_wcsicmp(L"References", Lexer.GetTokenText()) == 0)
        *pdwQueryType |= WMIQ_ASSOCQ_REFERENCES;
    else if (_wcsicmp(L"Associators", Lexer.GetTokenText()) == 0)
        *pdwQueryType |= WMIQ_ASSOCQ_ASSOCIATORS;
    else
        goto Error;

    // OF
    // ==
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_IDENT)
        goto Error;
    if (_wcsicmp(L"of", Lexer.GetTokenText()) != 0)
        goto Error;

    // {OBJECTPATH}
    // ============
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_STRING)
        goto Error;

    *pTargetObj = Macro_CloneLPWSTR(Lexer.GetTokenText());
    if (!(*pTargetObj))
        goto Error;    

    // WHERE
    // =====
    nTok = Lexer.NextToken();
    if (nTok == QASSOC_TOK_EOF)
        goto Completed;

    if (nTok != QASSOC_TOK_IDENT)
        goto Error;

    if (_wcsicmp(L"where", Lexer.GetTokenText()) != 0)
        goto Error;

    // Check for RESULTCLASS, ROLE, ASSOCCLASS, CLASSDEFSONLY,
    // REQUIREDQUALIFIER, REQUIREDASSOCQUALIFIER
    // ======================================================

    for (;;)
    {
        nTok = Lexer.NextToken();
        if (nTok == QASSOC_TOK_ERROR)
            goto Error;

        if (nTok == QASSOC_TOK_EOF)
        {
            if(!bHadTokens)
                goto Error;
            else
                goto Completed;
        }

        if (nTok != QASSOC_TOK_IDENT)
            goto Error;

        bHadTokens = TRUE;

        if (_wcsicmp(L"RESULTCLASS", Lexer.GetTokenText()) == 0)
        {
            if(*pResultClass)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pResultClass = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pResultClass))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_RESULTCLASS;
        }
        else if (_wcsicmp(L"ROLE", Lexer.GetTokenText()) == 0)
        {
            if(*pRole)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRole = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pRole))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_ROLE;
        }
        else if (_wcsicmp(L"RESULTROLE", Lexer.GetTokenText()) == 0)
        {
            if(*pResultRole)
                goto Error;
            if(*pdwQueryType & WMIQ_ASSOCQ_ASSOCIATORS)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pResultRole = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pResultRole))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_RESULTROLE;
        }
        else if (_wcsicmp(L"ASSOCCLASS", Lexer.GetTokenText()) == 0)
        {
            if(*pAssocClass)
                goto Error;
            if(*pdwQueryType & WMIQ_ASSOCQ_REFERENCES)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pAssocClass = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pAssocClass))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_ASSOCCLASS;
        }
        else if (_wcsicmp(L"REQUIREDQUALIFIER", Lexer.GetTokenText()) == 0)
        {
            if(*pRequiredQualifier)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRequiredQualifier = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pRequiredQualifier))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_REQUIREDQUALIFIER;
        }
        else if (_wcsicmp(L"REQUIREDASSOCQUALIFIER", Lexer.GetTokenText()) == 0)
        {
            if(*pRequiredAssocQualifier)
                goto Error;
            if(*pdwQueryType & WMIQ_ASSOCQ_REFERENCES)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRequiredAssocQualifier = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pRequiredAssocQualifier))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER;
        }
        else if (_wcsicmp(L"CLASSDEFSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= WMIQ_ASSOCQ_CLASSDEFSONLY;
        }
        else if (_wcsicmp(L"KEYSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= WMIQ_ASSOCQ_KEYSONLY;
        }
        else if (_wcsicmp(L"SCHEMAONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= WMIQ_ASSOCQ_SCHEMAONLY;
        }
        else if (_wcsicmp(L"CLASSREFSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= WMIQ_ASSOCQ_CLASSREFSONLY;
        }

        else
        {
            goto Error;
        }
    }


Completed:
    if( (*pdwQueryType & WMIQ_ASSOCQ_SCHEMAONLY) &&
        (*pdwQueryType & WMIQ_ASSOCQ_CLASSDEFSONLY))
    {
        goto Error;
    }
    return TRUE;

Error:
    delete *pTargetObj;
    delete *pResultClass;
    delete *pAssocClass;
    delete *pRole;
    delete *pResultRole;
    delete *pRequiredQualifier;
    delete *pRequiredAssocQualifier;

    *pTargetObj = 0;
    *pResultClass = 0;
    *pAssocClass = 0;
    *pRole = 0;
    *pResultRole = 0;
    *pdwQueryType = 0;
    *pRequiredQualifier = 0;
    *pRequiredAssocQualifier = 0;

    return FALSE;
}

//***************************************************************************
//
//***************************************************************************

CAssocQueryParser::CAssocQueryParser()
{
    m_uVersion = ASSOC_QUERY_VERSION;
    m_uFeatureMask = 0;
    m_uAnalysisType = WMIQ_ANALYSIS_ASSOC_QUERY;
    m_pPath = 0;

    m_pszPath = 0;
    m_pszQueryText = 0;
    m_pszResultClass = 0;
    m_pszAssocClass = 0;
    m_pszRole = 0;
    m_pszResultRole = 0;
    m_pszRequiredQualifier = 0;
    m_pszRequiredAssocQualifier = 0;
}

//***************************************************************************
//
//***************************************************************************

CAssocQueryParser::~CAssocQueryParser()
{
    delete m_pszPath;
    delete m_pszQueryText;
    delete m_pszResultClass;
    delete m_pszAssocClass;
    delete m_pszRole;
    delete m_pszResultRole;
    delete m_pszRequiredQualifier;
    delete m_pszRequiredAssocQualifier;

    if (m_pPath)
        m_pPath->Release();
}

//***************************************************************************
//
//***************************************************************************
HRESULT CAssocQueryParser::Parse(LPCWSTR pszQuery)
{
    if (pszQuery == NULL)
        return WBEM_E_INVALID_QUERY;

    // Clone the query text for debugging.
    // ===================================
    int nLen = wcslen(pszQuery) + 1;
    m_pszQueryText = new wchar_t[nLen];
    if (m_pszQueryText == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    wcscpy(m_pszQueryText, pszQuery);

    // Parse it.
    // =========

    BOOL bRes = ParseAssocQuery(
        m_pszQueryText,
        &m_pszPath,
        &m_pszResultClass,
        &m_pszAssocClass,
        &m_pszRole,
        &m_pszResultRole,
        &m_pszRequiredQualifier,
        &m_pszRequiredAssocQualifier,
        &m_uFeatureMask
        );

    if (bRes == FALSE)
        return WBEM_E_INVALID_QUERY;

    // Parse the object path.
    // ======================

    if (m_pszPath)
    {
    	HRESULT hRes= CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER, IID_IWbemPath, (LPVOID *) &m_pPath);
        if (FAILED(hRes))
            return WBEM_E_FAILED;
        hRes = m_pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, m_pszPath);
        if (FAILED(hRes))
            return WBEM_E_FAILED;
    }
    else
        return WBEM_E_INVALID_QUERY;

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\actualparse.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ActualParse.H

Abstract:

    Declares the object path parser engine.

History:

    a-davj  11-feb-00       Created.

--*/

#ifndef _ACTUALPARSE_H_
#define _ACTUALPARSE_H_

#include "genlex.h"
#include "opathlex2.h"
#include <wmiutils.h>
//#include "wbemutil.h"
#include "wbemcli.h"
#include <flexarry.h>

// NOTE:
// The m_vValue in the CKeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  

class  CActualPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    CDefPathParser *m_pOutput;
    CKeyRef *m_pTmpKeyRef;
    
    DWORD m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int optional_scope_class_list();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();
public:
    enum { NoError, SyntaxError, InvalidParameter, NoMemory };
    friend class AutoClear;
    CActualPathParser(DWORD eFlags);
   ~CActualPathParser();

    int Parse(LPCWSTR RawPath, CDefPathParser & Output);
    static LPWSTR GetRelativePath(LPWSTR wszFullPath);

};

class AutoClear
{
    private:
        CActualPathParser * m_pToBeCleared;
    public:
        AutoClear(CActualPathParser * pToBeCleared){m_pToBeCleared = pToBeCleared;};
        ~AutoClear(){m_pToBeCleared->Empty(); m_pToBeCleared->Zero();};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\like.cpp ===
//***************************************************************************
//
//   (c) 2000 by Microsoft Corp. All Rights Reserved.
//
//   like.cpp
//
//   a-davcoo     28-Feb-00       Implements the SQL like operation.
//
//***************************************************************************


#include "precomp.h"
#include "like.h"


#define WILDCARD		L'%'
#define ANYSINGLECHAR	L'_'


CLike::CLike (LPCWSTR expression, WCHAR escape)
{
	m_expression=new WCHAR[wcslen(expression)+1];
    if(m_expression)
	    wcscpy (m_expression, expression);
	m_escape=escape;
}


CLike::~CLike (void)
{
	delete [] m_expression;
}


bool CLike::Match (LPCWSTR string)
{
    // m_expression might be NULL in out-of-memory
	return DoLike (m_expression, string, m_escape);
}


bool CLike::DoLike (LPCWSTR pattern, LPCWSTR string, WCHAR escape)
{
    // pattern might be NULL in out-of-memory
    if(pattern == NULL)
        return false;

	bool like=false;
	while (!like && *pattern && *string)
	{
		// Wildcard match.
		if (*pattern==WILDCARD)
		{
			pattern++;

			do
			{
				like=DoLike (pattern, string, escape);
				if (!like) string++;
			}
			while (*string && !like);
		}
		// Set match.
		else if (*pattern=='[')
		{
			int skip;
			if (MatchSet (pattern, string, skip))
			{
				pattern+=skip;
				string++;
			}
			else
			{
				break;
			}
		}
		// Single character match.
		else
		{
			if (escape!='\0' && *pattern==escape) pattern++;
			if (towupper(*pattern)==towupper(*string) || *pattern==ANYSINGLECHAR)
			{
				pattern++;
				string++;
			}
			else
			{
				break;
			}
		}
	}

	// Skip any trailing wildcard characters.
	while (*pattern==WILDCARD) pattern++;

	// It's a match if we reached the end of both strings, or a recursion 
	// succeeded.
	return (!(*pattern) && !(*string)) || like;
}


bool CLike::MatchSet (LPCWSTR pattern, LPCWSTR string, int &skip)
{
	// Skip the opening '['.
	LPCWSTR pos=pattern+1;

	// See if we are matching a [^] set.
	bool notinset=(*pos=='^');
	if (notinset) pos++;

	// See if the target character matches any character in the set.
	bool matched=false;
	WCHAR lastchar='\0';
	while (*pos && *pos!=']' && !matched)
	{
		// A range of characters is indicated by a '-' unless it's the first
		// character in the set (in which case it's just a character to be
		// matched.
		if (*pos=='-' && lastchar!='\0')
		{
			pos++;
			if (*pos && *pos!=']')
			{
				matched=(towupper(*string)>=lastchar && towupper(*string)<=towupper(*pos));
				lastchar=towupper(*pos);
				pos++;
			}
		}
		else
		{
			// Match a normal character in the set.
			lastchar=towupper(*pos);
			matched=(towupper(*pos)==towupper(*string));
			if (!matched) pos++;
		}
	}

	// Skip the trailing ']'.  If the set did not contain a closing ']'
	// we return a failed match.
	while (*pos && *pos!=']') pos++;
	if (*pos==']') pos++;
	if (!*pos) matched=false;

	// Done.
	skip=(int)(pos-pattern);
	return matched==!notinset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\helpers.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    helpers.h

Abstract:

    Generic helper code

History:

--*/

#ifndef _HELPERS_H_

#include <genutils.h>

inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    wchar_t *dest = new wchar_t[wcslen(src) + 1];
    if (!dest)
        return 0;
    return wcscpy(dest, src);
}

//#define Macro_CloneLPWSTR(x) \
//    (x ? wcscpy(new wchar_t[wcslen(x) + 1], x) : 0)

template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p) : m_p(p){}
    ~CDeleteMe() {delete m_p;}
};

class CSysFreeMe
{
protected:
    BSTR m_str;

public:
    CSysFreeMe(BSTR str) : m_str(str){}
    ~CSysFreeMe() {SysFreeString(m_str);}
};


typedef LPVOID * PPVOID;

template<class TObj>
class CGenFactory : public IClassFactory
    {
    protected:
        long           m_cRef;
    public:
        CGenFactory(void)
		{
			m_cRef=0L;
			return;
		};

        ~CGenFactory(void)
		{
			return;
		}

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
		{
			*ppv=NULL;

			if (IID_IUnknown==riid || IID_IClassFactory==riid)
				*ppv=this;

			if (NULL!=*ppv)
				{
				((LPUNKNOWN)*ppv)->AddRef();
				return NOERROR;
				}

			return ResultFromScode(E_NOINTERFACE);
		};

        STDMETHODIMP_(ULONG) AddRef(void)
		{
			return InterlockedIncrement(&m_cRef);
		};
        STDMETHODIMP_(ULONG) Release(void)
		{
			long lRet = InterlockedDecrement(&m_cRef);
			if (0 ==lRet)
				delete this;
			return lRet;
		};

        //IClassFactory members
        STDMETHODIMP         CreateInstance(IN LPUNKNOWN pUnkOuter, IN REFIID riid, OUT PPVOID ppvObj)
		{
			HRESULT    hr;

			*ppvObj=NULL;
			hr=E_OUTOFMEMORY;

			// This object doesnt support aggregation.

			if (NULL!=pUnkOuter)
				return ResultFromScode(CLASS_E_NOAGGREGATION);

			//Create the object passing function to notify on destruction.

			TObj * pObj = new TObj();

			if (NULL==pObj)
				return hr;

			// Setup the class all empty, etc.

			pObj->InitEmpty();
			hr=pObj->QueryInterface(riid, ppvObj);
			pObj->Release();
			return hr;
			
		};
        STDMETHODIMP         LockServer(BOOL fLock)
		{
			if (fLock)
				InterlockedIncrement((long *)&g_cLock);
			else
				InterlockedDecrement((long *)&g_cLock);
			return NOERROR;
		};
    };
class CReleaseMe
{
protected:
    IUnknown* m_pUnk;

public:
    CReleaseMe(IUnknown* pUnk) : m_pUnk(pUnk){}
    ~CReleaseMe() { release();}
    void release() { if(m_pUnk) m_pUnk->Release(); m_pUnk=0;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\like.h ===
//***************************************************************************
//
//   (c) 2000 by Microsoft Corp. All Rights Reserved.
//
//   like.h
//
//   a-davcoo     28-Feb-00       Implements the SQL like operation.
//
//***************************************************************************

#ifndef _LIKE_H_
#define _LIKE_H_


#include <string.h>


// The CLike class implements the SQL "like" operation.  To compare test strings
// to an expression, construct an instance of the CLike class using the expression
// and an optional escape character.  Then use the Match() method on that instance
// to test each string.  Note, this class makes it's own copy of the expression
// used to construct it.  This implementation supports the '%' and '_' wildard
// characters as well as the [] and [^] constructs for matching sets of characters
// and ranges of characters.
class CLike
{
	public:
		CLike (LPCWSTR expression, WCHAR escape='\0');
		~CLike (void);

		bool Match (LPCWSTR string);

	protected:
		LPWSTR m_expression;
		WCHAR m_escape;

		// Recursive function and helpers for performing like operation.
		bool DoLike (LPCWSTR pattern, LPCWSTR string, WCHAR escape);
		bool MatchSet (LPCWSTR pattern, LPCWSTR string, int &skip);
};


#endif // _LIKE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\actualparse.cpp ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    ActualParse.CPP

Abstract:

    Implements the object path parser engine

History:

    a-davj  11-feb-00       Created.

--*/

#include "precomp.h"
#include <genlex.h>
#include "opathlex2.h"
#include "PathParse.h"
#include "ActualParse.h"
#include "commain.h"
//#include "resource.h"
#include "wbemcli.h"
#include <stdio.h>
#include "helpers.h"



//***************************************************************************
//
//  CActualPathParser
//
//***************************************************************************



LPWSTR CActualPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    // We need the last colon, if any

    LPWSTR wszTemp = wcschr(wszFullPath, L':');
    while (wszTemp != NULL)
    {
        LPWSTR wszSave = wszTemp;
        wszTemp++;
        wszTemp = wcschr(wszTemp, L':'); 
        if (!wszTemp)
        {
            wszTemp = wszSave;
            break;
        }
    }

    if (wszTemp)
        return wszTemp + 1;
    else
        return NULL;
}

void CActualPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CActualPathParser::CActualPathParser(DWORD eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CActualPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CActualPathParser::~CActualPathParser()
{
    Empty();
}

int CActualPathParser::Parse(
    LPCWSTR pRawPath,
    CDefPathParser & Output
    )
{
	DWORD dwTest = m_eFlags & ~WBEMPATH_TREAT_SINGLE_IDENT_AS_NS;
    if(dwTest != WBEMPATH_CREATE_ACCEPT_RELATIVE &&
       dwTest != WBEMPATH_CREATE_ACCEPT_ABSOLUTE &&
       dwTest != WBEMPATH_CREATE_ACCEPT_ALL)
        return CActualPathParser::InvalidParameter;

    if (pRawPath == 0 || wcslen(pRawPath) == 0)
        return CActualPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================
    
    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0])) 
        return InvalidParameter;
    
     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    m_pOutput = &Output;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
		// Since the next slash can be either, search for both and take
		// the first one.  If the first character is a '[', then then
		// end is indicated by a ']'
        // ============================================================

        WCHAR* pwcEnd = NULL;
		if(*pwcStart == L'[')
		{
			// look for the ']'
			
			WCHAR * pCloseBrace = wcschr(pwcStart, L']');
			if(pCloseBrace == NULL)
				return SyntaxError;
			pwcEnd = pCloseBrace+1;
		}
		else
		{
			WCHAR* pwcNextBack = wcschr(pwcStart, L'\\');
			WCHAR* pwcNextForward = wcschr(pwcStart, L'/');
			pwcEnd = pwcNextBack;
			if(pwcEnd == NULL)
				pwcEnd = pwcNextForward;
			else if(pwcNextForward && (pwcNextForward < pwcNextBack))
				pwcEnd = pwcNextForward;
		}   
        if (pwcEnd == NULL)
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            if ((m_eFlags & WBEMPATH_CREATE_ACCEPT_ALL) == 0)
            {
                return SyntaxError;
            }
            else    // A lone server name is legal.
            {   
                m_pOutput->SetServer(pwcStart);
                return NoError;
            }
        }

        if(pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            return SyntaxError;
        }

        WCHAR * wTemp = new WCHAR[pwcEnd-pwcStart+1];
		if(wTemp == NULL)
			return NoMemory;
        wcsncpy(wTemp, pwcStart, pwcEnd-pwcStart);
        wTemp[pwcEnd-pwcStart] = 0;
        m_pOutput->SetServer(wTemp, false, true);
        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src((LPWSTR)pRawPath);
    {
    	AutoClear ac(this);
	    m_pLexer = new CGenLexer(OPath_LexTable2, &src);
		if(m_pLexer == NULL)
			return NoMemory;
		Output.m_pGenLex = m_pLexer;				// TEST CODE
	    // Go.
	    // ===

	    int nRes = begin_parse();
	    if (nRes)
	    {
	        return nRes;
	    }

	    if (m_nCurrentToken != OPATH_TOK_EOF)
	    {
	        return SyntaxError;
	    }

	    if (m_pOutput->GetNumComponents() > 0 && !m_pOutput->HasServer())
	    {
	        if ( ! ( m_eFlags & WBEMPATH_CREATE_ACCEPT_RELATIVE ) && ! ( m_eFlags & WBEMPATH_CREATE_ACCEPT_ALL ) )
	        {
	            return SyntaxError;
	        }
	        else
	        {
	            // Local namespace --- set server to "."
	            // =====================================

	            m_pOutput->SetServer(L".", true, false);
	        }
	    }
    }
    Output.SortKeys();

    // Add in key refs.
    // ================
    return NoError;
}

BOOL CActualPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <ns_or_class>;
//
int CActualPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
    	m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
		if(m_pInitialIdent == NULL)
			return NoMemory;
		if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        // A colon may indicate a namespace now...

        if (!NextToken())
            return SyntaxError;
        return ns_or_class();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= IDENT <ns_list>;
//
int CActualPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        return ns_list();
    }
    else 
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref> <optional_scope_class_list>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//  <ns_or_class> ::= <ident_becomes_ns> <objref_rest>;
//  <ns_or_class> ::= <ident_becomes_class> <objref_rest>;

int CActualPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = objref();
        if (nRes)
            return nRes; 
        if ((m_nCurrentToken != OPATH_TOK_EOF))
            return optional_scope_class_list();
        return NoError;
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
	else if ((m_nCurrentToken == OPATH_TOK_EOF) && 
		     (m_eFlags & WBEMPATH_TREAT_SINGLE_IDENT_AS_NS))
	{
		return ident_becomes_ns();
	}
    // Else
    // ====
    ident_becomes_class();
    if(objref_rest())
        return SyntaxError;
    else
        return optional_scope_class_list();
}

//  <optional_scope_class_list> ::= COLON <objref> <optional_scope_class_list>
//  <optional_scope_class_list> ::= <>

int CActualPathParser::optional_scope_class_list()
{    
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        if (objref() == NoError)
            return optional_scope_class_list();
        return SyntaxError;

    }
    return NoError;
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CActualPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->AddClass(m_pLexer->GetTokenText());

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
//  <ns_list> ::= IDENT <ns_list_rest>;
//
int CActualPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CActualPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CActualPathParser::ident_becomes_class()
{
    m_pOutput->AddClass(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS @;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CActualPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            NextToken();
            m_pOutput->SetSingletonObj();
            return NoError;

        }

        m_pTmpKeyRef = new CKeyRef;
		if(m_pTmpKeyRef == NULL)
			return NoMemory;

        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        m_pOutput->AddKeyRef(m_pTmpKeyRef);
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= COLON <objref> <optional_scope_class_list>;
//  <ns_list_rest> ::= <>;

int CActualPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        if (objref() == NoError)
            return optional_scope_class_list();
        return SyntaxError;
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CActualPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        int iNumByte = 2*(wcslen(m_pLexer->GetTokenText()) +1);
        m_pTmpKeyRef->SetData(CIM_STRING, iNumByte, m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_REFERENCE)
    {
        int iNumByte = 2*(wcslen(m_pLexer->GetTokenText()) +1);
        m_pTmpKeyRef->SetData(CIM_REFERENCE, iNumByte, m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
       	if(*(m_pLexer->GetTokenText()) == L'-')
		{
			__int64 llVal = _wtoi64(m_pLexer->GetTokenText());
			if(llVal > 2147483647 || llVal < -(__int64)2147483648) 
				m_pTmpKeyRef->SetData(CIM_SINT64, 8, &llVal);
			else
				m_pTmpKeyRef->SetData(CIM_SINT32, 4, &llVal);
		}
		else
		{
			unsigned __int64 ullVal;
			if(0 == swscanf(m_pLexer->GetTokenText(), L"%I64u", &ullVal))
				return SyntaxError;
			if(ullVal < 2147483648) 
				m_pTmpKeyRef->SetData(CIM_SINT32, 4, &ullVal);
			else if(ullVal > 0xffffffff) 
				m_pTmpKeyRef->SetData(CIM_UINT64, 8, &ullVal);
			else
				m_pTmpKeyRef->SetData(CIM_UINT32, 4, &ullVal);
		}
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        unsigned __int64 ullVal;
        if(0 ==swscanf(m_pLexer->GetTokenText(),L"%I64x", &ullVal))
        	return SyntaxError;
        m_pTmpKeyRef->SetData(CIM_UINT64, 8, &ullVal);
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            long lVal = 1;
            m_pTmpKeyRef->SetData(CIM_BOOLEAN, 4, &lVal);
        }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            long lVal = 0;
            m_pTmpKeyRef->SetData(CIM_BOOLEAN, 4, &lVal);
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CActualPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CActualPathParser::keyref()
{
    m_pTmpKeyRef = new CKeyRef;
	if(m_pTmpKeyRef == NULL)
		return NoMemory;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    m_pOutput->AddKeyRef(m_pTmpKeyRef);
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CActualPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CActualPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!m_pTmpKeyRef->m_pName)
        return NoMemory;

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\precomp.h ===
#pragma warning (disable : 4786)
#include <windows.h>
#include <objidl.h>
extern long g_cLock;
extern long g_cObj;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\opathlex2.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    OPATHLEX2.H

Abstract:

    Object Path DFA Tokens

History:

--*/

#ifndef _OPATHLEX_H_

#define OPATH_TOK_EOF       0
#define OPATH_TOK_ERROR     1

#define OPATH_TOK_IDENT         100
#define OPATH_TOK_QSTRING       101
#define OPATH_TOK_INT           102
#define OPATH_TOK_HEXINT        103
#define OPATH_TOK_EQ            104

#define OPATH_TOK_DOT           105
#define OPATH_TOK_OPEN_PAREN    106
#define OPATH_TOK_CLOSE_PAREN   107
#define OPATH_TOK_SINGLETON_SYM 108
#define OPATH_TOK_COMMA         109

#define OPATH_TOK_BACKSLASH     110
#define OPATH_TOK_COLON         111
#define OPATH_TOK_REFERENCE     112

#define OPATH_SINGLETON_STRING  L"@"

extern LexEl OPath_LexTable2[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\opathlex2.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

  OPATHLEX2.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <opathlex2.h>             


#define ST_IDENT            24
#define ST_NUMERIC          30
#define ST_DECIMAL          32
#define ST_HEX              34
#define ST_SQ_STRING        38
#define ST_DQ_STRING        42
#define ST_DQ_STRING_ESC    45
#define ST_REFERENCE        48
#define ST_REFERENCE_ESC    51



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable2[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,
/* 21 */ L'{',   GLEX_EMPTY, ST_REFERENCE, 0,               GLEX_ACCEPT,
/* 22 */ L'{',   GLEX_EMPTY, ST_REFERENCE, 0,               GLEX_ACCEPT,    // Actually reserved for next new

    // All remaining unknown characters

/* 23 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

//TODO


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 24 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 27 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 28 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 29 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 30 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 31 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 32 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 33 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 34 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 36 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 37 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 38 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 39 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 40 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 41 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 42 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 43 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 44 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 45  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 46  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 47  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_DQ_REFERENCE
    //
    // A reference begins with '{' and ends with '}'.  Embedded
    // '}' are allowed if preceeded by '\':

/* 48 */   L'\\', GLEX_EMPTY, ST_REFERENCE_ESC, 0,                     GLEX_CONSUME,    // Escape
/* 49 */   L'}',  GLEX_EMPTY, 0,                OPATH_TOK_REFERENCE,   GLEX_ACCEPT,
/* 50 */   L'}',  GLEX_EMPTY, ST_REFERENCE,     0,                     GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_REFERENCE_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 51  */    L'\\', GLEX_EMPTY, ST_REFERENCE, 0,  GLEX_ACCEPT,
/* 52  */    L'}',  GLEX_EMPTY, ST_REFERENCE, 0,  GLEX_ACCEPT,
/* 53  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\pathparse.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PathParse.H

Abstract:

    Implements the default object path parser.

History:

    a-davj  5-feb-00       Created.

--*/

#ifndef _PATHPARSE_H_
#define _PATHPARSE_H_

#include "genlex.h"
//#include "opathlex.h"
#include <wmiutils.h>
#include <umi.h>
#include "wbemcli.h"
#include "flexarry.h"
typedef LPVOID * PPVOID;

class CSafeInCritSec
{
protected:
    CRITICAL_SECTION* m_pcs;
    BOOL m_bOK;
public:
    CSafeInCritSec(CRITICAL_SECTION* pcs) : m_pcs(pcs)
    {
        m_bOK = TRUE;
        __try
        {
            EnterCriticalSection(m_pcs);
        }
        __except(1)
        {
            m_bOK = FALSE;
        };
            
    }
    inline ~CSafeInCritSec()
    {
        if(m_bOK)
            LeaveCriticalSection(m_pcs);
    }
    BOOL IsOK(){return m_bOK;};
    
};

class CRefCntCS
{
private:
    long m_lRef;
    DWORD m_guard1;         // test
    CRITICAL_SECTION m_cs;
    DWORD m_guard2;         // test
    HRESULT m_Status;

public:
    CRefCntCS();
    ~CRefCntCS()
    {
        if(m_Status == S_OK)
            DeleteCriticalSection(&m_cs);
        m_guard1 = 0;
    }
    HRESULT GetStatus(){return m_Status;};
    long AddRef(void){long lRef = InterlockedIncrement(&m_lRef);return lRef;};
    long Release(void);
    CRITICAL_SECTION * GetCS(){return &m_cs;};
};


//***************************************************************************
//
//  STRUCT NAME:
//
//  CKeyRef
//
//  DESCRIPTION:
//
//  Holds information for a single key.  Includes name, data, and data type.
//
//***************************************************************************

struct CKeyRef
{
    LPWSTR  m_pName;
    DWORD m_dwType;
    DWORD m_dwSize;
    void * m_pData;

    CKeyRef();
    CKeyRef(LPCWSTR wszKeyName, DWORD dwType, DWORD dwSize, void * pData);
    HRESULT SetData(DWORD dwType, DWORD dwSize, void * pData);
   ~CKeyRef();

    // note that the caller is to free the returned string.
    LPWSTR GetValue(BOOL bQuotes=TRUE);
   
    DWORD GetValueSize();
    DWORD GetTotalSize();
};

class  CUmiParsedComponent : public IUmiURLKeyList
{
public:
	CUmiParsedComponent(IWbemPathKeyList * pParent) : m_pParent(pParent){};

    //IUnknown members

    STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
    {
		return m_pParent->QueryInterface(riid, ppv);
    };

    STDMETHODIMP_(ULONG) AddRef(void){return m_pParent->AddRef();};
    STDMETHODIMP_(ULONG) Release(void){return m_pParent->Release();};

    HRESULT STDMETHODCALLTYPE GetCount( 
		/* [out] */ ULONG __RPC_FAR *puKeyCount){return m_pParent->GetCount(puKeyCount);};
        
    HRESULT STDMETHODCALLTYPE SetKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [string][in] */ LPCWSTR pszValue){return m_pParent->SetKey(pszName, 0, CIM_STRING,
			(void *)pszValue);};
        
    HRESULT STDMETHODCALLTYPE GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue);
        
    HRESULT STDMETHODCALLTYPE RemoveKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags){return m_pParent->RemoveKey(pszName,0);};
        
    HRESULT STDMETHODCALLTYPE RemoveAllKeys( 
	/* [in] */ ULONG uFlags){return m_pParent->RemoveAllKeys(0);};
        
    HRESULT STDMETHODCALLTYPE GetKeysInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse){return WBEM_E_NOT_AVAILABLE;};

protected:
	IWbemPathKeyList * m_pParent;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CParsedComponent
//
//  DESCRIPTION:
//
//  Each namespace, scope and the class is represented by an instance of this.  It holds 
//  an array of CKeyRef objects and supports the IWbemPathKeyList interface.
//
//***************************************************************************

class  CParsedComponent : public IWbemPathKeyList
{
public:
    CParsedComponent(CRefCntCS *);
    ~CParsedComponent();
	friend class CDefPathParser;
	friend class CUmiPathParser;
	void ClearKeys ();
    HRESULT GetName(BSTR *pName);
    HRESULT Unparse(BSTR *pKey, bool bGetQuotes, bool bUseClassName);
    HRESULT GetComponentType(DWORD &dwType);
    BOOL AddKeyRef(CKeyRef* pAcquireRef);
	bool IsPossibleNamespace();
    bool IsInstance();
	HRESULT SetNS(LPCWSTR pName);

    //IUnknown members

    STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
    {
        *ppv=NULL;

        if (IID_IUnknown==riid || IID_IWbemPathKeyList==riid)
            *ppv=this;
        else if (riid == IID_IMarshal && m_pFTM)
            return m_pFTM->QueryInterface(riid, ppv);
//postponed till Blackcomb        if (IID_IUmiURLKeyList==riid)
//postponed till Blackcomb			*ppv = &m_UmiWrapper;

        if (NULL!=*ppv)
        {
            AddRef();
            return NOERROR;
        }

        return E_NOINTERFACE;
    };

    STDMETHODIMP_(ULONG) AddRef(void)
    {    
        return InterlockedIncrement(&m_cRef);
    };
    STDMETHODIMP_(ULONG) Release(void)
    {
        long lRef = InterlockedDecrement(&m_cRef);
        if (0L == lRef)
            delete this;
        return lRef;
    };

    HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount);
        
    HRESULT STDMETHODCALLTYPE SetKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ LPVOID pKeyVal);

    HRESULT STDMETHODCALLTYPE SetKey2( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ VARIANT __RPC_FAR *pKeyVal);

    HRESULT STDMETHODCALLTYPE GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
            /* [out][in] */ LPVOID pKeyVal,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType);
        
    HRESULT STDMETHODCALLTYPE GetKey2( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType);

    HRESULT STDMETHODCALLTYPE RemoveKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags);

    HRESULT STDMETHODCALLTYPE RemoveAllKeys( 
            /* [in] */ ULONG uFlags);
        
    HRESULT STDMETHODCALLTYPE MakeSingleton( boolean bSet);
        
    HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);

	HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out] */ LPWSTR pszText);


private:

    BSTR        m_sClassName;
    CFlexArray  m_Keys;
    bool        m_bSingleton;
    long        m_cRef;
// postponed till blackcomb	CUmiParsedComponent m_UmiWrapper;
    CRefCntCS * m_pCS;
    IUnknown * m_pFTM;

};



//***************************************************************************
//
//  CLASS NAME:
//
//  CDefPathParser
//
//  DESCRIPTION:
//
//  Provides the default wmi path parser.
//
//***************************************************************************

class CDefPathParser : public IWbemPath, public IUmiURL
{
    public:
        CDefPathParser(void);
        ~CDefPathParser(void);
		DWORD GetNumComponents();
		bool IsEmpty(void);
		long GetNumNamespaces();
		void Empty(void);
        enum Status {UNINITIALIZED, BAD_STRING, EXECEPTION_THROWN, OK, FAILED_TO_INIT};
        BOOL ActualRelativeTest(LPWSTR wszMachine,
                               LPWSTR wszNamespace,
                               BOOL bChildrenOK);
        void InitEmpty(){};

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if(m_dwStatus == FAILED_TO_INIT)
                return WBEM_E_OUT_OF_MEMORY;
            if(m_pCS == NULL)
                return E_NOINTERFACE;
            if (IID_IUnknown==riid || IID_IWbemPath==riid)
                *ppv=(IWbemPath *)this;
            else if (riid == IID_IMarshal && m_pFTM)
                return m_pFTM->QueryInterface(riid, ppv);

// postponed till Blackcomb            else if (IID_IUmiURL==riid)
// postponed till Blackcomb                *ppv=(IUmiURL *)this;

            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return E_NOINTERFACE;
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return InterlockedIncrement(&m_cRef);
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRef = InterlockedDecrement(&m_cRef);
            if (0L == lRef)
                delete this;
            return lRef;
        };

        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ ULONG uMode,
            /* [in] */ LPCWSTR pszPath);
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out] */ LPWSTR pszText);

        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
         
        virtual HRESULT STDMETHODCALLTYPE SetServer( 
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE GetServer( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out] */ LPWSTR pName);
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceCount( 
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        virtual HRESULT STDMETHODCALLTYPE SetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [string][in] */ LPCWSTR pszName);

        virtual HRESULT STDMETHODCALLTYPE GetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out] */ LPWSTR pName);

        virtual HRESULT STDMETHODCALLTYPE RemoveNamespaceAt( 
            /* [in] */ ULONG uIndex);

		virtual HRESULT STDMETHODCALLTYPE RemoveAllNamespaces( void);
        
        virtual HRESULT STDMETHODCALLTYPE GetScopeCount( 
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        virtual HRESULT STDMETHODCALLTYPE SetScope(
            unsigned long,unsigned short *);

        virtual HRESULT STDMETHODCALLTYPE SetScopeFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText);
        
        virtual HRESULT STDMETHODCALLTYPE GetScope( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [in] */ LPWSTR pszClass,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList);

        virtual HRESULT STDMETHODCALLTYPE GetScopeAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText);
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScope( 
            /* [in] */ ULONG uIndex);

		virtual HRESULT STDMETHODCALLTYPE RemoveAllScopes( void);

        virtual HRESULT STDMETHODCALLTYPE SetClassName( 
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE GetClassName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out] */ LPWSTR pszName);
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyList( 
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut);

		virtual HRESULT STDMETHODCALLTYPE CreateClassPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassPart( 
            /* [in] */ long lFlags);

        virtual BOOL STDMETHODCALLTYPE IsRelative( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace);
        
        virtual BOOL STDMETHODCALLTYPE IsRelativeOrChild( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [in] */ long lFlags);

        virtual BOOL STDMETHODCALLTYPE IsLocal( 
            /* [string][in] */ LPCWSTR wszMachine);

        virtual BOOL STDMETHODCALLTYPE IsSameClassName( 
            /* [string][in] */ LPCWSTR wszClass);

		// IUmiURL interface

        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText);
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest);
        
        virtual HRESULT STDMETHODCALLTYPE GetPathInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        virtual HRESULT STDMETHODCALLTYPE SetLocator( 
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE GetLocator( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName);
        
        virtual HRESULT STDMETHODCALLTYPE SetRootNamespace( 
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE GetRootNamespace( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName);
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentCount( 
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        virtual HRESULT STDMETHODCALLTYPE SetComponent( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass);

        virtual HRESULT STDMETHODCALLTYPE SetComponentFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText);
			
        virtual HRESULT STDMETHODCALLTYPE GetComponent( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList);

        virtual HRESULT STDMETHODCALLTYPE GetComponentAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText);
			
        virtual HRESULT STDMETHODCALLTYPE RemoveComponent( 
            /* [in] */ ULONG uIndex);
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllComponents( void);
        
        virtual HRESULT STDMETHODCALLTYPE SetLeafName( 
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE GetLeafName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName);
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyList( 
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut);
        
        virtual HRESULT STDMETHODCALLTYPE CreateLeafPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteLeafPart( 
            /* [in] */ long lFlags);
        




		HRESULT SetServer(LPCWSTR Name, bool m_bServerNameSetByDefault, bool bAcquire);
        BOOL HasServer(){return m_pServer != NULL;};
        LPWSTR GetPath(DWORD nStartAt, DWORD nStopAt,bool bGetServer = false);
        BOOL AddNamespace(LPCWSTR wszNamespace);
        BOOL AddClass(LPCWSTR lpClassName);
        BOOL AddKeyRef(CKeyRef* pAcquireRef);
        BOOL SetSingletonObj();
        LPWSTR GetNamespacePart(); 
	    LPWSTR GetParentNamespacePart(); 
        BOOL SortKeys();
		CParsedComponent * GetLastComponent();
		HRESULT GetComponentString(ULONG Index, BSTR * pUnparsed, WCHAR & wDelim);
		HRESULT AddComponent(CParsedComponent * pComp);
		CParsedComponent * GetClass();
        CRefCntCS * GetRefCntCS(){return m_pCS;};
        void * m_pGenLex;               // for test purposes only

    protected:
		bool		m_bSetViaUMIPath;
        long        m_cRef;
        LPWSTR      m_pServer;           // NULL if no server
		CFlexArray  m_Components;        // list of namespaces and scopes
//		CParsedComponent * m_pClass;  // the class
        DWORD       m_dwStatus;
		bool		m_bParent;			 // true if text is ".."
		LPWSTR	m_pRawPath;				// temporary fix for Raja
        CRefCntCS * m_pCS;
        LPWSTR m_wszOriginalPath;
		bool   m_bServerNameSetByDefault;
        IUnknown * m_pFTM;
        DWORD m_dwException;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\maindll.cpp ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    MAINDLL.CPP

Abstract:

    Contains DLL Entrypoints

History:

--*/

#include "precomp.h"
#include <wbemcli.h>
#include "pathparse.h"
#include "wbemerror.h"

#include <wmiutils.h>
#include <wbemint.h>
#include "genlex.h"
#include "assocqp.h"
#include "ql.h"
#include "wmiquery.h"

#include "helpers.h"
HINSTANCE g_hInstance;
long g_cLock;
long g_cObj;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
    if (DLL_PROCESS_DETACH == ulReason)
    {
        CWmiQuery::Shutdown();
    }
    else if (DLL_PROCESS_ATTACH == ulReason)
    {
        g_hInstance = hInstance;
	DisableThreadLibraryCalls ( hInstance ) ;

        CWmiQuery::Startup();
    }

    return TRUE;
}


//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//
//***************************************************************************

STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT PPVOID ppv)
{
    HRESULT hr = WBEM_E_FAILED;

    IClassFactory * pFactory = NULL;
    if (CLSID_WbemDefPath == rclsid)
        pFactory = new CGenFactory<CDefPathParser>();
//postponed till Blackcomb    if (CLSID_UmiDefURL == rclsid)
//postponed till Blackcomb        pFactory = new CGenFactory<CDefPathParser>();
    else if (CLSID_WbemStatusCodeText == rclsid)
        pFactory = new CGenFactory<CWbemError>();

    else if (CLSID_WbemQuery == rclsid)
		pFactory = new CGenFactory<CWmiQuery>();

    if(pFactory == NULL)
        return E_FAIL;
    hr=pFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pFactory;

    return hr;
}


//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;
    HRESULT hRes = CWmiQuery::CanUnload();

    if (hRes == S_FALSE)
        return S_FALSE;

    // It is OK to unload if there are no objects or locks on the
    // class factory.

    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;


    return ResultFromScode(sc);
}
POLARITY void RegisterUtilsDLL(IN HMODULE hModule, IN GUID guid, IN TCHAR * pDesc, TCHAR * pModel,
            TCHAR * pProgID)
{
//    char       szID[128];
    TCHAR      wcID[128];
    TCHAR      szCLSID[128];
    TCHAR      szModule[MAX_PATH];
    HKEY hKey1 = NULL, hKey2 = NULL;

    // Create the path.

    wchar_t strCLSID[128];
    if(0 ==StringFromGUID2(guid, strCLSID, 128))
        return;
#ifdef UNICODE
    lstrcpy(wcID, strCLSID);
#else
    wcstombs(wcID, strCLSID, 128);
#endif

//    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, wcID);

    // Create entries under CLSID

    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1))
        return;

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc, (lstrlen(pDesc)+1) * sizeof(TCHAR));
    if(ERROR_SUCCESS != RegCreateKey(hKey1,__TEXT("InprocServer32"),&hKey2))
        return;

    if(0 == GetModuleFileName(hModule, szModule,  MAX_PATH))
    return;

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule,
                                        (lstrlen(szModule)+1) * sizeof(TCHAR));
    RegSetValueEx(hKey2, __TEXT("ThreadingModel"), 0, REG_SZ,
                                       (BYTE *)pModel, (lstrlen(pModel)+1) * sizeof(TCHAR));

    RegCloseKey(hKey1);
    RegCloseKey(hKey2);

    // If there is a progid, then add it too

    if(pProgID)
    {
        wsprintf(wcID, __TEXT("SOFTWARE\\CLASSES\\%s"), pProgID);
        if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, wcID, &hKey1))
        {

            RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc , (lstrlen(pDesc)+1) * sizeof(TCHAR));
            if(ERROR_SUCCESS == RegCreateKey(hKey1,__TEXT("CLSID"),&hKey2))
            {
//                wcstombs(szID, wcID, 128);
                RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)wcID,
                                        (lstrlen(wcID)+1) * sizeof(TCHAR));
                RegCloseKey(hKey2);
                hKey2 = NULL;
            }
            RegCloseKey(hKey1);
        }

    }
    return;
}

POLARITY void UnRegisterUtilsDLL(GUID guid, TCHAR * pProgID)
{

//    char       szID[128];
    TCHAR      wcID[128];
    TCHAR  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    wchar_t strCLSID[128];
    if(0 ==StringFromGUID2(guid, strCLSID, 128))
        return;
#ifdef UNICODE
    lstrcpy(wcID, strCLSID);
#else
    wcstombs(wcID, strCLSID, 128);
#endif


//    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, wcID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, __TEXT("InProcServer32"));
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,wcID);
        RegCloseKey(hKey);
    }

    if(pProgID)
    {
        HKEY hKey;
        DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, pProgID, &hKey);
        if(dwRet == NO_ERROR)
        {
            RegDeleteKey(hKey, __TEXT("CLSID"));
            RegCloseKey(hKey);
        }
        RegDeleteKey(HKEY_LOCAL_MACHINE, pProgID);

    }
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

#define LocatorPROGID "WBEMComLocator"

STDAPI DllRegisterServer(void)
{
    RegisterUtilsDLL(g_hInstance, CLSID_WbemDefPath, __TEXT("WbemDefaultPathParser"), __TEXT("Both"), NULL);
//postponed till Blackcomb    RegisterDLL(g_hInstance, CLSID_UmiDefURL, __TEXT("UMIDefaultPathParser"), __TEXT("Both"), NULL);
    RegisterUtilsDLL(g_hInstance, CLSID_WbemStatusCodeText, __TEXT("WbemStatusCode"), __TEXT("Both"), NULL);
    RegisterUtilsDLL(g_hInstance, CLSID_WbemQuery, __TEXT("WbemQuery"), __TEXT("Both"), NULL);

    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    UnRegisterUtilsDLL(CLSID_WbemDefPath,NULL);
//postponed till Blackcomb    UnRegisterDLL(CLSID_UmiDefURL,NULL);
    UnRegisterUtilsDLL(CLSID_WbemStatusCodeText,NULL);
    UnRegisterUtilsDLL(CLSID_WbemQuery,NULL);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\pathparse.cpp ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    PathParse.CPP

Abstract:

    Implements the default object path parser/

History:

    a-davj  6-feb-00       Created.

--*/

#include "precomp.h"
#include <genlex.h>
//#include <opathlex.h>
#include <string.h>
#include "PathParse.h"
#include "ActualParse.h"
#include "commain.h"
//#include "resource.h"
#include "wbemcli.h"
#include <stdio.h>
#include <sync.h>
#include "helpers.h"

CRefCntCS::CRefCntCS() 
{
    m_lRef = 1;
    m_Status = S_OK;
    m_guard1 = 0x52434353;
    m_guard2 = 0x52434353;
    __try
    {
        InitializeCriticalSection(&m_cs);
    }
    __except(1)
    {
	    m_Status = WBEM_E_OUT_OF_MEMORY;
    }
}

long CRefCntCS::Release()
{
    long lRet = InterlockedDecrement(&m_lRef);
    if(lRet == 0)
        delete this;
    return lRet;
}

bool Equal(LPCWSTR first, LPCWSTR second, DWORD dwLen)
{
	if(first == NULL || second == NULL)
		return false;
	if(wcslen(first) < dwLen || wcslen(second) < dwLen)
		return false;
	for (DWORD dwCnt = 0; dwCnt < dwLen; dwCnt++, first++, second++)
	{
		if(towupper(*first) != towupper(*second))
			return false;
	}
	return true;
}

/*++

Routine Description:

  Determines the number of bytes needed to store data

Arguments:

  uCimType	- Cim type
  pKyeValue - pointer to data to be stored

Return Value:

  Number of bytes.  0 if an error
--*/

DWORD GetCIMSize(DWORD uCimType, void * pKeyVal)
{
    DWORD dwRet = 0;
    switch(uCimType)
    {
        case CIM_STRING:
        case CIM_REFERENCE:
        case CIM_DATETIME:
            dwRet = 2 * (wcslen((WCHAR *)pKeyVal) + 1);
            break;
        case CIM_UINT8:
        case CIM_SINT8:
            dwRet = 1;
            break;
        case CIM_SINT16:
        case CIM_UINT16:
        case CIM_CHAR16:
            dwRet = 2;
            break;
        case CIM_SINT32:
        case CIM_UINT32:
        case CIM_BOOLEAN:
            dwRet = 4;
            break;
        case CIM_SINT64:
        case CIM_UINT64:
            dwRet = 8;
            break;
    }
    return dwRet;
}

//***************************************************************************
//
//  CKeyRef Class.  Used to store a key name/value pair
//
//***************************************************************************

/*++

Routine Description:

  Default Constructor.

--*/

CKeyRef::CKeyRef()
{
    m_pName = 0;
    m_dwType = CIM_EMPTY;
    m_dwSize = 0;
    m_pData = NULL;
}

/*++

Routine Description:

  Constructor.

Arguments:

  wszKeyName	- name
  dwType		- cim type
  dwSize		- data size
  pData			- actual data
	
--*/

CKeyRef::CKeyRef(LPCWSTR wszKeyName, DWORD dwType, DWORD dwSize, void * pData)
{
    if(wszKeyName)
        m_pName = Macro_CloneLPWSTR(wszKeyName);
    else
        m_pName = NULL;
    m_pData = NULL;
    SetData(dwType, dwSize, pData);
}

/*++

Routine Description:

  Sets the data for a CKeyRef object.  Frees any existing data.

Arguments:

  dwType		- cim type
  dwSize		- data size
  pData			- actual data

Return Value:

  S_OK if all is well.
  WBEM_E_INVALID_PARAMETER if bad arg
  WBEM_E_OUT_OF_MEMORY if low memory problem

--*/

HRESULT CKeyRef::SetData(DWORD dwType, DWORD dwSize, void * pData)
{
    if(m_pData)
        delete m_pData;
    m_pData = NULL;
    m_dwType = CIM_EMPTY;
    m_dwSize = 0;
    if(dwSize && pData && GetCIMSize(dwType, pData))
    {
        m_pData = new byte[dwSize];
        if(m_pData)
        {
            m_dwType = dwType;
			m_dwSize = dwSize;
            memcpy(m_pData, pData, dwSize);
            return S_OK;
        }
        return WBEM_E_OUT_OF_MEMORY;
    }
    else
        return WBEM_E_INVALID_PARAMETER;
}

/*++

Routine Description:

  Destructor.
	
--*/

CKeyRef::~CKeyRef()
{
    if (m_pName)
        delete m_pName;

    if (m_pData)
        delete m_pData;
}


/*++

Routine Description:

  provide an estimate of how large the value could be once converted to 
  a character string.

Return Value:

  Limit on how many bytes are needed.
  
--*/



DWORD CKeyRef::GetValueSize()
{
	if(m_dwType == CIM_STRING || m_dwType == CIM_REFERENCE || m_dwType == CIM_DATETIME)
		return m_dwSize * 2 + 2;
	else if(m_dwSize == 8)
		return 21;
	else
		return 14;
}

/*++

Routine Description:

  Returns estimate of how large the key/value pair may be.

--*/

DWORD CKeyRef::GetTotalSize()
{
    DWORD dwSize = GetValueSize();
    if (m_pName)
        dwSize += wcslen(m_pName) +1;
    return dwSize;
}

/*++

Routine Description:

  Returns the value as text.

Arguments:

  bQuotes	- If true, the strings are enclosed in quotes

Return Value:

  Pointer to string.  Caller must free via delete.  NULL if error.

--*/

LPWSTR CKeyRef::GetValue(BOOL bQuotes)
{
    LPWSTR lpKey = NULL;
    DWORD dwSize, dwCnt;
    WCHAR * pFr, * pTo;
	unsigned __int64 * pull;
    pFr = (WCHAR *)m_pData;

    // For string, the size may need to be increaed for quotes

    if(m_dwType == CIM_STRING || m_dwType == CIM_REFERENCE)
    {
        dwSize = m_dwSize;
        if(bQuotes)
            dwSize+= 2;
    }
    else
        dwSize = 32;
    lpKey = new WCHAR[dwSize];
	if(lpKey == NULL)
		return NULL;

    switch(m_dwType)
    {
      case CIM_STRING:
      case CIM_REFERENCE:
        pTo = lpKey;
        if (bQuotes && m_dwType == CIM_STRING)
        {
            *pTo = '"';
            pTo++;
        }
        for(dwCnt = 0; dwCnt < m_dwSize && *pFr; dwCnt++, pFr++, pTo++)
        {
            if(*pFr == '\\' || *pFr == '"')
            {
                *pTo = '\\';
                pTo++;
            }

           *pTo = *pFr;
        }
        if (bQuotes && m_dwType == CIM_STRING)
        {
            *pTo = '"';
            pTo++;
        }
        *pTo = 0;
        break;
      case CIM_SINT32:
        swprintf(lpKey, L"%d", *(int *)m_pData);
        break;
      case CIM_UINT32:
        swprintf(lpKey, L"%u", *(unsigned *)m_pData);
        break;
      case CIM_SINT16:
        swprintf(lpKey, L"%hd", *(signed short *)m_pData);
        break;
      case CIM_UINT16:
        swprintf(lpKey, L"%hu", *(unsigned short *)m_pData);
        break;
      case CIM_SINT8:
        swprintf(lpKey, L"%d", *(signed char *)m_pData);
        break;
      case CIM_UINT8:
        swprintf(lpKey, L"%u", *(unsigned char *)m_pData);
        break;
      case CIM_UINT64:
        swprintf(lpKey, L"%I64u", *(unsigned __int64 *)m_pData);
        break;
      case CIM_SINT64:
        swprintf(lpKey, L"%I64d", *(__int64 *)m_pData);
        break;
      case CIM_BOOLEAN:
        if(*(int *)m_pData == 0)
            wcscpy(lpKey,L"false");
        else
            wcscpy(lpKey,L"true");
        break;
      default:
          *lpKey = 0;
        break;            
    }

    return lpKey;
}



//***************************************************************************
//
//  CParsedComponent
//
//***************************************************************************

/*++

Routine Description:

	Constructor.

--*/

CParsedComponent::CParsedComponent(CRefCntCS * pCS)
{
	m_bSingleton = false;
	m_cRef = 1;
	m_sClassName = NULL;
    m_pCS = pCS;
    if(m_pCS)
        m_pCS->AddRef();
   //// m_UmiWrapper.Set(m_hMutex);
   	m_pFTM = NULL;
    CoCreateFreeThreadedMarshaler((IWbemPath*)this, &m_pFTM);

}

/*++

Routine Description:

  Destructor.

--*/

CParsedComponent::~CParsedComponent()
{
    if(m_pCS)
        m_pCS->Release();
    ClearKeys();
	if(m_sClassName)
		SysFreeString(m_sClassName);
    m_pCS = NULL;
    if(m_pFTM)
    	m_pFTM->Release();
    
}
      
/*++

Routine Description:

  Retrieves the call name.

Arguments:

  pName	- Where the name is to be copied.  Note that the call must free via SysFreeString

Return Value:

  S_OK if all is well, else error

--*/

HRESULT CParsedComponent::GetName(BSTR *pName)
{
    HRESULT hr = 0;
    if (pName == NULL || m_sClassName == NULL)
		return WBEM_E_INVALID_PARAMETER;

	*pName = SysAllocString(m_sClassName);
    if(*pName)
		return S_OK;
	else
		return WBEM_E_OUT_OF_MEMORY;
}

/*++

Routine Description:

  returns the class/key info in standard format.  Ex;   class="hello" or
  class.key1=23,key2=[reference]

Arguments:

  pOutputKey	-   Where the value is to be copied.  Must be freed by the
					caller.
Return Value:
	
  S_OK if all is well, else an error code

--*/

HRESULT CParsedComponent::Unparse(BSTR *pOutputKey, bool bGetQuotes, bool bUseClassName)
{
    HRESULT hr = 0;
    if (pOutputKey)
    {
        int nSpace = 0;
		if(m_sClassName && bUseClassName)
			nSpace += wcslen(m_sClassName);
        nSpace += 10;
        DWORD dwIx;
        for (dwIx = 0; dwIx < (DWORD)m_Keys.Size(); dwIx++)
        {
            CKeyRef* pKey = (CKeyRef*)m_Keys[dwIx];
            nSpace += pKey->GetTotalSize();
        }

        LPWSTR wszPath = new WCHAR[nSpace];
		if(wszPath == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<WCHAR> dm1(wszPath);
		wszPath[0] = 0;
		if(m_sClassName && bUseClassName)
			wcscpy(wszPath, (const wchar_t *)m_sClassName);

        if (m_bSingleton)
			if(bUseClassName)
				wcscat(wszPath, L"=@");
			else
				wcscat(wszPath, L"@");

        for (dwIx = 0; dwIx < (DWORD)m_Keys.Size(); dwIx++)
        {
            CKeyRef* pKey = (CKeyRef *)m_Keys[dwIx];

            // We dont want to put a '.' if there isnt a key name,
            // for example, Myclass="value"
            if(dwIx == 0)
            {
                if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || m_Keys.Size() > 1)
                    if(bUseClassName)
						wcscat(wszPath, L".");
            }
            else
            {
                wcscat(wszPath, L",");
            }
            if(pKey->m_pName)
			{
                wcscat(wszPath, pKey->m_pName);
			}
            LPWSTR lpTemp = pKey->GetValue(bGetQuotes);
            if(lpTemp)
			{
				if(wcslen(wszPath))
					wcscat(wszPath, L"=");
				wcscat(wszPath, lpTemp);
				delete lpTemp;
			}
        }

        *pOutputKey = SysAllocString(wszPath);
        if (!(*pOutputKey))
        	return WBEM_E_OUT_OF_MEMORY;
    }
    else
        hr = WBEM_E_INVALID_PARAMETER;
    return hr;
}


/*++

Routine Description:

  Gets the number of keys.

Arguments:

  puKeyCount	-	Where the result is to be put.

Return Value:

  S_OK if all is well, else an error code.

--*/

HRESULT CParsedComponent::GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puKeyCount == NULL)
        return WBEM_E_INVALID_PARAMETER;
    *puKeyCount = m_Keys.Size();
	return S_OK;

}
        
/*++

Routine Description:

  Sets the name/value pair for a key.  If the key exists, then it is
  replace.  If the name is empty, then all existing keys are deleted.

Arguments:

  wszName	-	Key name.  May be NULL	
  uFlags	-	not used for now
  uCimType	-	data type
  pKeyVal	-	pointer to the data

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::SetKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ LPVOID pKeyVal)
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    DWORD dwCnt = 0;
    CKeyRef * pKey; 
	m_bSingleton = false;
    DWORD dwSize = GetCIMSize(uCimType, pKeyVal);
    if(uFlags || pKeyVal == NULL || dwSize == 0)
        return WBEM_E_INVALID_PARAMETER;

    // If the current list has just a single unnamed entry, the delete it.

    if(m_Keys.Size() == 1)
    {
        pKey = (CKeyRef *)m_Keys[dwCnt];
        if(pKey->m_pName == NULL || pKey->m_pName[0] == 0)
            ClearKeys();
    }

    if(wszName == NULL || wcslen(wszName) < 1)
    {
        // If new key has null name, delete all existing entries.
    
        ClearKeys();
    }
    else
    {
        // If new key has name, look for current entry of same name

        for(dwCnt = 0; dwCnt < (DWORD)m_Keys.Size(); dwCnt++)
        {
            pKey = (CKeyRef *)m_Keys[dwCnt];
            if(pKey->m_pName && !_wcsicmp(pKey->m_pName, wszName))
                break;
        }
    }

    // If current entry of same name exists, replace it

    if(dwCnt < (DWORD)m_Keys.Size())
    {
        // If it exists, replace it
    
        pKey->SetData(uCimType, dwSize, pKeyVal);
    }
    else
    {
        // otherwise, new entry
        CKeyRef * pNew = new CKeyRef(wszName, uCimType, dwSize, pKeyVal);
        if(pNew)
            m_Keys.Add(pNew);
		else
			return WBEM_E_OUT_OF_MEMORY;
    }
    return S_OK;
}

/*++

Routine Description:

  Converts a simple vartype to the cim equivalent

Arguments:

  vt	-	simple vartype

Return Value:

  valid cimtype.  CIM_EMPTY is returned if there is an error.
	
--*/

DWORD CalcCimType(VARTYPE vt)
{
    switch (vt)
    {
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_BSTR:
    case VT_BOOL:
    case VT_UI1:
        return vt;
    default:
        return  CIM_EMPTY;
    }
}

/*++

Routine Description:

  Sets the name/value pair for a key.  If the key exists, then it is
  replace.  If the name is empty, then all existing keys are deleted.

Arguments:

  wszName	-	Key name.  May be NULL	
  uFlags	-	not used for now
  uCimType	-	data type
  pKeyVal	-	pointer to the data

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::SetKey2( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ VARIANT __RPC_FAR *pKeyVal)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(uFlags != 0 || pKeyVal == NULL || wszName == 0)
		return WBEM_E_INVALID_PARAMETER;

    // special code for the provider team

    if(uCimType == CIM_ILLEGAL)
        uCimType = CalcCimType(pKeyVal->vt);
    if(uCimType == CIM_EMPTY)
        return WBEM_E_INVALID_PARAMETER;

	if(uCimType == CIM_SINT64)
	{
		__int64 llVal = _wtoi64(pKeyVal->bstrVal);
		return SetKey(wszName, uFlags, CIM_SINT64, &llVal);
	}
	else if(uCimType == CIM_UINT64)
	{
		unsigned __int64 ullVal;
		char cTemp[50];
		wcstombs(cTemp, pKeyVal->bstrVal,50);
		if(sscanf(cTemp, "%I64u", &ullVal) != 1)
            return WBEM_E_INVALID_PARAMETER;
		return SetKey(wszName, uFlags, CIM_UINT64, &ullVal);
	}
	else if(pKeyVal->vt == VT_BSTR)
	{
		return SetKey(wszName, uFlags, uCimType, pKeyVal->bstrVal);
	}
	else
	{
		DWORD dwSize = GetCIMSize(uCimType, &pKeyVal->lVal);
		if(dwSize == 0)
			return WBEM_E_INVALID_PARAMETER;
		return SetKey(wszName, uFlags, uCimType, &pKeyVal->lVal);
	}
}

/*++

Routine Description:

  Gets the key information based on the key's index.  Note that all return
  values are optional.

Arguments:

  uKeyIx			-	Zero based index of the desired key
  uNameBufSize		-	size of buffer in WCHAR of pszKeyName
  pszKeyName		-	where name is to be copied.  Can be NULL if not needed
  uKeyValBufSize	-	size of pKeyVal buffer in bytes
  pKeyVal			-	where data is to be copied.  Can be NULL if not needed
  puApparentCimType -	data type.  Can be NULL if not needed

Return Value:

  S_OK if all is well, else an error code.
	
--*/
        
HRESULT CParsedComponent::GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
            /* [in] */ LPVOID pKeyVal,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    bool bTooSmall = false;
    if(uKeyIx >= (DWORD)m_Keys.Size())
        return WBEM_E_INVALID_PARAMETER;
	if(uFlags != 0 && uFlags != WBEMPATH_TEXT && uFlags != WBEMPATH_QUOTEDTEXT)
        return WBEM_E_INVALID_PARAMETER;

    if(puNameBufSize && *puNameBufSize > 0 && pszKeyName == NULL)
        return WBEM_E_INVALID_PARAMETER;
	if(puKeyValBufSize && *puKeyValBufSize && pKeyVal == NULL)
        return WBEM_E_INVALID_PARAMETER;


    CKeyRef * pKey = (CKeyRef *)m_Keys[uKeyIx];
    if(puNameBufSize)
	{
        if(pKey->m_pName == NULL)
        {
            *puNameBufSize = 1;
            if(pszKeyName)
                pszKeyName[0] = 0;
        }
        else
        {
            DWORD dwSizeNeeded = wcslen(pKey->m_pName)+1;
		    if(*puNameBufSize < dwSizeNeeded && pszKeyName)
		    {
                bTooSmall = true;
			    *puNameBufSize = dwSizeNeeded;
		    }
            else
            {
                *puNameBufSize = dwSizeNeeded;
		        if(pszKeyName)
			        wcscpy(pszKeyName, pKey->m_pName);
            }
        }
	}

	if(puKeyValBufSize)
	{

		// get a pointer to the data and figure out how large it is

		DWORD dwSizeNeeded = 0;
		BYTE * pData = 0;
		bool bNeedToDelete = false;

		if(uFlags == 0)
		{
			dwSizeNeeded = pKey->m_dwSize;
			pData = (BYTE *)pKey->m_pData;
		}
		else
		{
			bool bQuoted = false;
			if(uFlags == WBEMPATH_QUOTEDTEXT)
				bQuoted = true;
			pData = (BYTE *)pKey->GetValue(bQuoted);
			if(pData == NULL)
				return WBEM_E_FAILED;
			bNeedToDelete = true;
			dwSizeNeeded = 2 * (wcslen((LPWSTR)pData)+1);
		}

		// Copy the data in

		if(*puKeyValBufSize < dwSizeNeeded && pKeyVal)
		{
			*puKeyValBufSize = dwSizeNeeded;
			if(bNeedToDelete)
				delete pData;
			return WBEM_E_BUFFER_TOO_SMALL;
		}
        *puKeyValBufSize = dwSizeNeeded;
		if(pData && pKeyVal)
			memcpy(pKeyVal, pData, dwSizeNeeded);
		if(bNeedToDelete)
			delete pData;
	}

    if(puApparentCimType)
        *puApparentCimType = pKey->m_dwType;
    if(bTooSmall)
        return WBEM_E_BUFFER_TOO_SMALL;
    else
        return S_OK;
}
  
/*++

Routine Description:

  Gets the key information based on the key's index.  Note that all return
  values are optional.

Arguments:

  uKeyIx			-	Zero based index of the desired key
  uNameBufSize		-	size of buffer in WCHAR of pszKeyName
  pszKeyName		-	where name is to be copied.  Can be NULL if not needed
  uKeyValBufSize	-	size of pKeyVal buffer in bytes
  pKeyVal			-	where data is to be copied.  Can be NULL if not needed
  puApparentCimType -	data type.  

Return Value:

  S_OK if all is well, else an error code.
	
--*/
        
HRESULT CParsedComponent::GetKey2( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType)
{

	DWORD dwSize = 50;
	WCHAR wTemp[50];

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(uKeyIx >= (DWORD)m_Keys.Size() || pKeyValue == NULL || puApparentCimType == NULL)
        return WBEM_E_INVALID_PARAMETER;
    CKeyRef * pKey = (CKeyRef *)m_Keys[uKeyIx];

	if(pKey->m_dwType == CIM_STRING || pKey->m_dwType == CIM_REFERENCE || pKey->m_dwType == CIM_DATETIME)
		dwSize = pKey->m_dwSize * 4 + 2;
	char * pTemp = new char[dwSize];
	if(pTemp == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<char> dm(pTemp);
	HRESULT hr = GetKey(uKeyIx, uFlags, puNameBufSize,pszKeyName, &dwSize, 
							(void *)pTemp, puApparentCimType);
	if(FAILED(hr))
		return hr;

	__int64 temp64;
	// convert to cim type;

	VariantClear(pKeyValue);
	switch (*puApparentCimType)
	{
        case CIM_STRING:
        case CIM_REFERENCE:
        case CIM_DATETIME:
			pKeyValue->vt = VT_BSTR;
			pKeyValue->bstrVal = SysAllocString((LPWSTR)pTemp);
			if(pKeyValue->bstrVal == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            break;
        case CIM_UINT8:
        case CIM_SINT8:
            pKeyValue->vt = VT_UI1;
			memcpy((void*)&pKeyValue->lVal, pTemp, 1);
            break;
        case CIM_SINT16:
        case CIM_CHAR16:
            pKeyValue->vt = VT_I2;
			memcpy((void*)&pKeyValue->lVal, pTemp, 2);
            break;
        case CIM_UINT16:
            pKeyValue->vt = VT_I4;
			memcpy((void*)&pKeyValue->lVal, pTemp, 2);
            break;
        case CIM_SINT32:
        case CIM_UINT32:
            pKeyValue->vt = VT_I4;
			memcpy((void*)&pKeyValue->lVal, pTemp, 4);
            break;
        case CIM_BOOLEAN:
            pKeyValue->vt = VT_BOOL;
			memcpy((void*)&pKeyValue->lVal, pTemp, 4);
            break;
        case CIM_SINT64:
        case CIM_UINT64:
			memcpy((void *)&temp64, pTemp, 8);
			if(*puApparentCimType == CIM_SINT64)
				_i64tow(temp64, wTemp, 10);
			else
				_ui64tow(temp64, wTemp, 10);
			pKeyValue->vt = VT_BSTR;
			pKeyValue->bstrVal = SysAllocString(wTemp);
			if(pKeyValue->bstrVal == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            break;
	}
	return hr;
}
      
/*++

Routine Description:

  Removes a key from the key list.

Arguments:

  wszName		-	Name of the key to be delete.  Can be null if the key doesnt have a name.	
  uFlags		-	not currently used.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::RemoveKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    CKeyRef * pKey = NULL;
    bool bFound = false;
    DWORD dwCnt = 0;

    if(uFlags != 0)
        return WBEM_E_INVALID_PARAMETER;

    if(wszName == NULL || wszName[0] == 0)
    {

        // check for null key, it can match if single entry also null

        if(m_Keys.Size() == 1)
        {
            pKey = (CKeyRef *)m_Keys[dwCnt];
            if(pKey->m_pName == NULL || pKey->m_pName[0] == 0)
                bFound = true;
        }
    }
    else
    {

        // loop through and look for name match

        for(dwCnt = 0; dwCnt < (DWORD)m_Keys.Size(); dwCnt++)
        {
            pKey = (CKeyRef *)m_Keys[dwCnt];
            if(pKey->m_pName && !_wcsicmp(pKey->m_pName, wszName))
            {
                bFound = true;
                break;
            }
        }
    }
    if(bFound)
    {
        delete pKey;
        m_Keys.RemoveAt(dwCnt);
        return S_OK;
    }
    else
        return WBEM_E_INVALID_PARAMETER;
}

/*++

Routine Description:

  Removes all keys from the key list.

Arguments:

  wszName		-	Name of the key to be delete.  Can be null if the key doesnt have a name.	
  uFlags		-	not currently used.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::RemoveAllKeys( 
            /* [in] */ ULONG uFlags)
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(uFlags != 0)
		return WBEM_E_INVALID_PARAMETER;
	ClearKeys();
	return S_OK;
}
  
/*++

Routine Description:

  Sets or unsets a key to be singleton.

Arguments:

  bSet		-	if true, then all keys are deleted and the singleton flag is set.
				if false, then the singleton flag is cleared.
Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::MakeSingleton(boolean bSet)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(bSet)
	{
		ClearKeys();
		m_bSingleton = true;
	}
	else
		m_bSingleton = false;
	return S_OK;
}

       
/*++

Routine Description:

  Returns information about a particular key list.

Arguments:

  uRequestedInfo	-	Not currently used, should be set to zero	
  puResponse		-	any appropriate values will be OR'ed into this

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(uRequestedInfo != 0 || puResponse == NULL)
		return WBEM_E_INVALID_PARAMETER;
	*puResponse = 0;
	ULONG ulKeyCnt = m_Keys.Size();
	if(ulKeyCnt > 1)
		*puResponse |= WBEMPATH_INFO_IS_COMPOUND;


	for(DWORD dwKey = 0; dwKey < ulKeyCnt; dwKey++)
	{
		CKeyRef * pKey = (CKeyRef *)m_Keys[dwKey];
		if(pKey->m_pName == NULL || wcslen(pKey->m_pName) < 1)
			*puResponse |= WBEMPATH_INFO_HAS_IMPLIED_KEY;

		if(pKey->m_dwType == CIM_REFERENCE)
			*puResponse |= WBEMPATH_INFO_HAS_V2_REF_PATHS;
	}
    if(m_bSingleton)
		*puResponse |= WBEMPATH_INFO_CONTAINS_SINGLETON;
	return S_OK;
}

/*++

Routine Description:

  Returns text version of a particular key list.

Arguments:

  lFlags		- 0 is only current value
  uBuffLength	- number of WCHAR which can fit into pszText 
  pszText		- buffer supplied by caller where data is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out] */ LPWSTR pszText)
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if((lFlags != 0 && lFlags != WBEMPATH_QUOTEDTEXT && lFlags != WBEMPATH_TEXT) || puBuffLength == NULL)
		return WBEM_E_INVALID_PARAMETER;

	BSTR data = NULL;
	bool bGetQuotes = false;
	if(lFlags & WBEMPATH_QUOTEDTEXT)
		bGetQuotes = true;

    HRESULT hr = Unparse(&data, bGetQuotes, false);
	if(FAILED(hr))
		return hr;
	if(data == NULL)
		return WBEM_E_FAILED;

	DWORD dwBuffSize = *puBuffLength;
	DWORD dwSizeNeeded = wcslen(data)+1;
	*puBuffLength = dwSizeNeeded;
	hr = S_OK;
	if(pszText)
	{
		if(dwSizeNeeded > dwBuffSize)
			hr = WBEM_E_BUFFER_TOO_SMALL;
		else
			wcscpy(pszText, data);
	}
	SysFreeString(data);
	return hr;
}


/*++

Routine Description:

  Cleans out a key list.
	
--*/

void CParsedComponent::ClearKeys ()
{
    DWORD dwSize = m_Keys.Size();
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < dwSize ; 
            dwDeleteIndex ++ )
    {
        CKeyRef * pDel = (CKeyRef *)m_Keys[dwDeleteIndex];
		delete pDel;
    }
    m_Keys.Empty();
}

/*++

Routine Description:

  Determines if the key list could be for an instance.

Return Value:

  true if path has keys or is marked as singleton.

--*/

bool CParsedComponent::IsInstance()
{
	if(m_bSingleton || m_Keys.Size())
		return true;
	else
		return false;
}

/*++

Routine Description:

  Adds a key to the key list.

Arguments:

  CKeyRef	-	key to be added.  Note that it is now owned by the key list
				and should not be freed by the caller.

Return Value:

  TRUE if all is well.
	
--*/

BOOL CParsedComponent::AddKeyRef(CKeyRef* pAcquireRef)
{
	if(pAcquireRef == NULL)
		return FALSE;

    if(CFlexArray::no_error == m_Keys.Add(pAcquireRef))
		return TRUE;
	else
		return FALSE;
}

/*++

Routine Description:

  Tests a component to determine if it could be a namespace.  That is true
  only if it contains a single string value with no class name or key name.


Return Value:

  TRUE if it could be a namespace.
	
--*/

bool CParsedComponent::IsPossibleNamespace()
{
	if(m_sClassName && wcslen(m_sClassName))
		return false;
	if(m_Keys.Size() != 1)
		return false;

	CKeyRef * pKey = (CKeyRef *)m_Keys[0];
	if(pKey->m_pName && wcslen(pKey->m_pName))
		return false;
	if(pKey->m_dwType != CIM_STRING)
		return false;
	if(pKey->m_pData == NULL)
		return false;
	else
		return true;
}


/*++

Routine Description:

  Sets a component to be a namespace.

Arguments:

  pName	-		Name to be added.

Return Value:

  S_OK if all is well, else standard error code.
	
--*/

HRESULT CParsedComponent::SetNS(LPCWSTR pName)
{
	if(pName == NULL)
		return WBEM_E_INVALID_PARAMETER;

	CKeyRef * pNew = new CKeyRef;
	if(pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	DWORD dwStrSize = wcslen(pName) + 1;	// one for the numm
	pNew->m_dwSize = 2 * dwStrSize;			// size is in byte, not unicode
    pNew->m_pData = new WCHAR[dwStrSize];
	if(pNew->m_pData == NULL)
    {
        delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
    }

	wcscpy((LPWSTR)pNew->m_pData, pName);
    pNew->m_dwType = CIM_STRING;
	if(CFlexArray::no_error == m_Keys.Add(pNew))
		return S_OK;
	else
	{
		delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
	}

}

//***************************************************************************
//
//  CDefPathParser
//
//***************************************************************************

/*++

Routine Description:

  Constructor.
	
--*/

CDefPathParser::CDefPathParser(void)
{
    m_cRef=1;
    m_pServer = 0;                  // NULL if no server
    m_dwStatus = OK;
	m_bParent = false;
	m_pRawPath = NULL;
    m_wszOriginalPath = NULL;
	m_bSetViaUMIPath = false;
    m_pCS = new CRefCntCS;
    if(m_pCS == NULL || FAILED(m_pCS->GetStatus()))
    	m_dwStatus = FAILED_TO_INIT;
    InterlockedIncrement(&g_cObj);
	m_bServerNameSetByDefault = false;
	m_pFTM = NULL;
    CoCreateFreeThreadedMarshaler((IWbemPath*)this, &m_pFTM);
	m_pGenLex = NULL; 
	m_dwException = 0;
    return;
};

/*++

Routine Description:

  Destructor.
	
--*/

CDefPathParser::~CDefPathParser(void)
{
	if(m_pCS)
        m_pCS->Release();
	Empty();
    m_pCS = NULL;
    InterlockedDecrement(&g_cObj);
    if(m_pFTM)
    	m_pFTM->Release();
    return;
}

/*++

Routine Description:

  Gets the total number of namespaces, scopes, and class parts.

Return Value:

  Number of components.
	
--*/

DWORD CDefPathParser::GetNumComponents()
{
	int iSize = m_Components.Size();
	return iSize;
}

/*++

Routine Description:

  Determines if there is anything in the path.

Return Value:

  true if there is no server, namepace, scope or class part.

--*/

bool CDefPathParser::IsEmpty()
{
	if(m_pServer || GetNumComponents() || m_pRawPath)
		return false;
	else
		return true;
}

/*++

Routine Description:

  Cleans out the data.  Used by destructor.
	
--*/

void CDefPathParser::Empty(void)
{
	m_bSetViaUMIPath = false;
    delete m_pServer;
	m_bParent = false;
	m_pServer = NULL;
	delete m_pRawPath;
	m_pRawPath = NULL;
	delete m_wszOriginalPath;
	m_wszOriginalPath = NULL;
    for (DWORD dwIx = 0; dwIx < (DWORD)m_Components.Size(); dwIx++)
    {
        CParsedComponent * pCom = (CParsedComponent *)m_Components[dwIx];
        pCom->Release();
    }
	m_Components.Empty();
    return;
}

/*++

Routine Description:

  Gets the component string.  The string varies depending on if the component
  if a namepace, or scope or path.

Arguments:

  i				- zero based index
  pUnparsed		- where the string is returned.  The caller must free via SysFreeString.
  wDelim		- Delimiter for this type

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetComponentString(ULONG i, BSTR * pUnparsed, WCHAR & wDelim)
{

	DWORD dwNs = GetNumNamespaces();
	DWORD dwSc = m_Components.Size();
	if(i < dwNs)
	{
		CParsedComponent * pNS = (CParsedComponent *)m_Components[i]; 
		wDelim = L'\\';
		return pNS->Unparse(pUnparsed, false, true);
	}
	CParsedComponent * pInst = NULL;
	if(i < (dwSc))
		pInst = (CParsedComponent *)m_Components[i];
	if(pInst == NULL)
		return WBEM_E_INVALID_PARAMETER;
	wDelim = L':';
	HRESULT hRes;
	hRes = pInst->Unparse(pUnparsed, true, true);
	return hRes;
}

/*++

Routine Description:

  Returns the path

Arguments:

  nStartAt		-   first component to be added to the path
  nStopAt		-	last component to be added to the path.  Note that this is usually just set to
					the number of components.

Return Value:

  pointer to the string.  The caller must free this via delete.  If there is an Error, NULL is returned.
	
--*/

LPWSTR CDefPathParser::GetPath(DWORD nStartAt, DWORD nStopAt,bool bGetServer)
{

    DWORD dwSize = 1024, dwUsed = 0;
	if(bGetServer && m_pServer && wcslen(m_pServer) > 1000)
		dwSize = 2 * wcslen(m_pServer);

    LPWSTR wszOut = new WCHAR[dwSize];
	if(wszOut == NULL)
		return NULL;
    wszOut[0] = 0;
	bool bFirst = true;

	if(bGetServer && m_pServer && wcslen(m_pServer) < 1020)
	{
		int iLen = wcslen(m_pServer) + 3;	// allow for back slashes
		wcscpy(wszOut, L"\\\\");
		wcscat(wszOut, m_pServer);
		wcscat(wszOut, L"\\");
		dwUsed = iLen;
	}
    for (unsigned int i = nStartAt; (int)i < (int)nStopAt; i++)
    {
        BSTR sTemp = NULL;
        WCHAR wDel;
        HRESULT hRes = GetComponentString(i, &sTemp, wDel);
		if(FAILED(hRes))
		{
			delete wszOut;
			return NULL;
		}
		CSysFreeMe fm(sTemp);
        int iLen = wcslen(sTemp);
        if ((iLen + dwUsed) > dwSize)
        {
            DWORD dwNewSize = 2*(dwSize + iLen);
            LPWSTR lpTemp = new WCHAR[dwNewSize];
			CDeleteMe<WCHAR> dm(wszOut);
			if(lpTemp == NULL)
				return NULL;
            memcpy(lpTemp,wszOut, dwSize * sizeof(WCHAR));
            dwSize = dwNewSize;
            wszOut = lpTemp;
        }

        if (!bFirst)
        {
            int n = wcslen(wszOut);
            wszOut[n] = wDel;
            wszOut[n+1] = '\0';
			iLen++;
        }
		bFirst = false;
        wcscat(wszOut, sTemp);
        dwUsed += iLen;
    }

    return wszOut;

}

/*++

Routine Description:

  Adds a namespace.

Arguments:

  wszNamespace		-	Name to be set into the namespace.

Return Value:

  TRUE if all is well.

--*/

BOOL CDefPathParser::AddNamespace(LPCWSTR wszNamespace)
{
    BOOL bRet = FALSE;
	DWORD dwNumNS = GetNumNamespaces();

    CParsedComponent *pNew = new CParsedComponent(m_pCS);
    if (pNew)
    {
        HRESULT hr = pNew->SetNS(wszNamespace);
		if(FAILED(hr))
		{
			delete pNew;
			return FALSE;
		}
        int iRet = m_Components.InsertAt(dwNumNS, pNew); 
        if(iRet != CFlexArray::no_error)
        {
			delete pNew;
			bRet = FALSE;
        }
        else 
        	bRet = TRUE;
    }

    return bRet;
}

/*++

Routine Description:

  This is used during the parsing of the path and is
  just a convenient way to get at the last scope.  Note 
  that during this phase, the class part is in the scope 
  list.

Return Value:

  pointer to last scope or NULL if there isnt one.
--*/

CParsedComponent * CDefPathParser::GetLastComponent()
{
    DWORD dwSize = m_Components.Size();
    if (dwSize > (DWORD)GetNumNamespaces())
        return (CParsedComponent *)m_Components[dwSize-1];
    else
        return NULL;
}

/*++

Routine Description:

  Adds new class.  This is used during the parsing stage when
  the class is just treated as the last scope.

Arguments:

  lpClassName		-	Name of the class

Return Value:

  TRUE if ok

--*/

BOOL CDefPathParser::AddClass(LPCWSTR lpClassName)
{
    BOOL bRet = FALSE;

    CParsedComponent *pNew = new CParsedComponent(m_pCS);
    if (pNew)
    {
        pNew->m_sClassName = SysAllocString(lpClassName);
		if(pNew->m_sClassName)
		{
			m_Components.Add(pNew);
			bRet = TRUE;
		}
		else
			delete pNew;
    }
    
    return bRet;
}

/*++

Routine Description:

  Adds a key/value pair.

Arguments:

  pKey		-	Data to be added.  Note that this is acquired by this routine.

Return Value:

  TRUE if all is well

--*/

BOOL CDefPathParser::AddKeyRef(CKeyRef *pRef)
{
    BOOL bRet = FALSE;
    CParsedComponent *pTemp = GetLastComponent();
    if (pTemp)
    {
        DWORD dwType = 0;
        bRet = pTemp->AddKeyRef(pRef);
    }
    return bRet;
}

/*++

Routine Description:

  Sets the most recent class to be singleton.

Return Value:

  TRUE if OK.

--*/

BOOL CDefPathParser::SetSingletonObj()
{
    BOOL bRet = FALSE;
    CParsedComponent *pTemp = GetLastComponent();
    if (pTemp)
            pTemp->MakeSingleton(true);
    return bRet;
}

/*++

Routine Description:

  Sets the path text.  This causes object to be emptied, the path to be parsed
  and the object be rebuilt.

Arguments:

  uMode			-	mode, can be 
			          WBEMPATH_CREATE_ACCEPT_RELATIVE
					  WBEMPATH_CREATE_ACCEPT_ABSOLUTE
					  WBEMPATH_CREATE_ACCEPT_ALL

  pszPath		- Path.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetText( 
            /* [in] */ ULONG uMode,
            /* [in] */ LPCWSTR pszPath) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(pszPath == NULL)
		return WBEM_E_INVALID_PARAMETER;

	if(!IsEmpty())
		Empty();

    if ((uMode & WBEMPATH_CREATE_ACCEPT_ALL) != 0 && wcslen (pszPath) == 0)
	return S_OK;

    try
    {
        m_wszOriginalPath = new WCHAR[wcslen(pszPath)+1];

        if(m_wszOriginalPath)
        {
	        wcscpy(m_wszOriginalPath, pszPath);

		    if(wcscmp(pszPath, L"..") == 0)
		    {
			    m_bParent = true;
	            m_dwStatus = OK;
	            return S_OK;
		    }

		    // if a umi path is being passed in, use that parser for it

		    if(Equal(pszPath, L"UMI:", 4))
		    {
			    return Set(uMode, pszPath);
		    }
		    else if(Equal(pszPath, L"UMILDAP:", 8) || Equal(pszPath, L"UMIWINNT:", 9))
		    {
			    return Set(0x8000, pszPath);
		    }

		    // normal case

	        CActualPathParser parser(uMode);
	        int iRet = parser.Parse(pszPath, *this);
	        if(iRet == 0)
	        {
	            m_dwStatus = OK;
	            return S_OK;
	        }
	        else
	        {
	            m_dwStatus = BAD_STRING;
	            return WBEM_E_INVALID_PARAMETER;
	        }
	    }
	    else
	    {
	        return WBEM_E_OUT_OF_MEMORY;
	    }
    }
    catch(...)
    {
        m_dwStatus = EXECEPTION_THROWN;
	    return WBEM_E_CRITICAL_ERROR;
    } 
}

/*++

Routine Description:

  Create a WMI path from the object

Arguments:

  lFlags		- 0
  uBuffLength	- number of WCHAR which can fit into pszText 
  pszText		- buffer supplied by caller where data is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetText( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG * puBuffLength,
            /* [string][out] */ LPWSTR pszText) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puBuffLength == NULL || (*puBuffLength > 0 &&pszText == NULL))
        return WBEM_E_INVALID_PARAMETER;

	if(lFlags != 0 && lFlags != WBEMPATH_GET_RELATIVE_ONLY && lFlags != WBEMPATH_GET_SERVER_TOO && 
	   lFlags != WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY && lFlags != WBEMPATH_GET_NAMESPACE_ONLY &&
	   lFlags != WBEMPATH_GET_ORIGINAL)
			return WBEM_E_INVALID_PARAMETER;

    if(lFlags == WBEMPATH_GET_ORIGINAL && m_wszOriginalPath)
    {
        DWORD dwSizeNeeded = wcslen(m_wszOriginalPath) + 1;
        DWORD dwBuffSize = *puBuffLength;
        *puBuffLength = dwSizeNeeded;
        if(pszText)
        {
            if(dwSizeNeeded > dwBuffSize)
                return WBEM_E_BUFFER_TOO_SMALL;
            wcscpy(pszText, m_wszOriginalPath);
        }
        return S_OK;
    }
        
	LPWSTR pTemp = NULL;
	DWORD dwStartAt = 0;
	if(lFlags & WBEMPATH_GET_RELATIVE_ONLY)
		dwStartAt = GetNumNamespaces();
	bool bGetServer = false;
	if(lFlags & WBEMPATH_GET_SERVER_TOO || lFlags & WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY)
		bGetServer = true;

	DWORD dwNum;
	if(lFlags & WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY ||
        lFlags & WBEMPATH_GET_NAMESPACE_ONLY)
		dwNum = GetNumNamespaces();
	else
		dwNum = GetNumComponents();

	// If just a relative path is specified, then dont prepend the server since that
	// will create an invalid path

	if(bGetServer && GetNumNamespaces() == 0 && m_bServerNameSetByDefault == true)
		bGetServer = false;

	pTemp = GetPath(dwStartAt, dwNum, bGetServer);

	if(pTemp == NULL)
        return WBEM_E_FAILED;
    CDeleteMe<WCHAR> dm(pTemp);
	DWORD dwSizeNeeded = wcslen(pTemp) + 1;
	DWORD dwBuffSize = *puBuffLength;
	*puBuffLength = dwSizeNeeded;
	if(pszText)
	{
		if(dwSizeNeeded > dwBuffSize)
			return WBEM_E_BUFFER_TOO_SMALL;
		wcscpy(pszText, pTemp);
	}
	return S_OK;
}

CParsedComponent * CDefPathParser::GetClass()
{
	DWORD dwNS = GetNumNamespaces();
	DWORD dwScopes = m_Components.Size() - dwNS;
	if(dwScopes < 1)
		return NULL;
	int iLast = m_Components.Size()-1;
	return (CParsedComponent *)m_Components.GetAt(iLast);
}


/*++

Routine Description:

  Gets information about the object path.

Arguments:

  uRequestedInfo	-	Must be zero for now
  puResponse		-	The various flags in tag_WMI_PATH_STATUS_FLAG are
						OR'ed in as appropriate.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetInfo(/* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(uRequestedInfo != 0 || puResponse == NULL)
		return WBEM_E_INVALID_PARAMETER;
	*puResponse = 0;

	// special case for ".." paths.

	if(IsEmpty() && m_bParent)
	{
		*puResponse |= WBEMPATH_INFO_IS_PARENT;
		return S_OK;
	}

	// bits for
    // WBEMPATH_INFO_NATIVE_PATH           = 0X8000,
    // WBEMPATH_INFO_WMI_PATH              = 0X10000,

	if(m_bSetViaUMIPath)
		*puResponse |= WBEMPATH_INFO_WMI_PATH;
	if(m_pRawPath)
		*puResponse |= WBEMPATH_INFO_NATIVE_PATH;

    // Bits for
    // WBEMPATH_INFO_ANON_LOCAL_MACHINE      <path has \\. as server name>
    // WBEMPATH_INFO_HAS_MACHINE_NAME        <not a dot>
	// WBEMPATH_INFO_PATH_HAD_SERVER		 <there is a path and it was not specified by default>

	if(m_pServer == NULL || !_wcsicmp(m_pServer, L"."))
		*puResponse |= WBEMPATH_INFO_ANON_LOCAL_MACHINE;
	else
		*puResponse |= WBEMPATH_INFO_HAS_MACHINE_NAME;
	if(m_pServer && m_bServerNameSetByDefault == false)
		*puResponse |= WBEMPATH_INFO_PATH_HAD_SERVER;


	// WBEMPATH_INFO_HAS_SUBSCOPES           <true if a subscope is present

	DWORD dwNS = GetNumNamespaces();
	DWORD dwScopes = m_Components.Size() - dwNS;
	if(dwScopes)
		*puResponse |= WBEMPATH_INFO_HAS_SUBSCOPES;

    // Bits for
    // WBEMPATH_INFO_IS_CLASS_REF            <a path to a classs, not a path to an instance
    // WBEMPATH_INFO_IS_INST_REF             <a path to an instance


	CParsedComponent * pClass = GetClass();
    if (pClass)
    {
        DWORD dwType = 0;
        if(pClass->IsInstance())
            *puResponse |= WBEMPATH_INFO_IS_INST_REF;
		else
			*puResponse |= WBEMPATH_INFO_IS_CLASS_REF;
		if(pClass->m_bSingleton)
			*puResponse |= WBEMPATH_INFO_IS_SINGLETON;

    }
	else
		if(dwScopes == 0)
			*puResponse |= WBEMPATH_INFO_SERVER_NAMESPACE_ONLY;


	// loop through all the scopes and the class deff.
	// set the following
    // WBEMPATH_INFO_IS_COMPOUND             <true if compound key is used
    // WBEMPATH_INFO_HAS_V2_REF_PATHS        <true if V2-style ref paths are used
    // WBEMPATH_INFO_HAS_IMPLIED_KEY         <true if keynames are missing somewhere
    // WBEMPATH_INFO_CONTAINS_SINGLETON      <true if one or more singletons

	unsigned __int64 llRet = 0;

    for (unsigned int iCnt = dwNS; iCnt < (DWORD)m_Components.Size(); iCnt++)
    {
        CParsedComponent *pComp = (CParsedComponent *)m_Components[iCnt];
		pComp->GetInfo(0, &llRet);
		*puResponse |= llRet;
	}
	
	if(pClass)
	{
		pClass->GetInfo(0, &llRet);
		*puResponse |= llRet;
	}

	// For now, assume that v1 compilance means no scopes or new references

	bool bOK = (!IsEmpty() && m_dwStatus == OK);

	if(dwScopes == 0 && (*puResponse & WBEMPATH_INFO_HAS_V2_REF_PATHS) == 0 && bOK)
			*puResponse |= WBEMPATH_INFO_V1_COMPLIANT;

    // WBEMPATH_INFO_V2_COMPLIANT            <true if path is WMI-V2-compliant
    // WBEMPATH_INFO_CIM_COMPLIANT           <true if path is CIM-compliant

	if(bOK)
	{
		// todo, need to define cim compliance

		*puResponse |= WBEMPATH_INFO_V2_COMPLIANT;
		*puResponse |= WBEMPATH_INFO_CIM_COMPLIANT;
	}
 
    return S_OK;
}        
        
/*++

Routine Description:

  Sets the server portion of the path.

Arguments:

  Name			-	New server name.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetServer( 
            /* [string][in] */ LPCWSTR Name) 
{
	return SetServer(Name, false, false);
}

HRESULT CDefPathParser::SetServer( 
            /* [string][in] */ LPCWSTR Name, bool bServerNameSetByDefault, bool bAcquire) 
{
	m_bServerNameSetByDefault = bServerNameSetByDefault;     
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    delete m_pServer;
	m_pServer = NULL;
    if(Name == NULL)		// it is ok to have a null server an
        return S_OK; 

    if(bAcquire)
    {
        m_pServer = (LPWSTR)Name;
    }
    else
    {
        m_pServer = new WCHAR[wcslen(Name)+1];
        if(m_pServer == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        wcscpy(m_pServer, Name);
    }
    return S_OK;
}

/*++

Routine Description:

  Gets the server portion of the path

Arguments:

  puNameBufLength	- size of pName in WCHAR.  On return, set to size used or needed
  pName				- caller allocated buffer where date is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetServer( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out] */ LPWSTR pName) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puNameBufLength == 0 || (*puNameBufLength > 0 && pName == NULL))
        return WBEM_E_INVALID_PARAMETER;
	if(m_pServer == NULL)
        return WBEM_E_NOT_AVAILABLE;
	DWORD dwSizeNeeded = wcslen(m_pServer)+1;
	DWORD dwBuffSize = *puNameBufLength;
	*puNameBufLength = dwSizeNeeded;
	if(pName)
	{
		if(dwSizeNeeded > dwBuffSize)
			return WBEM_E_BUFFER_TOO_SMALL;
		wcscpy(pName, m_pServer);
	}
    return S_OK;
}
        
/*++

Routine Description:

  Gets the number of namespaces

Arguments:

  puCount		-	Set to the number of namespaces.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetNamespaceCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puCount == NULL)
        return WBEM_E_INVALID_PARAMETER;
    
    *puCount = GetNumNamespaces();    
    return S_OK;
}

/*++

Routine Description:

  Inserts a namespace into the path.  An index of 0 inserts it
  at the front of the list.  The maximum allowed value is equal
  to the current number of namespaces which results in adding it
  to the end of the list.

Arguments:

  uIndex	-	See above
  pszName	-	Name of the new Namespace

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetNamespaceAt(/* [in] */ ULONG uIndex,
            /* [string][in] */ LPCWSTR pszName) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;

    // get the count.

	DWORD dwNSCnt = GetNumNamespaces();

	// check the parameters, index must be between 0 and count!

	if(pszName == NULL || uIndex > dwNSCnt)
		return WBEM_E_INVALID_PARAMETER;

	// add this in.

    CParsedComponent *pNew = new CParsedComponent(m_pCS);
    if (pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    
    HRESULT hr = pNew->SetNS(pszName);
	if(FAILED(hr))
	{
		delete pNew;
		return hr;
	}
	int iRet = m_Components.InsertAt(uIndex, pNew);
	if(iRet ==  CFlexArray::no_error)
	    return S_OK;
	else
	{
		delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
	}
}

/*++

Routine Description:

  Gets a namespace name from the list

Arguments:

  uIndex			-	zero based index.  0 if the leftmost.
  uNameBufLength	-	size of pName in WCHAR
  pName				-	caller supplied buffer where the data is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [in] */ ULONG * puNameBufLength,
            /* [string][out] */ LPWSTR pName)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    DWORD dwType;
    if(uIndex >= (DWORD)GetNumNamespaces() || puNameBufLength == NULL || (*puNameBufLength > 0 && pName == NULL))
        return WBEM_E_INVALID_PARAMETER;

    CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
    BSTR bsName;
    SCODE sc = pTemp->Unparse(&bsName, false, true);
    if(FAILED(sc))
        return sc;
	CSysFreeMe fm(bsName);

	DWORD dwSizeNeeded = wcslen(bsName)+1;
	DWORD dwBuffSize = *puNameBufLength;
	*puNameBufLength = dwSizeNeeded;
	if(pName)
	{
		if(dwSizeNeeded > dwBuffSize)
			return WBEM_E_BUFFER_TOO_SMALL;
		wcscpy(pName, bsName);
	}
    return S_OK;
}

/*++

Routine Description:

  Removes a namespace.

Arguments:

  uIndex			-	0 based index of namespace to be removed.  0 is the leftmost.
Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::RemoveNamespaceAt( 
            /* [in] */ ULONG uIndex) 
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwNSCnt;
	GetNamespaceCount(&dwNSCnt);

	// check the parameter, index must be between 0 and count-1!

	if(uIndex >= dwNSCnt)
		return WBEM_E_INVALID_PARAMETER;

	// all is well, delete this

    CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
	delete pTemp;
	m_Components.RemoveAt(uIndex);
    return S_OK;
}
 
/*++

Routine Description:

  Removes all namespaces.

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::RemoveAllNamespaces() 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwNum = GetNumNamespaces();
    for (DWORD dwIx = 0; dwIx < dwNum; dwIx++)
    {
        CParsedComponent * pNS = (CParsedComponent *)m_Components[0];
        delete pNS;
		m_Components.RemoveAt(0);
    }
	return S_OK;
}
       
/*++

Routine Description:

  Gets the number of scopes

Arguments:

  puCount		-	where the number is set.

Return Value:

  S_OK if all is well, else an error code.
	
--*/
     
HRESULT CDefPathParser::GetScopeCount(/* [out] */ ULONG __RPC_FAR *puCount) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(puCount == NULL)
		return WBEM_E_INVALID_PARAMETER;

	*puCount = m_Components.Size() - GetNumNamespaces();
    return S_OK;
}
        
/*++

Routine Description:

  Inserts a scope into the path.  An index of 0 inserts it
  at the front of the list.  The maximum allowed value is equal
  to the current number of scope which results in adding it
  to the end of the list.

Arguments:

  uIndex		-	See description
  pszClass		-	Name of the new scope

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetScope( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwScopeCnt = m_Components.Size();
	uIndex += GetNumNamespaces();
	if(pszClass == NULL || uIndex > dwScopeCnt)
		return WBEM_E_INVALID_PARAMETER;
    CParsedComponent *pNew = new CParsedComponent(m_pCS);
	if(pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pNew->m_sClassName = SysAllocString(pszClass);
	if(pNew->m_sClassName == NULL)
	{
		delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
	}
	int iRet = m_Components.InsertAt(uIndex, pNew);
	if(iRet ==  CFlexArray::no_error)
	    return S_OK;
	else
	{
		delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
	}
	return S_OK;
}
HRESULT CDefPathParser::SetScopeFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText)
{
	return WBEM_E_NOT_AVAILABLE;
}

/*++

Routine Description:

  Retrieves scope information.

Arguments:

  uIndex			-	0 based index.  0 is the leftmost scope
  uClassNameBufSize	-	size of pszClass in WCHAR
  pszClass			-	Optional, caller supplied buffer where name is to be copied
  pKeyList			-	Optional, returns a pKeyList pointer.  Caller must call Release.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetScope( 
            /* [in] */ ULONG uIndex,
            /* [in] */ ULONG * puClassNameBufSize,
            /* [in] */ LPWSTR pszClass,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwScopeCnt = m_Components.Size();
	HRESULT hr = S_OK;
	uIndex += GetNumNamespaces();

	if(uIndex >= dwScopeCnt)
		return WBEM_E_INVALID_PARAMETER;

    if(puClassNameBufSize && (*puClassNameBufSize > 0 && pszClass == NULL))
        return WBEM_E_INVALID_PARAMETER;

    CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
    if(puClassNameBufSize)
	{
		BSTR bsName;
		SCODE sc = pTemp->GetName(&bsName);
		if(FAILED(sc))
		{
			return sc;
		}
		CSysFreeMe fm(bsName);
        DWORD dwSizeNeeded = wcslen(bsName)+1;
		DWORD dwBuffSize = *puClassNameBufSize;
		*puClassNameBufSize = dwSizeNeeded;
		if(pszClass)
		{
			if(dwSizeNeeded > dwBuffSize)
				return WBEM_E_BUFFER_TOO_SMALL;
			wcscpy(pszClass, bsName);
		}
	}
	if(pKeyList)
	{
		hr = pTemp->QueryInterface(IID_IWbemPathKeyList, (void **)pKeyList);
		if(FAILED(hr))
			return hr;
	}
	return S_OK;
}
HRESULT CDefPathParser::GetScopeAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwScopeCnt = m_Components.Size();
	uIndex += GetNumNamespaces();

	if(uIndex >= dwScopeCnt || puTextBufSize == NULL)
		return WBEM_E_INVALID_PARAMETER;

	CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
	
	BSTR bstr;
	HRESULT hr = pTemp->Unparse(&bstr, true, true);
	if(FAILED(hr))
		return hr;

	CSysFreeMe fm(bstr);
	DWORD dwBuffSize = *puTextBufSize;
	DWORD dwSizeNeeded = wcslen(bstr)+1;
	*puTextBufSize = dwSizeNeeded;
	if(pszText)
	{
		if(dwSizeNeeded > dwBuffSize)
			return WBEM_E_BUFFER_TOO_SMALL;
		wcscpy(pszText, bstr);
	}
	return S_OK;
}
        
/*++

Routine Description:

  Removes a scope.

Arguments:

  uIndex		-	0 based index.  0 is the leftmost scope.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::RemoveScope(/* [in] */ ULONG uIndex) 
{
	HRESULT hr = S_OK;
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	bool bGotInterface = false;

	uIndex += GetNumNamespaces();
	if(uIndex >= (DWORD)m_Components.Size())
		return WBEM_E_INVALID_PARAMETER;

    CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
	pTemp->Release();
	m_Components.RemoveAt(uIndex);
	return S_OK;
}

/*++

Routine Description:

  Removes all scopes.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::RemoveAllScopes( void)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    DWORD dwNumNS = GetNumNamespaces();
    for (DWORD dwIx = dwNumNS; dwIx < (DWORD)m_Components.Size(); dwIx++)
    {
        CParsedComponent * pCom = (CParsedComponent *)m_Components[dwNumNS];
        pCom->Release();
		m_Components.RemoveAt(dwNumNS);
    }
	return S_OK;
}

/*++

Routine Description:

  Sets the class name.

Arguments:

  Name			-	New class name.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetClassName( 
            /* [string][in] */ LPCWSTR Name) 
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(Name == NULL)
        return WBEM_E_INVALID_PARAMETER;

    HRESULT hRes = WBEM_E_INVALID_OBJECT_PATH;
	CParsedComponent * pClass = GetClass();
    if (pClass)
    {
		if(pClass->m_sClassName)
            SysFreeString(pClass->m_sClassName);
		pClass->m_sClassName = NULL;
		pClass->m_sClassName = SysAllocString(Name);
        if(pClass->m_sClassName)
            hRes = S_OK;
        else
            hRes = WBEM_E_OUT_OF_MEMORY;
    }
	else
        hRes = CreateClassPart(0, Name);
    return hRes;
}
        
/*++

Routine Description:

  Gets the class name.

Arguments:

  uBuffLength		-	size of pszName in WCHAR
  pszName			-	caller supplied buffer where name is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetClassName( 
            /* [in, out] */ ULONG * puBuffLength,
            /* [string][out] */ LPWSTR pszName) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puBuffLength == NULL || (*puBuffLength > 0 && pszName == NULL))
        return WBEM_E_INVALID_PARAMETER;
    HRESULT hRes = WBEM_E_INVALID_OBJECT_PATH;
	CParsedComponent * pClass = GetClass();
    if (pClass && pClass->m_sClassName)
    {
        DWORD dwSizeNeeded = wcslen(pClass->m_sClassName) +1;
		DWORD dwBuffSize = *puBuffLength;
		*puBuffLength = dwSizeNeeded;
		if(pszName)
		{
			if(dwSizeNeeded > dwBuffSize)
				return WBEM_E_BUFFER_TOO_SMALL;
			wcscpy(pszName, pClass->m_sClassName);
		}
        hRes = S_OK;
    }
    return hRes;
}
        
/*++

Routine Description:

  Gets the key list pointer for the class key list.

Arguments:

  pOut			-	Set to the key list.  Caller must call Release on this.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetKeyList( 
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    HRESULT hRes = WBEM_E_NOT_AVAILABLE;
	CParsedComponent * pClass = GetClass();
	if(pOut == NULL || pClass == NULL)
		return WBEM_E_INVALID_PARAMETER;

    hRes = pClass->QueryInterface(IID_IWbemPathKeyList, (void **)pOut);
	return hRes;
}

/*++

Routine Description:

  Creates a class part of one does not exist.

Arguments:

  lFlags			-	not used for now, set to 0
  Name				-	name of the class

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::CreateClassPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(lFlags != 0 || Name == NULL)
		return WBEM_E_INVALID_PARAMETER;
	CParsedComponent * pClass = new CParsedComponent(m_pCS);
	if(pClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	
	pClass->m_sClassName = SysAllocString(Name);
	if(pClass->m_sClassName == NULL)
	{
		delete pClass;
		return WBEM_E_OUT_OF_MEMORY;
	}
	m_Components.Add(pClass);

	return S_OK;
}
        
/*++

Routine Description:

  Deletes the class part.

Arguments:

  lFlags			-	Not used for now, set to 0

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::DeleteClassPart( 
            /* [in] */ long lFlags)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	CParsedComponent * pClass = GetClass();
	if(lFlags != 0)
		return WBEM_E_INVALID_PARAMETER;

	if(pClass == NULL)
		return WBEM_E_NOT_FOUND;
	pClass->Release();
	int iSize = m_Components.Size();
	m_Components.RemoveAt(iSize-1);
	return S_OK;
}

/*++

Routine Description:

  Does the actual work of the "Relative" tests.

Arguments:

  wszMachine			-	Local machine name
  wszNamespace          -   Namespace
  bChildreOK            -   If true, then it is OK if the obj
                            path has additional child namespaces

Return Value:

  TRUE if relative, else false
	
--*/

BOOL CDefPathParser::ActualRelativeTest( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace,
                               BOOL bChildrenOK)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;

    if(!IsLocal(wszMachine))
        return FALSE;

    DWORD dwNumNamespaces = GetNumNamespaces();
    if(dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    if(wszCopy == NULL)return FALSE;
    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    WCHAR * pToFar = wszCopy + wcslen(wszCopy);

    BOOL bFailed = FALSE;
    for(DWORD i = 0; i < dwNumNamespaces; i++)
    {
		CParsedComponent * pInst = (CParsedComponent *)m_Components[i];

        if(pInst == NULL)
        {
            bFailed = TRUE;
            break;
        }
        
        BSTR bsNS = NULL;
        HRESULT hr = pInst->Unparse(&bsNS, false, true);
        if(FAILED(hr) || bsNS == NULL)
        {
            bFailed = TRUE;
            break;
        }
        CSysFreeMe fm(bsNS);

        if(bChildrenOK && wszLeft >= pToFar)
            return TRUE;

        unsigned int nLen = wcslen(bsNS);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != dwNumNamespaces - 1 && wszLeft[nLen] != L'\\' && bChildrenOK == FALSE)
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, bsNS))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;

}

/*++

Routine Description:

  Tests if path is relative to the machine and namespace.

Arguments:

  wszMachine			-	Local machine name
  wszNamespace          -   Namespace

Return Value:

  TRUE if relative, else false
	
--*/

BOOL CDefPathParser::IsRelative( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace)
{
    return ActualRelativeTest(wszMachine, wszNamespace, FALSE);

}

/*++

Routine Description:

  Tests if path is relative to the machine and namespace.

Arguments:

  wszMachine			-	Local machine name
  wszNamespace          -   Namespace
  lFlags                -   flags, not used for now.

Return Value:

  TRUE if relative, or a child namespace. else false
	
--*/

BOOL CDefPathParser::IsRelativeOrChild( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [in] */ long lFlags)
{

    if(lFlags != 0)
        return FALSE;
    return ActualRelativeTest(wszMachine, wszNamespace, TRUE);
}
        
/*++

Routine Description:

  Tests if path is to local machine

Arguments:

  wszMachine			-	Local machine name

Return Value:

  TRUE if local, else false
	
--*/

BOOL CDefPathParser::IsLocal( 
            /* [string][in] */ LPCWSTR wszMachine)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    return (m_pServer == NULL || !_wcsicmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));

}

/*++

Routine Description:

  Tests if class name matches test

Arguments:

  wszClassName			-	Local machine name

Return Value:

  TRUE if local, else false
	
--*/

BOOL CDefPathParser::IsSameClassName( 
            /* [string][in] */ LPCWSTR wszClass)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	CParsedComponent * pClass = GetClass();
    if (pClass == NULL || pClass->m_sClassName == NULL || wszClass == NULL)
        return FALSE;
    return !_wcsicmp(pClass->m_sClassName, wszClass);
}
/*++

Routine Description:

  Returns just the namspace part of the path

Return Value:

  pointer to the result.  Null if failer.  Caller should free.

--*/

LPWSTR CDefPathParser::GetNamespacePart()
{
    LPWSTR lpRet = NULL;
    lpRet = GetPath(0, GetNumNamespaces());
    return lpRet;
}

/*++

Routine Description:

  Returns the parent namespace part.

Return Value:

  pointer to the result.  Null if failer.  Caller should free.
	
--*/

LPWSTR CDefPathParser::GetParentNamespacePart()
{
	DWORD dwNumNS = GetNumNamespaces();
    if (dwNumNS < 2)
        return NULL;
    LPWSTR lpRet = NULL;
    lpRet = GetPath(0, dwNumNS-1);
    return lpRet;
}

long CDefPathParser::GetNumNamespaces()
{
	long lRet = 0;
	for(DWORD dwCnt = 0; dwCnt < (DWORD)m_Components.Size(); dwCnt++)
	{
		CParsedComponent * pInst = (CParsedComponent *)m_Components[dwCnt];
		if(pInst->IsPossibleNamespace())
			lRet++;
		else
			break;
	}
	return lRet;
}


/*++

Routine Description:

  Sorts the keys based on the key name

Return Value:

  TRUE if OK.

--*/

BOOL CDefPathParser::SortKeys()
{
    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================

    BOOL bChanges = FALSE;
    if (m_Components.Size())
    {
        CParsedComponent *pComp = GetLastComponent();
        if (pComp)
        {
            CParsedComponent *pInst = (CParsedComponent *)pComp;

            if (pInst->m_Keys.Size() > 1)
            {        
                while (bChanges)
                {
                    bChanges = FALSE;
                    for (DWORD dwIx = 0; dwIx < (DWORD)pInst->m_Keys.Size() - 1; dwIx++)
                    {
                        CKeyRef * pFirst = (CKeyRef *)pInst->m_Keys[dwIx];
                        CKeyRef * pSecond = (CKeyRef *)pInst->m_Keys[dwIx+1];
                        if (_wcsicmp(pFirst->m_pName, pSecond->m_pName) > 0)
                        {
                            pInst->m_Keys.SetAt(dwIx, pSecond);
                            pInst->m_Keys.SetAt(dwIx+1, pFirst);
                            bChanges = TRUE;
                        }
                    }
                }
            }

        }
    }

    return bChanges;
}

HRESULT CDefPathParser::AddComponent(CParsedComponent * pComp)
{
	if (CFlexArray::no_error == m_Components.Add(pComp))
		return S_OK;
	else
		return WBEM_E_OUT_OF_MEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\ql.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QL.H

Abstract:

    Level 1 Syntax QL Parser

    Implements the syntax described in QL.BNF.  This translates the input
    into an RPN stream of tokens.

History:

    raymcc    21-Jun-96       Created.

--*/

#ifndef _QL__H_
#define _QL__H_

#include <wbemidl.h>
#include <wbemint.h>
#include <qllex.h>
#include <corepol.h>
#include <parmdefs.h>
#include <stdio.h>
#include <wmiutils.h>

class  CPropertyName : public WBEM_PROPERTY_NAME
{
protected:
    long m_lAllocated;

    void EnsureAllocated(long lElements);
public:
    void Init();
    CPropertyName() {Init();}
    CPropertyName(const CPropertyName& Other);
    void operator=(const CPropertyName& Other);
    void operator=(const WBEM_PROPERTY_NAME& Other);
    BOOL operator==(const WBEM_PROPERTY_NAME& Other);

    void Empty();
    ~CPropertyName() {Empty();}

    long GetNumElements() const {return m_lNumElements;}
    LPCWSTR GetStringAt(long lIndex) const;
    void AddElement(LPCWSTR wszElement);
    DELETE_ME LPWSTR GetText();
};

class  CQl1ParseSink
{
public:
    virtual void SetClassName(LPCWSTR wszClass) = 0;
    virtual void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance) = 0;
    virtual void AddToken(const WBEM_QL1_TOKEN& Token) = 0;
    virtual void AddProperty(const CPropertyName& Property) = 0;
    virtual void AddAllProperties() = 0;

    virtual void SetAggregated() = 0;
    virtual void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance)= 0;
    virtual void AddAggregationProperty(const CPropertyName& Property) = 0;
    virtual void AddAllAggregationProperties() = 0;
    virtual void AddHavingToken(const WBEM_QL1_TOKEN& Token) = 0;

    virtual void InOrder(long lOp){}
};

class  CAbstractQl1Parser
{
protected:
    // Controls keyword parsing in Next().
    // ===================================
    enum {
        NO_KEYWORDS = 0,
        ALL_KEYWORDS,
        EXCLUDE_GROUP_KEYWORD,
        EXCLUDE_EXPRESSION_KEYWORDS
        };

    CQl1ParseSink* m_pSink;
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    BOOL       m_bQuoted;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    CPropertyName m_PropertyName;
    BOOL       m_bInAggregation;
    CPropertyName m_PropertyName2;
    BOOL       m_bPropComp;

    // Parsing functions.
    // ==================
    virtual BOOL Next(int nFlags = ALL_KEYWORDS);
    LPCWSTR GetSinglePropertyName();
    void DeletePropertyName();
    int FlipOperator(int nOp);
    void AddAppropriateToken(const WBEM_QL1_TOKEN& Token);

    int parse_property_name(CPropertyName& Prop);

    int parse(int nFlags);

    int prop_list();
    int class_name();
    int tolerance();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int trailing_ident_expr();
    int unknown_func_expr();
    int typed_constant();
    int opt_aggregation();
    int aggregation_params();
    int aggregate_by();
    int aggregate_within();
    int opt_having();

    static DWORD TranslateIntrinsic(LPCWSTR pFuncName);
    static void InitToken(WBEM_QL1_TOKEN* pToken);
public:
    enum {
        SUCCESS = 0,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL
        };

    enum {
        FULL_PARSE = 0,
        NO_WHERE,
        JUST_WHERE
    };

    CAbstractQl1Parser(CGenLexSource *pSrc);
    virtual ~CAbstractQl1Parser();

    int Parse(CQl1ParseSink* pSink, int nFlags);

    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
};



struct  QL_LEVEL_1_TOKEN
{
    enum
    {
        OP_EXPRESSION = QL1_OP_EXPRESSION,
        TOKEN_AND = QL1_AND,
        TOKEN_OR = QL1_OR,
        TOKEN_NOT = QL1_NOT
    };
    enum
    {
        IFUNC_NONE = QL1_FUNCTION_NONE,
        IFUNC_UPPER = QL1_FUNCTION_UPPER,
        IFUNC_LOWER = QL1_FUNCTION_LOWER
    };

    // If the field is a OP_EXPRESSION, then the following are used.
    enum
    {
        OP_EQUAL = QL1_OPERATOR_EQUALS,
        OP_NOT_EQUAL = QL1_OPERATOR_NOTEQUALS,
        OP_EQUALorGREATERTHAN = QL1_OPERATOR_GREATEROREQUALS,
        OP_EQUALorLESSTHAN = QL1_OPERATOR_LESSOREQUALS,
        OP_LESSTHAN = QL1_OPERATOR_LESS,
        OP_GREATERTHAN = QL1_OPERATOR_GREATER,
        OP_LIKE  = QL1_OPERATOR_LIKE
    };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    CPropertyName PropertyName;
                   // Name of the property on which the operator is applied
    int     nOperator;      // Operator that is applied on property
    VARIANT vConstValue;    // Value applied by operator
    BOOL bQuoted; // FALSE if the string should not have quotes around it.

    CPropertyName PropertyName2; // Property to compare, if applicable.
    BOOL m_bPropComp;        // TRUE if this is a property-to-property compare.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "

    QL_LEVEL_1_TOKEN();
    QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN&);
   ~QL_LEVEL_1_TOKEN();
    QL_LEVEL_1_TOKEN& operator=(const QL_LEVEL_1_TOKEN &Src);
    QL_LEVEL_1_TOKEN& operator=(const WBEM_QL1_TOKEN &Src);

    void Dump(FILE *);
    DELETE_ME LPWSTR GetText();
};


// Contains RPN version of expression.
// ===================================

struct  QL_LEVEL_1_RPN_EXPRESSION : public CQl1ParseSink
{
    int nNumTokens;
    int nCurSize;
    QL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;
    WBEM_QL1_TOLERANCE Tolerance;

    int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
    BOOL bStar;
    CPropertyName *pRequestedPropertyNames;
                // Array of property names which values are to be returned if

    BOOL bAggregated;
    WBEM_QL1_TOLERANCE AggregationTolerance;
    BOOL bAggregateAll;
    int nNumAggregatedProperties;
    int nCurAggPropSize;
    CPropertyName *pAggregatedPropertyNames;

    int nNumHavingTokens;
    int nCurHavingSize;
    QL_LEVEL_1_TOKEN *pArrayOfHavingTokens;

    long lRefCount;

    QL_LEVEL_1_RPN_EXPRESSION();
    QL_LEVEL_1_RPN_EXPRESSION(const QL_LEVEL_1_RPN_EXPRESSION& Other);
   ~QL_LEVEL_1_RPN_EXPRESSION();
    void AddRef();
    void Release();

    void SetClassName(LPCWSTR wszName);
    void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddToken(const WBEM_QL1_TOKEN& Tok);
    void AddToken(const QL_LEVEL_1_TOKEN& Tok);
    void AddProperty(const CPropertyName& Prop);
    void AddAllProperties();

    void SetAggregated();
    void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddAggregationProperty(const CPropertyName& Property);
    void AddAllAggregationProperties();
    void AddHavingToken(const WBEM_QL1_TOKEN& Tok);

    void Dump(const char *pszTextFile);
    DELETE_ME LPWSTR GetText();
};


class QL1_Parser : public CAbstractQl1Parser
{
    QL_LEVEL_1_RPN_EXPRESSION* m_pExpression;
    BOOL m_bPartiallyParsed;

public:
    QL1_Parser(CGenLexSource *pSrc);
#undef ExportClass
#define ExportClass SMSEXPORT
   ~QL1_Parser();
#undef ExportClass
#define ExportClass SMSIMPORT


    int GetQueryClass(LPWSTR pBuf, int nBufSize);

    int Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput);

    HRESULT Parse(
        SWbemRpnEncodedQuery **pOutput
        );

    static LPWSTR ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
        LPCWSTR wszClassName);
};

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\qllex.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    QLLEX.CPP

Abstract:

    QL Level 1 DFA Table

History:

    raymcc    24-Jun-95       Created.

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <qllex.h>             

#define ST_STRING       24
#define ST_IDENT        29
#define ST_GE           35
#define ST_LE           37
#define ST_NE           40
#define ST_NUMERIC      42
#define ST_REAL         47
#define ST_STRING2      53
#define ST_STRING_ESC   58
#define ST_STRING2_ESC  61   
#define ST_DOT          64
#define ST_NEGATIVE_NUM 66
#define ST_POSITIVE_NUM 69

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl Ql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          QL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  QL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  QL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  QL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, ST_NEGATIVE_NUM, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  QL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  QL_1_TOK_COMMA, GLEX_ACCEPT,
/* 22 */ L'+',   GLEX_EMPTY, ST_POSITIVE_NUM, 0,               GLEX_CONSUME,

    // Unknown characters

/* 23 */ GLEX_ANY, GLEX_EMPTY, 0,        QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 24 */   L'\n', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 25 */   L'\r', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 26 */   L'"',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 27 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 28 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 29 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 35 */  L'=',   GLEX_EMPTY,  0,  QL_1_TOK_GE,  GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 37 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_LE,  GLEX_ACCEPT,
/* 38 */  L'>',   GLEX_EMPTY,      0,  QL_1_TOK_NE,  GLEX_ACCEPT,
/* 39 */  GLEX_ANY, GLEX_EMPTY,    0,  QL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 40 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_NE,     GLEX_ACCEPT,
/* 41 */  GLEX_ANY,  GLEX_EMPTY,   0,  QL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 42 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 43 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 44 */  L'E',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 45 */  L'e',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 46 */  GLEX_ANY, GLEX_EMPTY, 0,          QL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 47 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 48 */  L'E',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 49 */  L'e',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 50 */  L'+',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 51 */  L'-',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 52 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 53 */   L'\n',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 54 */   L'\r',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 55 */   L'\'',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 56 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 57 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 58 */   L'"', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 59 */   L'\\', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 60 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING2_ESC
/* 61 */   L'\'', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 62 */   L'\\', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 63 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_DOT
/* 64 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 65 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,


// ST_NEGATIVE_NUM - Strips whitespace after '-'
/* 66 */ L' ', GLEX_EMPTY, ST_NEGATIVE_NUM, 0, GLEX_CONSUME,
/* 67 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 68 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_POSITIVE_NUM - Strips whitespace after '+'
/* 69 */ L' ', GLEX_EMPTY, ST_POSITIVE_NUM, 0, GLEX_CONSUME,
/* 70 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 71 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\qllex.h ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    QLLEX.CH

Abstract:

	QL Level 1 DFA Table & Tokens

History:

	raymcc    24-Jun-95       Created.

--*/

#ifndef _QLLEX_H_

#include <genlex.h>
#define QL_1_TOK_EOF       0
#define QL_1_TOK_ERROR     1
#define QL_1_TOK_IDENT     100
#define QL_1_TOK_QSTRING   101
#define QL_1_TOK_INT       102
#define QL_1_TOK_REAL      103
#define QL_1_TOK_CHAR      104

#define QL_1_TOK_LE        105
#define QL_1_TOK_LT        106
#define QL_1_TOK_GE        107
#define QL_1_TOK_GT        108
#define QL_1_TOK_EQ        109
#define QL_1_TOK_NE        110

#define QL_1_TOK_DOT           111
#define QL_1_TOK_OPEN_PAREN    112
#define QL_1_TOK_CLOSE_PAREN   113
#define QL_1_TOK_ASTERISK      114
#define QL_1_TOK_COMMA         115

#define QL_1_TOK_SELECT        120
#define QL_1_TOK_WHERE         121
#define QL_1_TOK_FROM          122
#define QL_1_TOK_LIKE          123
#define QL_1_TOK_OR            124
#define QL_1_TOK_AND           125
#define QL_1_TOK_NOT           126
#define QL_1_TOK_IS            127
#define QL_1_TOK_NULL          128
#define QL_1_TOK_WITHIN        129
#define QL_1_TOK_ISA           130
#define QL_1_TOK_GROUP         131
#define QL_1_TOK_BY            132
#define QL_1_TOK_HAVING        133

#define QL_1_TOK_TRUE        140
#define QL_1_TOK_FALSE        141

extern LexEl Ql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\queryparse.cpp ===
//***************************************************************************
//
//   (c) 2000 by Microsoft Corp.  All Rights Reserved.
//
//   queryparse.cpp
//
//   a-davcoo     02-Mar-00       Implements the query parser and analysis
//                                interfaces.
//
//***************************************************************************


#include "precomp.h"
#include <stdio.h>
#include "queryparse.h"
#include "wbemcli.h"
#include "wqllex.h"


CWbemQNode::CWbemQNode (IWbemQuery *query, const SWQLNode *node) : m_query(query), m_node(node)
{
    m_cRef=1;
	m_query->AddRef();
}


CWbemQNode::~CWbemQNode (void)
{
}


HRESULT CWbemQNode::QueryInterface (REFIID riid, void **ppv)
{
    if (IID_IUnknown==riid || IID_IWbemQNode==riid)
	{
        *ppv=this;
	}
	else
	{
	    *ppv=NULL;
	}

    if (NULL!=*ppv)
    {
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
};


ULONG CWbemQNode::AddRef(void)
{
	m_query->AddRef();
    return InterlockedIncrement (&m_cRef);
};


ULONG CWbemQNode::Release(void)
{
	m_query->Release();
	if (!InterlockedDecrement (&m_cRef))
	{
        delete this;
	}

    return m_cRef;
};


HRESULT CWbemQNode::GetNodeType( 
	/* [out] */ DWORD __RPC_FAR *pdwType)
{
	if (pdwType==NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	*pdwType=m_node->m_dwNodeType;
	return WBEM_S_NO_ERROR;
}


HRESULT CWbemQNode::GetNodeInfo( 
	/* [in] */ LPCWSTR pszName,
	/* [in] */ DWORD dwFlags,
	/* [in] */ DWORD dwBufSize,
	/* [out] */ LPVOID pMem)
{
	switch (m_node->m_dwNodeType)
	{
		case WBEMQ_TYPE_SWQLNode_Select:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_TableRefs:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_ColumnList:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_FromClause:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_Sql89Join:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_Join:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_JoinPair:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_TableRef:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_OnClause:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_WhereClause:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_RelExpr:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_WhereOptions:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_GroupBy:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_Having:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_OrderBy:
		{
			return WBEM_E_NOT_AVAILABLE;
		}

		case WBEMQ_TYPE_SWQLNode_Datepart:
		{
			return WBEM_E_NOT_AVAILABLE;
		}
	}
	
	return WBEM_E_INVALID_PARAMETER;
}


HRESULT CWbemQNode::GetSubNode( 
	/* [in] */ DWORD dwFlags,
	/* [out] */ IWbemQNode __RPC_FAR *__RPC_FAR *pSubnode)
{
	if (pSubnode==NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	switch (dwFlags)
	{
		case WBEMQ_FLAG_LEFTNODE:
		{
			if (m_node->m_pLeft==NULL)
			{
				return WBEM_E_NOT_AVAILABLE;
			}
			else
			{
				CWbemQNode *node=new CWbemQNode(m_query, m_node->m_pLeft);
				if (node==NULL)
				{
					return WBEM_E_OUT_OF_MEMORY;
				}

				HRESULT hr=node->QueryInterface (IID_IWbemQNode, (void **)pSubnode);
				node->Release();
				return hr;
			}
		}

		case WBEMQ_FLAG_RIGHTNODE:
		{
			if (m_node->m_pRight==NULL)
			{
				return WBEM_E_NOT_AVAILABLE;
			}
			else
			{
				CWbemQNode *node=new CWbemQNode(m_query, m_node->m_pRight);
				if (node==NULL)
				{
					return WBEM_E_OUT_OF_MEMORY;
				}

				HRESULT hr=node->QueryInterface (IID_IWbemQNode, (void **)pSubnode);
				node->Release();
				return hr;
			}
		}

		default:
		{
			return WBEM_E_INVALID_PARAMETER;
		}
	}

	return WBEM_E_FAILED;
}


CWbemQuery::CWbemQuery (void)
{
    m_cRef=1;
	m_parser=NULL;
	m_class=NULL;
}


CWbemQuery::~CWbemQuery (void)
{
	delete m_parser;
	if (m_class)
	{
		m_class->Release();
	}
}


HRESULT CWbemQuery::Empty (void)
{
	delete m_parser;
	m_parser=NULL;

	if (m_class)
	{
		m_class->Release();
		m_class=NULL;
	}

	return WBEM_S_NO_ERROR;
}


void CWbemQuery::InitEmpty (void)
{
}


HRESULT CWbemQuery::QueryInterface (REFIID riid, void **ppv)
{
    if (IID_IUnknown==riid || IID_IWbemQuery==riid)
	{
        *ppv=this;
	}
	else
	{
	    *ppv=NULL;
	}

    if (NULL!=*ppv)
    {
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
};


ULONG CWbemQuery::AddRef(void)
{    
    return InterlockedIncrement (&m_cRef);
};


ULONG CWbemQuery::Release(void)
{
    if (!InterlockedDecrement (&m_cRef))
	{
        delete this;
	}

    return m_cRef;
};


HRESULT CWbemQuery::SetLanguageFeatures( 
    /* [in] */ long lFlags,
    /* [in] */ ULONG uArraySize,
    /* [in] */ ULONG __RPC_FAR *puFeatures)
{
	return WBEM_E_NOT_AVAILABLE;
}


HRESULT CWbemQuery::TestLanguageFeature(
    /* [in,out] */ ULONG *uArraySize,
    /* [out] */ ULONG *puFeatures)
{
	if (m_parser==NULL)
	{
		return WBEM_E_INVALID_QUERY;
	}

	if (uArraySize==NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	if (puFeatures==NULL)
	{
		*uArraySize=0;
	}

	return WBEM_E_NOT_AVAILABLE;
}


HRESULT CWbemQuery::Parse( 
    /* [in] */ LPCWSTR pszLang,
    /* [in] */ LPCWSTR pszQuery,
    /* [in] */ ULONG uFlags)
{
	if (pszQuery==NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	delete m_parser;
	m_parser=NULL;

	if (!_wcsicmp (pszLang, L"wql"))
	{
		CTextLexSource query(pszQuery);

		m_parser=new CWQLParser(&query);
		if (m_parser==NULL)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		else
		{
			HRESULT hr=LookupParserError(m_parser->Parse());
			if (FAILED(hr))
			{
				delete m_parser;
				m_parser=NULL;
			}

			return hr;
		}
	}
	else if (!_wcsicmp (pszLang, L"sql"))
	{
		return WBEM_E_NOT_AVAILABLE;
	}
	else
	{
		return WBEM_E_INVALID_PARAMETER;
	}
}


HRESULT CWbemQuery::GetAnalysis( 
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pObj)
{
	if (pObj==NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	if (m_parser==NULL || m_parser->GetParseRoot()==NULL)
	{
		return WBEM_E_INVALID_QUERY;
	}

	HRESULT hr=WBEM_E_INVALID_PARAMETER;
	*pObj=NULL;
	if (riid==IID_IWbemClassObject)
	{
		if (uFlags==WBEMQ_FLAG_SUMMARY_OBJECT)
		{
			hr=GetAnalysis ((IWbemClassObject **)pObj);
		}
	}
	else if (riid==IID_IWbemQNode)
	{
		if (uFlags==WBEMQ_FLAG_ANALYSIS_AST)
		{
			hr=GetAnalysis ((IWbemQNode **)pObj);
		}
	}
	else
	{
		if (uFlags==WBEMQ_FLAG_RPN_TOKENS)
		{
			hr=WBEM_E_NOT_AVAILABLE;
		}
	}

	return hr;
}


HRESULT CWbemQuery::GetAnalysis (IWbemQNode **ppObject)
{
	HRESULT hr=WBEM_E_FAILED;

	CWbemQNode *node=new CWbemQNode(this, m_parser->GetParseRoot());
	if (node==NULL)
	{
		hr=WBEM_E_OUT_OF_MEMORY;
	}
	else
	{
		hr=node->QueryInterface (IID_IWbemQNode, (void **)ppObject);
		node->Release();
	}

	return hr;
}


HRESULT CWbemQuery::GetAnalysis (IWbemClassObject **ppObject)
{
	*ppObject=NULL;
	return WBEM_E_NOT_AVAILABLE;
}


HRESULT CWbemQuery::TestObject( 
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pObj)
{
	if (pObj==NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	if (m_parser==NULL)
	{
		return WBEM_E_INVALID_QUERY;
	}

	_IWmiObject *pWmiObject=NULL;

	HRESULT hr=WBEM_E_INVALID_PARAMETER;
	if (riid==IID_IWbemClassObject)
	{
		hr=((IWbemClassObject *)pObj)->QueryInterface (IID__IWmiObject, (void **)&pWmiObject);
	}
	else if (riid==IID__IWmiObject)
	{
		pWmiObject=(_IWmiObject *)pObj;
		hr=pWmiObject->AddRef();
	}

	if (SUCCEEDED(hr))
	{
		hr=TestObject (pWmiObject);
	}

	if (pWmiObject!=NULL)
	{
		pWmiObject->Release();
	}

	return hr;
}


HRESULT CWbemQuery::TestObject (_IWmiObject *pObject)
{
	const SWQLNode_WhereClause *pWhere=(SWQLNode_WhereClause *)m_parser->GetWhereClauseRoot();
	if (pWhere==NULL)
	{
		// No where clause.
		return WBEM_S_NO_ERROR;
	}

	const SWQLNode_RelExpr *pExpr=(SWQLNode_RelExpr *)pWhere->m_pLeft;
	if (pExpr==NULL)
	{
		// No expression.
		return WBEM_S_NO_ERROR;
	}

	return TestObject (pObject, pExpr);
}


HRESULT CWbemQuery::TestObject (_IWmiObject *pObject, const SWQLNode_RelExpr *pExpr)
{
	HRESULT hr=WBEM_E_FAILED;

	switch (pExpr->m_dwExprType)
	{
		case WQL_TOK_TYPED_EXPR:
		{
			hr=TestExpression (pObject, pExpr->m_pTypedExpr);
			break;
		}

		case WQL_TOK_AND:
		{
			hr=TestObject (pObject, (SWQLNode_RelExpr *)pExpr->m_pLeft);
			if (hr!=WBEM_S_FALSE)
			{
				hr=TestObject (pObject, (SWQLNode_RelExpr *)pExpr->m_pRight);
			}

			break;
		}

		case WQL_TOK_OR:
		{
			hr=TestObject (pObject, (SWQLNode_RelExpr *)pExpr->m_pLeft);
			if (hr==WBEM_S_FALSE)
			{
				hr=TestObject (pObject, (SWQLNode_RelExpr *)pExpr->m_pRight);
			}

			break;
		}

		case WQL_TOK_NOT:
		{
			hr=TestObject (pObject, (SWQLNode_RelExpr *)pExpr->m_pLeft);
			if (hr==WBEM_S_FALSE)
			{
				hr=WBEM_S_NO_ERROR;
			}
			else if (hr==WBEM_S_NO_ERROR)
			{
				hr=WBEM_S_FALSE;
			}

			break;
		}
	}

	return hr;
}


HRESULT CWbemQuery::TestExpression (_IWmiObject *pObject, const SWQLTypedExpr *pExpr)
{
	CIMTYPE cimtype;
	long handle;

	HRESULT hr=pObject->GetPropertyHandleEx (pExpr->m_pColRef, 0, &cimtype, &handle);
	if (SUCCEEDED(hr))
	{
		void *pProperty=NULL;
		hr=pObject->GetPropAddrByHandle (handle, 0, NULL, &pProperty);
		if (SUCCEEDED(hr))
		{
			switch (cimtype)
			{
				case CIM_SINT8:
				case CIM_SINT16:
				case CIM_SINT32:
				case CIM_SINT64:
				{
					__int64 prop;

					switch (cimtype)
					{
						case CIM_SINT8:
						{
							prop=*((__int8 *)pProperty);
							break;
						}

						case CIM_SINT16:
						{
							prop=*((__int16 *)pProperty);
							break;
						}

						case CIM_SINT32:
						{
							prop=*((__int32 *)pProperty);
							break;
						}

						case CIM_SINT64:
						{
							prop=*((__int64 *)pProperty);
							break;
						}
					}

					__int64 value=GetNumeric (pExpr->m_pConstValue);
					hr=CompareNumeric (prop, value, pExpr->m_dwRelOperator);

					break;
				}

				case CIM_UINT8:
				case CIM_UINT16:
				case CIM_UINT32:
				case CIM_UINT64:
				{
					unsigned __int64 prop;

					switch (cimtype)
					{
						case CIM_UINT8:
						{
							prop=*((unsigned __int8 *)pProperty);
							break;
						}

						case CIM_UINT16:
						{
							prop=*((unsigned __int16 *)pProperty);
							break;
						}

						case CIM_UINT32:
						{
							prop=*((unsigned __int32 *)pProperty);
							break;
						}

						case CIM_UINT64:
						{
							prop=*((unsigned __int64 *)pProperty);
							break;
						}
					}

					unsigned __int64 value=GetNumeric (pExpr->m_pConstValue);
					hr=CompareNumeric (prop, value, pExpr->m_dwRelOperator);

					break;
				}

				case CIM_BOOLEAN:
				{
					unsigned __int16 temp=*((unsigned __int16 *)pProperty);
					bool prop=(temp!=0);

					bool value=GetBoolean (pExpr->m_pConstValue);
					hr=CompareBoolean (prop, value, pExpr->m_dwRelOperator);

					break;
				}

				case CIM_CHAR16:
				case CIM_STRING:
				{
					LPWSTR prop=NULL;

					switch (cimtype)
					{
						case CIM_CHAR16:
						{
							prop=new wchar_t[wcslen((wchar_t *)pProperty)+1];
							if (prop==NULL)
							{
								hr=WBEM_E_OUT_OF_MEMORY;
							}
							else
							{
								wcscpy (prop, (wchar_t *)pProperty);
							}

							break;
						}

						case CIM_STRING:
						{
							prop=new wchar_t[strlen((char *)pProperty)+1];
							if (prop==NULL)
							{
								hr=WBEM_E_OUT_OF_MEMORY;
							}
							else
							{
								mbstowcs (prop, (char *)pProperty, strlen((char *)pProperty)+1);
							}

							break;
						}
					}
					
					if (SUCCEEDED(hr))
					{
						LPWSTR value=GetString (pExpr->m_pConstValue);
						hr=CompareString (prop, value, pExpr->m_dwRelOperator);

						delete [] value;
					}

					delete [] prop;

					break;
				}

				default:
				{
					hr=WBEM_E_NOT_AVAILABLE;
					break;
				}
			}
		}
	}

	return hr;
}

	
HRESULT CWbemQuery::GetQueryInfo( 
    /* [in] */ ULONG uInfoId,
    /* [in] */ LPCWSTR pszParam,
    /* [out] */ VARIANT __RPC_FAR *pv)
{
	if (m_parser==NULL)
	{
		return WBEM_E_INVALID_QUERY;
	}

	switch (uInfoId)
	{
		case WBEMQ_INF_IS_QUERY_LF1_UNARY:
		{
			return TestLF1Unary();
		}

		case WBEMQ_INF_IS_QUERY_CONJUNCTIVE:
		{
			return TestConjunctive();
		}

		case WBEMQ_INF_SELECT_STAR:
		{
			DWORD features=m_parser->GetFeatureFlags();
			return (features & CWQLParser::Feature_SelectAll) ? WBEM_S_NO_ERROR : WBEM_S_FALSE;
		}
		
		case WBEMQ_INF_TARGET_CLASS:
		{
			if (pv==NULL)
			{
				return WBEM_E_INVALID_PARAMETER;
			}

			return TargetClass (pv);
		}

		case WBEMQ_INF_SELECTED_PROPS:
		{
			if (pv==NULL)
			{
				return WBEM_E_INVALID_PARAMETER;
			}

		 	return SelectedProps (pv);
		}

		case WBEMQ_INF_PROP_TEST_EQ:
		{
			if (pv==NULL)
			{
				return WBEM_E_INVALID_PARAMETER;
			}

		 	return PropertyEqualityValue (pszParam, pv);
		}
	}

	return WBEM_E_INVALID_PARAMETER;
}


HRESULT CWbemQuery::TargetClass (VARIANT *pv)
{
	const SWQLNode_FromClause *pFrom=(SWQLNode_FromClause *)m_parser->GetFromClause();
	if (pFrom==NULL)
	{
		return WBEM_E_INVALID_QUERY;
	}

	const SWQLNode_TableRef *pTableRef=(SWQLNode_TableRef *)pFrom->m_pLeft;

	BSTR bstrVal=SysAllocString (pTableRef->m_pTableName);
	if (bstrVal==NULL)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	VariantInit (pv);
	pv->bstrVal=bstrVal;

	return WBEM_S_NO_ERROR;
}


HRESULT CWbemQuery::SelectedProps (VARIANT *pv)
{
	const SWQLNode_ColumnList *pColumnList=(SWQLNode_ColumnList *)m_parser->GetColumnList();
	if (pColumnList==NULL)
	{
		return WBEM_E_INVALID_QUERY;
	}

	HRESULT hr=WBEM_S_NO_ERROR;
	const CFlexArray *columns=&(pColumnList->m_aColumnRefs);
	int numcols=columns->Size();
	SAFEARRAY *paColumns=NULL;
	if (numcols>0)
	{
		SAFEARRAYBOUND bound[1];
		bound[0].lLbound=0;
		bound[0].cElements=numcols;
		
		paColumns=SafeArrayCreate (VT_BSTR, 1, bound);
		if (paColumns==NULL)
		{
			hr=WBEM_E_OUT_OF_MEMORY;
		}
		else
		{
			for (int i=0; i<numcols; i++)
			{
				const SWQLColRef *pColumn=(SWQLColRef *)columns->GetAt (i);
				BSTR bstrVal=SysAllocString (pColumn->m_pColName);
				if (bstrVal==NULL)
				{
					hr=WBEM_E_OUT_OF_MEMORY;
					break;
				}
				else
				{
					long index=i;
					hr=SafeArrayPutElement (paColumns, &index, bstrVal);
					if (FAILED(hr))
					{
						break;
					}
				}
			}
		}
	}

	if (FAILED(hr) && paColumns!=NULL)
	{
		SafeArrayDestroy (paColumns);
	}
	else
	{
		VariantInit (pv);
		pv->parray=paColumns;
	}

	return hr;
}


HRESULT CWbemQuery::TestConjunctive (void)
{
	const SWQLNode_WhereClause *pWhere=(SWQLNode_WhereClause *)m_parser->GetWhereClauseRoot();
	if (pWhere==NULL)
	{
		// No where clause.
		return WBEM_S_FALSE;
	}
	
	const SWQLNode_RelExpr *pExpr=(SWQLNode_RelExpr *)pWhere->m_pLeft;
	if (pExpr==NULL)
	{
		// No expression.
		return WBEM_S_FALSE;
	}

	// Perform an in-order traversal of expression sub-tree.
	return TestConjunctive (pExpr);
}


HRESULT CWbemQuery::TestConjunctive (const SWQLNode_RelExpr *pExpr)
{
	if (pExpr->m_dwExprType==WQL_TOK_TYPED_EXPR || pExpr->m_dwExprType==WQL_TOK_AND)
	{
		const SWQLNode_RelExpr *pLeft=(SWQLNode_RelExpr *)pExpr->m_pLeft;
		if (pLeft!=NULL && TestConjunctive (pLeft)==WBEM_S_FALSE)
		{
			return WBEM_S_FALSE;
		}

		const SWQLNode_RelExpr *pRight=(SWQLNode_RelExpr *)pExpr->m_pRight;
		if (pRight!=NULL && TestConjunctive (pRight)==WBEM_S_FALSE)
		{
			return WBEM_S_FALSE;
		}

		return WBEM_S_NO_ERROR;
	}

	return WBEM_S_FALSE;
}


HRESULT CWbemQuery::PropertyEqualityValue (LPCWSTR pszParam, VARIANT *pv)
{
	const SWQLNode_WhereClause *pWhere=(SWQLNode_WhereClause *)m_parser->GetWhereClauseRoot();
	if (pWhere==NULL)
	{
		// No where clause.
		return WBEM_E_NOT_FOUND;
	}
	
	const SWQLNode_RelExpr *pExpr=(SWQLNode_RelExpr *)pWhere->m_pLeft;
	if (pExpr==NULL)
	{
		// No expression.
		return WBEM_E_NOT_FOUND;
	}

	// Perform an in-order traversal of expression sub-tree.
	return PropertyEqualityValue (pExpr, pszParam, pv);
}


HRESULT CWbemQuery::PropertyEqualityValue (const SWQLNode_RelExpr *pExpr, LPCWSTR pszParam, VARIANT *pv)
{
	if (pExpr->m_dwExprType==WQL_TOK_TYPED_EXPR)
	{
		const SWQLTypedExpr *pTypedExpr=pExpr->m_pTypedExpr;
		if (_wcsicmp (pTypedExpr->m_pColRef, pszParam)==0)
		{
			if (pTypedExpr->m_dwRelOperator!=WQL_TOK_EQ)
			{
				return WBEM_S_FALSE;
			}
			else
			{
				VariantInit (pv);
				/// A-DAVCOO:  Need to fill the variant with the value in the pTypedExpr.
				return WBEM_S_NO_ERROR;
			}
		}
	}
	else
	{
		const SWQLNode_RelExpr *pLeft=(SWQLNode_RelExpr *)pExpr->m_pLeft;
		if (pLeft!=NULL)
		{
			HRESULT hr=PropertyEqualityValue (pLeft, pszParam, pv);
			if (hr!=WBEM_E_NOT_FOUND)
			{
				return hr;
			}
		}
		
		const SWQLNode_RelExpr *pRight=(SWQLNode_RelExpr *)pExpr->m_pRight;
		if (pRight!=NULL)
		{
			HRESULT hr=PropertyEqualityValue (pRight, pszParam, pv);
			if (hr!=WBEM_E_NOT_FOUND)
			{
				return hr;
			}
		}
	}

	return WBEM_E_NOT_FOUND;
}


HRESULT CWbemQuery::TestLF1Unary (void)
{
	const SWQLNode_FromClause *pFrom=(SWQLNode_FromClause *)m_parser->GetFromClause();
	if (pFrom!=NULL)
	{
		const SWQLNode *pLeft=pFrom->m_pLeft;
		if (pLeft->m_dwNodeType!=WBEMQ_TYPE_SWQLNode_TableRef)
		{
			return WBEM_S_FALSE;
		}
	}

	return WBEM_S_NO_ERROR;
}


HRESULT CWbemQuery::AttachClassDef( 
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pClassDef)
{
	if (pClassDef==NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	_IWmiObject *pClass=NULL;

	HRESULT hr=WBEM_E_INVALID_PARAMETER;
	if (riid==IID_IWbemClassObject)
	{
		hr=((IWbemClassObject *)pClassDef)->QueryInterface (IID__IWmiObject, (void **)&pClass);
	}
	else if (riid==IID__IWmiObject)
	{
		pClass=(_IWmiObject *)pClassDef;
		hr=pClass->AddRef();
	}

	if (SUCCEEDED(hr))
	{
		if (m_class!=NULL)
		{
			m_class->Release();
		}

		m_class=pClass;
	}

	return hr;
}


HRESULT CWbemQuery::LookupParserError (int error)
{
	switch (error)
	{
		case CWQLParser::SUCCESS:
		{
			return WBEM_S_NO_ERROR;
		}

		case CWQLParser::SYNTAX_ERROR:
		case CWQLParser::LEXICAL_ERROR:
		{
			return WBEM_E_INVALID_QUERY;
		}

		case CWQLParser::BUFFER_TOO_SMALL:
		{
			return WBEM_E_BUFFER_TOO_SMALL;
		}

		case CWQLParser::FAILED:
		case CWQLParser::INTERNAL_ERROR:
		{
			return WBEM_E_FAILED;
		}

		default:
		{
			return WBEM_E_FAILED;
		}
	}
}


__int64 CWbemQuery::GetNumeric (const SWQLTypedConst *pExpr)
{
    __int64 dRet=0;
    
    if (pExpr)
    {
        switch (pExpr->m_dwType)
        {
			case VT_LPWSTR:
			{
				dRet=_wtoi64 (pExpr->m_Value.m_pString);
				break;
			}

			case VT_I4:
			{
				dRet=pExpr->m_Value.m_lValue;
				break;
			}

			case VT_R4:
			{
				dRet=(__int64)pExpr->m_Value.m_dblValue;
				break;
			}

			case VT_BOOL:
			{
				dRet=pExpr->m_Value.m_bValue;
				break;
			}

			default:
			{
				dRet=0;
				break;
			}
        }
    }

    return dRet;
}


LPWSTR CWbemQuery::GetString (const SWQLTypedConst *pExpr)
{
    LPWSTR lpRet=NULL;
    
    if (pExpr)
    {
        switch (pExpr->m_dwType)
        {
			case VT_LPWSTR:
			{
				lpRet=new wchar_t[wcslen (pExpr->m_Value.m_pString)+1];
				wcscpy (lpRet, pExpr->m_Value.m_pString);
				break;
			}

			case VT_I4:
			{
				lpRet=new wchar_t[30];
				swprintf (lpRet, L"%ld", pExpr->m_Value.m_lValue);
				break;
			}

			case VT_R4:
			{
				lpRet=new wchar_t[30];
				swprintf (lpRet, L"%lG", pExpr->m_Value.m_dblValue);
				break;
			}

			case VT_BOOL:
			{
				lpRet=new wchar_t[30];
				swprintf (lpRet, L"%I64d", (__int64)pExpr->m_Value.m_bValue);
				break;
			}

			default:
			{
				lpRet=NULL;
				break;
			}
        }
    }

    return lpRet;
}


bool CWbemQuery::GetBoolean (const SWQLTypedConst *pExpr)
{
	return (GetNumeric (pExpr)!=0);
}


HRESULT CWbemQuery::CompareNumeric (__int64 prop, __int64 value, DWORD relation)
{
	HRESULT hr=WBEM_E_NOT_AVAILABLE;

	switch (relation)
	{
		case WQL_TOK_LE:
		{
			hr=(prop<=value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_GE:
		{
			hr=(prop>=value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_EQ:
		{
			hr=(prop==value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_NE:
		{
			hr=(prop!=value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_LT:
		{
			hr=(prop<value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_GT:
		{
			hr=(prop>value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}
	}

	return hr;
}


HRESULT CWbemQuery::CompareNumeric (unsigned __int64 prop, unsigned __int64 value, DWORD relation)
{
	HRESULT hr=WBEM_E_NOT_AVAILABLE;

	switch (relation)
	{
		case WQL_TOK_LE:
		{
			hr=(prop<=value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_GE:
		{
			hr=(prop>=value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_EQ:
		{
			hr=(prop==value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_NE:
		{
			hr=(prop!=value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_LT:
		{
			hr=(prop<value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}

		case WQL_TOK_GT:
		{
			hr=(prop>value ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
			break;
		}
	}

	return hr;
}


HRESULT CWbemQuery::CompareBoolean (bool prop, bool value, DWORD relation)
{
	return CompareNumeric ((unsigned __int64)(prop ? 1 : 0), (unsigned __int64)(value ? 1 : 0), relation);
}


HRESULT CWbemQuery::CompareString (LPWSTR prop, LPWSTR value, DWORD relation)
{
	return WBEM_E_NOT_AVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\queryparse.h ===
//***************************************************************************
//
//   (c) 2000 by Microsoft Corp.  All Rights Reserved.
//
//   queryparse.h
//
//   a-davcoo     02-Mar-00       Implements the query parser and analysis
//                                interfaces.
//
//***************************************************************************


#ifndef _QUERYPARSE_H_
#define _QUERYPARSE_H_


#include <wmiutils.h>
#include <flexarry.h>
#include "wqlnode.h"
#include "genlex.h"
#include "wql.h"
#include "wbemint.h"


class CWbemQNode : public IWbemQNode
{
	public:
		CWbemQNode (IWbemQuery *query, const SWQLNode *node);
		virtual ~CWbemQNode (void);

		virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riid, void **ppv);
		virtual ULONG STDMETHODCALLTYPE AddRef (void);
		virtual ULONG STDMETHODCALLTYPE Release (void);

		virtual HRESULT STDMETHODCALLTYPE GetNodeType( 
			/* [out] */ DWORD __RPC_FAR *pdwType);
    
		virtual HRESULT STDMETHODCALLTYPE GetNodeInfo( 
			/* [in] */ LPCWSTR pszName,
			/* [in] */ DWORD dwFlags,
			/* [in] */ DWORD dwBufSize,
			/* [out] */ LPVOID pMem);
    
		virtual HRESULT STDMETHODCALLTYPE GetSubNode( 
			/* [in] */ DWORD dwFlags,
			/* [out] */ IWbemQNode __RPC_FAR *__RPC_FAR *pSubnode);

	protected:
        long m_cRef;

		IWbemQuery *m_query;
		const SWQLNode *m_node;
};


class CWbemQuery : public IWbemQuery
{
	public:
		CWbemQuery (void);
		virtual ~CWbemQuery (void);
        void InitEmpty (void);												// Used by the CGenFactory<> class factory.

		virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riid, void **ppv);
		virtual ULONG STDMETHODCALLTYPE AddRef (void);
		virtual ULONG STDMETHODCALLTYPE Release (void);

        virtual HRESULT STDMETHODCALLTYPE Empty (void);
        
        virtual HRESULT STDMETHODCALLTYPE SetLanguageFeatures( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uArraySize,
            /* [in] */ ULONG __RPC_FAR *puFeatures);
        
        virtual HRESULT STDMETHODCALLTYPE TestLanguageFeature(
            /* [in,out] */ ULONG *uArraySize,
            /* [out] */ ULONG *puFeatures);
        
        virtual HRESULT STDMETHODCALLTYPE Parse( 
            /* [in] */ LPCWSTR pszLang,
            /* [in] */ LPCWSTR pszQuery,
            /* [in] */ ULONG uFlags);
        
        virtual HRESULT STDMETHODCALLTYPE GetAnalysis( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pObj);
        
        virtual HRESULT STDMETHODCALLTYPE TestObject( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pObj);
        
        virtual HRESULT STDMETHODCALLTYPE GetQueryInfo( 
            /* [in] */ ULONG uInfoId,
            /* [in] */ LPCWSTR pszParam,
            /* [out] */ VARIANT __RPC_FAR *pv);
        
        virtual HRESULT STDMETHODCALLTYPE AttachClassDef( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pClassDef);

	protected:
        long m_cRef;

		CWQLParser *m_parser;
		_IWmiObject *m_class;

		HRESULT TestObject (_IWmiObject *pObject);
		HRESULT TestObject (_IWmiObject *pObject, const SWQLNode_RelExpr *pExpr);
		HRESULT TestExpression (_IWmiObject *pObject, const SWQLTypedExpr *pExpr);
		HRESULT TargetClass (VARIANT *pv);
		HRESULT SelectedProps (VARIANT *pv);
		HRESULT TestConjunctive (void);
		HRESULT TestConjunctive (const SWQLNode_RelExpr *pExpr);
		HRESULT PropertyEqualityValue (LPCWSTR pszParam, VARIANT *pv);
		HRESULT PropertyEqualityValue (const SWQLNode_RelExpr *pExpr, LPCWSTR pszParam, VARIANT *pv);
		HRESULT TestLF1Unary (void);
		HRESULT GetAnalysis (IWbemQNode **ppObject);
		HRESULT GetAnalysis (IWbemClassObject **pObject);

		static HRESULT LookupParserError (int error);

		static __int64 GetNumeric (const SWQLTypedConst *pExpr);
		static LPWSTR GetString (const SWQLTypedConst *pExpr);
		static bool GetBoolean (const SWQLTypedConst *pExpr);

		HRESULT CompareNumeric (__int64 prop, __int64 value, DWORD relation);
		HRESULT CompareNumeric (unsigned __int64 prop, unsigned __int64 value, DWORD relation);
		HRESULT CompareBoolean (bool prop, bool value, DWORD relation);
		HRESULT CompareString (LPWSTR prop, LPWSTR value, DWORD relation);
};


#endif // _QUERYPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\ql.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QL.CPP

Abstract:

    WMI Public Query Parser

    Supported features:
        LF1     Basic select
        LF2     __CLASS
        LF3     Upper/Lower
        LF4     Prop-to-prop tests
        LF6     ORDER BY
        LF8     ISA, ISNOTA
        LF9     __THIS
        LF12    GROUP BY ... HAVING
        LF17    Qualified Names
        LF18    Associations/References
        LF25    DatePart
        LF26    LIKE
        LF27    CIM Temporal Constructs
        LF31    __Qualifier
        LF36    Reference property tests

History:

    raymcc      21-Jun-96       Created.
    raymcc      11-Apr-00       Updated for WMIUTILS.DLL


--*/

#include "precomp.h"
#include <stdio.h>
#include <errno.h>

#include <math.h>

#include <corepol.h>
#include <genlex.h>
#include <qllex.h>
#include <ql.h>
#include <wbemcomn.h>
#include <wbemutil.h>
#include <genutils.h>

#define trace(x) //printf x

WBEM_WSTR WbemStringAlloc(unsigned long lNumChars)
{
    return (WBEM_WSTR)CoTaskMemAlloc(lNumChars+1);
}

void WbemStringFree(WBEM_WSTR String)
{
    CoTaskMemFree(String);
}

unsigned long WbemStringLen(const WCHAR* String)
{
    return wcslen(String);
}

WBEM_WSTR WbemStringCopy(const WCHAR* String)
{
    if(String == NULL) return NULL;
    WBEM_WSTR NewString = (WBEM_WSTR)CoTaskMemAlloc(2*(wcslen(String)+1));
    if(NewString == NULL) return NULL;
    wcscpy(NewString, String);
    return NewString;
}

//***************************************************************************
//
//  WCHARToDOUBLE
//
//  Converts a wchar to a double, but does it using the english locale rather
//  than whatever local the process is running in.  This allows us to support
//  all english queries even on German machines.
//
//***************************************************************************

DOUBLE WCHARToDOUBLE(WCHAR * pConv, bool & bSuccess)
{
    bSuccess = false;
    if(pConv == NULL)
        return 0.0;

    VARIANT varTo, varFrom;
    VariantInit(&varTo);
    varFrom.vt = VT_BSTR;
    varFrom.bstrVal = SysAllocString(pConv);
    if(varFrom.bstrVal == NULL)
        return 0.0;
    SCODE sc = VariantChangeTypeEx(&varTo, &varFrom, 0x409, 0, VT_R8);
    VariantClear(&varFrom);
    if(sc == S_OK)
        bSuccess = true;
    return varTo.dblVal;
}

CPropertyName::CPropertyName(const CPropertyName& Other)
{
    Init();
    *this = Other;
}

void CPropertyName::Init()
{
    m_lNumElements = 0;
    m_lAllocated = 0;
    m_aElements = NULL;
}

void CPropertyName::operator=(const CPropertyName& Other)
{
    *this = (const WBEM_PROPERTY_NAME&)Other;
}

void CPropertyName::operator=(const WBEM_PROPERTY_NAME& Other)
{
    Empty();
//    delete [] m_aElements;
    m_lNumElements = Other.m_lNumElements;
    m_lAllocated = m_lNumElements;
    if(m_lNumElements > 0)
        m_aElements = new WBEM_NAME_ELEMENT[m_lNumElements];

    for(long l = 0; l < m_lNumElements; l++)
    {
        m_aElements[l].m_nType = Other.m_aElements[l].m_nType;
        if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            m_aElements[l].Element.m_wszPropertyName =
                WbemStringCopy(Other.m_aElements[l].Element.m_wszPropertyName);
        }
        else
        {
            m_aElements[l].Element.m_lArrayIndex =
                Other.m_aElements[l].Element.m_lArrayIndex;
        }
    }
}

BOOL CPropertyName::operator==(const WBEM_PROPERTY_NAME& Other)
{
    if(m_lNumElements != Other.m_lNumElements)
        return FALSE;

    for(long l = 0; l < m_lNumElements; l++)
    {
        if(m_aElements[l].m_nType != Other.m_aElements[l].m_nType)
            return FALSE;
        if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            if(wbem_wcsicmp(m_aElements[l].Element.m_wszPropertyName,
                        Other.m_aElements[l].Element.m_wszPropertyName))
            {
                return FALSE;
            }
        }
        else
        {
            if(m_aElements[l].Element.m_lArrayIndex !=
                Other.m_aElements[l].Element.m_lArrayIndex)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

void CPropertyName::Empty()
{
    for(long l = 0; l < m_lNumElements; l++)
    {
        if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            WbemStringFree(m_aElements[l].Element.m_wszPropertyName);
        }
    }
    delete [] m_aElements;
    m_aElements = NULL;
    m_lNumElements = 0;
    m_lAllocated = 0;
}

LPCWSTR CPropertyName::GetStringAt(long lIndex) const
{
    if(m_aElements[lIndex].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return m_aElements[lIndex].Element.m_wszPropertyName;
    }
    else return NULL;
}

void CPropertyName::AddElement(LPCWSTR wszElement)
{
    EnsureAllocated(m_lNumElements+1);
    m_aElements[m_lNumElements].m_nType = WBEM_NAME_ELEMENT_TYPE_PROPERTY;
    m_aElements[m_lNumElements].Element.m_wszPropertyName =
        WbemStringCopy(wszElement);
    m_lNumElements++;
}

void CPropertyName::EnsureAllocated(long lElements)
{
    if(m_lAllocated < lElements)
    {
        m_lAllocated = lElements+5;

        WBEM_NAME_ELEMENT* pTemp = new WBEM_NAME_ELEMENT[m_lAllocated];
        memcpy(pTemp, m_aElements, sizeof(WBEM_NAME_ELEMENT) * m_lNumElements);
        delete [] m_aElements;
        m_aElements = pTemp;
    }
}

DELETE_ME LPWSTR CPropertyName::GetText()
{
    WString wsText;
    for(int i = 0; i < m_lNumElements; i++)
    {
        if(m_aElements[i].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            return NULL;
        if(i > 0)
            wsText += L".";
        wsText += m_aElements[i].Element.m_wszPropertyName;
    }
    return wsText.UnbindPtr();
}




//***************************************************************************
//***************************************************************************


DWORD CAbstractQl1Parser::TranslateIntrinsic(LPCWSTR pFuncName)
{
    if (wbem_wcsicmp(pFuncName, L"UPPER") == 0)
        return QL1_FUNCTION_UPPER;
    if (wbem_wcsicmp(pFuncName, L"LOWER") == 0)
        return QL1_FUNCTION_LOWER;
    return QL1_FUNCTION_NONE;
}

void CAbstractQl1Parser::InitToken(WBEM_QL1_TOKEN* pToken)
{
    pToken->m_lTokenType = QL1_NONE;
    pToken->m_PropertyName.m_lNumElements = 0;
    pToken->m_PropertyName.m_aElements = NULL;

    pToken->m_PropertyName2.m_lNumElements = 0;
    pToken->m_PropertyName2.m_aElements = NULL;

    VariantInit(&pToken->m_vConstValue);
}


CAbstractQl1Parser::CAbstractQl1Parser(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(Ql_1_LexTable, pSrc);
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
    m_PropertyName2.m_lNumElements = 0;
    m_PropertyName2.m_aElements = NULL;
    m_bPropComp = FALSE;
}

CAbstractQl1Parser::~CAbstractQl1Parser()
{
    VariantClear(&m_vTypedConst);
    DeletePropertyName();
    delete m_pLexer;
}


int CAbstractQl1Parser::Parse(CQl1ParseSink* pSink, int nFlags)
{
    m_pSink = pSink;
    int nRes = parse(nFlags);
    m_pSink = NULL;
    return nRes;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL CAbstractQl1Parser::Next(int nFlags)
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == QL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == QL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == QL_1_TOK_IDENT && nFlags != NO_KEYWORDS)
    {
        if (wbem_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = QL_1_TOK_SELECT;
        else if (wbem_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = QL_1_TOK_FROM;
        else if (wbem_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = QL_1_TOK_WHERE;
/*
        else if (wbem_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = QL_1_TOK_LIKE;
*/
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = QL_1_TOK_OR;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = QL_1_TOK_AND;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = QL_1_TOK_NOT;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = QL_1_TOK_IS;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = QL_1_TOK_NULL;
        else if (wbem_wcsicmp(m_pTokenText, L"WITHIN") == 0)
            m_nCurrentToken = QL_1_TOK_WITHIN;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"ISA") == 0)
            m_nCurrentToken = QL_1_TOK_ISA;
        else if (nFlags != EXCLUDE_GROUP_KEYWORD && wbem_wcsicmp(m_pTokenText, L"GROUP") == 0)
            m_nCurrentToken = QL_1_TOK_GROUP;
        else if (wbem_wcsicmp(m_pTokenText, L"BY") == 0)
            m_nCurrentToken = QL_1_TOK_BY;
        else if (wbem_wcsicmp(m_pTokenText, L"HAVING") == 0)
            m_nCurrentToken = QL_1_TOK_HAVING;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"TRUE") == 0)
            m_nCurrentToken = QL_1_TOK_TRUE;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"FALSE") == 0)
            m_nCurrentToken = QL_1_TOK_FALSE;
    }

    return TRUE;
}

LPCWSTR CAbstractQl1Parser::GetSinglePropertyName()
{
    if(m_PropertyName.m_lNumElements < 1)
        return NULL;

    if(m_PropertyName.m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        return NULL;

    return m_PropertyName.m_aElements[0].Element.m_wszPropertyName;
}

void CAbstractQl1Parser::DeletePropertyName()
{
    for(long l = 0; l < m_PropertyName.m_lNumElements; l++)
    {
        if(m_PropertyName.m_aElements[l].m_nType ==
                                             WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            WbemStringFree(m_PropertyName.m_aElements[l].
                                Element.m_wszPropertyName);
        }
    }
    delete [] m_PropertyName.m_aElements;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
}

int CAbstractQl1Parser::FlipOperator(int nOp)
{
    switch(nOp)
    {
    case QL1_OPERATOR_EQUALS:
        return QL1_OPERATOR_EQUALS;

    case QL1_OPERATOR_NOTEQUALS:
        return QL1_OPERATOR_NOTEQUALS;

    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESS;

    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATER;

    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATEROREQUALS;

    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_LIKE:
        return QL1_OPERATOR_LIKE;

    case QL1_OPERATOR_UNLIKE:
        return QL1_OPERATOR_UNLIKE;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_INV_ISA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_ISNOTA;

    default:
        return nOp;
    }
}

void CAbstractQl1Parser::AddAppropriateToken(const WBEM_QL1_TOKEN& Token)
{
    if(m_bInAggregation)
        m_pSink->AddHavingToken(Token);
    else
        m_pSink->AddToken(Token);
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int CAbstractQl1Parser::parse(int nFlags)
{
    int nRes;

    m_bInAggregation = FALSE;
    if(nFlags != JUST_WHERE)
    {
        m_pLexer->Reset();

        // SELECT
        // ======
        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != QL_1_TOK_SELECT)
            return SYNTAX_ERROR;
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        // <prop_list>
        // ===========
        if (nRes = prop_list())
            return nRes;

        // FROM
        // ====
        if (m_nCurrentToken != QL_1_TOK_FROM)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;

        // <classname>
        // ===========
        if (nRes = class_name())
            return nRes;

        // <tolerance>
        // ===========

        if(nRes = tolerance())
            return nRes;
    }

    if(nFlags != NO_WHERE)
    {
        // WHERE clause.
        // =============
        if(nRes = opt_where())
            return nRes;

        // GROUP BY clause
        // ===============
        if(nRes = opt_aggregation())
            return nRes;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int CAbstractQl1Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == QL_1_TOK_EOF || m_nCurrentToken == QL_1_TOK_GROUP)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != QL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is QL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != QL_1_TOK_EOF && m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != QL_1_TOK_ASTERISK &&
        m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list_2()
{
    if (m_nCurrentToken == QL_1_TOK_COMMA)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


int CAbstractQl1Parser::parse_property_name(CPropertyName& Prop)
{
    Prop.Empty();

    int nCount = 0;
    while(m_nCurrentToken == QL_1_TOK_IDENT)
    {
        Prop.AddElement(m_pTokenText);
        nCount++;

        if(!Next())
            return LEXICAL_ERROR;

        if(m_nCurrentToken != QL_1_TOK_DOT)
            break;

        if(!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
    }
    if (nCount)
        return SUCCESS;
    else
        return SYNTAX_ERROR;
}

//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int CAbstractQl1Parser::property_name()
{
    if (m_nCurrentToken == QL_1_TOK_ASTERISK)
    {
        trace(("Asterisk\n"));

        if(m_bInAggregation)
            m_pSink->AddAllAggregationProperties();
        else
            m_pSink->AddAllProperties();

        if(!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // Else a list of property names
    // =============================

    CPropertyName Prop;
    int nRes = parse_property_name(Prop);
    if(nRes != SUCCESS)
        return nRes;

    if(m_bInAggregation)
        m_pSink->AddAggregationProperty(Prop);
    else
        m_pSink->AddProperty(Prop);

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int CAbstractQl1Parser::class_name()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pSink->SetClassName(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <tolerance> ::= <>;
//  <tolerance> ::= WITHIN duration;
//
//***************************************************************************

int CAbstractQl1Parser::tolerance()
{
    LPWSTR wszGarbage;
    WBEM_QL1_TOLERANCE Tolerance;
    if(m_nCurrentToken != QL_1_TOK_WITHIN)
    {
        Tolerance.m_bExact = TRUE;
        m_pSink->SetTolerance(Tolerance);
        return SUCCESS;
    }

    if(!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        Tolerance.m_bExact = FALSE;
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(Tolerance.m_fTolerance <= 0 || bSuccess == false)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_bExact = FALSE;
        Tolerance.m_fTolerance = wcstol(m_pTokenText, &wszGarbage, 10);
        if(Tolerance.m_fTolerance < 0)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int CAbstractQl1Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int CAbstractQl1Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_OR)
        {
            trace(("Token OR\n"));
            m_pSink->InOrder(QL1_OR);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_OR;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int CAbstractQl1Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_AND)
        {
            trace(("Token AND\n"));
            m_pSink->InOrder(QL1_AND);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_AND;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        WBEM_QL1_TOKEN NewTok;
        InitToken(&NewTok);
        NewTok.m_lTokenType = QL1_NOT;
        AddAppropriateToken(NewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == QL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != QL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == QL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        if(nRes = parse_property_name(m_PropertyName))
            return nRes;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == QL_1_TOK_INT ||
             m_nCurrentToken == QL_1_TOK_REAL ||
             m_nCurrentToken == QL_1_TOK_TRUE ||
             m_nCurrentToken == QL_1_TOK_FALSE ||
             m_nCurrentToken == QL_1_TOK_NULL ||
             m_nCurrentToken == QL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        // dont allow const followed by isa!

        if(m_nRelOp == QL1_OPERATOR_ISA)
            return SYNTAX_ERROR;

        // Since we always view the token as IDENT <rel> constant, we need
        // to invert this operator, e.g. replace > with <
        // ================================================================

        m_nRelOp = FlipOperator(m_nRelOp);

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    int nRes = parse_property_name(m_PropertyName);
    return nRes;
}

//***************************************************************************
//
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::leading_ident_expr()
{
    int nRes;
    if (SUCCESS ==  comp_operator())
    {
        return trailing_const_expr();
    }
    else if(SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != QL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
    {
        V_VT(&m_vTypedConst) = VT_NULL;
        return SUCCESS;
    }
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//
//***************************************************************************

int CAbstractQl1Parser::trailing_or_null()
{
    if (m_nCurrentToken == QL_1_TOK_NULL)
    {
        if (!Next())
            return LEXICAL_ERROR;
        else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
            return SUCCESS;
        }
    }
    return trailing_const_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//  <trailing_const_expr> ::= <trailing_ident_expr>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_const_expr()
{
    int nRes;
    nRes = typed_constant();
    if (nRes != SUCCESS)
        nRes = trailing_ident_expr();
    return nRes;
}

//***************************************************************************
//
//  <trailing_ident_expr> ::= <property_name>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_ident_expr()
{
    int nRes = parse_property_name(m_PropertyName2) ;
    if (nRes == SUCCESS)
        m_bPropComp = TRUE;
    return nRes;
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the QL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int CAbstractQl1Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================

    WBEM_QL1_TOKEN NewTok;
    InitToken(&NewTok);

    NewTok.m_lTokenType = QL1_OP_EXPRESSION;
    VariantInit(&NewTok.m_vConstValue);

    memcpy((void*)&NewTok.m_PropertyName,
           (void*)&m_PropertyName,
           sizeof m_PropertyName);

    if (m_bPropComp)
    {
        NewTok.m_bPropComp = true;
        memcpy((void*)&NewTok.m_PropertyName2,
               (void*)&m_PropertyName2,
               sizeof m_PropertyName2);
    }
    else
    {
        NewTok.m_bPropComp = false;
        VariantCopy(&NewTok.m_vConstValue, &m_vTypedConst);
    }

    NewTok.m_lOperator = m_nRelOp;
    NewTok.m_lPropertyFunction = m_dwPropFunction;
    NewTok.m_lConstFunction = m_dwConstFunction;
    NewTok.m_bQuoted = m_bQuoted;

    AddAppropriateToken(NewTok);

//    m_PropertyName.m_lNumElements = 0;
//    m_PropertyName.m_aElements = NULL;
    m_PropertyName.Empty();
    m_PropertyName2.Empty();

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    VariantClear(&NewTok.m_vConstValue);
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_bPropComp = FALSE;

    return SUCCESS;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int CAbstractQl1Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
    m_bQuoted = FALSE;

    if (m_nCurrentToken == QL_1_TOK_INT)
    {
        trace((" Integer\n"));

        // Read it in as a 64-bit one
        // ==========================

        __int64 i64;
        unsigned __int64 ui64;
        BOOL b32bits = FALSE;
        if(ReadI64(m_pTokenText, i64))
        {
            // Check if it is within range of I4
            // =================================

            if(i64 >= - (__int64)0x80000000 && i64 <= 0x7FFFFFFF)
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = (long)i64;
                b32bits = TRUE;
            }
        }
        else if(!ReadUI64(m_pTokenText, ui64))
        {
            // Not a valid number
            // ==================

            return LEXICAL_ERROR;
        }

        if(!b32bits)
        {
            // Valid 64-bit number but not 32-bit
            // ==================================

            V_VT(&m_vTypedConst) = VT_BSTR;
            V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
            m_bQuoted = FALSE;
        }
    }
    else if (m_nCurrentToken == QL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
        m_bQuoted = TRUE;
    }
    else if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        trace((" Real\n"));
        V_VT(&m_vTypedConst) = VT_R8;
        bool bSuccess;
        V_R8(&m_vTypedConst) = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(bSuccess == false)
            return LEXICAL_ERROR;
    }
    else if(m_nCurrentToken == QL_1_TOK_TRUE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_TRUE;
    }
    else if(m_nCurrentToken == QL_1_TOK_FALSE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_FALSE;
    }
    else if (m_nCurrentToken == QL_1_TOK_NULL)
        V_VT(&m_vTypedConst) = VT_NULL;

    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>;
//  <rel_operator> ::= <comp_operator>;
//
//***************************************************************************

int CAbstractQl1Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == QL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != QL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
        return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_GREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else if (m_nCurrentToken == QL_1_TOK_ISA)
    {
        trace(("    REL OP 'isa' \n"));
        m_nRelOp = QL1_OPERATOR_ISA;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::opt_aggregation()
{
    if(m_nCurrentToken == QL_1_TOK_EOF)
        return SUCCESS;

    if(m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    m_pSink->SetAggregated();

    int nRes = aggregation_params();
    if(nRes)
        return nRes;

    if(nRes = opt_having())
        return nRes;

    // Make sure we've reached the end
    // ===============================

    if(m_nCurrentToken != QL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::aggregation_params()
{
    int nRes;
    WBEM_QL1_TOLERANCE Exact;
    Exact.m_bExact = TRUE;

    if(m_nCurrentToken == QL_1_TOK_BY)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        if(nRes = aggregate_by())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_WITHIN)
        {
            if (!Next())
                return LEXICAL_ERROR;

            if(nRes = aggregate_within())
                return nRes;
        }
        else
        {
            m_pSink->SetAggregationTolerance(Exact);
        }
    }
    else if(m_nCurrentToken == QL_1_TOK_WITHIN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        if(nRes = aggregate_within())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_BY)
        {
            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if(nRes = aggregate_by())
                return nRes;
        }
    }
    else
    {
        return SYNTAX_ERROR;
    }

    return SUCCESS;
}

int CAbstractQl1Parser::aggregate_within()
{
    WBEM_QL1_TOLERANCE Tolerance;
    Tolerance.m_bExact = FALSE;
    LPWSTR wszGarbage;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(!bSuccess)
            return SYNTAX_ERROR;
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_fTolerance = (double)wcstol(m_pTokenText, &wszGarbage, 10);
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

int CAbstractQl1Parser::aggregate_by()
{
    m_bInAggregation = TRUE;
    int nRes = prop_list();
    m_bInAggregation = FALSE;
    return nRes;
}

int CAbstractQl1Parser::opt_having()
{
    if(m_nCurrentToken == QL_1_TOK_HAVING)
    {
        if(!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        m_bInAggregation = TRUE;
        int nRes = expr();
        m_bInAggregation = FALSE;
        return nRes;
    }
    else return SUCCESS;
}


//***************************************************************************
//***************************************************************************
//
//  class QL1_Parser
//
//  A derivative of CAbstractQlParser for backward compatibility
//
//***************************************************************************
//
//

QL1_Parser::QL1_Parser(CGenLexSource *pSrc)
    : m_pExpression(NULL), CAbstractQl1Parser(pSrc), m_bPartiallyParsed(FALSE)
{
    m_pExpression = new QL_LEVEL_1_RPN_EXPRESSION;
}

QL1_Parser::~QL1_Parser()
{
    delete m_pExpression;
}

int QL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    // Get the underlying parser to parse the first part of the query
    // ==============================================================

    if(!m_bPartiallyParsed)
    {
        int nRes = CAbstractQl1Parser::Parse(m_pExpression, NO_WHERE);
        if(nRes != SUCCESS) return nRes;
    }

    if (!m_pExpression->bsClassName)
        return SYNTAX_ERROR;

    m_bPartiallyParsed = TRUE;
    if(wcslen(m_pExpression->bsClassName) >= (unsigned int)nBufLen)
        return BUFFER_TOO_SMALL;

    wcscpy(pDestBuf, m_pExpression->bsClassName);
    return WBEM_S_NO_ERROR;
}

int QL1_Parser::Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    // Get the underying parser to completely parse the query. If
    // GetQueryClass was called in the past, no sense in duplcating
    // the work
    // ============================================================

    int nRes = CAbstractQl1Parser::Parse(m_pExpression,
        m_bPartiallyParsed?JUST_WHERE:FULL_PARSE);
    *pOutput = m_pExpression;
    m_pExpression = new QL_LEVEL_1_RPN_EXPRESSION;
    m_bPartiallyParsed = FALSE;

    return nRes;
}

DELETE_ME LPWSTR QL1_Parser::ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                                LPCWSTR wszClassName)
{
    QL_LEVEL_1_RPN_EXPRESSION NewExpr(*pExpr);

    if (NewExpr.bsClassName)
        SysFreeString(NewExpr.bsClassName);
    NewExpr.bsClassName = SysAllocString(wszClassName);

    LPWSTR wszNewQuery = NewExpr.GetText();
    return wszNewQuery;
}


//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    bsClassName = 0;
    nNumberOfProperties = 0;
    bStar = FALSE;
    pRequestedPropertyNames = 0;
    nCurSize = 1;
    nCurPropSize = 1;
    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    pRequestedPropertyNames = new CPropertyName[nCurPropSize];

    bAggregated = FALSE;
    bAggregateAll = FALSE;
    nNumAggregatedProperties = 0;
    nCurAggPropSize = 1;
    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];

    nNumHavingTokens = 0;
    nCurHavingSize = 1;
    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];

    lRefCount = 0;
}

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION(
                                const QL_LEVEL_1_RPN_EXPRESSION& Other)
{
    nNumTokens = Other.nNumTokens;
    bsClassName = SysAllocString(Other.bsClassName);
    nNumberOfProperties = Other.nNumberOfProperties;
    bStar = Other.bStar;
    pRequestedPropertyNames = 0;
    nCurSize = Other.nCurSize;
    nCurPropSize = Other.nCurPropSize;

    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    int i;
    for(i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i] = Other.pArrayOfTokens[i];

    pRequestedPropertyNames = new CPropertyName[nCurPropSize];
    for(i = 0; i < nNumberOfProperties; i++)
        pRequestedPropertyNames[i] = Other.pRequestedPropertyNames[i];

    bAggregated = Other.bAggregated;
    bAggregateAll = Other.bAggregateAll;
    nNumAggregatedProperties = Other.nNumAggregatedProperties;
    nCurAggPropSize = Other.nCurAggPropSize;

    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];
    for(i = 0; i < nNumAggregatedProperties; i++)
        pAggregatedPropertyNames[i] = Other.pAggregatedPropertyNames[i];

    nNumHavingTokens = Other.nNumHavingTokens;
    nCurHavingSize = Other.nCurHavingSize;

    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];
    for(i = 0; i < nNumHavingTokens; i++)
        pArrayOfHavingTokens[i] = Other.pArrayOfHavingTokens[i];

    lRefCount = 0;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddRef()
{
    InterlockedIncrement(&lRefCount);
}

void QL_LEVEL_1_RPN_EXPRESSION::Release()
{
    if(InterlockedDecrement(&lRefCount) == 0)
        delete this;
}


QL_LEVEL_1_RPN_EXPRESSION::~QL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    delete [] pAggregatedPropertyNames;
    delete [] pArrayOfHavingTokens;
    delete [] pRequestedPropertyNames;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetClassName(LPCWSTR wszClassName)
{
    bsClassName = SysAllocString(wszClassName);
}

void QL_LEVEL_1_RPN_EXPRESSION::SetTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    Tolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregationTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    AggregationTolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(
                                  const WBEM_QL1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;
        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];
        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(
                                  const QL_LEVEL_1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;
        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];
        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddHavingToken(
                                  const WBEM_QL1_TOKEN& Tok)
{
    if (nCurHavingSize == nNumHavingTokens)
    {
        nCurHavingSize += 1;
        nCurHavingSize *= 2;
        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurHavingSize];
        for (int i = 0; i < nNumHavingTokens; i++)
            pTemp[i] = pArrayOfHavingTokens[i];
        delete [] pArrayOfHavingTokens;
        pArrayOfHavingTokens = pTemp;
    }

    pArrayOfHavingTokens[nNumHavingTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddProperty(const CPropertyName& Prop)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 1;
        nCurPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurPropSize];
        for(int i = 0; i < nNumberOfProperties; i++)
            pTemp[i] = pRequestedPropertyNames[i];
        delete [] pRequestedPropertyNames;
        pRequestedPropertyNames = pTemp;
    }

    pRequestedPropertyNames[nNumberOfProperties++] = Prop;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllProperties()
{
    bStar = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregated()
{
    bAggregated = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAggregationProperty(
                                    const CPropertyName& Property)
{
    if(pAggregatedPropertyNames == NULL)
    {
        // '*' requested
        return;
    }
    if (nCurAggPropSize == nNumAggregatedProperties)
    {
        nCurAggPropSize += 1;
        nCurAggPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurAggPropSize];
        for(int i = 0; i < nNumAggregatedProperties; i++)
            pTemp[i] = pAggregatedPropertyNames[i];
        delete [] pAggregatedPropertyNames;
        pAggregatedPropertyNames = pTemp;
    }

    pAggregatedPropertyNames[nNumAggregatedProperties++] = Property;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllAggregationProperties()
{
    bAggregateAll = TRUE;
}

DELETE_ME LPWSTR QL_LEVEL_1_RPN_EXPRESSION::GetText()
{
    WString wsText;

    wsText += L"select ";
    for(int i = 0; i < nNumberOfProperties; i++)
    {
        if(i != 0) wsText += L", ";
        wsText += (LPWSTR)pRequestedPropertyNames[i].GetStringAt(0);
    }
    if(bStar)
    {
        if(nNumberOfProperties > 0)
            wsText += L", ";
        wsText += L"*";
    }

    wsText += L" from ";
    if (bsClassName)
        wsText += bsClassName;

    if(nNumTokens > 0)
    {
        wsText += L" where ";

        CWStringArray awsStack;
        for(int i = 0; i < nNumTokens; i++)
        {
            QL_LEVEL_1_TOKEN& Token = pArrayOfTokens[i];
            LPWSTR wszTokenText = Token.GetText();
            if(Token.nTokenType == QL1_OP_EXPRESSION)
            {
                awsStack.Add(wszTokenText);
                delete [] wszTokenText;
            }
            else if(Token.nTokenType == QL1_NOT)
            {
                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                WString wsNew;
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" (";
                wsNew += wszLast;
                wsNew += L")";
                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.Add(wsNew);
            }
            else
            {
                if(awsStack.Size() < 2) return NULL;

                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                LPWSTR wszPrev = awsStack[awsStack.Size()-2];

                WString wsNew;
                wsNew += L"(";
                wsNew += wszPrev;
                wsNew += L" ";
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" ";
                wsNew += wszLast;
                wsNew += L")";

                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.RemoveAt(awsStack.Size()-1); //pop

                awsStack.Add(wsNew);
            }
        }

        if(awsStack.Size() != 1) return NULL;
        wsText += awsStack[0];
    }

    return wsText.UnbindPtr();
}

void QL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pRequestedPropertyNames[i].GetStringAt(0));
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;

    *this = Src;
}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const QL_LEVEL_1_TOKEN &Src)
{
    nTokenType = Src.nTokenType;
    PropertyName = Src.PropertyName;
    if (Src.m_bPropComp)
        PropertyName2 = Src.PropertyName2;
    nOperator = Src.nOperator;
    VariantCopy(&vConstValue, (VARIANT*)&Src.vConstValue);
    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
    bQuoted = Src.bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;

}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const WBEM_QL1_TOKEN &Src)
{
    nTokenType = Src.m_lTokenType;
    PropertyName = Src.m_PropertyName;
    if (Src.m_bPropComp)
        PropertyName2 = Src.m_PropertyName2;
    nOperator = Src.m_lOperator;
    VariantCopy(&vConstValue, (VARIANT*)&Src.m_vConstValue);
    dwPropertyFunction = Src.m_lPropertyFunction;
    dwConstFunction = Src.m_lConstFunction;
    bQuoted = Src.m_bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;
}

QL_LEVEL_1_TOKEN::~QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantClear(&vConstValue);
}

DELETE_ME LPWSTR QL_LEVEL_1_TOKEN::GetText()
{
    WString wsText;
    LPWSTR wszPropName;
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            wszPropName = PropertyName.GetText();
            wsText += wszPropName;
            delete [] wszPropName;
            wsText += L" ";

            WCHAR* wszOp;
            switch (nOperator)
            {
            case OP_EQUAL: wszOp = L"="; break;
            case OP_NOT_EQUAL: wszOp = L"<>"; break;
            case OP_EQUALorGREATERTHAN: wszOp = L">="; break;
            case OP_EQUALorLESSTHAN: wszOp = L"<="; break;
            case OP_LESSTHAN: wszOp = L"<"; break;
            case OP_GREATERTHAN: wszOp = L">"; break;
            case OP_LIKE: wszOp = L"LIKE"; break;
            case QL1_OPERATOR_ISA: wszOp = L"ISA"; break;
            default: wszOp = NULL;
            }
            if(wszOp)
                wsText += wszOp;
            wsText += L" ";

            if (m_bPropComp)
            {
                // property comparison (e.g., prop1 > prop2)
                wszPropName = PropertyName2.GetText();
                wsText += wszPropName;
                delete [] wszPropName;
            }
            else
            {
                // expression with constant (e.g., prop1 > 5)
                WCHAR wszConst[100];
                switch (V_VT(&vConstValue))
                {
                case VT_NULL:
                    wsText += L"NULL";
                    break;
                case VT_I4:
                    swprintf(wszConst, L"%d", V_I4(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_I2:
                    swprintf(wszConst, L"%d", (int)V_I2(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_UI1:
                    swprintf(wszConst, L"%d", (int)V_UI1(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_BSTR:
                {
                    if(bQuoted)
                        wsText += L"\"";
                    //If we need to parse the string we do it the hard way
                    WCHAR* pwc = V_BSTR(&vConstValue);
                    BOOL bLongMethod = FALSE;
                    for (int tmp = 0; pwc[tmp]; tmp++)
                        if ((pwc[tmp] == L'\\') || (pwc[tmp] == L'"'))
                            bLongMethod = TRUE;
                    if (bLongMethod)
                    {
                        for(pwc; *pwc; pwc++)
                        {
                            if(*pwc == L'\\' || *pwc == L'"')
                                wsText += L'\\';
                            wsText += *pwc;
                        }
                    }
                    else
                    {
                        //otherwise we do it the fast way...
                        wsText += pwc;
                    }
                    if(bQuoted)
                        wsText += L"\"";
                }
                    break;
                case VT_R4:
                    swprintf(wszConst, L"%G", V_R4(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_R8:
                    swprintf(wszConst, L"%lG", V_R8(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_BOOL:
                    wsText += (V_BOOL(&vConstValue)?L"TRUE":L"FALSE");
                    break;
                }
            }

            break;
        case TOKEN_AND:
            wsText = "AND";
            break;
        case TOKEN_OR:
            wsText = "OR";
            break;
        case TOKEN_NOT:
            wsText = "NOT";
            break;
    }

    return wsText.UnbindPtr();
}

void QL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        LPWSTR wszPropName = PropertyName.GetText();
        fprintf(f, "    Property = %S\n", wszPropName);
        delete [] wszPropName;
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");

        if (m_bPropComp)
        {
            wszPropName = PropertyName2.GetText();
            fprintf(f, "   <Property:%S>\n", wszPropName);
            delete [] wszPropName;
        }
        else
        {
            switch (V_VT(&vConstValue))
            {
                case VT_I4:
                    fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                    break;
                case VT_I2:
                    fprintf(f, "VT_I2 = %d\n", (int)V_I2(&vConstValue));
                    break;
                case VT_UI1:
                    fprintf(f, "VT_UI1 = %d\n", (int)V_UI1(&vConstValue));
                    break;
                case VT_BSTR:
                    fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                    break;
                case VT_R4:
                    fprintf(f, "VT_R4 = %f\n", V_R4(&vConstValue));
                    break;
                case VT_R8:
                    fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                    break;
                case VT_BOOL:
                    fprintf(f, "%S\n", V_BOOL(&vConstValue)?L"TRUE":L"FALSE");
                    break;
                case VT_NULL:
                    fprintf(f, "%S\n", L"NULL");
                    break;
                default:
                    fprintf(f, "<unknown>\n");
            }

            switch (dwPropertyFunction)
            {
                case IFUNC_NONE:
                    break;
                case IFUNC_LOWER:
                    fprintf(f, "Intrinsic function LOWER() applied to property\n");
                    break;
                case IFUNC_UPPER:
                    fprintf(f, "Intrinsic function UPPER() applied to property\n");
                    break;
            }
            switch (dwConstFunction)
            {
                case IFUNC_NONE:
                    break;
                case IFUNC_LOWER:
                    fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                    break;
                case IFUNC_UPPER:
                    fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                    break;
            }
        }
    }

    fprintf(f, " <end of token>\n");
}


//***************************************************************************
//
//  BOOL ReadUI64
//
//  DESCRIPTION:
//
//  Reads an unsigned 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz              String to read from
//      unsigned __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadUI64(LPCWSTR wsz, UNALIGNED unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return FALSE;

        pwc++;
    }

    if(*pwc)
    {
        return FALSE;
    }

    rui64 = ui64;
    return TRUE;
}

//***************************************************************************
//
//  BOOL ReadI64
//
//  DESCRIPTION:
//
//  Reads a signed 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz     String to read from
//      __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadI64(LPCWSTR wsz, UNALIGNED __int64& ri64)
{
    __int64 i64 = 0;
    const WCHAR* pwc = wsz;

    int nSign = 1;
    if(*pwc == L'-')
    {
        nSign = -1;
        pwc++;
    }

    while(i64 >= 0 && i64 < 0x7FFFFFFFFFFFFFFF / 8 &&
            *pwc >= L'0' && *pwc <= L'9')
    {
        i64 = i64 * 10 + (*pwc - L'0');
        pwc++;
    }

    if(*pwc)
        return FALSE;

    if(i64 < 0)
    {
        // Special case --- largest negative number
        // ========================================

        if(nSign == -1 && i64 == (__int64)0x8000000000000000)
        {
            ri64 = i64;
            return TRUE;
        }

        return FALSE;
    }

    ri64 = i64 * nSign;
    return TRUE;
}


HRESULT QL1_Parser::Parse(
        SWbemRpnEncodedQuery **pOutput
        )
{
    *pOutput = 0;
    return E_NOTIMPL;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    RESOURCE,H

Abstract:

	Resource definitions

History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by common.rc
//
#define IDS_FAC_WBEM                    450
#define IDS_FAC_ITF                     451
#define IDS_FAC_NULL                    452
#define IDS_FAC_RPC                     453
#define IDS_FAC_STORAGE                 454
#define IDS_FAC_DISPATCH                455
#define IDS_FAC_WIN32                   456
#define IDS_FAC_WINDOWS                 457
#define IDS_FAC_SSPI                    458
#define IDS_FAC_CONTROL                 459
#define IDS_FAC_CERT                    460
#define IDS_FAC_INET                    461
#define IDS_FAC_UNKNOWN                 462
#define IDS_SUBSYS                      463

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\umiparse.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UMIParse.H

Abstract:

    Declares the object path parser engine.

History:

    a-davj  11-feb-00       Created.

--*/

#ifndef _UMIPARSE_H_
#define _UMIPARSE_H_

#include "genlex.h"
#include "opathlex2.h"
#include <wmiutils.h>
//#include "wbemutil.h"
#include "wbemcli.h"
#include "flexarry.h"

// NOTE:
// The m_vValue in the CKeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  

class  CUmiPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    CDefPathParser *m_pOutput;
    CKeyRef *m_pTmpKeyRef;
    
    DWORD m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse(bool bRelative);

	int locator();
	int ns_root_selector();
	int component_list();
	int component_list_rest();
	int component();
	int def_starts_with_ident(LPWSTR pwsLeadingName, CParsedComponent * pComp);
	int guid_path(CParsedComponent * pComp);
	int key_list(CParsedComponent * pComp);
	int key_list_rest(CParsedComponent * pComp);
	int key(CParsedComponent * pComp);

    int NextToken();
public:
    enum { NoError, SyntaxError, InvalidParameter, NoMemory };

    CUmiPathParser(DWORD eFlags);
   ~CUmiPathParser();

    int Parse(LPCWSTR RawPath, CDefPathParser & Output);
    static LPWSTR GetRelativePath(LPWSTR wszFullPath);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\umiparse.cpp ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    UmiParse.CPP

Abstract:

    Implements the UMI object path parser engine

History:

    a-davj  11-feb-00       Created.

--*/

#include "precomp.h"
#include <genlex.h>
#include "umipathlex.h"
#include "PathParse.h"
#include "UMIParse.h"
#include "commain.h"

//#include "resource.h"
#include "wbemcli.h"
#include <stdio.h>
#include <sync.h>
#include "helpers.h"

//***************************************************************************
//
//  CUmiPathParser
//
//***************************************************************************

void CUmiPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CUmiPathParser::CUmiPathParser(DWORD eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CUmiPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CUmiPathParser::~CUmiPathParser()
{
    Empty();
}

int CUmiPathParser::Parse(
    LPCWSTR pRawPath,
    CDefPathParser & Output
    )
{
	bool bRelative = true;
    if(m_eFlags != 0)
        return CUmiPathParser::InvalidParameter;

    if (pRawPath == 0 || wcslen(pRawPath) == 0)
        return CUmiPathParser::InvalidParameter;

    // Check for leading ws.
    // =====================
    
    if (iswspace(pRawPath[0])) 
        return InvalidParameter;
    
     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    m_pOutput = &Output;

    // Parse the server name (if there is one) manually
    // ================================================

	if(wcslen(pRawPath) > 6 && towupper(pRawPath[0]) == L'U' && towupper(pRawPath[1]) == L'M' &&
		towupper(pRawPath[2]) == L'I' && pRawPath[3] == L':' && pRawPath[4] == L'/' &&
		pRawPath[5] == L'/') 
    {
        const WCHAR* pwcStart = pRawPath + 6;
		bRelative = false;

        // Find the next backslash --- it's the end of the server name
		// Since the next slash can be either, search for both and take
		// the first one.  If the first character is a '[', then then
		// end is indicated by a ']'
        // ============================================================

        WCHAR* pwcEnd = NULL;
		if(*pwcStart == L'[')
		{
			// look for the ']'
			
			WCHAR * pCloseBrace = wcschr(pwcStart, L']');
			if(pCloseBrace == NULL)
				return SyntaxError;
			pwcEnd = pCloseBrace+1;
		}
		else
		{
			pwcEnd = wcschr(pwcStart, L'/');;
		}   
        if (pwcEnd == NULL)
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            return SyntaxError;
        }

        if(pwcEnd == pwcStart)
        {
            // No name at all.  This is OK in umi
            // ==================================
			m_pOutput->SetServer(L"");	//  also sets relative
			pRawPath = pwcEnd;
        }
		else
		{
			WCHAR * wTemp = new WCHAR[pwcEnd-pwcStart+1];
			if(wTemp == NULL)
				return NoMemory;
			wcsncpy(wTemp, pwcStart, pwcEnd-pwcStart);
			wTemp[pwcEnd-pwcStart] = 0;
			m_pOutput->SetServer(wTemp);
			delete wTemp;
			pRawPath = pwcEnd;
		}
    }


    // Point the lexer at the source.
    // ==============================

    CTextLexSource src((LPWSTR)pRawPath);
    m_pLexer = new CGenLexer(UMIPath_LexTable, &src);
	if(m_pLexer == NULL)
		return NoMemory;

    // Go.
    // ===

    int nRes = begin_parse(bRelative);
    if (nRes)
    {
        return nRes;
    }

    if (m_nCurrentToken != UMIPATH_TOK_EOF)
    {
        return SyntaxError;
    }

	// todo, check the following conditions
/*    if (m_pOutput->GetNumComponents() > 0 && !m_pOutput->HasServer())
    {
        if (m_eFlags != WBEMPATH_CREATE_ACCEPT_RELATIVE && m_eFlags != WBEMPATH_CREATE_ACCEPT_ALL)
        {
            return SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================

            m_pOutput->SetServer(L".", true);
        }
    }
*/

//    m_pOutput->SortKeys();           //?? todo, is this applicable?

    // Add in key refs.
    // ================
    return NoError;
}

BOOL CUmiPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == UMIPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}

//
//<umi_path> ::= UMICONST FSLASH FSLASH <locator> FSLASH <ns_root_selector> FSLASH 
//														<component_list>;
//
int CUmiPathParser::begin_parse(bool bRelative)
{

	// note that the locator is parsed manually in the calling routine.

    if (!NextToken())
        return SyntaxError;

	// get the root namespace

	if(!bRelative)
	{

		if(m_nCurrentToken != UMIPATH_TOK_FORWARDSLASH)
			return SyntaxError;

		if (!NextToken())
			return SyntaxError;

		int iRet = ns_root_selector();
		if(iRet)
			return iRet;

		// get the next forward slash.  Note that ns_root_selector will have advanced the token

		if (m_nCurrentToken == UMIPATH_TOK_EOF)			// take care of minimal case
			return 0;
		if (m_nCurrentToken != UMIPATH_TOK_FORWARDSLASH)
			return SyntaxError;
		if (!NextToken())
			return SyntaxError;
	}

	return component_list();

}

//
//  <locator> ::= IDENT ;    // Machine name
//  <locator> ::= SERVERNAME ;    // [Machine name]
//  <locator> ::= DOT ;      // current machine name
//  <locator> ::= <>;    // Machine name
//

int CUmiPathParser::locator()
{

    if (!NextToken())
        return SyntaxError;

	// if forward slash, then no server was specified.

	if (m_nCurrentToken == UMIPATH_TOK_FORWARDSLASH)
    {
		return 0;
	}

    if (m_nCurrentToken == UMIPATH_TOK_DOT)
		m_pOutput->SetServer(L".");
	else if(m_nCurrentToken == UMIPATH_TOK_IDENT ||
		    m_nCurrentToken == UMIPATH_TOK_SERVERNAME)
		m_pOutput->SetServer(m_pLexer->GetTokenText());
	else
		return SyntaxError;

    if(NextToken())
		return 0;
	else
		return SyntaxError;
}

//
//  <ns_root_selector> ::= IDENT;
//

int CUmiPathParser::ns_root_selector()
{
    // This just expects the initial namespace.

	if (m_nCurrentToken != UMIPATH_TOK_IDENT)
        return SyntaxError;

	HRESULT hr = m_pOutput->SetNamespaceAt(0, m_pLexer->GetTokenText());
	if(FAILED(hr))
		return NoMemory;

	if(NextToken())
		return 0;
	else
		return SyntaxError;
}

//
//  <component_list>   ::= <component><component_list_rest>;
//

int CUmiPathParser::component_list()
{

	int iRet = component();
	if(iRet)
		return iRet;
	return component_list_rest();
}

//
//  <component_list_rest> ::= FSLASH <component><component_list_rest>;
//  <component_list_rest> ::= <>;
//

int CUmiPathParser::component_list_rest()
{
	if (m_nCurrentToken == UMIPATH_TOK_EOF)
		return 0;

	if (m_nCurrentToken == UMIPATH_TOK_FORWARDSLASH)
	{
		if (!NextToken())
			return SyntaxError;
		if(component())
			return SyntaxError;
		else
			return component_list_rest();
	}
	else
		return SyntaxError;
}

//
//  <component> ::= IDENT <def_starts_with_ident>;
//  <component> ::= DOT <key_list>;
//  <component> ::= <GUID_PATH>;

int CUmiPathParser::component()
{
	CParsedComponent * pComp = new CParsedComponent(m_pOutput->GetRefCntCS());  // has ref count of 1
	if(pComp == NULL)
		return NoMemory;

	CReleaseMe rm(pComp);	// Is addrefed if all is well.
	int iRet;
	if (m_nCurrentToken == UMIPATH_TOK_DOT)
	{
		if (!NextToken())
			return SyntaxError;
		iRet = key_list(pComp);
		if(iRet == 0)
		{
			if(SUCCEEDED(m_pOutput->AddComponent(pComp)))
				pComp->AddRef();
		}
		return iRet;
	}
	
	// a guid path looks like an ident to the parser

	if (m_nCurrentToken != UMIPATH_TOK_IDENT)
	{
        return SyntaxError;
	}

	if(!_wcsnicmp( m_pLexer->GetTokenText(), L"<GUID>={", 8))
	{

		iRet = guid_path(pComp);
	}
	else
	{
		WCHAR * pTemp = new WCHAR[wcslen(m_pLexer->GetTokenText()) + 1];
		if(pTemp == NULL)
			return NoMemory;
		wcscpy(pTemp, m_pLexer->GetTokenText());
		iRet = def_starts_with_ident(pTemp, pComp);
		delete pTemp;
	}
	if(iRet == 0)
		if(SUCCEEDED(m_pOutput->AddComponent(pComp)))
		    pComp->AddRef();
	return iRet;
}

//
//  <def_starts_with_ident> ::= DOT <key_list>;
//  <def_starts_with_ident> ::= TOK_EQUALS IDENT;
//  <def_starts_with_ident> ::= <>;
//

int CUmiPathParser::def_starts_with_ident(LPWSTR pwsLeadingName, CParsedComponent * pComp)
{
    int iRet = 0;
    if (!NextToken()) 
        return SyntaxError;

	if (m_nCurrentToken == UMIPATH_TOK_DOT)
	{
		pComp->m_sClassName = SysAllocString(pwsLeadingName);
		if(pComp->m_sClassName == NULL)
			return NoMemory;
		if (!NextToken())
			return SyntaxError;
		return key_list(pComp);
	}
	if (m_nCurrentToken == UMIPATH_TOK_EQ)
	{
		pComp->m_sClassName = SysAllocString(pwsLeadingName);
		if(pComp->m_sClassName == NULL)
			return NoMemory;
		if (!NextToken())
			return SyntaxError;
		if(m_nCurrentToken == UMIPATH_TOK_IDENT)
    		iRet = pComp->SetKey(NULL, 0, CIM_STRING, m_pLexer->GetTokenText());
	    else if(m_nCurrentToken == UMIPATH_TOK_SINGLETON_SYM)
            pComp->MakeSingleton(true);
        else
            return SyntaxError;
		if (!NextToken())
			return SyntaxError;
		return iRet;
	}
	else
	{
		pComp->m_sClassName = SysAllocString(pwsLeadingName);
		if(pComp->m_sClassName == NULL)
			return NoMemory;
		else
			return 0;
	}
}

//  <guid_path> ::= TOK_GUILD_CONST TOK_GUID;

int CUmiPathParser::guid_path(CParsedComponent * pComp)
{
	LPWSTR pTemp = m_pLexer->GetTokenText();
	if(!_wcsnicmp( m_pLexer->GetTokenText(), L"<GUID>={", 8))
	{
		// got a guid.  try doing a converstion just to check the syntax.

	    UUID Uuid;
		HRESULT hr = UuidFromString(pTemp+7, &Uuid);
		if(FAILED(hr))
			return SyntaxError;
	}
	HRESULT hr = pComp->SetNS(m_pLexer->GetTokenText());
	if(FAILED(hr))
		return NoMemory;
	else
		return 0;
}

//
//  <key_list>   ::= <key><key_list_rest>;
//

int CUmiPathParser::key_list(CParsedComponent * pComp)
{
	int iRet = key(pComp);
	if(iRet)
		return iRet;
	else
		return key_list_rest(pComp);
}

//
//  <key_list_rest> ::= TOK_COMMA <key><key_list_rest>;
//  <key_list_rest> ::= <>;
//

int CUmiPathParser::key_list_rest(CParsedComponent * pComp)
{
    if (!NextToken())
        return SyntaxError;

	if (m_nCurrentToken == UMIPATH_TOK_COMMA)
	{
		if (!NextToken())
			return SyntaxError;
		int iRet = key(pComp);
		if(iRet)
			return iRet;
		else
			return key_list_rest(pComp);
	}
	return 0;
}

//
//  <key>        ::= IDENT TOK_EQUALS IDENT;
//

int CUmiPathParser::key(CParsedComponent * pComp)
{
	if(m_nCurrentToken != UMIPATH_TOK_IDENT)
		return SyntaxError;

	LPWSTR pKeyName = new WCHAR[wcslen(m_pLexer->GetTokenText())+1];
	if(pKeyName == NULL)
		return NoMemory;

	CDeleteMe<WCHAR> dm(pKeyName);
	wcscpy(pKeyName,m_pLexer->GetTokenText());
	
	if (!NextToken())
		return SyntaxError;
	if(m_nCurrentToken != UMIPATH_TOK_EQ)
		return SyntaxError;

	if (!NextToken())
		return SyntaxError;

	if(m_nCurrentToken != UMIPATH_TOK_IDENT)
		return SyntaxError;

	return pComp->SetKey(pKeyName, 0, CIM_STRING, m_pLexer->GetTokenText());

}


HRESULT CDefPathParser::Set( 
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText)
{

	//todo, look at the flags.  Note that this can get redirected wmi calls.

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
		return WBEM_E_OUT_OF_MEMORY;
	if(pszText == NULL)			
		return WBEM_E_INVALID_PARAMETER;

	if(!IsEmpty())
		Empty();

	m_bSetViaUMIPath = true;

	// special hack for Raja

	if(lFlags & 0x8000)
	{
		int iLen = wcslen(pszText) + 1;
		m_pRawPath = new WCHAR[iLen];
		if(m_pRawPath == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		wcscpy(m_pRawPath, pszText);
		return S_OK;
	}

	// end of special hack for Raja


    CUmiPathParser parser(0);
    int iRet = parser.Parse(pszText, *this);
    if(iRet == 0)
    {
		// the parser doesnt know scopes from class.  So, make the last
		// scope the class.

        m_dwStatus = OK;
        return S_OK;
    }
    else
    {
        m_dwStatus = BAD_STRING;
        return WBEM_E_INVALID_PARAMETER;
    }
}

HRESULT CDefPathParser::Get( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest)
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puBufSize == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// special hack for Raja

	if(m_pRawPath)
	{
		DWORD dwSizeNeeded = wcslen(m_pRawPath) + 1;
		DWORD dwBuffSize = *puBufSize;
		*puBufSize = dwSizeNeeded;
		if(pszDest)
		{
			if(dwSizeNeeded > dwBuffSize)
				return WBEM_E_BUFFER_TOO_SMALL;
			wcscpy(pszDest, m_pRawPath);
		}
		return S_OK;
	}
	
	// special hack for Raja
	
	
	// determine how big the buffer needs to be.
	// an example path is "umi://h27pjr/root/st";

	DWORD dwSc = m_Components.Size();
	int iSize = 1;					// 1 for the null terminator
	
	if(m_pServer)
	{
		iSize += 7;					// counts for umi: and first three slashes and null
		iSize += wcslen(m_pServer);
	}
	DWORD dwNumComp = GetNumComponents();
	for(DWORD dwCnt = 0; dwCnt < dwNumComp; dwCnt++)
	{
		bool bNeedEqual = false;
		CParsedComponent * pObj;
		if(dwCnt < (dwSc))
			pObj = (CParsedComponent *)m_Components[dwCnt];
		else
			break;
		if(pObj->m_sClassName)
		{
			iSize += wcslen(pObj->m_sClassName);
			bNeedEqual = true;
		}
		
		DWORD dwNumKey = 0;
		pObj->GetCount(&dwNumKey);
		for(DWORD dwKey = 0; dwKey < dwNumKey; dwKey++)
		{
			CKeyRef * pKey = (CKeyRef *)pObj->m_Keys.GetAt(dwKey);
			if(pKey->m_pName && wcslen(pKey->m_pName))
			{
				iSize += wcslen(pKey->m_pName);
				if(dwKey == 0)
					iSize++;					// 1 is for the dot.
				bNeedEqual = true;
			}
			if(pKey->m_dwSize)
			{
				LPWSTR pValue = pKey->GetValue(false);
				if(pValue)
				{
					iSize+= wcslen(pValue);
					delete pValue;
				}
				if(bNeedEqual)
					iSize++;
			}
			if(dwKey < dwNumKey-1)
				iSize++;	// one for the comma!
		}
		if(dwCnt < dwNumComp-1)
			iSize++;		// one for the slash
	}

	// If caller is just looking for size, return now
	
	if(pszDest == NULL)
	{
		*puBufSize = iSize;
		return S_OK;
	}

    DWORD dwBuffSize = *puBufSize;
    *puBufSize = iSize;

	if((DWORD)iSize > dwBuffSize)
		return WBEM_E_BUFFER_TOO_SMALL;

	if(m_pServer)
	{
		wcscpy(pszDest, L"umi://");
		if(m_pServer)
			wcscat(pszDest, m_pServer);
		wcscat(pszDest, L"/");
	}
	else
		*pszDest = 0;

	for(DWORD dwCnt = 0; dwCnt < dwNumComp; dwCnt++)
	{
		bool bNeedEqual = false;
		CParsedComponent * pObj;
		if(dwCnt < (dwSc))
			pObj = (CParsedComponent *)m_Components[dwCnt];
		else
			break;

		if(pObj->m_sClassName)
		{
			wcscat(pszDest,pObj->m_sClassName);
			bNeedEqual = true;
		}
		
		DWORD dwNumKey = 0;
		pObj->GetCount(&dwNumKey);
		for(DWORD dwKey = 0; dwKey < dwNumKey; dwKey++)
		{
			CKeyRef * pKey = (CKeyRef *)pObj->m_Keys.GetAt(dwKey);
			if(pKey->m_pName && wcslen(pKey->m_pName))
			{
				if(dwKey == 0)
					wcscat(pszDest,L".");
				wcscat(pszDest,pKey->m_pName);		// 1 is for the dot.
				bNeedEqual = true;
			}
			if(pKey->m_dwSize)
			{
				if(bNeedEqual)
					wcscat(pszDest,L"=");
				LPWSTR pValue = pKey->GetValue(false);
				if(pValue)
				{
					wcscat(pszDest, pValue);
					delete pValue;
				}
			}
			if(dwKey < dwNumKey-1)
				wcscat(pszDest, L",");	// one for the comma!
		}
		if(dwCnt < dwNumComp-1)
			wcscat(pszDest, L"/");		// one for the slash
		
	}


	return S_OK;	
}
        
HRESULT CDefPathParser::GetPathInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(uRequestedInfo != 0 || puResponse == NULL)
		return WBEM_E_INVALID_PARAMETER;
	*puResponse = NULL;
	if(m_pRawPath)
		*puResponse |= UMIPATH_INFO_NATIVE_STRING;
	else if(m_pServer == NULL)
		*puResponse |= UMIPATH_INFO_RELATIVE_PATH;
	if(m_Components.Size() > 0)
	{
		 int iSize = m_Components.Size();
		CParsedComponent * pComp = (CParsedComponent *)m_Components.GetAt(iSize-1);
		if(!pComp->IsPossibleNamespace())
            if(pComp->IsInstance())
            {
			    *puResponse |= UMIPATH_INFO_INSTANCE_PATH;
		        if(pComp->m_bSingleton)
			        *puResponse |= UMIPATH_INFO_SINGLETON_PATH;
            }
            else
                *puResponse |= UMIPATH_INFO_CLASS_PATH;
	}
	return S_OK;	
}
        
       
HRESULT CDefPathParser::SetLocator( 
            /* [string][in] */ LPCWSTR Name)
{
	return SetServer(Name);	// mutex is grabbed here
}
        
HRESULT CDefPathParser::GetLocator( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName)
{
	return GetServer(puNameBufLength, pName);	// mutex is grabbed here
}
        
HRESULT CDefPathParser::SetRootNamespace( 
            /* [string][in] */ LPCWSTR Name)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(Name == NULL)
		return WBEM_E_INVALID_PARAMETER;
	if(m_Components.Size() > 0)
		RemoveNamespaceAt(0);
	return SetNamespaceAt(0, Name);
}
        
HRESULT CDefPathParser::GetRootNamespace( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	return GetNamespaceAt(0, puNameBufLength, pName);	
}
        
HRESULT CDefPathParser::GetComponentCount( 
            /* [out] */ ULONG __RPC_FAR *puCount)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(puCount == 0)
		return WBEM_E_INVALID_PARAMETER;

	*puCount = m_Components.Size()-1;  // dont count root namespace

	return S_OK;	
}
        
HRESULT CDefPathParser::SetComponent( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwNumComp = m_Components.Size()-1;  // dont count root namespace
	if(uIndex > dwNumComp)
		return WBEM_E_INVALID_PARAMETER;
	CParsedComponent * pNew = new CParsedComponent(m_pCS);
	if(pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	if(pszClass)
	{
		pNew->m_sClassName = SysAllocString(pszClass);
		if(pNew->m_sClassName == NULL)
		{
			delete pNew;
			return WBEM_E_OUT_OF_MEMORY;
		}
	}
	int iRet = m_Components.InsertAt(uIndex + 1, pNew);
	if(iRet ==  CFlexArray::no_error)
	    return S_OK;
	else
	{
		delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
	}
}
HRESULT CDefPathParser::SetComponentFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	return WBEM_E_NOT_AVAILABLE;
}
        
HRESULT CDefPathParser::GetComponent( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	uIndex++;		// skip root ns

	if(uIndex >= (DWORD)m_Components.Size())
		return WBEM_E_INVALID_PARAMETER;
	CParsedComponent * pComp = (CParsedComponent *)m_Components.GetAt(uIndex);
	DWORD dwSize = 0;
	if(pComp->m_sClassName)
		dwSize = wcslen(pComp->m_sClassName)+1;
	DWORD dwBuffSize = *puClassNameBufSize;
	if(puClassNameBufSize)
	{
		*puClassNameBufSize = dwSize;
		if(dwBuffSize > 0 && pszClass)
			pszClass[0] = NULL;
	}
	if(pComp->m_sClassName && pszClass)
	{
		if(dwSize > dwBuffSize)
			return WBEM_E_BUFFER_TOO_SMALL;
		else
			wcscpy(pszClass, pComp->m_sClassName);
	}
	if(pKeyList)
	{
		return pComp->QueryInterface(IID_IUmiURLKeyList, (void **)pKeyList);
	}

	return S_OK;	
}
HRESULT CDefPathParser::GetComponentAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	return WBEM_E_NOT_AVAILABLE;
}
        
HRESULT CDefPathParser::RemoveComponent( 
            /* [in] */ ULONG uIndex)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	uIndex++;		// skip root ns
	if(uIndex >= (DWORD)m_Components.Size())
		return WBEM_E_INVALID_PARAMETER;
	CParsedComponent * pComp = (CParsedComponent *)m_Components.GetAt(uIndex);
	pComp->Release();
	m_Components.RemoveAt(uIndex);
	return S_OK;	
}
        
HRESULT CDefPathParser::RemoveAllComponents( void)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    for (DWORD dwIx = (DWORD)m_Components.Size()-1; dwIx > 0 ; dwIx--)
    {
        CParsedComponent * pCom = (CParsedComponent *)m_Components[dwIx];
        pCom->Release();
		m_Components.RemoveAt(dwIx);
    }
	return S_OK;	
}
        
HRESULT CDefPathParser::SetLeafName( 
            /* [string][in] */ LPCWSTR Name)
{
	return SetClassName(Name);	// mutex is grabbed here
}
        
HRESULT CDefPathParser::GetLeafName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName)
{
	return GetClassName(puBuffLength, pszName);	// mutex is grabbed here
}
        
HRESULT CDefPathParser::GetKeyList( 
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	CParsedComponent * pClass = GetClass();
    HRESULT hRes = WBEM_E_NOT_AVAILABLE;
	if(pOut == NULL || pClass == NULL)
		return WBEM_E_INVALID_PARAMETER;
    hRes = pClass->QueryInterface(IID_IUmiURLKeyList, (void **)pOut);
	return hRes;
}
        
HRESULT CDefPathParser::CreateLeafPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name)
{
	return CreateClassPart(lFlags, Name);	// mutex is grabbed here
}
        
HRESULT CDefPathParser::DeleteLeafPart( 
            /* [in] */ long lFlags)
{
	return DeleteClassPart(lFlags);	 // mutex is grabbed here
}
        
HRESULT CUmiParsedComponent::GetKey(            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue)
{
//fix in blackcomb    CSafeInCritSec cs(m_pOutput->GetRefCntCS()->GetCS());
    if(puValueBufSize)
		*puValueBufSize *= 2;
    return m_pParent->GetKey(uKeyIx, WBEMPATH_TEXT,puKeyNameBufSize,pszKeyName,puValueBufSize,
							pszValue, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\umipathlex.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

  UMIPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  3-Mar-00       Created.

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <umipathlex.h>             


#define ST_IDENT            17
#define ST_IDENT_ESC		22
#define ST_SERVER        28



// DFA State Table for Object Path tokens.
// =======================================

LexEl UMIPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

/* 0 */ L',',   GLEX_EMPTY, 0,  UMIPATH_TOK_COMMA, GLEX_ACCEPT,
/* 1 */  L'.',   GLEX_EMPTY, 0,  UMIPATH_TOK_DOT,              GLEX_ACCEPT,
/* 2 */  L'=',   GLEX_EMPTY, 0,  UMIPATH_TOK_EQ,               GLEX_ACCEPT,
/* 3 */ L'/',   GLEX_EMPTY, 0, UMIPATH_TOK_FORWARDSLASH,      GLEX_ACCEPT,


// White space characters

/* 4 */ L' ',   GLEX_EMPTY, 0,  UMIPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 5 */ L'\t',  GLEX_EMPTY, 0,  UMIPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 6 */ L'\n',  GLEX_EMPTY, 0,  UMIPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 7 */ L'\r',  GLEX_EMPTY, 0,  UMIPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

/* 8 */ L'[',   GLEX_EMPTY, ST_SERVER, 0,               GLEX_ACCEPT,
/* 9 */ L'@',    GLEX_EMPTY, 0,  UMIPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Identifiers
    
/* 10 */  L'!',   0xfffd,       ST_IDENT,   0,               GLEX_ACCEPT,
/* 11*/  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 12 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 13 */ L'0',   L'9',       ST_IDENT, 0,               GLEX_ACCEPT,
/* 14 */ L'-',   GLEX_EMPTY, ST_IDENT, 0,               GLEX_ACCEPT,
/* 15 */ 0,      GLEX_EMPTY, 0,  UMIPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return

	// anything else is an error

/* 16 */ GLEX_ANY, GLEX_EMPTY, 0,        UMIPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,



    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.  Note that
	// we bail out if ,=/or .

/* 17 */  L' ',       L'+',       ST_IDENT,     0,                 GLEX_ACCEPT,
/* 18 */  L'-', GLEX_EMPTY,       ST_IDENT, 0,  GLEX_ACCEPT,
/* 19 */  L'0',     L'<',       ST_IDENT,     0,                 GLEX_ACCEPT,
/* 20 */  L'>',     0xfffd,       ST_IDENT,     0,                 GLEX_ACCEPT,
/* 21 */  GLEX_ANY, GLEX_EMPTY, 0,          UMIPATH_TOK_IDENT,     GLEX_PUSHBACK|GLEX_RETURN,



/* 22  */    L'\\', GLEX_EMPTY, ST_IDENT, 0,  GLEX_ACCEPT,
/* 23  */    L'.',  GLEX_EMPTY, ST_IDENT, 0,  GLEX_ACCEPT,
/* 24  */    L'/',  GLEX_EMPTY, ST_IDENT, 0,  GLEX_ACCEPT,
/* 25  */    L'=',  GLEX_EMPTY, ST_IDENT, 0,  GLEX_ACCEPT,
/* 26  */    L',',  GLEX_EMPTY, ST_IDENT, 0,  GLEX_ACCEPT,
/* 27  */ GLEX_ANY, GLEX_EMPTY, 0,        UMIPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_DQ_SERVER
    //
    // A server begins with '[' and ends with ']'.

/* 28*/   L']',  GLEX_EMPTY, 0,                UMIPATH_TOK_SERVERNAME,   GLEX_ACCEPT,
/* 29*/   L']',  GLEX_EMPTY, ST_SERVER,     0,                     GLEX_ACCEPT|GLEX_NOT, 

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wmiquery.cpp ===
//***************************************************************************
//
//  WMIQUERY.CPP
//
//  Query parser implementation
//
//  raymcc      10-Apr-00       Created
//
//***************************************************************************

#include "precomp.h"
#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include "sync.h"
#include "flexarry.h"

#include <wmiutils.h>
#include <wbemint.h>

#include "wmiquery.h"
#include "helpers.h"
#include <like.h>
#include <wqllex.h>

#include <stdio.h>
#include <string.h>

#define INVALID     0x3


static CRITICAL_SECTION CS_UserMem;
static CFlexArray *g_pUserMem;

CCritSec g_csQPLock;
class C_SYNC
{
public:
    C_SYNC ()                   { g_csQPLock.Enter();}
    ~C_SYNC()                   { g_csQPLock.Leave();}
};



struct SWmiqUserMem
{
    DWORD  m_dwType;
    LPVOID m_pMem;
};


class BoolStack
{
    BOOL *m_pValues;
    int   nPtr;
public:
    enum { DefaultSize = 256 };

    BoolStack(int nSz)
    {
        m_pValues = new BOOL[nSz];
        nPtr = -1;
    }
    ~BoolStack() { delete m_pValues; }
    void Push(BOOL b){ m_pValues[++nPtr] = b; }
    BOOL Pop() { return m_pValues[nPtr--]; }
    BOOL Peek() { return m_pValues[nPtr]; }
};

//***************************************************************************
//
//***************************************************************************
//
CWmiQuery::CWmiQuery()
{
    m_uRefCount = 1;        // Required by helper in MainDLL.CPP.

    m_pParser = 0;
    m_pAssocParser = 0;
    m_pLexerSrc = 0;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//***************************************************************************
//
CWmiQuery::~CWmiQuery()
{
    Empty();
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
//
//***************************************************************************
//
void CWmiQuery::InitEmpty()
{
//    Empty();
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWmiQuery::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWmiQuery::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CWmiQuery::QueryInterface
//
//  Exports IWbemServices interface.
//
//***************************************************************************
//
HRESULT CWmiQuery::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemQuery==riid || IID__IWmiQuery==riid )
    {
        *ppvObj = (IWbemServicesEx*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::Empty()
{
//  if ( CS_Entry.TryEnter () == FALSE )
//      return WBEM_E_CRITICAL_ERROR;
    C_SYNC cs;

    if (m_pParser)
        delete m_pParser;
    m_pParser = 0;

    if (m_pAssocParser)
        delete m_pAssocParser;
    m_pAssocParser = 0;

    if (m_pLexerSrc)
        delete m_pLexerSrc;
    m_pLexerSrc = 0;

    if (m_aClassCache.Size())
    {
        for (int i = 0; i < m_aClassCache.Size(); i++)
        {
            _IWmiObject *pObj = (_IWmiObject *) m_aClassCache[i];
            pObj->Release();
        }

        m_aClassCache.Empty();
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
// *

HRESULT CWmiQuery::SetLanguageFeatures(
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uArraySize,
            /* [in] */ ULONG __RPC_FAR *puFeatures
            )
{
//  if ( CS_Entry.TryEnter () == FALSE )
//      return WBEM_E_CRITICAL_ERROR;
    C_SYNC cs;


    for (ULONG u = 0; u < uArraySize; u++)
    {
        m_uRestrictedFeatures[u] = puFeatures[u];
    }
    m_uRestrictedFeaturesSize = u;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::TestLanguageFeatures(
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *uArraySize,
            /* [out] */ ULONG __RPC_FAR *puFeatures
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::Parse(
            /* [in] */ LPCWSTR pszLang,
            /* [in] */ LPCWSTR pszQuery,
            /* [in] */ ULONG uFlags
            )
{
    if (_wcsicmp(pszLang, L"WQL") != 0 && _wcsicmp(pszLang, L"SQL") != 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if (pszQuery == 0 || wcslen(pszQuery) == 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

//  if ( CS_Entry.TryEnter () == FALSE )
//      return WBEM_E_CRITICAL_ERROR;
    C_SYNC cs;


    HRESULT hRes;
    int nRes;

    Empty();

    try
    {
        // Get a text source bound to the query.
        // =====================================

        m_pLexerSrc = new CTextLexSource(pszQuery);
        if (!m_pLexerSrc)
            return WBEM_E_OUT_OF_MEMORY;

        // Check the first token and see which way to branch.
        // ==================================================

        m_pParser = new CWQLParser(LPWSTR(pszQuery), m_pLexerSrc);

        if (!m_pParser)
            return WBEM_E_OUT_OF_MEMORY;

        hRes = m_pParser->Parse();
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::GetAnalysis(
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pAnalysis
            )
{
//  if ( CS_Entry.TryEnter () == FALSE )
//      return WBEM_E_CRITICAL_ERROR;
    C_SYNC cs;


    int nRes;

    if (!m_pParser)
        return WBEM_E_INVALID_OPERATION;

    if (uAnalysisType == WMIQ_ANALYSIS_RPN_SEQUENCE)
    {
        // Verify it was a select clause.
        // ==============================

        SWQLNode_QueryRoot *pRoot = m_pParser->GetParseRoot();
        if (pRoot->m_dwQueryType != SWQLNode_QueryRoot::eSelect)
            return WBEM_E_INVALID_OPERATION;

        // Encode and record it.
        // =====================

        nRes = m_pParser->GetRpnSequence((SWbemRpnEncodedQuery **) pAnalysis);
        if (nRes != 0)
            return WBEM_E_FAILED;

        SWmiqUserMem *pUM = new SWmiqUserMem;
        if (!pUM)
            return WBEM_E_OUT_OF_MEMORY;

        pUM->m_pMem = *pAnalysis;
        pUM->m_dwType = WMIQ_ANALYSIS_RPN_SEQUENCE;

        EnterCriticalSection(&CS_UserMem);
        g_pUserMem->Add(pUM);
        LeaveCriticalSection(&CS_UserMem);

        return WBEM_S_NO_ERROR;
    }

    else if (uAnalysisType == WMIQ_ANALYSIS_RESERVED)
    {
        SWQLNode *p = m_pParser->GetParseRoot();
        *pAnalysis = p;
        return WBEM_S_NO_ERROR;
    }

    else if (uAnalysisType == WMIQ_ANALYSIS_ASSOC_QUERY)
    {
        SWQLNode_QueryRoot *pRoot = m_pParser->GetParseRoot();
        if (pRoot->m_dwQueryType != SWQLNode_QueryRoot::eAssoc)
            return WBEM_E_INVALID_OPERATION;

        SWQLNode_AssocQuery *pAssocNode = (SWQLNode_AssocQuery *) pRoot->m_pLeft;
        if (!pAssocNode)
            return WBEM_E_INVALID_QUERY;

        SWbemAssocQueryInf *pAssocInf = (SWbemAssocQueryInf *) pAssocNode->m_pAQInf;
        if (!pAssocInf)
            return WBEM_E_INVALID_QUERY;

        *pAnalysis = pAssocInf;

        SWmiqUserMem *pUM = new SWmiqUserMem;
        if (!pUM)
            return WBEM_E_OUT_OF_MEMORY;
        pUM->m_pMem = *pAnalysis;
        pUM->m_dwType = WMIQ_ANALYSIS_ASSOC_QUERY;

        EnterCriticalSection(&CS_UserMem);
        g_pUserMem->Add(pUM);
        LeaveCriticalSection(&CS_UserMem);

        return WBEM_S_NO_ERROR;
    }

    else if (uAnalysisType == WMIQ_ANALYSIS_QUERY_TEXT)
    {
        LPWSTR pszQuery = Macro_CloneLPWSTR(m_pParser->GetQueryText());
        if (!pszQuery)
            return WBEM_E_OUT_OF_MEMORY;

        SWmiqUserMem *pUM = new SWmiqUserMem;
        if (!pUM)
            return WBEM_E_OUT_OF_MEMORY;
        pUM->m_pMem = pszQuery;
        pUM->m_dwType = WMIQ_ANALYSIS_QUERY_TEXT;

        EnterCriticalSection(&CS_UserMem);
        g_pUserMem->Add(pUM);
        LeaveCriticalSection(&CS_UserMem);

        *pAnalysis = pszQuery;

        return WBEM_S_NO_ERROR;
    }

    return WBEM_E_INVALID_PARAMETER;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::GetQueryInfo(
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uInfoId,
            /* [in] */ ULONG uBufSize,
            /* [out] */ LPVOID pDestBuf
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//
#ifdef _OLD_
HRESULT CWmiQuery::StringTest(
            /* [in] */ ULONG uTestType,
            /* [in] */ LPCWSTR pszTestStr,
            /* [in] */ LPCWSTR pszExpr
            )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (uTestType == WQL_TOK_LIKE)
    {
        CLike l (pszTestStr);
        BOOL bRet = l.Match(pszExpr);
        if(bRet)
        	hr = S_OK;
        else
        	hr = S_FALSE;
    }
    else
        hr = E_NOTIMPL;

    return hr;
}
#endif


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::FreeMemory(
    LPVOID pMem
    )
{
//  if ( CS_Entry.TryEnter () == FALSE )
//      return WBEM_E_CRITICAL_ERROR;
    C_SYNC cs;


    // Check to ensure that query root isn't freed.
    // Allow a pass-through as if it succeeded.
    // ============================================

    SWQLNode *p = m_pParser->GetParseRoot();
    if (pMem == p)
        return WBEM_S_NO_ERROR;

    // Find and free the memory.
    // =========================

    HRESULT hRes = WBEM_E_NOT_FOUND;
    EnterCriticalSection(&CS_UserMem);
    for (int i = 0; i < g_pUserMem->Size(); i++)
    {
        SWmiqUserMem *pUM = (SWmiqUserMem *) (*g_pUserMem)[i];
        if (pUM->m_pMem == pMem)
        {
            switch (pUM->m_dwType)
            {
                case WMIQ_ANALYSIS_RPN_SEQUENCE:
                    delete (CWbemRpnEncodedQuery *) pMem;
                    break;

                case WMIQ_ANALYSIS_ASSOC_QUERY:
                    break;

                case WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX:
                    break;

                case WMIQ_ANALYSIS_QUERY_TEXT:
                    delete LPWSTR(pMem);
                    break;

                case WMIQ_ANALYSIS_RESERVED:
                    // A copy of the internal parser tree pointer.
                    // Leave it alone! Don't delete it!  If you do, I will hunt you down.
                    break;
                default:
                    break;
            }

            delete pUM;
            g_pUserMem->RemoveAt(i);
            hRes = WBEM_S_NO_ERROR;
            break;
        }
    }
    LeaveCriticalSection(&CS_UserMem);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::Dump(
    LPSTR pszFile
    )
{
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::Startup()
{
    InitializeCriticalSection(&CS_UserMem);
    g_pUserMem = new CFlexArray;
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::Shutdown()
{
    DeleteCriticalSection(&CS_UserMem);
    delete g_pUserMem;
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::CanUnload()
{
    // Later, track outstanding analysis pointers
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\umipathlex.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    UMIPATHLEX.H

Abstract:

    UMI Object Path DFA Tokens

History:

--*/

#ifndef _UMIPATHLEX_H_
#define _UMIPATHLEX_H_

#define UMIPATH_TOK_EOF       0
#define UMIPATH_TOK_ERROR     1

#define UMIPATH_TOK_IDENT         100
#define UMIPATH_TOK_EQ            104
#define UMIPATH_TOK_DOT           105
#define UMIPATH_TOK_COMMA         109
#define UMIPATH_TOK_FORWARDSLASH  110
#define UMIPATH_TOK_SERVERNAME    111
#define UMIPATH_TOK_SINGLETON_SYM 108

extern LexEl UMIPath_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wbemerror.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMERROR.H

Abstract:

    Implements string table based, error msgs for all of wbem.

History:

    a-khint  5-mar-98       Created.

--*/

//#include "wbemutil.h"
#include "wbemcli.h"
typedef LPVOID * PPVOID;

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemError
//
//  DESCRIPTION:
//
//  Provides error and facility code info.
//
//***************************************************************************

class CWbemError : IWbemStatusCodeText
{
    protected:
        long           m_cRef;
    public:
        CWbemError(void)
        {
            InterlockedIncrement(&g_cObj);
            m_cRef=1L;
            return;
        };

        ~CWbemError(void)
        {
            InterlockedDecrement(&g_cObj);
            return;
        }

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid || IID_IWbemStatusCodeText==riid)
                *ppv=this;

            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return E_NOINTERFACE;
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return ++m_cRef;
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRef = InterlockedDecrement(&m_cRef);
            if (0L == lRef)
                delete this;
            return lRef;
        };

        HRESULT STDMETHODCALLTYPE GetErrorCodeText(
            HRESULT hRes,
            LCID    LocaleId,
            long    lFlags,
            BSTR   * MessageText);

        HRESULT STDMETHODCALLTYPE GetFacilityCodeText(
            HRESULT hRes,
            LCID    LocaleId,
            long    lFlags,
            BSTR   * MessageText);

        void InitEmpty(){};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wbemerror.cpp ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    WBEMERROR.CPP

Abstract:

    Implements string table based, error msgs for all of wbem.

History:

    a-khint  5-mar-98       Created.

--*/

#include "precomp.h"
#include "WbemError.h"
#include "commain.h"
#include "resource.h"
#include "wbemcli.h"
#include <stdio.h>

extern HINSTANCE g_hInstance;


//-------------------------------------------------

bool LoadMyString(UINT ID, 
                  LPTSTR str, UINT size, 
                  LPCTSTR def)
{
    bool retval = true;
    if(str)
    {
//      TCHAR *szStr = new TCHAR[size];
        if (LoadString(g_hInstance, ID, str, size) == 0)
        {
            if(def)
                lstrcpyn(str, def, size);
        }
/*      else
        {
            mbstowcs(str, szStr, size);
            retval = true;
        }
*/
//      delete [] szStr;
    }
    return retval;
}

DWORD MyFormatMessage(DWORD dwFlags,
                      LPCVOID lpSource,
                      DWORD dwMessageId,
                      DWORD dwLanguageId,
                      LPTSTR lpBuffer,
                      DWORD nSize,
                      va_list *Arguments)
{
    DWORD dwRet = 0;
//  TCHAR *szString = new TCHAR[nSize];
    
    if(lpBuffer)
    {
        dwRet = FormatMessage(dwFlags,lpSource,dwMessageId,dwLanguageId,lpBuffer,
                                nSize,Arguments);
//      if(dwRet > 0)
//          mbstowcs(lpBuffer, szString, nSize);
//      delete [] szString;
    }
    return dwRet;
}
//-------------------------------------------------
DWORD WbemErrorString(SCODE sc, 
                   TCHAR *errMsg, UINT errSize, DWORD dwFlags=FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_FROM_HMODULE)
{
    return MyFormatMessage(dwFlags,
                      g_hInstance, sc, 
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                      errMsg, errSize, NULL);
}

HRESULT CWbemError::GetErrorCodeText(HRESULT hRes,  LCID    LocaleId, long lFlags, BSTR * MessageText)
{
    TCHAR errMsg[256];
    int errSize = 256;
    DWORD dwMsgSize = 0;
    *MessageText = NULL;
	DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS;

    if(LocaleId != 0 )
        return WBEM_E_INVALID_PARAMETER;

	// If WBEMSTATUS_FORMAT_NO_NEWLINE is specified update FormatMessage mask
	if(lFlags==WBEMSTATUS_FORMAT_NO_NEWLINE)
		dwFlags|=FORMAT_MESSAGE_MAX_WIDTH_MASK;			// No newline mask for FormatMessage
	else if (lFlags!=WBEMSTATUS_FORMAT_NEWLINE)
		return WBEM_E_INVALID_PARAMETER;
	
    // If the facility code is wbem, try loading the error from the wbem strings

    if(SCODE_FACILITY(hRes) == FACILITY_ITF)
        dwMsgSize = WbemErrorString(hRes, errMsg, errSize, dwFlags|FORMAT_MESSAGE_FROM_HMODULE);

    if(dwMsgSize == 0)
        dwMsgSize = MyFormatMessage(dwFlags|FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL, hRes, 
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                      errMsg, errSize, NULL);
    if(dwMsgSize > 0)
    {
#ifdef UNICODE
        *MessageText = SysAllocString(errMsg);
#else
        wchar_t *wcErr = new wchar_t[strlen(errMsg) + 1];
        mbstowcs(wcErr, errMsg, strlen(errMsg)+1);
        *MessageText = SysAllocString(wcErr);
        delete [] wcErr;
#endif
        if(*MessageText)
            return S_OK;
    }
    return WBEM_E_FAILED;
}

HRESULT CWbemError::GetFacilityCodeText(HRESULT sc, LCID    LocaleId, long lFlags, BSTR * MessageText)
{
    TCHAR facility[50];
    int facSize = 50;
    TCHAR wTemp[256];
    bool bLoaded = false;

    *MessageText = NULL;

    if(LocaleId != 0 || lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;

    switch(SCODE_FACILITY(sc))
    {
    case FACILITY_ITF:
        if(WbemErrorString(sc, wTemp, 256))
        {
            bLoaded = LoadMyString(IDS_FAC_WBEM, 
                        facility, facSize,
                        __TEXT("WMI"));
            break;
        }
        else
            bLoaded = LoadMyString(IDS_FAC_ITF, 
                        facility, facSize,
                        __TEXT("Interface"));
        break;

    case FACILITY_NULL:
        bLoaded = LoadMyString(IDS_FAC_NULL, 
                    facility, facSize,
                    __TEXT("<Null>"));
        break;

    case FACILITY_RPC:
        bLoaded = LoadMyString(IDS_FAC_RPC, 
                    facility, facSize,
                    __TEXT("RPC"));
        break;

    case FACILITY_STORAGE:
        bLoaded = LoadMyString(IDS_FAC_STORAGE, 
                    facility, facSize,
                    __TEXT("Storage"));
        break;

    case FACILITY_DISPATCH:
        bLoaded = LoadMyString(IDS_FAC_DISPATCH, 
                    facility, facSize,
                    __TEXT("Dispatch"));
        break;

    case FACILITY_WIN32:
        bLoaded = LoadMyString(IDS_FAC_WIN32, 
                    facility, facSize,
                    __TEXT("Win32"));
        break;

    case FACILITY_WINDOWS:
        bLoaded = LoadMyString(IDS_FAC_WINDOWS, 
                    facility, facSize,
                    __TEXT("Windows"));
        break;

    case FACILITY_SSPI:
        bLoaded = LoadMyString(IDS_FAC_SSPI, 
                    facility, facSize,
                    __TEXT("SSPI"));
        break;

    case FACILITY_CONTROL:
        bLoaded = LoadMyString(IDS_FAC_CONTROL, 
                    facility, facSize,
                    __TEXT("Control"));
        // get error msg from the system.
        break;

    case FACILITY_CERT:
        bLoaded = LoadMyString(IDS_FAC_CERT, 
                    facility, facSize,
                    __TEXT("Cert"));
        break;

    case FACILITY_INTERNET:
        bLoaded = LoadMyString(IDS_FAC_INET, 
                    facility, facSize,
                    __TEXT("Internet"));
        break;

    default :
        bLoaded = LoadMyString(IDS_FAC_UNKNOWN, 
                    facility, facSize,
                    __TEXT("General"));
        break;
    } //endswitch

    if(bLoaded)
    {
#ifdef UNICODE
        *MessageText = SysAllocString(facility);
#else
        wchar_t *wcErr = new wchar_t[strlen(facility) + 1];
        mbstowcs(wcErr, facility, strlen(facility)+1);
        *MessageText = SysAllocString(wcErr);
        delete [] wcErr;
#endif

        if(*MessageText)
            return  S_OK;
    }
    return WBEM_E_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wmiquery.h ===
//***************************************************************************
//
//  WMIQUERY.H
//
//  IWbemQuery, _IWmiQuery implementation
//
//  raymcc  10-Apr-00       Created
//
//***************************************************************************

#ifndef _WMIQUERY_H_
#define _WMIQUERY_H_


#include "genlex.h"
#include "assocqp.h"
#include "wqlnode.h"
#include "wql.h"



class CWmiQuery : public _IWmiQuery
{
    ULONG m_uRefCount;
    CAssocQueryParser *m_pAssocParser;
    CTextLexSource *m_pLexerSrc;
    BOOL m_bParsed;
    CFlexArray m_aClassCache;
    CWQLParser *m_pParser;

    SWbemRpnEncodedQuery *m_pQuery;

    ULONG m_uRestrictedFeatures[WMIQ_LF_LAST];
    ULONG m_uRestrictedFeaturesSize;

public:
        //  IUnknown

        virtual ULONG STDMETHODCALLTYPE AddRef (void);
		virtual ULONG STDMETHODCALLTYPE Release (void);

		virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riid, void **ppv);

        // IWbemQuery

        virtual HRESULT STDMETHODCALLTYPE Empty( void);

        virtual HRESULT STDMETHODCALLTYPE SetLanguageFeatures(
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uArraySize,
            /* [in] */ ULONG __RPC_FAR *puFeatures);

        virtual HRESULT STDMETHODCALLTYPE TestLanguageFeatures(
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *uArraySize,
            /* [out] */ ULONG __RPC_FAR *puFeatures);

        virtual HRESULT STDMETHODCALLTYPE Parse(
            /* [in] */ LPCWSTR pszLang,
            /* [in] */ LPCWSTR pszQuery,
            /* [in] */ ULONG uFlags);

        virtual HRESULT STDMETHODCALLTYPE GetAnalysis(
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pAnalysis
            );

        virtual HRESULT STDMETHODCALLTYPE FreeMemory(
            LPVOID pMem
            );

        virtual HRESULT STDMETHODCALLTYPE GetQueryInfo(
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uInfoId,
            /* [in] */ ULONG uBufSize,
            /* [out] */ LPVOID pDestBuf);


        virtual HRESULT STDMETHODCALLTYPE Dump(LPSTR pszFile);

    CWmiQuery();
    void InitEmpty();   // Used by the CGenFactory<> class factory.


    static HRESULT Startup();
    static HRESULT Shutdown();
    static HRESULT CanUnload();

private:
   ~CWmiQuery();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wql.cpp ===
//***************************************************************************
//
//  WQL.CPP
//
//  WQL Parser
//
//  Implements the LL(1) syntax described in WQL.BNF via a recursive
//  descent parser.
//
//  raymcc    14-Sep-97       Created for WMI/SMS.
//  raymcc    18-Oct-97       Additional extensions for SMS team.
//  raymcc    20-Apr-00       Whistler RPN extensions
//  raymcc    19-May-00       Whistler delete/insert/update extensions
//
//***************************************************************************
// TO DO:

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <flexarry.h>

#include <wqllex.h>

#include <wqlnode.h>
#include <wql.h>
#include <helpers.h>

#include "wmiquery.h"
#include <corex.h>
#include <memory>
#include <autoptr.h>
#include <math.h>
#include <comdef.h>
void __stdcall _com_issue_error(long hResult) { throw hResult;};

POLARITY BOOL ReadI64(LPCWSTR wsz, UNALIGNED __int64& ri64);
POLARITY BOOL ReadUI64(LPCWSTR wsz, UNALIGNED unsigned __int64& rui64);


//***************************************************************************
//
//   Misc
//
//***************************************************************************
//

static DWORD FlipOperator(DWORD dwOp);

#define trace(x) printf x

void StrArrayDelete(ULONG, LPWSTR *);

HRESULT StrArrayCopy(
    ULONG  uSize,
    LPWSTR *pSrc,
    LPWSTR **pDest
    );

//***************************************************************************
//
//  CloneLPWSTR
//
//***************************************************************************
//  ok
static LPWSTR CloneLPWSTR(LPCWSTR pszSrc)
{
    if (pszSrc == 0)
        return 0;
    LPWSTR pszTemp = new wchar_t[wcslen(pszSrc) + 1];
    if (pszTemp == 0)
        return 0;
    wcscpy(pszTemp, pszSrc);
    return pszTemp;
}

//***************************************************************************
//
//  CloneFailed
//
//***************************************************************************

bool inline CloneFailed(LPCWSTR p1, LPCWSTR p2)
{
	if (0 == p1 && 0 == p2 ) return false;
    if (p1 && p2) return false;
	return true;
}

//***************************************************************************
//
//  CWQLParser::CWQLParser
//
//  Constructor
//
//  Parameters:
//  <pSrc>          A source from which to lex from.
//
//***************************************************************************
//
CWQLParser::CWQLParser(
    LPWSTR pszQueryText,
    CGenLexSource *pSrc
    )
{
    if (pszQueryText == 0 || pSrc == 0)
        throw CX_Exception();

    m_pLexer = new CGenLexer(WQL_LexTable, pSrc);
    if (m_pLexer == 0)
        throw CX_Exception();

    m_pszQueryText = CloneLPWSTR(pszQueryText);
    if (m_pszQueryText == 0 && pszQueryText!=0 )
    {
        delete m_pLexer;
        m_pLexer = 0;
        throw CX_Exception();
    }

    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    m_uFeatures = 0I64;

    m_pQueryRoot = 0;
    m_pRootWhere = 0;
    m_pRootColList = 0;
    m_pRootFrom = 0;
    m_pRootWhereOptions = 0;
    m_nParseContext = Ctx_Default;

    m_bAllowPromptForConstant = false;
}

//***************************************************************************
//
//  CWQLParser::~CWQLParser
//
//***************************************************************************
//
CWQLParser::~CWQLParser()
{
    Empty();
    delete m_pLexer;
}

//***************************************************************************
//
//  CWQLParser::Empty
//
//***************************************************************************
// ok
void CWQLParser::Empty()
{
    m_aReferencedTables.Empty();
    m_aReferencedAliases.Empty();

    m_pTokenText = 0;   // We don't delete this, it was never allocated
    m_nLine = 0;
    m_nCurrentToken = 0;
    m_uFeatures = 0I64;

    delete m_pQueryRoot;    // Clean up previous query, if any

    m_pQueryRoot = 0;
    m_pRootWhere = 0;
    m_pRootColList = 0;
    m_pRootFrom = 0;
    m_pRootWhereOptions = 0;
    m_nParseContext = Ctx_Default;

    // For the next two, we don't delete the pointers since they
    // were copies of structs elsewhere in the tree.
    // =========================================================

    m_aSelAliases.Empty();
    m_aSelColumns.Empty();

    delete [] m_pszQueryText;
}

//***************************************************************************
//
//  CWQLParser::GetTokenLong
//
//  Converts the current token to a 32/64 bit integer.  Returns info
//  about the size of the constant.
//
//***************************************************************************
// ok
BOOL CWQLParser::GetIntToken(
    OUT BOOL *bSigned,
    OUT BOOL *b64Bit,
    OUT unsigned __int64 *pVal
    )
{
    BOOL bRes;

    if (m_pTokenText == 0 || *m_pTokenText == 0)
        return FALSE;

    if (*m_pTokenText == L'-')
    {
        __int64 Temp;
        bRes = ReadI64(m_pTokenText, Temp);
        if (bRes == FALSE)
            return FALSE;
        *bSigned = TRUE;
        if (Temp <  -2147483648I64)
        {
            *b64Bit = TRUE;
        }
        else
        {
            *b64Bit = FALSE;
        }
        *pVal = (unsigned __int64) Temp;
    }
    else
    {
        bRes = ReadUI64(m_pTokenText, *pVal);
        if (bRes == FALSE)
            return FALSE;
        *bSigned = FALSE;
        if (*pVal >> 32)
        {
            *b64Bit = TRUE;
            if (*pVal <= 0x7FFFFFFFFFFFFFFFI64)
            {
                *bSigned = TRUE;
            }
        }
        else
        {
            *b64Bit = FALSE;

            // See if we can dumb down to 32-bit VT_I4 for simplicity.
            // Much code recognizes VT_I4 and doesn't recognize VT_UI4
            // because it can't be packed into a VARIANT.  So, if there
            // are only 31 bits used, let's convert to VT_I4. We do this
            // by returning this as a 'signed' value (the positive sign :).

            if (*pVal <= 0x7FFFFFFF)
            {
                *bSigned = TRUE;
            }
        }
    }


    return TRUE;
}

//***************************************************************************
//
//  CWQLParser::GetReferencedTables
//
//  Creates an array of the names of the tables referenced in this query
//
//***************************************************************************
// ok
BOOL CWQLParser::GetReferencedTables(OUT CWStringArray& Tables)
{
    Tables = m_aReferencedTables;
    return TRUE;
}

//***************************************************************************
//
//  CWQLParser::GetReferencedAliases
//
//***************************************************************************
// ok
BOOL CWQLParser::GetReferencedAliases(OUT CWStringArray & Aliases)
{
    Aliases = m_aReferencedAliases;
    return TRUE;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************
// ok
struct WqlKeyword
{
    LPWSTR m_pKeyword;
    int    m_nTokenCode;
};

static WqlKeyword KeyWords[] =      // Keep this alphabetized for binary search
{
    L"ALL",         WQL_TOK_ALL,
    L"AND",         WQL_TOK_AND,
    L"AS",          WQL_TOK_AS,
    L"ASC",         WQL_TOK_ASC,
    L"ASSOCIATORS", WQL_TOK_ASSOCIATORS,
    L"BETWEEN",     WQL_TOK_BETWEEN,
    L"BY",       WQL_TOK_BY,
    L"COUNT",    WQL_TOK_COUNT,
    L"DATEPART", WQL_TOK_DATEPART,
    L"DELETE",   WQL_TOK_DELETE,
    L"DESC",     WQL_TOK_DESC,
    L"DISTINCT", WQL_TOK_DISTINCT,
    L"FROM",     WQL_TOK_FROM,
    L"FULL",     WQL_TOK_FULL,
    L"GROUP",    WQL_TOK_GROUP,
    L"HAVING",   WQL_TOK_HAVING,
    L"IN",       WQL_TOK_IN,
    L"INNER",    WQL_TOK_INNER,
    L"INSERT",   WQL_TOK_INSERT,
    L"ISA",      WQL_TOK_ISA,

    L"ISNULL",   WQL_TOK_ISNULL,
    L"JOIN",     WQL_TOK_JOIN,
    L"LEFT",     WQL_TOK_LEFT,
    L"LIKE",     WQL_TOK_LIKE,
    L"LOWER",    WQL_TOK_LOWER,
    L"NOT",      WQL_TOK_NOT,
    L"NULL",     WQL_TOK_NULL,
    L"ON",       WQL_TOK_ON,
    L"OR",       WQL_TOK_OR,
    L"ORDER",    WQL_TOK_ORDER,
    L"OUTER",           WQL_TOK_OUTER,
    L"__QUALIFIER",     WQL_TOK_QUALIFIER,
    L"REFERENCES",      WQL_TOK_REFERENCES,
    L"RIGHT",           WQL_TOK_RIGHT,
    L"SELECT",   WQL_TOK_SELECT,
    L"__THIS",   WQL_TOK_THIS,
    L"UPDATE",   WQL_TOK_UPDATE,
    L"UPPER",    WQL_TOK_UPPER,
    L"WHERE",    WQL_TOK_WHERE
};

const int NumKeywords = sizeof(KeyWords)/sizeof(WqlKeyword);

BOOL CWQLParser::Next()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == WQL_TOK_ERROR
        || (m_nCurrentToken == WQL_TOK_PROMPT && !m_bAllowPromptForConstant))
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == WQL_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check. Do a binary search
    // on the keyword table.
    // =================================

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        int l = 0, u = NumKeywords - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) < 0)
                u = m - 1;
            else if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) > 0)
                l = m + 1;
            else        // Match
            {
                m_nCurrentToken = KeyWords[m].m_nTokenCode;
                break;
            }
        }
    }

    return TRUE;
}


//***************************************************************************
//
//  <parse> ::= SELECT <select_stmt>;
//          ::= DELETE <delete_stmt>;
//          ::= INSERT <insert_stmt>;
//          ::= UPDATE <update_stmt>;
//
//  Precondition: All cleanup has been performed from previous parse
//                by a call to Empty()
//
//***************************************************************************
// ok
HRESULT CWQLParser::Parse()
{
    HRESULT hRes = WBEM_E_INVALID_SYNTAX;

    m_pQueryRoot = new SWQLNode_QueryRoot;
    if (!m_pQueryRoot)
        return WBEM_E_OUT_OF_MEMORY;

    try
    {
        m_pLexer->Reset();

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        // See which kind of query we have.
        // ================================

        switch (m_nCurrentToken)
        {
            case WQL_TOK_SELECT:
                {
                    if (!Next())
                        return WBEM_E_INVALID_SYNTAX;

                    SWQLNode_Select *pSelStmt = 0;
                    hRes = select_stmt(&pSelStmt);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pSelStmt;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eSelect;
                }
                break;

            case WQL_TOK_ASSOCIATORS:
            case WQL_TOK_REFERENCES:
                {
                    SWQLNode_AssocQuery *pAQ = 0;
                    hRes = assocquery(&pAQ);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pAQ;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eAssoc;
                }
                break;

            case WQL_TOK_INSERT:
                {
                    if (!Next())
                        return WBEM_E_INVALID_SYNTAX;
                    SWQLNode_Insert *pIns = 0;
                    hRes = insert_stmt(&pIns);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pIns;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eInsert;
                }
                break;

            case WQL_TOK_DELETE:
                {
                    if (!Next())
                        return WBEM_E_INVALID_SYNTAX;

                    SWQLNode_Delete *pDel = 0;
                    hRes = delete_stmt(&pDel);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pDel;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eDelete;
                }
                break;

            case WQL_TOK_UPDATE:
                {
                    if (!Next())
                        return WBEM_E_INVALID_SYNTAX;

                    SWQLNode_Update *pUpd = 0;
                    hRes = update_stmt(&pUpd);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pUpd;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eUpdate;
                }
                break;

            default:
                return WBEM_E_INVALID_SYNTAX;
        }
    }
    catch (CX_MemoryException)
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    return hRes;
}

//***************************************************************************
//
//  <select_stmt> ::=
//      <select_type>
//      <col_ref_list>
//      <from_clause>
//      <where_clause>
//
//***************************************************************************
// ok
int CWQLParser::select_stmt(OUT SWQLNode_Select **pSelStmt)
{
    int nRes = 0;
    int nType = 0;
    SWQLNode_FromClause *pFrom = 0;
    SWQLNode_Select *pSel = 0;
    SWQLNode_TableRefs *pTblRefs = 0;
    SWQLNode_WhereClause *pWhere = 0;

    *pSelStmt = 0;

    // Set up the basic AST.
    // =====================

    pSel = new SWQLNode_Select;
    if (!pSel)
        return WBEM_E_OUT_OF_MEMORY;
    pTblRefs = new SWQLNode_TableRefs;
    if (!pTblRefs)
    {
        delete pSel;
        return WBEM_E_OUT_OF_MEMORY;
    }
    pSel->m_pLeft = pTblRefs;

    // Get the select type.
    // ====================

    nRes = select_type(nType);
    if (nRes)
        goto Exit;

    pTblRefs->m_nSelectType = nType;        // ALL, DISTINCT

    // Get the selected list of columns.
    // =================================

    nRes = col_ref_list(pTblRefs);
    if (nRes)
        goto Exit;

    m_pRootColList = (SWQLNode_ColumnList *) pTblRefs->m_pLeft;

    // Get the FROM clause and patch it into the AST.
    // ===============================================

    nRes = from_clause(&pFrom);
    if (nRes)
        goto Exit;

    m_pRootFrom = pFrom;
    pTblRefs->m_pRight = pFrom;

    // Get the WHERE clause.
    // =====================

    nRes = where_clause(&pWhere);
    if (nRes)
        goto Exit;

    m_pRootWhere = pWhere;
    pSel->m_pRight = pWhere;

    // Verify we are at the end of the query.
    // ======================================

    if (m_nCurrentToken != WQL_TOK_EOF)
    {
        nRes = WBEM_E_INVALID_SYNTAX;
        goto Exit;
    }

    nRes = NO_ERROR;

Exit:
    if (nRes)
        delete pSel;
    else
    {
        *pSelStmt = pSel;
    }

    return nRes;
}

//***************************************************************************
//
//  CWQLParser::delete_stmt
//
//***************************************************************************
// ok
int CWQLParser::delete_stmt(OUT SWQLNode_Delete **pDelStmt)
{
    int nRes = 0;
    int nType = 0;
    SWQLNode_TableRef *pTblRef = 0;
    SWQLNode_WhereClause *pWhere = 0;

    // Default in case of error.
    // =========================

    *pDelStmt = 0;

    if (m_nCurrentToken != WQL_TOK_FROM)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // Otherwise, traditional SQL.
    // ===========================

    nRes = single_table_decl(&pTblRef);
    if (nRes)
        return nRes;

    // Get the WHERE clause.
    // =====================

    nRes = where_clause(&pWhere);
    if (nRes)
    {
        delete pTblRef;
        return nRes;
    }

    // Verify we are at the end of the query.
    // ======================================

    if (m_nCurrentToken != WQL_TOK_EOF)
    {
        nRes = WBEM_E_INVALID_SYNTAX;
        delete pTblRef;
        delete pWhere;
    }
    else
    {
        // If here, everything is wonderful.
        // ==================================

        SWQLNode_Delete *pDel = new SWQLNode_Delete;
        if (!pDel)
        {
            // Except that we might have just run out of memory...
            // ====================================================

            delete pTblRef;
            delete pWhere;
            return WBEM_E_OUT_OF_MEMORY;
        }

        // Patch in the new node.
        // =====================

        pDel->m_pLeft = pTblRef;
        pDel->m_pRight = pWhere;
        *pDelStmt = pDel;
        nRes = WBEM_S_NO_ERROR;
    }

    return nRes;
}


//***************************************************************************
//
//  <select_type> ::= ALL;
//  <select_type> ::= DISTINCT;
//  <select_type> ::= <>;
//
//  Returns type through nSelType :
//      WQL_TOK_ALL or WQL_TOK_DISTINCT
//
//***************************************************************************
// done

int CWQLParser::select_type(int & nSelType)
{
    nSelType = WQL_FLAG_ALL;        // Default

    if (m_nCurrentToken == WQL_TOK_ALL)
    {
        nSelType = WQL_FLAG_ALL;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_DISTINCT)
    {
        nSelType = WQL_FLAG_DISTINCT;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        return NO_ERROR;
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  <col_ref_list> ::= <col_ref> <col_ref_rest>;
//  <col_ref_list> ::= ASTERISK;
//  <col_ref_list> ::= COUNT <count_clause>;
//
//***************************************************************************
// ?
int CWQLParser::col_ref_list(
    IN OUT SWQLNode_TableRefs *pTblRefs
    )
{
    int nRes;
    DWORD dwFuncFlags = 0;

    // Allocate a new left node of type SWQLNode_ColumnList and patch it in
    // if it doesn't already exist.
    // =====================================================================

    SWQLNode_ColumnList *pColList = (SWQLNode_ColumnList *) pTblRefs->m_pLeft;

    if (pColList == NULL)
    {
        pColList = new SWQLNode_ColumnList;
        if (!pColList)
            return WBEM_E_OUT_OF_MEMORY;
        pTblRefs->m_pLeft = pColList;
    }


    // If here, it is a "select *..." query.
    // =====================================

    if (m_nCurrentToken == WQL_TOK_ASTERISK)
    {
        // Allocate a new column list which has a single asterisk.
        // =======================================================

        SWQLColRef *pColRef = new SWQLColRef;
        if (!pColRef)
            return WBEM_E_OUT_OF_MEMORY;

        pColRef->m_pColName = CloneLPWSTR(L"*");
        if (pColRef->m_pColName == 0)
        {
            delete pColRef;
            return WBEM_E_OUT_OF_MEMORY;
        }

        m_uFeatures |= WMIQ_RPNF_FEATURE_SELECT_STAR;

        pColRef->m_dwFlags = WQL_FLAG_ASTERISK;

        if (pColList->m_aColumnRefs.Add(pColRef) != CFlexArray::no_error)
        {
            delete pColRef;
            return WBEM_E_OUT_OF_MEMORY;
        };

        if (!Next())
        {
           return WBEM_E_INVALID_SYNTAX;
        }

        return NO_ERROR;
    }

    // If here, we have a "select COUNT..." operation.
    // ===============================================

    if (m_nCurrentToken == WQL_TOK_COUNT)
    {
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        SWQLQualifiedName *pQN = 0;
        nRes = count_clause(&pQN);
        if (!nRes)
        {
            pTblRefs->m_nSelectType |= WQL_FLAG_COUNT;

            SWQLColRef *pCR = 0;
            if (SUCCEEDED(nRes = QNameToSWQLColRef(pQN, &pCR)))
            {
                if (pColList->m_aColumnRefs.Add(pCR))
                {
                    delete pCR;
                    return WBEM_E_OUT_OF_MEMORY;
                }
            }

            return nRes;
        }
        else
        {
            // This may be a column named count
            // in which case the current token is
            // either an ident or "from"

            if (m_nCurrentToken == WQL_TOK_FROM ||
                m_nCurrentToken == WQL_TOK_COMMA)
            {
                wmilib::auto_ptr<SWQLColRef> pCR = wmilib::auto_ptr<SWQLColRef>(new SWQLColRef);

                if (pCR.get())
                {
                    pCR->m_pColName = CloneLPWSTR(L"count");
                    if (pCR->m_pColName == 0)
                        return WBEM_E_OUT_OF_MEMORY;
                    if (pColList->m_aColumnRefs.Add(pCR.get()) != CFlexArray::no_error)
                        return WBEM_E_OUT_OF_MEMORY;
                    pCR.release();
                }
                else
                    return WBEM_E_OUT_OF_MEMORY;

                if (WQL_TOK_FROM == m_nCurrentToken)
                    return 0;
                else
                {
                    return col_ref_rest(pTblRefs);
                }
            }
            else
                return WBEM_E_INVALID_SYNTAX;
        }
    }

    // Make a provision for wrapping the
    // column in a function all UPPER or LOWER
    // =======================================

    if (m_nCurrentToken == WQL_TOK_UPPER)
        dwFuncFlags = WQL_FLAG_FUNCTIONIZED | WQL_FLAG_UPPER;
    else if (m_nCurrentToken == WQL_TOK_LOWER)
        dwFuncFlags = WQL_FLAG_FUNCTIONIZED | WQL_FLAG_LOWER;

    if (dwFuncFlags)
    {
        // Common procedure for cases where UPPER or LOWER are used.

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }


    // If here, must be an identifier.
    // ===============================

    if (m_nCurrentToken != WQL_TOK_IDENT)
        return WBEM_E_INVALID_SYNTAX;

    SWQLQualifiedName *pInitCol = 0;

    nRes = col_ref(&pInitCol);
    if (nRes)
        return nRes;

    wmilib::auto_ptr<SWQLQualifiedName> initCol(pInitCol);

    SWQLColRef *pCR = 0;
    nRes = QNameToSWQLColRef(initCol.get(), &pCR);
    if (nRes)
    	return nRes;

    initCol.release();

    pCR->m_dwFlags |= dwFuncFlags;

    if (dwFuncFlags)
    {
        // If a function call was invoked, remove the trailing paren.
        // ==========================================================

        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return WBEM_E_INVALID_SYNTAX;

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }

    pColList->m_aColumnRefs.Add(pCR);

    m_uFeatures |= WMIQ_RPNF_PROJECTION;

    return col_ref_rest(pTblRefs);
}


//***************************************************************************
//
//  <count_clause> ::= OPEN_PAREN <count_col> CLOSE_PAREN;
//  <count_col> ::= ASTERISK;
//  <count_col> ::= IDENT;
//
//  On NO_ERROR returns:
//  <bAsterisk> set to TRUE if a * occurred in the COUNT clause,
//  or <bAsterisk> set to FALSE and <pQualName> set to point to the
//  qualified name of the column referenced.
//
//***************************************************************************
// ok
int CWQLParser::count_clause(
    OUT SWQLQualifiedName **pQualName
    )
{
    int nRes;
    *pQualName = 0;

    // Syntax check.
    // =============
    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // Determine whether an asterisk was used COUNT(*) or
    // a col-ref COUNT(col-ref)
    // ==================================================

    if (m_nCurrentToken == WQL_TOK_ASTERISK)
    {
        SWQLQualifiedName *pQN = new SWQLQualifiedName;
        if (!pQN)
            return WBEM_E_OUT_OF_MEMORY;
        SWQLQualifiedNameField *pQF = new SWQLQualifiedNameField;
        if (!pQF)
        {
            delete pQN;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pQF->m_pName = CloneLPWSTR(L"*");
        if (pQF->m_pName == 0)
        {
            delete pQN;
            delete pQF;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pQN->Add(pQF);
        *pQualName = pQN;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        m_uFeatures |= WMIQ_RPNF_COUNT_STAR;
    }
    else if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        SWQLQualifiedName *pQN = 0;
        nRes = col_ref(&pQN);
        if (nRes)
            return nRes;
        *pQualName = pQN;
    }

    // Check for errors in syntax and clean up
    // if so.
    // =======================================

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
    {
        if (*pQualName)
            delete *pQualName;
        *pQualName = 0;
        return WBEM_E_INVALID_SYNTAX;
    }

    if (!Next())
    {
        if (*pQualName)
            delete *pQualName;
        *pQualName = 0;
        return WBEM_E_INVALID_SYNTAX;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  <col_ref_rest> ::= COMMA <col_ref_list>;
//  <col_ref_rest> ::= <>;
//
//***************************************************************************

int CWQLParser::col_ref_rest(IN OUT SWQLNode_TableRefs *pTblRefs)
{
    int nRes;

    if (m_nCurrentToken != WQL_TOK_COMMA)
        return NO_ERROR;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    nRes = col_ref_list(pTblRefs);
    return nRes;
}

//***************************************************************************
//
//  <from_clause> ::= <table_list>;
//  <from_clause> ::= <wmi_scoped_select>;
//
//  <table_list> ::= <single_table_decl> <optional_join>;
//
//  <optional_join> ::= <sql89_join_entry>;
//  <optional_join> ::= <sql92_join_entry>;
//
//  <optional_join> ::= <>;     // Unary query
//
//***************************************************************************

int CWQLParser::from_clause(OUT SWQLNode_FromClause **pFrom)
{
    int nRes = 0;
    SWQLNode_TableRef *pTbl = 0;
    std::auto_ptr<SWQLNode_FromClause> pFC (new SWQLNode_FromClause);
    if (pFC.get() == 0)
        return WBEM_E_OUT_OF_MEMORY;

    if (m_nCurrentToken != WQL_TOK_FROM)
    {
        return WBEM_E_INVALID_SYNTAX;
    }
    if (!Next())
    {
        return WBEM_E_INVALID_SYNTAX;
    }

    // Special case for WMI scope selections.
    // ======================================

    if (m_nCurrentToken == WQL_TOK_BRACKETED_STRING)
    {
        nRes = wmi_scoped_select (pFC.get ());
        *pFrom = pFC.release();
        return nRes;
    }

    // Otherwise, traditional SQL.
    // ===========================

    nRes = single_table_decl(&pTbl);
    if (nRes)
    {
        return nRes;
    }

    // Check for joins.
    // ===============

    if (m_nCurrentToken == WQL_TOK_COMMA)
    {
        SWQLNode_Sql89Join *pJoin = 0;
        nRes = sql89_join_entry(pTbl, &pJoin);
        if (nRes)
        {
            return nRes;
        }
        pFC->m_pLeft = pJoin;
    }
    else
    {

        if (m_nCurrentToken == WQL_TOK_INNER ||
            m_nCurrentToken == WQL_TOK_FULL  ||
            m_nCurrentToken == WQL_TOK_LEFT  ||
            m_nCurrentToken == WQL_TOK_RIGHT ||
            m_nCurrentToken == WQL_TOK_JOIN
            )
        {
            SWQLNode_Join *pJoin = 0;
            nRes = sql92_join_entry(pTbl, &pJoin);
            if (nRes)
            {
                return nRes;
            }
            pFC->m_pLeft = pJoin;
        }

        // Single table select (unary query).
        // ==================================
        else
        {
            pFC->m_pLeft = pTbl;
        }
    }

    *pFrom = pFC.release();

    return NO_ERROR;
}

//***************************************************************************
//
//  wmi_scoped_select
//
//  '[' objectpath ']'  <class-list>
//
//  <class-list> ::= CLASS
//  <class-list> ::= '{' class1, class2, ...classn '}'
//
//***************************************************************************
//
int CWQLParser::wmi_scoped_select(SWQLNode_FromClause *pFC)
{
    // Strip all input up to the next closing bracket.
    // ===============================================

    SWQLNode_WmiScopedSelect *pSS = new SWQLNode_WmiScopedSelect;
    if (!pSS)
        throw CX_MemoryException();

    pSS->m_pszScope = CloneLPWSTR(m_pTokenText);
    if (!pSS->m_pszScope)
    {
        delete pSS;
        throw CX_MemoryException();
    }

    if (!Next())
        goto Error;

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        // Get simple class name.
        // ======================

        LPWSTR pszTmp = CloneLPWSTR(m_pTokenText);
        if (pszTmp == 0)
        {
            delete pSS;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pSS->m_aTables.Add(pszTmp);

        if (!Next())
            goto Error;
    }
    else if (m_nCurrentToken == WQL_TOK_OPEN_BRACE)
    {
        while(1)
        {
            if (!Next())
               goto Error;
            if (m_nCurrentToken == WQL_TOK_IDENT)
            {
                LPWSTR pszTmp = CloneLPWSTR(m_pTokenText);
                if (pszTmp == 0)
                {
                    delete pSS;
                    return WBEM_E_OUT_OF_MEMORY;
                }
                pSS->m_aTables.Add(pszTmp);
            }
            else
                goto Error;
            if (!Next())
               goto Error;
            if (m_nCurrentToken == WQL_TOK_CLOSE_BRACE)
                break;
            if (m_nCurrentToken == WQL_TOK_COMMA)
                continue;
        }
        if (!Next())
            goto Error;
    }

    // Patch in the node.
    // ==================

    pFC->m_pRight = pSS;
    return NO_ERROR;

Error:
    delete pSS;
    return WBEM_E_INVALID_SYNTAX;
}


//***************************************************************************
//
//  <sql89_join_entry> ::= COMMA <sql89_join_list>;
//
//***************************************************************************


int CWQLParser::sql89_join_entry(IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin )
{
    if (m_nCurrentToken != WQL_TOK_COMMA)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    return sql89_join_list(pInitialTblRef, pJoin);
}

//***************************************************************************
//
//  <sql89_join_list> ::= <single_table_decl> <sql89_join_rest>;
//
//  <sql89_join_rest> ::= COMMA <sql89_join_list>;
//  <sql89_join_rest> ::= <>;
//
//***************************************************************************

int CWQLParser::sql89_join_list(IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin )
{
    int nRes;

    SWQLNode_Sql89Join *p89Join = new SWQLNode_Sql89Join;
    if (!p89Join)
        return WBEM_E_OUT_OF_MEMORY;

    p89Join->m_aValues.Add(pInitialTblRef);

    while (1)
    {
        SWQLNode_TableRef *pTR = 0;
        nRes = single_table_decl(&pTR);
        if (nRes)
        {
            delete p89Join;
            return nRes;
        }
        p89Join->m_aValues.Add(pTR);
        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;
        if (!Next())
        {
            delete p89Join;
            return WBEM_E_INVALID_SYNTAX;
        }
    }

    *pJoin = p89Join;

    return NO_ERROR;
}

//***************************************************************************
//
//  <where_clause> ::= WQL_TOK_WHERE <rel_expr> <where_options>;
//  <where_clause> ::= <>;          // 'where' is not required
//
//***************************************************************************
// done

int CWQLParser::where_clause(OUT SWQLNode_WhereClause **pRetWhere)
{
    SWQLNode_WhereClause *pWhere = new SWQLNode_WhereClause;
    if (!pWhere)
        return WBEM_E_OUT_OF_MEMORY;

    *pRetWhere = pWhere;
    SWQLNode_RelExpr *pRelExpr = 0;
    int nRes;

    // 'where' is optional.
    // ====================

    if (m_nCurrentToken == WQL_TOK_WHERE)
    {
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        m_uFeatures |= WMIQ_RPNF_WHERE_CLAUSE_PRESENT;

        // Get the primary relational expression for the 'where' clause.
        // =============================================================
        nRes = rel_expr(&pRelExpr);
        if (nRes)
        {
            delete pRelExpr;
            return nRes;
        }
    }

    // Get the options, such as ORDER BY, GROUP BY, etc.
    // =================================================

    SWQLNode_WhereOptions *pWhereOpt = 0;
    nRes = where_options(&pWhereOpt);
    if (nRes)
    {
        delete pRelExpr;
        delete pWhereOpt;
        return nRes;
    }

    pWhere->m_pLeft = pRelExpr;
    pWhere->m_pRight = pWhereOpt;
    m_pRootWhereOptions = pWhereOpt;

    return NO_ERROR;
}

//***************************************************************************
//
//  <where_options> ::=
//      <group_by_clause>
//      <order_by_clause>
//
//***************************************************************************
// done

int CWQLParser::where_options(OUT SWQLNode_WhereOptions **pRetWhereOpt)
{
    int nRes;
    *pRetWhereOpt = 0;

    SWQLNode_GroupBy *pGroupBy = 0;
    nRes = group_by_clause(&pGroupBy);
    if (nRes)
    {
        delete pGroupBy;
        return nRes;
    }

    SWQLNode_OrderBy *pOrderBy = 0;
    nRes = order_by_clause(&pOrderBy);
    if (nRes)
    {
        delete pOrderBy;
        delete pGroupBy;
        return nRes;
    }

    SWQLNode_WhereOptions *pWhereOpt = 0;

    if (pGroupBy || pOrderBy)
    {
        pWhereOpt = new SWQLNode_WhereOptions;
        if (!pWhereOpt)
        {
            delete pOrderBy;
            delete pGroupBy;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pWhereOpt->m_pLeft = pGroupBy;
        pWhereOpt->m_pRight = pOrderBy;
    }

    *pRetWhereOpt = pWhereOpt;
    return NO_ERROR;
}


//***************************************************************************
//
//  <group_by_clause> ::= WQL_TOK_GROUP WQL_TOK_BY <col_list> <having_clause>;
//  <group_by_clause> ::= <>;
//
//***************************************************************************
// done

int CWQLParser::group_by_clause(OUT SWQLNode_GroupBy **pRetGroupBy)
{
    int nRes;
    *pRetGroupBy = 0;

    if (m_nCurrentToken != WQL_TOK_GROUP)
        return NO_ERROR;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;
    if (m_nCurrentToken != WQL_TOK_BY)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // Get the guts of the GROUP BY.
    // =============================

    SWQLNode_GroupBy *pGroupBy = new SWQLNode_GroupBy;
    if (!pGroupBy)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    SWQLNode_ColumnList *pColList = 0;

    nRes = col_list(&pColList);
    if (nRes)
    {
        delete pGroupBy;
        delete pColList;
        return nRes;
    }

    pGroupBy->m_pLeft = pColList;

    // Check for the HAVING clause.
    // ============================
    SWQLNode_Having *pHaving = 0;
    nRes = having_clause(&pHaving);

    if (pHaving)
        pGroupBy->m_pRight = pHaving;

    *pRetGroupBy = pGroupBy;

    m_uFeatures |= WMIQ_RPNF_GROUP_BY_HAVING;

    return NO_ERROR;
}

//***************************************************************************
//
//  <having_clause> ::= WQL_TOK_HAVING <rel_expr>;
//  <having_clause> ::= <>;
//
//***************************************************************************
// done

int CWQLParser::having_clause(OUT SWQLNode_Having **pRetHaving)
{
    int nRes;
    *pRetHaving = 0;

    if (m_nCurrentToken != WQL_TOK_HAVING)
        return NO_ERROR;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // If here, we have a HAVING clause.
    // =================================

    SWQLNode_RelExpr *pRelExpr = 0;
    nRes = rel_expr(&pRelExpr);
    if (nRes)
    {
        delete pRelExpr;
        return nRes;
    }

    SWQLNode_Having *pHaving = new SWQLNode_Having;
    if (!pHaving)
    {
        delete pRelExpr;
        return WBEM_E_OUT_OF_MEMORY;
    }
    pHaving->m_pLeft = pRelExpr;

    *pRetHaving = pHaving;

    return NO_ERROR;
}

//***************************************************************************
//
//  <order_by_clause> ::= WQL_TOK_ORDER WQL_TOK_BY <col_list>;
//  <order_by_clause> ::= <>;
//
//***************************************************************************
//  done

int CWQLParser::order_by_clause(OUT SWQLNode_OrderBy **pRetOrderBy)
{
    int nRes;

    if (m_nCurrentToken != WQL_TOK_ORDER)
        return NO_ERROR;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;
    if (m_nCurrentToken != WQL_TOK_BY)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // If here, we have an ORDER BY clause.
    // ====================================

    m_uFeatures |= WMIQ_RPNF_ORDER_BY;

    SWQLNode_ColumnList *pColList = 0;
    nRes = col_list(&pColList);
    if (nRes)
    {
        delete pColList;
        return nRes;
    }

    SWQLNode_OrderBy *pOrderBy = new SWQLNode_OrderBy;
    if (!pOrderBy)
    {
        delete pColList;
        return WBEM_E_OUT_OF_MEMORY;
    }
    pOrderBy->m_pLeft = pColList;
    *pRetOrderBy = pOrderBy;

    return NO_ERROR;
}

//***************************************************************************
//
//  <single_table_decl> ::= <unbound_table_ident> <table_decl_rest>;
//
//  <unbound_table_ident> ::= IDENT;
//  <table_decl_rest> ::= <redundant_as> <table_alias>;
//  <table_decl_rest> ::= <>;
//  <table_alias> ::= IDENT;
//
//  <redundant_as> ::= AS;
//  <redundant_as> ::= <>;
//
//***************************************************************************
// done; no cleanup

int CWQLParser::single_table_decl(OUT SWQLNode_TableRef **pTblRef)
{
    if (pTblRef == 0)
        return WBEM_E_CRITICAL_ERROR;

    *pTblRef = 0;

    if (m_nCurrentToken != WQL_TOK_IDENT)
        return WBEM_E_INVALID_SYNTAX;

    SWQLNode_TableRef *pTR = new SWQLNode_TableRef;
    if (!pTR)
        return WBEM_E_OUT_OF_MEMORY;
    pTR->m_pTableName = CloneLPWSTR(m_pTokenText);
    if (pTR->m_pTableName == 0)
    {
        delete pTR;
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_aReferencedTables.Add(m_pTokenText);

    if (!Next())
    {
        delete pTR;
        return WBEM_E_INVALID_SYNTAX;
    }

    if (m_nCurrentToken == WQL_TOK_AS)
    {
        // Here we have a redundant AS and an alias.
        // =========================================
        if (!Next())
        {
            delete pTR;
            return WBEM_E_INVALID_SYNTAX;
        }
    }


    // If no Alias was used, we simply copy the table name into
    // the alias slot.
    // ========================================================
    else
    {
        pTR->m_pAlias = CloneLPWSTR(pTR->m_pTableName);
        if (pTR->m_pAlias == 0)
        {
            delete pTR;
            return WBEM_E_OUT_OF_MEMORY;
        }
        m_aReferencedAliases.Add(pTR->m_pTableName);
    }

    // For the primary select, we are keeping a list of tables
    // we are selecting from.
    // =======================================================

    if ((m_nParseContext & Ctx_Subselect) == 0)
        m_aSelAliases.Add(pTR);

    // Return the pointer to the caller.
    // =================================

    *pTblRef = pTR;

    return NO_ERROR;
}



//***************************************************************************
//
//  SQL-92 Joins.
//
//  We support:
//  1. [INNER] JOIN
//  2. LEFT [OUTER] JOIN
//  3. RIGHT [OUTER] JOIN
//  4. FULL [OUTER] JOIN
//
//
//  <sql92_join_entry> ::= <simple_join_clause>;
//  <sql92_join_entry> ::= INNER <simple_join_clause>;
//  <sql92_join_entry> ::= FULL <opt_outer> <simple_join_clause>;
//  <sql92_join_entry> ::= LEFT <opt_outer> <simple_join_clause>;
//  <sql92_join_entry> ::= RIGHT <opt_outer> <simple_join_clause>;
//
//  <opt_outer> ::= WQL_TOK_OUTER;
//  <opt_outer> ::= <>;
//
//  <simple_join_clause> ::=
//    JOIN
//    <single_table_decl>
//    <on_clause>
//    <sql92_join_continuator>
//
//  <sql92_join_continuator> ::= <sql92_join_entry>;
//  <sql92_join_continuator> ::= <>;
//
//***************************************************************************

int CWQLParser::sql92_join_entry(
    IN  SWQLNode_TableRef *pInitialTblRef,      // inherited
    OUT SWQLNode_Join **pJoin                   // synthesized
    )
{
    int nRes;

    /* Build a nested join tree bottom up.  Currently, the tree is always left-heavy:

            JN = Join Noe
            JP = Join Pair
            OC = On Clause
            TR = Table Ref

                   JN
                  /  \
                JP    OC
               /  \
             JN    TR
            /   \
          JP     OC
         /  \
        TR   TR
    */

    // State 1: Attempting to build a new JOIN node.
    // =============================================

    std::auto_ptr<SWQLNode_Join> pCurrentLeftNode;
    SWQLNode_JoinPair *pBottomJP = 0;

    while (1)
    {
      std::auto_ptr<SWQLNode_Join> pJN (new SWQLNode_Join);
      if (pJN.get() == 0)
    return WBEM_E_OUT_OF_MEMORY;

        // Join-type.
        // ==========

        pJN->m_dwJoinType = WQL_FLAG_INNER_JOIN;    // Default

        if (m_nCurrentToken == WQL_TOK_INNER)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            pJN->m_dwJoinType = WQL_FLAG_INNER_JOIN;
        }
        else if (m_nCurrentToken == WQL_TOK_FULL)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            if (m_nCurrentToken == WQL_TOK_OUTER)
                if (!Next())
                    return WBEM_E_INVALID_SYNTAX;
            pJN->m_dwJoinType = WQL_FLAG_FULL_OUTER_JOIN;
        }
        else if (m_nCurrentToken == WQL_TOK_LEFT)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            if (m_nCurrentToken == WQL_TOK_OUTER)
                if (!Next())
                    return WBEM_E_INVALID_SYNTAX;
            pJN->m_dwJoinType = WQL_FLAG_LEFT_OUTER_JOIN;
        }
        else if (m_nCurrentToken == WQL_TOK_RIGHT)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            if (m_nCurrentToken == WQL_TOK_OUTER)
                if (!Next())
                    return WBEM_E_INVALID_SYNTAX;
            pJN->m_dwJoinType = WQL_FLAG_RIGHT_OUTER_JOIN;
        }

        // <simple_join_clause>
        // =====================

        if (m_nCurrentToken != WQL_TOK_JOIN)
        {
            return WBEM_E_INVALID_SYNTAX;
        }

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

    std::auto_ptr<SWQLNode_JoinPair> pJP (new SWQLNode_JoinPair);

    if (pJP.get() == 0)
            return WBEM_E_OUT_OF_MEMORY;

        // Determine the table to which to join.
        // =====================================

        SWQLNode_TableRef *pTR = 0;
        nRes = single_table_decl(&pTR);
        if (nRes)
            return nRes;

        pJP->m_pRight = pTR;
        pJP->m_pLeft = pCurrentLeftNode.release();

    pCurrentLeftNode = pJN;

    if (pBottomJP==0)
      pBottomJP = pJP.get();

        // If FIRSTROW is used, add it in.
        // ===============================

        if (m_nCurrentToken == WQL_TOK_IDENT)
        {
            if (_wcsicmp(L"FIRSTROW", m_pTokenText) != 0)
                return WBEM_E_INVALID_SYNTAX;
            pCurrentLeftNode/*pJN*/->m_dwFlags |= WQL_FLAG_FIRSTROW;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
        }

        // Get the ON clause.
        // ==================
        SWQLNode_OnClause *pOC = 0;

        nRes = on_clause(&pOC);
        if (nRes)
            return nRes;

        pCurrentLeftNode/*pJN*/->m_pRight = pOC;    // On clause
        pCurrentLeftNode/*pJN*/->m_pLeft  = pJP.release();

        // sql92_join_continuator();
        // =========================

        if (m_nCurrentToken == WQL_TOK_INNER ||
            m_nCurrentToken == WQL_TOK_FULL  ||
            m_nCurrentToken == WQL_TOK_LEFT  ||
            m_nCurrentToken == WQL_TOK_RIGHT ||
            m_nCurrentToken == WQL_TOK_JOIN
            )
            continue;

        break;
    }

    // Return the join node to the caller.
    // ====================================
    //  Set
    pBottomJP->m_pLeft = pInitialTblRef;
    *pJoin = pCurrentLeftNode.release();

    return NO_ERROR;
}


//***************************************************************************
//
//  <on_clause> ::= ON <rel_expr>;
//
//***************************************************************************

int CWQLParser::on_clause(OUT SWQLNode_OnClause **pOC)
{
    if (m_nCurrentToken != WQL_TOK_ON)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    SWQLNode_OnClause *pNewOC = new SWQLNode_OnClause;
    if (!pNewOC)
        return WBEM_E_OUT_OF_MEMORY;

    SWQLNode_RelExpr *pRelExpr = 0;
    int nRes = rel_expr(&pRelExpr);
    if (nRes)
    {
        delete pRelExpr;
        return nRes;
    }

    pNewOC->m_pLeft = pRelExpr;
    *pOC = pNewOC;

    return NO_ERROR;
}

//***************************************************************************
//
//  <rel_expr> ::= <rel_term> <rel_expr2>;
//
//  We are creating a new expression or subexpression each time
//  we enter this recursively.   No inherited attributes are
//  propagated to this production.
//
//***************************************************************************

int CWQLParser::rel_expr(OUT SWQLNode_RelExpr **pRelExpr)
{
    int nRes;
    *pRelExpr = 0;

    // Get the new node.  This becomes a temporary root.
    // =================================================

    SWQLNode_RelExpr *pRE = 0;
    nRes = rel_term(&pRE);
    if (nRes)
        return nRes;

    // At this point, we have a possible root.  If
    // there are OR operations, the root will be
    // replaced by the next function.  Otherwise,
    // the call will pass through pRE into pNewRoot.
    // =============================================

    SWQLNode_RelExpr *pNewRoot = 0;
    nRes = rel_expr2(pRE, &pNewRoot);
    if (nRes)
        return nRes;

    // Return the expression to the caller.
    // ====================================

    *pRelExpr = pNewRoot;
    return NO_ERROR;
}



//***************************************************************************
//
//  <rel_expr2> ::= OR <rel_term> <rel_expr2>;
//  <rel_expr2> ::= <>;
//
//***************************************************************************
// done!

int CWQLParser::rel_expr2(
    IN OUT SWQLNode_RelExpr *pLeftSide,
    OUT SWQLNode_RelExpr **pNewRootRE
    )
{
    int nRes;
    *pNewRootRE = pLeftSide;            // Default for the nullable production

    while (1)
    {
        // Build a series of OR subtrees bottom-up.  We use iteration
        // and pointer juggling to simulate recursion.
        // ============================================================

        if (m_nCurrentToken == WQL_TOK_OR)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            SWQLNode_RelExpr *pNewRoot = new SWQLNode_RelExpr;
            if (!pNewRoot)
                return WBEM_E_OUT_OF_MEMORY;

            pNewRoot->m_dwExprType = WQL_TOK_OR;
            pNewRoot->m_pLeft = pLeftSide;
            pLeftSide = pNewRoot;
            *pNewRootRE = pNewRoot;     // Communicate this fact to the caller

            SWQLNode_RelExpr *pRight = 0;

            if (nRes = rel_term(&pRight))
                return nRes;

            pNewRoot->m_pRight = pRight;
            // Right node becomes the new subexpr
        }
        else break;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  <rel_term> ::= <rel_simple_expr> <rel_term2>;
//
//***************************************************************************
// done!

int CWQLParser::rel_term(
    OUT SWQLNode_RelExpr **pNewTerm
    )
{
    int nRes;

    SWQLNode_RelExpr *pNewSimple = 0;
    if (nRes = rel_simple_expr(&pNewSimple))
        return nRes;

    SWQLNode_RelExpr *pNewRoot = 0;
    if (nRes = rel_term2(pNewSimple, &pNewRoot))
        return nRes;

    *pNewTerm = pNewRoot;

    return NO_ERROR;
}



//***************************************************************************
//
//  <rel_term2> ::= AND <rel_simple_expr> <rel_term2>;
//  <rel_term2> ::= <>;
//
//***************************************************************************
// done!

int CWQLParser::rel_term2(
    IN SWQLNode_RelExpr *pLeftSide,                 // Inherited
    OUT SWQLNode_RelExpr **pNewRootRE       // Synthesized
    )
{
    int nRes;
    *pNewRootRE = pLeftSide;            // Default for the nullable production

    while (1)
    {
        // Build a series of AND subtrees bottom-up.  We use iteration
        // and pointer juggling to simulate recursion.
        // ============================================================

        if (m_nCurrentToken == WQL_TOK_AND)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            SWQLNode_RelExpr *pNewRoot = new SWQLNode_RelExpr;
            if (!pNewRoot)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            pNewRoot->m_dwExprType = WQL_TOK_AND;
            pNewRoot->m_pLeft = pLeftSide;
            pLeftSide = pNewRoot;
            *pNewRootRE = pNewRoot;     // Communicate this fact to the caller

            SWQLNode_RelExpr *pRight = 0;
            if (nRes = rel_simple_expr(&pRight))
                return nRes;

            pNewRoot->m_pRight = pRight;
        }
        else break;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  <rel_simple_expr> ::= NOT <rel_expr>;
//  <rel_simple_expr> ::= OPEN_PAREN <rel_expr> CLOSE_PAREN;
//  <rel_simple_expr> ::= <typed_expr>;
//
//***************************************************************************
// done!

int CWQLParser::rel_simple_expr(OUT SWQLNode_RelExpr **pRelExpr)
{
    int nRes;
    *pRelExpr = 0;  // Default

    // NOT <rel_expr>
    // ==============
    if (m_nCurrentToken == WQL_TOK_NOT)
    {
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        // Allocate a NOT root and place the NOTed subexpr
        // under it.
        // ===============================================

        SWQLNode_RelExpr *pNotRoot = new SWQLNode_RelExpr;
        if (!pNotRoot)
            return WBEM_E_OUT_OF_MEMORY;

        pNotRoot->m_dwExprType = WQL_TOK_NOT;

        SWQLNode_RelExpr *pRelSubExpr = 0;
        if (nRes = rel_expr(&pRelSubExpr))
            return nRes;

        pNotRoot->m_pLeft = pRelSubExpr;
        pNotRoot->m_pRight = NULL;   // intentional
        *pRelExpr = pNotRoot;

        return NO_ERROR;
    }

    // OPEN_PAREN <rel_expr> CLOSE_PAREN
    // =================================
    else if (m_nCurrentToken == WQL_TOK_OPEN_PAREN)
    {
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        SWQLNode_RelExpr *pSubExpr = 0;
        if (rel_expr(&pSubExpr))
            return WBEM_E_INVALID_SYNTAX;

        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return WBEM_E_INVALID_SYNTAX;

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        *pRelExpr = pSubExpr;

        return NO_ERROR;
    }

    // <typed_expr>
    // ============

    SWQLNode_RelExpr *pSubExpr = 0;
    nRes = typed_expr(&pSubExpr);
    if (nRes)
        return nRes;
    *pRelExpr = pSubExpr;

    return NO_ERROR;
}

//***************************************************************************
//
//  <typed_expr> ::= <typed_subexpr> <rel_op> <typed_subexpr_rh>;
//
//***************************************************************************
// done

int CWQLParser::typed_expr(OUT SWQLNode_RelExpr **pRelExpr)
{
    int nRes;

    // Allocate a node for this typed expression.
    // There are no possible child nodes, so <pRelExpr> this becomes
    // a synthesized attribute.
    // =============================================================

    SWQLNode_RelExpr *pRE = new SWQLNode_RelExpr;
    if (!pRE)
        return WBEM_E_OUT_OF_MEMORY;

    pRE->m_dwExprType = WQL_TOK_TYPED_EXPR;
    *pRelExpr = pRE;

    SWQLTypedExpr *pTE = new SWQLTypedExpr;
    if (!pTE)
        return WBEM_E_OUT_OF_MEMORY;

    // Look at the left hand side.
    // ===========================
    nRes = typed_subexpr(pTE);
    if (nRes)
    {
        delete pTE;
        return nRes;
    }

    int nOperator;

    // Get the operator.
    // =================
    nRes = rel_op(nOperator);
    if (nRes)
        return nRes;

    pTE->m_dwRelOperator = DWORD(nOperator);


    if (nOperator == WQL_TOK_ISNULL || nOperator == WQL_TOK_NOT_NULL)
    {
        pRE->m_pTypedExpr = pTE;
        return NO_ERROR;
    }

    // Get the right-hand side.
    // ========================
    nRes = typed_subexpr_rh(pTE);
    if (nRes)
	{
        delete pTE;
        return nRes;
	}


    // Check for IN, NOT IN and a const-list, to change the operator
    // to a more specific variety.
    // =============================================================
    if (pTE->m_pConstList)
    {
        if (pTE->m_dwRelOperator == WQL_TOK_IN)
            pTE->m_dwRelOperator = WQL_TOK_IN_CONST_LIST;
        if (pTE->m_dwRelOperator == WQL_TOK_NOT_IN)
            pTE->m_dwRelOperator = WQL_TOK_NOT_IN_CONST_LIST;
    }

    // Post-processing.  If the left side is a const and the right
    // side is a col-ref, flip the operator and swap so that
    // such expressions are normalized with the constant on the
    // right hand side and the column on the left.
    // ============================================================

    if (pTE->m_pConstValue && pTE->m_pJoinColRef)
    {
        pTE->m_dwRelOperator = FlipOperator(pTE->m_dwRelOperator);

        pTE->m_pColRef = pTE->m_pJoinColRef;
        pTE->m_pTableRef = pTE->m_pJoinTableRef;
        pTE->m_pJoinTableRef = 0;
        pTE->m_pJoinColRef = 0;

        DWORD dwTmp = pTE->m_dwRightFlags;
        pTE->m_dwRightFlags = pTE->m_dwLeftFlags;
        pTE->m_dwLeftFlags = dwTmp;

        // Interchange function references.
        // ================================

        pTE->m_pIntrinsicFuncOnColRef = pTE->m_pIntrinsicFuncOnJoinColRef;
        pTE->m_pIntrinsicFuncOnJoinColRef = 0;
    }

    pRE->m_pTypedExpr = pTE;

    return NO_ERROR;
}

//***************************************************************************
//
//  <typed_subexpr> ::= <col_ref>;
//  <typed_subexpr> ::= <function_call>;
//  <typed_subexpr> ::= <typed_const>;
//
//***************************************************************************
// ok
int CWQLParser::typed_subexpr(
    SWQLTypedExpr *pTE
    )
{
    int nRes;
    BOOL bStripTrailingParen = FALSE;
    SWQLQualifiedName *pColRef = 0;
    wmilib::auto_buffer<wchar_t> pFuncHolder;

    // Check for <function_call>
    // =========================

    if (m_nCurrentToken == WQL_TOK_UPPER)
    {
        pTE->m_dwLeftFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder.reset(CloneLPWSTR(L"UPPER")); //FIXIT will it return NULL?

        if (pFuncHolder.get() == 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        bStripTrailingParen = TRUE;
    }

    if (m_nCurrentToken == WQL_TOK_LOWER)
    {
        pTE->m_dwLeftFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder.reset(CloneLPWSTR(L"LOWER"));  // FIXIT will it return NULL?
        if (pFuncHolder.get() == 0)
        {
           return WBEM_E_OUT_OF_MEMORY;
        }

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        bStripTrailingParen = TRUE;
    }

    if (
        m_nCurrentToken == WQL_TOK_DATEPART  ||
        m_nCurrentToken == WQL_TOK_QUALIFIER ||
        m_nCurrentToken == WQL_TOK_ISNULL
        )
    {
        nRes = function_call(TRUE, pTE);
        if (nRes)
            return nRes;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_QSTRING ||
        m_nCurrentToken == WQL_TOK_INT     ||
        m_nCurrentToken == WQL_TOK_HEX_CONST ||
        m_nCurrentToken == WQL_TOK_REAL    ||
        m_nCurrentToken == WQL_TOK_CHAR    ||
        m_nCurrentToken == WQL_TOK_PROMPT  ||
        m_nCurrentToken == WQL_TOK_NULL
       )
    {
        SWQLTypedConst *pTC = 0;
        nRes = typed_const(&pTC);
        if (nRes)
            return nRes;
        pTE->m_pConstValue = pTC;
        pTE->m_dwLeftFlags |= WQL_FLAG_CONST;  // Intentional!
        pTE->m_pIntrinsicFuncOnConstValue = pFuncHolder.release();
        goto Exit;
    }

    // If here, must be a <col_ref>.
    // =============================

    nRes = col_ref(&pColRef);   // TBD
    if (nRes)
        return nRes;

    pTE->m_pIntrinsicFuncOnColRef = pFuncHolder.release();

    // Convert the col_ref to be part of the current SWQLTypedExpr.  We analyze the
    // qualified name and extract the table and col name.
    // ============================================================================

    if (pColRef->m_aFields.Size() == 1)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[0];
        pTE->m_pColRef = CloneLPWSTR(pCol->m_pName);
        if (pTE->m_pColRef == 0 && pCol->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_dwLeftFlags |= WQL_FLAG_COLUMN;
        if (pCol->m_bArrayRef)
        {
            pTE->m_dwLeftFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwLeftArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    else if (pColRef->m_aFields.Size() == 2)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[1];
        SWQLQualifiedNameField *pTbl = (SWQLQualifiedNameField *) pColRef->m_aFields[0];

        pTE->m_pColRef = CloneLPWSTR(pCol->m_pName);
        if (pTE->m_pColRef == 0 && pCol->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_pTableRef = CloneLPWSTR(pTbl->m_pName);  // FIXIT
        if (pTE->m_pTableRef == 0 && pTbl->m_pName != 0)
        {
           return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_dwLeftFlags |= WQL_FLAG_TABLE | WQL_FLAG_COLUMN;
        if (pCol->m_bArrayRef)
        {
            pTE->m_dwLeftFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwLeftArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    // If UPPER or LOWER was used, we have to strip a trailing
    // parenthesis.
    // =======================================================

Exit:
    delete pColRef;

    if (bStripTrailingParen)
    {
        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }

    return NO_ERROR;
}



//***************************************************************************
//
//  <typed_subexpr_rh> ::= <function_call>;
//  <typed_subexpr_rh> ::= <typed_const>;
//  <typed_subexpr_rh> ::= <col_ref>;
//
//  <typed_subexpr_rh> ::= <in_clause>;   // Operator must be _IN or _NOT_IN
//
//***************************************************************************
int CWQLParser::typed_subexpr_rh(IN SWQLTypedExpr *pTE)
{
    int nRes;
    BOOL bStripTrailingParen = FALSE;
    SWQLQualifiedName *pColRef = 0;
    wmilib::auto_buffer<wchar_t> pFuncHolder;

    // Check for <function_call>
    // =========================

    if (m_nCurrentToken == WQL_TOK_UPPER)
    {
        pTE->m_dwRightFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder.reset(CloneLPWSTR(L"UPPER"));
        if (pFuncHolder.get() == 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        bStripTrailingParen = TRUE;
    }

    if (m_nCurrentToken == WQL_TOK_LOWER)
    {
        pTE->m_dwRightFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder.reset(CloneLPWSTR(L"LOWER"));
        if (pFuncHolder.get() == 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        bStripTrailingParen = TRUE;
    }

    if (m_nCurrentToken == WQL_TOK_DATEPART  ||
        m_nCurrentToken == WQL_TOK_QUALIFIER ||
        m_nCurrentToken == WQL_TOK_ISNULL
        )
    {
        nRes = function_call(FALSE, pTE);
        if (nRes)
            return nRes;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_QSTRING ||
        m_nCurrentToken == WQL_TOK_INT     ||
        m_nCurrentToken == WQL_TOK_HEX_CONST  ||
        m_nCurrentToken == WQL_TOK_REAL    ||
        m_nCurrentToken == WQL_TOK_CHAR    ||
        m_nCurrentToken == WQL_TOK_PROMPT  ||
        m_nCurrentToken == WQL_TOK_NULL
       )
    {
		// If we already have a typed constant, then the expression doesn't
		// really make sense, trying to do a relop around two constants,
		// so we'll fail the operation here
		if ( NULL != pTE->m_pConstValue )
		{
			return WBEM_E_INVALID_SYNTAX;
		}
		
        SWQLTypedConst *pTC = 0;
        nRes = typed_const(&pTC);
        if (nRes)
            return nRes;
        pTE->m_pConstValue = pTC;
        pTE->m_dwRightFlags |= WQL_FLAG_CONST;
        pTE->m_pIntrinsicFuncOnConstValue = pFuncHolder.release();

        // Check for BETWEEN operator, since we have
        // the other end of the range to parse.
        // =========================================

        if (pTE->m_dwRelOperator == WQL_TOK_BETWEEN ||
            pTE->m_dwRelOperator == WQL_TOK_NOT_BETWEEN)
        {
            if (m_nCurrentToken != WQL_TOK_AND)
                return WBEM_E_INVALID_SYNTAX;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            SWQLTypedConst *pTC2 = 0;
            nRes = typed_const(&pTC2);
            if (nRes)
                return nRes;
            pTE->m_pConstValue2 = pTC2;
            pTE->m_dwRightFlags |= WQL_FLAG_CONST_RANGE;
        }

        goto Exit;
    }

    if (m_nCurrentToken == WQL_TOK_OPEN_PAREN)
    {
        // IN clause.
        nRes = in_clause(pTE);
        if (nRes)
            return nRes;
        goto Exit;
    }

    // If here, must be a <col_ref>.
    // =============================

    nRes = col_ref(&pColRef);
    if (nRes)
        return nRes;

    pTE->m_pIntrinsicFuncOnJoinColRef = pFuncHolder.release();

    // Convert the col_ref to be part of the current SWQLTypedExpr.  We analyze the
    // qualified name and extract the table and col name.
    // ============================================================================

    if (pColRef->m_aFields.Size() == 1)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[0];
        pTE->m_pJoinColRef = CloneLPWSTR(pCol->m_pName);
        if (pTE->m_pJoinColRef == 0 && pCol->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        pTE->m_dwRightFlags |= WQL_FLAG_COLUMN;
        if (pCol->m_bArrayRef)
        {
            pTE->m_dwRightFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwRightArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    else if (pColRef->m_aFields.Size() == 2)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[1];
        SWQLQualifiedNameField *pTbl = (SWQLQualifiedNameField *) pColRef->m_aFields[0];

        pTE->m_pJoinColRef = CloneLPWSTR(pCol->m_pName);
        if (pTE->m_pJoinColRef == 0 && pCol->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_pJoinTableRef = CloneLPWSTR(pTbl->m_pName);
        if (pTE->m_pJoinTableRef == 0 && pTbl->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_dwRightFlags |= WQL_FLAG_TABLE | WQL_FLAG_COLUMN;

        if (pCol->m_bArrayRef)
        {
            pTE->m_dwRightFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwRightArrayIndex = pCol->m_dwArrayIndex;
        }
    }

Exit:
    delete pColRef;

    if (bStripTrailingParen)
    {
        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }

    return NO_ERROR;
}




//*****************************************************************************************
//
//  <rel_op> ::= WQL_TOK_LE;
//  <rel_op> ::= WQL_TOK_LT;
//  <rel_op> ::= WQL_TOK_GE;
//  <rel_op> ::= WQL_TOK_GT;
//  <rel_op> ::= WQL_TOK_EQ;
//  <rel_op> ::= WQL_TOK_NE;
//  <rel_op> ::= WQL_TOK_LIKE;
//  <rel_op> ::= WQL_TOK_BETWEEN;
//  <rel_op> ::= WQL_TOK_IS <is_continuator>;
//  <rel_op> ::= WQL_TOK_ISA;
//  <rel_op> ::= WQL_TOK_IN;
//  <rel_op> ::= WQL_TOK_NOT <not_continuator>;
//
//  Operator type is returned via <nReturnedOp>
//
//*****************************************************************************************
// done

int CWQLParser::rel_op(OUT int & nReturnedOp)
{
    int nRes;
    nReturnedOp = WQL_TOK_ERROR;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_LE:
            nReturnedOp = WQL_TOK_LE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_LT:
            nReturnedOp = WQL_TOK_LT;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_GE:
            nReturnedOp = WQL_TOK_GE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_GT:
            nReturnedOp = WQL_TOK_GT;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_EQ:
            nReturnedOp = WQL_TOK_EQ;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NE:
            nReturnedOp = WQL_TOK_NE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_LIKE:
            nReturnedOp = WQL_TOK_LIKE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BETWEEN:
            nReturnedOp = WQL_TOK_BETWEEN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_IS:
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            nRes = is_continuator(nReturnedOp);
            return nRes;

        case WQL_TOK_ISA:
            nReturnedOp = WQL_TOK_ISA;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            m_uFeatures |= WMIQ_RPNF_ISA_USED;
            return NO_ERROR;

        case WQL_TOK_IN:
            nReturnedOp = WQL_TOK_IN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NOT:
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            nRes = not_continuator(nReturnedOp);
            return nRes;
    }

    return WBEM_E_INVALID_SYNTAX;
}

//*****************************************************************************************
//
//  <typed_const> ::= WQL_TOK_QSTRING;
//  <typed_const> ::= WQL_TOK_HEX_CONST;
//  <typed_const> ::= WQL_TOK_INT;
//  <typed_const> ::= WQL_TOK_REAL;
//  <typed_const> ::= WQL_TOK_PROMPT;
//  <typed_const> ::= WQL_TOK_NULL;
//
//*****************************************************************************************
// done

int CWQLParser::typed_const(OUT SWQLTypedConst **pRetVal)
{
    SWQLTypedConst *pNew = new SWQLTypedConst;
    if (!pNew)
        return WBEM_E_OUT_OF_MEMORY;
    *pRetVal = pNew;

    if (m_nCurrentToken == WQL_TOK_QSTRING
        || m_nCurrentToken == WQL_TOK_PROMPT)
    {
        pNew->m_dwType = VT_LPWSTR;
        pNew->m_bPrompt = (m_nCurrentToken == WQL_TOK_PROMPT);
        pNew->m_Value.m_pString = CloneLPWSTR(m_pTokenText);
        if (NULL == pNew->m_Value.m_pString)
            return WBEM_E_OUT_OF_MEMORY;
        if (!Next())
            goto Error;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_INT || m_nCurrentToken == WQL_TOK_HEX_CONST)
    {
        unsigned __int64 val = 0;
        BOOL bSigned = FALSE;
        BOOL b64Bit = FALSE;

        if (!GetIntToken(&bSigned, &b64Bit, &val))
            return WBEM_E_INVALID_SYNTAX;

        if (!b64Bit)
        {
            if (bSigned)
                pNew->m_dwType = VT_I4;
            else
                pNew->m_dwType = VT_UI4;

            pNew->m_Value.m_lValue = (LONG) val;
        }
        else    // 64 bit moved into string
        {
            if (bSigned)
                pNew->m_dwType = VT_I8;
            else
                pNew->m_dwType = VT_UI8;
            pNew->m_Value.m_i64Value = val;
        }

        if (!Next())
            goto Error;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_REAL)
    {
        pNew->m_dwType = VT_R8;
        wchar_t *pStopper = 0;
       BSTR bstrValue = SysAllocString(m_pTokenText);
         if (!bstrValue)
           return WBEM_E_OUT_OF_MEMORY;
       _variant_t varValue;
       V_VT(&varValue) = VT_BSTR;
       V_BSTR(&varValue) = bstrValue;

         if (FAILED(VariantChangeTypeEx(&varValue,&varValue, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), VARIANT_NOUSEROVERRIDE, VT_R8)))

               return WBEM_E_INVALID_SYNTAX;

         double d = varValue;
        pNew->m_Value.m_dblValue = d;
        if (!Next())
            goto Error;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_NULL)
    {
        pNew->m_dwType = VT_NULL;
        if (!Next())
            goto Error;
        return NO_ERROR;
    }

    // Unrecognized constant.
    // ======================
Error:
    *pRetVal = 0;
    delete pNew;

    return WBEM_E_INVALID_SYNTAX;
}

//*****************************************************************************************
//
//  <datepart_call> ::=
//    WQL_TOK_OPEN_PAREN
//    WQL_TOK_IDENT               // yy, mm,dd, hh, mm, ss, year, month, etc.
//    WQL_TOK_COMMA
//    <col_ref>
//    WQL_TOK_CLOSE_PAREN
//
//*****************************************************************************************

static WqlKeyword DateKeyWords[] =      // Keep this alphabetized for binary search
{
    L"DAY",      WQL_TOK_DAY,
    L"DD",       WQL_TOK_DAY,
    L"HH",       WQL_TOK_HOUR,
    L"HOUR",     WQL_TOK_HOUR,
    L"MI",       WQL_TOK_MINUTE,
    L"MILLISECOND", WQL_TOK_MILLISECOND,
    L"MINUTE",   WQL_TOK_MINUTE,
    L"MONTH",    WQL_TOK_MONTH,
    L"MM",       WQL_TOK_MONTH,
    L"MS",          WQL_TOK_MILLISECOND,
    L"YEAR",     WQL_TOK_YEAR,
    L"YY",       WQL_TOK_YEAR
};

const int NumDateKeywords = sizeof(DateKeyWords)/sizeof(WqlKeyword);

int CWQLParser::datepart_call(OUT SWQLNode_Datepart **pRetDP)
{
    DWORD dwDatepartTok = 0;
    int nRes;

    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;
    if (m_nCurrentToken != WQL_TOK_IDENT)
        return WBEM_E_INVALID_SYNTAX;

    // Ident must be one of the DATEPART identifiers.
    // ==============================================

    BOOL bFound = FALSE;
    int l = 0, u = NumDateKeywords - 1;
    while (l <= u)
    {
        int m = (l + u) / 2;
        if (_wcsicmp(m_pTokenText, DateKeyWords[m].m_pKeyword) < 0)
             u = m - 1;
        else if (_wcsicmp(m_pTokenText, DateKeyWords[m].m_pKeyword) > 0)
             l = m + 1;
        else        // Match
        {
           bFound = TRUE;
           dwDatepartTok = DateKeyWords[m].m_nTokenCode;
           break;
        }
    }

    if (!bFound)
        return WBEM_E_INVALID_SYNTAX;

    // If here, we know the date part.
    // ===============================

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;
    if (m_nCurrentToken != WQL_TOK_COMMA)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    SWQLQualifiedName *pQN = 0;
    nRes = col_ref(&pQN);
    if (nRes)
        return nRes;

    SWQLColRef *pCR = 0;
    nRes = QNameToSWQLColRef(pQN, &pCR);

    if (nRes)
    {
        delete pQN;
        return WBEM_E_INVALID_PARAMETER;
    }

    std::auto_ptr <SWQLColRef> _1(pCR);

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // Return the new node.
    // ====================

    SWQLNode_Datepart *pDP = new SWQLNode_Datepart;
    if (!pDP)
        return WBEM_E_OUT_OF_MEMORY;

    _1.release();

    pDP->m_nDatepart = dwDatepartTok;
    pDP->m_pColRef = pCR;

    *pRetDP = pDP;

    return NO_ERROR;
}



//*****************************************************************************************
//
//  <function_call> ::= WQL_TOK_UPPER <function_call_parms>;
//  <function_call> ::= WQL_TOK_LOWER  <function_call_parms>;
//  <function_call> ::= WQL_TOK_DATEPART  <datepart_call>;
//  <function_call> ::= WQL_TOK_QUALIFIER  <function_call_parms>;
//  <function_call> ::= WQL_TOK_ISNULL <function_call_parms>;
//
//*****************************************************************************************

int CWQLParser::function_call(
    IN BOOL bLeftSide,
    IN SWQLTypedExpr *pTE
    )
{
    int nRes;
    SWQLNode_Datepart *pDP = 0;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_DATEPART:
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            nRes = datepart_call(&pDP);

            if (nRes)
                return nRes;

            if (bLeftSide)
            {
                pTE->m_dwLeftFlags |= WQL_FLAG_FUNCTIONIZED;
                pTE->m_pLeftFunction = pDP;
                pTE->m_pIntrinsicFuncOnColRef = CloneLPWSTR(L"DATEPART");
                if (!pTE->m_pIntrinsicFuncOnColRef)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                pTE->m_dwRightFlags |= WQL_FLAG_FUNCTIONIZED;
                pTE->m_pRightFunction = pDP;
                pTE->m_pIntrinsicFuncOnJoinColRef = CloneLPWSTR(L"DATEPART");
                if (!pTE->m_pIntrinsicFuncOnJoinColRef)
                    return WBEM_E_OUT_OF_MEMORY;
            }

            return NO_ERROR;
        }

        case WQL_TOK_QUALIFIER:
            trace(("EMIT: QUALIFIER\n"));
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            nRes = function_call_parms();
            return nRes;

        case WQL_TOK_ISNULL:
            trace(("EMIT: ISNULL\n"));
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            nRes = function_call_parms();
            return nRes;
    }

    return WBEM_E_INVALID_SYNTAX;
}

//*****************************************************************************************
//
//  <function_call_parms> ::=
//    WQL_TOK_OPEN_PAREN
//    <func_args>
//    WQL_TOK_CLOSE_PAREN
//
//*****************************************************************************************

int CWQLParser::function_call_parms()
{
    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    int nRes = func_args();
    if (nRes)
        return nRes;

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    return NO_ERROR;
}

//*****************************************************************************************
//
//  <func_args> ::= <func_arg> <func_arg_list>;
//  <func_arg_list> ::= WQL_TOK_COMMA <func_arg> <func_arg_list>;
//  <func_arg_list> ::= <>;
//
//*****************************************************************************************

int CWQLParser::func_args()
{
    int nRes;

    while (1)
    {
        nRes = func_arg();
        if (nRes)
            return nRes;

        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }

    return NO_ERROR;
}

//*****************************************************************************************
//
//  <func_arg> ::= <typed_const>;
//  <func_arg> ::= <col_ref>;
//
//*****************************************************************************************

int CWQLParser::func_arg()
{
    SWQLQualifiedName *pColRef = 0;
    int nRes;

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        nRes = col_ref(&pColRef);
        return nRes;
    }

    SWQLTypedConst *pTC = 0;
    return typed_const(&pTC);
}


// Tokens which can follow IS
// ===========================

//*****************************************************************************************
//
//  <is_continuator> ::= WQL_TOK_LIKE;
//  <is_continuator> ::= WQL_TOK_BEFORE;
//  <is_continuator> ::= WQL_TOK_AFTER;
//  <is_continuator> ::= WQL_TOK_BETWEEN;
//  <is_continuator> ::= WQL_TOK_NULL;
//  <is_continuator> ::= WQL_TOK_NOT <not_continuator>;
//  <is_continuator> ::= WQL_TOK_IN;
//  <is_continuator> ::= WQL_TOK_A;
//
//*****************************************************************************************
// done

int CWQLParser::is_continuator(int & nReturnedOp)
{
    int nRes;

    nReturnedOp = WQL_TOK_ERROR;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_LIKE:
            nReturnedOp = WQL_TOK_LIKE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BEFORE:
            nReturnedOp = WQL_TOK_BEFORE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_AFTER:
            nReturnedOp = WQL_TOK_AFTER;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BETWEEN:
            nReturnedOp = WQL_TOK_BETWEEN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NULL:
            nReturnedOp = WQL_TOK_ISNULL;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NOT:
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
              nRes = not_continuator(nReturnedOp);
            return nRes;

        case WQL_TOK_IN:
            nReturnedOp = WQL_TOK_IN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_A:
            nReturnedOp = WQL_TOK_ISA;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            m_uFeatures |= WMIQ_RPNF_ISA_USED;
            return NO_ERROR;
    }

    return WBEM_E_INVALID_SYNTAX;
}

//*****************************************************************************************
//
//  <not_continuator> ::= WQL_TOK_LIKE;
//  <not_continuator> ::= WQL_TOK_BEFORE;
//  <not_continuator> ::= WQL_TOK_AFTER;
//  <not_continuator> ::= WQL_TOK_BETWEEN;
//  <not_continuator> ::= WQL_TOK_NULL;
//  <not_continuator> ::= WQL_TOK_IN;
//
//  Returns WQL_TOK_NOT_LIKE, WQL_TOK_NOT_BEFORE, WQL_TOK_NOT_AFTER, WQL_TOK_NOT_BETWEEN
//          WQL_TOK_NOT_NULL, WQL_TOK_NOT_IN
//
//*****************************************************************************************
// done

int CWQLParser::not_continuator(int & nReturnedOp)
{
    nReturnedOp = WQL_TOK_ERROR;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_LIKE:
            nReturnedOp = WQL_TOK_NOT_LIKE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BEFORE:
            nReturnedOp = WQL_TOK_NOT_BEFORE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_AFTER:
            nReturnedOp = WQL_TOK_NOT_AFTER;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BETWEEN:
            nReturnedOp = WQL_TOK_NOT_BETWEEN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NULL:
            nReturnedOp = WQL_TOK_NOT_NULL;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_IN:
            nReturnedOp = WQL_TOK_NOT_IN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_A:
            nReturnedOp = WQL_TOK_NOT_A;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;
    }

    return WBEM_E_INVALID_SYNTAX;
}


//*****************************************************************************************
//
//  <in_clause> ::= WQL_TOK_OPEN_PAREN <in_type> WQL_TOK_CLOSE_PAREN;
//  <in_type> ::= <subselect_stmt>;
//  <in_type> ::= <const_list>;
//  <in_type> ::= <qualified_name>;
//
//*****************************************************************************************

int CWQLParser::in_clause(IN SWQLTypedExpr *pTE)
{
    int nRes;

    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    //int nStPos = m_pLexer->GetCurPos();

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    if (m_nCurrentToken == WQL_TOK_SELECT)
    {
        SWQLNode_Select *pSel = 0;
        nRes = subselect_stmt(&pSel);
        if (nRes)
            return nRes;

        // pSel->m_nStPos = nStPos;
        // pSel->m_nEndPos = m_pLexer->GetCurPos() - 1;

        // Translate the IN / NOT IN operator to the specific
        // case of subselects.
        // ==================================================

        if (pTE->m_dwRelOperator == WQL_TOK_IN)
            pTE->m_dwRelOperator = WQL_TOK_IN_SUBSELECT;
        else if (pTE->m_dwRelOperator == WQL_TOK_NOT_IN)
            pTE->m_dwRelOperator = WQL_TOK_NOT_IN_SUBSELECT;

        pTE->m_pSubSelect = pSel;
    }

    else if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        nRes = qualified_name(0);
        if (nRes)
            return nRes;
    }

    // If here, we must have a const-list.
    // ===================================

    else
    {
        SWQLConstList *pCL = 0;

        nRes = const_list(&pCL);
        if (nRes)
            return nRes;

        pTE->m_pConstList = pCL;
    }

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    return NO_ERROR;
}

//*****************************************************************************************
//
//  <const_list> ::= <typed_const> <const_list2>;
//  <const_list2> ::= WQL_TOK_COMMA <typed_const> <const_list2>;
//  <const_list2> ::= <>;
//
//*****************************************************************************************
// done

int CWQLParser::const_list(SWQLConstList **pRetVal)
{
    int nRes;
    SWQLConstList *pCL = new SWQLConstList;
    if (!pCL)
        return WBEM_E_OUT_OF_MEMORY;

    *pRetVal = 0;

    while (1)
    {
        if (m_nCurrentToken == WQL_TOK_QSTRING ||
            m_nCurrentToken == WQL_TOK_INT     ||
            m_nCurrentToken == WQL_TOK_HEX_CONST  ||
            m_nCurrentToken == WQL_TOK_REAL    ||
            m_nCurrentToken == WQL_TOK_CHAR    ||
            m_nCurrentToken == WQL_TOK_PROMPT  ||
            m_nCurrentToken == WQL_TOK_NULL
           )
        {
            SWQLTypedConst *pTC = 0;
            nRes = typed_const(&pTC);
            if (nRes)
            {
                delete pCL;
                return nRes;
            }

            pCL->Add(pTC);
        }

        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;

        // If here, a comma, indicating a following constant.
        // ==================================================
        if (!Next())
        {
            delete pCL;
            return WBEM_E_INVALID_SYNTAX;
        }
    }

    *pRetVal = pCL;
    return NO_ERROR;
}

//*****************************************************************************************
//
//  QUALIFIED_NAME
//
//  This recognizes a name separated by dots, and recognizes any array references which
//  may occur with those names:
//      a
//      a.b
//      a[n].b[n]
//      a.b.c.d
//      a.b[2].c.d.e[3].f
//      ...etc.
//
//  <qualified_name> ::= WQL_TOK_IDENT <qualified_name2>;
//  <qualified_name2> ::= WQL_TOK_DOT WQL_TOK_IDENT <qualified_name2>;
//
//  <qualified_name2> ::=
//      WQL_TOK_OPEN_BRACKET
//      WQL_TOK_INT
//      WQL_TOK_CLOSEBRACKET
//      <qname_becomes_array_ref>
//      <qualified_name2>;
//
//  <qname_becomes_array_ref> ::= <>;   // Dummy to enforce array semantics
//
//  <qualified_name2> ::= <>;
//
//*****************************************************************************************
// done

int CWQLParser::qualified_name(OUT SWQLQualifiedName **pRetVal)
{
    if (pRetVal == 0)
        return WBEM_E_INVALID_PARAMETER;

    *pRetVal = 0;

    if (m_nCurrentToken != WQL_TOK_IDENT && m_nCurrentToken != WQL_TOK_COUNT)
        return WBEM_E_INVALID_SYNTAX;

    SWQLQualifiedName QN;
    SWQLQualifiedNameField *pQNF;

    pQNF = new SWQLQualifiedNameField;
    if (!pQNF)
        return WBEM_E_OUT_OF_MEMORY;

    pQNF->m_pName = CloneLPWSTR(m_pTokenText);
    if (pQNF->m_pName == 0 || QN.Add(pQNF))
    {
        delete pQNF;
        return WBEM_E_OUT_OF_MEMORY;
    }

    if (_wcsicmp(m_pTokenText, L"__CLASS") == 0)
        m_uFeatures |= WMIQ_RPNF_SYSPROP_CLASS_USED;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    while (1)
    {
        if (m_nCurrentToken == WQL_TOK_DOT)
        {
            // Move past dot
            // ==============

            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            if (!(m_nCurrentToken == WQL_TOK_IDENT || m_nCurrentToken == WQL_TOK_ASTERISK))
                return WBEM_E_INVALID_SYNTAX;

            m_uFeatures |= WMIQ_RPNF_QUALIFIED_NAMES_USED;

            pQNF = new SWQLQualifiedNameField;
            if (!pQNF)
                return WBEM_E_OUT_OF_MEMORY;

            pQNF->m_pName = CloneLPWSTR(m_pTokenText);
            if (!pQNF->m_pName)
                return WBEM_E_OUT_OF_MEMORY;

            QN.Add(pQNF);

            if (_wcsicmp(m_pTokenText, L"__CLASS") == 0)
                m_uFeatures |= WMIQ_RPNF_SYSPROP_CLASS_USED;

            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            continue;
        }

        if (m_nCurrentToken == WQL_TOK_OPEN_BRACKET)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            if (m_nCurrentToken != WQL_TOK_INT)
                return WBEM_E_INVALID_SYNTAX;

            unsigned __int64 ArrayIndex = 0;
            BOOL bRes, b64Bit, bSigned;

            m_uFeatures |= WMIQ_RPNF_ARRAY_ACCESS_USED;

            bRes = GetIntToken(&bSigned, &b64Bit, &ArrayIndex);
            if (!bRes || b64Bit || bSigned)
                return WBEM_E_INVALID_SYNTAX;

            pQNF->m_bArrayRef = TRUE;
            pQNF->m_dwArrayIndex = (DWORD) ArrayIndex;

            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            if (m_nCurrentToken != WQL_TOK_CLOSE_BRACKET)
                return WBEM_E_INVALID_SYNTAX;

            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            continue;
        }

        break;
    }

    // Copy the object and return it.  We worked with the copy QN
    // throughout to avoid complicated cleanup problems on errors, since
    // we take advantage of the auto destructor of <QN> in cases
    // above where we return errors.
    // ==================================================================

    SWQLQualifiedName *pRetCopy = new SWQLQualifiedName(QN);
    if (!pRetCopy)
        return WBEM_E_OUT_OF_MEMORY;

    *pRetVal = pRetCopy;

    return NO_ERROR;
}


//*****************************************************************************************
//
//  col_ref
//
//*****************************************************************************************
// done

int CWQLParser::col_ref(OUT SWQLQualifiedName **pRetVal)
{
    return qualified_name(pRetVal);
}


//*****************************************************************************************
//
//  <col_list> ::= <col_ref> <col_list_rest>;
//  <col_list_rest> ::= WQL_TOK_COMMA <col_ref> <col_list_rest>;
//  <col_list_rest> ::= <>;
//
//*****************************************************************************************
// <status: SWQLColRef fields to be analyzed and filled in. Testable, though>

int CWQLParser::col_list(OUT SWQLNode_ColumnList **pRetColList)
{
    *pRetColList = 0;
    SWQLNode_ColumnList *pColList = new SWQLNode_ColumnList;

    if (!pColList)
        return WBEM_E_OUT_OF_MEMORY;

    while (1)
    {
        SWQLQualifiedName *pColRef = 0;

        int nRes = col_ref(&pColRef);
        if (nRes)
        {
            delete pColList;
            return nRes;
        }

        // If here, we have a legit column to add to the node.
        // ===================================================

        SWQLColRef *pCRef = 0;

        QNameToSWQLColRef(pColRef, &pCRef);

        pColList->m_aColumnRefs.Add(pCRef);

        // Check for sortation indication
        // ==============================

        if (m_nCurrentToken == WQL_TOK_ASC)
        {
            pCRef->m_dwFlags |= WQL_FLAG_SORT_ASC;
            if (!Next())
            {
                delete pColList;
                return WBEM_E_INVALID_SYNTAX;
            }
        }
        else if (m_nCurrentToken == WQL_TOK_DESC)
        {
            pCRef->m_dwFlags |= WQL_FLAG_SORT_DESC;
            if (!Next())
            {
                delete pColList;
                return WBEM_E_INVALID_SYNTAX;
            }
        }

        // Check for a continuation.
        // =========================

        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;

        if (!Next())
        {
            delete pColList;
            return WBEM_E_INVALID_SYNTAX;
        }
    }

    *pRetColList = pColList;
    return NO_ERROR;
}


//*****************************************************************************************
//
//  <subselect_stmt> ::=
//      WQL_TOK_SELECT
//      <select_type>
//      <col_ref>                   // Must not be an asterisk
//      <from_clause>
//      <where_clause>
//
//*****************************************************************************************

int CWQLParser::subselect_stmt(OUT SWQLNode_Select **pRetSel)
{
    int nSelType;
    int nRes = 0;

    SWQLNode_FromClause *pFrom = 0;
    SWQLNode_Select *pSel = 0;
    SWQLNode_TableRefs *pTblRefs = 0;
    SWQLNode_WhereClause *pWhere = 0;

    *pRetSel = 0;

    // Verify that we are in a subselect.
    // ==================================

    if (m_nCurrentToken != WQL_TOK_SELECT)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // This affects some of the productions, since they behave differently
    // in subselects than in primary selects.
    // ===================================================================

    m_nParseContext = Ctx_Subselect;

    // If here, we are definitely in a subselect, so
    // allocate a new node.
    // ==============================================

    pSel = new SWQLNode_Select;
    if (!pSel)
        return WBEM_E_OUT_OF_MEMORY;

    pTblRefs = new SWQLNode_TableRefs;
    if (!pTblRefs)
    {
        delete pSel;
        return WBEM_E_OUT_OF_MEMORY;
    }
    pSel->m_pLeft = pTblRefs;

    // Find the select type.
    // =====================

    nRes = select_type(nSelType);
    if (nRes)
        return nRes;

    pTblRefs->m_nSelectType = nSelType;        // ALL, DISTINCT

    // Get the column list.  In this case
    // it must be a single column and not
    // an asterisk.
    // ====================================

    nRes = col_ref_list(pTblRefs);
    if (nRes)
        return nRes;

    // Get the FROM clause and patch it in.
    // =====================================

    nRes = from_clause(&pFrom);
    if (nRes)
        return nRes;

    pTblRefs->m_pRight = pFrom;

    // Get the WHERE clause.
    // =====================

    nRes = where_clause(&pWhere);
    if (nRes)
        return nRes;

    pSel->m_pRight = pWhere;

    *pRetSel = pSel;

    m_nParseContext = Ctx_Default;     // No longer in a subselect

    return NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Containers
//
/////////////////////////////////////////////////////////////////////////////

//***************************************************************************
//
//  SWQLTypedConst constructor
//
//***************************************************************************
// done

SWQLTypedConst::SWQLTypedConst()
{
    m_dwType = VT_NULL;
    m_bPrompt = false;
    memset(&m_Value, 0, sizeof(m_Value));
}

//***************************************************************************
//
//  SWQLTypedConst::operator =
//
//***************************************************************************
// done

SWQLTypedConst & SWQLTypedConst::operator = (SWQLTypedConst &Src)
{
    Empty();

    if (Src.m_dwType == VT_LPWSTR)
    {
        m_Value.m_pString = CloneLPWSTR(Src.m_Value.m_pString);
        if (CloneFailed(m_Value.m_pString,Src.m_Value.m_pString))
            throw CX_MemoryException();
    }
    else
    {
        m_Value = Src.m_Value;
    }

    m_dwType = Src.m_dwType;
    m_bPrompt = Src.m_bPrompt;

    return *this;
}

//***************************************************************************
//
//  SWQLTypedConst::Empty()
//
//***************************************************************************
// done

void SWQLTypedConst::Empty()
{
    if (m_dwType == VT_LPWSTR)
        delete [] m_Value.m_pString;
    m_bPrompt = false;
}



//***************************************************************************
//
//  SWQLConstList::operator =
//
//***************************************************************************
// done

SWQLConstList & SWQLConstList::operator = (SWQLConstList & Src)
{
    Empty();

    for (int i = 0; i < Src.m_aValues.Size(); i++)
    {
        SWQLTypedConst *pC = (SWQLTypedConst *) Src.m_aValues[i];
        m_aValues.Add(new SWQLTypedConst(*pC));
    }

    return *this;
}

//***************************************************************************
//
//  SWQLConstList::Empty
//
//***************************************************************************
// done

void SWQLConstList::Empty()
{
    for (int i = 0; i < m_aValues.Size(); i++)
        delete (SWQLTypedConst *) m_aValues[i];
    m_aValues.Empty();
}

//***************************************************************************
//
//  SWQLQualifiedName::operator =
//
//***************************************************************************
// done

SWQLQualifiedName & SWQLQualifiedName::operator = (SWQLQualifiedName &Src)
{
    Empty();

    for (int i = 0; i < Src.m_aFields.Size(); i++)
    {
        SWQLQualifiedNameField *pQN = new SWQLQualifiedNameField;
        if (!pQN)
            throw CX_MemoryException();

        *pQN = *(SWQLQualifiedNameField *) Src.m_aFields[i];
        m_aFields.Add(pQN);
    }

    return *this;
}

//***************************************************************************
//
//  SWQLQualifiedNameField::operator =
//
//***************************************************************************
// done


SWQLQualifiedNameField &
    SWQLQualifiedNameField::operator =(SWQLQualifiedNameField &Src)
{
    Empty();

    m_bArrayRef = Src.m_bArrayRef;
    m_pName = CloneLPWSTR(Src.m_pName);
    if (CloneFailed(m_pName,Src.m_pName))
        throw CX_MemoryException();
    m_dwArrayIndex = Src.m_dwArrayIndex;
    return *this;
}




//***************************************************************************
//
//  SWQLNode_ColumnList destructor
//
//***************************************************************************
// tbd


//***************************************************************************
//
//  QNameToSWQLColRef
//
//  Translates a qualified name to a SWQLColRef structure and embeds
//  the q-name into the struct (since that is a field).
//
//***************************************************************************

int CWQLParser::QNameToSWQLColRef(
    IN  SWQLQualifiedName *pQName,
    OUT SWQLColRef **pRetVal
    )
{
    *pRetVal = 0;
    if (pQName == 0 || pRetVal == 0)
        return WBEM_E_INVALID_PARAMETER;

    SWQLColRef *pCR = new SWQLColRef;
    if (!pCR)
        return WBEM_E_OUT_OF_MEMORY;

    // Algorithm: With a two name sequence, assume that the first name is
    // the table and that the second name is the column. If multiple
    // names occur, then we set the SWQLColRef type to WQL_FLAG_COMPLEX
    // and just take the last name for the column.
    // ==================================================================

    if (pQName->m_aFields.Size() == 2)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pQName->m_aFields[1];
        SWQLQualifiedNameField *pTbl = (SWQLQualifiedNameField *) pQName->m_aFields[0];

        pCR->m_pColName = CloneLPWSTR(pCol->m_pName);
        pCR->m_pTableRef = CloneLPWSTR(pTbl->m_pName);
        if (!pCR->m_pColName || !pCR->m_pTableRef)
            return WBEM_E_OUT_OF_MEMORY;

        pCR->m_dwFlags = WQL_FLAG_TABLE | WQL_FLAG_COLUMN;

        if (_wcsicmp(L"*", pCol->m_pName) == 0)
            pCR->m_dwFlags |= WQL_FLAG_ASTERISK;

        if (pCol->m_bArrayRef)
        {
            pCR->m_dwFlags |= WQL_FLAG_ARRAY_REF;
            pCR->m_dwArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    else if (pQName->m_aFields.Size() == 1)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pQName->m_aFields[0];
        pCR->m_pColName = CloneLPWSTR(pCol->m_pName);
        if (!pCR->m_pColName)
            return WBEM_E_OUT_OF_MEMORY;

        pCR->m_dwFlags |= WQL_FLAG_COLUMN;

        if (_wcsicmp(L"*", pCol->m_pName) == 0)
            pCR->m_dwFlags |= WQL_FLAG_ASTERISK;

        if (pCol->m_bArrayRef)
        {
            pCR->m_dwFlags |= WQL_FLAG_ARRAY_REF;
            pCR->m_dwArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    // Complex case.
    // =============
    else
    {
        pCR->m_dwFlags = WQL_FLAG_COMPLEX_NAME;
    }

    // Copy the qualified name.
    // ========================

    pCR->m_pQName = pQName;

    *pRetVal = pCR;

    return NO_ERROR;;
}




//***************************************************************************
//
//  SWQLNode_ColumnList::DebugDump
//
//***************************************************************************
void SWQLNode_ColumnList::DebugDump()
{
    printf("---SWQLNode_ColumnList---\n");
    for (int i = 0; i < m_aColumnRefs.Size(); i++)
    {
        SWQLColRef *pCR = (SWQLColRef *) m_aColumnRefs[i];
        if (pCR)
            pCR->DebugDump();
    }

    printf("---End SWQLNode_ColumnList---\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_TableRefs::DebugDump()
{
    printf("********** BEGIN SWQLNode_TableRefs *************\n");
    printf("Select type = ");
    if (m_nSelectType & WQL_FLAG_COUNT)
        printf("WQL_FLAG_COUNT ");
    if (m_nSelectType & WQL_FLAG_ALL)
        printf("WQL_FLAG_ALL ");
    if (m_nSelectType & WQL_FLAG_DISTINCT)
        printf("WQL_FLAG_DISTINCT ");
    printf("\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();
    printf("********** END SWQLNode_TableRefs *************\n\n\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_FromClause::DebugDump()
{
    printf("---SWQLNode_FromClause---\n");

    if (m_pLeft == 0)
        return;
    m_pLeft->DebugDump();

    printf("---End SWQLNode_FromClause---\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_Select::DebugDump()
{
    printf("********** BEGIN SWQLNode_Select *************\n");
    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();
    printf("********** END SWQLNode_Select *************\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_WmiScopedSelect::DebugDump()
{
    printf("********** BEGIN SWQLNode_WmiScopedSelect *************\n");
    printf("Scope = %S\n", m_pszScope);
    for (int i = 0; i < m_aTables.Size(); i++)
    {
        printf("Selected table = %S\n", LPWSTR(m_aTables[i]));
    }
    printf("********** END SWQLNode_WmiScopedSelect *************\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_TableRef::DebugDump()
{
    printf("  ---TableRef---\n");
    printf("  TableName = %S\n", m_pTableName);
    printf("  Alias     = %S\n", m_pAlias);
    printf("  ---End TableRef---\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_Join::DebugDump()
{
    printf("---SWQLNode_Join---\n");

    printf("Join type = ");

    switch (m_dwJoinType)
    {
        case WQL_FLAG_INNER_JOIN : printf("WQL_FLAG_INNER_JOIN "); break;
        case WQL_FLAG_FULL_OUTER_JOIN : printf("WQL_FLAG_FULL_OUTER_JOIN "); break;
        case WQL_FLAG_LEFT_OUTER_JOIN : printf("WQL_FLAG_LEFT_OUTER_JOIN "); break;
        case WQL_FLAG_RIGHT_OUTER_JOIN : printf("WQL_FLAG_RIGHT_OUTER_JOIN "); break;
        default: printf("<error> ");
    }

    if (m_dwFlags & WQL_FLAG_FIRSTROW)
        printf(" (FIRSTROW)");

    printf("\n");

    if (m_pRight)
        m_pRight->DebugDump();

    if (m_pLeft)
        m_pLeft->DebugDump();

    printf("---End SWQLNode_Join---\n");
}

//***************************************************************************
//
//  SWQLNode_Sql89Join::Empty
//
//***************************************************************************

void SWQLNode_Sql89Join::Empty()
{
    for (int i = 0; i < m_aValues.Size(); i++)
        delete (SWQLNode_TableRef *) m_aValues[i];
    m_aValues.Empty();
}

//***************************************************************************
//
//  SWQLNode_Sql89Join::DebugDump
//
//***************************************************************************

void SWQLNode_Sql89Join::DebugDump()
{
    printf("\n========== SQL 89 JOIN =================================\n");
    for (int i = 0; i < m_aValues.Size(); i++)
    {
        SWQLNode_TableRef *pTR = (SWQLNode_TableRef *) m_aValues[i];
        if (pTR)
            pTR->DebugDump();
    }
    printf("\n========== END SQL 89 JOIN =============================\n");

}


//***************************************************************************
//
//  SWQLNode_WhereClause::DebugDump
//
//***************************************************************************

void SWQLNode_WhereClause::DebugDump()
{
    printf("\n========== WHERE CLAUSE ================================\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    else
        printf(" <no where clause> \n");
    if (m_pRight)
        m_pRight->DebugDump();

    printf("============= END WHERE CLAUSE ============================\n");
}

//***************************************************************************
//
//  SWQLNode_WhereOptions::DebugDump
//
//***************************************************************************

void SWQLNode_WhereOptions::DebugDump()
{
    printf("---- Where Options ----\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();

    printf("---- End Where Options ----\n");
}

//***************************************************************************
//
//  SWQLNode_Having::DebugDump
//
//***************************************************************************

void SWQLNode_Having::DebugDump()
{
    printf("---- Having ----\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();

    printf("---- End Having ----\n");
}

//***************************************************************************
//
//  SWQLNode_GroupBy::DebugDump
//
//***************************************************************************

void SWQLNode_GroupBy::DebugDump()
{
    printf("---- Group By ----\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();

    printf("---- End Group By ----\n");
}


//***************************************************************************
//
//  SWQLNode_RelExpr::DebugDump
//
//***************************************************************************

void SWQLNode_RelExpr::DebugDump()
{
    if (m_pRight)
        m_pRight->DebugDump();

    printf("   --- SWQLNode_RelExpr ---\n");

    switch (m_dwExprType)
    {
        case WQL_TOK_OR:
            printf("    <WQL_TOK_OR>\n");
            break;

        case WQL_TOK_AND:
            printf("    <WQL_TOK_AND>\n");
            break;

        case WQL_TOK_NOT:
            printf("    <WQL_TOK_NOT>\n");
            break;

        case WQL_TOK_TYPED_EXPR:
            printf("    <WQL_TOK_TYPED_EXPR>\n");
            m_pTypedExpr->DebugDump();
            break;

        default:
            printf("    <invalid>\n");
    }

    printf("   --- END SWQLNode_RelExpr ---\n\n");

    if (m_pLeft)
        m_pLeft->DebugDump();

}

//***************************************************************************
//
//***************************************************************************

static LPWSTR OpToStr(DWORD dwOp)
{
    LPWSTR pRet = 0;

    switch (dwOp)
    {
        case WQL_TOK_EQ: pRet = L" '='   <WQL_TOK_EQ>"; break;
        case WQL_TOK_NE: pRet = L" '!='  <WQL_TOK_NE>"; break;
        case WQL_TOK_GT: pRet = L" '>'   <WQL_TOK_GT>"; break;
        case WQL_TOK_LT: pRet = L" '<'   <WQL_TOK_LT>"; break;
        case WQL_TOK_GE: pRet = L" '>='  <WQL_TOK_GE>"; break;
        case WQL_TOK_LE: pRet = L" '<='  <WQL_TOK_LE>"; break;

        case WQL_TOK_IN_CONST_LIST : pRet = L" IN <WQL_TOK_IN_CONST_LIST>"; break;
        case WQL_TOK_NOT_IN_CONST_LIST : pRet = L" NOT IN <WQL_TOK_NOT_IN_CONST_LIST>"; break;
        case WQL_TOK_IN_SUBSELECT : pRet = L" IN <WQL_TOK_IN_SUBSELECT>"; break;
        case WQL_TOK_NOT_IN_SUBSELECT : pRet = L" NOT IN <WQL_TOK_NOT_IN_SUBSELECT>"; break;

        case WQL_TOK_ISNULL: pRet = L"<WQL_TOK_ISNULL>"; break;
        case WQL_TOK_NOT_NULL: pRet = L"<WQL_TOK_NOT_NULL>"; break;

        case WQL_TOK_BETWEEN: pRet = L"<WQL_TOK_BETWEEN>"; break;
        case WQL_TOK_NOT_BETWEEN: pRet = L"<WQL_TOK_NOT_BETWEEN>"; break;

        default: pRet = L"   <unknown operator>"; break;
    }

    return pRet;
}

//***************************************************************************
//
//***************************************************************************

void SWQLTypedExpr::DebugDump()
{
    printf("        === BEGIN SWQLTypedExpr ===\n");
    printf("        m_pTableRef     = %S\n", m_pTableRef);
    printf("        m_pColRef       = %S\n", m_pColRef);
    printf("        m_pJoinTableRef = %S\n", m_pJoinTableRef);
    printf("        m_pJoinColRef   = %S\n", m_pJoinColRef);
    printf("        m_dwRelOperator = %S\n", OpToStr(m_dwRelOperator));
//    printf("        m_pSubSelect    = 0x%X\n", m_pSubSelect);
    printf("        m_dwLeftArrayIndex = %d\n", m_dwLeftArrayIndex);
    printf("        m_dwRightArrayIndex = %d\n", m_dwRightArrayIndex);

    printf("        m_pConstValue   = ");
    if (m_pConstValue)
        m_pConstValue->DebugDump();
    else
        printf("  NULL ptr \n");

    printf("        m_pConstValue2   = ");
    if (m_pConstValue2)
        m_pConstValue2->DebugDump();
    else
        printf("  NULL ptr \n");



    printf("        m_dwLeftFlags = (0x%X)", m_dwLeftFlags);
    if (m_dwLeftFlags & WQL_FLAG_COLUMN)
        printf(" WQL_FLAG_COLUMN");
    if (m_dwLeftFlags & WQL_FLAG_TABLE)
        printf(" WQL_FLAG_TABLE");
    if (m_dwLeftFlags & WQL_FLAG_CONST)
        printf(" WQL_FLAG_CONST");
    if (m_dwLeftFlags & WQL_FLAG_COMPLEX_NAME)
        printf(" WQL_FLAG_COMPLEX_NAME");
    if (m_dwLeftFlags & WQL_FLAG_SORT_ASC)
        printf(" WQL_FLAG_SORT_ASC");
    if (m_dwLeftFlags & WQL_FLAG_SORT_DESC)
        printf(" WQL_FLAG_SORT_DESC");
    if (m_dwLeftFlags & WQL_FLAG_FUNCTIONIZED)
        printf(" WQL_FLAG_FUNCTIONIZED (Function=%S)", m_pIntrinsicFuncOnColRef);
    if (m_dwLeftFlags & WQL_FLAG_ARRAY_REF)
        printf(" WQL_FLAG_ARRAY_REF");
    printf("\n");


    printf("        m_dwRightFlags = (0x%X)", m_dwRightFlags);
    if (m_dwRightFlags & WQL_FLAG_COLUMN)
        printf(" WQL_FLAG_COLUMN");
    if (m_dwRightFlags & WQL_FLAG_TABLE)
        printf(" WQL_FLAG_TABLE");
    if (m_dwRightFlags & WQL_FLAG_CONST)
        printf(" WQL_FLAG_CONST");
    if (m_dwRightFlags & WQL_FLAG_COMPLEX_NAME)
        printf(" WQL_FLAG_COMPLEX_NAME");
    if (m_dwLeftFlags & WQL_FLAG_SORT_ASC)
        printf(" WQL_FLAG_SORT_ASC");
    if (m_dwLeftFlags & WQL_FLAG_SORT_DESC)
        printf(" WQL_FLAG_SORT_DESC");
    if (m_dwRightFlags & WQL_FLAG_FUNCTIONIZED)
    {
        printf(" WQL_FLAG_FUNCTIONIZED");
        if (m_pIntrinsicFuncOnJoinColRef)
            printf("(On join col: Function=%S)", m_pIntrinsicFuncOnJoinColRef);
        if (m_pIntrinsicFuncOnConstValue)
            printf("(On const: Function=%S)", m_pIntrinsicFuncOnConstValue);
    }
    if (m_dwRightFlags & WQL_FLAG_ARRAY_REF)
        printf(" WQL_FLAG_ARRAY_REF");

    if (m_dwRightFlags & WQL_FLAG_CONST_RANGE)
        printf(" WQL_FLAG_CONST_RANGE");

    printf("\n");

    if (m_pLeftFunction)
    {
        printf("m_pLeftFunction: \n");
        m_pLeftFunction->DebugDump();
    }
    if (m_pRightFunction)
    {
        printf("m_pRightFunction: \n");
        m_pRightFunction->DebugDump();
    }

    if (m_pConstList)
    {
        printf("   ---Const List---\n");
        for (int i = 0; i < m_pConstList->m_aValues.Size(); i++)
        {
            SWQLTypedConst *pConst = (SWQLTypedConst *) m_pConstList->m_aValues.GetAt(i);
            printf("    ");
            pConst->DebugDump();
        }

        printf("   ---End Const List---\n");
    }

    // Subselects
    // ==========
    if (m_pSubSelect)
    {
        printf("    ------- Begin Subselect ------\n");
        m_pSubSelect->DebugDump();
        printf("    ------- End   Subselect ------\n");
    }

    printf("\n");

    printf("        === END SWQLTypedExpr ===\n");
}

//***************************************************************************
//
//***************************************************************************

SWQLTypedExpr::SWQLTypedExpr()
{
    m_pTableRef = 0;
    m_pColRef = 0;
    m_dwRelOperator = 0;
    m_pConstValue = 0;
    m_pConstValue2 = 0;
    m_pJoinTableRef = 0;
    m_pJoinColRef = 0;
    m_pIntrinsicFuncOnColRef = 0;
    m_pIntrinsicFuncOnJoinColRef = 0;
    m_pIntrinsicFuncOnConstValue = 0;
    m_pLeftFunction = 0;
    m_pRightFunction = 0;
    m_pQNRight = 0;
    m_pQNLeft = 0;
    m_dwLeftFlags = 0;
    m_dwRightFlags = 0;
    m_pSubSelect = 0;
    m_dwLeftArrayIndex = 0;
    m_dwRightArrayIndex = 0;
    m_pConstList = 0;
}

//***************************************************************************
//
//***************************************************************************

void SWQLTypedExpr::Empty()
{
    delete [] m_pTableRef;
    delete [] m_pColRef;

    delete m_pConstValue;
    delete m_pConstValue2;

    delete m_pConstList;

    delete [] m_pJoinTableRef;
    delete [] m_pJoinColRef;
    delete [] m_pIntrinsicFuncOnColRef;
    delete [] m_pIntrinsicFuncOnJoinColRef;
    delete [] m_pIntrinsicFuncOnConstValue;

    delete m_pLeftFunction;
    delete m_pRightFunction;
    delete m_pQNRight;
    delete m_pQNLeft;
    delete m_pSubSelect;
}

//***************************************************************************
//
//***************************************************************************
//
void SWQLNode_Delete::DebugDump()
{
    printf("Delete Node\n");

    printf("FROM:");
    if (m_pLeft)
        m_pLeft->DebugDump();
    printf("WHERE:");
    if (m_pRight)
        m_pRight->DebugDump();
}

//***************************************************************************
//
//***************************************************************************
SWQLNode_Delete::~SWQLNode_Delete()
{
    // nothing for now
}


//***************************************************************************
//
//***************************************************************************

void SWQLTypedConst::DebugDump()
{
    printf("   Typed Const <");

    switch (m_dwType)
    {
        case VT_LPWSTR:
            printf("%S", m_Value.m_pString);
            break;

        case VT_I4:
            printf("%d (0x%X)", m_Value.m_lValue, m_Value.m_lValue);
            break;

        case VT_R8:
            printf("%f", m_Value.m_dblValue);
            break;

        case VT_BOOL:
            printf("(bool) %d", m_Value.m_bValue);
            break;

        case VT_NULL:
            printf(" NULL");
            break;

        default:
            printf(" unknown");
    }

    printf(">\n");
}


//***************************************************************************
//
//***************************************************************************

static DWORD FlipOperator(DWORD dwOp)
{
    switch (dwOp)
    {
        case WQL_TOK_LT: return WQL_TOK_GT;
        case WQL_TOK_LE: return WQL_TOK_GE;
        case WQL_TOK_GT: return WQL_TOK_LT;
        case WQL_TOK_GE: return WQL_TOK_LE;
    }

    return dwOp; // Echo original
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_JoinPair::DebugDump()
{
    printf("---SWQLNode_JoinPair---\n");
    if (m_pRight)
        m_pRight->DebugDump();
    if (m_pLeft)
        m_pLeft->DebugDump();
    printf("---End SWQLNode_JoinPair---\n");
}

void SWQLNode_OnClause::DebugDump()
{
    printf("---SWQLNode_OnClause---\n");
    if (m_pLeft)
        m_pLeft->DebugDump();
    printf("---END SWQLNode_OnClause---\n");
}


//***************************************************************************
//
//***************************************************************************

void SWQLNode_OrderBy::DebugDump()
{
    printf("\n\n---- 'ORDER BY' Clause ----\n");
    if (m_pLeft)
        m_pLeft->DebugDump();
    printf("---- End 'ORDER BY' Clause ----\n\n");
}

//***************************************************************************
//
//***************************************************************************


const LPWSTR CWQLParser::AliasToTable(IN LPWSTR pAlias)
{
    const CFlexArray *pAliases = GetSelectedAliases();

    for (int i = 0; i < pAliases->Size(); i++)
    {
        SWQLNode_TableRef *pTR = (SWQLNode_TableRef *) pAliases->GetAt(i);

        if (_wcsicmp(pTR->m_pAlias, pAlias) == 0)
            return pTR->m_pTableName;
    }

    return NULL;    // Not found
}


//***************************************************************************
//
//***************************************************************************
//

void SWQLNode_Datepart::DebugDump()
{
    printf("        ----Begin SWQLNode_Datepart----\n");

    switch (m_nDatepart)
    {
        case WQL_TOK_YEAR:   printf("       WQL_TOK_YEAR"); break;
        case WQL_TOK_MONTH:  printf("       WQL_TOK_MONTH"); break;
        case WQL_TOK_DAY:    printf("       WQL_TOK_DAY"); break;
        case WQL_TOK_HOUR:   printf("       WQL_TOK_HOUR"); break;
        case WQL_TOK_MINUTE: printf("       WQL_TOK_MINUTE"); break;
        case WQL_TOK_SECOND: printf("       WQL_TOK_SECOND"); break;
        case WQL_TOK_MILLISECOND: printf("      WQL_TOK_MILLISECOND"); break;
        default:
            printf("        -> No datepart specified\n");
    }

    printf("\n");

    if (m_pColRef)
        m_pColRef->DebugDump();

    printf("        ----End SWQLNode_Datepart----\n");
}


//***************************************************************************
//
//***************************************************************************
//

void SWQLNode_ColumnList::Empty()
{
    for (int i = 0; i < m_aColumnRefs.Size(); i++)
        delete (SWQLColRef *) m_aColumnRefs[i];
    m_aColumnRefs.Empty();
}


//***************************************************************************
//
//***************************************************************************
//

void StrArrayDelete(
    ULONG uSize,
    LPWSTR *pszArray
    )
{
    if (!pszArray)
    	return;
    for (unsigned u = 0; u < uSize; u++)
        delete  pszArray[u];
    delete pszArray;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT StrArrayCopy(
    ULONG  uSize,
    LPWSTR *pSrc,
    LPWSTR **pDest
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR *pFinal = new LPWSTR[uSize];
    if (pFinal)
    {
        for (ULONG u = 0; u < uSize; u++)
        {
            pFinal[u] = CloneLPWSTR(pSrc[u]);
            if (!pFinal[u])
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                break;
            }
        }

        if (SUCCEEDED(hr))
        {
            *pDest = pFinal;
        }
        else
        {
            for (ULONG u2 = 0; u2 < u; u2++)
            {
                delete pFinal[u];
            }
            delete [] pFinal;
        }
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//***************************************************************************
//

CWbemQueryQualifiedName::CWbemQueryQualifiedName()
{
    Init();
}

//***************************************************************************
//
//***************************************************************************
//

void CWbemQueryQualifiedName::Init()
{
    m_uVersion = 1;
    m_uTokenType = 1;

    m_uNameListSize = 0;
    m_ppszNameList = 0;

    m_bArraysUsed = 0;
    m_pbArrayElUsed = 0;
    m_puArrayIndex = 0;
}

//////////////////////////////////////////////////////////////////////////////////
// *

CWbemQueryQualifiedName::~CWbemQueryQualifiedName() { DeleteAll(); }

void CWbemQueryQualifiedName::DeleteAll()
{
    StrArrayDelete(m_uNameListSize, (LPWSTR *) m_ppszNameList);
    
    delete [] m_pbArrayElUsed;
    delete [] m_puArrayIndex;
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemQueryQualifiedName::CWbemQueryQualifiedName(CWbemQueryQualifiedName &Src)
{
    Init();
    *this = Src;
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemQueryQualifiedName& CWbemQueryQualifiedName::operator =(CWbemQueryQualifiedName &Src)
{
    DeleteAll();

    m_uVersion = Src.m_uVersion;
    m_uTokenType = Src.m_uTokenType;

    m_uNameListSize = Src.m_uNameListSize;

    m_ppszNameList = new LPCWSTR[m_uNameListSize];
    m_pbArrayElUsed = new BOOL[m_uNameListSize];
    m_puArrayIndex = new ULONG[m_uNameListSize];

    if (!m_ppszNameList || !m_pbArrayElUsed || !m_puArrayIndex)
        throw CX_MemoryException();

    for (unsigned u = 0; u < m_uNameListSize; u++)
    {
        m_pbArrayElUsed[u] = Src.m_pbArrayElUsed[u];
        m_puArrayIndex[u] = Src.m_puArrayIndex[u];
    }

    if (FAILED(StrArrayCopy(m_uNameListSize, (LPWSTR *) Src.m_ppszNameList, (LPWSTR **) &m_ppszNameList)))
	throw CX_MemoryException();

    return *this;
};

//////////////////////////////////////////////////////////////////////////////////
//

void CWbemRpnQueryToken::Init()
{
    m_uVersion = 1;
    m_uTokenType = 0;

    m_uSubexpressionShape = 0;
    m_uOperator = 0;

    m_pRightIdent = 0;
    m_pLeftIdent = 0;

    m_uConstApparentType = 0;  // VT_ type
    m_uConst2ApparentType  = 0;

    m_Const.m_uVal64 = 0;
    m_Const2.m_uVal64 = 0;

    m_pszLeftFunc = 0;
    m_pszRightFunc = 0;
}


///////////////////////////////////////////////////////////////////////////////////
//
//

CWbemRpnQueryToken::CWbemRpnQueryToken()
{
    Init();
}

///////////////////////////////////////////////////////////////////////////////////
//
//

void CWbemRpnEncodedQuery::DeleteAll()
{
    unsigned u = 0;

    for (u = 0; u < m_uSelectListSize; u++)
    {
        SWbemQueryQualifiedName *pQN = m_ppSelectList[u];
        CWbemQueryQualifiedName  *pTmp = (CWbemQueryQualifiedName*) pQN;
        delete pTmp;
    }

    delete [] m_puDetectedFeatures;
    delete [] m_ppSelectList;
    delete LPWSTR(m_pszOptionalFromPath);

    StrArrayDelete(m_uFromListSize, (LPWSTR *) m_ppszFromList);

    for (u = 0; u < m_uWhereClauseSize; u++)
    {
        CWbemRpnQueryToken *pTmp = (CWbemRpnQueryToken *) m_ppRpnWhereClause[u];
        delete pTmp;
    }

    m_uWhereClauseSize = 0;

    delete [] m_ppRpnWhereClause;
    StrArrayDelete(m_uOrderByListSize, (LPWSTR *) m_ppszOrderByList);
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemRpnQueryToken::~CWbemRpnQueryToken() { DeleteAll(); }

void CWbemRpnQueryToken::DeleteAll()
{
    delete (CWbemQueryQualifiedName *) m_pRightIdent;
    delete (CWbemQueryQualifiedName *) m_pLeftIdent;

    if (m_uConstApparentType == VT_LPWSTR)
    {
        delete (LPWSTR) m_Const.m_pszStrVal;
    }

    if (m_uConst2ApparentType == VT_LPWSTR)
    {
        delete (LPWSTR) m_Const2.m_pszStrVal;
    }


    delete LPWSTR(m_pszLeftFunc);
    delete LPWSTR(m_pszRightFunc);
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemRpnQueryToken::CWbemRpnQueryToken(CWbemRpnQueryToken &Src)
{
    Init();
    *this = Src;
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemRpnQueryToken& CWbemRpnQueryToken::operator =(CWbemRpnQueryToken &Src)
{
    // Kill old stuff.

    DeleteAll();

    // Copy new stuff.

    m_pRightIdent = (SWbemQueryQualifiedName *) new CWbemQueryQualifiedName(
        *(CWbemQueryQualifiedName *) Src.m_pRightIdent
        );

    m_pLeftIdent = (SWbemQueryQualifiedName *) new CWbemQueryQualifiedName(
        *(CWbemQueryQualifiedName *) Src.m_pLeftIdent
        );

    if (!m_pRightIdent || !m_pLeftIdent)
        throw CX_MemoryException();

    m_uConstApparentType = Src.m_uConstApparentType;
    m_uConst2ApparentType = Src.m_uConst2ApparentType;

    if (m_uConstApparentType == VT_LPWSTR)
    {
        m_Const.m_pszStrVal = CloneLPWSTR(Src.m_Const.m_pszStrVal);\
        if (!m_Const.m_pszStrVal)
            throw CX_MemoryException();
    }
    else
        m_Const = Src.m_Const;

    if (m_uConst2ApparentType == VT_LPWSTR)
    {
        m_Const2.m_pszStrVal = CloneLPWSTR(Src.m_Const2.m_pszStrVal);
        if (!m_Const2.m_pszStrVal)
            throw CX_MemoryException();
    }
    else
        m_Const2 = Src.m_Const2;

    m_pszLeftFunc = CloneLPWSTR(Src.m_pszLeftFunc);
    if (CloneFailed(m_pszLeftFunc,Src.m_pszLeftFunc))
        throw CX_MemoryException();
    m_pszRightFunc = CloneLPWSTR(Src.m_pszRightFunc);
    if (CloneFailed(m_pszRightFunc,Src.m_pszRightFunc))
        throw CX_MemoryException();

    return *this;
};

//////////////////////////////////////////////////////////////////////////////////

void CWbemRpnEncodedQuery::Init()
{
    m_uVersion = 1;
    m_uTokenType = 0;

    m_uParsedFeatureMask = 0I64;

    m_uDetectedArraySize = 0;
    m_puDetectedFeatures = 0;

    m_uSelectListSize = 0;
    m_ppSelectList = 0;

    // FROM clause
    // ===========

    m_uFromTargetType = 0;
    m_pszOptionalFromPath = 0;
    m_uFromListSize = 0;
    m_ppszFromList = 0;

    // Where clause
    // ============

    m_uWhereClauseSize = 0;
    m_ppRpnWhereClause = 0;

    // WITHIN value
    // ============

    m_dblWithinPolling = 0.0;
    m_dblWithinWindow = 0.0;

    // ORDER BY
    // ========

    m_uOrderByListSize = 0;
    m_ppszOrderByList = 0;
    m_uOrderDirectionEl = 0;
}


///////////////////////////////////////////////////////////////////////////////////
//
//

CWbemRpnEncodedQuery::CWbemRpnEncodedQuery()
{
    Init();
}

///////////////////////////////////////////////////////////////////////////////////
//
//


CWbemRpnEncodedQuery::~CWbemRpnEncodedQuery()
{
    DeleteAll();
}

///////////////////////////////////////////////////////////////////////////////////
//
//

CWbemRpnEncodedQuery::CWbemRpnEncodedQuery(CWbemRpnEncodedQuery &Src)
{
    Init();
    *this = Src;
}

///////////////////////////////////////////////////////////////////////////////////
//
//

CWbemRpnEncodedQuery& CWbemRpnEncodedQuery::operator=(CWbemRpnEncodedQuery &Src)
{
    unsigned u;

    // Kill old stuff.
    DeleteAll();

    // Clone new stuff.

    m_uVersion = Src.m_uVersion;
    m_uTokenType  = Src.m_uTokenType;

    // General query features
    // ======================

    m_uParsedFeatureMask = Src.m_uParsedFeatureMask;

    m_uDetectedArraySize = Src.m_uDetectedArraySize;
    m_puDetectedFeatures = new ULONG[Src.m_uDetectedArraySize];
    if (!m_puDetectedFeatures)
        throw CX_MemoryException();

    memcpy(m_puDetectedFeatures, Src.m_puDetectedFeatures, sizeof(ULONG) * Src.m_uDetectedArraySize);

    // Values being selected if WMIQ_RPNF_PROJECTION is set
    // =====================================================

    m_uSelectListSize = Src.m_uSelectListSize;

    m_ppSelectList = (SWbemQueryQualifiedName **) new CWbemQueryQualifiedName *[m_uSelectListSize];
    if (!m_ppSelectList)
        throw CX_MemoryException();

    for (u = 0; u < m_uSelectListSize; u++)
    {
        CWbemQueryQualifiedName *p = new CWbemQueryQualifiedName(*(CWbemQueryQualifiedName *) Src.m_ppSelectList[u]);
        if (!p)
            throw CX_MemoryException();

        m_ppSelectList[u] = (SWbemQueryQualifiedName *) p;
    }

    // FROM

    m_uFromTargetType = Src.m_uFromTargetType;
    m_pszOptionalFromPath = CloneLPWSTR(Src.m_pszOptionalFromPath);// NULL if not used
    if (CloneFailed(m_pszOptionalFromPath,Src.m_pszOptionalFromPath))
        throw CX_MemoryException();

    if (FAILED(StrArrayCopy(Src.m_uFromListSize, (LPWSTR *) Src.m_ppszFromList, (LPWSTR **) &m_ppszFromList)))
    	throw CX_MemoryException();

    m_uFromListSize = Src.m_uFromListSize;

    // Where clause
    // ============

    m_uWhereClauseSize = Src.m_uWhereClauseSize;
    m_ppRpnWhereClause = new SWbemRpnQueryToken *[m_uWhereClauseSize];
    if (!m_ppRpnWhereClause)
        throw CX_MemoryException();

    for (u = 0; u < m_uWhereClauseSize; u++)
    {
        CWbemRpnQueryToken *pTmp = new CWbemRpnQueryToken(* (CWbemRpnQueryToken *) Src.m_ppRpnWhereClause[u]);
        if (!pTmp)
            throw CX_MemoryException();

        m_ppRpnWhereClause[u] = (SWbemRpnQueryToken *) pTmp;
    }

    // WITHIN value
    // ============

    m_dblWithinPolling  = Src.m_dblWithinPolling;
    m_dblWithinWindow = Src.m_dblWithinWindow;


    // ORDER BY
    // ========

    if (FAILED(StrArrayCopy(Src.m_uOrderByListSize, (LPWSTR *) Src.m_ppszOrderByList, (LPWSTR **) &m_ppszOrderByList)))
    	throw CX_MemoryException();
    m_uOrderByListSize = Src.m_uOrderByListSize;

    m_uOrderDirectionEl = new ULONG[m_uOrderByListSize];
    if (!m_uOrderDirectionEl)
        throw CX_MemoryException();

    memcpy(m_uOrderDirectionEl, Src.m_uOrderDirectionEl, sizeof(ULONG) * m_uOrderByListSize);

    return *this;
}


///////////////////////////////////////////////////////////////////////////////////
//
//  Recursively rearranges the tokens from AST to RPN.
//  Nondestructive to the query itself; only stores the pointers.
//
//

HRESULT CWQLParser::BuildRpnWhereClause(
    SWQLNode *pCurrent,
    CFlexArray &aRpnReorg
    )
{
    if (pCurrent == 0)
        return WBEM_S_NO_ERROR;

    BuildRpnWhereClause(pCurrent->m_pLeft, aRpnReorg);
    BuildRpnWhereClause(pCurrent->m_pRight, aRpnReorg);
    aRpnReorg.Add(pCurrent);

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
int CWQLParser::update_stmt(OUT SWQLNode_Update **pUpdStmt)
{
    return WBEM_E_INVALID_SYNTAX;
}

//***************************************************************************
//
//***************************************************************************
//
int CWQLParser::insert_stmt(OUT SWQLNode_Insert **pInsStmt)
{
    return WBEM_E_INVALID_SYNTAX;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWQLParser::BuildSelectList(CWbemRpnEncodedQuery *pQuery)
{
    SWQLNode_ColumnList *pCL = (SWQLNode_ColumnList *) GetColumnList();
    if (pCL == 0)
        return WBEM_E_INVALID_QUERY;

    ULONG uSize = (ULONG) pCL->m_aColumnRefs.Size();
    pQuery->m_uSelectListSize = uSize;

    pQuery->m_ppSelectList = (SWbemQueryQualifiedName  **)
        new CWbemQueryQualifiedName *[uSize];
    if (!pQuery->m_ppSelectList)
    {
        throw CX_MemoryException();
    }

    for (ULONG u = 0; u < uSize; u++)
    {
        SWQLColRef *pCol = (SWQLColRef *) pCL->m_aColumnRefs[u];
        SWbemQueryQualifiedName *pTemp = (SWbemQueryQualifiedName *) new CWbemQueryQualifiedName;
        if (!pTemp)
            throw CX_MemoryException();

        unsigned uNameListSize = 1;
        if (pCol->m_pTableRef)
            uNameListSize = 2;
        pTemp->m_uNameListSize = uNameListSize;
        pTemp->m_ppszNameList = (LPCWSTR *) new LPWSTR[uNameListSize];

        if (!pTemp->m_ppszNameList)
        {
            delete pTemp;
            throw CX_MemoryException();
        }

        if (uNameListSize == 1)
        {
            pTemp->m_ppszNameList[0] = CloneLPWSTR(pCol->m_pColName);
            if (!pTemp->m_ppszNameList[0])
            {
                delete pTemp;
                throw CX_MemoryException();
            }
        }
        else
        {
            pTemp->m_ppszNameList[0] = CloneLPWSTR(pCol->m_pTableRef);
            if (!pTemp->m_ppszNameList[0])
            {
                delete pTemp;
                throw CX_MemoryException();
            }
            pTemp->m_ppszNameList[1] = CloneLPWSTR(pCol->m_pColName);
            if (!pTemp->m_ppszNameList[1])
            {
                delete pTemp;
                throw CX_MemoryException();
            }
        }

        pQuery->m_ppSelectList[u] = pTemp;
    }

    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWQLParser::BuildFromClause(CWbemRpnEncodedQuery *pQuery)
{
    SWQLNode_FromClause *pFrom = (SWQLNode_FromClause *) GetFromClause();

    if (pFrom == NULL)
        return WBEM_E_INVALID_QUERY;

    // Check left node for traditional SQL
    // Check right node for WMI scoped select

    if (pFrom->m_pLeft)
    {
        SWQLNode_TableRef *pTR = (SWQLNode_TableRef *) pFrom->m_pLeft;
        pQuery->m_uFromTargetType |= WMIQ_RPN_FROM_UNARY;

        pQuery->m_uFromListSize = 1;
        pQuery->m_ppszFromList = (LPCWSTR *) new LPWSTR[1];
        if (!pQuery->m_ppszFromList)
            throw CX_MemoryException();

        pQuery->m_ppszFromList[0] = CloneLPWSTR(pTR->m_pTableName);
        if (!pQuery->m_ppszFromList[0])
        {
            delete pQuery->m_ppszFromList;
            throw CX_MemoryException();
        }
    }
    else if (pFrom->m_pRight)
    {
        SWQLNode_WmiScopedSelect *pSS = (SWQLNode_WmiScopedSelect *) pFrom->m_pRight;

        pQuery->m_uFromTargetType |= WMIQ_RPN_FROM_PATH;
        pQuery->m_pszOptionalFromPath = CloneLPWSTR(pSS->m_pszScope);
        if (pQuery->m_pszOptionalFromPath)
        {
            throw CX_MemoryException();
        }

        int nSz = pSS->m_aTables.Size();
        if (nSz == 1)
            pQuery->m_uFromTargetType |= WMIQ_RPN_FROM_UNARY;
        else if (nSz > 1)
            pQuery->m_uFromTargetType |= WMIQ_RPN_FROM_CLASS_LIST;


        pQuery->m_uFromListSize = (ULONG) nSz;
        pQuery->m_ppszFromList = (LPCWSTR *) new LPWSTR[nSz];
        if (!pQuery->m_ppszFromList)
            throw CX_MemoryException();

        for (int n = 0; n < nSz; n++)
        {
            pQuery->m_ppszFromList[n] = CloneLPWSTR(LPWSTR(pSS->m_aTables[n]));
            if (!pQuery->m_ppszFromList[n])
                throw CX_MemoryException();
        }
    }
    else
        return WBEM_E_INVALID_QUERY;

    return 0;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWQLParser::GetRpnSequence(OUT SWbemRpnEncodedQuery **pRpn)
{
    HRESULT hRes;

    try
    {
        CWbemRpnEncodedQuery *pNewRpn = new CWbemRpnEncodedQuery;
        if (!pNewRpn)
            return WBEM_E_OUT_OF_MEMORY;

        // Copy detected features.
        // =======================

        pNewRpn->m_uParsedFeatureMask = m_uFeatures;

        // Do the SELECT LIST.
        // ===================
        BuildSelectList(pNewRpn);

        // Do the FROM list.
        // =================
        BuildFromClause(pNewRpn);

        // Do the WHERE clause.
        // ====================

        CFlexArray aRpn;
        SWQLNode *pWhereRoot = GetWhereClauseRoot();

        SWQLNode_RelExpr *pExprRoot = (SWQLNode_RelExpr *) pWhereRoot->m_pLeft;
        SWQLNode_WhereOptions *pOp = (SWQLNode_WhereOptions *) pWhereRoot->m_pRight;      // ORDER BY, etc.

        if (pExprRoot)
            hRes = BuildRpnWhereClause(pExprRoot, aRpn);

        // Now traverse the RPN form of the WHERE clause, if any.
        // ======================================================
        if (aRpn.Size())
        {
            pNewRpn->m_uWhereClauseSize = aRpn.Size();
            pNewRpn->m_ppRpnWhereClause = (SWbemRpnQueryToken **) new CWbemRpnQueryToken*[aRpn.Size()];
            if (!pNewRpn->m_ppRpnWhereClause)
                return WBEM_E_OUT_OF_MEMORY;
        }

        BOOL b_Test_AllEqualityTests = TRUE;
        BOOL b_Test_Disjunctive = FALSE;
        BOOL b_AtLeastOneTest = FALSE;

        for (int i = 0; i < aRpn.Size(); i++)
        {
            SWQLNode_RelExpr *pSrc = (SWQLNode_RelExpr *) aRpn[i];
            SWbemRpnQueryToken *pDest = (SWbemRpnQueryToken *) new CWbemRpnQueryToken;
            if (!pDest)
                return WBEM_E_OUT_OF_MEMORY;
            hRes = BuildCurrentWhereToken(pSrc, pDest);
            pNewRpn->m_ppRpnWhereClause[i] = pDest;

            // Add in stats.
            // =============
            if (pDest->m_uTokenType == WMIQ_RPN_TOKEN_EXPRESSION)
            {
                if (pDest->m_uOperator != WMIQ_RPN_OP_EQ)
                    b_Test_AllEqualityTests = FALSE;
                b_AtLeastOneTest = TRUE;
            }
            else if (pDest->m_uTokenType != WMIQ_RPN_TOKEN_AND)
            {
                b_Test_Disjunctive = TRUE;
            }

            if (pDest->m_pRightIdent != 0 && pDest->m_pLeftIdent != 0)
            {
                pNewRpn->m_uParsedFeatureMask |= WMIQ_RPNF_PROP_TO_PROP_TESTS;
            }
        }

        if (b_Test_AllEqualityTests && b_AtLeastOneTest)
            pNewRpn->m_uParsedFeatureMask |= WMIQ_RPNF_EQUALITY_TESTS_ONLY;

        if (b_Test_Disjunctive)
            pNewRpn->m_uParsedFeatureMask |= WMIQ_RPNF_QUERY_IS_DISJUNCTIVE;
        else
            pNewRpn->m_uParsedFeatureMask |= WMIQ_RPNF_QUERY_IS_CONJUNCTIVE;

        *pRpn = pNewRpn;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;

    }
    catch (...)
    {
        return  WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG RpnTranslateExprFlags(SWQLTypedExpr *pTE)
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG RpnTranslateOperator(SWQLTypedExpr *pTE)
{
    ULONG uRes = WMIQ_RPN_OP_UNDEFINED;

    switch (pTE->m_dwRelOperator)
    {
        case WQL_TOK_LE:   uRes = WMIQ_RPN_OP_LE; break;
        case WQL_TOK_LT:   uRes = WMIQ_RPN_OP_LT; break;
        case WQL_TOK_GE:   uRes = WMIQ_RPN_OP_GE; break;
        case WQL_TOK_GT:   uRes = WMIQ_RPN_OP_GT; break;
        case WQL_TOK_EQ:   uRes = WMIQ_RPN_OP_EQ; break;
        case WQL_TOK_NE:   uRes = WMIQ_RPN_OP_NE; break;
        case WQL_TOK_LIKE: uRes = WMIQ_RPN_OP_LIKE; break;
        case WQL_TOK_ISA:  uRes = WMIQ_RPN_OP_ISA; break;
    }

    return uRes;
}

//***************************************************************************
//
//***************************************************************************
//
SWbemQueryQualifiedName *RpnTranslateIdent(ULONG uWhichSide, SWQLTypedExpr *pTE)
{
    SWQLQualifiedName *pQN = 0;

    if (uWhichSide == WMIQ_RPN_LEFT_PROPERTY_NAME)
    {
         pQN = pTE->m_pQNLeft;
    }
    else
    {
         pQN = pTE->m_pQNRight;
    }

    if (pQN)
    {
        CWbemQueryQualifiedName *pNew = new CWbemQueryQualifiedName;
        if (!pNew)
            throw CX_MemoryException();

        pNew->m_uNameListSize = (ULONG) pQN->m_aFields.Size();
        pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[pNew->m_uNameListSize];
        if (!pNew->m_ppszNameList)
        {
            delete pNew;
            throw CX_MemoryException();
        }

        for (int i = 0; i < pQN->m_aFields.Size(); i++)
        {
            SWQLQualifiedNameField *pField = (SWQLQualifiedNameField *) pQN->m_aFields[i];
            LPWSTR pszNewName = CloneLPWSTR(pField->m_pName);
            if (!pszNewName)
            {
                delete pNew;
                throw CX_MemoryException();
            }
            pNew->m_ppszNameList[i] = pszNewName;
        }
        return (SWbemQueryQualifiedName *) pNew;
    }

    else if (pTE->m_pColRef && WMIQ_RPN_LEFT_PROPERTY_NAME == uWhichSide)
    {
        CWbemQueryQualifiedName *pNew = new CWbemQueryQualifiedName;
        if (!pNew)
            throw CX_MemoryException();

        if (pTE->m_pTableRef)
        {
            pNew->m_uNameListSize = 2;
            pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[2];
            if (!pNew->m_ppszNameList)
            {
                delete pNew;
                throw CX_MemoryException();
            }

            pNew->m_ppszNameList[0] = CloneLPWSTR(pTE->m_pTableRef);
            if (!pNew->m_ppszNameList[0])
            {
                delete pNew;
                throw CX_MemoryException();
            }
            pNew->m_ppszNameList[1] = CloneLPWSTR(pTE->m_pColRef);
            if (!pNew->m_ppszNameList[1])
            {
                delete pNew;
                throw CX_MemoryException();
            }
        }
        else
        {
            pNew->m_uNameListSize = 1;
            pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[1];
            if (!pNew->m_ppszNameList)
            {
                delete pNew;
                throw CX_MemoryException();
            }

            pNew->m_ppszNameList[0] = CloneLPWSTR(pTE->m_pColRef);
            if (!pNew->m_ppszNameList[0])
            {
                delete pNew;
                throw CX_MemoryException();
            }
        }
        return (SWbemQueryQualifiedName *) pNew;
    }

    else if (pTE->m_pJoinColRef && WMIQ_RPN_RIGHT_PROPERTY_NAME == uWhichSide)
    {
        CWbemQueryQualifiedName *pNew = new CWbemQueryQualifiedName;
        if (!pNew)
            throw CX_MemoryException();

        if (pTE->m_pJoinTableRef)
        {
            pNew->m_uNameListSize = 2;
            pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[2];
            if (!pNew->m_ppszNameList)
            {
                delete pNew;
                throw CX_MemoryException();
            }

            pNew->m_ppszNameList[0] = CloneLPWSTR(pTE->m_pJoinTableRef);
            if (!pNew->m_ppszNameList[0])
            {
                delete pNew;
                throw CX_MemoryException();
            }
            pNew->m_ppszNameList[1] = CloneLPWSTR(pTE->m_pJoinColRef);
            if (!pNew->m_ppszNameList[1])
            {
                delete pNew;
                throw CX_MemoryException();
            }
        }
        else
        {
            pNew->m_uNameListSize = 1;
            pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[1];
            if (!pNew->m_ppszNameList)
            {
                delete pNew;
                throw CX_MemoryException();
            }

            pNew->m_ppszNameList[0] = CloneLPWSTR(pTE->m_pJoinColRef);
            if (!pNew->m_ppszNameList[0])
            {
                delete pNew;
                throw CX_MemoryException();
            }
        }
        return (SWbemQueryQualifiedName *) pNew;
    }
    else
        return 0;
}

//***************************************************************************
//
//***************************************************************************
//

SWbemQueryQualifiedName *RpnTranslateRightIdent(SWQLTypedExpr *pTE)
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

SWbemRpnConst RpnTranslateConst(SWQLTypedConst *pSrc)
{
    SWbemRpnConst c;
    memset(&c, 0, sizeof(c));

    if (!pSrc)
        return c;

    switch (pSrc->m_dwType)
    {
        case VT_LPWSTR:
            c.m_pszStrVal = CloneLPWSTR(pSrc->m_Value.m_pString);
            // this will fail with an "empty" struct returned
            break;

        case VT_I4:
            c.m_lLongVal = pSrc->m_Value.m_lValue;
            break;

        case VT_R8:
            c.m_dblVal = pSrc->m_Value.m_dblValue;
            break;

        case VT_BOOL:
            c.m_bBoolVal = pSrc->m_Value.m_bValue;
            break;

        case VT_UI4:
            c.m_uLongVal = (unsigned) pSrc->m_Value.m_lValue;
            break;

        case VT_I8:
            c.m_lVal64 =  pSrc->m_Value.m_i64Value;
            break;

        case VT_UI8:
            c.m_uVal64 = (unsigned __int64) pSrc->m_Value.m_i64Value;
            break;

    }
    return c;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG RpnTranslateConstType(SWQLTypedConst *pSrc)
{
    if (pSrc)
        return pSrc->m_dwType;
    else
        return VT_NULL;
}

//***************************************************************************
//
//***************************************************************************
//

LPCWSTR RpnTranslateLeftFunc(SWQLTypedExpr *pTE)
{
	return pTE->m_pIntrinsicFuncOnColRef;
}

//***************************************************************************
//
//***************************************************************************
//

LPCWSTR RpnTranslateRightFunc(SWQLTypedExpr *pTE)
{
	if (pTE->m_pIntrinsicFuncOnJoinColRef == 0)
		return pTE->m_pIntrinsicFuncOnConstValue;
	else
		return pTE->m_pIntrinsicFuncOnJoinColRef;
}


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWQLParser::BuildCurrentWhereToken(
        SWQLNode_RelExpr *pSrc,
        SWbemRpnQueryToken *pDest
        )
{
    HRESULT hRes = WBEM_E_INVALID_QUERY;

    if (pSrc->m_dwExprType == WQL_TOK_OR)
    {
        pDest->m_uTokenType = WMIQ_RPN_TOKEN_OR;
    }
    else if (pSrc->m_dwExprType == WQL_TOK_AND)
    {
        pDest->m_uTokenType = WMIQ_RPN_TOKEN_AND;
    }
    else if (pSrc->m_dwExprType == WQL_TOK_NOT)
    {
        pDest->m_uTokenType = WMIQ_RPN_TOKEN_NOT;
    }
    else if (pSrc->m_dwExprType == WQL_TOK_TYPED_EXPR)
    {
        pDest->m_uTokenType = WMIQ_RPN_TOKEN_EXPRESSION;

        SWQLTypedExpr *pTmp = pSrc->m_pTypedExpr;

        pDest->m_uSubexpressionShape = RpnTranslateExprFlags(pTmp);
        pDest->m_uOperator = RpnTranslateOperator(pTmp);

        pDest->m_pLeftIdent = RpnTranslateIdent(WMIQ_RPN_LEFT_PROPERTY_NAME, pTmp);
        pDest->m_pRightIdent = RpnTranslateIdent(WMIQ_RPN_RIGHT_PROPERTY_NAME, pTmp);

        pDest->m_uConstApparentType = RpnTranslateConstType(pTmp->m_pConstValue);
        pDest->m_Const = RpnTranslateConst(pTmp->m_pConstValue);

        pDest->m_uConst2ApparentType = RpnTranslateConstType(pTmp->m_pConstValue2);
        pDest->m_Const2 = RpnTranslateConst(pTmp->m_pConstValue2);

        pDest->m_pszLeftFunc = RpnTranslateLeftFunc(pTmp);
        pDest->m_pszRightFunc = RpnTranslateRightFunc(pTmp);

        if (pDest->m_pLeftIdent)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_LEFT_PROPERTY_NAME;
        if (pDest->m_pRightIdent)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_RIGHT_PROPERTY_NAME;
		
		// Special case NULL if there really is a const value with a type of NULL
        if ( (pDest->m_uConstApparentType != VT_NULL) || 
			( NULL != pTmp->m_pConstValue && pTmp->m_pConstValue->m_dwType == VT_NULL ) )
            pDest->m_uSubexpressionShape |= WMIQ_RPN_CONST;

		// Do the same for CONST2
        if ( (pDest->m_uConst2ApparentType != VT_NULL) ||
			( NULL != pTmp->m_pConstValue2 && pTmp->m_pConstValue2->m_dwType == VT_NULL ) )
            pDest->m_uSubexpressionShape |= WMIQ_RPN_CONST2;

        if (pDest->m_pszLeftFunc)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_LEFT_FUNCTION;
        if (pDest->m_pszRightFunc)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_RIGHT_FUNCTION;
        if (pDest->m_uOperator != 0)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_RELOP;
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
int CWQLParser::assocquery(OUT SWQLNode_AssocQuery **pAssocQuery)
{
    HRESULT hRes;
    CAssocQueryParser AP;
    *pAssocQuery = 0;

    hRes = AP.Parse(m_pszQueryText);

    if (FAILED(hRes))
        return hRes;

    // If here, extract the info and put it into a new node.
    // =====================================================

    SWQLNode_AssocQuery *pTmp = new SWQLNode_AssocQuery;
    if (pTmp == 0)
        return WBEM_E_OUT_OF_MEMORY;

    pTmp->m_pAQInf = new CWbemAssocQueryInf;
    if (!pTmp->m_pAQInf)
    {
        delete pTmp;
        return WBEM_E_OUT_OF_MEMORY;
    }

    hRes = pTmp->m_pAQInf->CopyFrom((SWbemAssocQueryInf *) &AP);
    *pAssocQuery = pTmp;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
void SWQLNode_QueryRoot::DebugDump()
{
    if (m_pLeft)
        m_pLeft->DebugDump();
}

//***************************************************************************
//
//***************************************************************************
//
void SWQLNode_AssocQuery::DebugDump()
{
    printf("Association query info\n");

    printf("Version         = %u\n",  m_pAQInf->m_uVersion);
    printf("Analysis Type   = %u\n",  m_pAQInf->m_uAnalysisType);
    printf("Feature Mask    = 0x%X\n", m_pAQInf->m_uFeatureMask);

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_ASSOCIATORS)
        printf("    WMIQ_ASSOCQ_ASSOCIATORS\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_REFERENCES)
        printf("    WMIQ_ASSOCQ_REFERENCES\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_RESULTCLASS)
        printf("    WMIQ_ASSOCQ_RESULTCLASS\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_ASSOCCLASS)
        printf("    WMIQ_ASSOCQ_ASSOCCLASS\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_ROLE)
        printf("    WMIQ_ASSOCQ_ROLE\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_RESULTROLE)
        printf("    WMIQ_ASSOCQ_RESULTROLE\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_REQUIREDQUALIFIER)
        printf("    WMIQ_ASSOCQ_REQUIREDQUALIFIER\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER)
        printf("    WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_CLASSDEFSONLY)
        printf("    WMIQ_ASSOCQ_CLASSDEFSONLY\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_KEYSONLY)
        printf("    WMIQ_ASSOCQ_KEYSONLY\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_SCHEMAONLY)
        printf("    WMIQ_ASSOCQ_SCHEMAONLY\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_CLASSREFSONLY)
        printf("    WMIQ_ASSOCQ_CLASSREFSONLY\n");


    printf("IWbemPath pointer = 0x%I64X\n", (unsigned __int64) m_pAQInf->m_pPath);
    if (m_pAQInf->m_pPath)
    {
        printf("Path object has ");
        wchar_t Buf[256];
        ULONG uLen = 256;
        m_pAQInf->m_pPath->GetText(0, &uLen, Buf);
        printf("<%S>\n", Buf);
    }

    printf("m_pszQueryText              = %S\n", m_pAQInf->m_pszQueryText);
    printf("m_pszResultClass            = %S\n", m_pAQInf->m_pszResultClass);
    printf("m_pszAssocClass             = %S\n", m_pAQInf->m_pszAssocClass);
    printf("m_pszRole                   = %S\n", m_pAQInf->m_pszRole);
    printf("m_pszResultRole             = %S\n", m_pAQInf->m_pszResultRole);
    printf("m_pszRequiredQualifier      = %S\n", m_pAQInf->m_pszRequiredQualifier);
    printf("m_pszRequiredAssocQualifier = %S\n", m_pAQInf->m_pszRequiredAssocQualifier);

    printf("---end---\n");
}

//***************************************************************************
//
//***************************************************************************
//
CWbemAssocQueryInf::CWbemAssocQueryInf()
{
    Init();
}


//***************************************************************************
//
//***************************************************************************
//
CWbemAssocQueryInf::~CWbemAssocQueryInf()
{
    Empty();
}

//***************************************************************************
//
//***************************************************************************
//
void CWbemAssocQueryInf::Empty()
{
    if (m_pPath)
        m_pPath->Release();
    delete [] m_pszPath;
    delete [] m_pszQueryText;
    delete [] m_pszResultClass;
    delete [] m_pszAssocClass;
    delete [] m_pszRole;
    delete [] m_pszResultRole;
    delete [] m_pszRequiredQualifier;
    delete [] m_pszRequiredAssocQualifier;
    Init();
}

//***************************************************************************
//
//***************************************************************************
//
void CWbemAssocQueryInf::Init()
{
    m_uVersion = 0;
    m_uAnalysisType = 0;
    m_uFeatureMask = 0;
    m_pPath = 0;
    m_pszPath = 0;
    m_pszQueryText = 0;
    m_pszResultClass = 0;
    m_pszAssocClass = 0;
    m_pszRole = 0;
    m_pszResultRole = 0;
    m_pszRequiredQualifier = 0;
    m_pszRequiredAssocQualifier = 0;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemAssocQueryInf::CopyFrom(SWbemAssocQueryInf *pSrc)
{
    m_uVersion = pSrc->m_uVersion;
    m_uAnalysisType = pSrc->m_uAnalysisType;
    m_uFeatureMask = pSrc->m_uFeatureMask;
    m_pszPath = CloneLPWSTR(pSrc->m_pszPath);
    if (CloneFailed(m_pszPath,pSrc->m_pszPath))
        return WBEM_E_OUT_OF_MEMORY;

    if (m_pszPath)
    {
        HRESULT hRes= CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER, IID_IWbemPath, (LPVOID *) &m_pPath);
        if (SUCCEEDED(hRes))
        {
            hRes = m_pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, m_pszPath);
            if (FAILED(hRes))
            {
                m_pPath->Release();
                m_pPath = 0;
                return hRes;
            }
        }
        else
            return hRes;
    }

    m_pszQueryText = CloneLPWSTR(pSrc->m_pszQueryText);
    if (CloneFailed(m_pszQueryText,pSrc->m_pszQueryText))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszResultClass = CloneLPWSTR(pSrc->m_pszResultClass);
    if (CloneFailed(m_pszResultClass,pSrc->m_pszResultClass))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszAssocClass = CloneLPWSTR(pSrc->m_pszAssocClass);
    if (CloneFailed(m_pszAssocClass,pSrc->m_pszAssocClass))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszRole = CloneLPWSTR(pSrc->m_pszRole);
    if (CloneFailed(m_pszRole,pSrc->m_pszRole))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszResultRole = CloneLPWSTR(pSrc->m_pszResultRole);
    if (CloneFailed(m_pszResultRole,pSrc->m_pszResultRole))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszRequiredQualifier = CloneLPWSTR(pSrc->m_pszRequiredQualifier);
    if (CloneFailed(m_pszRequiredQualifier,pSrc->m_pszRequiredQualifier))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszRequiredAssocQualifier = CloneLPWSTR(pSrc->m_pszRequiredAssocQualifier);
    if (CloneFailed(m_pszRequiredAssocQualifier,pSrc->m_pszRequiredAssocQualifier))
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wqllex.cpp ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    WQLLEX.CPP

Abstract:

    WQL DFA Table

History:

    raymcc    14-Sep-97       Created.
    raymcc    06-Oct-97       Single quote support

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <wqllex.h>

#define ST_STRING        29
#define ST_IDENT         34
#define ST_GE            40
#define ST_LE            42
#define ST_NE            45
#define ST_NUMERIC       47
#define ST_REAL          54
#define ST_STRING2       60
#define ST_STRING_ESC    65
#define ST_STRING2_ESC   66
#define ST_SSTRING       67
#define ST_DOT           71
#define ST_BRACKETED_STR 74
#define ST_NEGATIVE_NUM  76
#define ST_POSITIVE_NUM  79
#define ST_HEX_CONST     82

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl WQL_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,                     GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,                     GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,                     GLEX_ACCEPT,
/* 3 */  0x80,   0xfffd,     ST_IDENT,   0,                     GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          WQL_TOK_OPEN_PAREN,    GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,          WQL_TOK_CLOSE_PAREN,   GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,     0,                     GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,          WQL_TOK_ASTERISK,      GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,          WQL_TOK_EQ,            GLEX_ACCEPT,
/* 9 */  L'[',   GLEX_EMPTY, ST_BRACKETED_STR, 0,               GLEX_CONSUME,
/* 10 */  L']',  GLEX_EMPTY, 0,          WQL_TOK_CLOSE_BRACKET, GLEX_ACCEPT,
/* 11 */ L'{',   GLEX_EMPTY, 0,          WQL_TOK_OPEN_BRACE,    GLEX_ACCEPT,
/* 12 */ L'}',   GLEX_EMPTY, 0,          WQL_TOK_CLOSE_BRACE,   GLEX_ACCEPT,


/* 13 */  L'>',  GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 14 */  L'<',  GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 15 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 16 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 17 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 18 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 19 */ L'-',   GLEX_EMPTY, ST_NEGATIVE_NUM, 0,          GLEX_ACCEPT,
/* 20 */ L'\'',  GLEX_EMPTY, ST_SSTRING, 0,               GLEX_CONSUME,

    // Whitespace, newlines, etc.
/* 21 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 22 */ L'\t',  GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 23 */ L'\n',  GLEX_EMPTY, 0,          0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 24 */ L'\r',  GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 25 */ 0,      GLEX_EMPTY, 0,          WQL_TOK_EOF,     GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 26 */ L',',   GLEX_EMPTY, 0,          WQL_TOK_COMMA,   GLEX_ACCEPT,
/* 27 */ L'+',   GLEX_EMPTY, ST_POSITIVE_NUM, 0,          GLEX_CONSUME,

    // Unknown characters

/* 28 */ GLEX_ANY, GLEX_EMPTY, 0,        WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 29 */   L'\n',    GLEX_EMPTY, 0,              WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 30 */   L'\r',    GLEX_EMPTY, 0,              WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 31 */   L'"',     GLEX_EMPTY, 0,              WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 32 */   L'\\',    GLEX_EMPTY, ST_STRING_ESC,  0,                GLEX_CONSUME,
/* 33 */   GLEX_ANY, GLEX_EMPTY, ST_STRING,      0,                GLEX_ACCEPT,

// ST_IDENT

/* 34 */  L'a',   L'z',          ST_IDENT,   0,              GLEX_ACCEPT,
/* 35 */  L'A',   L'Z',          ST_IDENT,   0,              GLEX_ACCEPT,
/* 36 */  L'_',   GLEX_EMPTY,    ST_IDENT,   0,              GLEX_ACCEPT,
/* 37 */  L'0',   L'9',          ST_IDENT,   0,              GLEX_ACCEPT,
/* 38 */  0x80,  0xfffd,         ST_IDENT,   0,              GLEX_ACCEPT,
/* 39 */  GLEX_ANY, GLEX_EMPTY,  0,          WQL_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 40 */  L'=',   GLEX_EMPTY,    0,  WQL_TOK_GE,  GLEX_ACCEPT,
/* 41 */  GLEX_ANY, GLEX_EMPTY,  0,  WQL_TOK_GT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 42 */  L'=',     GLEX_EMPTY,      0,  WQL_TOK_LE,  GLEX_ACCEPT,
/* 43 */  L'>',     GLEX_EMPTY,      0,  WQL_TOK_NE,  GLEX_ACCEPT,
/* 44 */  GLEX_ANY, GLEX_EMPTY,      0,  WQL_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 45 */  L'=',      GLEX_EMPTY,      0,  WQL_TOK_NE,     GLEX_ACCEPT,
/* 46 */  GLEX_ANY,  GLEX_EMPTY,      0,  WQL_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 47 */  L'0',     L'9',         ST_NUMERIC, 0,            GLEX_ACCEPT,
/* 48 */  L'.',     GLEX_EMPTY,   ST_REAL,    0,            GLEX_ACCEPT,
/* 49 */  L'E',     GLEX_EMPTY,   ST_REAL,    0,            GLEX_ACCEPT,
/* 50 */  L'e',     GLEX_EMPTY,   ST_REAL,    0,            GLEX_ACCEPT,
/* 51 */  L'x',     GLEX_EMPTY,   ST_HEX_CONST,  0,            GLEX_ACCEPT,
/* 52 */  L'X',     GLEX_EMPTY,   ST_HEX_CONST,  0,            GLEX_ACCEPT,
/* 53 */  GLEX_ANY, GLEX_EMPTY,   0,          WQL_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 54 */  L'0',     L'9',         ST_REAL, 0,            GLEX_ACCEPT,
/* 55 */  L'E',     GLEX_EMPTY,   ST_REAL, 0,            GLEX_ACCEPT,
/* 56 */  L'e',     GLEX_EMPTY,   ST_REAL, 0,            GLEX_ACCEPT,
/* 57 */  L'+',     GLEX_EMPTY,   ST_REAL, 0,            GLEX_ACCEPT,
/* 58 */  L'-',     GLEX_EMPTY,   ST_REAL, 0,            GLEX_ACCEPT,
/* 59 */  GLEX_ANY, GLEX_EMPTY,   0,       WQL_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 60 */   L'\n',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 61 */   L'\r',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 62 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,   GLEX_CONSUME,
/* 63 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,    GLEX_CONSUME,
/* 64 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2,    0,    GLEX_ACCEPT,

// ST_STRING_ESC
/* 65 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 66 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

// ST_SSTRING (Single quoted strings)
/* 67 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 68 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 69 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 70 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 71 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,

// ST_DOT
/* 72 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 73 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,

// ST_BRACKETED_STRING
/* 74 */   L']',  GLEX_EMPTY, 0,  WQL_TOK_BRACKETED_STRING,  GLEX_CONSUME,
/* 75 */   GLEX_ANY, GLEX_EMPTY, ST_BRACKETED_STR, 0,        GLEX_ACCEPT,

// ST_NEGATIVE_NUM - Strips whitespace after '-'
/* 76 */ L' ', GLEX_EMPTY, ST_NEGATIVE_NUM, 0, GLEX_CONSUME,
/* 77 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 78 */ GLEX_ANY, GLEX_EMPTY, 0, WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_POSITIVE_NUM - Strips whitespace after '+'
/* 79 */ L' ', GLEX_EMPTY, ST_POSITIVE_NUM, 0, GLEX_CONSUME,
/* 80 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 81 */ GLEX_ANY, GLEX_EMPTY, 0, WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_HEX_CONST - Recognizes 0x hex constants
/* 82 */ L'0', L'9',       ST_HEX_CONST, 0, GLEX_ACCEPT,
/* 83 */  GLEX_ANY, GLEX_EMPTY,   0,          WQL_TOK_HEX_CONST,  GLEX_PUSHBACK|GLEX_RETURN,
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wql.h ===
//***************************************************************************
//
//  WQL.H
//
//  WQL 1.1 Parser
//
//  Implements the syntax described in WQL.BNF.
//
//  raymcc  19-Sep-97
//
//***************************************************************************


#ifndef _WQL__H_
#define _WQL__H_

#include <wmiutils.h>
#include <wbemint.h>



class CWbemQueryQualifiedName : public SWbemQueryQualifiedName
{
public:
    void Init();
    void DeleteAll();
    CWbemQueryQualifiedName();
   ~CWbemQueryQualifiedName();
    CWbemQueryQualifiedName(CWbemQueryQualifiedName &Src);
    CWbemQueryQualifiedName& operator =(CWbemQueryQualifiedName &Src);
};

class CWbemRpnQueryToken : public SWbemRpnQueryToken
{
public:
    void Init();
    void DeleteAll();
    CWbemRpnQueryToken();
   ~CWbemRpnQueryToken();
    CWbemRpnQueryToken(CWbemRpnQueryToken &);
    CWbemRpnQueryToken& operator =(CWbemRpnQueryToken&);
};


class CWbemRpnEncodedQuery : public SWbemRpnEncodedQuery
{
public:
    void Init();
    void DeleteAll();
    CWbemRpnEncodedQuery();
   ~CWbemRpnEncodedQuery();
    CWbemRpnEncodedQuery(CWbemRpnEncodedQuery &Src);
    CWbemRpnEncodedQuery& operator=(CWbemRpnEncodedQuery &Src);
};


class CWQLParser
{
    // Data.
    // =====

    CGenLexer    *m_pLexer;
    LPWSTR        m_pszQueryText;
    int           m_nLine;
    wchar_t      *m_pTokenText;
    int           m_nCurrentToken;
    unsigned __int64 m_uFeatures;
    CWStringArray m_aReferencedTables;
    CWStringArray m_aReferencedAliases;
    CFlexArray    m_aSelAliases;
    CFlexArray    m_aSelColumns;

    SWQLNode_QueryRoot      *m_pQueryRoot;
    SWQLNode_WhereClause    *m_pRootWhere;
    SWQLNode_ColumnList     *m_pRootColList;
    SWQLNode_FromClause     *m_pRootFrom;
    SWQLNode_WhereOptions   *m_pRootWhereOptions;

    CWbemRpnEncodedQuery    *m_pRpn;

    // Parse context. In some cases, there is a general
    // shift in state for the whole parser.  Rather than
    // pass this as an inherited attribute to each production,
    // it is much easier to have a general purpose state variable.
    // ============================================================

    enum { Ctx_Default = 0, Ctx_Subselect = 0x1 };

    int         m_nParseContext;

    bool m_bAllowPromptForConstant;

    // Functions.
    // ==========

    BOOL Next();
    BOOL GetIntToken(BOOL *bSigned, BOOL *b64Bit, unsigned __int64 *pVal);

    int QNameToSWQLColRef(
        IN  SWQLQualifiedName *pQName,
        OUT SWQLColRef **pRetVal
        );

    enum { eCtxLeftSide = 1, eCtxRightSide = 2 };

    // Non-terminal productions.
    // =========================
    int select_stmt(OUT SWQLNode_Select **pSelStmt);
    int delete_stmt(OUT SWQLNode_Delete **pDelStmt);
    int update_stmt(OUT SWQLNode_Update **pUpdStmt);
    int insert_stmt(OUT SWQLNode_Insert **pInsStmt);
    int assocquery(OUT SWQLNode_AssocQuery **pAssocQuery);

    int select_type(int & nSelType);
    int col_ref_list(IN OUT SWQLNode_TableRefs *pTblRefs);

    int from_clause(OUT SWQLNode_FromClause **pFrom);
    int where_clause(OUT SWQLNode_WhereClause **pRetWhere);
    int col_ref(OUT SWQLQualifiedName **pRetVal);
    int col_ref_rest(IN OUT SWQLNode_TableRefs *pTblRefs);

    int count_clause(
        OUT SWQLQualifiedName **pQualName
        );

    int wmi_scoped_select(SWQLNode_FromClause *pFC);

    int single_table_decl(OUT SWQLNode_TableRef **pTblRef);
    int sql89_join_entry(
        IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin  );
    int sql92_join_entry(
        IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Join **pJoin
        );

    int sql89_join_list(
        IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin  );
    int on_clause(OUT SWQLNode_OnClause **pOC);
    int rel_expr(OUT SWQLNode_RelExpr **pRelExpr);
    int where_options(OUT SWQLNode_WhereOptions **pWhereOpt0);
    int group_by_clause(OUT SWQLNode_GroupBy **pRetGroupBy);
    int having_clause(OUT SWQLNode_Having **pRetHaving);
    int order_by_clause(OUT SWQLNode_OrderBy **pRetOrderBy);
    int rel_term(OUT SWQLNode_RelExpr **pNewTerm);
    int rel_expr2(
        IN OUT SWQLNode_RelExpr *pLeftSide,
        OUT SWQLNode_RelExpr **pNewRootRE
        );
    int rel_simple_expr(OUT SWQLNode_RelExpr **pRelExpr);
    int rel_term2(
        IN SWQLNode_RelExpr *pLeftSide,
        OUT SWQLNode_RelExpr **pNewRootRE
        );

    int typed_expr(OUT SWQLNode_RelExpr **pRelExpr);
    int typed_subexpr_rh(SWQLTypedExpr *pTE);
    int typed_subexpr(IN SWQLTypedExpr *pTE);
    int typed_const(OUT SWQLTypedConst **pRetVal);

    int datepart_call(
        OUT SWQLNode_Datepart **pRetDP
        );


    int function_call(IN BOOL bLeftSide, IN SWQLTypedExpr *pTE);
    int function_call_parms();
    int func_args();
    int func_arg();

    int rel_op(int &);
    int is_continuator(int &);
    int not_continuator(int &);

    int in_clause(IN SWQLTypedExpr *pTE);
    int subselect_stmt(OUT SWQLNode_Select **pSel);
    int qualified_name(OUT SWQLQualifiedName **pHead);
    int const_list(OUT SWQLConstList **pRetVal);
    int col_list(OUT SWQLNode_ColumnList **pRetColList);

    void Empty();

public:
    enum
    {
        Feature_Refs    = 0x2,             // A WQL 'references of' query
        Feature_Assocs  = 0x4,             // A WQL 'associators of' query
        Feature_Events  = 0x8,             // A WQL event-related query

        Feature_Joins        = 0x10,       // One or more joins occurred

        Feature_Having       = 0x20,       // HAVING used
        Feature_GroupBy      = 0x40,       // GROUP BY used
        Feature_OrderBy      = 0x80,       // ORDER BY used
        Feature_Count        = 0x100,      // COUNT used

        Feature_SelectAll     = 0x400,     // select * from
        Feature_SimpleProject = 0x800,        // no 'where' clause, no join
        Feature_ComplexNames  = 0x1000,       // Names with long qualifications occurred, such
                                              // as array properties and embedded objects.
        Feature_WQL_Extensions = 0x80000000   // WQL-specific extensions

    }   QueryFeatures;

    DWORD GetFeatureFlags();

    BOOL GetReferencedTables(OUT CWStringArray & Tables);
    BOOL GetReferencedAliases(OUT CWStringArray & Aliases);

    const LPWSTR AliasToTable(IN LPWSTR pAlias);

    const CFlexArray *GetSelectedAliases() { return &m_aSelAliases; }
        // Array of ptrs to SWQLNode_TableRef structs; read-only

    const CFlexArray *GetSelectedColumns() { return &m_pRootColList->m_aColumnRefs; }
        // Array of ptrs to SWQLColRef structs; read-only

    // Manual traversal.
    // =================

    SWQLNode_QueryRoot *GetParseRoot() { return m_pQueryRoot; }
    SWQLNode *GetWhereClauseRoot() { return m_pRootWhere; }
    SWQLNode *GetColumnList() { return m_pRootColList; }
    SWQLNode *GetFromClause() { return m_pRootFrom; }
    SWQLNode *GetWhereOptions() { return m_pRootWhereOptions; }

    LPCWSTR GetQueryText() { return m_pszQueryText; }

    // Working
    // =======

    CWQLParser(LPWSTR pszQueryText, CGenLexSource *pSrc);
   ~CWQLParser();

    HRESULT Parse();

    void AllowPromptForConstant(bool bIsAllowed = TRUE) {m_bAllowPromptForConstant = bIsAllowed;}

    // Rpn Helpers.
    // ============

    HRESULT GetRpnSequence(
        OUT SWbemRpnEncodedQuery **pRpn
        );

    HRESULT BuildRpnWhereClause(
        SWQLNode *pRootOfWhere,
        CFlexArray &aRpnReorg
        );

    HRESULT BuildCurrentWhereToken(
        SWQLNode_RelExpr *pSrc,
        SWbemRpnQueryToken *pDest
        );

    HRESULT BuildSelectList(
        CWbemRpnEncodedQuery *pQuery
        );

    HRESULT BuildFromClause(
        CWbemRpnEncodedQuery *pQuery
        );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wqllex.h ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    WQLLEX.H

Abstract:

	WQL DFA Table & Tokenizer

History:

	raymcc    14-Sep-97       Created.

--*/

#ifndef _WQLLEX_H_

#include <genlex.h>

#define WQL_TOK_EOF           0
#define WQL_TOK_ERROR         1

#define WQL_TOK_SELECT                      256
#define WQL_TOK_ALL                         257
#define WQL_TOK_DISTINCT                    258
#define WQL_TOK_OPTIONS_DUMMY               259
#define WQL_TOK_ASTERISK                    260
#define WQL_TOK_COUNT                       261
#define WQL_TOK_COMMA                       262
#define WQL_TOK_OPEN_PAREN                  263
#define WQL_TOK_CLOSE_PAREN                 264
#define WQL_TOK_IDENT                       265
#define WQL_TOK_DOT                         266
#define WQL_TOK_FROM                        267
#define WQL_TOK_AS                          268
#define WQL_TOK_INNER                       269
#define WQL_TOK_FULL                        270
#define WQL_TOK_LEFT                        271
#define WQL_TOK_RIGHT                       272
#define WQL_TOK_OUTER                       273
#define WQL_TOK_JOIN                        274
#define WQL_TOK_ON                          275
#define WQL_TOK_WHERE                       276
#define WQL_TOK_GROUP                       277
#define WQL_TOK_BY                          278
#define WQL_TOK_HAVING                      279
#define WQL_TOK_ORDER                       280
#define WQL_TOK_OR                          281
#define WQL_TOK_AND                         282
#define WQL_TOK_NOT                         283
#define WQL_TOK_LE                          284
#define WQL_TOK_LT                          285
#define WQL_TOK_GE                          286
#define WQL_TOK_GT                          287
#define WQL_TOK_EQ                          288
#define WQL_TOK_NE                          289
#define WQL_TOK_LIKE                        290
#define WQL_TOK_IS                          291
#define WQL_TOK_BEFORE                      292
#define WQL_TOK_AFTER                       293
#define WQL_TOK_BETWEEN                     294
#define WQL_TOK_QSTRING                     295
#define WQL_TOK_INT                         296
#define WQL_TOK_REAL                        297
#define WQL_TOK_CHAR                        298
#define WQL_TOK_NULL                        299
#define WQL_TOK_OPEN_BRACKET                300
#define WQL_TOK_CLOSE_BRACKET               301
#define WQL_TOK_ISA                         302
#define WQL_TOK_A                           303
#define WQL_TOK_DAY                         304
#define WQL_TOK_MONTH                       305
#define WQL_TOK_YEAR                        306
#define WQL_TOK_HOUR                        307
#define WQL_TOK_MINUTE                      308
#define WQL_TOK_SECOND                      309
#define WQL_TOK_MILLISECOND                 310

#define WQL_TOK_UPPER                       311
#define WQL_TOK_LOWER                       312
#define WQL_TOK_DATEPART                    313
#define WQL_TOK_QUALIFIER                   314
#define WQL_TOK_ISNULL                      315
#define WQL_TOK_IN                          316

#define WQL_TOK_NOT_LIKE                    317
#define WQL_TOK_NOT_BEFORE                  318
#define WQL_TOK_NOT_AFTER                   319
#define WQL_TOK_NOT_BETWEEN                 320
#define WQL_TOK_NOT_NULL                    321
#define WQL_TOK_NOT_IN                      322
#define WQL_TOK_NOT_A                       323

#define WQL_TOK_TYPED_EXPR                  324


#define WQL_TOK_IN_SUBSELECT                325
#define WQL_TOK_NOT_IN_SUBSELECT            326
#define WQL_TOK_IN_CONST_LIST               327
#define WQL_TOK_NOT_IN_CONST_LIST           328

#define WQL_TOK_ASC                         329
#define WQL_TOK_DESC                        330
#define WQL_TOK_AGGREGATE                   331
#define WQL_TOK_FIRSTROW                    332

#define WQL_TOK_PROMPT                      333
#define WQL_TOK_UNION                       334

#define WQL_TOK_OPEN_BRACE                  335
#define WQL_TOK_CLOSE_BRACE                 336
#define WQL_TOK_BRACKETED_STRING            337

#define WQL_TOK_INSERT                      338
#define WQL_TOK_UPDATE                      339
#define WQL_TOK_DELETE                      340
#define WQL_TOK_ASSOCIATORS                 341
#define WQL_TOK_REFERENCES                  342
#define WQL_TOK_THIS                        343
#define WQL_TOK_ISNOTA                      344
#define WQL_TOK_HEX_CONST                   345

extern LexEl WQL_LexTable[];




#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wqlnode.h ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    WQLNODE.H

Abstract:

	WMI SQL Parse Node Definitions

History:

	raymcc      29-Sep-97       Created

--*/

#ifndef _WQLNODE_H_
#define _WQLNODE_H_


#define  WQL_FLAG_ALIAS          0x1
#define  WQL_FLAG_TABLE          0x2
#define  WQL_FLAG_ASTERISK       0x4
#define  WQL_FLAG_DISTINCT       0x8
#define  WQL_FLAG_ALL            0x10
#define  WQL_FLAG_COUNT          0x20
#define  WQL_FLAG_CONST          0x40
#define  WQL_FLAG_COLUMN         0x80
#define  WQL_FLAG_COMPLEX_NAME   0x100
#define  WQL_FLAG_FUNCTIONIZED   0x200
#define  WQL_FLAG_ARRAY_REF      0x400
#define  WQL_FLAG_UPPER          0x800
#define  WQL_FLAG_LOWER          0x1000
#define  WQL_FLAG_FIRSTROW       0x2000
#define  WQL_FLAG_CONST_RANGE    0x4000
#define  WQL_FLAG_SORT_ASC       0x8000
#define  WQL_FLAG_SORT_DESC      0x10000
#define  WQL_FLAG_AGGREGATE      0x20000
#define  WQL_FLAG_NULL           0x40000

#define WQL_FLAG_INNER_JOIN         1
#define WQL_FLAG_LEFT_OUTER_JOIN    2
#define WQL_FLAG_RIGHT_OUTER_JOIN   3
#define WQL_FLAG_FULL_OUTER_JOIN    4

#define WQL_TOK_BASE            100

#include <wmiutils.h>


class CWbemAssocQueryInf : public SWbemAssocQueryInf
{
public:
    CWbemAssocQueryInf();
   ~CWbemAssocQueryInf();
    void Empty();
    void Init();
    HRESULT CopyFrom(SWbemAssocQueryInf *pSrc);
};


//***************************************************************************
//
//  SWQLNode
//
//  Base node type for all parser output.
//
//***************************************************************************

struct SWQLNode
{
    DWORD        m_dwNodeType;
    SWQLNode    *m_pLeft;
    SWQLNode    *m_pRight;

    SWQLNode() { m_pLeft = 0; m_pRight = 0; m_dwNodeType = 0; }
    virtual ~SWQLNode() { if (m_pLeft) delete m_pLeft; if (m_pRight) delete m_pRight; }
    virtual void DebugDump() = 0;
};


//***************************************************************************
//
//   SWQLNode_QueryRoot
//
//   This is the root of the parse tree.  The child nodes are for one of
//  SELECT, INSERT, UPDATE, DELETE.
//
//                SWQLQueryRoot
//               /               \
//      SWQLNode_Select         NULL
//   or SWQLNode_Insert
//   or SWQLNode_Delete
//   or SWQLNode_Update
//   or SWQLNode_AssocQuery
//
//***************************************************************************
#define TYPE_SWQLNode_QueryRoot       (WQL_TOK_BASE + 1)

struct SWQLNode_QueryRoot : SWQLNode
{
    enum { eInvalid = 0, eSelect, eInsert, eDelete, eUpdate, eAssoc };
    DWORD m_dwQueryType;

    SWQLNode_QueryRoot() { m_dwNodeType = TYPE_SWQLNode_QueryRoot; m_dwQueryType = 0; }
   ~SWQLNode_QueryRoot() {}
    void DebugDump();
};


//***************************************************************************
//
//  SWQLTypedConst
//
//  Typed constant container (similar to OA VARIANT).
//
//***************************************************************************

union UWQLTypedConst
{
    LPWSTR  m_pString;       // VT_LPWSTR for WQL_TOK_QSTRING and WQL_TOK_PROMPT
    LONG    m_lValue;        // VT_LONG
    double  m_dblValue;      // VT_DOUBLE
    __int64 m_i64Value;     // VT_I8, VT_UI8
    BOOL    m_bValue;        // VT_BOOL, use TRUE/FALSE (not VARIANT_TRUE, VARIANT_FALSE)
};

struct SWQLTypedConst
{
    DWORD m_dwType;             // A VT_ type,  VT_UI4, VT_I8, VT_UI8 all supported
    UWQLTypedConst m_Value;     // One of the union fields
    bool m_bPrompt;             // Only true if token was WQL_TOK_PROMPT

    SWQLTypedConst();
    SWQLTypedConst(SWQLTypedConst &Src) { m_dwType = VT_NULL; *this = Src; }
    SWQLTypedConst & operator = (SWQLTypedConst &Src);
   ~SWQLTypedConst() { Empty(); }
    void Empty();
    void DebugDump();
};

struct SWQLConstList
{
    CFlexArray m_aValues;       // ptrs to SWQLTypedConst

    SWQLConstList() {}
    SWQLConstList(SWQLConstList &Src) { *this = Src; }
    SWQLConstList & operator = (SWQLConstList & Src);
   ~SWQLConstList() { Empty(); }
    int Add(SWQLTypedConst *pTC) { return m_aValues.Add(pTC); }
    void Empty();
};



struct SWQLQualifiedNameField
{
    LPWSTR  m_pName;         // Name
    BOOL    m_bArrayRef;     // TRUE if this is an array reference
    DWORD   m_dwArrayIndex;  // If <m_bArrayRef == TRUE> this is the array index

    SWQLQualifiedNameField() { m_pName = 0; m_bArrayRef = 0; m_dwArrayIndex = 0; }
    SWQLQualifiedNameField(SWQLQualifiedNameField &Src) { m_pName = 0; *this = Src; }
    SWQLQualifiedNameField & operator = (SWQLQualifiedNameField &Src);

   ~SWQLQualifiedNameField() { Empty(); }
private:
    void Empty() { delete [] m_pName; m_pName = 0; }
};

struct SWQLQualifiedName
{
    CFlexArray m_aFields;       // [0] =  left most, last entry is column

    SWQLQualifiedName() {}
    SWQLQualifiedName(SWQLQualifiedName &Src) { *this = Src; }
    SWQLQualifiedName & operator = (SWQLQualifiedName &Src);
   ~SWQLQualifiedName() { Empty(); }

    int GetNumNames() { return m_aFields.Size(); }

    const LPWSTR GetName(int nIndex)
    {
        return (LPWSTR) ((SWQLQualifiedNameField*) m_aFields[nIndex])->m_pName;
    }

    int Add(SWQLQualifiedNameField *pQN) { return m_aFields.Add(pQN); }
    void Empty()
    {
        for (int i = 0; i < m_aFields.Size(); i++)
	     delete (SWQLQualifiedNameField *) m_aFields[i];
    }
};




//***************************************************************************
//
//   SWQLNode_Select
//
//   This is the root of the parse tree or the root of a subselect.
//
//                SWQLNode_Select
//               /               \
//      SWQLNode_TableRefs     SWQLNode_WhereClause
//     /                \      /                   \
//    x                  x    x                     x
//
//***************************************************************************

#define TYPE_SWQLNode_Select        (WQL_TOK_BASE + 2)

struct SWQLNode_Select : SWQLNode
{
    // Left  Node is of type SWQLNode_TableRefs
    // Right Node is of type SWQLNode_WhereClause

    int m_nStPos;
    int m_nEndPos;

    SWQLNode_Select() : m_nStPos(-1), m_nEndPos(-1) { m_dwNodeType = TYPE_SWQLNode_Select; }
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_TableRefs
//
//  This contains everything prior to the WHERE clause: the target
//  column list and the FROM clause.
//
//  Also contains the SELECT type, i.e., ALL vs. DISTINCT vs. COUNT.
//
//                SWQLNode_TableRefs
//               /               \
//      SWQLNode_ColumnList     SWQLNode_FromClause
//
//  In all cases, SWQLNode_ColumnList is present.  Note that if the
//  user did a "select *...", then the SWQLNode_ColumnList will only
//  have a single column in it clearly marked as an asterisk.  If
//  a "select count(...) " was done, then m_nSelectType is set to
//  WQL_FLAG_COUNT and the SWQLNode_ColumnList will have a single
//  column in it, whether an * or a qualified name.
//
//***************************************************************************

#define TYPE_SWQLNode_TableRefs      (WQL_TOK_BASE + 3)

struct SWQLNode_TableRefs : SWQLNode
{
    // Left  Node is SWQLNode_ColumnList
    // Right Node is SWQLNode_FromClause

    int m_nSelectType;       // WQL_FLAG_ALL means ALL was used.
                             // WQL_FLAG_DISTINCT means DISTINCT was used.
                             // WQL_FLAG_COUNT means COUNT was used.

    SWQLNode_TableRefs()
        { m_nSelectType = WQL_FLAG_ALL;
          m_dwNodeType = TYPE_SWQLNode_TableRefs;
        }

   ~SWQLNode_TableRefs() {}
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_ColumnList
//
//  This contains the selected list of columns.
//
//                SWQLNode_ColumnList
//               /                 \
//              NULL               NULL
//
//***************************************************************************

#define TYPE_SWQLNode_ColumnList   (WQL_TOK_BASE + 4)

struct SWQLNode_ColumnList : SWQLNode
{
    // Left  Node is NULL
    // Right Node is NULL

    CFlexArray m_aColumnRefs ;   // Pointers to SWQLColRef entries.

    SWQLNode_ColumnList() { m_dwNodeType = TYPE_SWQLNode_ColumnList; }
   ~SWQLNode_ColumnList() { Empty(); }
    void Empty();
    void DebugDump();
};


struct SWQLColRef
{
    LPWSTR m_pColName;      // The column name or "*" or NULL
    LPWSTR m_pTableRef;     // The table/alias name or NULL if there is none
    DWORD  m_dwArrayIndex;
    DWORD  m_dwFlags;       // WQL_FLAG_TABLE bit set if m_pTableRef
                            //   is a table name
                            // WQL_FLAG_ALIAS bit set if m_pTableRef
                            //   is a table alias
                            // WQL_FLAG_ASTERISK bit set if m_pColName is
                            //   * (this is faster than to check than a
                            //   string compare on <m_pColName> for "*".
                            // WQL_FLAG_NULL if the column name was "NULL"
                            // WQL_FLAG_FUNCTIONIZED is set if the column
                            //    is wrapped in a function call.
                            //    The function bits WQL_FLAG_UPPER or
                            //    WQL_FLAG_LOWER will be set.
                            // WQL_FLAG_ARRAY_REF is set if the column
                            //    is an array column, in which case
                            //    m_dwArrayIndex is set to the array offset.
                            // WQL_FLAG_COMPLEX_NAME is set if the name
                            //  is qualified in a deeply nested way,
                            //  which requires examination of the <QName>
                            //  object.  In this case <m_pColName> is
                            //  set to the last name, but m_pTableRef
                            //  is left blank.
                            // WQL_FLAG_SORT_ASC to sort ascending (Order by only)
                            // WQL_FLAG_SORT_DESC to sort descending (Order by only)

    SWQLQualifiedName *m_pQName;    // The full qualified name

    SWQLColRef() { m_pColName = NULL; m_pTableRef = 0;
        m_dwFlags = 0; m_dwArrayIndex = 0; m_pQName = 0;
        }

   ~SWQLColRef() { delete [] m_pColName; delete [] m_pTableRef; delete m_pQName; }
    //
    // we are inlining to remove a compiler dependency in wbemcomn
    //
    void DebugDump()
    {
	    printf("  ---SWQLColRef---\n");
	    printf("  Col Name    = %S\n",   m_pColName);
	    printf("  Table       = %S\n",   m_pTableRef);
	    printf("  Array Index = %d\n", m_dwArrayIndex);
	    printf("  Flags       = 0x%X ", m_dwFlags);

	    if (m_dwFlags & WQL_FLAG_TABLE)
	        printf("WQL_FLAG_TABLE ");
	    if (m_dwFlags & WQL_FLAG_COLUMN)
	        printf("WQL_FLAG_COLUMN ");
	    if (m_dwFlags & WQL_FLAG_ASTERISK)
	        printf("WQL_FLAG_ASTERISK ");
	    if (m_dwFlags & WQL_FLAG_NULL)
	        printf("WQL_FLAG_NULL ");
	    if (m_dwFlags & WQL_FLAG_FUNCTIONIZED)
	        printf("WQL_FLAG_FUNCTIONIZED ");
	    if (m_dwFlags & WQL_FLAG_COMPLEX_NAME)
	        printf("WQL_FLAG_COMPLEX_NAME ");
	    if (m_dwFlags & WQL_FLAG_ARRAY_REF)
	        printf(" WQL_FLAG_ARRAY_REF");
	    if (m_dwFlags & WQL_FLAG_UPPER)
	        printf(" WQL_FLAG_UPPER");
	    if (m_dwFlags & WQL_FLAG_LOWER)
	        printf(" WQL_FLAG_LOWER");
	    if (m_dwFlags & WQL_FLAG_SORT_ASC)
	        printf(" WQL_FLAG_SORT_ASC");
	    if (m_dwFlags & WQL_FLAG_SORT_DESC)
	        printf(" WQL_FLAG_SORT_DESC");

	    printf("\n");

	    printf("  ---\n\n");
	}    	
    	
};



//***************************************************************************
//
//   SWQLNode_FromClause
//
//   The subtree containing the tables selected from and any joins.
//
//                SWQLNode_FromClause
//               /                   \
//             SWQLNode_TableRef      SWQLNode_WmiScopedSelect
//          or SWQLNode_Join
//          or SWQLNode_Sql89Join
//
//  Note that left and right nodes are mutually exclusive.  Either
//  the left side is used for traditional SQL or the right side is
//  used for the WMI scoped select.
//
//***************************************************************************

#define TYPE_SWQLNode_FromClause  (WQL_TOK_BASE + 5)

struct SWQLNode_FromClause : SWQLNode
{
    // Left is SWQLNode_TableRef or SWQLNode_Join
    // Right is NULL

    SWQLNode_FromClause() { m_dwNodeType = TYPE_SWQLNode_FromClause; }
   ~SWQLNode_FromClause() {}
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_WmiScopedSelect
//
//                SWQLNode_WmiScopedSelect
//               /                   \
//             NULL                  NULL
//
//
//   Contains a special-case selection for WMI v2.  The syntax is
//
//      FROM '['<object path>']' <class-list>
//
//   ...where <class-list> is either a single class or a curly-bracket-delimited
//   list of classes, separated by commas:
//
//          FROM [scope.p1=2] MyClass
//          FROM [scope.p1=2] {MyClass}
//          FROM [scope.p1=2] {MyClass, MyClass2}
//
//
//***************************************************************************


#define TYPE_SWQLNode_WmiScopedSelect (WQL_TOK_BASE + 6)

struct SWQLNode_WmiScopedSelect : SWQLNode
{
    LPWSTR m_pszScope;
    CFlexArray m_aTables;

    SWQLNode_WmiScopedSelect()
        { m_dwNodeType = TYPE_SWQLNode_FromClause;
          m_pszScope = 0;
        }

   ~SWQLNode_WmiScopedSelect()
        {
            for (int i = 0; i < m_aTables.Size(); i++)
                delete LPWSTR(m_aTables[i]);
            delete m_pszScope;
        }

    void DebugDump();
};


//***************************************************************************
//
//  SWQLNode_Sql89Join
//
//  A subtree which expresses a SQL-89 join.
//
//                SWQLNode_Sql89Join
//               /             \
//             NULL             NULL
//
//***************************************************************************

#define TYPE_SWQLNode_Sql89Join     (WQL_TOK_BASE + 7)

struct SWQLNode_Sql89Join : SWQLNode
{
    CFlexArray m_aValues;           // Array of pointers to SWQLNode_TableRef
                                    // objects

    SWQLNode_Sql89Join() { m_dwNodeType = TYPE_SWQLNode_Sql89Join; }
    ~SWQLNode_Sql89Join() {Empty();};
    void DebugDump();
    void Empty();
};



//***************************************************************************
//
//  SWQLNode_Join
//
//  A subtree which expresses a join.
//
//                SWQLNode_Join
//               /              \
//       SWQLNode_JoinPair       SWQLNode_OnClause or NULL.
//
//***************************************************************************

#define TYPE_SWQLNode_Join  (WQL_TOK_BASE + 8)

struct SWQLNode_Join : SWQLNode
{
    // Left ptr is SWQLNode_JoinPair
    // Right ptr is ON clause.  If NULL, there is no ON clause
    // and the JOIN was a SQL-89 style join with the join condition
    // present in the WHERE clause.

    DWORD m_dwJoinType;
            // One of WQL_FLAG_INNER_JOIN, WQL_FLAG_LEFT_OUTER_JOIN,
            // WQL_FLAG_RIGHT_OUTER_JOIN or WQL_FLAG_FULL_OUTER_JOIN
    DWORD m_dwFlags;
        // Contains WQL_FLAG_FIRSTROW if used

    SWQLNode_Join() { m_dwNodeType = TYPE_SWQLNode_Join; m_dwJoinType = m_dwFlags = 0; }
   ~SWQLNode_Join() {}
    void DebugDump();
};


//***************************************************************************
//
//  SWQLNode_JoinPair
//
//                SWQLNode_JoinPair
//               /                 \
//        <SWQLNode_Join or SWQLNode_TableRef>
//
//***************************************************************************
#define TYPE_SWQLNode_JoinPair   (WQL_TOK_BASE + 9)

struct SWQLNode_JoinPair : SWQLNode
{
    // Left ptr is SWQLNode_Join or SWQLNode_TableRef
    // Right ptr is SWQLNodeNode_Join or SWQL_NodeTableRef

    SWQLNode_JoinPair() { m_dwNodeType = TYPE_SWQLNode_JoinPair; }
   ~SWQLNode_JoinPair() {}

    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_TableRef
//
//  A node representing a table name and its alias, if any.
//
//                SWQLNode_TableRef
//               /                 \
//             NULL               NULL
//
//***************************************************************************

#define TYPE_SWQLNode_TableRef  (WQL_TOK_BASE + 10)

struct SWQLNode_TableRef : SWQLNode
{
    LPWSTR m_pTableName;        // The table
    LPWSTR m_pAlias;            // Table alias. NULL if not used.

    SWQLNode_TableRef() { m_pTableName = 0; m_pAlias = 0; m_dwNodeType = TYPE_SWQLNode_TableRef; }
    ~SWQLNode_TableRef() { delete [] m_pTableName; delete [] m_pAlias; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_OnClause
//
//                SWQLNode_OnClause
//               /                 \
//        <SWQLNode_RelExpr>        NULL
//
//***************************************************************************
#define TYPE_SWQLNode_OnClause   (WQL_TOK_BASE + 11)

struct SWQLNode_OnClause : SWQLNode
{
    // Left ptr is <SWQLNode_RelExpr> which contains the ON clause.
    // Right ptr is always NULL.

    SWQLNode_OnClause() { m_dwNodeType = TYPE_SWQLNode_OnClause; }
   ~SWQLNode_OnClause() {}
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_WhereClause
//
//                SWQLNode_WhereClause
//               /                 \
//        SWQLNode_RelExpr         SWQLNode_WhereOptions or NULL
//        or
//        NULL if no conditions
//
//***************************************************************************

#define TYPE_SWQLNode_WhereClause  (WQL_TOK_BASE + 12)

struct SWQLNode_WhereClause : SWQLNode
{
    // Left ptr is SWQLNode_RelExpr.
    // Right ptr is SQLNode_QueryOptions or NULL if none

    SWQLNode_WhereClause() { m_dwNodeType = TYPE_SWQLNode_WhereClause; }
   ~SWQLNode_WhereClause() {}

    void DebugDump();
};

//***************************************************************************
//
//  struct SWQLTypedExpr
//
//  This represents a typed subexpression in a where clause:
//
//      mycol < 2
//      33 <= tbl1.col2
//      tbl3.col4 = tbl4.col5
//      ...etc.
//
//***************************************************************************

struct SWQLTypedExpr
{
    LPWSTR         m_pTableRef;         // For qualified column names,
                                        //   NULL if not used
    LPWSTR         m_pColRef;           // Column name

    DWORD          m_dwRelOperator;     // The operator used: WQL_TOK_LE,
                                        //  WQL_TOK_GE, WQL_TOK_LIKE etc.
                                        //  WQL_TOK_IN_CONST_LIST
                                        //  WQL_TOK_NOT_IN_CONST_LIST
                                        //  WQL_TOK_IN_SUBSELECT
                                        //  WQL_TOK_NOT_IN_SUBSELECT

    SWQLTypedConst *m_pConstValue;     // A const value
    SWQLTypedConst *m_pConstValue2;    // The other const value used with BETWEEN

    LPWSTR         m_pJoinTableRef;     // The joined table name or its alias,
                                        //   NULL if not used
    LPWSTR         m_pJoinColRef;       // The joined column name

    LPWSTR         m_pIntrinsicFuncOnColRef;
    LPWSTR         m_pIntrinsicFuncOnJoinColRef;
    LPWSTR         m_pIntrinsicFuncOnConstValue;

    SWQLNode      *m_pLeftFunction;         // More detail for DATEPART, etc.
    SWQLNode      *m_pRightFunction;        // More detail for DATEPART, etc.

    DWORD          m_dwLeftArrayIndex;
    DWORD          m_dwRightArrayIndex;

    SWQLQualifiedName *m_pQNRight;
    SWQLQualifiedName *m_pQNLeft;

    DWORD          m_dwLeftFlags;
    DWORD          m_dwRightFlags;
        // Each of the above to Flags shows the expression layout on each side
        // of the operator.
        //  WQL_FLAG_CONST        = A typed constant was used
        //  WQL_FLAG_COLUMN       = Column field was used
        //  WQL_FLAG_TABLE        = Table/Alias was used
        //  WQL_FLAG_COMPLEX      = Complex qualified name and/or array was used
        //  WQL_FLAG_FUNCTIONIZED = Function was applied over the const or col.


    // For IN and NOT IN clauses.
    // ==========================

    SWQLNode       *m_pSubSelect;

    SWQLConstList  *m_pConstList;   // For IN clause with constant-list

    /*
    (1) If a const is tested against a column, then <m_pConstValue> will
        be used to represent it, and the table+col referenced will be in
        <m_pTableRef> and <m_pColRef>.

    (2) If a join occurs, then <m_pConstValue> will be NULL.

    (3) Intrinsic functions (primarily UPPER() and LOWER()) can be applied
        to the column references  or the constant.  The function names will
        be placed in the <m_pIntrinsic...> pointers when applied.

    (4) If <m_dwRelOperator> is WQL_TOK_IN_CONST_LIST or WQL_TOK_NOT_IN_CONST_LIST
        then <m_aConstSet> is an array of pointers to SWQLTypedConst structs representing
        the set of constants that the referenced column must intersect with.

    (5) If <m_dwRelOperator> is WQL_TOK_IN_SUBSELECT or WQL_TOK_NOT_IN_SUBSELECT
        then m_pSubSelect is a pointer to an embedded subselect tree in the form
        of a SWQLNode_Select struct, beginning the root of an entirely new select
        statement.
    */

    SWQLTypedExpr();
   ~SWQLTypedExpr() { Empty(); }
    void DebugDump();
    void Empty();
};



//***************************************************************************
//
//  SWQLNode_RelExpr
//
//                SWQLNode_RelExpr
//               /                \
//        SWQLNode_RelExpr        SWQLNode_RelExpr
//        or NULL                 or NULL
//
//***************************************************************************

#define TYPE_SWQLNode_RelExpr   (WQL_TOK_BASE + 13)

struct SWQLNode_RelExpr : SWQLNode
{
    DWORD m_dwExprType;  // WQL_TOK_OR
                         // WQL_TOK_AND
                         // WQL_TOK_NOT
                         // WQL_TOK_TYPED_EXPR

    SWQLTypedExpr *m_pTypedExpr;

    /*
    (1) If the <m_dwExprType> is WQL_TOK_AND or WQL_TOK_OR, then each of
        the two subnodes are themselves SWQLNode_RelExpr nodes and
        <m_pTypedExpr> points to NULL.

    (2) If <m_dwExprType> is WQL_TOK_NOT, then <m_pLeft> points to a
        SWQLNode_RelExpr containing the subclause to which to apply the NOT
        operation and <m_pRight> points to NULL.

    (3) If <m_dwExprType> is WQL_TOK_TYPED_EXPR, then <m_pLeft> and
        <m_pRight> both point to NULL, and <m_pTypedExpr> contains a typed
        relational subexpression.

    (4) Parentheses have been removed and are implied by the nesting.
    */

    SWQLNode_RelExpr() { m_dwNodeType = TYPE_SWQLNode_RelExpr; m_pTypedExpr = 0; m_dwExprType = 0; }
   ~SWQLNode_RelExpr() { delete m_pTypedExpr; }
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_WhereOptions
//
//                SWQLNode_WhereOptions
//               /                 \
//           SWQLNode_GroupBy      SWQLNode_OrderBy
//
//***************************************************************************

#define TYPE_SWQLNode_WhereOptions (WQL_TOK_BASE + 14)

struct SWQLNode_WhereOptions : SWQLNode
{
    // left ptr is SWQLNode_GroupBy, or NULL if not used
    // right ptr is SWQLNode_OrderBy, or NULL if not used

    SWQLNode_WhereOptions() { m_dwNodeType = TYPE_SWQLNode_WhereOptions; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_GroupBy
//
//                SWQLNode_GroupBy
//               /                \
//        SWQLNode_ColumnList    SWQLNode_Having
//                               or NULL
//
//***************************************************************************

#define TYPE_SWQLNode_GroupBy (WQL_TOK_BASE + 15)

struct SWQLNode_GroupBy : SWQLNode
{
    // left ptr is SWQLNode_ColumnList of columns to group by
    // right ptr is Having clause, if any

    SWQLNode_GroupBy() { m_dwNodeType = TYPE_SWQLNode_GroupBy; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_Having
//
//                SWQLNode_Having
//               /               \
//           SWQLNode_RelExpr    NULL
//
//***************************************************************************

#define TYPE_SWQLNode_Having (WQL_TOK_BASE + 16)

struct SWQLNode_Having : SWQLNode
{
    // left ptr is SQLNode_RelExpr pointing to HAVING expressions
    // right ptr is NULL

    SWQLNode_Having() { m_dwNodeType = TYPE_SWQLNode_Having; }
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_OrderBy
//
//                SWQLNode_OrderBy
//               /                \
//      SWQLNode_ColumnList       NULL
//
//***************************************************************************

#define TYPE_SWQLNode_OrderBy (WQL_TOK_BASE + 17)

struct SWQLNode_OrderBy : SWQLNode
{
    // left ptr is SWQLNode_ColumnList
    // right ptr is NULL
    SWQLNode_OrderBy() { m_dwNodeType = TYPE_SWQLNode_OrderBy; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_Datepart
//
//  Contains a datepart call.
//
//***************************************************************************
#define TYPE_SWQLNode_Datepart  (WQL_TOK_BASE + 18)

struct SWQLNode_Datepart : SWQLNode
{
    int m_nDatepart;        // One of WQL_TOK_YEAR, WQL_TOK_MONTH,
                            // WQL_TOK_DAY, WQL_TOK_HOUR, WQL_TOK_MINUTE
                            // WQL_TOK_SECOND

    SWQLColRef *m_pColRef;  // The column to which DATEPART applies

    SWQLNode_Datepart() { m_dwNodeType = TYPE_SWQLNode_Datepart; m_nDatepart = 0; }
   ~SWQLNode_Datepart() { delete m_pColRef; }

    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_Delete
//
//   This is the root of a parse tree for delete.
//
//                SWQLNode_Delete
//               /               \
//      SWQLNode_TableRef   vSWQLNode_WhereClause
//     /                \
//    x                  x
//
//***************************************************************************

#define TYPE_SWQLNode_Delete        (WQL_TOK_BASE + 19)

struct SWQLNode_Delete : SWQLNode
{
    // Left  Node is of type SWQLNode_TableRef
    // Right Node is of type SWQLNode_WhereClause

    SWQLNode_Delete() { m_dwNodeType = TYPE_SWQLNode_Delete; }
   ~SWQLNode_Delete();
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_Insert
//
//   This is the root of an INSERT
//
//                SWQLNode_Delete
//               /               \
//      SWQLNode_TableRef       SWQLNode_InsertValues
//     /                \
//    x                  x
//
//***************************************************************************

#define TYPE_SWQLNode_Insert        (WQL_TOK_BASE + 20)

struct SWQLNode_Insert : SWQLNode
{
    SWQLNode_Insert() { m_dwNodeType = TYPE_SWQLNode_Insert; }
   ~SWQLNode_Insert();
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_Update
//
//   This is the root of an INSERT
//
//                SWQLNode_Update
//               /               \
//      SWQLNode_SetClause      SWQLNode_WhereClause
//
//***************************************************************************

#define TYPE_SWQLNode_Update        (WQL_TOK_BASE + 21)

struct SWQLNode_Update : SWQLNode
{
    SWQLNode_Update() { m_dwNodeType = TYPE_SWQLNode_Update; }
   ~SWQLNode_Update();
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_AssocQuery
//
//                SWQLNode_AssocQuery
//               /               \
//             NULL             NULL
//
//***************************************************************************

#define TYPE_SWQLNode_AssocQuery        (WQL_TOK_BASE + 22)

struct SWQLNode_AssocQuery : SWQLNode
{
    CWbemAssocQueryInf *m_pAQInf;

    SWQLNode_AssocQuery() { m_pAQInf = 0; m_dwNodeType = TYPE_SWQLNode_AssocQuery; }
    ~SWQLNode_AssocQuery() { delete m_pAQInf; }
    void DebugDump();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wqlscan.cpp ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    WQLSCAN.CPP

Abstract:

    WQL Prefix Scanner

    This module implements a specially cased shift-reduce parser to
    parse out selected columns, JOINed tables and aliases, while ignoring
    the rest of the query.

History:

    raymcc    17-Oct-97       SMS extensions.

--*/


#include "precomp.h"
#include <stdio.h>

#include <flexarry.h>
#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>

#include <helpers.h>

#define trace(x) printf x


class CTokenArray : public CFlexArray
{
public:
    ~CTokenArray() { Empty(); }
    void Empty()
    {
        for (int i = 0; i < Size(); i++) delete PWSLexToken(GetAt(i));
        CFlexArray::Empty();
    }
};

//***************************************************************************
//
//  CWQLScanner::CWQLScanner
//
//  Constructor
//
//  Parameters:
//  <pSrc>          A source from which to lex from.
//
//***************************************************************************

CWQLScanner::CWQLScanner(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(WQL_LexTable, pSrc);
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;
    m_bCount = FALSE;
}

//***************************************************************************
//
//  CWQLScanner::~CWQLScanner
//
//***************************************************************************


CWQLScanner::~CWQLScanner()
{
    delete m_pLexer;

    ClearTokens();
    ClearTableRefs();
    ClearPropRefs();
}

//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedAliases(CWStringArray &aAliases)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aAliases.Add(pTRef->m_pszAlias);
    }
    return TRUE;
}
//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedTables(CWStringArray &aClasses)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aClasses.Add(pTRef->m_pszTable);
    }
    return TRUE;
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearTokens()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
        delete (WSLexToken *) m_aTokens[i];
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearPropRefs()
{
    for (int i = 0; i < m_aPropRefs.Size(); i++)
        delete (SWQLColRef *) m_aPropRefs[i];
}

//***************************************************************************
//
//***************************************************************************

void CWQLScanner::ClearTableRefs()
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
        delete (WSTableRef *) m_aTableRefs[i];
    m_aTableRefs.Empty();
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

struct WqlKeyword
{
    LPWSTR m_pKeyword;
    int    m_nTokenCode;
};

static WqlKeyword KeyWords[] =      // Keep this alphabetized for binary search
{
    L"ALL",      WQL_TOK_ALL,
    L"AND",      WQL_TOK_AND,
    L"AS",       WQL_TOK_AS,
    L"BETWEEN",  WQL_TOK_BETWEEN,
    L"BY",       WQL_TOK_BY,
    L"COUNT",    WQL_TOK_COUNT,
    L"DATEPART", WQL_TOK_DATEPART,
    L"DISTINCT", WQL_TOK_DISTINCT,
    L"FIRSTROW", WQL_TOK_FIRSTROW,
    L"FROM",     WQL_TOK_FROM,
    L"FULL",     WQL_TOK_FULL,
    L"GROUP",    WQL_TOK_GROUP,
    L"HAVING",   WQL_TOK_HAVING,
    L"IN",       WQL_TOK_IN,
    L"INNER",    WQL_TOK_INNER,
    L"IS",       WQL_TOK_IS,
    L"ISA",      WQL_TOK_ISA,
    L"ISNULL",   WQL_TOK_ISNULL,
    L"JOIN",     WQL_TOK_JOIN,
    L"LEFT",     WQL_TOK_LEFT,
    L"LIKE",     WQL_TOK_LIKE,
    L"LOWER",    WQL_TOK_LOWER,
    L"NOT",      WQL_TOK_NOT,
    L"NULL",     WQL_TOK_NULL,
    L"ON",       WQL_TOK_ON,
    L"OR",       WQL_TOK_OR,
    L"ORDER",    WQL_TOK_ORDER,
    L"OUTER",    WQL_TOK_OUTER,
    L"QUALIFIER", WQL_TOK_QUALIFIER,
    L"RIGHT",    WQL_TOK_RIGHT,
    L"SELECT",   WQL_TOK_SELECT,
    L"UNION",    WQL_TOK_UNION,
    L"UPPER",    WQL_TOK_UPPER,
    L"WHERE",    WQL_TOK_WHERE

};

const int NumKeywords = sizeof(KeyWords)/sizeof(WqlKeyword);

BOOL CWQLScanner::Next()
{
    if (!m_pLexer)
        return FALSE;

    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == WQL_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == WQL_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check. Do a binary search
    // on the keyword table.
    // =================================

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        int l = 0, u = NumKeywords - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) < 0)
                u = m - 1;
            else if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) > 0)
                l = m + 1;
            else        // Match
            {
                m_nCurrentToken = KeyWords[m].m_nTokenCode;
                break;
            }
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  CWQLScanner::ExtractNext
//
//***************************************************************************

PWSLexToken CWQLScanner::ExtractNext()
{
    if (m_aTokens.Size() == 0)
        return NULL;

    PWSLexToken pTok = PWSLexToken(m_aTokens[0]);
    m_aTokens.RemoveAt(0);
    return pTok;
}

//***************************************************************************
//
//  CWQLScanner::Pushback
//
//***************************************************************************

void CWQLScanner::Pushback(PWSLexToken pPushbackTok)
{
    m_aTokens.InsertAt(0, pPushbackTok);
}

//***************************************************************************
//
//  Shift-reduce parser entry.
//
//***************************************************************************

int CWQLScanner::Parse()
{
    int nRes = SYNTAX_ERROR;
    if (m_pLexer == NULL)
        return FAILED;

    m_pLexer->Reset();

    if (!Next())
        return LEXICAL_ERROR;


    // Completely tokenize the entire query and build a parse-stack.
    // =============================================================

    if (m_nCurrentToken == WQL_TOK_SELECT)
    {
        while (1)
        {
            WSLexToken *pTok = new WSLexToken;
            if (!pTok)
                return FAILED;

            pTok->m_nToken = m_nCurrentToken;
            pTok->m_pszTokenText = Macro_CloneLPWSTR(m_pTokenText);

            if (!pTok->m_pszTokenText)
                return FAILED;

            m_aTokens.Add(pTok);

            if (m_nCurrentToken == WQL_TOK_EOF)
                break;

            if (!Next())
                return LEXICAL_ERROR;
        }
    }
    else
        return SYNTAX_ERROR;

    // Reduce by extracting the select type keywords if possible.
    // ==========================================================

    nRes = ExtractSelectType();
    if (nRes)
        return nRes;

    // Eliminate all tokens from WHERE onwards.
    // ========================================

    StripWhereClause();

    // Reduce by extracting the select list.
    // =====================================

    if (!m_bCount)
    {
        nRes = SelectList();
        if (nRes != 0)
            return nRes;
    }
    else
    {
        // Strip everything until the FROM keyword is encountered.
        // =======================================================

        WSLexToken *pTok = ExtractNext();


        while (pTok)
        {
            if (pTok->m_nToken == WQL_TOK_FROM)
            {
                Pushback(pTok);
                break;
            }
            // Bug #46728: the count(*) clause
            // can be the only element of the select clause.

            else if (!wcscmp(pTok->m_pszTokenText, L","))
            {
                delete pTok;
                return SYNTAX_ERROR;
            }

            delete pTok;
            pTok = ExtractNext();
        }
        if (pTok == 0)
            return SYNTAX_ERROR;
    }

    // Extract tables/aliases from JOIN clauses.
    // =========================================

    if (ReduceSql89Joins() != TRUE)
    {
        ClearTableRefs();
        if (ReduceSql92Joins() != TRUE)
            return SYNTAX_ERROR;
    }


    // Post process select clause to determine if
    // columns are tables or aliases.
    // ==========================================
    for (int i = 0; i < m_aPropRefs.Size(); i++)
    {
        SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
        if (pCRef->m_pTableRef != 0)
        {
            LPWSTR pTbl = AliasToTable(pCRef->m_pTableRef);
            if (pTbl == 0)
                continue;

            if (_wcsicmp(pTbl, pCRef->m_pTableRef) == 0)
                pCRef->m_dwFlags |= WQL_FLAG_TABLE;
            else
                pCRef->m_dwFlags |= WQL_FLAG_ALIAS;
        }
    }


    if (m_aTableRefs.Size() == 0)
        return SYNTAX_ERROR;


    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::StripWhereClause
//
//  If present, removes the WHERE or ORDER BY clause.  Because
//  of SQL Syntax, stripping the first of {ORDER BY, WHERE} will automatically
//  get rid of the other.
//
//***************************************************************************
BOOL CWQLScanner::StripWhereClause()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        WSLexToken *pCurrent = (WSLexToken *) m_aTokens[i];

        // If a WHERE token is found, we have something to strip.
        // ======================================================

        if (pCurrent->m_nToken == WQL_TOK_WHERE ||
            pCurrent->m_nToken == WQL_TOK_ORDER)
        {
            int nNumTokensToRemove = m_aTokens.Size() - i - 1;
            for (int i2 = 0; i2 < nNumTokensToRemove; i2++)
            {
                delete PWSLexToken(m_aTokens[i]);
                m_aTokens.RemoveAt(i);
            }
            return TRUE;
        }
    }

    return FALSE;
}


//***************************************************************************
//
//  CWQLScanner::ExtractSelectType
//
//  Examines the prefix to reduce the query by eliminating the SELECT
//  and select-type keywords, such as ALL, DISTINCT, FIRSTROW, COUNT
//
//  If COUNT is used, move past the open-close parentheses.
//
//***************************************************************************

int CWQLScanner::ExtractSelectType()
{
    // Verify that SELECT is the first token.
    // ======================================

    WSLexToken *pFront = ExtractNext();

    if (pFront == 0 || pFront->m_nToken == WQL_TOK_EOF)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    if (pFront->m_nToken != WQL_TOK_SELECT)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    delete pFront;

    // Check for possible select-type and extract it.
    // ==============================================

    pFront = ExtractNext();
    if (pFront == 0)
        return SYNTAX_ERROR;

    if (pFront->m_nToken == WQL_TOK_COUNT)
    {
        delete pFront;
        m_bCount = TRUE;
    }
    else if (pFront->m_nToken == WQL_TOK_ALL ||
        pFront->m_nToken == WQL_TOK_DISTINCT ||
        pFront->m_nToken == WQL_TOK_FIRSTROW
       )
        delete pFront;
    else
        Pushback(pFront);

    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::SelectList
//
//  Extracts all tokens up to the FROM keyword and builds a list
//  of selected properties/columns.  FROM is left on the parse-stack on exit.
//
//***************************************************************************

int CWQLScanner::SelectList()
{
    // If the first token is FROM, then we have a SELECT FROM <rest>
    // which is the same as SELECT * FROM <rest>.  We simply
    // alter the parse-stack and let the following loop handle it.
    // =============================================================

    WSLexToken *pTok = ExtractNext();

    if (pTok->m_nToken == WQL_TOK_FROM)
    {
        WSLexToken *pAsterisk = new WSLexToken;
        if (pAsterisk == NULL)
            return FAILED;

        pAsterisk->m_nToken = WQL_TOK_ASTERISK;
        pAsterisk->m_pszTokenText = Macro_CloneLPWSTR(L"*");
        if (!pAsterisk->m_pszTokenText)
            return FAILED;
        Pushback(pTok);
        Pushback(pAsterisk);
    }
    else
        Pushback(pTok);

    // Otherwise, some kind of column selection is present.
    // ====================================================

    BOOL bTerminate = FALSE;

    while (!bTerminate)
    {
        pTok = ExtractNext();
        if (pTok == 0)
            return SYNTAX_ERROR;

        // We must begin at a legal token.
        // ===============================

        if (pTok->m_nToken != WQL_TOK_EOF)
        {
            CTokenArray Tokens;
            Tokens.Add(pTok);

            while (1)
            {
                pTok = ExtractNext();
                if (pTok == 0 || pTok->m_nToken == WQL_TOK_EOF)
                {
                    delete pTok;
                    return SYNTAX_ERROR;
                }
                if (pTok->m_nToken == WQL_TOK_FROM)
                {
                    Pushback(pTok);
                    bTerminate = TRUE;
                    break;
                }
                else if (pTok->m_nToken == WQL_TOK_COMMA)
                {
                    delete pTok;
                    break;
                }
                else
                    Tokens.Add(pTok);
            }

            SWQLColRef *pColRef = new SWQLColRef;
            if (pColRef == 0)
                return FAILED;

            BOOL bRes = BuildSWQLColRef(Tokens, *pColRef);
            if (bRes)
                m_aPropRefs.Add(pColRef);
            else
            {
                delete pColRef;
                return SYNTAX_ERROR;
            }
        }

        // Else an illegal token, such as WQL_TOK_EOF.
        // ===========================================
        else
        {
            delete pTok;
            return SYNTAX_ERROR;

        }
    }

    return SUCCESS;
}



//***************************************************************************
//
//  CWQLScanner::ReduceSql89Joins
//
//  Attempts to reduce the FROM clause, assuming it is based on SQL-89
//  join syntax or else a simple unary select.
//
//  The supported forms are:
//
//      FROM x
//      FROM x, y
//      FROM x as x1, y as y1
//      FROM x x1, y y1
//
//  If incompatible tokens are encountered, the entire function
//  returns FALSE and the results are ignored, and the parse-stack
//  is unaffected, in essence, allowing backtracking to try the SQL-92
//  syntax branch instead.
//
//***************************************************************************
BOOL CWQLScanner::ReduceSql89Joins()
{
    int i = 0;

    // Parse the FROM keyword.
    // =======================

    WSLexToken *pCurr = (WSLexToken *) m_aTokens[i++];
    if (pCurr->m_nToken != WQL_TOK_FROM)
        return FALSE;

    pCurr = (WSLexToken *) m_aTokens[i++];

    while (1)
    {
        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        // If here, we are looking at the beginnings of a table ref.
        // =========================================================

        WSTableRef *pTRef = new WSTableRef;
        if (pTRef == 0)
            return FALSE;

        pTRef->m_pszTable = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszTable)
            return FALSE;
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszAlias)
            return FALSE;
        m_aTableRefs.Add(pTRef);

        // Attempt to recognize an alias.
        // ==============================

        pCurr = (WSLexToken *) m_aTokens[i++];
        if (pCurr == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken == WQL_TOK_AS)
            pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_COMMA)
        {
            pCurr = (WSLexToken *) m_aTokens[i++];
            continue;
        }

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        delete [] pTRef->m_pszAlias;
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszAlias)
            return FALSE;

        // We have completely parsed a table reference.
        // Now we move on to the next one.
        // ============================================

        pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_COMMA)
            return FALSE;

        pCurr = (WSLexToken *) m_aTokens[i++];
    }

    if (m_aTableRefs.Size())
        return TRUE;

    return FALSE;
}

//***************************************************************************
//
//  CWQLScanner::ReduceSql92Joins
//
//  This scans SQL-92 JOIN syntax looking for table aliases.   See the
//  algorithm at the end of this file.
//
//***************************************************************************

BOOL CWQLScanner::ReduceSql92Joins()
{
    WSLexToken *pCurrent = 0, *pRover = 0, *pRight = 0, *pLeft;
    int nNumTokens = m_aTokens.Size();
    DWORD dwNumJoins = 0;
    int iCurrBase = 0;

    for (int i = 0; i < nNumTokens; i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        // If a JOIN token is found, we have a candidate.
        // ==============================================

        if (pCurrent->m_nToken == WQL_TOK_JOIN)
        {
            dwNumJoins++;

            // Analyze right-context.
            // ======================

            if (i + 1 < nNumTokens)
                pRover = PWSLexToken(m_aTokens[i + 1]);
            else
                pRover = NULL;

            if (pRover && pRover->m_nToken == WQL_TOK_IDENT)
            {
                // Check for aliased table by checking for
                // AS or two juxtaposed idents.
                // =======================================

                if (i + 2 < nNumTokens)
                    pRight = PWSLexToken(m_aTokens[i + 2]);
                else
                    pRight = NULL;


                if (pRight && pRight->m_nToken == WQL_TOK_AS)
                {
                    if (i + 3 < nNumTokens)
                        pRight = PWSLexToken(m_aTokens[i + 3]);
                    else
                        pRight = NULL;
                }

                if (pRight && pRight->m_nToken == WQL_TOK_IDENT)
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FALSE;
                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRight->m_pszTokenText);
                    if (!pTRef->m_pszAlias)
                        return FALSE;
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszTable)
                        return FALSE;
                    m_aTableRefs.Add(pTRef);
                }
                else    // An alias wasn't used, just a simple table ref.
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FALSE;

                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszAlias)
                        return FALSE;
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszTable)
                        return FALSE;
                    m_aTableRefs.Add(pTRef);
                }
                // discontinue analysis of right-context.
            }


            // Analyze left-context.
            // =====================

            int nLeft = i - 1;

            if (nLeft >= 0)
                pRover = PWSLexToken(m_aTokens[nLeft--]);
            else
                continue;   // No point in continuing

            // Verify the ANSI join syntax.

            if (nLeft)
            {
                int iTemp = nLeft;
                WSLexToken *pTemp = pRover;
                bool bInner = false;
                bool bDir = false;
                bool bOuter = false;
                bool bFail = false;
                bool bIdent = false;
                while (iTemp >= iCurrBase)
                {
                    if (pTemp->m_nToken == WQL_TOK_INNER)
                    {
                        if (bOuter || bIdent || bInner)
                            bFail = TRUE;
                        bInner = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_OUTER)
                    {
                        if (bInner || bIdent || bOuter)
                            bFail = TRUE;
                        bOuter = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_FULL  ||
                        pTemp->m_nToken == WQL_TOK_LEFT  ||
                        pTemp->m_nToken == WQL_TOK_RIGHT
                        )
                    {
                        if (bDir || bIdent)
                            bFail = TRUE;
                        bDir = true;
                    }
                    else
                        bIdent = TRUE;

                    // We are trying to enforce correct ANSI-92 joins
                    // even though we don't support them ourselves:
                    // OK:  LEFT OUTER JOIN
                    //      OUTER LEFT JOIN
                    //      LEFT JOIN
                    //      INNER JOIN
                    // NOT: LEFT LEFT JOIN
                    //      LEFT INNER JOIN
                    //      LEFT RIGHT JOIN
                    //      OUTER INNER JOIN
                    //      OUTER LEFT OUTER JOIN
                    //      OUTER GARBAGE LEFT JOIN
                    //      (no right side)

                    if ((bDir && bInner) || bFail)
                        return FALSE;

                    pTemp = PWSLexToken(m_aTokens[iTemp--]);
                }

            }

            // Skip past potential JOIN modifiers : INNER, OUTER,
            // FULL, LEFT, RIGHT
            // ==================================================

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            // Now we look to see if the roving pointer is pointing
            // to an ident.
            // ====================================================

            if (pRover && pRover->m_nToken != WQL_TOK_IDENT)
            {
                // No chance that we are looking at an aliased
                // table in a JOIN clause.
                // ===========================================
                continue;
            }

            iCurrBase = i;

            // If here, we are now possibliy looking at the second half
            // of an alias, the 'alias' name proper.  We mark this
            // by leaving pRover alone and continue to move into the
            // left context with a different pointer.
            // ========================================================

            if (nLeft >= 0)
                pLeft = PWSLexToken(m_aTokens[nLeft--]);
            else
                pLeft = 0;

            if (pLeft && pLeft->m_nToken == WQL_TOK_AS)
            {
                if (nLeft >= 0)
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pLeft = 0;
            }

            // The critical test.  Are we at an ident?
            // =======================================

            if (pLeft && pLeft->m_nToken == WQL_TOK_IDENT)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FALSE;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszAlias)
                    return FALSE;
                pTRef->m_pszTable = Macro_CloneLPWSTR(pLeft->m_pszTokenText);
                if (!pTRef->m_pszTable)
                    return FALSE;
                m_aTableRefs.Add(pTRef);
            }
            else if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FALSE;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszAlias)
                    return FALSE;
                pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszTable)
                    return FALSE;
                m_aTableRefs.Add(pTRef);
                if (nLeft >= 0)
                {
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                    if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
                        return FALSE;
                }
            }
        }

        // Find next JOIN occurrence
    }

    // Make sure there are two sides to every join reference.

    if (dwNumJoins+1 != (DWORD)m_aTableRefs.Size())
        return FALSE;

    return TRUE;
}


//***************************************************************************
//
//***************************************************************************
void CWQLScanner::Dump()
{
    WSLexToken *pCurrent = 0;

    printf("---Token Stream----\n");

    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        printf("Token %d <%S>\n", pCurrent->m_nToken, pCurrent->m_pszTokenText);
    }

    printf("---Table Refs---\n");

    for (i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        printf("Table = %S  Alias = %S\n", pTRef->m_pszTable, pTRef->m_pszAlias);
    }


    if (!m_bCount)
    {
        printf("---Select List---\n");

        for (i = 0; i < m_aPropRefs.Size(); i++)
        {
            SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
            pCRef->DebugDump();
        }
    }
    else
        printf(" -> COUNT query\n");

    printf("\n\n---<end of dump>---\n\n");
}


/*---------------------------------------------------------------------------

   Algorithm for detecting aliased tables in SQL-92 join syntax.

   The JOIN keyword must appear.

   It may appear in several contexts which are not
   relevant to the aliasing problem, such as the following:

     select distinct t1a.name, t2a.id, t3.value from
       (t1 as t1a join t2 as t2a on t1a.name = t2a.name)
       join
       (t1 as t1b join t3 on t1b.id = t3.id and (t3.id = t1b.id or t1b.id = t3.id))
       on
       t1a.id = t3.id
     where a = b and c = d

   where the middle join is against anonymous result sets.

   When analyzing the JOIN, we can easily parse the right-context.  Either
   an identifier follows (possibly further followed by AS),and an optional
   identifier if the JOIN is aliased.  Otherwise, we hit ON immediately, or
   a parenthesis.

   The problem is the left-context of the JOIN token.

   For an alias to occur, an identifier must appear immediately to
   the left of the JOIN.

     id JOIN id2 as id3 ON ...
     ^

   If here, there is a chance we are looking at the left hand side of a
   SQL92 join, a table reference.  However, we might be looking at the end of
   an ON clause which ends in an identifier:

     idx = id JOIN id2 as id3 ON...
         ^
   To disambiguate, we have to do further analysis of left context.

   Consider the follow left-context possibilities:

        (1) t1 AS id JOIN id2 as id3 ON
               ^
        (2) t1 id JOIN id2 as id3 ON
            ^
        (3) <keyword (except AS)> id JOIN id2 as id3 ON
             ^
        (4) on x <rel op> id JOIN id2 as id3 ON
                  ^

   Once we have identified <id>, we have to consider the above cases.

   (1) Case 1 is easy.  An AS clearly tells us we have an alias
       and we know how to get at the table and alias names.

   (2) Case 2 is easy.  Two juxtaposed identifiers to the left always
       indicates an alias.

   In all other cases, like (3) and (4), etc., the table is not
   aliased anyway.  Therefore, we only have to determine whether we
   are looking at an unaliased table name or the trailing end of
   another construct like an ON clause.  This is easy.  Only the
   FROM keyword can precede <id> if <id> is a simple table name.

---------------------------------------------------------------------------
*/


//***************************************************************************
//
//  CWQLScanner::BuildSWQLColRef
//
//***************************************************************************

BOOL CWQLScanner::BuildSWQLColRef(
    IN  CFlexArray     &aTokens,
    IN OUT SWQLColRef  &ColRef      // Empty on entry
    )
{
    if (aTokens.Size() == 0)
        return FALSE;
    int nCurrent = 0;
    WSLexToken *pTok = PWSLexToken(aTokens[nCurrent++]);

    // Initial state: single asterisk or else prop name.
    // =================================================

    if (pTok->m_nToken == WQL_TOK_ASTERISK && aTokens.Size() == 1)
    {
        ColRef.m_pColName = Macro_CloneLPWSTR(L"*");
        if (!ColRef.m_pColName)
            return FALSE;
        ColRef.m_dwFlags = WQL_FLAG_ASTERISK;
        ColRef.m_pQName = new SWQLQualifiedName;
        if (ColRef.m_pQName == 0)
            return FALSE;
        SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
        if (pField == 0)
            return FALSE;

        pField->m_pName = Macro_CloneLPWSTR(L"*");
        if (!pField->m_pName)
            return FALSE;
        ColRef.m_pQName->Add(pField);
        return TRUE;
    }

    // If not an identifier, we have an error.
    // =======================================

    else if (pTok->m_nToken == WQL_TOK_EOF)
        return FALSE;

    // If here, we have an identifier.
    // ===============================

    ColRef.m_pQName = new SWQLQualifiedName;
    if (ColRef.m_pQName == NULL)
        return FALSE;
    SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
    if (pField == 0)
        return FALSE;

    pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
    if (!pField->m_pName)
        return FALSE;
    ColRef.m_pQName->Add(pField);

    // Subsequent states.
    // ==================

    while (1)
    {
        if (nCurrent == aTokens.Size())
            break;

        pTok = PWSLexToken(aTokens[nCurrent++]);

        if (pTok->m_nToken == WQL_TOK_DOT)
        {
            pField = new SWQLQualifiedNameField;
            if (pField == 0)
                return FALSE;

            ColRef.m_pQName->Add(pField);

            if (nCurrent == aTokens.Size())
                return FALSE;
            pTok = PWSLexToken(aTokens[nCurrent++]);
            if (pTok->m_nToken != WQL_TOK_IDENT &&
                pTok->m_nToken != WQL_TOK_ASTERISK
                )
                return FALSE;

            pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
            if (!pField->m_pName)
                return FALSE;
        }
        else if (pTok->m_nToken == WQL_TOK_OPEN_BRACKET)
        {
            return FALSE; // Not supported at present!
        }
        else // illegal token
            return FALSE;
    }

    // Post-process.  If the name is not complex, then we
    // can fill out fields of ColRef.
    // ==================================================
    if (ColRef.m_pQName->GetNumNames() == 2)
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        if (!ColRef.m_pTableRef)
            return FALSE;
        ColRef.m_pColName  = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(1));
        if (!ColRef.m_pColName)
            return FALSE;
        if (_wcsicmp(ColRef.m_pColName, L"NULL") == 0)
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else if (ColRef.m_pQName->GetNumNames() == 1)
    {
        LPWSTR pName = ColRef.m_pQName->GetName(0);
        ColRef.m_pColName  = Macro_CloneLPWSTR(pName);
        if (!ColRef.m_pColName)
            return FALSE;
        if (_wcsicmp(ColRef.m_pColName, L"NULL") == 0)
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        if (!ColRef.m_pTableRef)
            return FALSE;
        ColRef.m_dwFlags = WQL_FLAG_COMPLEX_NAME;
    }

    return TRUE;
}




const LPWSTR CWQLScanner::AliasToTable(LPWSTR pszAlias)
{
    if (pszAlias == 0)
        return 0;

    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        if (_wcsicmp(pszAlias, pTRef->m_pszAlias) == 0)
            return pTRef->m_pszTable;

        if (_wcsicmp(pszAlias, pTRef->m_pszTable) == 0)
            return pTRef->m_pszTable;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\testlib\wqlparsertest.cpp ===
#include "WQLParserTest.h"
#include "TestSuite.h"
#include "TestCaller.h"
#include <objbase.h>
#include <wbemcli.h>
#include <wqllex.h>

PathParserTest::PathParserTest (std::string name)
: TestCase (name)
{
}


PathParserTest::~PathParserTest()
{
}

void PathParserTest::setUp ()
{
  comPath = 0;
  CDefPathParser * tmp = new CDefPathParser;
  assert(tmp != 0);
  assert(tmp->QueryInterface(IID_IWbemPath,(void**)&comPath)==S_OK);

}


void PathParserTest::tearDown ()
{
  if (comPath)
    {
     comPath->Release();
    }
}

void PathParserTest::testNamespaceRemoval ()
{
  ULONG count;
  assert(comPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,L"\\\\server\\root:obj.name=3")==S_OK);
  assert(comPath->GetNamespaceCount(&count)==0);
  assert(count==1);

  assert(comPath->RemoveAllNamespaces()==S_OK);
  assert(comPath->GetNamespaceCount(&count)==0);
  assert(count==0);

  assert(comPath->SetNamespaceAt(0,L"default")==S_OK);
  assert(comPath->GetNamespaceCount(&count)==S_OK);
  assert(count==1);

  assert(comPath->SetNamespaceAt(1,L"cimv2")==S_OK);
  assert(comPath->GetNamespaceCount(&count)==S_OK);
  assert(count==2);

  wchar_t res[128];
  ULONG length=128;
  assert(comPath->GetNamespaceAt(0,&length,res)==S_OK);
  assert(wcscmp(res,L"default")==0);
  length=128;
  assert(comPath->GetNamespaceAt(1,&length,res)==S_OK);
  assert(wcscmp(res,L"cimv2")==0);
  
  assert(comPath->RemoveAllNamespaces()==S_OK);
  assert(comPath->GetNamespaceCount(&count)==S_OK);
  assert(comPath->SetNamespaceAt(0,L"newroot")==S_OK);
  
  length=128;
  assert(comPath->GetText(WBEMPATH_GET_SERVER_TOO,&length,res)==S_OK);
  assert(wcscmp(res,L"\\\\server\\newroot:obj.name=3")==0);;



}


Test *PathParserTest::suite ()
{
    TestSuite *suite = new TestSuite ("PathParser");

    suite->addTest (new TestCaller<PathParserTest>("testNamespaceRemoval",testNamespaceRemoval));
    return suite;

}

WQLParserTest::WQLParserTest (std::string name)
: TestCase (name)
{
}


WQLParserTest::~WQLParserTest()
{
}

void WQLParserTest::setUp ()
{
  comQuery = 0;
  CWmiQuery * tmp = new CWmiQuery;
  assert(tmp != 0);
  assert(tmp->QueryInterface(IID__IWmiQuery,(void**)&comQuery)==S_OK);



  // Set the object
  CoInitialize(0);
  assert(CoCreateInstance (CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, IID_IWbemClassObject, (void **)&pObj) == S_OK);
  _variant_t t_Variant( L"Sample");
  assert(pObj->Put ( L"__CLASS" ,0 , &t_Variant, CIM_STRING) == S_OK) ;
}


void WQLParserTest::tearDown ()
{
  if (comQuery)
    {
     comQuery->Release();
    }
  if (pObj)
    {
      pObj->Release();
    }
  CoUninitialize();
  
}



void WQLParserTest::testExpr ()
{
  wchar_t query[] = L"select * from table1";
  wchar_t query2[] = L"select * from table1,table2";
  
  CTextLexSource lex(query);
  CWQLParser p(query,&lex);
  assert(p.Parse()==0);
  
  CTextLexSource lex2(query2);
  CWQLParser p2(query2,&lex2);
  assert(p2.Parse()==0);


}


void WQLParserTest::test_Like ()
{
	assert(comQuery->StringTest(WQL_TOK_LIKE,L"st",L"st%")==S_OK); 
	assert(comQuery->StringTest(WQL_TOK_LIKE,L"str",L"st%")==S_OK); 
	assert(comQuery->StringTest(WQL_TOK_LIKE,L"str2",L"st%")==S_OK); 
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"st%",L"st[%]")==S_OK); 
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"s",L"st%")!=S_OK); 

//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"[",L"[[]")==S_OK);
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"]",L"]")==S_OK);
	
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"-",L"[-acdf]")==S_OK);
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"a",L"[-acdf]")==S_OK);

//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"b",L"[a-cdf]")==S_OK);
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"-",L"[a-cdf]")!=S_OK);
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"5%",L"5[%]")!=S_OK);

//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"5a",L"5_")!=S_OK);
	
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"5a",L"5[^ab]")!=S_OK);
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"5c",L"5[^ab]")==S_OK);
	// Test []
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"a",L"[ab]")==S_OK); 
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"b",L"[ab]")==S_OK); 
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"c",L"[ab]")!=S_OK); 
	// Test [] at end
//	assert(comQuery->StringTest(WQL_TOK_LIKE,L"aabae",L"[ab]a[ab]a[eb]")==S_OK); 
}

void WQLParserTest::testTestObject()
{
  
//  assert(comQuery->Parse(L"WQL",L"Select * from Sample where Name ='Steve' and Value = 3", 0 ) != S_OK);
//  assert(comQuery->TestObject ( 0 , 0 , IID_IWbemClassObject , pObj) == S_OK);
//  assert(comQuery->Parse(L"WQL",L"Select * from Sample where Name ='Steve' and Value = 3", 0 ) == S_OK);
}


_declspec(dllexport) Test *WQLParserTest::suite ()
{
    TestSuite *suite = new TestSuite ("WQLParserTest");

    suite->addTest(PathParserTest::suite());
    suite->addTest (new TestCaller<WQLParserTest>("testExpr",testExpr));
    suite->addTest (new TestCaller<WQLParserTest>("test_Like",test_Like));
    suite->addTest (new TestCaller<WQLParserTest>("testTestObject",testTestObject));

    return suite;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\testlib\wqlparsertest.h ===
#ifndef __WQLPARSER_H__
#define __WQLPARSER_H__

#include <polarity.h>
#include <windows.h>
#include <wbemint.h>
#include <comdef.h>
#include <arena.h>
#include <flexarry.h>
#include <genlex.h>
#include <wqlnode.h>
#include <wql.h>
#include <wmiquery.h>
#include <like.h>
#include <pathparse.h>
#ifndef CPPUNIT_TESTCASE_H
#include "TestCase.h"
#endif




class PathParserTest: public TestCase
{
  IWbemPath * comPath;  
public:
    void                        setUp ();
    void                        tearDown ();

    void testNamespaceRemoval();

public:
    PathParserTest (std::string name);
    virtual ~PathParserTest();
    static Test *suite ();
};

class WQLParserTest : public TestCase
{
  _IWmiQuery * comQuery;
  IWbemClassObject * pObj;
public:
    void                        setUp ();
    void                        tearDown ();

    void                        testExpr ();
    void                        test_Like();
    void                        testTestObject();

public:
    WQLParserTest (std::string name);
    virtual ~WQLParserTest();

    static _declspec(dllexport) Test *suite ();

};

#endif //__WQLPARSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\wqlscan.h ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    WQLSCAN.H

Abstract:

    WQL Prefix Scanner

History:

	raymcc  26-Mar-98

--*/

#ifndef _WQLSCAN_H_
#define _WQLSCAN_H_


struct WSLexToken
{
    int      m_nToken;
    wchar_t *m_pszTokenText;

    WSLexToken() { m_pszTokenText = 0; }
    ~WSLexToken() { delete [] m_pszTokenText; }
};

typedef WSLexToken *PWSLexToken;

struct WSTableRef
{
    wchar_t *m_pszTable;    
    wchar_t *m_pszAlias;    // Can be NULL if no alias specified

    WSTableRef() { m_pszTable = m_pszAlias = 0; }
   ~WSTableRef() { delete [] m_pszTable; delete [] m_pszAlias; }
};

typedef WSTableRef * PWSTableRef;

class CWQLScanner
{
    // Data.
    // =====

    CGenLexer    *m_pLexer;
    int           m_nLine;
    wchar_t      *m_pTokenText;
    int           m_nCurrentToken;
    BOOL          m_bCount;

    CFlexArray m_aTokens;       // Array of ptrs to WSLexToken structs.
    CFlexArray m_aPropRefs;     // Array of ptrs to SWQLColRef structs.
    CFlexArray m_aTableRefs;    // Ptrs to WSTableRef structs.
    
    // Local functions.
    // ==================

    BOOL Next();
    PWSLexToken ExtractNext();
    void Pushback(PWSLexToken);

    BOOL StripWhereClause();
    BOOL SelectList();
    BOOL ReduceSql92Joins();
    BOOL ReduceSql89Joins();
    BOOL ExtractSelectType();

    void ClearTableRefs();
    void ClearPropRefs();
    void ClearTokens();

    BOOL BuildSWQLColRef(
        CFlexArray &aTokens,
        SWQLColRef  &ColRef      // Empty on entry
        );

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL,
        INVALID_PARAMETER,
        INTERNAL_ERROR
    };

    const LPWSTR AliasToTable(LPWSTR pszAlias);

    BOOL GetReferencedAliases(CWStringArray &aClasses);
    BOOL GetReferencedTables(CWStringArray &aClasses);
    BOOL CountQuery() {return m_bCount;}

    CWQLScanner(CGenLexSource *pSrc);
   ~CWQLScanner(); 
    int Parse();
    
    void Dump();

    const CFlexArray *GetSelectedColumns() { return &m_aPropRefs; }
        // Returns pointer to array of SWQLColRef*

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\copyright\chgcpy.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  chgcpy.CPP
//
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define FILEBUFFERSIZE 1024*10
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h> 

char gszSourceFiles[MAX_PATH];
char gszReplace[MAX_PATH];
char gszIgnore[MAX_PATH];

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParseCommandLine(int argc, char *argv[])
{
    BOOL fRc = TRUE;

    //============================================================================================
    //
    //  Loop through the command line and get all of the available arguments.  
    //
    //============================================================================================
	for(int i=1; i<argc; i++)
	{
		if(_stricmp(argv[i], "-SOURCEFILES") == 0)
		{
            argv[i++];
            strcpy( gszSourceFiles, argv[i] );
		}
		else if(_stricmp(argv[i], "-IGNORE") == 0)
		{
            argv[i++];
            strcpy( gszIgnore, argv[i] );
		}
		else if(_stricmp(argv[i], "-REPLACE") == 0)
		{
            argv[i++];
            strcpy( gszReplace, argv[i] );
		}
    }

    if( argc < 4 )
	{
	    printf("Usage : %s OPTIONS\n\n", argv[0]);
	    printf("-SOURCEFILES Files to search for.\n");
	    printf("-IGNORE      Files to ignore.\n");
	    printf("-REPLACE     Fields to be replaced.\n");
    }

    return fRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetNewCopyrightInfo(char * szLineToReplace, char * szNew)
{
    BOOL fRc = FALSE;
    FILE * fp = NULL;

    fp = fopen(gszReplace,"r");
    if(fp)
    {
        char szBuffer[FILEBUFFERSIZE];
        char szOld[FILEBUFFERSIZE];
        while(!feof(fp)) 
        {
            //=====================================================
            // Read a line at a time, see if the string is in there
            //=====================================================
//            fscanf(fp,"%[^\n]%*c",szBuffer);
            fgets(szBuffer, FILEBUFFERSIZE, fp );

            sscanf( szBuffer, "%[^~]%*c%[^\n]%*c",szOld, szNew );
            if( stricmp(szOld, szLineToReplace ) == 0 )
            {
                fRc = TRUE;
                break;
            }
        }
        fclose(fp);
    }
    return fRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL GenerateReplacementLine( char * szLineToReplace, char * szBuffer, char * pBeginning )
{
    char szOriginalLine[FILEBUFFERSIZE];
    char szNewLine[FILEBUFFERSIZE];
    BOOL fRc = FALSE;
    
    strcpy( szOriginalLine, szBuffer );
    int nOldTotal = strlen(szBuffer);
    //==========================================================
    //  Copy anything up to the line to replace
    //==========================================================
    int nBytesBeforeNew = pBeginning - szBuffer;
    strncpy( szBuffer, pBeginning, nBytesBeforeNew);
    //==========================================================
    //  insert new line
    //==========================================================
    if( GetNewCopyrightInfo( szLineToReplace, szNewLine ))
    {
        strncpy( &szBuffer[nBytesBeforeNew], szNewLine, strlen(szNewLine) );    
        //==========================================================
        //  Copy anything left over
        //==========================================================
        int nNewPos = nBytesBeforeNew + strlen(szNewLine);
        int nLeftOverBytes = nBytesBeforeNew + strlen(szLineToReplace);
        if( nLeftOverBytes < nOldTotal )
        {
            int nOldPos = nBytesBeforeNew + strlen( szLineToReplace );
            strncpy( &szBuffer[nNewPos], &szOriginalLine[nOldPos], nLeftOverBytes );
        }
        fRc = TRUE;
        szBuffer[nNewPos]= NULL;
    }
    return fRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetTempFileName(char * szFileLine, char * szNewLine)
{
    BOOL fReturn = FALSE;
    // tmp tmp
    sprintf(szNewLine,"%s.xxx", szFileLine );
    fReturn = TRUE;
    return fReturn;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL WriteReplacement(char * szFileLine, char * szLineToReplace, char * szTmpFileLine)
{
    BOOL fRc = FALSE;
    FILE * fp = NULL, * fp2 = NULL;

    fp = fopen(szFileLine,"r");
    if(fp)
    {
        char szBuffer[FILEBUFFERSIZE];
        if( GetTempFileName( szFileLine, szTmpFileLine ) )
        {
            fp2 = fopen(szTmpFileLine,"w");
            if(fp2)
            {
                char * pBeginning = NULL;
                char szTmp[FILEBUFFERSIZE];
                while(!feof(fp)) 
                {
                    //=====================================================
                    // Read a line at a time, see if the string is in there
                    //=====================================================
                    fgets(szBuffer, FILEBUFFERSIZE, fp );
                    sscanf(szBuffer,"%[^\n]",szTmp);  // tmp

                    if( pBeginning = strstr( szTmp, szLineToReplace ))
                    {
                        fRc = GenerateReplacementLine(szLineToReplace, szTmp, pBeginning);                    
                        if( !fRc )
                        {
                            break;
                        }
                        fprintf(fp2,"%s\n", szTmp );
                        //=================================================
                        //  just bulk copy rest of file, we got it in there
                        //  once anyway...
                        //=================================================
                        while(!feof(fp)) 
                        {
                            fgets(szBuffer, FILEBUFFERSIZE, fp );
                            fputs(szBuffer, fp2 );
                            memset( szBuffer, NULL, FILEBUFFERSIZE );
                        }
                        break;
                    }
                    else
                    {
                        fprintf(fp2,"%s\n", szBuffer );
                    }
                }
                fclose(fp2);
            }
            fclose(fp);
        }
    }
    return fRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ReplaceCopyright(char * szFileLine)
{
    BOOL fRc = FALSE;
    char szFile[FILEBUFFERSIZE];
    char szCopyInfo[FILEBUFFERSIZE];
    char szCommand[FILEBUFFERSIZE];
    char szTmpFileLine[FILEBUFFERSIZE];
 
    sscanf( szFileLine, "%[^:]:%[^\n]",szFile,szCopyInfo);
    sprintf( szCommand,"sd edit %s",szFile );
    system( szCommand );

    if( WriteReplacement( szFile, szCopyInfo, szTmpFileLine) )
    {
        sprintf( szCommand,"copy %s %s.bak",szFile, szFile );
        system(szCommand);
        sprintf( szCommand,"copy %s %s",szTmpFileLine, szFile );
        system(szCommand);
        sprintf( szCommand,"del %s",szFile); // testing here - some weirdness
        system(szCommand);
        sprintf( szCommand,"copy %s %s",szTmpFileLine, szFile);
        system(szCommand);
        sprintf( szCommand,"del %s",szTmpFileLine);
        system(szCommand);

        FILE * fp = fopen( "FCCP.BAT","a" );
        if( fp )
        {
            fprintf(fp,"fc %s %s.bak\n", szFile, szFile );
            fclose(fp);
        }

        printf( "edit of %s complete, replaced %s\n",szFile, szCopyInfo);
    }
    else
    {
        sprintf( szCommand,"sd revert %s",szFile );
        system( szCommand );
    }
    return fRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ValidLine(char * szLineToValidate)
{
    BOOL fRc = TRUE;
    FILE * fp = NULL;

    fp = fopen(gszIgnore,"r");
    if(fp)
    {
        char szBuffer[FILEBUFFERSIZE],szTmp[FILEBUFFERSIZE];
        while(!feof(fp)) 
        {
            //=====================================================
            // Read a line at a time, see if the string is in there
            //=====================================================
            fgets(szBuffer, FILEBUFFERSIZE, fp );
            sscanf(szBuffer,"%[^\n]",szTmp);  // tmp

            char * pChars = strstr( szLineToValidate, szTmp);
            if( pChars )
            {
                fRc = FALSE;
                break;
            }
        }
        fclose(fp);
    }
    return fRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL DoIt()
{
    BOOL fRc = FALSE;
    FILE * fp = NULL;

    fp = fopen(gszSourceFiles,"r");
    if(fp)
    {
        char szBuffer[FILEBUFFERSIZE];
        while(!feof(fp)) 
        {
            //=====================================================
            // Read a line at a time
            //=====================================================
//            fscanf(fp,"%[^\n]%*c",szBuffer);  
            fgets(szBuffer, FILEBUFFERSIZE, fp );

            if( !ValidLine(szBuffer) )
            {
                continue;
            }
            //=====================================================
            // If it is something we want to work with, save it
            //=====================================================
            ReplaceCopyright(szBuffer);
        }
        fclose(fp);
    }
    return fRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
int main( int argc, char *argv[ ] )

{
    int nRc = 1;

    memset(gszSourceFiles,NULL,MAX_PATH);
    memset(gszIgnore,NULL,MAX_PATH);
    memset(gszReplace,NULL,MAX_PATH);

    //==============================================================
    //  Get the command line arguments
    //==============================================================
    if( ParseCommandLine(argc, argv) )
    {
        if( strlen(gszSourceFiles) > 0 && strlen(gszReplace) > 0 && strlen(gszIgnore) > 0 )
        {
            //======================================================
            // Generate the list of files to edit 
            //======================================================
            if( DoIt())            
            {
                nRc = 1;
            }
        }
    }
    else
    {
        printf( "Invalid command line.\n");
    }

    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wmiutils\testlib\maindll.cpp ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    MAINDLL.CPP

Abstract:

    Contains DLL Entrypoints

History:

--*/

#include "precomp.h"
#include <wbemcli.h>
#include "pathparse.h"
//#include "wbemerror.h"

#include <wmiutils.h>
#include <wbemint.h>
#include "genlex.h"
#include "assocqp.h"
#include "ql.h"
#include "wmiquery.h"

#include "helpers.h"
HINSTANCE g_hInstance;
long g_cLock;
long g_cObj;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
    if (DLL_PROCESS_DETACH == ulReason)
    {
        CWmiQuery::Shutdown();
    }
    else if (DLL_PROCESS_ATTACH == ulReason)
    {
        g_hInstance = hInstance;
        CWmiQuery::Startup();
    }

    return TRUE;
}


//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//
//***************************************************************************
/*
STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT PPVOID ppv)
{
    HRESULT hr = WBEM_E_FAILED;

    IClassFactory * pFactory = NULL;
    if (CLSID_WbemDefPath == rclsid)
        pFactory = new CGenFactory<CDefPathParser>();
//postponed till Blackcomb    if (CLSID_UmiDefURL == rclsid)
//postponed till Blackcomb        pFactory = new CGenFactory<CDefPathParser>();
    else if (CLSID_WbemStatusCodeText == rclsid)
        pFactory = new CGenFactory<CWbemError>();

    else if (CLSID_WbemQuery == rclsid)
		pFactory = new CGenFactory<CWmiQuery>();

    if(pFactory == NULL)
        return E_FAIL;
    hr=pFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pFactory;

    return hr;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\testrunner.h ===
#ifndef __TESTRUNNER_H__
#define __TESTRUNNER_H__
#include <iostream>
#include <vector>

#include "TextTestResult.h"
#include "MulticasterTest.h"


using namespace std;

typedef pair<string, Test *>           mapping;
typedef vector<pair<string, Test *> >   mappings;

class TestAllocator;
class TestRunner
{
protected:
    TestAllocator  * allocator;
    bool                                m_wait;
    vector<pair<string,Test *> >        m_mappings;

public:
    TestRunner    ();
    ~TestRunner   ();

    void        run           (int ac, char **av);
    void        addTest       (string name, Test *test)
    { m_mappings.push_back (mapping (name, test)); }

protected:
    void        run (Test *test);
    void        printBanner ();

};

#endif __TESTRUNNER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn


# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
TARGETLIBS= \
	$(WMIROOT)\CPPUNIT\samples\testlib\$(O)\testlib.lib \
	$(WMIROOT)\common\utillib\testlib\$(O)\testlib.lib \
	$(WMIROOT)\common\wmiutils\testlib\$(O)\wmiutilstest.lib \
	$(WMIROOT)\winmgmt\coredll\testlib\$(O)\coredlltest.lib \
	$(WMIROOT)\winmgmt\wbemcomn\testlib\$(O)\testlib.lib \
        $(WBEMCOMN_STATIC_LIB) \
	$(STDLIBRARY_LIB) \


# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	 ..\.;\
	$(WMIROOT)\CPPUNIT\SAMPLEs\TESTLIB;\
	$(WMIROOT)\CPPUNIT\SAMPLEs;\
	$(WMIROOT)\common\utillib\testlib;\
	$(WMIROOT)\common\utillib\include;\
	$(WMIROOT)\common\wmiutils\testlib;\
	$(WMIROOT)\winmgmt\coredll\testlib;\
	$(WMIROOT)\winmgmt\wbemcomn\testlib;\
	$(WMIROOT)\winmgmt; \ 

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.
SOURCES= \
        ..\TestRunner.cpp \
	..\TextTestResult.cpp \
	main.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\testrunner.cpp ===
/*
 * A command line based tool to run tests.
 * TestRunner expects as its only argument the name of a TestCase class.
 * TestRunner prints out a trace as the tests are executed followed by a
 * summary at the end.
 *
 * You can add to the tests that the TestRunner knows about by 
 * making additional calls to "addTest (...)" in main.
 *
 * Here is the synopsis:
 *
 * TestRunner [-wait] ExampleTestCase
 *
 */

#include <iostream>
#include <vector>

#include "TestRunner.h"
#include "MulticasterTest.h"
#include "CHStringtest.h"
#include "autoptrtest.h"
#include <WQLParserTest.h>
#include <wbemcomn\testlib\maintest.h>
#include <maintest.h>
#include <windows.h>

  TestAllocator::TestAllocator():size_(0),mem_(HeapCreate(0,0,0)),freze_(false){} ;
  TestAllocator::~TestAllocator(){ HeapDestroy(mem_);} ;

  TestAllocator * TestAllocator::instance()
  {
  static TestAllocator tmp;
  return &tmp;
  }
  
  void * TestAllocator::allocate(size_t n){ 
    if (freze_ && size_< n )
      return 0;
    void * p = HeapAlloc(mem_,0,n); 
    if (p!=0) 
      size_+=n; 
    return p;
    };
    
  void TestAllocator::deallocate(void *p){ 
      if (p == 0)
	{
	return;
	}
      size_-=HeapSize(mem_,0,p);
      HeapFree(mem_,0,p); 
  }

/*
void* __cdecl operator new(size_t n) 
{
  return TestAllocator::instance()->allocate(n);
}

void*  __cdecl operator new(size_t n, std::nothrow_t&)
{
  return TestAllocator::instance()->allocate(n);
}

void __cdecl operator delete(void *p)
{
  return TestAllocator::instance()->deallocate(p);
}

void __cdecl operator delete(void *p, std::nothrow_t&)
{
  return TestAllocator::instance()->deallocate(p);
}

void*  __cdecl operator new[](size_t n) 
{
  return TestAllocator::instance()->allocate(n);
}

void*  __cdecl operator new[](size_t n, std::nothrow_t&)
{
  return TestAllocator::instance()->allocate(n);
}

void __cdecl operator delete[](void *p)
{
  return TestAllocator::instance()->deallocate(p);
}

void __cdecl operator delete[](void *p, std::nothrow_t&)
{
  return TestAllocator::instance()->deallocate(p);
}
*/
TestRunner::TestRunner ():allocator(TestAllocator::instance()),m_wait (false) 
{

}

void TestRunner::printBanner ()
{
    cout << "Usage: driver [ -wait ] testName, where name is the name of a test case class" << endl;
}


void TestRunner::run (int ac, char **av)
{
    string  testCase;
    int     numberOfTests = 0;

    for (int i = 1; i < ac; i++) {

        if (string (av [i]) == "-wait") {
            m_wait = true;
            continue;
        }

        testCase = av [i];
        
	Test *testToRun = NULL;
	
	if (testCase == "*") {
	  for (mappings::iterator it = m_mappings.begin ();
		  it != m_mappings.end ();
		  ++it) {
		  testToRun = (*it).second;
		  run (testToRun);
	    }

          return;
        }


        if (testCase == "/?" || testCase == "-?" ) {
            printBanner ();
            return;
        }


	for (mappings::iterator it = m_mappings.begin ();
                it != m_mappings.end ();
                ++it) {
            if ((*it).first == testCase) {
                testToRun = (*it).second;
                run (testToRun);

            }
        }

        numberOfTests++;

        if (!testToRun) {
            cout << "Test " << testCase << " not found." << endl;
            return;

        } 


    }

    if (numberOfTests == 0) {
        printBanner ();
        return;        
    }

    if (m_wait) {
        cout << "<RETURN> to continue" << endl;
        cin.get ();

    }


}


TestRunner::~TestRunner ()
{
    for (mappings::iterator it = m_mappings.begin ();
             it != m_mappings.end ();
             ++it)
        it->second->Delete();

}


void TestRunner::run (Test *test)
{
    TextTestResult  result;

    if (test)
	test->run (&result);

    cout << result << endl;
}


void 
populateRunner(TestRunner& runner)
{
    runner.addTest ("MulticasterTest", MulticasterTest::suite ());
    runner.addTest ("CHStringTest", CHStringTestCase::suite ());
    runner.addTest ("AutoBuffer", autobufferTest::suite());
    runner.addTest ("WQLParserTest", WQLParserTest::suite());
    runner.addTest ("CoreDllTest", CoreTest::suite());
		runner.addTest ("WBEMCommonTest", WBEMCommonTest::suite());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\texttestresult.cpp ===
#include "TextTestResult.h"
#include "CppUnitException.h"
#include "estring.h"

using namespace std;

void TextTestResult::addError (Test *test, CppUnitException *e)
{
    TestResult::addError (test, e);
    cerr << "E\n";

}

void TextTestResult::addFailure (Test *test, CppUnitException *e)
{
    TestResult::addFailure (test, e);
    cerr << "F\n";

}

void TextTestResult::startTest (Test *test)
{
    TestResult::startTest (test);
    cerr << ".";

}


void TextTestResult::printErrors (ostream& stream)
{
    if (testErrors () != 0) {

        if (testErrors () == 1)
            stream << "There was " << testErrors () << " error: " << endl;
        else
            stream << "There were " << testErrors () << " errors: " << endl;

        int i = 1;

        for (vector<TestFailure *>::iterator it = errors ().begin (); it != errors ().end (); ++it) {
            TestFailure             *failure    = *it;
            CppUnitException        *e          = failure->thrownException ();

            stream << i 
                   << ") "
                   << "line: " << (e ? estring (e->lineNumber ()) : "") << " "
                   << (e ? e->fileName () : "") << " "
                   << "\"" << failure->thrownException ()->what () << "\""
                   << endl;
            i++;
        }
    }

}

void TextTestResult::printFailures (ostream& stream) 
{
    if (testFailures () != 0) {
        if (testFailures () == 1)
            stream << "There was " << testFailures () << " failure: " << endl;
        else
            stream << "There were " << testFailures () << " failures: " << endl;

        int i = 1;

        for (vector<TestFailure *>::iterator it = failures ().begin (); it != failures ().end (); ++it) {
            TestFailure             *failure    = *it;
            CppUnitException        *e          = failure->thrownException ();

            stream << i 
                   << ") "
                   << "line: " << (e ? estring (e->lineNumber ()) : "") << " "
                   << (e ? e->fileName () : "") << " "
                   << "\"" << failure->thrownException ()->what () << "\""
                   << endl;
            i++;
        }
    }

}


void TextTestResult::print (ostream& stream) 
{
    printHeader (stream);
    printErrors (stream);
    printFailures (stream);

}


void TextTestResult::printHeader (ostream& stream)
{
    if (wasSuccessful ())
        cout << endl << "OK (" << runTests () << " tests)" << endl;
    else
        cout << endl
             << "!!!FAILURES!!!" << endl
             << "Test Results:" << endl
             << "Run:  "
             << runTests ()
             << "   Failures: "
             << testFailures ()
             << "   Errors: "
             << testErrors ()
             << endl;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\texttestresult.h ===
#ifndef CPPUNIT_TEXTTESTRESULT_H
#define CPPUNIT_TEXTTESTRESULT_H

#include <iostream>
#include "TestResult.h"


class TextTestResult : public TestResult
{
public:
    virtual void        addError      (Test *test, CppUnitException *e);
    virtual void        addFailure    (Test *test, CppUnitException *e);
    virtual void        startTest     (Test *test);
    virtual void        print         (std::ostream& stream);
    virtual void        printErrors   (std::ostream& stream);
    virtual void        printFailures (std::ostream& stream);
    virtual void        printHeader   (std::ostream& stream);

};


/* insertion operator for easy output */
inline std::ostream& operator<< (std::ostream& stream, TextTestResult& result)
{ result.print (stream); return stream; }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\guards.h ===
#ifndef CPPUNIT_GUARDS_H
#define CPPUNIT_GUARDS_H

// Prevent copy construction and assignment for a class
#define REFERENCEOBJECT(className) \
private: \
               className (const className& other); \
    className& operator= (const className& other); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\estring.h ===
#ifndef CPPUNIT_ESTRING_H
#define CPPUNIT_ESTRING_H


// Create a string from a const char pointer
inline std::string estring (const char *cstring)
{ return std::string (cstring); }

// Create a string from a string (for uniformities' sake)
inline std::string estring (std::string& expandedString)
{ return expandedString; }

// Create a string from an int
inline std::string estring (int number)
{ char buffer [50]; sprintf (buffer, "%d", number); return std::string (buffer); }

// Create a string from a long
inline std::string estring (long number)
{ char buffer [50]; sprintf (buffer, "%ld", number); return std::string (buffer); }

// Create a string from a double
inline std::string estring (double number)
{ char buffer [50]; sprintf (buffer, "%lf", number); return std::string (buffer); }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\cppunitexception.h ===
#ifndef CPPUNIT_CPPUNITEXCEPTION_H
#define CPPUNIT_CPPUNITEXCEPTION_H


/* 
 * CppUnitException is an exception that serves
 * descriptive strings through its what () method
 *
 */

#include <exception>
#include <string>

#define CPPUNIT_UNKNOWNFILENAME        "<unknown>"
#define CPPUNIT_UNKNOWNLINENUMBER      (-1)


class CppUnitException : public exception
{
public:
                        CppUnitException (std::string  message    = "", 
                                          long         lineNumber = CPPUNIT_UNKNOWNLINENUMBER, 
                                          std::string  fileName   = CPPUNIT_UNKNOWNFILENAME);
                        CppUnitException (const CppUnitException& other);

    virtual             ~CppUnitException ();

    CppUnitException&   operator= (const CppUnitException& other);

    const char          *what() const throw ();

    long                lineNumber ();
    std::string         fileName ();

private:
    std::string         m_message;
    long                m_lineNumber;
    std::string         m_fileName;

};


// Construct the exception
inline CppUnitException::CppUnitException (const CppUnitException& other)
: exception (other)
{ 
    m_message       = other.m_message; 
    m_lineNumber    = other.m_lineNumber;
    m_fileName      = other.m_fileName;
} 

inline CppUnitException::CppUnitException (std::string message, long lineNumber, std::string fileName)
: m_message (message), m_lineNumber (lineNumber), m_fileName (fileName)
{}


// Destruct the exception
inline CppUnitException::~CppUnitException ()
{}


// Perform an assignment
inline CppUnitException& CppUnitException::operator= (const CppUnitException& other)
{ 
	exception::operator= (other);

    if (&other != this) {
        m_message       = other.m_message; 
        m_lineNumber    = other.m_lineNumber;
        m_fileName      = other.m_fileName;
    }

    return *this; 
}


// Return descriptive message
inline const char *CppUnitException::what() const throw ()
{ return m_message.c_str (); }

// The line on which the error occurred
inline long CppUnitException::lineNumber ()
{ return m_lineNumber; }


// The file in which the error occurred
inline std::string CppUnitException::fileName ()
{ return m_fileName; }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\test.h ===
#ifndef CPPUNIT_TEST_H
#define CPPUNIT_TEST_H
#include <polarity.h>
#include <string>

class TestResult;

/*
 * A Test can be run and collect its results.
 * See TestResult.
 * 
 */


class Test
{
protected:
    virtual                ~Test () = 0;

public:
	void Delete(){ delete this;};
    virtual void           run (TestResult *result)    = 0;
    virtual int            countTestCases ()           = 0;
    virtual std::string    toString ()                 = 0;
};

inline Test::~Test ()
{}



// Runs a test and collects its result in a TestResult instance.
inline void Test::run (TestResult *result)
{}


// Counts the number of test cases that will be run by this test.
inline int Test::countTestCases ()
{ return 0; }


// Returns the name of the test instance. 
inline std::string Test::toString ()
{ return ""; }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\perftime.h ===
// Measurement harness based on Andrew Koenig JOOP article
// it repeats timing loops until it is (statistically) convinced
// that a result is meaningful


#include <vector>
#include <assert.h>
#include <algorithm>
#include <ctime>

template <typename F>
class perf_measure
{
	F f_;
	std::vector<double> mv;
    double ovhd;

	// We'd like the odds to be factor:1 that the result is
	// within percent% of the median
	const int factor;// = 10;
	const int percent;// = 20;

public:
	perf_measure(F f):f_(f),factor(10),percent(20),ovhd(clock_overhead()){};

	// How many clock units does it take to interrogate the clock?
	double clock_overhead()
	{
    clock_t k = clock(), start, limit;

    // Wait for the clock to tick
    do start = clock();
    while (start == k);

    // interrogate the clock until it has advanced at least a second
    // (for reasonable accuracy)
    limit = start + CLOCKS_PER_SEC;

    unsigned long r = 0;
    while ((k = clock()) < limit)
	++r;

    return double(k - start) / r;
	}

// Measure a function (object) factor*2 times,
// appending the measurements to the second argument

void measure_aux()
{

    // Ensure we don't reallocate in mid-measurement
    mv.reserve(mv.size() + factor*2);

    // Wait for the clock to tick
    clock_t k = clock();
    clock_t start;

    do start = clock();
    while (start == k);

    // Do 2*factor measurements
    for (int i = 2*factor; i; --i) {
	unsigned long count = 0, limit = 1, tcount = 0;
	const clock_t clocklimit = start + CLOCKS_PER_SEC/100;
	clock_t t;

	do {
	    while (count < limit) {
		f_();
		++count;
	    }
	    limit *= 2;
	    ++tcount;
	} while ((t = clock()) < clocklimit);

	// Wait for the clock to tick again;
	clock_t t2;
	do ++tcount;
	while ((t2 = clock()) == t);

	// Append the measurement to the vector
	mv.push_back(((t2 - start) - (tcount * ovhd)) / count);

	// Establish a new starting point
	start = t2;
    }
}

// Returns the number of clock units per iteration
// With odds of factor:1, the measurement is within percent% of
// the value returned, which is also the median of all measurements.
double measure()
{

    int n = 0;			// iteration counter
	double median = 0;
    do {
	++n;

	// Try 2*factor measurements
	measure_aux();
	assert(mv.size() == 2*n*factor);

	// Compute the median.  We know the size is even, so we cheat.
	std::sort(mv.begin(), mv.end());
	double median = (mv[n*factor] + mv[n*factor-1])/2;
	//double median = 0;
//	for(std::vector<double>::const_iterator it = mv.begin();it!=mv.end();++it)
//		median+=*it;
//	median = median/mv.size();


	// If the extrema are within threshold of the median, we're done
	if (mv[n] > (median * (100-percent))/100 &&
	    mv[mv.size() - n - 1] < (median * (100+percent))/100)
	    return median;


    } while (mv.size() < factor * 200);

	return -median;
}
};
template <typename F>
double measure(F f)
{
perf_measure<F> t(f);
return t.measure();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\testcaller.h ===
#ifndef CPPUNIT_TESTCALLER_H
#define CPPUNIT_TESTCALLER_H

#ifndef CPPUNIT_GUARDS_H
#include "Guards.h"
#endif

#ifndef CPPUNIT_TESTCASE_H
#include "TestCase.h"
#endif

/* 
 * A test caller provides access to a test case method 
 * on a test case class.  Test callers are useful when 
 * you want to run an individual test or add it to a 
 * suite.
 * 
 * Here is an example:
 * 
 * class MathTest : public TestCase {
 *         ...
 *     public:
 *         void         setUp ();
 *         void         tearDown ();
 *
 *         void         testAdd ();
 *         void         testSubtract ();
 * };
 *
 * Test *MathTest::suite () {
 *     TestSuite *suite = new TestSuite;
 *
 *     suite->addTest (new TestCaller<MathTest> ("testAdd", testAdd));
 *     return suite;
 * }
 *
 * You can use a TestCaller to bind any test method on a TestCase
 * class, as long as it returns accepts void and returns void.
 * 
 * See TestCase
 */


template <class Fixture> class TestCaller : public TestCase
{ 
   REFERENCEOBJECT (TestCaller)

   typedef void             (Fixture::*TestMethod)();
    
public:
                            TestCaller (std::string name, TestMethod test)
                            : TestCase (name), m_fixture (new Fixture (name)), m_test (test)
                            {}

protected:
    void                    runTest () 
                            { (m_fixture.get ()->*m_test)(); }  

    void                    setUp ()
                            { m_fixture.get ()->setUp (); }

    void                    tearDown ()
                            { m_fixture.get ()->tearDown (); }

private:
   TestMethod               m_test;
   std::auto_ptr<Fixture>   m_fixture;

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\testfailure.cpp ===
#include "TestFailure.h"
#include "Test.h"

// Returns a short description of the failure.
std::string TestFailure::toString () 
{ 
    return m_failedTest->toString () + ": " + m_thrownException->what ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\testresult.cpp ===
#include "TestResult.h"

// Destroys a test result
TestResult::~TestResult ()
{
    std::vector<TestFailure *>::iterator it;

    for (it = m_errors.begin (); it != m_errors.end (); ++it)
        delete *it;

    for (it = m_failures.begin (); it != m_failures.end (); ++it)
        delete *it;

    delete m_syncObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\testfailure.h ===
#ifndef CPPUNIT_TESTFAILURE_H
#define CPPUNIT_TESTFAILURE_H

#ifndef CPPUNIT_GUARDS_H
#include "Guards.h"
#endif

#ifndef CPPUNIT_EXCEPTION_H
#include "CppUnitException.h"
#endif

class Test;


/*
 * A TestFailure collects a failed test together with
 * the caught exception.
 *
 * TestFailure assumes lifetime control for any exception
 * passed to it.  The lifetime of tests is handled by
 * their TestSuite (if they have been added to one) or
 * whomever creates them.
 * 
 * see TestResult
 * see TestSuite
 *
 */

class TestFailure 
{
    REFERENCEOBJECT (TestFailure)

public:
                        TestFailure (Test *failedTest, CppUnitException *thrownException);
                        ~TestFailure ();

    Test                *failedTest ();
    CppUnitException    *thrownException ();
    std::string         toString ();

protected:
    Test                *m_failedTest;
    CppUnitException    *m_thrownException;

};


// Constructs a TestFailure with the given test and exception.
inline TestFailure::TestFailure (Test *failedTest, CppUnitException *thrownException)
 : m_failedTest (failedTest), m_thrownException (thrownException) 
{}


// Deletes the owned exception.
inline TestFailure::~TestFailure ()
{ delete m_thrownException; }


// Gets the failed test.
inline Test *TestFailure::failedTest ()
{ return m_failedTest; }


// Gets the thrown exception.
inline CppUnitException *TestFailure::thrownException ()
{ return m_thrownException; }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\testcase.h ===
#ifndef CPPUNIT_TESTCASE_H
#define CPPUNIT_TESTCASE_H
#include <polarity.h>
#include <string>


#ifndef CPPUNIT_GUARDS_H
#include "Guards.h"
#endif

#ifndef CPPUNIT_TEST_H
#include "Test.h"
#endif

#ifndef CPPUNIT_CPPUNITEXCEPTION_H
#include "CppUnitException.h"
#endif

class TestResult;



/*
 * A test case defines the fixture to run multiple tests. To define a test case
 * 1) implement a subclass of TestCase
 * 2) define instance variables that store the state of the fixture
 * 3) initialize the fixture state by overriding setUp
 * 4) clean-up after a test by overriding tearDown.
 *
 * Each test runs in its own fixture so there
 * can be no side effects among test runs.
 * Here is an example:
 * 
 * class MathTest : public TestCase {
 *     protected: int m_value1;
 *     protected: int m_value2;
 *
 *     public: MathTest (string name)
 *                 : TestCase (name) {
 *     }
 *
 *     protected: void setUp () {
 *         m_value1 = 2;
 *         m_value2 = 3;
 *     }
 * }
 * 
 *
 * For each test implement a method which interacts
 * with the fixture. Verify the expected results with assertions specified
 * by calling assert on the expression you want to test:
 * 
 *    protected: void testAdd () {
 *        int result = value1 + value2;
 *        assert (result == 5);
 *    }
 * 
 * Once the methods are defined you can run them. To do this, use
 * a TestCaller.
 *
 * Test *test = new TestCaller<MathTest>("testAdd", MathTest::testAdd);
 * test->run ();
 *
 *
 * The tests to be run can be collected into a TestSuite. CppUnit provides
 * different test runners which can run a test suite and collect the results.
 * The test runners expect a static method suite as the entry
 * point to get a test to run.
 * 
 * public: static MathTest::suite () {
 *      TestSuite *suiteOfTests = new TestSuite;
 *      suiteOfTests->addTest(new TestCaller<MathTest>("testAdd", testAdd));
 *      suiteOfTests->addTest(new TestCaller<MathTest>("testDivideByZero", testDivideByZero));
 *      return suiteOfTests;
 *  }
 * 
 * Note that the caller of suite assumes lifetime control
 * for the returned suite.
 *
 * see TestResult, TestSuite and TestCaller
 *
 */


class TestCase : public Test 
{
    REFERENCEOBJECT (TestCase)

public:
                        TestCase         (std::string Name);
                        ~TestCase        ();

    virtual void        run              (TestResult *result);
    virtual TestResult  *run             ();
    virtual int         countTestCases   ();
    std::string         name             ();
    std::string         toString         ();

    virtual void        setUp            ();
    virtual void        tearDown         ();

protected:
    virtual void        runTest          ();

    TestResult          *defaultResult   ();
    void                assertImplementation 
                                         (bool         condition, 
                                          std::string  conditionExpression = "",
                                          long         lineNumber = CPPUNIT_UNKNOWNLINENUMBER,
                                          std::string  fileName = CPPUNIT_UNKNOWNFILENAME);

    void                assertEquals     (long         expected, 
                                          long         actual,
                                          long         lineNumber = CPPUNIT_UNKNOWNLINENUMBER,
                                          std::string  fileName = CPPUNIT_UNKNOWNFILENAME);

    void                assertEquals     (double       expected, 
                                          double       actual, 
                                          double       delta, 
                                          long         lineNumber = CPPUNIT_UNKNOWNLINENUMBER,
                                          std::string  fileName = CPPUNIT_UNKNOWNFILENAME);

    std::string         notEqualsMessage (long         expected, 
                                          long         actual);

    std::string         notEqualsMessage (double       expected, 
                                          double       actual);
    
private:
    const std::string   m_name;



};


// Constructs a test case
inline TestCase::TestCase (std::string name) 
: m_name (name) 
{}


// Destructs a test case
inline TestCase::~TestCase ()
{}


// Returns a count of all the tests executed
inline int TestCase::countTestCases ()
{ return 1; }


// Returns the name of the test case
inline std::string TestCase::name ()
{ return m_name; }


// A hook for fixture set up
inline void TestCase::setUp ()
{}


// A hook for fixture tear down
inline void TestCase::tearDown ()
{}


// Returns the name of the test case instance
inline std::string TestCase::toString ()
{ const type_info& thisClass = typeid (*this); return std::string (thisClass.name ()) + "." + name (); }



// A set of macros which allow us to get the line number
// and file name at the point of an error.
// Just goes to show that preprocessors do have some
// redeeming qualities.

#define CPPUNIT_SOURCEANNOTATION

#ifdef CPPUNIT_SOURCEANNOTATION

    #undef assert
    #define assert(condition)\
    (this->assertImplementation ((condition),(#condition),\
        __LINE__, __FILE__))

#else

    #undef assert
    #define assert(condition)\
    (this->assertImplementation ((condition),"",\
        __LINE__, __FILE__))

#endif

#include <windows.h>
class TestAllocator
{
  int size_;
  bool freze_;
  HANDLE mem_;
  TestAllocator();
  ~TestAllocator();

public:

  static TestAllocator * instance();
  
  void * allocate(size_t n);    
  void deallocate(void *p);
  void freeze()
  { 
    freze_ = true;
  }
  void unfreeze()
  { 
    freze_ = false;
  }
  size_t size(){ return size_;};
};

class memory_leaks
{
  size_t initial_;
public:
  memory_leaks():initial_(TestAllocator::instance()->size()){ };
  bool hasleaks(){ return TestAllocator::instance()->size() > initial_;};
};
/*
void* __cdecl operator new(size_t n);
void* __cdecl operator new(size_t n, std::nothrow_t&);
void __cdecl operator delete(void *p);
void __cdecl operator delete(void *p, std::nothrow_t&);
void* __cdecl operator new[](size_t n) ;
void* __cdecl operator new[](size_t n, std::nothrow_t&);
void __cdecl operator delete[](void *p);
void __cdecl operator delete[](void *p, std::nothrow_t&);
*/

class UseAllMemory
{
  void allocate_all();
  void release_all();

public:
  UseAllMemory() { TestAllocator::instance()->freeze();};
  ~UseAllMemory(){ release();};
  void release(){ TestAllocator::instance()->unfreeze();};
};

// Macros for primitive value comparisons
#define assertDoublesEqual(expected,actual,delta)\
(this->assertEquals ((expected),\
        (actual),(delta),__LINE__,__FILE__))

#define assertLongsEqual(expected,actual)\
(this->assertEquals ((expected),\
        (actual),__LINE__,__FILE__))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\testcase.cpp ===
#include <stdexcept>
#include <cmath>

#include "TestCase.h"
#include "TestResult.h"
#include "estring.h"



// Create a default TestResult
TestResult *TestCase::defaultResult ()
{ return new TestResult; } 


// Check for a failed general assertion 
void TestCase::assertImplementation (bool          condition,
                                     std::string   conditionExpression,
                                     long          lineNumber,
                                     std::string   fileName)
{ 
    if (!condition) 
        throw CppUnitException (conditionExpression, lineNumber, fileName); 
}


// Check for a failed equality assertion 
void TestCase::assertEquals (long        expected, 
                             long        actual,
                             long        lineNumber,
                             std::string fileName)
{ 
    if (expected != actual) 
        assertImplementation (false, notEqualsMessage(expected, actual), lineNumber, fileName); 
}


// Check for a failed equality assertion
void TestCase::assertEquals (double        expected, 
                             double        actual, 
                             double        delta,
                             long          lineNumber,
                             std::string   fileName)
{ 
    if (fabs (expected - actual) > delta) 
        assertImplementation (false, notEqualsMessage(expected, actual), lineNumber, fileName); 

}


// Run the test and catch any exceptions that are triggered by it 
void TestCase::run (TestResult *result)
{
    result->startTest (this);

    setUp ();

    try {
        runTest ();

    }
    catch (CppUnitException e) {
        CppUnitException *copy = new CppUnitException (e);
        result->addFailure (this, copy);

    }
    catch (exception e) {
        result->addError (this, new CppUnitException (e.what ()));

    }
    catch (...) {
        CppUnitException *e = new CppUnitException ("unknown exception");
        result->addError (this, e);

    }

    tearDown ();

    result->endTest (this);

}


// A default run method 
TestResult *TestCase::run ()
{
    TestResult *result = defaultResult ();

    run (result);
    return result;

}


// All the work for runTest is deferred to subclasses 
void TestCase::runTest ()
{
}


// Build a message about a failed equality check 
std::string TestCase::notEqualsMessage (long expected, long actual)
{ 
    return "expected: " + estring (expected) + " but was: " + estring (actual); 
}


// Build a message about a failed equality check 
std::string TestCase::notEqualsMessage (double expected, double actual)
{ 
    return "expected: " + estring (expected) + " but was: " + estring (actual); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\testsuite.cpp ===
#include "TestSuite.h"
#include "TestResult.h"


// Deletes all tests in the suite.
void TestSuite::deleteContents ()
{
    for (std::vector<Test *>::iterator it = m_tests.begin ();
            it != m_tests.end ();
            ++it)
        (*it)->Delete();

}


// Runs the tests and collects their result in a TestResult.
void TestSuite::run (TestResult *result)
{
    for (std::vector<Test *>::iterator it = m_tests.begin ();
            it != m_tests.end ();
            ++it) {
        if (result->shouldStop ())
            break;

        Test *test = *it;
        test->run (result);
    }

}


// Counts the number of test cases that will be run by this test.
int TestSuite::countTestCases ()
{
    int count = 0;

    for (std::vector<Test *>::iterator it = m_tests.begin ();
            it != m_tests.end ();
            ++it)
        count += (*it)->countTestCases ();

    return count;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\testsuite.h ===
#ifndef CPPUNIT_TESTSUITE_H
#define CPPUNIT_TESTSUITE_H

#include <vector>
#include <string>

#ifndef CPPUNIT_GUARDS_H
#include "Guards.h"
#endif

#ifndef CPPUNIT_TEST_H
#include "Test.h"
#endif

class TestResult;

/*
 * A TestSuite is a Composite of Tests.
 * It runs a collection of test cases. Here is an example.
 * 
 * TestSuite *suite= new TestSuite();
 * suite->addTest(new TestCaller<MathTest> ("testAdd", testAdd));
 * suite->addTest(new TestCaller<MathTest> ("testDivideByZero", testDivideByZero));
 * 
 * Note that TestSuites assume lifetime
 * control for any tests added to them.
 *
 * see Test and TestCaller
 */


class TestSuite : public Test
{
    REFERENCEOBJECT (TestSuite)

public:
                        TestSuite       (std::string name = "");
                        ~TestSuite      ();

    void                run             (TestResult *result);
    int                 countTestCases  ();
    void                addTest         (Test *test);
    std::string         toString        ();

    virtual void        deleteContents  ();

private:
    std::vector<Test *> m_tests;
    const std::string   m_name;


};


// Default constructor
inline TestSuite::TestSuite (std::string name)
: m_name (name)
{}


// Destructor
inline TestSuite::~TestSuite ()
{ deleteContents (); }


// Adds a test to the suite. 
inline void TestSuite::addTest (Test *test)
{ m_tests.push_back (test); }


// Returns a string representation of the test suite.
inline std::string TestSuite::toString ()
{ return "suite " + m_name; }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\testresult.h ===
#ifndef CPPUNIT_TESTRESULT_H
#define CPPUNIT_TESTRESULT_H

#include <vector>

#ifndef CPPUNIT_GUARDS_H
#include "Guards.h"
#endif

#ifndef CPPUNIT_TESTFAILURE_H
#include "TestFailure.h"
#endif


class CppUnitException;
class Test;


/*
 * A TestResult collects the results of executing a test case. It is an 
 * instance of the Collecting Parameter pattern.
 *
 * The test framework distinguishes between failures and errors.
 * A failure is anticipated and checked for with assertions. Errors are
 * unanticipated problems signified by exceptions that are not generated
 * by the framework.
 *
 * TestResult supplies a template method 'setSynchronizationObject ()'
 * so that subclasses can provide mutual exclusion in the face of multiple
 * threads.  This can be useful when tests execute in one thread and
 * they fill a subclass of TestResult which effects change in another 
 * thread.  To have mutual exclusion, override setSynchronizationObject ()
 * and make sure that you create an instance of ExclusiveZone at the 
 * beginning of each method.
 *
 * see Test
 */

class TestResult
{
    REFERENCEOBJECT (TestResult)

public:
                                        TestResult  ();
    virtual                             ~TestResult ();

    virtual void                        addError       (Test *test, CppUnitException *e);
    virtual void                        addFailure     (Test *test, CppUnitException *e);
    virtual void                        startTest      (Test *test);
    virtual void                        endTest        (Test *test);
    virtual int                         runTests       ();
    virtual int                         testErrors     ();
    virtual int                         testFailures   ();
    virtual bool                        wasSuccessful  ();
    virtual bool                        shouldStop     ();
    virtual void                        stop           ();

    virtual std::vector<TestFailure *>& errors         ();
    virtual std::vector<TestFailure *>& failures       ();


    class SynchronizationObject
    {
    public:
                                SynchronizationObject  () {}
        virtual                 ~SynchronizationObject () {}

        virtual void            lock                   () {}
        virtual void            unlock                 () {}
    };

    class ExclusiveZone
    {
        SynchronizationObject   *m_syncObject;

    public:
                                ExclusiveZone (SynchronizationObject *syncObject) 
                                : m_syncObject (syncObject) 
                                { m_syncObject->lock (); }

                                ~ExclusiveZone () 
                                { m_syncObject->unlock (); }
    };

protected:
    virtual void                setSynchronizationObject (SynchronizationObject *syncObject);

    std::vector<TestFailure *>  m_errors;
    std::vector<TestFailure *>  m_failures;
    int                         m_runTests;
    bool                        m_stop;
    SynchronizationObject       *m_syncObject;

};



// Construct a TestResult
inline TestResult::TestResult ()
: m_syncObject (new SynchronizationObject ())
{ m_runTests = 0; m_stop = false; }


// Adds an error to the list of errors. The passed in exception
// caused the error
inline void TestResult::addError (Test *test, CppUnitException *e)
{ ExclusiveZone zone (m_syncObject); m_errors.push_back (new TestFailure (test, e)); }


// Adds a failure to the list of failures. The passed in exception
// caused the failure.
inline void TestResult::addFailure (Test *test, CppUnitException *e)
{ ExclusiveZone zone (m_syncObject); m_failures.push_back (new TestFailure (test, e)); }


// Informs the result that a test will be started.
inline void TestResult::startTest (Test *test)
{ ExclusiveZone zone (m_syncObject); m_runTests++; }

  
// Informs the result that a test was completed.
inline void TestResult::endTest (Test *test)
{ ExclusiveZone zone (m_syncObject); }


// Gets the number of run tests.
inline int TestResult::runTests ()
{ ExclusiveZone zone (m_syncObject); return m_runTests; }


// Gets the number of detected errors.
inline int TestResult::testErrors ()
{ ExclusiveZone zone (m_syncObject); return m_errors.size (); }


// Gets the number of detected failures.
inline int TestResult::testFailures ()
{ ExclusiveZone zone (m_syncObject); return m_failures.size (); }


// Returns whether the entire test was successful or not.
inline bool TestResult::wasSuccessful ()
{ ExclusiveZone zone (m_syncObject); return m_failures.size () == 0 && m_errors.size () == 0; }


// Returns a vector of the errors.
inline std::vector<TestFailure *>& TestResult::errors ()
{ ExclusiveZone zone (m_syncObject); return m_errors; }


// Returns a vector of the failures.
inline std::vector<TestFailure *>& TestResult::failures ()
{ ExclusiveZone zone (m_syncObject); return m_failures; }


// Returns whether testing should be stopped
inline bool TestResult::shouldStop ()
{ ExclusiveZone zone (m_syncObject); return m_stop; }


// Stop testing
inline void TestResult::stop ()
{ ExclusiveZone zone (m_syncObject); m_stop = true; }


// Accept a new synchronization object for protection of this instance
// TestResult assumes ownership of the object
inline void TestResult::setSynchronizationObject (SynchronizationObject *syncObject)
{ delete m_syncObject; m_syncObject = syncObject; }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\extensions\testsetup.h ===
#ifndef CPP_UINT_TESTSETUP_H
#define CPP_UINT_TESTSETUP_H

#ifndef CPPUNIT_GUARDS_H
#include "Guards.h"
#endif

#ifndef CPPUNIT_TESTDECORATOR_H
#include "TestDecorator.h"
#endif

class Test;
class TestResult;


class TestSetup : public TestDecorator 
{
    REFERENCEOBJECT (TestSetup)

public:
                    TestSetup (Test *test) : TestDecorator (test) {}
                    run (TestResult *result);

protected:
    void            setUp () {}
    void            tearDown () {}

};


inline TestSetup::run (TestResult *result)
{ setUp (); TestDecorator::run (result); tearDown (); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\extensions\testdecorator.h ===
#ifndef CPPUNIT_TESTDECORATOR_H
#define CPPUNIT_TESTDECORATOR_H

#ifndef CPPUNIT_GUARDS_H
#include "Guards.h"
#endif

#ifndef CPPUNIT_TEST_H
#include "Test.h"
#endif

class TestResult;

/*
 * A Decorator for Tests
 *
 * Does not assume ownership of the test it decorates
 *
 */ 

class TestDecorator : public Test 
{
    REFERENCEOBJECT (TestDecorator)

public:
                TestDecorator   (Test *test);
                ~TestDecorator  ();

    int         countTestCases  ();
    void        run             (TestResult *result);
    std::string toString        ();

protected:
    Test        *m_test;


};


inline TestDecorator::TestDecorator (Test *test)
{ m_test = test; }


inline TestDecorator::~TestDecorator ()
{}


inline TestDecorator::countTestCases ()
{ return m_test->countTestCases (); }


inline void TestDecorator::run (TestResult *result)
{ m_test->run (result); }


inline std::string TestDecorator::toString ()
{ return m_test->toString (); }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\extensions\repeatedtest.h ===
#ifndef CPPUNIT_REPEATEDTEST_H
#define CPPUNIT_REPEATEDTEST_H

#ifndef CPPUNIT_GUARDS_H
#include "Guards.h"
#endif

#ifndef CPPUNIT_TESTDECORATOR_H
#include "TestDecorator.h"
#endif

class Test;
class TestResult;


/*
 * A decorator that runs a test repeatedly.
 * Does not assume ownership of the test it decorates
 *
 */

class RepeatedTest : public TestDecorator 
{
    REFERENCEOBJECT (RepeatedTest)

public:
                        RepeatedTest (Test *test, int timesRepeat)
                            : TestDecorator (test), m_timesRepeat (timesRepeat) {}

    int                 countTestCases ();
    std::string         toString ();
    void                run (TestResult *result);

private:
    const int           m_timesRepeat;


};


// Counts the number of test cases that will be run by this test.
inline RepeatedTest::countTestCases ()
{ return TestDecorator::countTestCases () * m_timesRepeat; }

// Returns the name of the test instance. 
inline std::string RepeatedTest::toString ()
{ return TestDecorator::toString () + " (repeated)"; }

// Runs a repeated test
inline void RepeatedTest::run (TestResult *result)
{
    for (int n = 0; n < m_timesRepeat; n++) {
        if (result->shouldStop ())
            break;

        TestDecorator::run (result);
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\samples\exampletestcase.h ===
#ifndef CPP_UNIT_EXAMPLETESTCASE_H
#define CPP_UNIT_EXAMPLETESTCASE_H

#include "TestCase.h"
#include "TestSuite.h"
#include "TestCaller.h"

/* 
 * A test case that is designed to produce
 * example errors and failures
 *
 */

class ExampleTestCase : public TestCase
{
protected:

	double			m_value1;
	double			m_value2;

public:
                    ExampleTestCase (std::string name) : TestCase (name) {}

	void			setUp ();
	static Test		*suite ();

protected:
	void			example ();
	void			anotherExample ();
	void			testAdd ();
	void			testDivideByZero ();
	void			testEquals ();

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\framework\extensions\orthodox.h ===
#ifndef CPPUNIT_ORTHODOX_H
#define CPPUNIT_ORTHODOX_H

#ifndef CPPUNIT_TESTCASE_H
#include "TestCase.h"
#endif

/*
 * Orthodox performs a simple set of tests on an arbitary
 * class to make sure that it supports at least the
 * following operations:
 *
 *      default construction    - constructor
 *      equality/inequality     - operator== && operator!=
 *      assignment              - operator=
 *      negation                - operator!
 *      safe passage            - copy construction
 *
 * If operations for each of these are not declared
 * the template will not instantiate.  If it does 
 * instantiate, tests are performed to make sure
 * that the operations have correct semantics.
 *      
 * Adding an orthodox test to a suite is very 
 * easy: 
 * 
 * public: Test *suite ()  {
 *     TestSuite *suiteOfTests = new TestSuite;
 *     suiteOfTests->addTest (new ComplexNumberTest ("testAdd");
 *     suiteOfTests->addTest (new TestCaller<Orthodox<Complex> > ());
 *     return suiteOfTests;
 *  }
 *
 * Templated test cases be very useful when you are want to
 * make sure that a group of classes have the same form.
 *
 * see TestSuite
 */


template <class ClassUnderTest> class Orthodox : public TestCase
{
public:
                    Orthodox () : TestCase ("Orthodox") {}

protected:
    ClassUnderTest  call (ClassUnderTest object);
    void            runTest ();


};


// Run an orthodoxy test
template <class ClassUnderTest> void Orthodox<ClassUnderTest>::runTest ()
{
    // make sure we have a default constructor
    ClassUnderTest   a, b, c;

    // make sure we have an equality operator
    assert (a == b);

    // check the inverse
    b.operator= (a.operator! ());
    assert (a != b);

    // double inversion
    b = !!a;
    assert (a == b);

    // invert again
    b = !a;

    // check calls
    c = a;
    assert (c == call (a));

    c = b;
    assert (c == call (b));

}


// Exercise a call
template <class ClassUnderTest> ClassUnderTest Orthodox<ClassUnderTest>::call (ClassUnderTest object)
{
    return object;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\samples\multicaster.cpp ===
#include "Multicaster.h"

bool Multicaster::subscribe (MulticastObserver *observer, std::string address)
{
    AddressSpace::iterator  it = m_addresses.find (address);

    if (it == m_addresses.end ())
    {
        m_addresses.insert (std::pair<std::string, Subscriptions> (address, Subscriptions ()));       
        it = m_addresses.find (address);

        if (it == m_addresses.end ())
            return false;
    }

    (*it).second.push_back (observer);
    return true;

}


bool Multicaster::unsubscribe (MulticastObserver *observer, std::string address)
{
    AddressSpace::iterator  it = m_addresses.find (address);

    if (it == m_addresses.end ())
        return false;

    unsubscribe ((*it).second, observer);

    return true;

}

bool Multicaster::publish (MulticastObserver *publisher, std::string address, Value value)
{
    AddressSpace::iterator  it = m_addresses.find (address);

    if (it == m_addresses.end ())
        return false;

    Subscriptions& subscriptions = (*it).second;

    for (Subscriptions::iterator subit = subscriptions.begin ();
            subit != subscriptions.end ();
            ++subit) {
 
        MulticastObserver *subscriber = *subit;

        if (subscriber != publisher)
            subscriber->accept (address, value);
        
    } 

    return true;
}


void Multicaster::unsubscribeFromAll (MulticastObserver *observer)
{
    for (AddressSpace::iterator it = m_addresses.begin ();
            it != m_addresses.end ();
            ++it)
        unsubscribe ((*it).second, observer);
}


void Multicaster::unsubscribe (Subscriptions& subscriptions, MulticastObserver *observerToRemove)
{
    for (Subscriptions::iterator it = subscriptions.begin (); it != subscriptions.end (); ) {
        if (*it == observerToRemove)
            it = subscriptions.erase (it);
        else
            it++;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\samples\multicaster.h ===
#ifndef MULTICASTER_H
#define MULTICASTER_H

#include <map>
#include <vector>
#include <string>


class Value 
{
};


class MulticastObserver
{
public:
    virtual void accept (std::string address, Value value) = 0;

};

typedef std::vector<MulticastObserver *>     Subscriptions;
typedef std::map<std::string,Subscriptions>  AddressSpace;



class Multicaster
{
public:
    virtual        ~Multicaster () {}
    virtual bool    subscribe (MulticastObserver *observer, std::string address);
    virtual bool    unsubscribe (MulticastObserver *observer, std::string address);
    virtual bool    publish (MulticastObserver *observer, std::string address, Value value);
    virtual void    unsubscribeFromAll (MulticastObserver *observer);

private:
    AddressSpace    m_addresses;
    void            unsubscribe (Subscriptions& subscriptions, MulticastObserver *observerToRemove);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\textui\exampletestcase.h ===
#ifndef CPP_UNIT_EXAMPLETESTCASE_H
#define CPP_UNIT_EXAMPLETESTCASE_H

#include "TestCase.h"
#include "TestSuite.h"
#include "TestCaller.h"

/* 
 * A test case that is designed to produce
 * example errors and failures
 *
 */

class ExampleTestCase : public TestCase
{
protected:

	double			m_value1;
	double			m_value2;

public:
                    ExampleTestCase (std::string name) : TestCase (name) {}

	void			setUp ();
	static Test		*suite ();

protected:
	void			example ();
	void			anotherExample ();
	void			testAdd ();
	void			testDivideByZero ();
	void			testEquals ();

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\samples\exampletestcase.cpp ===
#include "ExampleTestCase.h"



void ExampleTestCase::example ()
{
	assertDoublesEqual (1.0, 1.1, 0.05);
	assert (1 == 0);
	assert (1 == 1);
}


void ExampleTestCase::anotherExample ()
{
	assert (1 == 2);
}

void ExampleTestCase::setUp ()
{
	m_value1 = 2.0;
	m_value2 = 3.0;
}

void ExampleTestCase::testAdd ()
{
	double result = m_value1 + m_value2;
	assert (result == 6.0);
}


void ExampleTestCase::testDivideByZero ()
{
	int	zero	= 0;
	int result	= 8 / zero;
}


void ExampleTestCase::testEquals ()
{
    std::auto_ptr<long>	l1 (new long (12));
    std::auto_ptr<long>	l2 (new long (12));

	assertLongsEqual (12, 12);
	assertLongsEqual (12L, 12L);
	assertLongsEqual (*l1, *l2);

	assert (12L == 12L);
	assertLongsEqual (12, 13);
	assertDoublesEqual (12.0, 11.99, 0.5);



}



Test *ExampleTestCase::suite ()
{
	TestSuite *testSuite = new TestSuite ("ExampleTestCase");

	testSuite->addTest (new TestCaller <ExampleTestCase> ("anotherExample", anotherExample));
    testSuite->addTest (new TestCaller <ExampleTestCase> ("testAdd", testAdd));
    testSuite->addTest (new TestCaller <ExampleTestCase> ("testDivideByZero", testDivideByZero));
    testSuite->addTest (new TestCaller <ExampleTestCase> ("testEquals", testEquals));

	return testSuite;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\samples\testtest.h ===
#ifndef CPPUNIT_TESTTEST_H
#define CPPUNIT_TESTTEST_H

#ifndef CPPUNIT_TESTCASE_H
#include "TestCase.h"
#endif

#ifndef CPPUNIT_TESTSUITE_H
#include "TestSuite.h"
#endif

#ifndef CPPUNIT_TESTRESULT_H
#include "TestResult.h"
#endif

#ifndef CPPUNIT_TESTCALLER_H
#include "TestCaller.h"
#endif



class TestTest : public TestCase
{
protected:
    TestCase            *m_failure;
    TestCase            *m_error;
    TestCase            *m_success;

public:
                        TestTest (std::string name) : TestCase (name) {}

    void                testFailure ();
    void                testError ();
    void                testSuccess ();
    static Test         *suite ();

    void                setUp ();
    void                tearDown ();

private:
    class FailureTestCase : public TestCase 
    { public: FailureTestCase (std::string name) : TestCase (name) {} 
      protected: void runTest () { assert (false); }; };

    class ErrorTestCase : public TestCase 
    { public: ErrorTestCase (std::string name) : TestCase (name) {} 
    protected: void runTest () { int zero = 0; int result = 8 / zero; }; };

    class SuccessTestCase : public TestCase 
    { public: SuccessTestCase (std::string name) : TestCase (name) {} 
      protected: void runTest () { assert (true); }; };

};

inline void TestTest::setUp ()
{ 
    m_failure   = new FailureTestCase ("failure");
    m_error     = new ErrorTestCase ("error");
    m_success   = new SuccessTestCase ("success");
}

inline void TestTest::tearDown ()
{ 
    delete m_failure;
    delete m_error;
    delete m_success;
}


inline void TestTest::testFailure ()
{
    std::auto_ptr<TestResult>    result (m_failure->run ());

    assert (result->runTests () == 1);
    assert (result->testFailures () == 1);
    assert (result->testErrors () == 0);
    assert (!result->wasSuccessful ());

}

inline void TestTest::testError ()
{
    std::auto_ptr<TestResult> result (m_error->run ());

    assert (result->runTests () == 1);
    assert (result->testFailures () == 0);
    assert (result->testErrors () == 1);
    assert (!result->wasSuccessful ());

}


inline void TestTest::testSuccess ()
{
    std::auto_ptr<TestResult> result (m_success->run ());

    assert (result->runTests () == 1);
    assert (result->testFailures () == 0);
    assert (result->testErrors () == 0);
    assert (result->wasSuccessful ());

}


inline Test *TestTest::suite ()
{
    TestSuite *suite = new TestSuite ("TestTest");

    suite->addTest (new TestCaller<TestTest> ("testFailure", testFailure));
    suite->addTest (new TestCaller<TestTest> ("testError", testError));
    suite->addTest (new TestCaller<TestTest> ("testSuccess", testSuccess));

    return suite;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\samples\testlib\multicastertest.cpp ===
#include "..\MulticasterTest.h"
#include "TestSuite.h"
#include "TestCaller.h"

MulticasterTest::MulticasterTest (std::string name)
: TestCase (name)
{
}


MulticasterTest::~MulticasterTest()
{
}

void MulticasterTest::setUp ()
{
    m_multicaster = new Multicaster;
    m_o1          = new Observer;
    m_o2          = new Observer;
    m_o3          = new Observer;
    m_o4          = new Observer;

}


void MulticasterTest::tearDown ()
{
    delete m_o4;
    delete m_o3;
    delete m_o2;
    delete m_o1;
    delete m_multicaster;
}



void MulticasterTest::testSinglePublish ()
{
    // Make sure we can subscribe and publish to an address
    Value value;

    assert (m_multicaster->subscribe (m_o1, "alpha"));
    assert (m_multicaster->publish (NULL, "alpha", value));

    assert (*m_o1 == Observer ("alpha", 1));

}


void MulticasterTest::testMultipleHomogenousPublish ()
{
    // Make sure we can multicast to an address
    Value value;

    assert (m_multicaster->subscribe (m_o1, "alpha"));
    assert (m_multicaster->subscribe (m_o2, "alpha"));
    assert (m_multicaster->subscribe (m_o3, "alpha"));
    assert (m_multicaster->subscribe (m_o4, "alpha"));
    assert (m_multicaster->publish (NULL, "alpha", value));

    assert (*m_o1 == Observer ("alpha", 1));
    assert (*m_o2 == Observer ("alpha", 1));
    assert (*m_o3 == Observer ("alpha", 1));
    assert (*m_o4 == Observer ("alpha", 1));


}

void MulticasterTest::testMultipleHeterogenousPublish ()
{
    // Make sure we can multicast to several addresses at once
    Value value;

    assert (m_multicaster->subscribe (m_o1, "alpha"));
    assert (m_multicaster->subscribe (m_o2, "beta"));
    assert (m_multicaster->subscribe (m_o3, "alpha"));
    assert (m_multicaster->subscribe (m_o4, "beta"));
    assert (m_multicaster->publish (NULL, "alpha", value));

    assert (*m_o1 == Observer ("alpha", 1));
    assert (*m_o2 == Observer ());
    assert (*m_o3 == Observer ("alpha", 1));
    assert (*m_o4 == Observer ());

}

void MulticasterTest::testSingleUnsubscribe ()
{
    // Make sure we can unsubscribe one of two observers on the same address
    Value value;

    assert (m_multicaster->subscribe (m_o1, "alpha"));
    assert (m_multicaster->subscribe (m_o2, "alpha"));
    assert (m_multicaster->unsubscribe (m_o1, "alpha"));
    assert (m_multicaster->publish (NULL, "alpha", value));

    assert (*m_o1 == Observer ());
    assert (*m_o2 == Observer ("alpha", 1));

}


void MulticasterTest::testMultipleUnsubscribe ()
{
    // Make sure we unsubscribe all occurrences of an observer on the same address
    Value value;

    assert (m_multicaster->subscribe (m_o1, "alpha"));
    assert (m_multicaster->subscribe (m_o1, "alpha"));
    assert (m_multicaster->unsubscribe (m_o1, "alpha"));
    assert (m_multicaster->publish (NULL, "alpha", value));
    assert (*m_o1 == Observer ());

}


void MulticasterTest::testSimpleUnsubscribeAll ()
{
    // Make sure we unsubscribe all occurrences of an observer on all addresses
    Value value;

    assert (m_multicaster->subscribe (m_o1, "alpha"));
    assert (m_multicaster->subscribe (m_o1, "beck"));
    assert (m_multicaster->subscribe (m_o1, "gamma"));
    m_multicaster->unsubscribeFromAll (m_o1);
    assert (m_multicaster->publish (NULL, "alpha", value));
    assert (m_multicaster->publish (NULL, "beck", value));
    assert (m_multicaster->publish (NULL, "gamma", value));
    assert (*m_o1 == Observer ());

}


void MulticasterTest::testComplexUnsubscribeAll ()
{
    // Make sure we unsubscribe all occurrences of an observer on all addresses
    // in the presence of many observers
    Value value;

    assert (m_multicaster->subscribe (m_o1, "alpha"));
    assert (m_multicaster->subscribe (m_o1, "beck"));
    assert (m_multicaster->subscribe (m_o1, "gamma"));
    assert (m_multicaster->subscribe (m_o2, "beck"));
    assert (m_multicaster->subscribe (m_o2, "gamma"));
    assert (m_multicaster->subscribe (m_o2, "demeter"));
    m_multicaster->unsubscribeFromAll (m_o2);

    assert (m_multicaster->publish (NULL, "alpha", value));
    assert (m_multicaster->publish (NULL, "beck", value));
    assert (m_multicaster->publish (NULL, "gamma", value));
    assert (m_multicaster->publish (NULL, "demeter", value));
    assert (*m_o1 == Observer ("gamma", 3));
    assert (*m_o2 == Observer ());

}


Test *MulticasterTest::suite ()
{
    TestSuite *suite = new TestSuite ("Multicaster");
    suite->addTest (new TestCaller<MulticasterTest>("testSinglePublish",testSinglePublish));
    suite->addTest (new TestCaller<MulticasterTest>("testMultipleHomogenousPublish",testMultipleHomogenousPublish));
    suite->addTest (new TestCaller<MulticasterTest>("testMultipleHeterogenousPublish",testMultipleHeterogenousPublish));
    suite->addTest (new TestCaller<MulticasterTest>("testSingleUnsubscribe",testSingleUnsubscribe));
    suite->addTest (new TestCaller<MulticasterTest>("testMultipleUnsubscribe",testMultipleUnsubscribe));
    suite->addTest (new TestCaller<MulticasterTest>("testSimpleUnsubscribeAll",testSimpleUnsubscribeAll));
    suite->addTest (new TestCaller<MulticasterTest>("testComplexUnsubscribeAll",testComplexUnsubscribeAll));

    return suite;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\samples\testlib\multicastertest.h ===
#ifndef MULTICASTERTEST_H
#define MULTICASTERTEST_H

#include "Multicaster.h"

#ifndef CPPUNIT_TESTCASE_H
#include "TestCase.h"
#endif





class MulticasterTest : public TestCase
{
public:
    class Observer : public MulticastObserver
    {
    public:
        int             m_state;
        std::string     m_lastAddressReceived;

                        Observer () : m_state (0) {}
                        Observer (std::string initialAddress, int state) 
                            : m_lastAddressReceived (initialAddress), m_state (state) {}

        virtual void    accept (std::string address, Value Value)
        { m_lastAddressReceived = address; m_state++; }

    };

    Multicaster                 *m_multicaster;
    Observer                    *m_o1;
    Observer                    *m_o2;
    Observer                    *m_o3;
    Observer                    *m_o4;


public:
    void                        setUp ();
    void                        tearDown ();

    void                        testSinglePublish ();
    void                        testMultipleHomogenousPublish ();
    void                        testMultipleHeterogenousPublish ();
    void                        testSingleUnsubscribe ();
    void                        testMultipleUnsubscribe ();
    void                        testSimpleUnsubscribeAll ();
    void                        testComplexUnsubscribeAll ();

public:
                                MulticasterTest (std::string name);
    virtual                     ~MulticasterTest ();

    static Test                 *suite ();

};


inline bool operator== (const MulticasterTest::Observer& o1, const MulticasterTest::Observer& o2)
{ return o1.m_state == o2.m_state && o1.m_lastAddressReceived == o2.m_lastAddressReceived; }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\samples\testlib\autoptrtest.cpp ===
#include "autoptrtest.h"
#include "TestSuite.h"
#include "TestCaller.h"
#include <scopeguard.h>
autobufferTest::autobufferTest(std::string name)
: TestCase (name)
{
}


autobufferTest::~autobufferTest()
{
}

void autobufferTest::setUp ()
{

}


void autobufferTest::tearDown ()
{
}



void autobufferTest::testDelete()
{
  memory_leaks l;
  {
  char *p = new char[10];
  wmilib::auto_buffer<char> ap(p,10);
  assert(ap.size()==10);
  assert(ap.get()==p);
  p[0] = 1;
  assert(ap[0]==1);
  }
  assert(!l.hasleaks());
  
  {
  wmilib::auto_buffer<char> up;
  {
    char *p = new char[10];
    wmilib::auto_buffer<char> ap(p,10);
    up = ap;
    assert(up.size()==10);
    assert(up.get()==p);
    assert(ap.get()==0);
    assert(ap.size()==-1);
  }
  }
  assert(!l.hasleaks());

}



Test *autobufferTest::suite ()
{
    TestSuite *suite = new TestSuite ("autobuffer");
    suite->addTest (new TestCaller<autobufferTest>("testDelete",testDelete));
    return suite;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\samples\testlib\autoptrtest.h ===
#pragma once
#include "autoptr.h"
#ifndef CPPUNIT_TESTCASE_H
#include "TestCase.h"
#endif





class autobufferTest : public TestCase
{
public:


public:
    void                        setUp ();
    void                        tearDown ();

    void                        testDelete ();

public:
    autobufferTest (std::string name);
    virtual ~autobufferTest();

    static Test *suite ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\textui\exampletestcase.cpp ===
#include "ExampleTestCase.h"



void ExampleTestCase::example ()
{
	assertDoublesEqual (1.0, 1.1, 0.05);
	assert (1 == 0);
	assert (1 == 1);
}


void ExampleTestCase::anotherExample ()
{
	assert (1 == 2);
}

void ExampleTestCase::setUp ()
{
	m_value1 = 2.0;
	m_value2 = 3.0;
}

void ExampleTestCase::testAdd ()
{
	double result = m_value1 + m_value2;
	assert (result == 6.0);
}


void ExampleTestCase::testDivideByZero ()
{
	int	zero	= 0;
	int result	= 8 / zero;
}


void ExampleTestCase::testEquals ()
{
    std::auto_ptr<long>	l1 (new long (12));
    std::auto_ptr<long>	l2 (new long (12));

	assertLongsEqual (12, 12);
	assertLongsEqual (12L, 12L);
	assertLongsEqual (*l1, *l2);

	assert (12L == 12L);
	assertLongsEqual (12, 13);
	assertDoublesEqual (12.0, 11.99, 0.5);



}



Test *ExampleTestCase::suite ()
{
	TestSuite *testSuite = new TestSuite ("ExampleTestCase");

	testSuite->addTest (new TestCaller <ExampleTestCase> ("anotherExample", anotherExample));
    testSuite->addTest (new TestCaller <ExampleTestCase> ("testAdd", testAdd));
    testSuite->addTest (new TestCaller <ExampleTestCase> ("testDivideByZero", testDivideByZero));
    testSuite->addTest (new TestCaller <ExampleTestCase> ("testEquals", testEquals));

	return testSuite;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\cppunit\textui\main.cpp ===
/*
 * A command line based tool to run tests.
 * TestRunner expects as its only argument the name of a TestCase class.
 * TestRunner prints out a trace as the tests are executed followed by a
 * summary at the end.
 *
 * You can add to the tests that the TestRunner knows about by 
 * making additional calls to "addTest (...)" in main.
 *
 * Here is the synopsis:
 *
 * TestRunner [-wait] ExampleTestCase
 *
 */

#include "TestRunner.h"

TestRunner runner;
void populateRunner(TestRunner&);

int __cdecl main (int ac, char **av)
{
    populateRunner(runner);
    runner.run (ac, av);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\utility.cpp ===
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500

#include <wbemcli.h>
#include <wbemprov.h>
#include <atlbase.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>

#include <genlex.h>
#include <qllex.h>
#include <ql.h>
#include <ntdsapi.h>

#include "objpath.h"
#include "iads.h"
#include "adshlp.h"

#include "Utility.h"

#include <SDDL.H>


BSTR
  // **** misc names

  g_bstrEmptyString = NULL,
  g_bstrEmptyDate = NULL,

  // **** AD schema names

  g_bstrADAuthor = NULL,
  g_bstrADChangeDate = NULL,
  g_bstrADClassDefinition = NULL,
  g_bstrADCreationDate = NULL,
  g_bstrADDescription = NULL,
  g_bstrADIntDefault = NULL,
  g_bstrADInt8Default = NULL,
  g_bstrADID = NULL,
  g_bstrADIntMax = NULL,
  g_bstrADInt8Max = NULL,
  g_bstrADIntMin = NULL,
  g_bstrADInt8Min = NULL,
  g_bstrADIntValidValues = NULL,
  g_bstrADName = NULL,
  g_bstrADNormalizedClass = NULL,
  g_bstrADObjectClass = NULL,
  g_bstrADParam2 = NULL,
  g_bstrADPolicyType = NULL,
  g_bstrADPropertyName = NULL,
  g_bstrADQuery = NULL,
  g_bstrADQueryLanguage = NULL,
  g_bstrADSourceOrganization = NULL,
  g_bstrADStringDefault = NULL,
  g_bstrADStringValidValues = NULL,
  g_bstrADTargetClass = NULL,
  g_bstrADTargetNameSpace = NULL,
  g_bstrADTargetObject = NULL,
  g_bstrADTargetPath = NULL,
  g_bstrADTargetType = NULL,

  // **** AD class names

  g_bstrADClassMergeablePolicy = NULL,
  g_bstrADClassRangeParam = NULL,
  g_bstrADClassRangeSint32 = NULL,
  g_bstrADClassRangeUint32 = NULL,
  g_bstrADClassRangeReal = NULL,
  g_bstrADClassParamUnknown = NULL,
  g_bstrADClassSetSint32 = NULL,
  g_bstrADClassSetUint32 = NULL,
  g_bstrADClassSetString = NULL,
  g_bstrADClassSimplePolicy = NULL,
  g_bstrADClassRule = NULL,
  g_bstrADClassSom = NULL,
  g_bstrADClassPolicyType = NULL,
  g_bstrADClassWMIGPO = NULL,

  // **** CIM schema names

  g_bstrAuthor = NULL,
  g_bstrChangeDate = NULL,
  g_bstrClassDefinition = NULL,
  g_bstrCreationDate = NULL,
  g_bstrDefault = NULL,
  g_bstrDescription = NULL,
  g_bstrDsPath = NULL,
  g_bstrDomain = NULL,
  g_bstrID = NULL,
  g_bstrMax = NULL,
  g_bstrMin = NULL,
  g_bstrName = NULL,
  g_bstrPolicyType = NULL,
  g_bstrPropertyName = NULL,
  g_bstrQuery = NULL,
  g_bstrQueryLanguage = NULL,
  g_bstrRangeSettings = NULL,
  g_bstrRules = NULL,
  g_bstrSourceOrganization = NULL,
  g_bstrTargetClass = NULL,
  g_bstrTargetNameSpace = NULL,
  g_bstrTargetObject = NULL,
  g_bstrTargetPath = NULL,
  g_bstrTargetType = NULL,
  g_bstrValidValues = NULL,

  // **** CIM class names

  g_bstrClassMergeablePolicy = NULL,
  g_bstrClassRangeParam = NULL,
  g_bstrClassRangeSint32 = NULL,
  g_bstrClassRangeUint32 = NULL,
  g_bstrClassRangeReal = NULL,
  g_bstrClassSetSint32 = NULL,
  g_bstrClassSetUint32 = NULL,
  g_bstrClassSetString = NULL,
  g_bstrClassSimplePolicy = NULL,
  g_bstrClassRule = NULL,
  g_bstrClassSom = NULL,
  g_bstrClassPolicyType = NULL,
  g_bstrClassWMIGPO = NULL;

void InitGlobalNames(void)
{
  // **** misc names

  g_bstrEmptyString =          SysAllocString(L" ");
  g_bstrEmptyDate =            SysAllocString(L"00000000000000.000000-000");

  // **** AD schema names

  g_bstrADAuthor =             SysAllocString(L"msWMI-Author");
  g_bstrADChangeDate =         SysAllocString(L"msWMI-ChangeDate");
  g_bstrADClassDefinition =    SysAllocString(L"msWMI-ClassDefinition"),
  g_bstrADCreationDate =       SysAllocString(L"msWMI-CreationDate");
  g_bstrADDescription =        SysAllocString(L"msWMI-Parm1");
  g_bstrADIntDefault =         SysAllocString(L"msWMI-IntDefault");
  g_bstrADInt8Default =        SysAllocString(L"msWMI-Int8Default");
  g_bstrADID =                 SysAllocString(L"msWMI-ID");
  g_bstrADIntMax =             SysAllocString(L"msWMI-IntMax");
  g_bstrADInt8Max =            SysAllocString(L"msWMI-Int8Max");
  g_bstrADIntMin =             SysAllocString(L"msWMI-IntMin");
  g_bstrADInt8Min =            SysAllocString(L"msWMI-Int8Min");
  g_bstrADIntValidValues =     SysAllocString(L"msWMI-IntValidValues");
  g_bstrADName =               SysAllocString(L"msWMI-Name");
  g_bstrADNormalizedClass =    SysAllocString(L"msWMI-NormalizedClass");
  g_bstrADObjectClass =        SysAllocString(L"objectClass"),
  g_bstrADParam2 =             SysAllocString(L"msWMI-Parm2"),
  g_bstrADPolicyType =         SysAllocString(L"msWMI-PolicyType");
  g_bstrADPropertyName =       SysAllocString(L"msWMI-PropertyName");
  g_bstrADQuery =              SysAllocString(L"msWMI-Query"),
  g_bstrADQueryLanguage =      SysAllocString(L"msWMI-QueryLanguage"),
  g_bstrADStringDefault =      SysAllocString(L"msWMI-StringDefault");
  g_bstrADStringValidValues =  SysAllocString(L"msWMI-StringValidValues");
  g_bstrADSourceOrganization = SysAllocString(L"msWMI-SourceOrganization");
  g_bstrADTargetClass =        SysAllocString(L"msWMI-TargetClass");
  g_bstrADTargetNameSpace =    SysAllocString(L"msWMI-TargetNameSpace");
  g_bstrADTargetObject =       SysAllocString(L"msWMI-TargetObject"),
  g_bstrADTargetPath =         SysAllocString(L"msWMI-TargetPath"),
  g_bstrADTargetType =         SysAllocString(L"msWMI-TargetType"),

  // **** AD class names

  g_bstrADClassMergeablePolicy = SysAllocString(L"msWMI-MergeablePolicyTemplate");
  g_bstrADClassRangeParam =      SysAllocString(L"msWMI-RangeParam");
  g_bstrADClassRangeSint32 =     SysAllocString(L"msWMI-IntRangeParam");
  g_bstrADClassRangeUint32 =     SysAllocString(L"msWMI-UintRangeParam");
  g_bstrADClassRangeReal =       SysAllocString(L"msWMI-RealRangeParam");
  g_bstrADClassParamUnknown =    SysAllocString(L"msWMI-UnknownRangeParam");
  g_bstrADClassSetSint32 =       SysAllocString(L"msWMI-IntSetParam");
  g_bstrADClassSetUint32 =       SysAllocString(L"msWMI-UintSetParam");
  g_bstrADClassSetString =       SysAllocString(L"msWMI-StringSetParam");
  g_bstrADClassSimplePolicy =    SysAllocString(L"msWMI-SimplePolicyTemplate");
  g_bstrADClassRule =            SysAllocString(L"msWMI-Rule");
  g_bstrADClassSom =             SysAllocString(L"msWMI-SOM");
  g_bstrADClassPolicyType =      SysAllocString(L"msWMI-PolicyType");
  g_bstrADClassWMIGPO =          SysAllocString(L"msWMI-WMIGPO");

  // **** CIM Attribute Names

  g_bstrAuthor =             SysAllocString(L"Author");
  g_bstrChangeDate =         SysAllocString(L"ChangeDate");
  g_bstrClassDefinition =    SysAllocString(L"ClassDefinition"),
  g_bstrCreationDate =       SysAllocString(L"CreationDate");
  g_bstrDefault =            SysAllocString(L"Default");
  g_bstrDescription =        SysAllocString(L"Description");
  g_bstrDsPath =             SysAllocString(L"DsPath");
  g_bstrDomain =             SysAllocString(L"Domain");
  g_bstrID =                 SysAllocString(L"ID");
  g_bstrMax =                SysAllocString(L"Max");
  g_bstrMin =                SysAllocString(L"Min");
  g_bstrName =               SysAllocString(L"Name");
  g_bstrPolicyType =         SysAllocString(L"PolicyType");
  g_bstrPropertyName =       SysAllocString(L"PropertyName");
  g_bstrQuery =              SysAllocString(L"query");
  g_bstrQueryLanguage =      SysAllocString(L"QueryLanguage");
  g_bstrRangeSettings =      SysAllocString(L"RangeSettings");
  g_bstrRules =              SysAllocString(L"Rules");
  g_bstrSourceOrganization = SysAllocString(L"SourceOrganization");
  g_bstrTargetClass =        SysAllocString(L"TargetClass"),
  g_bstrTargetNameSpace =    SysAllocString(L"TargetNamespace");
  g_bstrTargetObject =       SysAllocString(L"TargetObject"),
  g_bstrTargetPath =         SysAllocString(L"TargetPath"),
  g_bstrTargetType =         SysAllocString(L"TargetType"),
  g_bstrValidValues =        SysAllocString(L"ValidValues");

  // **** CIM class names

  g_bstrClassMergeablePolicy =        SysAllocString(L"MSFT_MergeablePolicyTemplate");
  g_bstrClassRangeParam =    SysAllocString(L"MSFT_RangeParam");
  g_bstrClassRangeSint32 =   SysAllocString(L"MSFT_SintRangeParam");
  g_bstrClassRangeUint32 =   SysAllocString(L"MSFT_UintRangeParam");
  g_bstrClassRangeReal =     SysAllocString(L"MSFT_RealRangeParam");
  g_bstrClassSetSint32 =     SysAllocString(L"MSFT_SintSetParam");
  g_bstrClassSetUint32 =     SysAllocString(L"MSFT_UintSetParam");
  g_bstrClassSetString =     SysAllocString(L"MSFT_StringSetParam");
  g_bstrClassSimplePolicy =  SysAllocString(L"MSFT_SimplePolicyTemplate");
  g_bstrClassRule =          SysAllocString(L"MSFT_Rule");
  g_bstrClassSom =           SysAllocString(L"MSFT_SomFilter");
  g_bstrClassPolicyType =    SysAllocString(L"MSFT_PolicyType");
  g_bstrClassWMIGPO =        SysAllocString(L"MSFT_WMIGPO");
}

void FreeGlobalNames(void)
{
  // **** misc names

  SysFreeString(g_bstrEmptyString);
  SysFreeString(g_bstrEmptyDate);

  // **** AD schema names

  SysFreeString(g_bstrADAuthor);
  SysFreeString(g_bstrADChangeDate);
  SysFreeString(g_bstrADClassDefinition);
  SysFreeString(g_bstrADCreationDate);
  SysFreeString(g_bstrADIntDefault);
  SysFreeString(g_bstrADInt8Default);
  SysFreeString(g_bstrADID);
  SysFreeString(g_bstrADIntMax);
  SysFreeString(g_bstrADInt8Max);
  SysFreeString(g_bstrADIntMin);
  SysFreeString(g_bstrADInt8Min);
  SysFreeString(g_bstrADIntValidValues);
  SysFreeString(g_bstrADName);
  SysFreeString(g_bstrADNormalizedClass);
  SysFreeString(g_bstrADObjectClass);
  SysFreeString(g_bstrADParam2),
  SysFreeString(g_bstrADPolicyType);
  SysFreeString(g_bstrADPropertyName);
  SysFreeString(g_bstrADQuery);
  SysFreeString(g_bstrADQueryLanguage);
  SysFreeString(g_bstrADStringDefault);
  SysFreeString(g_bstrADStringValidValues);
  SysFreeString(g_bstrADSourceOrganization);
  SysFreeString(g_bstrADTargetClass);
  SysFreeString(g_bstrADTargetNameSpace);
  SysFreeString(g_bstrADTargetObject);
  SysFreeString(g_bstrADTargetPath);
  SysFreeString(g_bstrADTargetType);

  // **** AD class names

  SysFreeString(g_bstrADClassMergeablePolicy);
  SysFreeString(g_bstrADClassRangeParam);
  SysFreeString(g_bstrADClassRangeSint32);
  SysFreeString(g_bstrADClassRangeUint32);
  SysFreeString(g_bstrADClassRangeReal);
  SysFreeString(g_bstrADClassParamUnknown);
  SysFreeString(g_bstrADClassSetSint32);
  SysFreeString(g_bstrADClassSetUint32);
  SysFreeString(g_bstrADClassSetString);
  SysFreeString(g_bstrADClassSimplePolicy);
  SysFreeString(g_bstrADClassRule);
  SysFreeString(g_bstrADClassSom);
  SysFreeString(g_bstrADClassPolicyType);
  SysFreeString(g_bstrADClassWMIGPO);

  // **** CIM Attribute Names

  SysFreeString(g_bstrAuthor);
  SysFreeString(g_bstrChangeDate);
  SysFreeString(g_bstrClassDefinition);
  SysFreeString(g_bstrCreationDate);
  SysFreeString(g_bstrDefault);
  SysFreeString(g_bstrDsPath);
  SysFreeString(g_bstrDomain);
  SysFreeString(g_bstrID);
  SysFreeString(g_bstrMax);
  SysFreeString(g_bstrMin);
  SysFreeString(g_bstrName);
  SysFreeString(g_bstrPolicyType);
  SysFreeString(g_bstrPropertyName);
  SysFreeString(g_bstrQuery);
  SysFreeString(g_bstrQueryLanguage);
  SysFreeString(g_bstrRangeSettings);
  SysFreeString(g_bstrRules);
  SysFreeString(g_bstrSourceOrganization);
  SysFreeString(g_bstrTargetClass);
  SysFreeString(g_bstrTargetNameSpace);
  SysFreeString(g_bstrTargetObject);
  SysFreeString(g_bstrTargetPath);
  SysFreeString(g_bstrTargetType);
  SysFreeString(g_bstrValidValues);

  // **** CIM class names

  SysFreeString(g_bstrClassMergeablePolicy);
  SysFreeString(g_bstrClassRangeParam);
  SysFreeString(g_bstrClassRangeSint32);
  SysFreeString(g_bstrClassRangeUint32);
  SysFreeString(g_bstrClassRangeReal);
  SysFreeString(g_bstrClassSetSint32);
  SysFreeString(g_bstrClassSetUint32);
  SysFreeString(g_bstrClassSetString);
  SysFreeString(g_bstrClassSimplePolicy);
  SysFreeString(g_bstrClassRule);
  SysFreeString(g_bstrClassSom);
  SysFreeString(g_bstrClassPolicyType);
  SysFreeString(g_bstrClassWMIGPO);
}

// TODO: attempt to create namespace if not available.
HRESULT GetNamespace(BSTR namespaceName, IWbemServices*& pNamespace, bool bInProc)
{
    HRESULT hr = WBEM_E_FAILED;

    IWbemLocator* pLoc = NULL;

	if (FAILED(hr = CoCreateInstance(bInProc ? CLSID_WbemAdministrativeLocator : CLSID_WbemLocator, 
        0, CLSCTX_ALL, IID_IWbemLocator,
         (LPVOID*) &pLoc)))
		ERRORTRACE((LOG_ESS, "Could not create wbem locator (0x%08X)\n", hr));
	else
	{
		DEBUGTRACE((LOG_ESS, "Created Locator\n"));
        if (FAILED(hr = pLoc->ConnectServer(namespaceName, NULL,NULL, 0,0,0,0,&pNamespace)))
            ERRORTRACE((LOG_ESS, "ConnectServer(%S) failed (0x%08X)\n", namespaceName, hr));
		else
			DEBUGTRACE((LOG_ESS, "ConnectServer(%S) succeeded (0x%08X)\n", namespaceName, hr));
			
		pLoc->Release();
	}

	return hr;
}

// make sure that the ID property of pObj has a value
// assumes property is a BSTR!
// will generate GUID if not
// if pName == NULL, assumes property name is "ID"
// returns WBEM_S_NO_ERROR if ID generated
//         WBEM_S_FALSE if no ID generated (already has a value)
//         WBEM_E_NOT_FOUND if ID property is not
//         some error if error of some sort
HRESULT EnsureID(IWbemClassObject* pObj, WCHAR* pName)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    WCHAR* pKeyName = (pName == NULL) ? L"ID" : pName;

    CComVariant
      v;

    if (SUCCEEDED(hr = pObj->Get(pKeyName, 0, &v, NULL, NULL)))
    {
        if ((v.vt == VT_NULL) ||  (v.bstrVal == NULL))
        {         
            GUID guid;

            CoCreateGuid(&guid);
            
            BSTR guidStr = SysAllocStringByteLen(NULL, 129);
            if (guidStr == NULL)
                hr = WBEM_E_OUT_OF_MEMORY;
            else
            {
                StringFromGUID2(guid, guidStr, 128);

                VARIANT v;
                VariantInit(&v);
                v.vt = VT_BSTR;
                v.bstrVal = guidStr;
                
                pObj->Put(pKeyName, 0, &v, NULL);

                SysFreeString(guidStr);
            }
        }
        else
        {
            VariantClear(&v);
            hr = WBEM_S_FALSE;
        }
    }

    return hr;
}

void Init_AdsAttrInfo(ADS_ATTR_INFO *pAdsAttrInfo, 
                        LPWSTR bstrName, 
                        DWORD control, 
                        ADSTYPE type, 
                        PADSVALUE pVals, 
                        DWORD nVals)
{
  unsigned long c1;

  if(NULL == pAdsAttrInfo) return;

  pAdsAttrInfo->pszAttrName = bstrName;
  pAdsAttrInfo->dwControlCode = control;
  pAdsAttrInfo->dwADsType = type;

  if(nVals > 0)
  {
    pAdsAttrInfo->dwNumValues = nVals;

    if(NULL != pVals)
    {
      pAdsAttrInfo->pADsValues = pVals;
    }
    else
    {
      throw L"could not init ADS_ATTR_INFO structure";
    }

    for(c1 = 0; c1 < nVals; c1++)
    { 
      (pAdsAttrInfo->pADsValues + c1)->dwType = type;
    }
  }
  else
  {
    pAdsAttrInfo->dwNumValues = 0;
    pAdsAttrInfo->pADsValues = NULL;
  }
}

HRESULT DomainNameFromDistName(QString &DomainName, QString &DistName)
{
  UINT
    lDCStart = 0,
    lDCEnd = 0;

  while(QString::NOT_FOUND != DistName.NextPattern(lDCEnd, L"DC=", lDCStart))
  {
    if(QString::NOT_FOUND != DistName.NextChar(lDCStart, L",", lDCEnd))
      DomainName.SubStrCat(DistName, lDCStart + 3, lDCEnd - 1) << L".";
    else
    {
      lDCEnd = DistName.StringLength();
      DomainName.SubStrCat(DistName, lDCStart + 3, lDCEnd);
    }
  }

  return WBEM_S_NO_ERROR;
}

HRESULT DistNameFromDomainName(QString &DomainName, QString &DistName)
{
  if(0 == DomainName.StringLength())
    return WBEM_E_FAILED;

  UINT
    lStart = 0,
    lEnd = 0;

  while(QString::NOT_FOUND != DomainName.NextChar(lStart, L".", lEnd))
  {
    if(lEnd) 
    {
      DistName << L"DC=";

      DistName.SubStrCat(DomainName, lStart, lEnd - 1);
      lStart = lEnd + 1;

      DistName << L",";
    }
  }

  if(0 < lEnd)
  {
    DistName << L"DC=";
    DistName.SubStrCat(DomainName, lStart, DomainName.StringLength());
  }

  return WBEM_S_NO_ERROR;
}

IADsContainer *CreateContainer(BSTR bstrPath, BSTR bstrName)
{
  HRESULT hres;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IDirectoryObject>
    pDirObj;

  IADsContainer
    *pADsContainer = NULL;

  ADSVALUE
    AdsValue[2];

  ADS_ATTR_INFO
    attrInfo[] = 
    { 
      { g_bstrADObjectClass, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING, &AdsValue[0], 1},
      { L"ntSecurityDescriptor", ADS_ATTR_UPDATE, ADSTYPE_NT_SECURITY_DESCRIPTOR, &AdsValue[1], 1}
    };

  CNtSecurityDescriptor
    cSD;

  hres = CreateDefaultSecurityDescriptor(cSD);

  if (FAILED(hres))
  {
       ERRORTRACE((LOG_ESS, "POLICMAN: could not create security descriptor\n"));
       return NULL;
  }

  AdsValue[0].dwType = ADSTYPE_CASE_IGNORE_STRING;
  AdsValue[0].CaseIgnoreString = L"Container";

  AdsValue[1].dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
  AdsValue[1].SecurityDescriptor.dwLength = cSD.GetSize();
  AdsValue[1].SecurityDescriptor.lpValue = (LPBYTE)cSD.GetPtr();

  hres = ADsGetObject(bstrPath, IID_IDirectoryObject, (void**) &pDirObj);
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not get AD object: %S, 0x%08X\n", bstrPath, hres));
    return NULL;
  }
  else
  {
    hres = pDirObj->CreateDSObject(bstrName, attrInfo, 2, &pDisp);
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: could not create AD object: %S, 0x%08X\n", bstrName, hres));
      return NULL;
    }

    hres = pDisp->QueryInterface(IID_IADsContainer, (void**)&pADsContainer);
  }

  return pADsContainer;
}

IADsContainer *CreateContainers(QString &pDomain, QString &pPath)
{
  HRESULT
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1;

  IADsContainer 
    *pADsContainer_return = NULL;

  CComPtr<IADsContainer>
    pADsContainer,
    pADsContainer2;

  UINT
    iIndex = 0,
    iIndex2 = 0;

  CComPtr<IDispatch>
    pDisp;

  // **** get root of domain

  hres = ADsGetObject(QString(L"LDAP://") << pDomain, IID_IADsContainer, (void**)&pADsContainer);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not connect to domain %S, 0x%08X\n", pDomain, hres));
    return NULL;
  }

  // **** find most derived element of pPath

  while(QString::OK == pPath.NextPattern(iIndex, L"CN=", iIndex))
  {
    hres = pADsContainer->GetObject(NULL, &pPath[iIndex], &pDisp);
    if(FAILED(hres) || (pDisp == NULL)) 
      iIndex += 1;
    else
      break;
  }

  if(pDisp == NULL)
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (IADs::GetObject) could not get container %S\n", pDomain));
    return NULL;
  }

  // **** now, backtrack up pPath creating each container as we go

  while(QString::OK == pPath.PrevPattern(iIndex, L"CN=", iIndex))
  {
    if(NULL != pADsContainer_return)
      pADsContainer_return->Release();
    pADsContainer_return = NULL;

    pPath.NextChar(iIndex, L",", iIndex2);
    
    // **** isolate name to create

    pPath[iIndex2] = L'\0';
    pADsContainer_return = CreateContainer(QString(L"LDAP://") << &pPath[iIndex2 + 1] << L"," << pDomain, &pPath[iIndex]);
    pPath[iIndex2] = L',';

    if(pADsContainer_return == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not get AD object: %S, 0x%08X\n", (wchar_t*)pPath, hres));
      return NULL;
    }
  }

  return pADsContainer_return;
}

HRESULT ADSIToWMIErrorCodes(HRESULT hresAD)
{
  if(((hresAD & 0x800FF000) == 0x80041000) ||
     ((hresAD & 0x800FF000) == 0x80042000) ||
     ((hresAD & 0x800FF000) == 0x80044000)) return hresAD;
  
  if(hresAD != WBEM_S_NO_ERROR) switch(hresAD)
  {
    case S_ADS_ERRORSOCCURRED          : return WBEM_E_FAILED ;
    case S_ADS_NOMORE_ROWS             : return WBEM_S_NO_MORE_DATA ;
    case S_ADS_NOMORE_COLUMNS          : return WBEM_S_NO_MORE_DATA ;

    case E_ADS_UNKNOWN_OBJECT          : return WBEM_E_NOT_FOUND ;
    case E_ADS_OBJECT_EXISTS           : return WBEM_E_ALREADY_EXISTS;

    case 0x80070005  : return WBEM_E_ACCESS_DENIED; // LDAP_INSUFFICIENT_RIGHTS
    case 0x80072030  : return WBEM_E_NOT_FOUND ; // LDAP_NO_SUCH_OBJECT
    case 0x8007200a  : return WBEM_E_FAILED;  //LDAP_NO_SUCH_ATTRIBUTE

    default : return WBEM_E_FAILED;
  }

  return WBEM_S_NO_ERROR;
}

int IsEmpty(VARIANT &v)
{
  if((v.vt == VT_NULL) || (v.vt == VT_EMPTY)) return 1;

  if((v.vt == VT_UNKNOWN) || (v.vt == VT_DISPATCH))
  { if(NULL == v.punkVal)
      return 1;
  }

  return 0;
}

// Creates the default security descriptor for WMI policy *containers*
// Full Control - Domain & Enterprise Admins & GPO Creator-Owner group
// Read Access  - authenticated users
// assumes input pointer is NULL or uninitialized or some such
HRESULT CreateDefaultSecurityDescriptor(CNtSecurityDescriptor& cSD)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    CNtSid sidWorld(L"Authenticated Users");

    CNtSid sidSystem(L"System");
    CNtSid sidAdmins(L"Domain Admins");
    CNtSid sidEnterpriseAdmins(L"Enterprise Admins");
    CNtSid sidAdministrators(L"Administrators");        
    CNtSid sidGPO(L"Group Policy Creator Owners");
    CNtSid sidOwner(L"CREATOR OWNER");

    // hmmm - does six aces beat four aces?
    // a smith and wesson beats four of a kind...
    DWORD full = FULL_CONTROL | DS_GENERIC_ALL;
    CNtAce aceEnterpriseAdmins(full, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE, sidEnterpriseAdmins);
    CNtAce            aceOwner(full, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE | ADS_ACEFLAG_INHERIT_ONLY_ACE, sidOwner);
    CNtAce     aceAdminsObject(full, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE | ADS_ACEFLAG_INHERIT_ONLY_ACE, sidAdmins);    
    

    DWORD write = DS_GENERIC_READ | DS_GENERIC_WRITE | ACTRL_DS_CREATE_CHILD;
    CNtAce         aceAdmins(write | ACTRL_DS_DELETE_CHILD, ACCESS_ALLOWED_ACE_TYPE, 0, sidAdmins);    
    CNtAce aceAdministrators(write,                         ACCESS_ALLOWED_ACE_TYPE, 0, sidAdministrators);    
    CNtAce            aceGPO(write,                         ACCESS_ALLOWED_ACE_TYPE, 0, sidGPO);
    
    DWORD read = DS_GENERIC_READ;
    CNtAce  aceWorld(read, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE, sidWorld);
    CNtAce aceSystem(read, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE, sidSystem);

    CNtAcl ackl;
    if (!ackl.AddAce(&aceWorld))            hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceSystem))           hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceAdmins))           hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceEnterpriseAdmins)) hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceAdministrators))   hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceGPO))              hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceOwner))            hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceAdminsObject))     hr = WBEM_E_FAILED;

    if (!ackl.Resize(CNtAcl::MinimumSize))  hr = WBEM_E_FAILED;

    if (!cSD.SetDacl(&ackl)) hr = WBEM_E_FAILED;
    if (!cSD.SetOwner(&sidEnterpriseAdmins)) hr = WBEM_E_FAILED;

    if (!SetSecurityDescriptorControl(cSD.GetPtr(), SE_DACL_PROTECTED, SE_DACL_PROTECTED)) hr = WBEM_E_FAILED;

    return hr;
}


// given an input security descriptor
// add owner from thread
HRESULT GetOwnerSecurityDescriptor(CNtSecurityDescriptor& SD)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CNtSid sidOwner(CNtSid::CURRENT_THREAD);
    if (!SD.SetOwner(&sidOwner)) hr = WBEM_E_FAILED;

    
    /***********************
    CNtSid sidOwner(CNtSid::CURRENT_THREAD);
    CNtAcl ackl;

    if (!SD.GetDacl(ackl)) hr = WBEM_E_FAILED;
    if (!SD.SetOwner(&sidOwner)) hr = WBEM_E_FAILED;

    if (SUCCEEDED(hr))
    {
        CNtSid sidGPO(L"Group Policy Creator Owners");

        int nAces = ackl.GetNumAces();
        CNtAce* pAce = NULL;
        CNtSid* pSid = NULL;

        // walk through all the aces, find GPO owner creators & kill them
        for (int i = 0; i < nAces; i++)
            if ((pAce = ackl.GetAce(i)) && (pSid = pAce->GetSid()))
            {
                if ((*pSid == sidGPO) && (pAce->GetType() == ACCESS_ALLOWED_ACE_TYPE))
                {
                    ackl.DeleteAce(i);   

                    delete pAce;
                    delete pSid;
                    break;
                }

                delete pAce;
                delete pSid;
            }
            else
            // 
            {
                hr = WBEM_E_CRITICAL_ERROR;
                break;
            }
    }

    if (SUCCEEDED(hr))
    {
        CNtAce aceOwner(FULL_CONTROL, ACCESS_ALLOWED_ACE_TYPE, 0, sidOwner);

        if (ackl.AddAce(&aceOwner) && SD.SetDacl(&ackl))
            hr = WBEM_S_NO_ERROR;
        else
            hr = WBEM_E_FAILED;


    }
    ******************/
    
   return hr;
}

PSECURITY_DESCRIPTOR GetADSecurityDescriptor(IDirectoryObject *pIDirectoryObject)
{
  HRESULT 
    hres;

  LPWSTR
    pAttrNames[] = { L"ntSecurityDescriptor" };

  ADsStruct<ADS_ATTR_INFO>
    pAttrInfo;

  PSECURITY_DESCRIPTOR
    pSD = NULL;

  DWORD
    dwReturn,
    dwLength;

  hres = pIDirectoryObject->GetObjectAttributes(pAttrNames, 1, &pAttrInfo, &dwReturn);
  
  if(SUCCEEDED(hres) && (1 == dwReturn))
  {
    dwLength = pAttrInfo->pADsValues->SecurityDescriptor.dwLength;

    pSD = new BYTE[dwLength];
    if(NULL == pSD) return NULL;

    ZeroMemory(pSD, dwLength);

    memcpy(pSD, pAttrInfo->pADsValues->SecurityDescriptor.lpValue, dwLength);
  }
  
  return pSD;
}

HRESULT GetADContainerInDomain(wchar_t *wcsDomain, wchar_t *wcsPath, IDirectorySearch **pObj)
{
  HRESULT
    hres = WBEM_E_FAILED;

  QString
    DomainDistName,
    LDAPPath(L"LDAP://");

  // **** check args

  if(NULL == pObj)
    return WBEM_E_FAILED;

  // **** build Path

  hres = DistNameFromDomainName(QString(wcsDomain), DomainDistName);

  LDAPPath << wcsPath << L"," << DomainDistName;

  // **** attempt to connect to container in AD

  hres = ADsGetObject(LDAPPath, IID_IDirectorySearch, (void**)pObj);

  return ADSIToWMIErrorCodes(hres);
}

HRESULT ExecuteWQLQuery(wchar_t *wcsPath, 
                        wchar_t *wcsWQLStmt, 
                        IWbemObjectSink *pResponseHandler,
                        IWbemServices *pWbemServices, 
                        BSTR bstrADClassName,
                        functTyp pf_ADToCIM)
{
  HRESULT
    hres = WBEM_E_FAILED;

  int
    nRes;

  QL_LEVEL_1_TOKEN
    *pToken = NULL;

  CComPtr<IDirectorySearch>
    pDirectorySearch;

  QString
    LDAPQuery;

  wchar_t
    objPath[1024];

  ADS_SEARCH_HANDLE
    searchHandle;

  ADS_SEARCH_COLUMN
    searchColumn;

  wchar_t
    *pszDistName[] = { L"distinguishedName" };

  // ****  parse WQL expression

  CTextLexSource 
    src(wcsWQLStmt);

  QL1_Parser 
    parser(&src);

  QL_LEVEL_1_RPN_EXPRESSION 
    *pExp = NULL;

  AutoDelete<QL_LEVEL_1_RPN_EXPRESSION>
    AutoExp(&pExp);

  if(nRes = parser.Parse(&pExp))
    return WBEM_E_INVALID_QUERY;

  // **** find domain attribute

  for(int iToken = 0; (iToken < pExp->nNumTokens) && (NULL == pToken); iToken++)
  {
    pToken = &pExp->pArrayOfTokens[iToken];

    if(_wcsicmp(g_bstrDomain, pToken->PropertyName.GetStringAt(pToken->PropertyName.GetNumElements() - 1)))
      pToken = NULL;
  }

  if(NULL == pToken)
    return WBEMESS_E_REGISTRATION_TOO_BROAD;

  if((QL_LEVEL_1_TOKEN::OP_EXPRESSION != pToken->nTokenType) ||
     (QL_LEVEL_1_TOKEN::OP_EQUAL != pToken->nOperator) ||
     (TRUE == pToken->m_bPropComp) ||
     (VT_BSTR != pToken->vConstValue.vt))
    return WBEM_E_INVALID_QUERY;

  if((NULL == bstrADClassName) || (NULL == pf_ADToCIM))
    return WBEM_E_INVALID_QUERY;

  // **** connect to LDAP location

  hres = GetADContainerInDomain(pToken->vConstValue.bstrVal, wcsPath, &pDirectorySearch);
  if(FAILED(hres))
  {
    if(WBEM_E_NOT_FOUND == hres)
      return WBEM_S_NO_ERROR;

    return hres;
  }
  else if(pDirectorySearch == NULL)
    return WBEM_E_FAILED;

  // **** build LDAP query to execute on container pADs

  LDAPQuery << L"(objectCategory=" << bstrADClassName << L")";

  // **** set search preferences

  ADS_SEARCHPREF_INFO
    SearchPreferences[1];

  SearchPreferences[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  SearchPreferences[0].vValue.dwType = ADSTYPE_INTEGER;
  SearchPreferences[0].vValue.Integer = 1000;

  hres = pDirectorySearch->SetSearchPreference(SearchPreferences, 1);

  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Could not set search preferences, returned error: 0x%08X\n", (LPWSTR)LDAPQuery, hres));
    return WBEM_E_FAILED;
  }

  // **** execute query

  hres = pDirectorySearch->ExecuteSearch(LDAPQuery, pszDistName, 1, &searchHandle);

  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Could execute query: (%s) returned error: 0x%08X\n", (LPWSTR)LDAPQuery, hres));
    return WBEM_E_FAILED;
  }

  // **** build result list

  try
  {
    while(SUCCEEDED(hres = pDirectorySearch->GetNextRow(searchHandle)) && (S_ADS_NOMORE_ROWS != hres))
    {
      CComPtr<IDirectoryObject>
        pDirectoryObject;

      CComPtr<IWbemClassObject>
        pWbemClassObject;

      // **** get path to object

      hres = pDirectorySearch->GetColumn(searchHandle, pszDistName[0], &searchColumn);
      if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

      // **** get pointer to object

      wcscpy(objPath, L"LDAP://");
      wcscat(objPath, searchColumn.pADsValues->CaseIgnoreString);
      pDirectorySearch->FreeColumn(&searchColumn);

      hres = ADsGetObject(objPath, IID_IDirectoryObject, (void **)&pDirectoryObject);
      if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

      hres = pf_ADToCIM(&pWbemClassObject, pDirectoryObject, pWbemServices);
      if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
      if(pWbemClassObject == NULL) return WBEM_E_FAILED;

      hres = pResponseHandler->Indicate(1, &pWbemClassObject);
    }
  }
  catch(long hret)
  {
    hres = ADSIToWMIErrorCodes(hret);
    ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
  }
  catch(wchar_t *swErrString)
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
    hres = WBEM_E_FAILED;
  }
  catch(...)
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
    hres = WBEM_E_TRANSPORT_FAILURE; // HACK for SP1 
  }

  pDirectorySearch->CloseSearchHandle(searchHandle);

  return hres;
}

void LogExtendedADErrorInfo(HRESULT hres)
{
  DWORD dwLastError;
  WCHAR szErrorBuf[1024], szNameBuf[256];

  if(HRESULT_FACILITY(hres) == FACILITY_WIN32)
  {
    HRESULT hres2;

    hres2 = ADsGetLastError(&dwLastError, szErrorBuf, 1023, szNameBuf, 255);

    if(SUCCEEDED(hres2))
      ERRORTRACE((LOG_ESS, "POLICMAN: Error Code: %d Error Text: %S Provider: %S\n", dwLastError, szErrorBuf, szNameBuf));
    else
      ERRORTRACE((LOG_ESS, "POLICMAN: Type mismatch on date property\n"));
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\cse\containers.cpp ===
#include <windows.h>
#include <wbemidl.h>
#include <wchar.h>
#include "Containers.h"

HRESULT LikeTemplateList::Add(IWbemClassObject* pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (pObj)
    {
        pObj->AddRef();
        m_objects.Add(pObj);
    }
    else 
        hr = WBEM_E_INVALID_PARAMETER;
        

    return hr;
}

LikeTemplateList::~LikeTemplateList()
{
    for (int i = 0; i < m_objects.Size(); i++)
        if (m_objects[i])
            ((IUnknown*)m_objects[i])->Release();
}

// returns safearray of objects
// callers responsibility to destroy
SAFEARRAY*  LikeTemplateList::GetArray()
{
    SAFEARRAYBOUND bounds = {m_objects.Size(), 0};

    SAFEARRAY* pArray = SafeArrayCreate(VT_UNKNOWN, 1, &bounds);

    if (pArray)
    {
        IUnknown** pObj;
        if (FAILED(SafeArrayAccessData(pArray, (void**) &pObj)))
        {
            SafeArrayDestroy(pArray);
            pArray = NULL;
        }
        else
        {
            for (int i = 0; i < m_objects.Size(); i++)
            {
                pObj[i] = (IUnknown*)m_objects[i];
                ((IUnknown*)pObj[i])->AddRef();
            }      
            SafeArrayUnaccessData(pArray);
        }
    }
    
    return pArray;
}

TemplateMap::~TemplateMap()
{
    for (int i = 0; i < m_lists.Size(); i++)
        if (m_lists[i])
            delete m_lists[i];
}

// inserts object into proper list
// creates new list entry if needed
HRESULT TemplateMap::Add(WCHAR* pPath, IWbemClassObject* pObj)
{    
    HRESULT hr = WBEM_S_NO_ERROR;

    bool bItPlaced = false;

    for (int i = 0; (i < m_lists.Size()) && !bItPlaced; i++)
    {
        int nCompare = ((LikeTemplateList*)m_lists[i])->Compare(pPath);

        // if is less than current position
        // insert a new one at current position
        if (nCompare < 0)
        {
            bItPlaced = true;
            LikeTemplateList* pList = new LikeTemplateList(pPath);
            if (!pList)
                hr = WBEM_E_OUT_OF_MEMORY;
            else
            {
                if (CFlexArray::no_error == m_lists.InsertAt(i, pList))
                    ((LikeTemplateList*)m_lists[i])->Add(pObj);
                else
                    hr = WBEM_E_FAILED;
            }
        }
        // equal - add it to existing list
        else if (nCompare == 0)
        {
            bItPlaced = true;
            hr  = ((LikeTemplateList*)m_lists[i])->Add(pObj);
        }
    }
    
    // fell off end of list w/o placing it - add to end
    if (!bItPlaced && (SUCCEEDED(hr)))
    {
        LikeTemplateList* pList = new LikeTemplateList(pPath);
        if (pList)
		{
			pList->Add(pObj);
            m_lists.Add(pList);
		}
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

// cookie is index into array
// meant to be used as a "get next"
// will increment cookie before returning;
// set to zero to get first one
SAFEARRAY* TemplateMap::GetTemplateList(int& cookie)
{
    if (cookie < m_lists.Size())
        return ((LikeTemplateList*)m_lists[cookie++])->GetArray();
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\utility.h ===
#ifndef __WBEM_UTILITY__H_
#define __WBEM_UTILITY__H_

#include "iads.h"
#undef _ASSERT
#include <wbemcli.h>
#include <wbemprov.h>
#include <wbemcomn.h>
#include <atlbase.h>
#include <activeds.h>
#include <WinNTSec.h>

// **** default min, max and default 

#define SINT_MIN 0xffffffff
#define SINT_MAX 0xefffffff
#define SINT_DEFAULT 0x0

#define UINT_MIN 0x0
#define UINT_MAX 0xffffffff
#define UINT_DEFAULT 0x0

#define REAL_MIN (double)(0xffffffffffffffff)
#define REAL_MAX (double)(0xefffffffffffffff)
#define REAL_DEFAULT 0x0

// retrieve namespace with given name
HRESULT GetNamespace(BSTR namespaceName, IWbemServices*& pNamespace, bool bInProc);

// make sure that the ID property of pObj has a value
// will generate GUID if not
// assumes property is a BSTR!
// if pName == NULL, assumes property name is "ID"
// returns WBEM_S_NO_ERROR if ID generated
//         WBEM_S_FALSE if no ID generated (already has a value)
//         WBEM_E_NOT_FOUND if ID property is not
//         some error if error of some sort
HRESULT EnsureID(IWbemClassObject* pObj, WCHAR* pName);

// init ADS_ATTR_INFO structure
void Init_AdsAttrInfo(ADS_ATTR_INFO *pAdsAttrInfo,
                        LPWSTR bstrName,
                        DWORD control,
                        ADSTYPE type,
                        PADSVALUE pVals,
                        DWORD nVals);

template <class ElementType, VARTYPE vt> class SafeArray
{
private:

  long
    m_IndexMin, 
    m_IndexMax, 
    m_Size;

  ElementType
    *m_pElementType;

  SAFEARRAY
    *m_pSafeArray;

  void _EmptyInit(void)
  {
    m_IndexMin = -1;
    m_IndexMax = -1;
    m_Size = 0;
    m_pElementType = NULL;
    m_pSafeArray = NULL;
  }

  void _ArrayInit(void)
  {
    HRESULT hres;

    hres = SafeArrayGetUBound(m_pSafeArray, 1, &m_IndexMax);
    if(FAILED(hres))
      return;

    hres = SafeArrayGetLBound(m_pSafeArray, 1, &m_IndexMin);
    if(FAILED(hres))
      return;

    m_Size = m_IndexMax - m_IndexMin + 1;

    m_pElementType = NULL;
    hres = SafeArrayAccessData(m_pSafeArray, (void **)&m_pElementType);
    if(FAILED(hres))
      return;
  }

public:

  SafeArray(void)
  {
    _EmptyInit();
  }

  // **** empty array creation

  SafeArray(long LowerBound, long ArgSize)
  {
    HRESULT hres;

    SAFEARRAYBOUND
      arrayBounds[1];

    // **** check for valid size

    if(LowerBound < 0)
      return;

    if(ArgSize < 0)
      return;

    // **** create empty array

    if(0 == ArgSize)
    {
      _EmptyInit();
    }
    else
    {
      arrayBounds[0].lLbound = LowerBound;
      arrayBounds[0].cElements = ArgSize;

      m_pSafeArray = SafeArrayCreate(vt, 1, arrayBounds);
      if(NULL == m_pSafeArray)
        return;

      _ArrayInit();
    }
  }

  // **** creation/init SafeArray from VARIANT

  SafeArray(VARIANT *v)
  {
    HRESULT hres;

    // **** first ensure that the contained object is valid

    if(NULL == v)
      return;

    if((V_VT(v) == VT_NULL) || (V_VT(v) == VT_EMPTY))
    {
      _EmptyInit();
    }
    else
    {
      if(V_VT(v) != (VT_ARRAY | vt))
        return;

      // **** copy to SafeArray contents of variant

      m_pSafeArray = NULL;
      hres = SafeArrayCopy(V_ARRAY(v), &m_pSafeArray);
      if(FAILED(hres))
        return;

      _ArrayInit();
    }
  }

  SafeArray &operator =(const VARIANT *Source)
  {
    HRESULT hres;

    // **** first ensure that the contained object is valid

    if((NULL == Source) || (V_VT(Source) != (VT_ARRAY | vt)))
      return *this;

    // **** get SAFEARRAY dimensions

    if(NULL != m_pSafeArray)
    {
      hres = SafeArrayUnaccessData(m_pSafeArray);
      hres = SafeArrayDestroy(m_pSafeArray);
    }

    hres = SafeArrayCopy(V_ARRAY(Source), &m_pSafeArray);
    if(FAILED(hres))
    {
      _EmptyInit();
      return *this;
    }

    _ArrayInit();

    return *this;
  }

  // **** creation/init SafeArray from SafeArray

  SafeArray(const SafeArray &Source)
  {
    HRESULT hres;

    if(NULL == Source.m_pSafeArray)
    {
      _EmptyInit();
    }
    else
    {
      // **** copy to SafeArray contents of variant

      m_pSafeArray = NULL;
      hres = SafeArrayCopy(Source.m_pSafeArray, &m_pSafeArray);
      if(FAILED(hres))
        return;

      _ArrayInit();
    }
  }

  SafeArray &operator = (const SafeArray &Source)
  {
    HRESULT hres;

    if(NULL == Source.m_pSafeArray)
    {
      _EmptyInit();
    }
    else
    {
      if(NULL != m_pSafeArray)
      {
        hres = SafeArrayUnaccessData(m_pSafeArray);
      }

      // **** copy to SafeArray contents of variant

      hres = SafeArrayCopy(Source.m_pSafeArray, &m_pSafeArray);
      if(FAILED(hres))
        return;

      _ArrayInit();
    }

    return *this;
  }

  ~SafeArray(void)
  {
    if(NULL != m_pSafeArray)
    {
      SafeArrayUnaccessData(m_pSafeArray);
      SafeArrayDestroy(m_pSafeArray);
    }

    _EmptyInit();
  }

  // **** Misc functions

  VARTYPE Type(void) { return vt; }
  long Size(void) { return m_Size; }
  long IndexMin(void) { return m_IndexMin; }
  long IndexMax(void) { return m_IndexMax; }

  SAFEARRAY *Data(void)
  { 
    HRESULT hres;
    SAFEARRAY *pArrayCopy = NULL;

    if(NULL != m_pSafeArray)
    {
      hres = SafeArrayCopy(m_pSafeArray, &pArrayCopy);
      if(FAILED(hres))
        return NULL;
    }

    return pArrayCopy; 
  }

  long ReDim(long LowerBound, long ArgSize)
  {
    HRESULT hres;

    SAFEARRAYBOUND arrayBounds[1];

    // **** check to see that Index is within range

    if((LowerBound != m_IndexMin) || ((LowerBound + ArgSize - 1) != m_IndexMax))
    {
      m_IndexMin = LowerBound;

      if(ArgSize < 1)
      {
        if(NULL != m_pSafeArray)
        {
          SafeArrayUnaccessData(m_pSafeArray);
          SafeArrayDestroy(m_pSafeArray);
        }

        _EmptyInit();
      }
      else
      {
        m_IndexMax = LowerBound + ArgSize - 1;
        m_Size = m_IndexMax - m_IndexMin + 1;

        arrayBounds[0].lLbound = LowerBound;
        arrayBounds[0].cElements = m_Size;

        if(NULL == m_pSafeArray)
        {
          m_pSafeArray = SafeArrayCreate(vt, 1, arrayBounds);
        }
        else
        {
          hres = SafeArrayUnaccessData(m_pSafeArray);
          hres = SafeArrayRedim(m_pSafeArray, arrayBounds);
        }

        m_pElementType = NULL;
        hres = SafeArrayAccessData(m_pSafeArray, (void **)&m_pElementType);
      }
    }

    // **** return reference to Index element

    return m_Size;
  }

  ElementType& operator[](long Index)
  {
    // **** return reference to Index element

    return m_pElementType[Index];
  }
};


class QString
{
  BSTR m_data; // pointer to beginning of string
  UINT m_StringLength; 
  UINT m_BufferLength; 
  UINT m_ExtraLength;

  void _InitMembers(void) 
  { m_data = NULL; m_StringLength = 0; m_BufferLength = 0; m_ExtraLength = 0; m_Status = OK; }

public:

  enum
  {
    OK = 0,
    NOT_FOUND,
    OUT_OF_MEMORY,
    INVALID_PARAM,
  } m_Status;

  QString(void) 
  { _InitMembers(); }

  QString(UINT size, UINT extra = 0)
  { 
    _InitMembers();

    m_data = SysAllocStringLen(NULL, size + 1);
    if(NULL == m_data) 
    {
      m_Status = OUT_OF_MEMORY;
      return;
    }
    m_data[0] = L'\0';
    m_BufferLength = SysStringLen(m_data);
    m_ExtraLength = extra;
  }

  QString(wchar_t *data, UINT extra = 0)
  {
    _InitMembers();

    m_StringLength = wcslen(data);
    m_ExtraLength = extra;

    if(m_StringLength > 0)
    {
      m_data = SysAllocStringLen(NULL, m_StringLength + m_ExtraLength + 1);
      if(NULL == m_data) 
      {
        m_Status = OUT_OF_MEMORY;
        return;
      }

      wcscpy(m_data, data);
      m_BufferLength = SysStringLen(m_data);
      m_StringLength = wcslen(m_data);
    }
  }

  QString(QString &org)
  {
    _InitMembers();

    m_data = SysAllocString(org.m_data);
    if(NULL == m_data) 
    {
      m_Status = OUT_OF_MEMORY;
      return;
    }
    m_StringLength = wcslen(m_data);
    m_BufferLength = SysStringLen(m_data);
    m_ExtraLength = org.m_ExtraLength;
  }

  ~QString(void)
  {
    if(NULL != m_data)
      SysFreeString(m_data);
    m_BufferLength = m_StringLength = m_ExtraLength = 0;
  }

  QString &Detach(void)
  {
    _InitMembers();

    return *this;
  }

  QString &operator=(wchar_t *data)
  {
    m_StringLength = wcslen(data);

    if((NULL == m_data) || (m_StringLength >= m_BufferLength))
    {
      if(NULL != m_data)
      {
        SysFreeString(m_data);
        m_BufferLength = 0;
      }

      m_data = SysAllocStringLen(NULL, m_StringLength + m_ExtraLength + 1);
      if(NULL == m_data) 
      {
        m_Status = OUT_OF_MEMORY;
        return *this;
      }

      m_BufferLength = SysStringLen(m_data);
    }

    wcscpy(m_data, data);

    return *this;
  }

  QString &operator << (UINT data)
  {
    wchar_t buffer[20];
    if(OK != m_Status) return *this;

    return (*this << _ltow(data, buffer, 10));
  }

  QString &operator << (wchar_t *data)
  {
    BSTR
      NewData;

    if(OK != m_Status) return *this;

    UINT
      DataSize = wcslen(data);

    if((DataSize + m_StringLength + 1) < m_BufferLength)
      wcscat(m_data, data);
    else
    {
      NewData = SysAllocStringLen(NULL, DataSize + m_StringLength + m_ExtraLength + 1);
      if(NULL == NewData)
      {
        m_Status = OUT_OF_MEMORY;
        return *this;
      }

      if(0 != m_StringLength)
      {
        wcscpy(NewData, m_data);
        wcscat(NewData, data);
      }
      else
        wcscpy(NewData, data);

      if(NULL != m_data) 
        SysFreeString(m_data);

      m_data = NewData;
      m_BufferLength = SysStringLen(m_data);
    }

    m_StringLength = wcslen(m_data);
    m_Status = OK;

    return *this;
  }

  UINT NextPattern(UINT offset, wchar_t *pattern, UINT &lIndex)
  {
    wchar_t *start;

    if(OK != m_Status) return m_Status;
    start = wcsstr(m_data + offset, pattern);

    if(NULL == start)
      return NOT_FOUND;
    else
      lIndex = (UINT)(start - m_data);

    return m_Status;
  }

  UINT PrevPattern(UINT offset, wchar_t *pattern, UINT &lIndex)
  {
    wchar_t 
      *prev = NULL,
      *curr = NULL,
      *currOffset = m_data + offset;

    UINT
      patternLength;

    if((offset < 1) || 
       (NULL == pattern) || 
       (m_StringLength < (patternLength = wcslen(pattern))) ||
       (m_StringLength < offset))
      return INVALID_PARAM;

    if(OK != m_Status) 
      return m_Status;

    curr = wcsstr(m_data, pattern);

    while(curr < currOffset)
    {
      prev = curr;
      curr = wcsstr(curr + patternLength, pattern);
      if(NULL == curr) curr = currOffset;
    }

    if(NULL == prev)
      return NOT_FOUND;
    else
      lIndex = (UINT)(prev - m_data);

    return m_Status;
  }

  UINT NextChar(UINT offset, wchar_t *charlist, UINT &lIndex)
  {
    wchar_t *start;

    if(OK != m_Status) return m_Status;

    start = wcspbrk(m_data + offset, charlist);

    if(NULL == start)
      return NOT_FOUND;
    else
      lIndex = (UINT)(start - m_data);

    return m_Status;
  }

  QString &SubStrCat(QString &SrcStr, UINT start, UINT end)
  {
    UINT
      SpliceLen = end - start + 1;

    BSTR
      NewData;

    if(OK != m_Status) return *this;

    if(end <= start)
      return *this;

    if((m_BufferLength - m_StringLength) > SpliceLen)
      wcsncat(m_data, SrcStr.m_data + start, SpliceLen);
    else
    {
      NewData = SysAllocStringLen(NULL, SpliceLen + m_StringLength + m_ExtraLength + 1);

      if(NULL == NewData)
      {
        m_Status = OUT_OF_MEMORY;
        return *this;
      }

      if(0 != m_StringLength)
      {
        wcscpy(NewData, m_data);
        wcsncat(NewData, SrcStr.m_data + start, SpliceLen);
      }
      else
        wcsncpy(NewData, SrcStr.m_data + start, SpliceLen);

      NewData[SpliceLen + m_StringLength] = L'\0';

      if(NULL != m_data)
        SysFreeString(m_data);

      m_data = NewData;
      m_BufferLength = SysStringLen(m_data);
    }

    m_StringLength = wcslen(m_data);

    return *this;
  }

  wchar_t & operator[] (UINT index) { return m_data[index]; }
  operator wchar_t* (void) { return m_data; }
  UINT StringLength(void) { return m_StringLength; }
  UINT BufferLength(void) { return m_BufferLength; }
};

template<class T> struct ADsStruct
{
  T *m_pADsMem;

  ADsStruct(void)
  { m_pADsMem = NULL; }
  ~ADsStruct(void)
  { if(NULL != m_pADsMem)  FreeADsMem(m_pADsMem); }

  operator T*(void) const { return m_pADsMem; }
  T** operator&(void) { return &m_pADsMem; }

  bool operator==(T *x) { return m_pADsMem == x; }
  bool operator!=(T *x) { return m_pADsMem != x; }

  T* & operator->(void) { return m_pADsMem; }
  // T* operator+(unsigned long x) { return m_pADsMem + x; }

  ADsStruct<T>& operator=(ADsStruct<T> &x)
  { return; }

  ADsStruct<T>& operator=(T* x)
  { if(NULL != m_pADsMem) FreeADsMem(m_pADsMem); m_pADsMem = x; return *this; }
};

template<class T> struct AutoDelete
{
  T **m_pTheThingToDelete;

  AutoDelete(void)
  { m_pTheThingToDelete = NULL; }

  AutoDelete(T **x)
  { m_pTheThingToDelete = x; }

  ~AutoDelete(void)
  { if((NULL != m_pTheThingToDelete) && (NULL != *m_pTheThingToDelete)) delete *m_pTheThingToDelete;}
};

class ADsObjAutoDelete
{
  CComPtr<IADsDeleteOps>
    m_pDelObj;

public:

  HRESULT Attach(IDispatch *pDisp) 
  { return pDisp->QueryInterface(IID_IADsDeleteOps, (void**)&m_pDelObj); }

  void Detach(void) 
  { if(m_pDelObj != NULL) m_pDelObj = NULL; }

  ~ADsObjAutoDelete(void) 
  { if(m_pDelObj != NULL) m_pDelObj->DeleteObject(0); }
};

extern BSTR

  // **** misc names

  g_bstrEmptyString,
  g_bstrEmptyDate,

  // **** AD schema names

  g_bstrADAuthor,
  g_bstrADChangeDate,
  g_bstrADClassDefinition,
  g_bstrADCreationDate,
  g_bstrADDescription,
  g_bstrADIntDefault,
  g_bstrADInt8Default,
  g_bstrADID,
  g_bstrADIntMax,
  g_bstrADInt8Max,
  g_bstrADIntMin,
  g_bstrADInt8Min,
  g_bstrADIntValidValues,
  g_bstrADName,
  g_bstrADNormalizedClass,
  g_bstrADObjectClass,
  g_bstrADParam2,
  g_bstrADPolicyType,
  g_bstrADPropertyName,
  g_bstrADQuery,
  g_bstrADQueryLanguage,
  g_bstrADStringDefault,
  g_bstrADStringValidValues,
  g_bstrADSourceOrganization,
  g_bstrADTargetClass,
  g_bstrADTargetNameSpace,
  g_bstrADTargetObject,
  g_bstrADTargetPath,
  g_bstrADTargetType,

  // **** AD class names

  g_bstrADClassMergeablePolicy,
  g_bstrADClassRangeParam,
  g_bstrADClassRangeSint32,
  g_bstrADClassRangeUint32,
  g_bstrADClassRangeReal,
  g_bstrADClassParamUnknown,
  g_bstrADClassSetSint32,
  g_bstrADClassSetUint32,
  g_bstrADClassSetString,
  g_bstrADClassSimplePolicy,
  g_bstrADClassRule,
  g_bstrADClassSom,
  g_bstrADClassPolicyType,
  g_bstrADClassWMIGPO,

  // **** CIM schema names

  g_bstrAuthor,
  g_bstrChangeDate,
  g_bstrClassDefinition,
  g_bstrCreationDate,
  g_bstrDefault,
  g_bstrDescription,
  g_bstrDsPath,
  g_bstrDomain,
  g_bstrID,
  g_bstrMax,
  g_bstrMin,
  g_bstrName,
  g_bstrPolicyType,
  g_bstrPropertyName,
  g_bstrQuery,
  g_bstrQueryLanguage,
  g_bstrRangeSettings,
  g_bstrRules,
  g_bstrSourceOrganization,
  g_bstrTargetClass,
  g_bstrTargetNameSpace,
  g_bstrTargetObject,
  g_bstrTargetPath,
  g_bstrTargetType,
  g_bstrValidValues,

  // **** CIM class names

  g_bstrClassMergeablePolicy,
  g_bstrClassRangeParam,
  g_bstrClassRangeSint32,
  g_bstrClassRangeUint32,
  g_bstrClassRangeReal,
  g_bstrClassSetSint32,
  g_bstrClassSetUint32,
  g_bstrClassSetString,
  g_bstrClassSimplePolicy,
  g_bstrClassRule,
  g_bstrClassSom,
  g_bstrClassPolicyType,
  g_bstrClassWMIGPO;

void InitGlobalNames(void);
void FreeGlobalNames(void);
HRESULT DomainNameFromDistName(QString &DomainName, QString &DistName);
HRESULT DistNameFromDomainName(QString &DomainName, QString &DistName);
IADsContainer *CreateContainer(BSTR bstrPath, BSTR bstrName);
IADsContainer *CreateContainers(QString &pDomain, QString &pPath);
HRESULT ADSIToWMIErrorCodes(HRESULT hresAD);
IsEmpty(VARIANT &);

typedef HRESULT (*functTyp)(IWbemClassObject * *,
                            IDirectoryObject*,
                            IWbemServices*);

HRESULT ExecuteWQLQuery(wchar_t *wcsPath, 
                        wchar_t *wcsWQLStmt, 
                        IWbemObjectSink *pResponseHandler, 
                        IWbemServices *pWbemServices,
                        BSTR bstrADClassName,
                        functTyp pf_ADToCIM);

// **** PolicyTemplate

HRESULT Policy_CIMToAD(long, IWbemClassObject *, IDirectoryObject *pDestContainer);
HRESULT Policy_ADToCIM(IWbemClassObject **, IDirectoryObject *, IWbemServices *);
HRESULT Policy_Merge(SafeArray<IUnknown*, VT_UNKNOWN> &PolicyArray,
                     CComPtr<IWbemClassObject> &pMergedPolicy,
                     IWbemServices *pDestCIM);

// **** RangeSint32

HRESULT Range_Sint32_Verify(IWbemClassObject*);
HRESULT Range_Sint32_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Range_Sint32_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** RangeUint32

HRESULT Range_Uint32_Verify(IWbemClassObject*);
HRESULT Range_Uint32_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Range_Uint32_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** RangeReal

HRESULT Range_Real_Verify(IWbemClassObject*);
HRESULT Range_Real_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Range_Real_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** SetSint32

HRESULT Set_Sint32_Verify(IWbemClassObject*);
HRESULT Set_Sint32_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Set_Sint32_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** SetUint32

HRESULT Set_Uint32_Verify(IWbemClassObject*);
HRESULT Set_Uint32_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Set_Uint32_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** SetString

HRESULT Set_String_Verify(IWbemClassObject*);
HRESULT Set_String_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Set_String_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** ParamUnknown

HRESULT Param_Unknown_Verify(IWbemClassObject*);
HRESULT Param_Unknown_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE*, IWbemServices*);

// **** SOM

HRESULT Som_CIMToAD(IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer, long lFlags);
HRESULT Som_ADToCIM(IWbemClassObject **, IDirectoryObject *pSrcPolicyObj, IWbemServices *pDestCIM);

// **** WMIGPO

HRESULT WMIGPO_CIMToAD(IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer, long lFlags);
HRESULT WMIGPO_ADToCIM(IWbemClassObject **, IDirectoryObject *pSrcPolicyObj, IWbemServices *pDestCIM);

// **** PolicyType

HRESULT PolicyType_CIMToAD(IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer);
HRESULT PolicyType_ADToCIM(IWbemClassObject**, IDirectoryObject *pSrcPolicyObj, IWbemServices *pDestCIM);

// **** Security Manipulation

HRESULT CreateDefaultSecurityDescriptor(CNtSecurityDescriptor& cSD);

HRESULT GetOwnerSecurityDescriptor(CNtSecurityDescriptor& SD);

PSECURITY_DESCRIPTOR GetADSecurityDescriptor(IDirectoryObject *pIDirectoryObject);

#endif __WBEM_UTILITY__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\cse\wmi_cse.h ===
#ifndef _WMI_CSE_HEADER_COMPILED_ALREADY_
#define _WMI_CSE_HEADER_COMPILED_ALREADY_

#include <FLEXARRY.H>
#include <containers.h>

// {AAEAE720-0328-4763-8ECB-23422EDE2DB5}
CLSID CLSID_CSE = 
    { 0xaaeae720, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

#define CSE_REG_KEY "Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{AAEAE720-0328-4763-8ECB-23422EDE2DB5}"
#define POLICY_PROC_NAME "ProcessGroupPolicyProc"
#define POLICY_PROC_NAME_EX "ProcessGroupPolicyProcEx"
#define GENREATE_POLICY_PROC "GenerateGroupPolicyProc"
#define WMI_CSE_NAME "WMI Group Policy Extension"
#define WMIGPO_GETOBJECT_TEMPLATE L"MSFT_WMIGPO.DsPath=\"%s\""
#define WMIGPO_GETOBJECT_STRLEN (sizeof(WMIGPO_GETOBJECT_TEMPLATE)/sizeof(WCHAR) +MAX_PATH +1)

HRESULT GetPolicyNamespace(IWbemServices*& pPolicyNamespace);
HRESULT GetPolicyTemplates(IWbemServices* pPolicyNamespace, const WCHAR* pPath, TemplateMap& policies,
                           IWbemServices* pRSOPNamespace, IWbemClassObject* pRsopWMIGPOClass, IWbemClassObject* pRsopTemplateClass,
                           IWbemServices* pHistoryNamespace, IWbemClassObject* pMsftWMIGPOClass, IWbemClassObject* pMsftTemplateClass);
HRESULT GetNamespace(BSTR namespaceName, IWbemServices*& pNamespace);

inline void MakeGPOPath(WCHAR* buf);
HRESULT GetPolicyArray(IWbemServices* pPolicyNamespace, PGROUP_POLICY_OBJECT pGPOList, 
                       IWbemServices* pRSOPNamespace, 
                       IWbemServices* pHistoryNamespace, TemplateMap& policies);

HRESULT ApplyPolices(TemplateMap& policies, IWbemServices* pPolicyNamespace, IWbemServices* pRSOPNamespace, 
                     IWbemServices* pHistoryNamespace, bool bDoItForReal);

void EnsureType(IWbemServices* pPolicyNamespace, IWbemClassObject* pTemplate);

// all parameters passed to ProcessGroupPolicy
// used to pass info along to thread start routine
struct PGPStartup
{
    DWORD dwFlags;
    HANDLE hToken;
    HKEY hKeyRoot;
    PGROUP_POLICY_OBJECT  pDeletedGPOList;
    PGROUP_POLICY_OBJECT  pChangedGPOList;
    ASYNCCOMPLETIONHANDLE pHandle;
    BOOL *pbAbort;
    PFNSTATUSMESSAGECALLBACK pStatusCallback;
    IWbemServices *pWbemServices;
    HRESULT      *pRsopStatus;
};


#endif // _WMI_CSE_HEADER_COMPILED_ALREADY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\cse\wmi_cse.cpp ===
#include <windows.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <wbemutil.h>
#include <utility.h>
#include <UserEnv.h>
#include <olectl.h>
#include <wchar.h>
#include <FLEXARRY.H>
#include "WMI_CSE.h"
#include <shlwapi.h>
#include <containers.h>
#include <WbemTran.h>
#include <stdio.h>
#include <arrtempl.h>
#include <lmcons.h>
#include <lmerr.h>
#include <Lmapibuf.h>
#include <Dsgetdc.h>
#include <genlex.h>
#include <objpath.h>


BSTR RSOP_WMIGPOName                = NULL;                    
BSTR RSOP_AppliedPolicyTemplateName = NULL;     
BSTR RSOP_AppliedPolicyTypeName     = NULL;         
BSTR RSOP_WmiTargetObjectName       = NULL;           
BSTR MSFT_PolicyTemplateName        = NULL;   

BSTR MSFT_WMIGPOName                = NULL;                    
BSTR MSFT_AppliedPolicyTemplateName = NULL;     
BSTR MSFT_AppliedPolicyTypeName     = NULL;
BSTR MSFT_WmiTargetObjectName       = NULL;

const WCHAR* DsContextName = L"DsContext";
const WCHAR* DsLocalValue  = L"Local";

// switch to enable async processing
// if re-enabled: must fix ProcessGroupPolicyEx
// and the dll registration to indicate we do async processing
//#define ASYNCH_ENABLED


// wrapper for PutInstance
// jumps through some extra hoops to make sure that the class def is correct
HRESULT PutInstance(IWbemServices* pNamespace, IWbemClassObject* pObj)
{
	DEBUGTRACE((LOG_ESS, "CSE: PutInstance(Long way)\n"));

	HRESULT hr = WBEM_E_FAILED;
	
	VARIANT vClassName;
	VariantInit(&vClassName);

	if (SUCCEEDED(hr = pObj->Get(L"__CLASS",0, &vClassName, NULL, NULL)))
	{
		IWbemClassObject* pNewClass = NULL;
		IWbemClassObject* pNewObj   = NULL;

		CReleaseMe r1(pNewClass);
		CReleaseMe r2(pNewObj);

		if (SUCCEEDED(hr = pNamespace->GetObject(vClassName.bstrVal, 0, NULL, &pNewClass, NULL)))
		{
			if (SUCCEEDED(hr = pNewClass->SpawnInstance(0, &pNewObj)))
			{
				// got all the pieces, walk the properties & transfer them.
				pObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
				BSTR pPropName = NULL;
				VARIANT vProp;
				VariantInit(&vProp);

				while (pObj->Next(0, &pPropName, &vProp, NULL, NULL) != WBEM_S_NO_MORE_DATA)
				{
					pNewObj->Put(pPropName, 0, &vProp, NULL);
					
					SysFreeString(pPropName);
					pPropName = NULL;
					VariantClear(&vProp);
				}

				pObj->EndEnumeration();

				if (FAILED(hr = pNamespace->PutInstance(pNewObj, WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL)))
					ERRORTRACE((LOG_ESS, "CSE: Failed to put new object, %0x08X", hr));
			}
			else
				ERRORTRACE((LOG_ESS, "CSE: Failed to spawn instance of new class, %0x08X", hr));
		}
		else
			ERRORTRACE((LOG_ESS, "CSE: Failed to retrieve new class, 0x%08X\n", hr));
	}

	DEBUGTRACE((LOG_ESS, "CSE: PutInstance(Long way) returning 0x%08X on %S\n", hr, vClassName.bstrVal));
	SysFreeString(vClassName.bstrVal);

	return hr;
}


HRESULT CSEInitGlobalNames()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    RSOP_WMIGPOName                = SysAllocString(L"RSOP_WMIGPOPolicySetting");
    RSOP_AppliedPolicyTemplateName = SysAllocString(L"RSOP_AppliedPolicyTemplate");
    RSOP_AppliedPolicyTypeName     = SysAllocString(L"RSOP_AppliedPolicyType");
    RSOP_WmiTargetObjectName       = SysAllocString(L"RSOP_WmiTargetObject");
 
    MSFT_WMIGPOName                = SysAllocString(L"MSFT_WMIGPOPolicySetting");
    MSFT_PolicyTemplateName        = SysAllocString(L"MSFT_PolicyTemplate");
    MSFT_AppliedPolicyTemplateName = SysAllocString(L"MSFT_AppliedPolicyTemplate");
    MSFT_AppliedPolicyTypeName     = SysAllocString(L"MSFT_AppliedPolicyType");
    MSFT_WmiTargetObjectName       = SysAllocString(L"MSFT_WmiTargetObject");

    if (
        (RSOP_WMIGPOName == NULL) ||
        (RSOP_AppliedPolicyTemplateName == NULL) ||
        (RSOP_WmiTargetObjectName == NULL) ||
        (RSOP_AppliedPolicyTypeName == NULL) ||
        (MSFT_PolicyTemplateName == NULL) ||
        (MSFT_WMIGPOName == NULL) ||
        (MSFT_AppliedPolicyTemplateName == NULL) ||
        (MSFT_AppliedPolicyTypeName     == NULL) ||
        (MSFT_WmiTargetObjectName       == NULL)
       )
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

void ReleaseGlobalNames()
{
    if (RSOP_WMIGPOName)
        SysFreeString(RSOP_WMIGPOName);
    if (RSOP_AppliedPolicyTemplateName)
        SysFreeString(RSOP_AppliedPolicyTemplateName);
     if (RSOP_WmiTargetObjectName)
        SysFreeString(RSOP_WmiTargetObjectName);
    if (RSOP_AppliedPolicyTypeName)
        SysFreeString(RSOP_AppliedPolicyTypeName);
    if (MSFT_PolicyTemplateName)
        SysFreeString(MSFT_PolicyTemplateName);
    if (MSFT_AppliedPolicyTemplateName)
        SysFreeString(MSFT_AppliedPolicyTemplateName);
    if (MSFT_AppliedPolicyTypeName)
        SysFreeString(MSFT_AppliedPolicyTypeName);
    if (MSFT_WmiTargetObjectName)
        SysFreeString(MSFT_WmiTargetObjectName);
    if (MSFT_WMIGPOName)
        SysFreeString(MSFT_WMIGPOName);
}

// todo: expand this
DWORD HResultToWinError(HRESULT hr)
{
	if (FAILED(hr))
		return ERROR_FUNCTION_FAILED;
	else
		return ERROR_SUCCESS;
}

HRESULT GetNamespaceAndSetBlanket( BSTR bstr, 
                                   IWbemServices*& pNamespace,
                                   bool bInProc )
{
    HRESULT hr = GetNamespace(bstr, pNamespace, bInProc );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return CoSetProxyBlanket( pNamespace, 
                              RPC_C_AUTHN_DEFAULT,
                              RPC_C_AUTHZ_DEFAULT,
                              COLE_DEFAULT_PRINCIPAL,
                              RPC_C_AUTHN_LEVEL_DEFAULT,
                              RPC_C_IMP_LEVEL_IMPERSONATE,
                              NULL,
                              EOAC_DEFAULT );
}
                              

HRESULT GetPolicyNamespace(IWbemServices*& pPolicyNamespace)
{
    HRESULT hr;

    BSTR bstr = SysAllocString(L"\\\\.\\ROOT\\POLICY");
    if (bstr)
    {
        hr = GetNamespaceAndSetBlanket(bstr, pPolicyNamespace, false);
        SysFreeString(bstr);
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "CSE: Failed to retrieve policy namespace (0x%08X)\n", hr));

    return hr;
}

HRESULT GetHistoryNamespace(IWbemServices*& pHistoryNamespace)
{
    HRESULT hr;

    BSTR bstr = SysAllocString(L"\\\\.\\ROOT\\POLICY\\HISTORY");
    if (bstr)
        hr = GetNamespaceAndSetBlanket(bstr, pHistoryNamespace, false);
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "CSE: Failed to retrieve history namespace \"%S\"(0x%08X)\n", bstr, hr));

    if (bstr)
        SysFreeString(bstr);

    return hr;
}

// compile classes from fname into given namespace
// assumes that fname is local to wbem directory
HRESULT EnsureSchema(IWbemServices* pNamespace, WCHAR* fname)
{
    // prepare file name
    WCHAR fpath[MAX_PATH +1];
    GetSystemDirectory(fpath, MAX_PATH);
    wcscat(fpath, L"\\wbem\\");
    wcscat(fpath, fname);

    // grab the compiler
    HRESULT hr;
    IMofCompiler* pCompiler = NULL;
    hr = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (void**)&pCompiler);

    if (SUCCEEDED(hr))
    {
        // see if we can't figure out the namespace name
        // will grab a system class & fish out the namespace name
        BSTR name;
        if (name = SysAllocString(L"__NAMESPACE"))
        {
            IWbemClassObject* pClass = NULL;            
            if (SUCCEEDED(hr = pNamespace->GetObject(name, 0, NULL, &pClass, NULL)))
            {
                VARIANT v;
                VariantInit(&v);

                if (SUCCEEDED(hr = pClass->Get(L"__namespace", 0, &v, NULL, NULL)))
                {
                    WBEM_COMPILE_STATUS_INFO info;    
					DEBUGTRACE((LOG_ESS, "CSE Compiling %S to %S\n", fname, v.bstrVal));

                    // ready, set, compile!
                    hr = pCompiler->CompileFile(fpath, v.bstrVal, NULL, NULL, NULL,
                                                WBEM_FLAG_DONT_ADD_TO_LIST, WBEM_FLAG_UPDATE_FORCE_MODE,
                                                0, &info);
                    
                    if (FAILED(hr))
                        ERRORTRACE((LOG_ESS, "CSE: mof compilation failed, phase: %l, line %l\n", 
                                              info.lPhaseError, info.FirstLine));
                    
                    VariantClear(&v);
                }
                else
                {
                    ERRORTRACE((LOG_ESS, "Could not determine namespace 0x%08X\n",hr));
                }

                pClass->Release();
            }
            SysFreeString(name);
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;

        pCompiler->Release();
    }

    if (FAILED(hr))
   		ERRORTRACE((LOG_ESS, "CSE: Failed EnsureSchema (%S) (0x%08X)\n", fpath, hr));

    return hr;
};

// compile the wmi rsop objects into the namespace
HRESULT EnsureRSOPSchema(IWbemServices* pNamespace)
{
    DEBUGTRACE((LOG_ESS, "CSE: EnsureRSOPSchema\n"));
	
	// grab a random class to determine whether our schema has been compiled yet.
    IWbemClassObject* pRandomClass = NULL;    
    
    if (SUCCEEDED(pNamespace->GetObject(RSOP_WMIGPOName, WBEM_FLAG_DIRECT_READ,  
                                          NULL, &pRandomClass, NULL)))
    {
		DEBUGTRACE((LOG_ESS, "CSE: EnsureRSOPSchema found RSOP_WMIGPO, no compilation\n"));
        pRandomClass->Release();
        return WBEM_S_NO_ERROR;
    }
    else
	{
		DEBUGTRACE((LOG_ESS, "CSE: EnsureRSOPSchema did not find RSOP_WMIGPO, will compile mof\n"));
		HRESULT hr = EnsureSchema(pNamespace, L"WMI_RSOP.MOF");

		if (FAILED(pNamespace->GetObject(RSOP_WMIGPOName, WBEM_FLAG_DIRECT_READ,  
                                          NULL, &pRandomClass, NULL)))
		{
			ERRORTRACE((LOG_ESS, "CSE: cannot find RSOP_WMIGPO after successful mof compilation!\n"));
			return WBEM_E_FAILED;
		}
		else
		{
			DEBUGTRACE((LOG_ESS, "CSE: found RSOP_WMIGPO after successful mof compilation!\n"));;
			pRandomClass->Release();
		}

		return hr;
	}
}

HRESULT EnsurePolicySchema(IWbemServices* pNamespace)
{    
    // grab a random class to determine whether our schema has been compiled yet.
    IWbemClassObject* pRandomClass = NULL;
    
    if (SUCCEEDED(pNamespace->GetObject(MSFT_PolicyTemplateName, WBEM_FLAG_DIRECT_READ,  
                                          NULL, &pRandomClass, NULL)))
    {
        pRandomClass->Release();
        return WBEM_S_NO_ERROR;
    }
    else
        return EnsureSchema(pNamespace, L"WMIPolicy.mof");
}

// given ds path
// creates MSFT_WMIGPO.DsPath="path"
inline void MakeGPOPath(const WCHAR* pDsPath, WCHAR* pBuf)
{
	swprintf(pBuf, WMIGPO_GETOBJECT_TEMPLATE, pDsPath);
}

// called by FixupPath, does actual parse & replace
// changes data in pParsedObjectPath
// alloc's bstr for return (with luck...)
HRESULT DoPathEdit(ParsedObjectPath* pParsedObjectPath, DWORD nKey, BSTR& newPath)
{
    DEBUGTRACE((LOG_ESS, "CSE: DoPathEdit\n"));
    
    HRESULT hr = WBEM_E_FAILED;
	
	PDOMAIN_CONTROLLER_INFO pInfo;
	if (0 == DsGetDcName(NULL, NULL, NULL, NULL, DS_RETURN_DNS_NAME, &pInfo))		
	{
		if (pInfo->DomainName)
		{
			// safe copy "Domain" has fewer chars than "DsContext"
			wcscpy(pParsedObjectPath->m_paKeys[nKey]->m_pName, L"Domain");
			
			// this will be freed externally via CObjectPathParser::Free
			BSTR valueName;
			if (valueName = SysAllocString(pInfo->DomainName))
			{
				SysFreeString(pParsedObjectPath->m_paKeys[nKey]->m_vValue.bstrVal);
				pParsedObjectPath->m_paKeys[nKey]->m_vValue.bstrVal = valueName;

				CObjectPathParser objPath(e_ParserAcceptRelativeNamespace);
				int nRet;

				WCHAR* tempNewPath;
				nRet = objPath.Unparse(pParsedObjectPath, &tempNewPath);

				if (nRet == CObjectPathParser::OutOfMemory)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (nRet == CObjectPathParser::NoError)
				{
					if (newPath = SysAllocString(tempNewPath))
						hr = WBEM_S_NO_ERROR;
					
					delete[] tempNewPath;
				}
				else
					hr = WBEM_E_FAILED;
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
		}
		NetApiBufferFree(pInfo);
	}

    DEBUGTRACE((LOG_ESS, "CSE: DoPathEdit returning 0x%08X (%S)\n", hr, newPath));

	return hr;
}

// support for legacy versions where the path may contain DsContext = LOCAL
// bstr may be different upon exit [IN OUT]
// returns success if finds DsContext = LOCAL
// returns WBEM_E_INVALID_PATH if DsContext = GLOBAL
HRESULT FixupPath(BSTR& path)
{
	DEBUGTRACE((LOG_ESS, "CSE: Fixup Path %S\n", path));
    
    HRESULT hr = WBEM_E_INVALID_OBJECT_PATH;

	enum ParseResults {GoodPath, BadPath, FixablePath};
	ParseResults parseResult = BadPath;
	DWORD whichKey = 0;
	
	CObjectPathParser objPath(e_ParserAcceptRelativeNamespace);

    ParsedObjectPath* pParsedObjectPath = NULL;

	if ((objPath.NoError == objPath.Parse(path, &pParsedObjectPath)))
	{
		parseResult = GoodPath;

		for (DWORD i = 0; i < pParsedObjectPath->m_dwNumKeys; i++)
			if (_wcsicmp(DsContextName, pParsedObjectPath->m_paKeys[i]->m_pName) == 0)
			{
				if ((pParsedObjectPath->m_paKeys[i]->m_vValue.vt == VT_BSTR) &&
					(pParsedObjectPath->m_paKeys[i]->m_vValue.bstrVal != NULL) &&
					(_wcsicmp(DsLocalValue, pParsedObjectPath->m_paKeys[i]->m_vValue.bstrVal) == 0)
				   )
				{
					parseResult = FixablePath;
					whichKey = i;
				}
				else
					parseResult = BadPath;
				break;
			}		
	}
	
	switch (parseResult)
	{
		case GoodPath:
			hr = WBEM_S_NO_ERROR;
			break;
		case BadPath:
			hr = WBEM_E_INVALID_OBJECT_PATH;
			break;
		case FixablePath:
		{
			BSTR newPath = NULL;
			if (SUCCEEDED(hr = DoPathEdit(pParsedObjectPath, whichKey, newPath)))
			{
				SysFreeString(path);
				path = newPath;
			}
		}
	}

	if (pParsedObjectPath)
		objPath.Free(pParsedObjectPath);

    DEBUGTRACE((LOG_ESS, "CSE: Fixup Path returning 0x%08X, (%S)\n", hr, path));

	return hr;
}

// given ds path of MSFT_WMIGPO object
// retrieves paths of templates packed in variant
HRESULT GetPolicyTemplatePaths(IWbemServices* pPolicyNamespace, const WCHAR* pWMIGPOPath, VARIANT& v)
{
    HRESULT hr;

    // get MSFT_WMIGPO
	WCHAR pathBuf[WMIGPO_GETOBJECT_STRLEN] = L"";
	MakeGPOPath(pWMIGPOPath, pathBuf);
	IWbemClassObject* pWMIGPO = NULL;
    BSTR bstrPath = SysAllocString(pathBuf);
    
    if (NULL == bstrPath)
        return WBEM_E_OUT_OF_MEMORY;
    else
    {
		hr = FixupPath(bstrPath);
		if (FAILED(hr))
			return hr;

	    if (FAILED(hr = pPolicyNamespace->GetObject(bstrPath, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pWMIGPO, NULL)))
		    ERRORTRACE((LOG_ESS, "CSE: Failed GetObject(%S) 0x%08X\n", pathBuf, hr));
	    else
	    {
		    if (FAILED(hr = pWMIGPO->Get(L"PolicyTemplate", 0, &v, NULL, NULL))) 
			    ERRORTRACE((LOG_ESS, "CSE: Failed MSFT_WMIGPO->Get(PolicyTemplate)  (0x%08X)\n", hr));
		    else 
		    {
			    if (v.vt != (VT_BSTR | VT_ARRAY))
			    {
				    hr = WBEM_E_INVALID_PARAMETER;
				    ERRORTRACE((LOG_ESS, "CSE: MSFT_WMIGPO \"%S\" contains invalid path\n", pWMIGPOPath));
                    VariantClear(&v);
			    }
            } // if got policy template reference

		    pWMIGPO->Release();
	    } // if Got GPO Object

		SysFreeString(bstrPath);
    }

    return hr;
}

// given ds history path of RSOP_PolicyObject in history
// retrieves paths of templates packed in variant
HRESULT GetPolicyTemplatePathsFromHistory(IWbemServices* pHistoryNamespace, const WCHAR* pPOPath, IWbemClassObject** pPO, VARIANT& v)
{
    HRESULT hr;

    // get MSFT_WMIGPO
//	IWbemClassObject* pPO = NULL;
    BSTR bstrPath = SysAllocString(pPOPath);
    if (!bstrPath)
        return WBEM_E_OUT_OF_MEMORY;
    
	if (FAILED(hr = pHistoryNamespace->GetObject(bstrPath, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, pPO, NULL)))
		ERRORTRACE((LOG_ESS, "CSE: Failed GetObject(%S) 0x%08X\n", bstrPath, hr));
	else
	{
        VariantInit(&v);
        
        if (FAILED(hr = (*pPO)->Get(L"templates", 0, &v, NULL, NULL))) 
			ERRORTRACE((LOG_ESS, "CSE: Failed MSFT_WMIGPOPolicySetting->Get(templates)  (0x%08X)\n", hr));
		else 
		{
			if (v.vt != (VT_BSTR | VT_ARRAY))
			{
				hr = WBEM_E_INVALID_PARAMETER;
				ERRORTRACE((LOG_ESS, "CSE: MSFT_WMIGPOPolicySetting \"%S\" contains invalid path\n", pPOPath));
                VariantClear(&v);
			}
        } // if got policy template reference

		// pPO->Release();
	} // if Got GPO Object

	if (bstrPath)
		SysFreeString(bstrPath);

    return hr;
}

// given ds path of MSFT_WMIGPO object, retrieves
// associated policy Templates, stuffs 'em all into the template map
HRESULT GetPolicyTemplates(IWbemServices* pPolicyNamespace, const WCHAR* pPath, TemplateMap& policies,
                           IWbemServices* pRSOPNamespace, IWbemClassObject* pRsopWMIGPOClass, IWbemClassObject* pRsopTemplateClass,
                           IWbemServices* pHistoryNamespace, IWbemClassObject* pMsftWMIGPOClass, IWbemClassObject* pMsftTemplateClass)
{
	DEBUGTRACE((LOG_ESS, "CSE: GetPolicyTemplate\n"));
    
    HRESULT hr = WBEM_S_NO_ERROR;
    BSTR bstr = NULL;
	  IWbemClassObject *pTemplate = NULL;

    VARIANT vPaths;
    VariantInit(&vPaths);

    IWbemClassObject* pRsopWMIGPOObj = NULL;
    CReleaseMe relWmiGpo(pRsopWMIGPOObj);

    IWbemClassObject* pMsftWMIGPOObj = NULL;
    CReleaseMe relOtherWmiGpo(pMsftWMIGPOObj);
    
    if (pRSOPNamespace || pHistoryNamespace)
    {
        // if we're writing to either, we will want both of these
        VARIANT vPrecedence;
        VariantInit(&vPrecedence);
        vPrecedence.vt = VT_I4;
        vPrecedence.lVal = 1;


        VARIANT vID;
        VariantInit(&vID);
        vID.vt = VT_BSTR;
        vID.bstrVal = SysAllocString(pPath);
        CSysFreeMe freeTheBeast(vID.bstrVal);
            

        
        if (pRSOPNamespace)
        {
            if (FAILED(hr = pRsopWMIGPOClass->SpawnInstance(0, &pRsopWMIGPOObj)))
            {
                ERRORTRACE((LOG_ESS, "CSE: pRsopWMIGPOClass->SpawnInstance failed, 0x%08X\n", hr));
                return hr;
            }
            else
            {
                pRsopWMIGPOObj->Put(L"precedence", 0, &vPrecedence, NULL);
                pRsopWMIGPOObj->Put(L"GPOID", 0, &vID, NULL);
                pRsopWMIGPOObj->Put(L"id", 0, &vID, NULL);
            }
        }

        if (pHistoryNamespace)
        {
            if (FAILED(hr = pMsftWMIGPOClass->SpawnInstance(0, &pMsftWMIGPOObj)))
            {
                ERRORTRACE((LOG_ESS, "CSE: pMsftWMIGPOClass->SpawnInstance failed, 0x%08X\n", hr));
                return hr;
            }
            else
            {
                pMsftWMIGPOObj->Put(L"precedence", 0, &vPrecedence, NULL);
                pMsftWMIGPOObj->Put(L"GPOID", 0, &vID, NULL);
                pMsftWMIGPOObj->Put(L"id", 0, &vID, NULL);
            }
        }
    }

    if (SUCCEEDED(hr = GetPolicyTemplatePaths(pPolicyNamespace, pPath, vPaths)))
    {
        SafeArray<BSTR, VT_BSTR> paths(&vPaths);

        SAFEARRAYBOUND arrayBounds;
        arrayBounds.lLbound = 0;
        arrayBounds.cElements = paths.Size();

        SAFEARRAY* pRsopReferences = SafeArrayCreate(VT_BSTR, 1, &arrayBounds);
        if (pRsopReferences == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        SAFEARRAY* pMsftReferences = SafeArrayCreate(VT_BSTR, 1, &arrayBounds);
        if (pMsftReferences == NULL)
            return WBEM_E_OUT_OF_MEMORY;

    
        for (long i = 0; i < paths.Size(); i++)
        {
            hr = FixupPath(paths[i]);
			if (FAILED(hr))
				return hr;
			
			pTemplate = NULL;
            if (FAILED(hr = pPolicyNamespace->GetObject(paths[i], WBEM_FLAG_RETURN_WBEM_COMPLETE, 
					                                    NULL, &pTemplate, NULL)))
	        {
		        ERRORTRACE((LOG_ESS, "CSE: Failed to retrieve \"%S\", (0x%08X)\n", bstr, hr));
		        hr = WBEM_E_INVALID_PARAMETER;
            break;
	        }
            else
            {
                CReleaseMe relTemplate1(pTemplate);
                
                VARIANT v;
                VariantInit(&v);

                if (SUCCEEDED(pTemplate->Get(L"targetPath", 0, &v, NULL, NULL)))
                {
                    policies.Add(v.bstrVal, pTemplate);                        
                    VariantClear(&v);
                }                 

                if (pRSOPNamespace || pHistoryNamespace)
                {
                    VARIANT vUnk;
                    VariantInit(&vUnk);
                    vUnk.vt = VT_UNKNOWN;
                    vUnk.punkVal = pTemplate; // no addref, no release

                    VARIANT v;
                    IWbemClassObject* pAppliedTemplate = NULL;

                    if (pRSOPNamespace)
                    {
                        if (FAILED(hr = pRsopTemplateClass->SpawnInstance(0, &pAppliedTemplate)))
                            return hr;
                        else
                        {
                            CReleaseMe relTemplate2(pAppliedTemplate);
                                        
                            pAppliedTemplate->Put(L"template", 0, &vUnk, NULL);

                            VariantInit(&v);
                            pTemplate->Get(L"__RELPATH", 0, &v, NULL, NULL);
                            pAppliedTemplate->Put(L"templatePath", 0, &v, NULL);
                            VariantClear(&v);
                            
                            pRSOPNamespace->PutInstance(pAppliedTemplate, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

                            pAppliedTemplate->Get(L"__RELPATH", 0, &v, NULL, NULL);

                            SafeArrayPutElement(pRsopReferences, &i, v.bstrVal);
                            VariantClear(&v);                    

                            pAppliedTemplate = NULL;
                        }                
                    }

                    if (pHistoryNamespace)
                    {
                        if (FAILED(hr = pMsftTemplateClass->SpawnInstance(0, &pAppliedTemplate)))
                            return hr;
                        else
                        {

                            CReleaseMe relTemplate2(pAppliedTemplate);
                                        
                            hr = pAppliedTemplate->Put(L"template", 0, &vUnk, NULL);

                            VariantInit(&v);
                            pTemplate->Get(L"__RELPATH", 0, &v, NULL, NULL);
                            hr = pAppliedTemplate->Put(L"templatePath", 0, &v, NULL);
                            VariantClear(&v);

                            hr = pHistoryNamespace->PutInstance(pAppliedTemplate, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
                            if (FAILED(hr))
                            {
                                ERRORTRACE((LOG_ESS, "Failed to put to history namespace 0x%08X\n",hr));
                                SafeArrayDestroy(pRsopReferences);
								SafeArrayDestroy(pMsftReferences);
								return hr;
                            }

                            pAppliedTemplate->Get(L"__RELPATH", 0, &v, NULL, NULL);

                            SafeArrayPutElement(pMsftReferences, &i, v.bstrVal);
                            VariantClear(&v);                    

                            pAppliedTemplate = NULL;
                        }                
                    }

                }
            } // end else
        } /// end for
        
        if(SUCCEEDED(hr))
        {
          VARIANT vAgain;
          VariantInit(&vAgain);
          vAgain.vt = VT_ARRAY | VT_BSTR;

          if (pHistoryNamespace)
          {
            vAgain.parray = pMsftReferences;
            pMsftWMIGPOObj->Put(L"templates", 0, &vAgain, NULL);
            hr = pHistoryNamespace->PutInstance(pMsftWMIGPOObj,  WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
          }

          if (pRSOPNamespace)
          {    
            vAgain.parray = pRsopReferences;
            pRsopWMIGPOObj->Put(L"templates", 0, &vAgain, NULL);
            hr = pRSOPNamespace->PutInstance(pRsopWMIGPOObj,  WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
          }

          VariantClear(&vPaths);
        }

        SafeArrayDestroy(pRsopReferences);
        SafeArrayDestroy(pMsftReferences);
    }

    DEBUGTRACE((LOG_ESS, "CSE: GetPolicyTemplate returning 0x%08X\n", hr));

	return hr;
}

// TODO: enable undelete (via a sub-namespace?)
// TODO: too darned deeply nested, break into smaller functions
HRESULT DeleteOldPolicies(IWbemServices* pPolicyNamespace, 
                          IWbemServices *pRSOPNamespace, 
                          PGROUP_POLICY_OBJECT pGPOList, 
                          TemplateMap& newPolicies)
{
    // no need to actually retrieve policies
    // if we've got said policy in history, we delete it
    //  if it IS the last policy of that type, we delete target instance
    //  if it is NOT the last policy, we stack up the remainders in the new policies
    
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemServices* pHistory;
    
    // TODO: this indents too deep. fix.
    PGROUP_POLICY_OBJECT pThisGPO;
    if (pThisGPO = pGPOList)
        if (SUCCEEDED(hr = GetHistoryNamespace(pHistory)))             
        {
            
            try 
            {
                do
                if (pThisGPO->lpDSPath)
                {
                    
                    DEBUGTRACE((LOG_ESS, "CSE: Deleting Policy '%S'\n\tcontaining path '%S'\n", 
                        pThisGPO->lpDisplayName, pThisGPO->lpDSPath));  
                    
                    // retrieve GPO from history
                    QString
                        pBuf(L"MSFT_WMIGPOPolicySetting.id='");
                    
                    pBuf << pThisGPO->lpDSPath << L"'";
                    
                    VARIANT vPaths;
                    VariantInit(&vPaths);
                    
                    CComPtr<IWbemClassObject>
                        pWMIGPO;
                    
                    if (SUCCEEDED(hr = GetPolicyTemplatePathsFromHistory(pHistory, pBuf, &pWMIGPO, vPaths)))
                    {
                        SafeArray<BSTR, VT_BSTR> paths(&vPaths);
                        
                        for (int i = 0; i < paths.Size(); i++)
                        {
                            IWbemClassObject* pDeadObject = NULL;
                            
                            // if it's not there, we've got no more work to do
                            if (SUCCEEDED(pHistory->GetObject(paths[i], 0,NULL, &pDeadObject,  NULL)))
                            {
                                // first delete from history...
                                
                                hr = pHistory->DeleteInstance(paths[i], 0, NULL, NULL);
                                
                                // **** next, delete from RSOP namespace
                                
                                if(NULL != pRSOPNamespace)
                                {
                                    CComVariant
                                        vTemplatePath;
                                    
                                    QString
                                        path(RSOP_AppliedPolicyTemplateName);
                                    
                                    hr = pDeadObject->Get(L"TemplatePath",  0, &vTemplatePath, NULL, NULL);
                                    
                                    path << L".TemplatePath='" << vTemplatePath.bstrVal << L"'";
                                    
                                    hr = pRSOPNamespace->DeleteInstance(path, 0, NULL, NULL);
                                }
                                
                                VARIANT vID;
                                VariantInit(&vID);
                                
                                VARIANT vObj;
                                VariantInit(&vObj);
                                
                                // okay, we deleted it.
                                // see if there are any left...
                                // get the object out of the object, unless it objects
                                if (SUCCEEDED(pDeadObject->Get(L"template", 0, &vObj, NULL, NULL)))
                                {
                                    IWbemClassObject* pDeadObjectObject = NULL;
                                    
                                    vObj.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pDeadObjectObject);
                                    CReleaseMe relDeadDead(pDeadObjectObject);
                                    if (SUCCEEDED(hr = pDeadObjectObject->Get(L"TargetPath", 0, &vID, NULL, NULL)))
                                    {
                                        // TODO: fix for indeterminant buffer size...
                                        WCHAR query[1024];
                                        swprintf(query, L"Select * from MSFT_AppliedPolicyTemplate where template.TargetPath = \"%S\"",vID.bstrVal);
                                        IEnumWbemClassObject *pEnum = NULL;
                                        bool bGotOne = false;
                                        
                                        if (SUCCEEDED(pHistory->ExecQuery(L"WQL", query, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnum)))
                                        {                                    
                                            HRESULT hrLoop;
                                            IWbemClassObject* pTemplate = NULL;
                                            ULONG uReturned;
                                            
                                            if (SUCCEEDED(hrLoop = pEnum->Next(WBEM_INFINITE, 1, &pTemplate, &uReturned)) && (hrLoop != WBEM_S_FALSE))
                                            {
                                                // we're not doing the re-collection of non-deleted templates right now
                                                // reserve the right to put it back later
                                                bGotOne = true;
                                                // newPolicies.Add(vID.bstrVal, pTemplate);
                                                
                                                pTemplate->Release();
                                                pTemplate = NULL;
                                            }
                                            
                                            pEnum->Release();
                                        }
                                        
                                        // if there are no outstanding templates
                                        // we will want to delete the target object
                                        // TODO: better error handling
                                        if (!bGotOne)
                                        {
                                            CComVariant vNamespace;
                                            
                                            // **** delete target object
                                            
                                            if (SUCCEEDED(pDeadObjectObject->Get(L"TargetNamespace", 0, &vNamespace, NULL, NULL)))
                                            {
                                                IWbemServices *pTargetNamespace = NULL;
                                                
                                                if (SUCCEEDED(GetNamespace(vNamespace.bstrVal, pTargetNamespace, false)))
                                                    if (FAILED(hr = pTargetNamespace->DeleteInstance(vID.bstrVal, 0, NULL, NULL)))
                                                        ERRORTRACE((LOG_ESS, "CSE: Unable to delete %S 0x%08X\n", vID.bstrVal, hr));
                                                    
                                                    if(NULL != pTargetNamespace) pTargetNamespace->Release();
                                            }
                                            
                                            // **** delete MSFT_WMITargetObject associated with target object
                                            
                                            if(pHistory != NULL)
                                            {
                                                QString
                                                    wmiTargetObject(MSFT_WmiTargetObjectName);
                                                
                                                wmiTargetObject << L".TargetPath='" << vID.bstrVal << L"'";
                                                
                                                hr = pHistory->DeleteInstance(wmiTargetObject, 0, NULL, NULL);
                                                if(FAILED(hr))
                                                    ERRORTRACE((LOG_ESS, "CSE: Unable to delete %S 0x%08X\n", wmiTargetObject, hr));
                                            }
                                            
                                            // **** delete RSOP_AppliedPolicyTemplate associated with target object
                                            
                                            if(pRSOPNamespace != NULL)
                                            {
                                                QString
                                                    wmiTargetObject(RSOP_WmiTargetObjectName);
                                                
                                                wmiTargetObject << L".TargetPath='" << vID.bstrVal << L"'";
                                                
                                                hr = pRSOPNamespace->DeleteInstance(wmiTargetObject, 0, NULL, NULL);
                                                if(FAILED(hr))
                                                    ERRORTRACE((LOG_ESS, "CSE: Unable to delete %S 0x%08X\n", wmiTargetObject, hr));
                                            }
                                        }
                                    }
                                    
                                    VariantClear(&vID);                                
                                }    
                                
                                pDeadObject->Release();
                                } //
                            }// end for
                            
                            // **** clean up MSFT_WMIGPOPolicySetting object
                            
                            VariantClear(&vPaths);
                            
                            hr = pHistory->DeleteInstance(pBuf, 0, NULL, NULL);
                            if(FAILED(hr))
                                ERRORTRACE((LOG_ESS, "CSE: Unable to delete %S 0x%08X\n", pBuf, hr));
                            
                            if(NULL != pRSOPNamespace)
                            {
                                QString
                                    RSOPpath(RSOP_WMIGPOName);
                                
                                RSOPpath << L".id='" << pThisGPO->lpDSPath << L"'";
                                
                                hr = pRSOPNamespace->DeleteInstance(RSOPpath, 0, NULL, NULL);
                                if(FAILED(hr))
                                    ERRORTRACE((LOG_ESS, "CSE: Unable to delete %S 0x%08X\n", (wchar_t*)RSOPpath, hr));
                            }
                        } // if (SUCCEEDED(hr = GetPolicyTemplatePaths(pPolicyNamespace, yada, yada
                    } // if (pThisGPO->lpDSPath)
                    while (pThisGPO = pThisGPO->pNext);
            }
            catch (...)
            {
                // here mostly to catch bad pointers in the list
                DEBUGTRACE((LOG_ESS, "CSE: caught exception: continuing\n"));
                hr = WBEM_E_CRITICAL_ERROR;
            }
            pHistory->Release();
        }
        
        if (FAILED(hr))
            ERRORTRACE((LOG_ESS, "CSE: DeleteOldPolicies failed: 0x%08X\n", hr));
        
        return hr;
}

// retrieve policies associated with GPO list
// policies returned as IWbemObjects, positive refcount
HRESULT GetPolicyArray(IWbemServices* pPolicyNamespace, PGROUP_POLICY_OBJECT pGPOList, 
                       IWbemServices* pRSOPNamespace, 
                       IWbemServices* pHistoryNamespace, TemplateMap& policies)
{
	HRESULT hr = WBEM_S_NO_ERROR;	
    
    IWbemClassObject* pRsopWmiGpo   = NULL;
    IWbemClassObject* pRsopTemplate = NULL;
    IWbemClassObject* pMsftWmiGpo   = NULL;
    IWbemClassObject* pMsftTemplate = NULL;

    CReleaseMe relpRsopWmiGpo  (pRsopWmiGpo  );
    CReleaseMe relpRsopTemplate(pRsopTemplate);
    CReleaseMe relpMsftWmiGpo  (pMsftWmiGpo  );
    CReleaseMe relpMsftTemplate(pMsftTemplate);

    if (pRSOPNamespace)
    {
        hr = pRSOPNamespace->GetObject(RSOP_WMIGPOName,                0, NULL, &pRsopWmiGpo,   NULL);
		if (FAILED(hr))
		{
			ERRORTRACE((LOG_ESS, "CSE: Unable to retrieve RSOP wmigpo 0x%08X\n", hr));
			return hr;
		}
        
        hr = pRSOPNamespace->GetObject(RSOP_AppliedPolicyTemplateName, 0, NULL, &pRsopTemplate, NULL);
		if (FAILED(hr))
		{
			ERRORTRACE((LOG_ESS, "CSE: Unable to retrieve RSOP policy template 0x%08X\n", hr));
			return hr;
		}
        
    }

    if (pHistoryNamespace)
    {
        hr = pHistoryNamespace->GetObject(MSFT_WMIGPOName,                0, NULL, &pMsftWmiGpo,   NULL);
        if (FAILED(hr))
		{
			ERRORTRACE((LOG_ESS, "CSE: Unable to retrieve History wmigpo 0x%08X\n", hr));
			return hr;
		}
		hr = pHistoryNamespace->GetObject(MSFT_AppliedPolicyTemplateName, 0, NULL, &pMsftTemplate, NULL);
		if (FAILED(hr))
		{
			ERRORTRACE((LOG_ESS, "CSE: Unable to retrieve History policy template 0x%08X\n", hr));
			return hr;
		}
    }

    

    PGROUP_POLICY_OBJECT pThisGPO;
	if (pThisGPO = pGPOList)
    {
        try
        {
            do
			    if (pThisGPO->lpDSPath)
			    {
				    DEBUGTRACE((LOG_ESS, "CSE: Retrieving Policy '%S'\n\tcontaining path '%S'\n", 
							    pThisGPO->lpDisplayName, pThisGPO->lpDSPath));  
				    
				    if (FAILED(hr = GetPolicyTemplates(pPolicyNamespace, pThisGPO->lpDSPath, policies,
                                               pRSOPNamespace, pRsopWmiGpo, pRsopTemplate,
                                               pHistoryNamespace, pMsftWmiGpo, pMsftTemplate
                                               )))
                    {
                        ERRORTRACE((LOG_ESS, "Error retrieving policy pThisGPO->lpDSPath (0x%08X)\n", hr));
                    }
			    }
		    while (SUCCEEDED(hr) && (pThisGPO = pThisGPO->pNext));
        }
        catch (...)
        {
            // here mostly to recover from bad pointers in the list...
            hr = WBEM_E_CRITICAL_ERROR;
        }
    }

    return hr;
}

// assuming that pTypeObj is a MSFT_PolicyType
// PutClass's embedded class def'n
// and PutInstance's embedded instances
HRESULT SetTypeFromObj(IWbemServices* pTargetNamespace, IWbemClassObject* pTypeObj, IWbemClassObject** ppClassDef)
{
    VARIANT vTypeType;
    VariantInit (&vTypeType);
    HRESULT hr = WBEM_E_FAILED;

	DEBUGTRACE((LOG_ESS, "CSE: SetTypeFromObj\n"));

    // do it for instances (may be types - class definitions!)
    if (SUCCEEDED(hr = pTypeObj->Get(L"InstanceDefinitions", 0, &vTypeType, NULL, NULL)))
    {
        if ((vTypeType.vt != VT_NULL) && (vTypeType.punkVal != NULL))
        {
            SafeArray<IUnknown*, VT_UNKNOWN> punks(&vTypeType);

			DEBUGTRACE((LOG_ESS, "CSE: Putting %d instance definitions\n", punks.Size()));

            for (int i = 0; i < punks.Size() && (SUCCEEDED(hr)); i++)
            {
                
				IWbemClassObject* pObj = NULL;
                if (punks[i] && SUCCEEDED(hr = punks[i]->QueryInterface(IID_IUnknown, (void**)&pObj) ))
                {                    
					CReleaseMe relativeUnknown(pObj);
                    VARIANT v;
                    VariantInit(&v);
                    
                    pObj->Get(L"__Genus", 0, &v, NULL, NULL);

					VARIANT vDebug;
					VariantInit(&vDebug);
					
                    if (v.lVal == WBEM_GENUS_CLASS)
                    {
						pObj->Get(L"__CLASS", 0, &vDebug, NULL, NULL);

                       	DEBUGTRACE((LOG_ESS, "CSE: Putting class %S\n", vDebug.bstrVal));

						if (FAILED(hr = pTargetNamespace->PutClass(pObj, 
                                           WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_FORCE_MODE,
                                           NULL, NULL)))
                            ERRORTRACE((LOG_ESS, "CSE: put class failed 0x%08X\n", hr));                
                    }
                    else
                    {
						pObj->Get(L"__RELPATH", 0, &vDebug, NULL, NULL);

						DEBUGTRACE((LOG_ESS, "CSE: Putting instance %S\n", vDebug.bstrVal));

                        //if (FAILED(hr = pTargetNamespace->PutInstance(pObj, 
                        //                   WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_CREATE_OR_UPDATE,
                        //                   NULL, NULL)))
						if (FAILED(hr = PutInstance(pTargetNamespace, pObj)))
                            ERRORTRACE((LOG_ESS, "CSE: put instance failed 0x%08X\n", hr));                
                    }

					VariantClear(&vDebug);
                }
            }
        }
        VariantClear(&vTypeType);
    }

    // do it for class def'n
    if (SUCCEEDED(hr) && SUCCEEDED(hr = pTypeObj->Get(L"ClassDefinition", 0, &vTypeType, NULL, NULL)))
    {
        
		if ((vTypeType.vt != VT_NULL) && (vTypeType.punkVal != NULL))
        {

            IWbemClassObject* pObj = NULL;

            if (SUCCEEDED(hr = vTypeType.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pObj)))
			{
				// nope - not gonna release it, wouldn't be prudent
				// we're gonna return it from the function instead
				//CReleaseMe relObject(pObj);
				*ppClassDef = pObj;				

				VARIANT vDebug;
				VariantInit(&vDebug);
				pObj->Get(L"__CLASS", 0, &vDebug, NULL, NULL);

		       	DEBUGTRACE((LOG_ESS, "CSE: Putting ClassDefinition %S\n", vDebug.bstrVal));

				VariantClear(&vDebug);
                if (FAILED(hr = pTargetNamespace->PutClass(pObj, 
                                       WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_FORCE_MODE,
                                       NULL, NULL)))
                    ERRORTRACE((LOG_ESS, "CSE: put class failed 0x%08X\n", hr));                
			}
        }
		

        VariantClear(&vTypeType);
    }

    if (FAILED(hr))
         ERRORTRACE((LOG_ESS, "CSE: SetTypeFromObj failed 0x%08X\n", hr));
	
	return hr;
}

// retrieve template path from object
// determine whether we've aleady got one
// if not, retrieve one & put the class & all
HRESULT EnsureType(IWbemServices* pTargetNamespace, IWbemServices* pPolicyNamespace, 
				   IWbemServices* pHistoryNamespace, 
                   IWbemClassObject* pTemplate, IWbemServices* pRsopNamespace, 
                   IWbemClassObject* pRsopObj,  IWbemClassObject* pHistoryObj,
				   IWbemClassObject** ppClassDef)
{
    HRESULT hr = WBEM_E_FAILED;

	DEBUGTRACE((LOG_ESS, "CSE: EnsureType\n"));
	
	VARIANT vTypeName;
    VariantInit(&vTypeName);

    if (SUCCEEDED(pTemplate->Get(L"TargetType", 0, &vTypeName, NULL, NULL))
        && (vTypeName.vt == VT_BSTR) && (vTypeName.bstrVal != NULL))
    {        
		DEBUGTRACE((LOG_ESS, "CSE: Target Type is %S\n", vTypeName.bstrVal));    
        
        WCHAR templ[] = L"MSFT_AppliedPolicyType.typePath='%s'";

        WCHAR* pBuf = new WCHAR[wcslen(templ) + wcslen(vTypeName.bstrVal) +1];
        if (!pBuf)
            return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<WCHAR> delChars(pBuf);
        
        swprintf(pBuf, templ, vTypeName.bstrVal);

        BSTR typePath = SysAllocString(pBuf);
        if (!typePath)
        {
            ERRORTRACE((LOG_ESS, "CSE: Allocation failed on type path\n"));
            return WBEM_E_OUT_OF_MEMORY;
        }
        CSysFreeMe freeBeer(typePath);

        // record type in target object
        VARIANT vTypePath;
        VariantInit(&vTypePath);
        vTypePath.vt = VT_BSTR;
        vTypePath.bstrVal = typePath;
        if (pRsopObj) 
            pRsopObj->Put(L"type", 0, &vTypePath, NULL);
        if (pHistoryObj)
            pHistoryObj->Put(L"type", 0, &vTypePath, NULL);

        IWbemClassObject* pTypeObj = NULL;
        CReleaseMe relative(pTypeObj);
   		IWbemClassObject* pHistoryTypeObj = NULL;


        // check to see if we've got it in history
        // pRSOPTypeObj should be initialized in one of the if/else clauses
        if (pHistoryNamespace && SUCCEEDED(pHistoryNamespace->GetObject(typePath, 0, NULL, &pHistoryTypeObj, NULL)))
        {
       		DEBUGTRACE((LOG_ESS, "CSE: found Target Type in history\n"));    
			
			VARIANT v;
            VariantInit(&v);
            
            if (SUCCEEDED(pHistoryTypeObj->Get(L"type", 0, &v, NULL, NULL)))
            {
                IWbemClassObject* pType = NULL;
                if (SUCCEEDED(v.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pTypeObj)))
                {
                    hr = SetTypeFromObj(pTargetNamespace, pTypeObj, ppClassDef);
                }
            }

            VariantClear(&v);
        }
        else
        {
			DEBUGTRACE((LOG_ESS, "CSE: retrieving Target Type from DS\n"));   
			if (FAILED(hr = FixupPath(vTypeName.bstrVal)))
				return hr;
            
            if (SUCCEEDED(hr = pPolicyNamespace->GetObject(vTypeName.bstrVal, 0, NULL, &pTypeObj, NULL)))
            {
                hr = SetTypeFromObj(pTargetNamespace, pTypeObj, ppClassDef);
                IWbemClassObject* pTypeTypeType = NULL;

                // Keep a history object for next time
                if (pHistoryNamespace && SUCCEEDED(pHistoryNamespace->GetObject(MSFT_AppliedPolicyTypeName, 0, NULL, &pTypeTypeType, NULL)))
                {
                    if (hr = SUCCEEDED(pTypeTypeType->SpawnInstance(0, &pHistoryTypeObj)))
                    {
                        VARIANT vObj;
                        VariantInit(&vObj);
                        vObj.vt = VT_UNKNOWN;
                        vObj.punkVal = pTypeObj;

                        VARIANT vPath;
                        VariantInit(&vPath);
                        
                        if (SUCCEEDED(pTypeObj->Get(L"__RELPATH", 0, &vPath, NULL, NULL)) &&
                            SUCCEEDED(pHistoryTypeObj->Put(L"type", 0, &vObj, NULL)) &&
                            SUCCEEDED(pHistoryTypeObj->Put(L"typePath", 0, &vPath, NULL)))
                            pHistoryNamespace->PutInstance(pHistoryTypeObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
                        else
                        {
                            // it's no good without the data, delete it now
                            pHistoryTypeObj->Release();
                            pHistoryTypeObj = NULL;
							hr = WBEM_E_FAILED;
                        }
                        VariantClear(&vPath);
                    }
                    pTypeTypeType->Release();
                }
            }
        }

        if (pHistoryTypeObj)
            pHistoryTypeObj->Release();


        // make type available in RSOP
        if (pRsopNamespace && pTypeObj)
        {
            IWbemClassObject* pRSOPTypeClass = NULL;
            IWbemClassObject* pRSOPTypeObj = NULL;

            if (SUCCEEDED(pRsopNamespace->GetObject(RSOP_AppliedPolicyTypeName, 0, NULL, &pRSOPTypeClass, NULL)))              
            {
                CReleaseMe rel45(pRSOPTypeClass);

                if (SUCCEEDED(pRSOPTypeClass->SpawnInstance(0, &pRSOPTypeObj)))
                {
                    CReleaseMe rel46(pRSOPTypeObj);
                    
                    VARIANT vObj;
                    VariantInit(&vObj);
                    vObj.vt = VT_UNKNOWN;
                    vObj.punkVal = pTypeObj;

                    VARIANT vPath;
                    VariantInit(&vPath);
                    
                    if (SUCCEEDED(pTypeObj->Get(L"__RELPATH", 0, &vPath, NULL, NULL)) &&
                        SUCCEEDED(pRSOPTypeObj->Put(L"type", 0, &vObj, NULL)) &&
                        SUCCEEDED(pRSOPTypeObj->Put(L"typePath", 0, &vPath, NULL)))
                        pRsopNamespace->PutInstance(pRSOPTypeObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

                    VARIANT vRsopPath;
                    VariantInit(&vRsopPath);
        
                    pRSOPTypeObj->Get(L"__RELPATH", 0, &vRsopPath, NULL, NULL);
                    pRsopObj->Put(L"policyType", 0,  &vRsopPath, NULL);
        
                    VariantClear(&vRsopPath);
                }
            }
        }

        VariantClear(&vTypeName);
    }
	else
	// retrieve type from namespace
	{
		DEBUGTRACE((LOG_ESS, "CSE: retrieving Target Class from Target Namespace\n"));    			

		VARIANT vTargetClassName;
		VariantInit(&vTargetClassName);

		if (SUCCEEDED(hr = pTemplate->Get(L"TargetClass", 0, &vTargetClassName, NULL, NULL)))
			hr = pTargetNamespace->GetObject(vTargetClassName.bstrVal, 0, NULL, ppClassDef, NULL);

		// don't release the class - we're returning it.
		VariantClear(&vTargetClassName);
	}

	DEBUGTRACE((LOG_ESS, "CSE: EnsureType returning 0x%08X\n", hr));

	return hr;
}

// puts list into object
// object is assumed to be the in-param object for the merge method
HRESULT PrepMergeParam(SAFEARRAY* pList, IWbemClassObject* pMergeParam)
{
    HRESULT hr;
    
    VARIANT v;
    VariantInit(&v);
    v.vt = VT_UNKNOWN | VT_ARRAY;

    if (SUCCEEDED(hr = SafeArrayCopy(pList, &v.parray)))
        hr = pMergeParam->Put(L"templateList", 0, &v, NULL);
    
    VariantClear(&v);

    return hr;
}

HRESULT PrepResolveParam(IWbemClassObject* pUnk, IWbemClassObject* pClassDef, IWbemClassObject* pResolveParam)
{
    HRESULT hr;
    
    VARIANT v;
    VariantInit(&v);
    v.vt = VT_UNKNOWN;
    v.punkVal = pUnk;

    hr = pResolveParam->Put(L"template", 0, &v, NULL);
    	
	if (SUCCEEDED(hr))
	{
		v.punkVal = pClassDef;
		hr = pResolveParam->Put(L"classObject", 0, &v, NULL);
	}
	
	// no addref, no release...
	// VariantClear(&v);

    return hr;
}

HRESULT GetTemplateParams(IWbemServices* pPolicyNamespace, IWbemClassObject*& pMergeParam, IWbemClassObject*& pResolveParam)
{
    HRESULT hr = WBEM_E_FAILED;

    BSTR bstrName = SysAllocString(L"MSFT_MergeablePolicyTemplate");
    BSTR bstrMerge = SysAllocString(L"Merge");
    BSTR bstrResolve = SysAllocString(L"Resolve");

    if ((!bstrName) || (!bstrMerge) || (!bstrResolve))
        hr = WBEM_E_OUT_OF_MEMORY;
    else
    {
        IWbemClassObject* pClass = NULL;

        if (SUCCEEDED(hr = pPolicyNamespace->GetObject(bstrName, 0, NULL, &pClass, NULL)))
        {
            if (SUCCEEDED(hr = pClass->GetMethod(bstrMerge, 0, &pMergeParam, NULL)))
               hr = pClass->GetMethod(L"Resolve", 0, &pResolveParam, NULL);
               
            pClass->Release();
        }
    }

    if (bstrName) 
        SysFreeString(bstrName);
        
    if (bstrMerge) 
        SysFreeString(bstrMerge); 

    if (bstrResolve)
        SysFreeString(bstrResolve);


    return hr;
}

// for each policyTemplate
// determine whether we have associated type / MSFT_PolicyType
// merge, write result, if pRSOPNamespace != NULL, result is written to rsop
// if bDoItForReal is false - we are in planning mode: write to RSOP but *NOT* the target namespace or history
// TODO:  this is too long: cut.
HRESULT ApplyPolicies(TemplateMap& policies, IWbemServices* pPolicyNamespace, IWbemServices* pRSOPNamespace, IWbemServices* pHistoryNamespace, bool bDoItForReal)
{
    HRESULT hr = WBEM_S_NO_ERROR;        // marching error recording for internal use
    HRESULT hrOverall = WBEM_S_NO_ERROR; // that which we will return to the outside world.

    // things we need to do RSOP
    IWbemClassObject* pRsopType     = NULL;
    IWbemClassObject* pRsopTarget   = NULL;

    // things we need to free RSOP things needed
    CReleaseMe relpRsopType    (pRsopType    );
    CReleaseMe relpRsopTarget  (pRsopTarget  );

    if ( pRSOPNamespace )
    {
        hr = pRSOPNamespace->GetObject(RSOP_AppliedPolicyTypeName,     0, NULL, &pRsopType,     NULL);
		if (FAILED(hr))
		{
			ERRORTRACE((LOG_ESS, "CSE: Unable to retrieve RSOP_AppliedPolicyType 0x%08X\n", hr));
            return WBEM_E_FAILED;
		}

        hr = pRSOPNamespace->GetObject(RSOP_WmiTargetObjectName,       0, NULL, &pRsopTarget,   NULL);
		if (FAILED(hr))
		{
			ERRORTRACE((LOG_ESS, "CSE: Unable to retrieve RSOP_WmiTargetObject 0x%08X\n", hr));
            return WBEM_E_FAILED;
		}

    }

    // things we need to do History
    IWbemClassObject* pHistoryType     = NULL;
    IWbemClassObject* pHistoryTarget   = NULL;

    // things we need to free history things needed
    CReleaseMe relpHistoryType    (pHistoryType    );
    CReleaseMe relpHistoryTarget  (pHistoryTarget  );

    if ( pHistoryNamespace )
    {
        hr = pHistoryNamespace->GetObject(MSFT_AppliedPolicyTypeName,     0, NULL, &pHistoryType,     NULL);
        if (FAILED(hr))
		{
			ERRORTRACE((LOG_ESS, "CSE: Unable to retrieve History type 0x%08X\n", hr));
			return hr;
		}


        hr = pHistoryNamespace->GetObject(MSFT_WmiTargetObjectName,       0, NULL, &pHistoryTarget,   NULL);
  		if (FAILED(hr))
		{
			ERRORTRACE((LOG_ESS, "CSE: Unable to retrieve History applied target object 0x%08X\n", hr));
			return hr;
		}

    }

    // parameters for methods
    IWbemClassObject* pMergeParam = NULL;
    IWbemClassObject* pResolveParam = NULL;

    BSTR bstrTemplate = SysAllocString(L"MSFT_MergeablePolicyTemplate");
    BSTR bstrMerge = SysAllocString(L"Merge");
    BSTR bstrResolve = SysAllocString(L"Resolve");

    CSysFreeMe freeTemplate(bstrTemplate);
    CSysFreeMe freeMerge(bstrMerge);
    CSysFreeMe freeResolve(bstrResolve);

    if ((bstrResolve == NULL) ||
        (bstrTemplate == NULL) ||
        (bstrMerge == NULL))
            return WBEM_E_OUT_OF_MEMORY;

    if (FAILED(hr = GetTemplateParams(pPolicyNamespace, pMergeParam, pResolveParam)))
        return hr;

    int cookie = 0;
    SAFEARRAY* pList;    
    while (pList = policies.GetTemplateList(cookie))
    {        
        // start building the RSOP Target obj
        IWbemClassObject* pRsopTargetObj = NULL;
        if (pRSOPNamespace)
            pRsopTarget->SpawnInstance(0, &pRsopTargetObj);
        CReleaseMe relTarget(pRsopTargetObj);
        
        // start building the History Target obj
        IWbemClassObject* pHistoryTargetObj = NULL;
        if (pHistoryNamespace)
            pHistoryTarget->SpawnInstance(0, &pHistoryTargetObj);
        CReleaseMe relHistoricalTarget(pHistoryTargetObj);
        
        // retrieve type object & namespace
        IWbemClassObject* pObj = NULL;
		IWbemClassObject* pClassDef = NULL;
		CReleaseMe relClassDef(pClassDef);

        IWbemServices* pTargetNamespace = NULL;
        long index = 0;

        // get first element, use for namespace name, etc.
        if (SUCCEEDED(hr = SafeArrayGetElement(pList, &index, &pObj)))
        {
            VARIANT vNamespaceName;
            VariantInit(&vNamespaceName);

            pObj->Get(L"TargetNamespace", 0, &vNamespaceName, NULL, NULL);
            if ((vNamespaceName.vt == VT_BSTR) && (vNamespaceName.bstrVal != NULL))
            {
                if (SUCCEEDED(hr = GetNamespace(vNamespaceName.bstrVal, pTargetNamespace, false)))
                    hr = EnsureType(pTargetNamespace, pPolicyNamespace, pHistoryNamespace, pObj, pRSOPNamespace, pRsopTargetObj, pHistoryTargetObj, &pClassDef);

				if (FAILED(hr))
				{
					hrOverall = hr;
                    ERRORTRACE((LOG_ESS, "CSE: EnsureType failed, 0x%08X, continuing\n", hr));
                    hr = WBEM_S_NO_ERROR;
					continue;
				}

                if (pRSOPNamespace && pRsopTargetObj) 
                    pRsopTargetObj->Put(L"TargetNamespace", 0, &vNamespaceName, NULL);
                    
                if (pHistoryNamespace && pHistoryTargetObj) 
                    pHistoryTargetObj->Put(L"TargetNamespace", 0, &vNamespaceName, NULL);

                VariantClear(&vNamespaceName);
            }
            
            pObj->Release();
            pObj = NULL;
        }
        else
        {
            ERRORTRACE((LOG_ESS, "ApplyPolicies: SafeArrayGetElement returned 0x%08X\n", hr));
            return hr;
        }

        // stuff objects into history and/or RSOP
        long lUbound = 0;
        SafeArrayGetUBound(pList, 1, &lUbound);
        
        if (pRSOPNamespace)
        {
            // array for references to templates
            SAFEARRAY* pTemplateRefs = NULL;        
        
            SAFEARRAYBOUND bounds = {lUbound, 0};
            pTemplateRefs = SafeArrayCreate(VT_BSTR, 1, &bounds);
            if (!pTemplateRefs)
                return WBEM_E_OUT_OF_MEMORY;

            for (index = 0; index < lUbound; index++)
            {
                if (SUCCEEDED(hr = SafeArrayGetElement(pList, &index, &pObj)))
                {
                    VARIANT vPath;
                    VariantInit(&vPath);
                    
                    CReleaseMe relObj(pObj);
                    pObj->Get(L"__RELPATH", 0, &vPath, NULL, NULL);

                    WCHAR templ[] = L"RSOP_AppliedPolicyTemplate.templatePath='%s'";
                    WCHAR* pBuf = new WCHAR[wcslen(templ) + wcslen(vPath.bstrVal) +1];
                    if (!pBuf)
                        return WBEM_E_OUT_OF_MEMORY;
                    CDeleteMe<WCHAR> delChars(pBuf);

                    swprintf(pBuf, templ, vPath.bstrVal);
                    BSTR path = SysAllocString(pBuf);                  

                    SafeArrayPutElement(pTemplateRefs, &index, path);
                
                    VariantClear(&vPath);
                    SysFreeString(path);
                }
            }

            // stuff template array into rsop obj
            VARIANT vArray;
            VariantInit(&vArray);
            vArray.vt = VT_ARRAY | VT_BSTR;
            vArray.parray = pTemplateRefs;
            
            pRsopTargetObj->Put(L"templates", 0, &vArray, NULL);

            // don't need this anymore...
            SafeArrayDestroy(pTemplateRefs);           
        }

        if (pHistoryNamespace)
        {
            // array for references to templates
            SAFEARRAY* pTemplateRefs = NULL;        
        
            SAFEARRAYBOUND bounds = {lUbound, 0};
            pTemplateRefs = SafeArrayCreate(VT_BSTR, 1, &bounds);
            if (!pTemplateRefs)
                return WBEM_E_OUT_OF_MEMORY;

            for (index = 0; index < lUbound; index++)
            {
                if (SUCCEEDED(hr = SafeArrayGetElement(pList, &index, &pObj)))
                {
                    VARIANT vPath;
                    VariantInit(&vPath);
                    
                    CReleaseMe relObj(pObj);
                    pObj->Get(L"__RELPATH", 0, &vPath, NULL, NULL);

                    WCHAR templ[] = L"MSFT_AppliedPolicyTemplate.templatePath='%s'";
                    WCHAR* pBuf = new WCHAR[wcslen(templ) + wcslen(vPath.bstrVal) +1];
                    if (!pBuf)
                        return WBEM_E_OUT_OF_MEMORY;
                    CDeleteMe<WCHAR> delChars(pBuf);

                    swprintf(pBuf, templ, vPath.bstrVal);
                    BSTR path = SysAllocString(pBuf);                  

                    SafeArrayPutElement(pTemplateRefs, &index, path);
                
                    VariantClear(&vPath);
                    SysFreeString(path);
                }
            }

            // stuff template array into history obj
            VARIANT vArray;
            VariantInit(&vArray);
            vArray.vt = VT_ARRAY | VT_BSTR;
            vArray.parray = pTemplateRefs;
            
            pHistoryTargetObj->Put(L"templates", 0, &vArray, NULL);

            // don't need this anymore...
            SafeArrayDestroy(pTemplateRefs);           
        }

        // perform merge, resolve, stick resulting object into destination namespace(s)
        PrepMergeParam(pList, pMergeParam);
        IWbemClassObject* pOut = NULL;

        {
          BSTR x = NULL;

          pMergeParam->GetObjectText(0, &x);
          DEBUGTRACE((LOG_ESS, "CSE: Execute merge with input params: %S\n", x));
          SysFreeString(x);
        }

        if (SUCCEEDED(hr = pPolicyNamespace->ExecMethod(bstrTemplate, bstrMerge, 0, NULL, pMergeParam, &pOut, NULL)))
        {
            VARIANT vOut;
            VariantInit(&vOut);

            if (SUCCEEDED(hr = pOut->Get(L"mergedTemplate", 0, &vOut, NULL, NULL))) 
            {            
                IWbemClassObject* pObj = NULL;
                if (SUCCEEDED(hr = vOut.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pObj)))
                {
            
                    CReleaseMe relObj(pObj);
                    hr = PrepResolveParam(pObj, pClassDef, pResolveParam);

                    // place merged template into rsop/history object
                    if (pRSOPNamespace)
                    {
                        VARIANT vObj;
                        VariantInit(&vObj);
                        vObj.vt = VT_UNKNOWN;
                        vObj.punkVal = pObj; // no addref / no release / no clear
                    
                        pRsopTargetObj->Put(L"mergedTemplate", 0, &vObj, NULL);                    
                    }

                    if (pHistoryNamespace)
                    {
                        VARIANT vObj;
                        VariantInit(&vObj);
                        vObj.vt = VT_UNKNOWN;
                        vObj.punkVal = pObj; // no addref / no release / no clear
                    
                        pHistoryTargetObj->Put(L"mergedTemplate", 0, &vObj, NULL);                    
                    }
                
                    // resolve merged template into object
                    if (SUCCEEDED(hr = pPolicyNamespace->ExecMethod(bstrTemplate, bstrResolve, 
                                                               0, NULL, pResolveParam, &pOut, NULL)))
                    {
                        if (SUCCEEDED(hr = pOut->Get(L"obj", 0, &vOut, NULL, NULL)))
                        {
					        
                            IWbemClassObject* pTargetObj = NULL;
                                     
                            if (SUCCEEDED(hr = vOut.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pTargetObj)))    
                            {
                                CReleaseMe relTarget(pTargetObj);

                                VARIANT vTargetPath;
                                VariantInit(&vTargetPath);
                                pTargetObj->Get(L"__RELPATH", 0, &vTargetPath, NULL, 0);

                                if (pRsopTargetObj)  
                                {
                                    pRsopTargetObj->Put(L"TargetInstance", 0, &vOut, NULL);
                                    pRsopTargetObj->Put(L"TargetPath", 0, &vTargetPath, NULL);
                                }

   					            if (pHistoryTargetObj)  
                                {
                                    pHistoryTargetObj->Put(L"TargetInstance", 0, &vOut, NULL);
                                    pHistoryTargetObj->Put(L"TargetPath", 0, &vTargetPath, NULL);
                                }

                                VariantClear(&vTargetPath);

                                if (bDoItForReal && pTargetNamespace)
                                {
                                    //hr = pTargetNamespace->PutInstance(pTargetObj, 0, NULL, NULL);
									hr = PutInstance(pTargetNamespace, pTargetObj);
                                    if (FAILED(hr))
                                        ERRORTRACE((LOG_ESS, "CSE: PutInstance(pTargetObj) failed, 0x%08X\n", hr));
                                }
                            }
                            else
                                hrOverall = hr;
                            
                            VariantClear(&vOut);
                        }
                        else
                            hrOverall = hr;

     	                pOut->Release();
                        pOut = NULL;
                    }
                    else
                        hrOverall = hr;

                    VariantClear(&vOut);
                }
                else 
                    hrOverall = hr;
            }
        }
        else
            hrOverall = hr;

        if (pHistoryNamespace)
            pHistoryNamespace->PutInstance(pHistoryTargetObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

        if (pRSOPNamespace)
            pRSOPNamespace->PutInstance(pRsopTargetObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
        
        // clean up after yerself.
        pTargetNamespace->Release();
        pTargetNamespace = NULL;

        SafeArrayDestroy(pList);
        pList = NULL;
    }

    if (pMergeParam)
        pMergeParam->Release();
    if (pResolveParam)
        pResolveParam->Release();

    return hrOverall;
}

DWORD WINAPI ProcessGroupPolicyAsync(LPVOID lpParameter)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    PGPStartup* pInfo = (PGPStartup*)lpParameter;

#ifdef ASYNCH_ENABLED        
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "CSE: Coninit failed 0x%08X\n", hr));
    else
#endif
    {
        if (pInfo->pWbemServices)
            hr = EnsureRSOPSchema(pInfo->pWbemServices);
		else
			DEBUGTRACE((LOG_ESS, "CSE: No services pointer, cannot call ensure schema"));

        if (FAILED(hr))
		{
            return hr;
		}
        
        // already done by caller.
   	    // if (FAILED(hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0)))	
     	//     ERRORTRACE((LOG_ESS, "CSE: CoInitializeSecurity failed (0x%08X)\n", hr));
	    IWbemServices* pPolicyNamespace = NULL;

	    if (SUCCEEDED(hr = GetPolicyNamespace(pPolicyNamespace)))
	    {
            IWbemServices* pHistoryNamespace = NULL;
            if (SUCCEEDED(hr = GetHistoryNamespace(pHistoryNamespace)))
            {
                TemplateMap newPolicies;

                DeleteOldPolicies(pPolicyNamespace, pInfo->pWbemServices, pInfo->pDeletedGPOList, newPolicies);

                if (SUCCEEDED (hr = GetPolicyArray(pPolicyNamespace, pInfo->pChangedGPOList, 
                                                   pInfo->pWbemServices, pHistoryNamespace, newPolicies)))
                    hr = ApplyPolicies(newPolicies, pPolicyNamespace, pInfo->pWbemServices, pHistoryNamespace, true);

                pHistoryNamespace->Release();
            }
 		    pPolicyNamespace->Release();
	    }
    }

#ifdef ASYNCH_ENABLED        
    // NOTE: if this is re-enabled, pass the right hresult for RSOP
    ProcessGroupPolicyCompletedEx(&CLSID_CSE, pInfo->pHandle, HResultToWinError(hr), 0);
#endif

    delete pInfo;

#ifdef ASYNCH_ENABLED        
    FreeLibraryAndExitThread(GetModuleHandleA("WMI_CSE.DLL"), 0);
#endif

    return hr;
}

//***************************************************************************
//
//  Function:  ProcessGroupPolicyEx 
//
//  Synopsis:  DIAGNOSTIC MODE callback,
//
//***************************************************************************
DWORD ProcessGroupPolicyProcEx (
    IN DWORD dwFlags,
    IN HANDLE hToken,
    IN HKEY hKeyRoot,
    IN PGROUP_POLICY_OBJECT  pDeletedGPOList,
    IN PGROUP_POLICY_OBJECT  pChangedGPOList,
    IN ASYNCCOMPLETIONHANDLE pHandle,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback,
    IN IWbemServices *pWbemServices,
    OUT HRESULT      *pRsopStatus)
{    
    DEBUGTRACE((LOG_ESS, "CSE: ProcessGroupPolicyProcEx\n"));
    
#ifndef ASYNCH_ENABLED
	CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
#endif
    

    HRESULT hr = WBEM_S_NO_ERROR;
    
    PGPStartup* pInfo = new PGPStartup;

    if (pInfo)
    {
        pInfo->dwFlags         = dwFlags;
        pInfo->hToken          = hToken;
        pInfo->hKeyRoot        = hKeyRoot;
        pInfo->pDeletedGPOList = pDeletedGPOList;
        pInfo->pChangedGPOList = pChangedGPOList;
        pInfo->pHandle         = pHandle;
        pInfo->pbAbort         = pbAbort;
        pInfo->pStatusCallback = pStatusCallback;
        pInfo->pWbemServices   = pWbemServices;
        pInfo->pRsopStatus     = pRsopStatus;    
        
        DWORD  threadIdAsIfICared;
        HANDLE threadHandleAsIfICared;

#ifdef ASYNCH_ENABLED        
        //okay, I gotta manage my own refcount to keep from being unloaded by WinLogon.
        LoadLibraryA("WMI_CSE.DLL");

        threadHandleAsIfICared = CreateThread(NULL, 0, ProcessGroupPolicyAsync, (void*)pInfo, 0, &threadIdAsIfICared);

        if (threadHandleAsIfICared != NULL)
        {
            hr = WBEM_S_NO_ERROR;
            // debug hack to keep us from being unloaded too soon
            // WaitForSingleObject(threadHandleAsIfICared, INFINITE);
            CloseHandle(threadHandleAsIfICared);
        }
        else
            hr = WBEM_E_FAILED;
#else
        hr = ProcessGroupPolicyAsync(pInfo);
#endif

    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;
    

	if FAILED(hr)
		ERRORTRACE((LOG_ESS, "CSE: ProcessGroupPolicyProcEx failed (0x%08X)\n", hr));
	else
		DEBUGTRACE((LOG_ESS, "CSE: ProcessGroupPolicyProcEx Succeeded (0x%08X)\n", hr));

#ifdef ASYNCH_ENABLED        
    if (hr == WBEM_S_NO_ERROR)
        return E_PENDING;
    else
#endif

	    return HResultToWinError(hr);
}

//***************************************************************************
//
//  Function:   ProcessGroupPolicyProc
//
//  Synopsis:   callback, called by GPO when it's time to do policy stuff
//
//***************************************************************************
DWORD ProcessGroupPolicyProc(
  DWORD dwFlags,
  HANDLE hToken,
  HKEY hKeyRoot,
  PGROUP_POLICY_OBJECT pDeletedGPOList,
  PGROUP_POLICY_OBJECT pChangedGPOList,
  ASYNCCOMPLETIONHANDLE pHandle,
  BOOL *pbAbort,
  PFNSTATUSMESSAGECALLBACK pStatusCallback
)
{
    DEBUGTRACE((LOG_ESS, "CSE: ProcessGroupPolicyProc\n"));

    return ProcessGroupPolicyProcEx(dwFlags,
                                    hToken,
                                    hKeyRoot,
                                    pDeletedGPOList,
                                    pChangedGPOList,
                                    pHandle,
                                    pbAbort,
                                    pStatusCallback, 
                                    NULL, NULL);
}

//***************************************************************************
//
//  Function:  GenerateGroupPolicy 
//
//  Synopsis:  Planning Mode callback
//
//***************************************************************************
DWORD GenerateGroupPolicyProc ( 
                   IN DWORD dwFlags,                             
                   IN BOOL  *pbAbort,                 
                   IN WCHAR *pwszSite, 
                   IN PRSOP_TARGET pComputerTarget,               
                   IN PRSOP_TARGET pUserTarget )
{
	DEBUGTRACE((LOG_ESS, "CSE: GenerateGroupPolicyProc\n"));
    HRESULT hr = WBEM_S_NO_ERROR;

	// no initialization needed
// 	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        ERRORTRACE((LOG_ESS, "CSE: Coninit failed 0x%08X\n", hr));
        return E_FAIL;
    }
    else
        DEBUGTRACE((LOG_ESS, "CSE: Coninit returned 0x%08X\n", hr));

    // already done by caller.
   	if (FAILED(hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0)))	
     	ERRORTRACE((LOG_ESS, "CSE: CoInitializeSecurity failed (0x%08X)\n", hr));

	IWbemServices* pPolicyNamespace = NULL;

	if (SUCCEEDED(hr = GetPolicyNamespace(pPolicyNamespace)))
	{
        TemplateMap policies;

        if (SUCCEEDED (hr = GetPolicyArray(pPolicyNamespace, pComputerTarget->pGPOList, pComputerTarget->pWbemServices, NULL, policies)))
            hr = ApplyPolicies(policies, pPolicyNamespace, pComputerTarget->pWbemServices, NULL, false);

		pPolicyNamespace->Release();
	}

	if (FAILED(hr))
		ERRORTRACE((LOG_ESS, "CSE: GenerateGroupPolicyProc failed (0x%08X)\n", hr));
    else
        DEBUGTRACE((LOG_ESS, "CSE: GenerateGroupPolicyProc succeeded (0x%08X)\n", hr));

	return HResultToWinError(hr);
}

//***************************************************************************
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//***************************************************************************
extern "C"
BOOL WINAPI
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        if (FAILED(CSEInitGlobalNames()))
            return FALSE;
        DisableThreadLibraryCalls(hInst);
        break;
    case DLL_PROCESS_DETACH:
        ReleaseGlobalNames();
        break;
    default:
        break;
    }

    return TRUE;
}

//***************************************************************************
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//***************************************************************************
extern "C"
BOOL WINAPI
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   

	HKEY hKey;
    LONG lResult;
    DWORD dwDisp;

    lResult = RegCreateKeyExA( HKEY_LOCAL_MACHINE,
                              CSE_REG_KEY,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);

    if (lResult == ERROR_SUCCESS)
	{	
		
	    // Get the dll's filename
		// ======================
		char path[MAX_PATH +1];
		GetModuleFileNameA(GetModuleHandleA("wmi_cse.dll"), path, MAX_PATH);
		unsigned char* ppath = (unsigned char*)&path[0];
		
		RegSetValueExA( hKey,
					   "DllName",
					   0,
					   REG_EXPAND_SZ,
					   ppath,
					   lstrlenA(path) + 1 );
		
		RegSetValueExA( hKey,
					   "ProcessGroupPolicy",
					   0,
					   REG_SZ,
					   (unsigned char *)POLICY_PROC_NAME,
					   lstrlenA(POLICY_PROC_NAME) + 1 );

		RegSetValueExA( hKey,
					   "ProcessGroupPolicyEx",
					   0,
					   REG_SZ,
					   (unsigned char *)POLICY_PROC_NAME_EX,
					   lstrlenA(POLICY_PROC_NAME_EX) + 1 );

		RegSetValueExA( hKey,
    				   "GenerateGroupPolicy",
					   0,
					   REG_SZ,
					   (unsigned char *)GENREATE_POLICY_PROC,
					   lstrlenA(GENREATE_POLICY_PROC) + 1 );

        RegSetValueExA( hKey,
    				   NULL,
					   0,
					   REG_SZ,
					   (unsigned char *)WMI_CSE_NAME,
					   lstrlenA(WMI_CSE_NAME) + 1 );


        DWORD trueVal = 1;
        DWORD falseVal = 0;


#ifdef ASYNCH_ENABLED        
        RegSetValueExA( hKey,
    				   "EnableAsynchronousProcessing",
					   0,
					   REG_DWORD,
					   (unsigned char *)&trueVal,
					   sizeof(DWORD) );
else
        RegSetValueExA( hKey,
    				   "EnableAsynchronousProcessing",
					   0,
					   REG_DWORD,
					   (unsigned char *)&falseVal,
					   sizeof(DWORD) );
#endif


		
        RegSetValueExA( hKey,
    				   "NoGPOListChanges",
					   0,
					   REG_DWORD,
					   (unsigned char *)&trueVal,
					   sizeof(DWORD) );

        RegCloseKey( hKey );
	}
	else
		lResult = SELFREG_E_CLASS;

    return lResult;
}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    return SHDeleteKeyA(HKEY_LOCAL_MACHINE, CSE_REG_KEY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\cse\containers.h ===
#ifndef _CSE_CONTAINERS_H_
#define _CSE_CONTAINERS_H_

#include <FlexArry.h>
#include <WString.h>

// container for MSFT_PolicyTemplates which are all alike (have same path)
class LikeTemplateList
{
public:
    LikeTemplateList(const WCHAR* path) 
        : m_path(path)
    { 
        if ((path == NULL) || (wcslen(path) == 0))
            throw WBEM_E_INVALID_PARAMETER;
    }

    ~LikeTemplateList();

    // adds to end of list
    HRESULT Add(IWbemClassObject* pObj);

    // returns variant containing safearray of objects
    SAFEARRAY* GetArray();

    // returns 0 if pOther is == path
    // negative # is pOther is < path
    // case insensitive compare
    int Compare(WCHAR* pOther)
    { return _wcsicmp(pOther, (wchar_t*)m_path); };
    
private:
    WString    m_path;
    CFlexArray m_objects;
};
    
// contains list of policy templates,
// sorted by path
class TemplateMap
{
public:
    TemplateMap()
    {}

    ~TemplateMap();

    // creates new entry if needed
    HRESULT Add(WCHAR* pPath, IWbemClassObject* pObj);

    // get each template list in turn
    // set cookie to zero to get the first one
    SAFEARRAY* GetTemplateList(int& cookie);

private:
    // array of template lists
    // sorted by path
    CFlexArray m_lists;
};

#endif // _CSE_CONTAINERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\mof\makefile.inc ===
$(O)\PolicMan.mof: PolicMan.mof
    copy copyright.mof+PolicMan.mof+PolicMan.mfl $(O)\PolicMan.mof
$(O)\PolicMan.mfl: PolicMan.mfl
    copy copyright.mof+PolicMan.mfl $(O)\PolicMan.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\param_unknown.cpp ===
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>
#include <sys/timeb.h>
#include <comdef.h>
#include <comutil.h>
#include <atlbase.h>

#include <buffer.h>

#include "windows.h"
#include "stdio.h"
#include "activeds.h"
#include "tchar.h"

#include "Utility.h"

/*
  Creates an AD based parameter object under the specified policy object from a CIM based obj.
*/

#define MAX_ATTR 4

HRESULT Param_Unknown_Verify(IWbemClassObject *pSrcParamObj)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1, v2;

  CComPtr<IDirectoryObject>
    pDestParamObj;

  CComPtr<IDispatch>
    pDisp;

  BYTE defaultBuffer[2048];
  ULONG bWritten = 0;
  LARGE_INTEGER offset;

  CBuffer
    ClassDefBuffer(defaultBuffer, 2048, FALSE);

  long
    nArgs = 0;

  nArgs++;

  // **** Property Name

  hres = pSrcParamObj->Get(g_bstrPropertyName, 0, &v1, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_BSTR != V_VT(&v1)) || (NULL == V_BSTR(&v1)))
    return WBEM_E_ILLEGAL_NULL;
  nArgs++;

  // **** Normalized Class

  hres = pSrcParamObj->Get(L"__CLASS", 0, &v2, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_BSTR != V_VT(&v2)) || (NULL == V_BSTR(&v2)))
    return WBEM_E_ILLEGAL_NULL;
  nArgs++;

  // **** Target Object

  if(NULL == pSrcParamObj)
    return WBEM_E_ILLEGAL_NULL;
  nArgs++;

  return hres;
}

/*
  Creates a CIM based parameter object within the specified policy object from an AD object.
*/

HRESULT Param_Unknown_ADToCIM(IWbemClassObject **ppDestParamObj,
                              IDirectorySearch *pDirSrch, 
                              ADS_SEARCH_HANDLE *SearchHandle, 
                              IWbemServices *pDestCIM) 
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  ADS_SEARCH_COLUMN
    Column;

  BYTE defaultBuffer[2048];
  ULONG bWritten = 0;
  LARGE_INTEGER offset;

  CBuffer
    ClassDefBuffer(defaultBuffer, 2048, FALSE);

  offset.LowPart = 0;
  offset.HighPart = 0;

  // **** TargetObject

  if((NULL == ppDestParamObj)) return WBEM_E_INVALID_OBJECT;

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADTargetObject, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    hres = ClassDefBuffer.Seek(offset, STREAM_SEEK_SET, NULL);
    if(SUCCEEDED(hres))
    {
      hres = ClassDefBuffer.Write(Column.pADsValues->OctetString.lpValue, Column.pADsValues->OctetString.dwLength, &bWritten);
      if(SUCCEEDED(hres))
      {
        hres = ClassDefBuffer.Seek(offset, STREAM_SEEK_SET, NULL);
        if(SUCCEEDED(hres))
          hres = CoUnmarshalInterface(&ClassDefBuffer, IID_IWbemClassObject, (void**)ppDestParamObj);
      }
    }

    pDirSrch->FreeColumn(&Column);
  }

  return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\loader\loader.cpp ===
// test harness for WMI GPO subsubsystem
// hardcoded for the hhancedom domain in microsoft.com

#include <windows.h>
#include <initguid.h>
#include <prsht.h>
#include <wbemidl.h>
#include <gpedit.h>
#include <stdio.h>

#define LINK_TARGET  L"LDAP://DC=EssCool,DC=com"
#define DOMAIN_NAME  L"LDAP://DC=EssCool,DC=com"

// {AAEAE720-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_CSE = 
    { 0xaaeae720, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// TODO: attempt to create namespace if not available.
HRESULT GetNamespace(BSTR namespaceName, IWbemServices*& pNamespace)
{
    HRESULT hr = WBEM_E_FAILED;

    IWbemLocator* pLoc = NULL;

	if (FAILED(hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*) &pLoc)))
		printf("Could not create wbem locator (0x%08X)\n", hr);
	else
	{
		if (SUCCEEDED(hr = pLoc->ConnectServer(namespaceName, NULL,NULL, 0,0,0,0,&pNamespace)))
            printf("Retrieved %S namespace\n", namespaceName);
        else
            printf("ConnectServer(%s) failed (0x%08X)\n", namespaceName, hr);

		pLoc->Release();
	}

	return hr;
}

HRESULT GetPolicyNamespace(IWbemServices*& pPolicyNamespace)
{
    HRESULT hr;

    BSTR bstr = SysAllocString(L"\\\\.\\ROOT\\POLICY");
    if (bstr)
    {
        hr = GetNamespace(bstr, pPolicyNamespace);
        SysFreeString(bstr);
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    if (FAILED(hr))
        printf("Failed to retrieve policy namespace (0x%08X)\n", hr);

    return hr;
}

HRESULT DeleteGPO(WCHAR *name)
{
	LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr;

	if (SUCCEEDED(hr = DeleteGPOLink(name,LINK_TARGET)))
		printf("deleted link\n");
	else
		printf("DeleteGPOLink failed with 0x%x.\n", hr);


    if (FAILED(hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO)))
       printf("CoCreateInstance failed with 0x%x.\n", hr);
	else
	{
		if (FAILED(hr = pGPO->OpenDSGPO(name, 0)))
			printf("OpenDSGPO failed with 0x%x.\n", hr);
		else
			if (FAILED(hr = pGPO->Delete()))
				printf("Delete failed with 0x%x.\n", hr);
			else
				printf("Deleted %S\n", name);

		pGPO->Release();
	}

	return hr;
}

// communicate with the Group Policy Infrastructure which will
// create a GPO object & return to us the path of the container
// into which we should write our object
HRESULT CreateGPO(const WCHAR* name, WCHAR* domain, WCHAR* szPath)
{
    LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO)))
       printf("CoCreateInstance failed with 0x%x.\n", hr);
	else
	{
	    if (FAILED(hr = pGPO->New(domain, (WCHAR*)name, 0)))
	        printf("New failed with 0x%x.\n", hr);
		else
		    if (FAILED(hr= pGPO->GetDSPath(GPO_SECTION_MACHINE, szPath, MAX_PATH)))
				printf("GetDSPath failed with 0x%x.\n", hr);
			else
			{
				printf("\nGPO machine path: %S\n\n", szPath);
				// pGPO->GetDSPath(GPO_SECTION_USER, szPath, MAX_PATH);
				// printf("GPO user path: %S\n\n", szPath);
				
				WCHAR rootPath[MAX_PATH];
				
				if (FAILED(hr = pGPO->GetPath(rootPath, MAX_PATH)))
					printf("GetPath failed with 0x%x.\n", hr);
				else
				{
					printf("GPO root path: %S\n\n", rootPath);

					if (FAILED(hr = CreateGPOLink(rootPath, domain, FALSE)))
						printf("CreateGPOLink failed with 0x%x.\n", hr);
					else
						if (FAILED(hr = pGPO->Save(TRUE, TRUE, (struct _GUID *)&CLSID_CSE, (struct _GUID *)&CLSID_CSE) ))
							printf("Save failed with 0x%x.\n", hr);
				}
			}

		pGPO->Release();
	}

    return hr;
}

HRESULT PutRangeParams(IWbemServices* pPolicyNamespace, IWbemClassObject* pTemplate)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    SAFEARRAYBOUND
        arrayBounds;
  
    arrayBounds.lLbound = 0;
    arrayBounds.cElements = 1;

    SAFEARRAY* psa = SafeArrayCreate(VT_UNKNOWN, 1, &arrayBounds);
    if (!psa)
    {
        printf("Failed to create safe array\n");
        return WBEM_E_OUT_OF_MEMORY;
    }

    IWbemClassObject* pClass = NULL;
    BSTR bustard = SysAllocString(L"MSFT_SintRangeParam");
    if (SUCCEEDED(hr = pPolicyNamespace->GetObject(bustard, 0, NULL, &pClass, NULL)))
    {
        IWbemClassObject* pRange = NULL;
        if (FAILED(hr = pClass->SpawnInstance(0, &pRange)))
		{
			printf("pClass->SpawnInstance failed, 0x%08X\n", hr);
			return hr;
		}

        VARIANT v;
        VariantInit(&v);
        v.vt = VT_BSTR;
        v.bstrVal = SysAllocString(L"ID");

        pRange->Put(L"PropertyName",0,&v,NULL);
        VariantClear(&v);
        
        v.vt = VT_BSTR;
        v.bstrVal = SysAllocString(L"SINT32");
        pRange->Put(L"TargetClass",0,&v,NULL);
        VariantClear(&v);

        v.vt = VT_I4;
        v.lVal = 5;
        pRange->Put(L"Default",0,&v,NULL);
        VariantClear(&v);

        v.vt = VT_I4;
        v.lVal = CIM_SINT32;
        pRange->Put(L"TargetType",0,&v,NULL);




        v.vt = VT_UNKNOWN | VT_ARRAY;
        v.parray = psa;
        long index = 0;
        SafeArrayPutElement(psa, &index, pRange);
    
        hr = pTemplate->Put(L"RangeSettings", 0, &v, NULL);

        pRange->Release();
        pClass->Release();
    }
    else
        printf("Failed to retrieve MSFT_SintRangeParam, 0x%08X\n", hr);

    printf("PutRangeParams returning 0x%08X\n", hr);

    return hr;
}


// create template based on object
// write it to ds, return key string
HRESULT CreatePolicyTemplate(IWbemServices* pPolicyNamespace, WCHAR* keyString)
{
	HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject* pTemplateTemplate = NULL;
    BSTR bstr = SysAllocString(L"MSFT_MergeablePolicyTemplate");

    if (FAILED(hr = pPolicyNamespace->GetObject(bstr,0,NULL,&pTemplateTemplate,NULL)))
        printf("GetObject on MSFT_MergeablePolicyTemplate failed 0x%08X\n", hr);
    else
    {
        printf("Retrieved MSFT_MergeablePolicyTemplate\n");

        IWbemClassObject* pTemplate = NULL;
        if (FAILED(hr = pTemplateTemplate->SpawnInstance(0, &pTemplate)))
            printf("SpawnInstance on MSFT_MergeablePolicyTemplate failed 0x%08X\n", hr);
        else
        {
            printf("SpawnInstance on MSFT_MergeablePolicyTemplate Succeeded\n");

            VARIANT v;
            VariantInit(&v);
            v.vt = VT_BSTR;
            GUID guid;

            CoCreateGuid(&guid);
            WCHAR guidStr[128];

            StringFromGUID2(guid, guidStr, 128);

            v.bstrVal = SysAllocString(guidStr);
            pTemplate->Put(L"ID", 0, &v, NULL);
            SysFreeString(v.bstrVal);
            
            v.bstrVal = SysAllocString(L"LOCAL");
            pTemplate->Put(L"DsContext", 0, &v, NULL);
            SysFreeString(v.bstrVal);
            
            v.bstrVal = SysAllocString(L"root\\policy");
            pTemplate->Put(L"TargetNamespace", 0, &v, NULL);
            SysFreeString(v.bstrVal);
            
            v.bstrVal = SysAllocString(L"ModemSetting");
            pTemplate->Put(L"TargetClass", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"Description");
            pTemplate->Put(L"Description", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"ModemSetting.id=5");
            pTemplate->Put(L"TargetPath", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"None whatsoever");
            pTemplate->Put(L"SourceOrganization", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"20000101000000.000000-480");
            pTemplate->Put(L"ChangeDate", 0, &v, NULL);
            pTemplate->Put(L"CreationDate", 0, &v, NULL);
            SysFreeString(v.bstrVal);
            
            v.bstrVal = SysAllocString(L"Joe Bob");
            pTemplate->Put(L"Name", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"Joe Jack");
            pTemplate->Put(L"Author", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            hr = PutRangeParams(pPolicyNamespace, pTemplate);
            if (SUCCEEDED(hr))
            {
                pTemplate->Get(L"__RELPATH", 0, &v, NULL, NULL);
                wcscpy(keyString, v.bstrVal);
                VariantClear(&v);

                if (SUCCEEDED(hr = pPolicyNamespace->PutInstance(pTemplate, WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL)))
                    printf("Successfully put %S\n", keyString);
                else
                    printf("PutInstance on MSFT_MergeablePolicyTemplate failed 0x%08X\n", hr);
            }

            pTemplate->Release();
        }

        pTemplateTemplate->Release();
    }

    SysFreeString(bstr);
	return hr;
}

// write WMIGPO object to DS
// to path specified in szPath
// containing keystring
HRESULT WriteWMIGPO(IWbemServices* pPolicyNamespace, const WCHAR* szPath, const WCHAR* keyString)
{
	HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject* pWmiGpoClass = NULL;
    BSTR bstr = SysAllocString(L"MSFT_WMIGPO");

    if (FAILED(hr = pPolicyNamespace->GetObject(bstr,WBEM_FLAG_USE_AMENDED_QUALIFIERS,NULL,&pWmiGpoClass,NULL)))
        printf("GetObject on MSFT_WMIGPO failed 0x%08X\n", hr);
    else
    {
        IWbemClassObject* pWmiGpo = NULL;
        if (FAILED(hr = pWmiGpoClass->SpawnInstance(0, &pWmiGpo)))
            printf("SpawnInstance on MSFT_WMIGPO failed 0x%08X\n", hr);
        else
        {
            VARIANT v;
            VariantInit(&v);
            v.vt = VT_BSTR;

            v.bstrVal = SysAllocString(szPath);
            pWmiGpo->Put(L"DsPath", 0, &v, NULL);
            
            VariantClear(&v);
            v.vt = VT_BSTR | VT_ARRAY;

            SAFEARRAYBOUND
                arrayBounds;
            SAFEARRAY* pArray = NULL;
     
           arrayBounds.lLbound = 0;
           arrayBounds.cElements = 1;

           long index = 0;
           pArray = SafeArrayCreate(VT_BSTR, 1, &arrayBounds);
           SafeArrayPutElement(pArray, &index, SysAllocString(keyString));
           v.parray = pArray;
           
           pWmiGpo->Put(L"PolicyTemplate", 0, &v, NULL);
           SafeArrayDestroy(pArray);

            
            if (SUCCEEDED(hr = pPolicyNamespace->PutInstance(pWmiGpo, WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL)))
                printf("Successfully put MSFT_WMIGPO\n");
            else
                printf("PutInstance on MSFT_WMIGPO failed 0x%08X\n", hr);

            pWmiGpo->Release();
        }

        pWmiGpoClass->Release();
    }

    SysFreeString(bstr);

	return hr;
}

int __cdecl wmain(int argc, WCHAR *argv[])
{
    CoInitialize(NULL);
    
    CoInitializeSecurity (NULL, -1, NULL, NULL, 
      RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 
      EOAC_NONE, NULL);

    /**********************

//	create deleter with this...
	if (argc==2)
		DeleteGPO(argv[1]);
	else
		printf("one and only one argument, please - that's the path to the root of the gpo\n");
     ******************/

	WCHAR szPath[MAX_PATH];
    IWbemServices* pPolicyNamespace = NULL;

	if (argc==3)
    {
        if (SUCCEEDED(GetPolicyNamespace(pPolicyNamespace))
            &&
            SUCCEEDED(CreateGPO(L"WMI Test Policy", argv[1], szPath)))
			    WriteWMIGPO(pPolicyNamespace, szPath, argv[2]);

        if (pPolicyNamespace)
            pPolicyNamespace->Release();
    }
	else if (argc==4)
	{
		if (SUCCEEDED(GetPolicyNamespace(pPolicyNamespace))
            &&
            SUCCEEDED(CreateGPO(argv[3], argv[1], szPath)))
			    WriteWMIGPO(pPolicyNamespace, szPath, argv[2]);

        if (pPolicyNamespace)
            pPolicyNamespace->Release();
	}
	else
		printf("\nUSAGE:\n\n  Loader [domain path] [Policy Template Path] <optional policy name>\n\nEXAMPLE (line breaks to improve readability):\n\n  Loader LDAP://DC=EssCool,DC=com\n         MSFT_MergeablePolicyTemplate.DsContext=\\\"LOCAL\\\",ID=\\\"{BA34...3471}\\\"\n         MyPolicy\n");


    
	/*********************
    hard coded version
    WCHAR keyString[MAX_PATH];
    if (SUCCEEDED(GetPolicyNamespace(pPolicyNamespace))
        &&
		SUCCEEDED(CreatePolicyTemplate(pPolicyNamespace, keyString))
		&&        
        SUCCEEDED(CreateGPO(L"fribbert", szPath))
        )
			WriteWMIGPO(pPolicyNamespace, szPath, keyString);

    if (pPolicyNamespace)
        pPolicyNamespace->Release();
    *************************/
           
    CoUninitialize();
 
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policgpo.h ===
#ifndef __WBEM_POLICY_GPO__H_
#define __WBEM_POLICY_GPO__H_

class CPolicyGPO : public CUnk
{
enum
{
  AD_LOCAL_CONTEXT = 0,
  AD_GLOBAL_CONTEXT,
  AD_MAX_CONTEXT
};

public:
    CPolicyGPO(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this), 
		m_pWMIMgmt(NULL), m_pADMgmt(NULL)
    {}
    
	~CPolicyGPO();

    void* GetInterface(REFIID riid);

	// stuff for our internal use
	IWbemServices* GetWMIServices();
	IADsContainer* GetADServices(wchar_t *DsPath = NULL);
	bool SetWMIServices(IWbemServices* pServices);
	bool SetADServices(IADsContainer* pServices);

protected:
    class XProvider : public CImpl<IWbemServices, CPolicyGPO>
    {
    public:
        XProvider(CPolicyGPO* pObj)
            : CImpl<IWbemServices, CPolicyGPO>(pObj),m_pWMIGPOClassObject(NULL)
		{}

		~XProvider();

	protected:
		/* object support */
		IWbemClassObject* GetWMIGPOClass();
		IWbemClassObject* GetWMIGPOInstance();

	private:		
		// templates for each type of object we support
		// NULL until we need it
		IWbemClassObject* m_pWMIGPOClassObject;

	public:
		
		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) 
			{return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CPolicyGPO>
    {
    public:
        XInit(CPolicyGPO* pObj)
            : CImpl<IWbemProviderInit, CPolicyGPO>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;

private:
	// pointer back to win management
	IWbemServices* m_pWMIMgmt; 
 	IADsContainer *m_pADMgmt;


  CComVariant
    m_vDsConfigContext,
    m_vDsLocalContext;

	// a little something to keep our threads from getting tangled
    // will use a single critical section to protect all instance variables
    CCritSec m_CS;   
};


#endif // __WBEM_POLICY_GPO__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policman.cpp ===
#include <windows.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include <ql.h>
#include <sync.h>
#include <Dsrole.h>
#include "utility.h"
#include "PolicMan.h"
#include "PolicTempl.h"
#include "PolicSOM.h"
#include "PolicType.h"
#include "PolicRange.h"
#include "PolicGPO.h"
#include "PolicStatus.h"

#include <tchar.h>

#define REG_RUN_KEY L"Software\\Microsoft\\Windows\\CurrentVersion\\Run"

class CMyServer : public CComServer
{
public:
    CMyServer(void) { InitGlobalNames(); }
    ~CMyServer(void) { FreeGlobalNames(); }

    HRESULT Initialize()
    {
        AddClassInfo(CLSID_PolicySOM, 
            new CClassFactory<CPolicySOM>(GetLifeControl()), 
            _T("WMI Policy SOM Provider"), TRUE);

        AddClassInfo(CLSID_PolicyStatus,
            new CClassFactory<CPolicyStatus>(GetLifeControl()),
            _T("WMI Policy Status Provider"), TRUE);

        return S_OK;

    }
    HRESULT InitializeCom()
    {
        return CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }

/*
  void Register(void)
  {
    wchar_t 
      swKeyValue[] = L"RUNDLL32.EXE %systemroot%\\system32\\wbem\\policman.dll,CreateADContainers",
      swExpandedValue[512],
      swRunOnceKey[] = REG_RUN_KEY ;

    HKEY
      hkRunOnce;

    LONG
      lReturnCode;

    lReturnCode = ExpandEnvironmentStrings(swKeyValue, swExpandedValue, 512);

    lReturnCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE, swRunOnceKey, 0, KEY_SET_VALUE, &hkRunOnce);

    if(ERROR_SUCCESS != lReturnCode)
    {
      // error
    }

    lReturnCode = RegSetValueEx(hkRunOnce, L"PolicMan", 0, REG_EXPAND_SZ, (BYTE *)swExpandedValue, 
                                (lstrlen(swExpandedValue)+1) * sizeof(wchar_t));

    if(ERROR_SUCCESS != lReturnCode)
    {
      // error
    }

    RegCloseKey(hkRunOnce);
  }
*/
} Server;

HRESULT GetOrCreateObj(CComQIPtr<IADsContainer, &IID_IADsContainer> &pIADsContainer_In, 
                       CComBSTR &bstrObjName,
                       CComQIPtr<IADsContainer, &IID_IADsContainer> &pIADsContainer_Out)
{
  HRESULT
    hres = WBEM_E_FAILED;

  CComQIPtr<IDispatch, &IID_IDispatch>
    pDisp;

  CComQIPtr<IDirectoryObject, &IID_IDirectoryObject>
    pDirectoryObj;

  CComQIPtr<IADsObjectOptions, &IID_IADsObjectOptions>
    pADsObjectOptions;

  CComVariant
    vSecurityOptions;

  ADSVALUE
    AdsValue[1];

  ADS_ATTR_INFO
    attrInfo[] = { { L"ntSecurityDescriptor", ADS_ATTR_UPDATE, ADSTYPE_NT_SECURITY_DESCRIPTOR, &AdsValue[0], 1} };

  CNtSecurityDescriptor
    cSD;

  DWORD
    dwModified;

  ADS_OBJECT_INFO 
    *pADsInfo = NULL;

  if(NULL == pIADsContainer_In.p) return WBEM_E_FAILED;

  // **** get/create object

  hres = pIADsContainer_In->GetObject(L"Container", bstrObjName, &pDisp);
  if(FAILED(hres) || (NULL == pDisp.p))
  {
    CComQIPtr<IADs, &IID_IADs>
      pIADs;

    hres = pIADsContainer_In->Create(L"Container", bstrObjName, &pDisp);
    if(FAILED(hres) || (NULL == pDisp.p))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could create container %S : 0x%x\n", (BSTR)bstrObjName, hres));
      return hres;
    }

    // **** write object to AD

    pIADs = pDisp;
    hres = pIADs->SetInfo();
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could write container %S to DS : 0x%x\n", (BSTR)bstrObjName, hres));
      return hres;
    }
  }

  // **** set object security option

  pADsObjectOptions = pDisp;
  vSecurityOptions = (ADS_SECURITY_INFO_OWNER | ADS_SECURITY_INFO_DACL);
  hres = pADsObjectOptions->SetOption(ADS_OPTION_SECURITY_MASK, vSecurityOptions);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could set security options on object : 0x%x\n", hres));
    return hres;
  }

  // **** create security descriptor

  hres = CreateDefaultSecurityDescriptor(cSD);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could create security descriptor : 0x%x\n", hres));
    return hres;
  }

  // **** set object security descriptor

  AdsValue[0].dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
  AdsValue[0].SecurityDescriptor.dwLength = cSD.GetSize();
  AdsValue[0].SecurityDescriptor.lpValue = (LPBYTE)cSD.GetPtr();

  pDirectoryObj = pDisp;
  hres = pDirectoryObj->SetObjectAttributes(attrInfo, 1, &dwModified);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could set security on object : 0x%x\n", hres));
    return hres;
  }

  pIADsContainer_Out = pDirectoryObj;

  return WBEM_S_NO_ERROR;
}

#define SYSTEM_PATH L"LDAP://CN=System,"
#define WMIPOLICY_PATH L"CN=WMIPolicy"
#define TEMPLATE_PATH L"CN=PolicyTemplate"
#define TYPE_PATH L"CN=PolicyType"
#define GPO_PATH L"CN=WMIGPO"
#define SOM_PATH L"CN=SOM"

HRESULT InScopeOfCOM_CreateADContainers(void)
{
  HRESULT
    hres = WBEM_E_FAILED;

  PDSROLE_PRIMARY_DOMAIN_INFO_BASIC 
    pBasic;

  CComPtr<IADs>
    pRootDSE;

  CComQIPtr<IADs, &IID_IADs>
    pObj;

  CComQIPtr<IADsContainer, &IID_IADsContainer>
    pWMIPolicyObj,
    pSystemObj,
    pADsContainer;

  CComVariant
    vDomainName;

  CComBSTR
    bstrSystemPath(SYSTEM_PATH),
    bstrWMIPolicy(WMIPOLICY_PATH),
    bstrTemplate(TEMPLATE_PATH),
    bstrType(TYPE_PATH),
    bstrSom(SOM_PATH),
    bstrGPO(GPO_PATH);

  // **** delay until AD is up and running

  DWORD
    dwResult = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic,
                                                 (PBYTE *)&pBasic);

  if(dwResult == ERROR_SUCCESS) 
  {
    // **** Check if this is a DC

    if((pBasic->MachineRole == DsRole_RoleBackupDomainController) || 
       (pBasic->MachineRole == DsRole_RolePrimaryDomainController)) 
    {
      HANDLE 
        hEvent;

      hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, TEXT("NtdsDelayedStartupCompletedEvent") );

      if(hEvent) {
          WaitForSingleObject(hEvent, 50000);
          CloseHandle (hEvent);
      }
    }
  }

  // **** get LDAP name of domain controller

  hres = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pRootDSE);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not get pointer to LDAP://rootDSE : 0x%x\n", hres));
    return hres;
  }
  else
  {
    hres = pRootDSE->Get(L"defaultNamingContext", &vDomainName);
    if(FAILED(hres) || (V_VT(&vDomainName) != VT_BSTR) || (V_BSTR(&vDomainName) == NULL))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) could not get defaultNamingContext : 0x%x\n", hres));
      return hres;
    }

    bstrSystemPath.Append(vDomainName.bstrVal);
  }

  // **** get system path

  hres = ADsGetObject(bstrSystemPath, IID_IADsContainer, (void **)&pSystemObj);
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not get pointer to %S : 0x%x\n", (BSTR)bstrSystemPath, hres));
    return hres;
  }

  // **** get/create WMIPolicy containers

  hres = GetOrCreateObj(pSystemObj, bstrWMIPolicy, pWMIPolicyObj);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrWMIPolicy, hres));
    return hres;
  }
  else
  {
    hres = GetOrCreateObj(pWMIPolicyObj, bstrTemplate, pADsContainer);
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrTemplate, hres));
      return hres;
    }

    hres = GetOrCreateObj(pWMIPolicyObj, bstrType, pADsContainer);
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrType, hres));
      return hres;
    }

    hres = GetOrCreateObj(pWMIPolicyObj, bstrSom, pADsContainer);
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrSom, hres));
      return hres;
    }

    hres = GetOrCreateObj(pWMIPolicyObj, bstrGPO, pADsContainer);
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrGPO, hres));
      return hres;
    }
  }

  return S_OK;
}

extern "C" STDAPI CreateADContainers(void)
{
  HRESULT
    hres = WBEM_E_FAILED;

  // **** init process context

  CoInitialize(NULL);

  CoInitializeSecurity (NULL, -1, NULL, NULL,
    RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
    EOAC_NONE, NULL);

  try
  {
    hres = InScopeOfCOM_CreateADContainers();
  }
  catch(...)
  {
    // **** error

    return WBEM_E_FAILED;
  }

  // **** if we returned successfully, then remove the run key

  if(SUCCEEDED(hres))
  {
    wchar_t
      swKeyValue[] = L"RUNDLL32.EXE %systemroot%\\system32\\wbem\\policman.dll,CreateADContainers",
      swExpandedKeyValue[512],
      swRunOnceKey[] = REG_RUN_KEY ;

    HKEY
      hkRunOnce;

    LONG
      lReturnCode;

    lReturnCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE, swRunOnceKey, 0, KEY_SET_VALUE, &hkRunOnce);

    if(ERROR_SUCCESS != lReturnCode)
    {
      // error
    }

    lReturnCode = RegDeleteValue(hkRunOnce, L"PolicMan");

    if(ERROR_SUCCESS != lReturnCode)
    {
      // error
    }
  }
    
  // **** cleanup and shutdown

  CoUninitialize();

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policman.h ===
#ifndef __WBEM_POLICY_MANAGER__H_
#define __WBEM_POLICY_MANAGER__H_

// {69D76D1B-B12E-4913-8F48-671B90195A2B}
const CLSID CLSID_PolicyStatus = 
    { 0x69d76d1b, 0xb12e, 0x4913, { 0x8f, 0x48, 0x67, 0x1b, 0x90, 0x19, 0x5a, 0x2b } };

// {AAEAE72B-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicyGPO = 
    { 0xaaeae72b, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// {AAEAE72C-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicyRange = 
    { 0xaaeae72c, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// {AAEAE72D-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicyTemplate = 
    { 0xaaeae72d, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// {AAEAE72E-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicyType = 
    { 0xaaeae72e, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// {AAEAE72F-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicySOM = 
    { 0xaaeae72f, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

#endif // __WBEM_POLICY_MANAGER__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policgpo.cpp ===
#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <atlbase.h>
#include <sync.h>
#include "activeds.h"
#include "genlex.h"
#include "objpath.h"
#include "Utility.h"

#include "PolicGPO.h"

/*****************************\
*** POLICY PROVIDER HELPERS ***
\*****************************/

// returns addref'd pointer back to m_pWMIMgmt
IWbemServices* CPolicyGPO::GetWMIServices(void)
{
  CInCritSec lock(&m_CS);

  if (NULL != m_pWMIMgmt)
    m_pWMIMgmt->AddRef();

  return m_pWMIMgmt;
}

// returns addref'd pointer back to m_pADMgmt
IADsContainer* CPolicyGPO::GetADServices(wchar_t *pADPath)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [WMIGPO] GetADServices (%S)\n", pADPath));

  CInCritSec lock(&m_CS);
  IADsContainer *pADContainer = NULL;
  HRESULT hres;

  if(NULL != pADPath)
  {
    wchar_t
      szDSPath[MAX_PATH];

    // wcscpy(szDSPath,L"LDAP://");
    // wcscat(szDSPath, pADPath);

    hres = ADsGetObject(pADPath, IID_IADsContainer, (void**) &pADContainer);
	if (FAILED(hres))
		ERRORTRACE((LOG_ESS, "POLICMAN: ADsGetObject failed 0x%08X\n", hres));
  }

  return pADContainer;
}

// returns false if services pointer has already been set
bool CPolicyGPO::SetWMIServices(IWbemServices* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull;

  if (bOldOneNull = (m_pWMIMgmt == NULL))
  {
    m_pWMIMgmt = pServices;
    pServices->AddRef();
  }

  return bOldOneNull;
}

// returns false if services pointer has already been set
bool CPolicyGPO::SetADServices(IADsContainer* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull;

  if (bOldOneNull = (m_pADMgmt == NULL))
  {
    m_pADMgmt = pServices;
    if(pServices) pServices->AddRef();
  }

  return bOldOneNull;
}
    
CPolicyGPO::~CPolicyGPO()
{
  // **** WMI services object

  if (NULL != m_pWMIMgmt)
  {
    m_pWMIMgmt->Release();
    m_pWMIMgmt= NULL;
  }

  // **** AD services object

  if (NULL != m_pADMgmt)
  {
    m_pADMgmt->Release();
    m_pADMgmt= NULL;
  }
};

void* CPolicyGPO::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}

/********************\
*** Object Support ***
\********************/

// returns addref'd pointer to class object
IWbemClassObject* CPolicyGPO::XProvider::GetWMIGPOClass()
{
    CInCritSec lock(&m_pObject->m_CS);

    if (m_pWMIGPOClassObject == NULL)
    {
        IWbemServices* pWinMgmt = NULL;
        if (pWinMgmt = m_pObject->GetWMIServices())
        {
            CReleaseMe relMgmt(pWinMgmt);
            pWinMgmt->GetObject(g_bstrClassWMIGPO, 
                                WBEM_FLAG_RETURN_WBEM_COMPLETE, 
                                NULL, 
                                &m_pWMIGPOClassObject, 
                                NULL);
        }
    }

    if (m_pWMIGPOClassObject)
        m_pWMIGPOClassObject->AddRef();

    return m_pWMIGPOClassObject;
}

// returns addref'd pointer to emply class instance
IWbemClassObject* CPolicyGPO::XProvider::GetWMIGPOInstance()
{
    IWbemClassObject* pObj = NULL;
    IWbemClassObject* pClass = NULL;

    if (pClass = GetWMIGPOClass())
    {
        CReleaseMe releaseClass(pClass);
        pClass->SpawnInstance(0, &pObj);
    }

    return pObj;
}

CPolicyGPO::XProvider::~XProvider()
{
  if(NULL != m_pWMIGPOClassObject)
  {
    m_pWMIGPOClassObject->Release();
    m_pWMIGPOClassObject = NULL;
  }
}

/*************************\
***  IWbemProviderInit  ***
\*************************/

STDMETHODIMP CPolicyGPO::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices* pServices, IWbemContext* pCtxt, 
            IWbemProviderInitSink* pSink)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [WMIGPO] IWbemProviderInit::Initialize\n"));

  CComPtr<IADs>
    pRootDSE;

  CComPtr<IADsContainer>
    pObject;

  HRESULT
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  wchar_t
    szDSPath[MAX_PATH];

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    return WBEM_S_ACCESS_DENIED;
  }
  else
  {
    // **** safe WMI name space pointer

    m_pObject->SetWMIServices(pServices);

    // **** get pointer to AD policy template table

    hres = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pRootDSE);
    if (FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not get object: LDAP://rootDSE, 0x%08X\n", hres));
      return WBEM_E_NOT_FOUND;
    }
    else
    {
      hres = pRootDSE->Get(L"defaultNamingContext",&m_pObject->m_vDsLocalContext);
      if(FAILED(hres))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: (IADs::Get) could not get defaultNamingContext, 0x%08X\n", hres));
        hres = WBEM_E_NOT_FOUND;
      }

      hres = pRootDSE->Get(L"configurationNamingContext",&m_pObject->m_vDsConfigContext);
      if(FAILED(hres))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: (IADs::Get) could not get configurationNamingContext, 0x%08X\n", hres));
        hres = WBEM_E_NOT_FOUND;
      }
    }
  }
  hres2 = pSink->SetStatus(hres, 0);
  if(FAILED(hres2))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
    if(SUCCEEDED(hres)) hres = hres2;
  }

  return hres;
}

/*******************\
*** IWbemServices ***
\*******************/

STDMETHODIMP CPolicyGPO::XProvider::GetObjectAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponse)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [WMIGPO] IWbemServices::GetObjectAsync(%S, 0x%x, 0x%x, 0x%x)\n", ObjectPath, lFlags, pCtx, pResponse));

  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  wchar_t
    *DsPath = NULL;

  CComPtr<IWbemServices>
    pNamespace;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IWbemClassObject>
    pObj;

  CComPtr<IDirectoryObject>
    pDirObj;

  // **** impersonate client

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    pNamespace = m_pObject->GetWMIServices();

    if(pNamespace == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: WMI services not initialized\n"));
      hres = WBEM_E_NOT_FOUND;
    }
    else
    {
      // **** Check arguments

      if(ObjectPath == NULL || pResponse == NULL)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: object path and/or return object are NULL\n"));
        hres = WBEM_E_INVALID_PARAMETER;
      }
      else
      {
        // **** parse object path

        CObjectPathParser
          ObjPath(e_ParserAcceptRelativeNamespace);

        ParsedObjectPath
          *pParsedObjectPath = NULL;

        if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
           (0 != _wcsicmp(g_bstrClassWMIGPO, pParsedObjectPath->m_pClass)) ||
           (1 != pParsedObjectPath->m_dwNumKeys))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
          hres = WBEM_E_INVALID_QUERY;
        }
        else
        {
          int x;

          for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
            if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDsPath))
              DsPath = V_BSTR(&((*(pParsedObjectPath->m_paKeys + x))->m_vValue));

          try
          {
            // **** obtain WMIGPO object pointed to by DsPath

            pADsContainer = m_pObject->GetADServices(DsPath);
            if(pADsContainer == NULL)
            {
              ERRORTRACE((LOG_ESS, "POLICMAN: could not find container in AD: %S\n", DsPath));
              return WBEM_E_NOT_FOUND;
            }

            // **** Get pointer to instance in AD

            hres = pADsContainer->GetObject(g_bstrADClassWMIGPO, 
                                            QString(L"CN=") << L"SINGLE_WMIGPO", &pDisp);
            if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

            hres = pDisp->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
            if(FAILED(hres)) return hres;

            // **** Get the instance and send it back

            hres = WMIGPO_ADToCIM(&pObj, pDirObj, pNamespace);
            if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
            if(pObj == NULL) return WBEM_E_FAILED;

            // **** Set object


            pResponse->Indicate(1, &pObj);
          }
          catch(long hret)
          {
            hres = ADSIToWMIErrorCodes(hret);
            ERRORTRACE((LOG_ESS, "POLICMAN: Translation of object from AD to WMI generated HRESULT 0x%08X\n", hres));
          }
          catch(wchar_t *swErrString)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
            hres = WBEM_E_FAILED;
          }
          catch(...)
          {
              // please leave the word 'unknown' in lower case.
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught Unknown Exception\n"));
            hres = WBEM_E_FAILED;
          }
        }

        hres2 = pResponse->SetStatus(0,hres, NULL, NULL);
        if(FAILED(hres2))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
          if(SUCCEEDED(hres)) hres = hres2;
        }

        ObjPath.Free(pParsedObjectPath);
        pParsedObjectPath = NULL;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicyGPO::XProvider::CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [WMIGPO] IWbemServices::CreateInstanceEnumAsync(%S, 0x%x, 0x%x, 0x%x)\n", Class, lFlags, pCtx, pResponseHandler));

  HRESULT
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  CComVariant
    v1;

  ULONG
    nFetched = 0;

  CComPtr<IWbemClassObject>
    pObj;

  CComPtr<IWbemServices>
    pNamespace;

  CComPtr<IDirectorySearch>
    pDirSrch;

  CComPtr<IDirectoryObject>
    pDirObj;

  CComPtr<IADsContainer>
    pADsContainer;

  IEnumVARIANT
    *pEnum = NULL;

  wchar_t 
    *pszContexts[] = { L"GLOBAL", L"LOCAL" }, 
    *pszDistName[] = { L"distinguishedName" },
    objPath[1024];

  ADS_SEARCH_HANDLE
    searchHandle;

  ADS_SEARCH_COLUMN
    searchColumn;

  // **** impersonate client

  hres = CoImpersonateClient();
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** Check arguments

    if(Class == NULL || pResponseHandler == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object path and/or return object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      ParsedObjectPath
        *pParsedObjectPath = NULL;

      if((ObjPath.NoError != ObjPath.Parse(Class, &pParsedObjectPath)) ||
         (0 != _wcsicmp(g_bstrClassWMIGPO, pParsedObjectPath->m_pClass)) ||
         (0 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", Class));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        // **** bind to global catalog and WMI

        pNamespace = m_pObject->GetWMIServices();

        if(pNamespace == NULL)
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: WMI and/or AD services not initialized: 0x%08X\n", hres));
          hres = WBEM_E_NOT_FOUND;
        }
        else
        {
          for(int i = 0; i < AD_MAX_CONTEXT; i++)
          {
            switch(i)
            {
              case AD_LOCAL_CONTEXT :
                wcscpy(objPath,L"LDAP://CN=System,");
                break;
              case AD_GLOBAL_CONTEXT :
                wcscpy(objPath,L"LDAP://CN=Services,CN=Configuration,");
              default : ;
            }

            wcscat(objPath, m_pObject->m_vDsLocalContext.bstrVal);

            pADsContainer = m_pObject->GetADServices(objPath);
            if(pADsContainer == NULL)
            {
              // ERRORTRACE((LOG_ESS, "POLICMAN: could not find container in AD: %S\n", DsPath));
              hres = WBEM_E_NOT_FOUND; 
            }
            else
            {
              hres = pADsContainer->QueryInterface(IID_IDirectorySearch, (void **)&pDirSrch);

              // **** set search preferences

              // **** perform search 

              hres = pDirSrch->ExecuteSearch(
                     QString(L"(objectCategory=") << g_bstrADClassWMIGPO << L")",
                     pszDistName,
                     1, 
                     &searchHandle);

              if(FAILED(hres))
              {
                ERRORTRACE((LOG_ESS, "POLICMAN: Could perform Global Catalog search for Som objects, 0x%08X\n", hres));
                hres = WBEM_E_FAILED;
              }
              else
              {
                try
                {
                  while(SUCCEEDED(hres = pDirSrch->GetNextRow(searchHandle)) &&
                      (S_ADS_NOMORE_ROWS != hres))
                  {
                    // **** get path to object
  
                    hres = pDirSrch->GetColumn(searchHandle, pszDistName[0], &searchColumn);
                    if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
  
                    // **** get pointer to object
  
                    wcscpy(objPath, L"LDAP://");
                    wcscat(objPath, searchColumn.pADsValues->CaseIgnoreString);
                    pDirSrch->FreeColumn(&searchColumn);
    
                    hres = ADsGetObject(objPath, IID_IDirectoryObject, (void **)&pDirObj);
                    if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

                    hres = WMIGPO_ADToCIM(&pObj, pDirObj, pNamespace);
                    if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
                    if(pObj == NULL) return WBEM_E_FAILED;
                    hres = pResponseHandler->Indicate(1, &pObj);
  
                    pDirObj = NULL;
                    pObj = NULL;
                  }
                }
                catch(long hret)
                {
                  hres = ADSIToWMIErrorCodes(hret);
                  ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
                }
                catch(wchar_t *swErrString)
                {
                  ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
                  hres = WBEM_E_FAILED;
                }
                catch(...)
                {
                  ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
                  hres = WBEM_E_FAILED;
                }

                hres = pDirSrch->CloseSearchHandle(searchHandle);
              }
            }
          }
        }
      }

      ObjPath.Free(pParsedObjectPath);
      hres2 = pResponseHandler->SetStatus(0, hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicyGPO::XProvider::PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [WMIGPO] IWbemServices::PutInstanceAsync(0x%x, 0x%x, 0x%x, 0x%x)\n", pInst, lFlags, pCtx, pResponseHandler));

  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1, vRelPath;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDirectoryObject>
    pDirObj;

  // **** impersonate client

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** check arguments

    if((NULL == pInst) || (NULL == pResponseHandler))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object handle and/or return status object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** put policy obj into AD

      try
      {
        // **** aquire AD path in which to place object

        hres = pInst->Get(g_bstrDsPath, 0, &v1, NULL, NULL);
        if(FAILED(hres)) return hres;

        if(VT_BSTR == v1.vt)
          pADsContainer = m_pObject->GetADServices(V_BSTR(&v1));

        if(pADsContainer == NULL)
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Could not find or connect to domain: %S\n", V_BSTR(&v1)));
          return WBEM_E_ACCESS_DENIED;
        }
        else
        {
          hres = pADsContainer->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
          if(FAILED(hres)) return hres;

          // **** copy policy obj into AD

          hres = WMIGPO_CIMToAD(pInst, pDirObj, lFlags);
          if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
        }  
      }
      catch(long hret)
      {
        hres = ADSIToWMIErrorCodes(hret);
        ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from WMI to AD generated HRESULT 0x%08X\n", hres));
      }
      catch(wchar_t *swErrString)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
        hres = WBEM_E_FAILED;
      }
      catch(...)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
        hres = WBEM_E_FAILED;
      }

      // send it back as we may have added keys
      if(SUCCEEDED(hres))
        pResponseHandler->Indicate(1, &pInst);

      // **** indicate return status

      pInst->Get(L"__RELPATH", 0, &vRelPath, NULL, NULL);
      if(FAILED(pResponseHandler->SetStatus(0, hres, vRelPath.bstrVal, NULL)))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicyGPO::XProvider::DeleteInstanceAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [WMIGPO] IWbemServices::DeleteInstanceAsync(%S, 0x%x, 0x%x, 0x%x)\n", ObjectPath, lFlags, pCtx, pResponseHandler));

  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IADsDeleteOps>
    pDelObj;

  wchar_t
    *DsPath = NULL;

  // **** impersonate client

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** Check arguments

    if(ObjectPath == NULL || pResponseHandler == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object handle and/or return status object are NULL\n"));
      return WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse WMI object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      ParsedObjectPath
        *pParsedObjectPath = NULL;

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         (0 != _wcsicmp(g_bstrClassWMIGPO, pParsedObjectPath->m_pClass)) ||
         (1 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        int x;

        // **** only grab ID key for now

        for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDsPath))
            DsPath = V_BSTR(&((*(pParsedObjectPath->m_paKeys + x))->m_vValue));

        // **** obtain WMIGPO object pointed to by DsPath

        pADsContainer = m_pObject->GetADServices(DsPath);
        if(pADsContainer == NULL)
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: could not find container in AD: %S\n", DsPath));
          hres = WBEM_E_NOT_FOUND;
        }
        else
        {
          // **** Get pointer to instance in AD

          hres = pADsContainer->GetObject(g_bstrADClassWMIGPO, L"CN=SINGLE_WMIGPO", &pDisp);
          if(FAILED(hres))
          {
            hres = ADSIToWMIErrorCodes(hres);
            ERRORTRACE((LOG_ESS, "POLICMAN: (IADsContainer::GetObject) could not get object in AD 0x%08X\n", hres));
          }
          else
          {
            hres = pDisp->QueryInterface(IID_IADsDeleteOps, (void **)&pDelObj);
            if(FAILED(hres))
            {
              ERRORTRACE((LOG_ESS, "POLICMAN: (IDispatch::QueryInterface) could not get IID_IADsDeleteOps interface on object\n"));
            }
            else
            {
              // **** delete the instance and all its children in AD

              hres = pDelObj->DeleteObject(0);
              if(FAILED(hres))
              {
                hres = ADSIToWMIErrorCodes(hres);
                ERRORTRACE((LOG_ESS, "POLICMAN: (IADsDeleteOps::DeleteObject) could not delete object\n"));
              }
            }
          }
        }

        ObjPath.Free(pParsedObjectPath);
      }

      // **** Set Status

      hres2 = pResponseHandler->SetStatus(0, hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicyGPO::XProvider::ExecQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

STDMETHODIMP CPolicyGPO::XProvider::ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policrange.cpp ===
#include "PolicRange.h"
#include <stdio.h>
#include <windows.h>
#include <ArrTempl.h>
#include <wbemutil.h>
#include <GenUtils.h>
#include "genlex.h"
#include "objpath.h"
#include "utility.h"

/******************************\
**** POLICY PROVIDER HELPERS ***
\******************************/

// returns addref'd pointer back to m_pWMIMgmt
IWbemServices* CPolicyRange::GetWMIServices(void)
{
  CInCritSec lock(&m_CS);

  if (NULL != m_pWMIMgmt)
    m_pWMIMgmt->AddRef();

  return m_pWMIMgmt;
}

// returns addref'd pointer back to m_pADMgmt
IADsContainer* CPolicyRange::GetADServices(void)
{
  CInCritSec lock(&m_CS);
  IADsContainer *pADContainer = NULL;
  HRESULT hres;
  wchar_t *pADPath = NULL;

  if(NULL == pADPath)
  {
    if(NULL != m_pADMgmt)
    {
      m_pADMgmt->AddRef();
      pADContainer = m_pADMgmt;
    }
  }
  else
  {
    wchar_t
      szDSPath[MAX_PATH];

    // wcscpy(szDSPath,L"LDAP://");
    // wcscat(szDSPath, pADPath);

    hres = ADsGetObject(pADPath, IID_IADsContainer, (void**) &pADContainer);
        if (FAILED(hres))
                ERRORTRACE((LOG_ESS, "POLICMAN: failed 0x%08X\n", hres));
  }

  return pADContainer;
}

// returns false if services pointer has already been set
bool CPolicyRange::SetWMIServices(IWbemServices* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull; 

  if (bOldOneNull = (m_pWMIMgmt == NULL))
  {
    m_pWMIMgmt = pServices;
    pServices->AddRef();
  }

  return bOldOneNull;
}

// returns false if services pointer has already been set
bool CPolicyRange::SetADServices(IADsContainer* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull;

  if (bOldOneNull = (m_pADMgmt == NULL))
  {
    m_pADMgmt = pServices;
    if(pServices) pServices->AddRef();
  }

  return bOldOneNull;
}

CPolicyRange::~CPolicyRange()
{
  // **** WMI services object

  if (NULL != m_pWMIMgmt)
  {
    m_pWMIMgmt->Release();
    m_pWMIMgmt= NULL;
  }

  // **** AD services object

  if (NULL != m_pADMgmt)
  {
    m_pADMgmt->Release();
    m_pADMgmt= NULL;
  }
};

void* CPolicyRange::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}

/*********************************************\
*** Policy Template Specific Implementation ***
\*********************************************/

// returns addref'd pointer to class object
IWbemClassObject* CPolicyRange::XProvider::GetPolicyTemplateClass()
{
  CInCritSec lock(&m_pObject->m_CS);

  if(NULL == m_pWMIPolicyClassObject)
  {
    IWbemServices* pWinMgmt = NULL;

    if(pWinMgmt = m_pObject->GetWMIServices())
    {
      CReleaseMe relMgmt(pWinMgmt);
      pWinMgmt->GetObject(g_bstrClassMergeablePolicy, 
                          WBEM_FLAG_RETURN_WBEM_COMPLETE, 
                          NULL, 
                          &m_pWMIPolicyClassObject, 
                          NULL);
    }
  }

  if (m_pWMIPolicyClassObject)
    m_pWMIPolicyClassObject->AddRef();

  return m_pWMIPolicyClassObject;
}

// returns addref'd pointer to emply class instance
IWbemClassObject* CPolicyRange::XProvider::GetPolicyTemplateInstance()
{
  IWbemClassObject* pObj = NULL;
  IWbemClassObject* pClass = NULL;

  if (pClass = GetPolicyTemplateClass())
  {
    CReleaseMe releaseClass(pClass);
    pClass->SpawnInstance(0, &pObj);
  }

  return pObj;
}


CPolicyRange::XProvider::~XProvider()
{
// I fixed it! - HMH  ;-)  
// CInCritSec lock(&m_pObject->m_CS);

  if(NULL != m_pWMIPolicyClassObject)
  {
    m_pWMIPolicyClassObject->Release();
    m_pWMIPolicyClassObject = NULL;
  }
}

/*************************\
***  IWbemProviderInit  ***
\*************************/

STDMETHODIMP CPolicyRange::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices* pServices, IWbemContext* pCtxt, 
            IWbemProviderInitSink* pSink)
{
  CComPtr<IADs>
    pRootDSE;

  CComPtr<IADsContainer>
    pObject;

  HRESULT
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  CComVariant
    v1;

  wchar_t
    szDSPath[MAX_PATH];

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    hres = WBEM_S_ACCESS_DENIED;
  }
  else
  {
    // **** safe WMI name space pointer

    m_pObject->SetWMIServices(pServices);
	
    // **** get pointer to AD policy template table

    hres = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pRootDSE);
    if (FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not get object: LDAP://rootDSE, 0x%08X\n", hres));
      hres = WBEM_E_NOT_FOUND;
    }
    else
    {
      hres = pRootDSE->Get(L"defaultNamingContext",&v1);
      if(FAILED(hres))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: (IADs::Get) could not get defaultNamingContext, 0x%08X\n", hres));
        hres = WBEM_E_NOT_FOUND;
      }
      else
      {
        wcscpy(szDSPath,L"LDAP://CN=PolicyTemplate,CN=WMIPolicy,CN=System,");
        wcscat(szDSPath, V_BSTR(&v1));
  
        hres = ADsGetObject(szDSPath, IID_IADsContainer, (void**) &pObject);
        if (FAILED(hres))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not get AD object: %S, 0x%08X\n", szDSPath, hres));
          hres = WBEM_E_NOT_FOUND;
        }

        m_pObject->SetADServices(pObject);
      }
    }
  }
  
  hres2 = pSink->SetStatus(hres, 0);
  if(FAILED(hres2))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
    if(SUCCEEDED(hres)) hres = hres2;
  }

  return hres;
}

/*******************\
*** IWbemServices ***
\*******************/

//TODO: clean up bstrs & variants upon raising an exception (maybe theres a CVariantClearMe or some such?)

HRESULT CPolicyRange::XProvider::DoResolve(IWbemServices* pPolicyNamespace,
                                              const BSTR strObjectPath,
                                              IWbemContext __RPC_FAR *pCtx,
                                              IWbemClassObject __RPC_FAR *pInParams,
                                              IWbemClassObject __RPC_FAR *pOutParams,
                                              IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT
    hres = WBEM_E_FAILED;

  CComPtr<IUnknown>
    pUnk;

  ParsedObjectPath
    *pParsedObjectPath = NULL;

  CComPtr<IWbemClassObject>
    pTargetPolicyObj,
    pMergedParam;

  CComVariant
    vRetVal,
    vMergedRange,
    vObj,
    vMergedParamValue,
    vMergedParamName,
    vTargetValue;

  long 
    nIndex = -1;

  wchar_t
    *pswIndexStart = NULL;

  // **** parse object path

  CObjectPathParser
    ObjPath(e_ParserAcceptRelativeNamespace);

  if(ObjPath.NoError != ObjPath.Parse(strObjectPath, &pParsedObjectPath))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", strObjectPath));
    hres = WBEM_E_INVALID_QUERY;
  }
  else
  {
    // **** get input param obj

    hres = pInParams->Get(L"mergedRange", 0, &vMergedRange, NULL, NULL);
    if(FAILED(hres)) return hres;
    hres = V_UNKNOWN(&vMergedRange)->QueryInterface(IID_IWbemClassObject, (void **)&pMergedParam);
    if(FAILED(hres)) return hres;

    // **** get target policy object 

    hres = pInParams->Get(L"obj", 0, &vObj, NULL, NULL);
    if(FAILED(hres)) return hres;
    hres = V_UNKNOWN(&vObj)->QueryInterface(IID_IWbemClassObject, (void **)&pTargetPolicyObj);
    if(FAILED(hres)) return hres;

    // **** get name for attribute in target policy object named in param obj

    hres = pMergedParam->Get(L"PropertyName", 0, &vMergedParamName, NULL, NULL);
    if(FAILED(hres)) return hres;

    // **** parse name to see if it is part of an array

    if(pswIndexStart = wcsstr(V_BSTR(&vMergedParamName), L"["))
    {
      *pswIndexStart = L'\0';

      nIndex = wcstol(pswIndexStart + 1, NULL, 10);
    }

    // **** check to see if vParamAttrName is an attribute in target object

    hres = pTargetPolicyObj->Get(V_BSTR(&vMergedParamName), 0, &vTargetValue, NULL, NULL);
    if(FAILED(hres))
    {
      if(WBEM_E_NOT_FOUND == hres)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Policy range setting %S not in target object\n", vMergedParamName.bstrVal));
      }
      else
        return hres;
    }
    else
    {
      // **** get default value from param obj

      hres = pMergedParam->Get(L"Default", 0, &vMergedParamValue, NULL, NULL);
      if(FAILED(hres)) return hres;

      // **** set value

      if(nIndex < 0)
      {
        // **** check to see if attribute is already set

        if(vTargetValue.vt != VT_NULL)
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Attempt to set policy range setting %S more than once\n", vMergedParamName.bstrVal));
        }
        else
        {
          hres = pTargetPolicyObj->Put(V_BSTR(&vMergedParamName), 0, &vMergedParamValue, 0);
          if(FAILED(hres)) 
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Attempting to place attribute %S in target instance generated error 0x%x\n", vMergedParamName.bstrVal, hres));
            return hres;
          }
        }
      }
      else
      {
        if((vTargetValue.vt & VT_ARRAY)  || (vTargetValue.vt == VT_NULL))
        {
          CComVariant
            vNewArray;
  
          // **** signed and unsigned integers

          if((vMergedParamValue.vt & VT_I4))
          {
            SafeArray<int, VT_I4>
              arrayMember(&vTargetValue);
  
            if(arrayMember.IndexMax() < nIndex)
            {
              arrayMember.ReDim(0, nIndex + 1);
            }
  
            arrayMember[nIndex] = vMergedParamValue.lVal;
  
            V_VT(&vNewArray) = (VT_ARRAY | VT_I4);
            V_ARRAY(&vNewArray) = arrayMember.Data();
          }
  
          // **** real numbers
  
          else if((vMergedParamValue.vt & VT_R8))
          {
            SafeArray<double, VT_R8>
              arrayMember(&vTargetValue);
  
            if(arrayMember.IndexMax() < nIndex)
            {
              arrayMember.ReDim(0, nIndex + 1);
            }
  
            arrayMember[nIndex] = vMergedParamValue.dblVal;
  
            V_VT(&vNewArray) = (VT_ARRAY | VT_R8);
            V_ARRAY(&vNewArray) = arrayMember.Data();
          }
  
          // **** strings
  
          else if((vMergedParamValue.vt & VT_BSTR))
          {
            SafeArray<BSTR, VT_BSTR>
              arrayMember(&vTargetValue);
  
            if(arrayMember.IndexMax() < nIndex)
            {
              arrayMember.ReDim(0, nIndex + 1);
            }
            else if(NULL != arrayMember[nIndex]) 
            {
              SysFreeString(arrayMember[nIndex]);
            }
  
            arrayMember[nIndex] = SysAllocString(vMergedParamValue.bstrVal);
  
            V_VT(&vNewArray) = (VT_ARRAY | VT_BSTR);
            V_ARRAY(&vNewArray) = arrayMember.Data();
          }
  
          hres = pTargetPolicyObj->Put(V_BSTR(&vMergedParamName), 0, &vNewArray, 0);
          if(FAILED(hres)) return hres;
        }
        else
          return WBEM_E_TYPE_MISMATCH;
      }
    }

    // **** put target policy obj in output param obj

    hres = pTargetPolicyObj->QueryInterface(IID_IUnknown, (void **)&pUnk);
    if(FAILED(hres)) return hres;

    vObj = pUnk;
    hres = pOutParams->Put(L"obj", 0, &vObj, 0);
    if(FAILED(hres)) return hres;

    // **** put status in return value

    vRetVal = hres;
    hres = pOutParams->Put(L"ReturnValue", 0, &vRetVal, 0);
    if(FAILED(hres)) return hres;

    // **** send output back to client

    hres = pResponseHandler->Indicate(1, &pOutParams);
    if(FAILED(hres)) return hres;
  }

  ObjPath.Free(pParsedObjectPath);

  return hres;
}

HRESULT CPolicyRange::XProvider::DoSet()
{
    HRESULT hr = WBEM_E_FAILED;
    return hr;
}

HRESULT CPolicyRange::XProvider::DoMerge(IWbemServices* pNamespace,
                                            const BSTR strObjectPath, 
                                            IWbemContext __RPC_FAR *pCtx,
                                            IWbemClassObject __RPC_FAR *pInParams,
                                            IWbemClassObject __RPC_FAR *pOutParams,
                                            IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
    hres = WBEM_E_FAILED;

  CComPtr<IUnknown>
    pUnk;

  ParsedObjectPath
    *pParsedObjectPath = NULL;

  CComPtr<IWbemClassObject>
    pMergedParam;

  CComVariant 
    v1;

  // **** parse object path

  CObjectPathParser
    ObjPath(e_ParserAcceptRelativeNamespace);

  if(ObjPath.NoError != ObjPath.Parse(strObjectPath, &pParsedObjectPath))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", strObjectPath));
    hres = WBEM_E_INVALID_QUERY;
  }
  else
  {
    int
      firstElement = -1,
      conflictObj = -1;

    CComPtr<IWbemClassObject>
      pArrayElement;

    CComVariant
      vRangeParamType;

    // **** get input array

    hres = pInParams->Get(L"ranges", 0, &v1, NULL, NULL);
    if(FAILED(hres)) return hres;

    SafeArray<IUnknown*, VT_UNKNOWN>
      InputArray(&v1);

    firstElement = -1;
    while((++firstElement < InputArray.Size()) && (NULL == InputArray[firstElement]));
    if(firstElement >= InputArray.Size()) return WBEM_E_INVALID_PARAMETER;

    // **** get actual type of range parameter objects

    hres = InputArray[firstElement]->QueryInterface(IID_IWbemClassObject, (void **)&pArrayElement);
    if(FAILED(hres)) return hres;

    hres = pArrayElement->Get(L"__CLASS", 0, &vRangeParamType, NULL, NULL);
    if(FAILED(hres)) return hres;
 
    // **** perform merge

    if(-1 == conflictObj)
    {
      if(_wcsicmp(vRangeParamType.bstrVal, L"MSFT_SintRangeParam") == 0) 
        hres = Range_Sint32_Merge(InputArray, pMergedParam, conflictObj);

      else if(_wcsicmp(vRangeParamType.bstrVal, L"MSFT_UintRangeParam") == 0) 
        hres = Range_Uint32_Merge(InputArray, pMergedParam, conflictObj);

      else if(_wcsicmp(vRangeParamType.bstrVal, L"MSFT_RealRangeParam") == 0) 
        hres = Range_Real_Merge(InputArray, pMergedParam, conflictObj);

      else if(_wcsicmp(vRangeParamType.bstrVal, L"MSFT_SintSetParam") == 0) 
        hres = Set_Sint32_Merge(InputArray, pMergedParam, conflictObj);

      else if(_wcsicmp(vRangeParamType.bstrVal, L"MSFT_UintSetParam") == 0) 
        hres = Set_Uint32_Merge(InputArray, pMergedParam, conflictObj);

      else if(_wcsicmp(vRangeParamType.bstrVal, L"MSFT_StringSetParam") == 0) 
        hres = Set_String_Merge(InputArray, pMergedParam, conflictObj);

      else
        return WBEM_E_INVALID_PARAMETER;
    }

    // **** put merged range in output param obj

    if(NULL != pMergedParam.p)
    {
      hres = pMergedParam->QueryInterface(IID_IUnknown, (void **)&pUnk);
      if(FAILED(hres)) return hres;

      v1 = pUnk;
      hres = pOutParams->Put(L"mergedRange", 0, &v1, 0);
      if(FAILED(hres)) return hres;
    }

    // **** put put which policy object caused conflict

    v1 = conflictObj;
    hres = pOutParams->Put(L"conflict", 0, &v1, 0);
    if(FAILED(hres)) return hres;

    // **** put status in return value

    v1 = hres;
    hres = pOutParams->Put(L"ReturnValue", 0, &v1, 0);
    if(FAILED(hres)) return hres;

    // **** send output back to client

    hres = pResponseHandler->Indicate(1, &pOutParams);
    if(FAILED(hres)) return hres;
  }

  ObjPath.Free(pParsedObjectPath);
 
  return WBEM_S_NO_ERROR;
}

STDMETHODIMP CPolicyRange::XProvider::ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
  hres = WBEM_S_NO_ERROR;

  IWbemServices* pNamespace = m_pObject->GetWMIServices();
  CReleaseMe RelpNamespace(pNamespace);

  // **** impersonate client
  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    hres = WBEM_S_ACCESS_DENIED;
  }
  else
  {
    if((NULL == strObjectPath) || 
      (NULL == strMethodName) || 
      (NULL == pInParams) ||
      (NULL == pResponseHandler))
    {
       ERRORTRACE((LOG_ESS, "POLICMAN: object handle and/or return status objects are NULL\n"));
       hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      try
      {
        // **** get policy template class definition

        IWbemClassObject* pClass = NULL;
        hres = pNamespace->GetObject(g_bstrClassRangeParam, 0, pCtx, &pClass, NULL);
        if(FAILED(hres)) return hres;
        CReleaseMe relClass(pClass);

        // **** get output object

        IWbemClassObject* pOutClass = NULL;
        IWbemClassObject* pOutParamsObj = NULL;

        CReleaseMe relOutClass(pOutClass);
        CReleaseMe relOutObj(pOutParamsObj);

        hres = pClass->GetMethod(strMethodName, 0, NULL, &pOutClass);
        if(FAILED(hres)) return hres;

        hres = pOutClass->SpawnInstance(0, &pOutParamsObj);
        if(FAILED(hres)) return hres;

        // **** figure out which method we're here to service

        if (_wcsicmp(strMethodName, L"Merge") == 0)
          hres = DoMerge(pNamespace, strObjectPath, pCtx, pInParams, pOutParamsObj, pResponseHandler);
        else if (_wcsicmp(strMethodName, L"Resolve") == 0)
          hres = DoResolve(pNamespace, strObjectPath, pCtx, pInParams, pOutParamsObj, pResponseHandler);
        else
          hres = WBEM_E_INVALID_PARAMETER;
      }
      catch(long hret)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: caught exception with HRESULT 0x%08X\n", hret));
        hres = hret;
      }
      catch(wchar_t *swErrString)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
        hres = WBEM_E_FAILED;
      }
      catch(...)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
        hres = WBEM_E_FAILED;
      }
    }

    pResponseHandler->SetStatus(0, hres, NULL, NULL);
    
    hres = CoRevertToSelf();
  }

  return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policrange.h ===
#ifndef __WBEM_POLICY_RANGE__H_
#define __WBEM_POLICY_RANGE__H_

#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>
#include <sync.h>
#include "activeds.h"

class CPolicyRange : public CUnk
{
public:
    CPolicyRange(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), 
          m_XProvider(this), 
          m_XInit(this), 
          m_pWMIMgmt(NULL),
          m_pADMgmt(NULL)
    {}
    
	~CPolicyRange();

    void* GetInterface(REFIID riid);

	// stuff for our internal use
	IWbemServices* GetWMIServices();
        IADsContainer* GetADServices(void);

	bool SetWMIServices(IWbemServices* pServices);
	bool SetADServices(IADsContainer* pServices);

protected:
    class XProvider : public CImpl<IWbemServices, CPolicyRange>
    {
    public:

        IWbemClassObject *GetPolicyTemplateClass();
        IWbemClassObject *GetPolicyTemplateInstance();

        IWbemClassObject *m_pWMIPolicyClassObject;

        HRESULT DoResolve(IWbemServices* pPolicyNamespace,
                          const BSTR strObjectPath,
                          IWbemContext __RPC_FAR *pCtx,
                          IWbemClassObject __RPC_FAR *pInParams,
                          IWbemClassObject __RPC_FAR *pOutParams,
                          IWbemObjectSink __RPC_FAR *pResponseHandler);

        HRESULT DoMerge(IWbemServices* pNamespace,
                        const BSTR strObjectPath,
                        IWbemContext __RPC_FAR *pCtx,
                        IWbemClassObject __RPC_FAR *pInParams,
                        IWbemClassObject __RPC_FAR *pOutParams,
                        IWbemObjectSink __RPC_FAR *pResponseHandler);

        XProvider(CPolicyRange* pObj)
            : CImpl<IWbemServices, CPolicyRange>(pObj),
              m_pWMIPolicyClassObject(NULL)
              {}

        ~XProvider(void);
		
		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
		{return WBEM_E_NOT_SUPPORTED;};

        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
		{return WBEM_E_NOT_SUPPORTED;};

        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
		{return WBEM_E_NOT_SUPPORTED;};

        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
		{return WBEM_E_NOT_SUPPORTED;};

        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) 
			{return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

      HRESULT DoSet();

    } m_XProvider;

    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CPolicyRange>
    {
    public:
        XInit(CPolicyRange* pObj)
            : CImpl<IWbemProviderInit, CPolicyRange>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;

    friend XInit;

private:

  // pointer back to win management
  IWbemServices* m_pWMIMgmt;

  // pointer to AD policy template table
  IADsContainer* m_pADMgmt;

  // templates for each type of object we support
  // NULL until we need it
  IWbemClassObject* m_pWMIPolicyClassObject;

  // a little something to keep our threads from getting tangled
  // will use a single critical section to protect all instance variables
  CCritSec m_CS;   
};


#endif // __WBEM_POLICY_RANGE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policstatus.cpp ===
#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <atlbase.h>
#include <sync.h>
#include <activeds.h>
#include <genlex.h>
#include <objpath.h>
#include <Utility.h>
#include <ql.h>

#include "PolicStatus.h"

#ifdef TIME_TRIALS
#include <StopWatch.h>
#pragma message("!! Including time trial code !!")
	StopWatch EvaluateTimer(L"Somfilter Evaluation", L"C:\\Som.Evaluate.log");
#endif

/******************************\
**** POLICY PROVIDER HELPERS ***
\******************************/

#define SOM_RDN L"CN=SOM,CN=WMIPolicy,CN=System"

// returns addref'd pointer back to WinMgmt
CComPtr<IWbemServices>& CPolicyStatus::GetWMIServices()
{
  CInCritSec lock(&m_CS);

  return m_pWMIMgmt;
}

IADsContainer *CPolicyStatus::GetADServices(wchar_t *pDomain, HRESULT &hres)
{
  CInCritSec lock(&m_CS);
  IADsContainer *pADsContainer = NULL;

  QString
    SomDN(SOM_RDN),
    DistDomainName,
    ObjPath(L"LDAP://");

  if(NULL == pDomain) return NULL;

  hres = DistNameFromDomainName(QString(pDomain), DistDomainName);

  ObjPath << DistDomainName;

  hres = ADsGetObject(ObjPath, IID_IADsContainer, (void**) &pADsContainer);

  return pADsContainer;
}

IADsContainer *GetADSchemaContainer(wchar_t *pDomain, HRESULT &hres)
{
  CComQIPtr<IADs>
    pRootDSE;

  CComVariant
    vSchemaPath;

  CComBSTR
    bstrSchemaPath(L"LDAP://");

  IADsContainer
    *pADsContainer = NULL;

  if(NULL == pDomain) return NULL;

  hres = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void **)&pRootDSE);
  if(FAILED(hres)) return NULL;

  hres = pRootDSE->Get(L"schemaNamingContext", &vSchemaPath);
  if(FAILED(hres)) return NULL;

  bstrSchemaPath.Append(vSchemaPath.bstrVal);

  hres = ADsGetObject(bstrSchemaPath, IID_IADsContainer, (void **)&pADsContainer);
  if(FAILED(hres)) return NULL;

  return pADsContainer;
}

// returns false if services pointer has already been set
bool CPolicyStatus::SetWMIServices(IWbemServices* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull = FALSE;

  if (bOldOneNull = (m_pWMIMgmt == NULL))
  {
    m_pWMIMgmt = pServices;
  }

  return bOldOneNull;
}

void* CPolicyStatus::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}

/*********************************\
***  Specific Implementation ***
\*********************************/

// returns addref'd pointer to class object
IWbemClassObject* CPolicyStatus::GetStatusClass()
{
    CInCritSec lock(&m_CS);

    if (m_pStatusClassObject == NULL)
    {
        CComPtr<IWbemServices> pWinMgmt = GetWMIServices();

        if (pWinMgmt != NULL)
        {
            pWinMgmt->GetObject(STATUS_CLASS, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &m_pStatusClassObject, NULL);
        }
    }

    return m_pStatusClassObject;
}

// returns addref'd pointer to emply class instance
IWbemClassObject* CPolicyStatus::GetStatusInstance()
{
    CComPtr<IWbemClassObject> pClass;
    IWbemClassObject *pObj = NULL;

    pClass = GetStatusClass();

    if(pClass != NULL)
        pClass->SpawnInstance(0, &pObj);

    return pObj;
}

/*************************\
***  IWbemProviderInit  ***
\*************************/

STDMETHODIMP CPolicyStatus::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices* pServices, IWbemContext* pCtxt, 
            IWbemProviderInitSink* pSink)
{
  HRESULT
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    return WBEM_S_ACCESS_DENIED;
  }
  else
  {
    // **** save WMI name space pointer

    m_pObject->SetWMIServices(pServices);
  }

  hres2 = pSink->SetStatus(hres, 0);
  if(FAILED(hres2))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
    if(SUCCEEDED(hres)) hres = hres2;
  }

  return hres;
}

/*******************\
*** IWbemServices ***
\*******************/

STDMETHODIMP CPolicyStatus::XProvider::GetObjectAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
   hres = WBEM_S_NO_ERROR,
   hres2 = WBEM_S_NO_ERROR;

  CComPtr<IWbemServices>
    pNamespace;

  CComPtr<IADsContainer>
    pADsSchemaContainer,
    pADsContainer;

  VARIANT
    *vDomain;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** Check arguments

    if(ObjectPath == NULL || pResponseHandler == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object path and/or return object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      ParsedObjectPath
        *pParsedObjectPath = NULL;

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         (0 != _wcsicmp(STATUS_CLASS, pParsedObjectPath->m_pClass)) ||
         (1 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        int x;

        for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
        {
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
            vDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
        }

        if(vDomain->bstrVal == NULL)
          hres = WBEM_E_FAILED;
        else
        {
          pNamespace = m_pObject->GetWMIServices();
          pADsContainer.Attach(m_pObject->GetADServices(vDomain->bstrVal, hres));
          pADsSchemaContainer.Attach(GetADSchemaContainer(vDomain->bstrVal, hres));
        }

        if((FAILED(hres)) || (pNamespace == NULL) || (pADsContainer == NULL))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: WMI and/or AD services not initialized\n"));
          hres = ADSIToWMIErrorCodes(hres);
        }
        else
        {
          try
          {
            CComPtr<IWbemClassObject>
              pStatusObj;

            CComQIPtr<IDispatch, &IID_IDispatch>
              pDisp1, pDisp2;

            CComQIPtr<IDirectoryObject, &IID_IDirectoryObject>
              pDirectoryObj;

            VARIANT
              vContainerPresent = {VT_BOOL, 0, 0, 0},
              vSchemaPresent = {VT_BOOL, 0, 0, 0};

            pStatusObj.Attach(m_pObject->GetStatusInstance());

            if(pStatusObj != NULL)
            {
              // **** test for existence of containers

              hres = pADsContainer->GetObject(L"Container", L"CN=SOM,CN=WMIPolicy,CN=System", &pDisp1);
              if(SUCCEEDED(hres) && (pDisp1.p != NULL)) vContainerPresent.boolVal = -1;

              // **** test for existence of schema object

              hres = pADsSchemaContainer->GetObject(L"classSchema", L"CN=ms-WMI-Som", &pDisp2);
              if(SUCCEEDED(hres) && (pDisp2.p != NULL)) vSchemaPresent.boolVal = -1;

              // **** build status object

              hres = pStatusObj->Put(L"Domain", 0, vDomain, 0);
              hres = pStatusObj->Put(L"ContainerAvailable", 0, &vContainerPresent, 0);
              hres = pStatusObj->Put(L"SchemaAvailable", 0, &vSchemaPresent, 0);

              hres = pResponseHandler->Indicate(1, &pStatusObj);
            }
            else
              hres = WBEM_E_FAILED;
          }
          catch(long hret)
          {
            hres = ADSIToWMIErrorCodes(hret);
            ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
          }
          catch(wchar_t *swErrString)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
            hres = WBEM_E_FAILED;
          }
          catch(...)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught UNKNOWN Exception\n"));
            hres = WBEM_E_FAILED;
          }
        }
      }

      ObjPath.Free(pParsedObjectPath);
      hres2 = pResponseHandler->SetStatus(0,hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policsom.h ===
#ifndef __WBEM_POLICY_SOM__H_
#define __WBEM_POLICY_SOM__H_

class CPolicySOM : public CUnk
{
public:
enum
{
  AD_LOCAL_CONTEXT = 0,
  AD_GLOBAL_CONTEXT,
  AD_MAX_CONTEXT
};

    CPolicySOM(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this),
        m_pWMIMgmt(NULL)
    {
        m_pADMgmt[AD_LOCAL_CONTEXT] = NULL;
        m_pADMgmt[AD_GLOBAL_CONTEXT] = NULL;
    }
    
	~CPolicySOM();

    void* GetInterface(REFIID riid);

  IWbemServices* GetWMIServices();
  IADsContainer* GetADServices(wchar_t *pADDomain, HRESULT &hres);
  bool SetWMIServices(IWbemServices* pServices);
  bool SetADServices(IADsContainer* ,unsigned);

protected:
    class XProvider : public CImpl<IWbemServices, CPolicySOM>
    {
    public:
        /* construction & de- */

        XProvider(CPolicySOM* pObj)
            : CImpl<IWbemServices, CPolicySOM>(pObj), m_pSOMClassObject(NULL), m_pLocator(NULL)
		{ /* this page intentionally left blank */ }

        ~XProvider();
		
        /* Internals */

    protected:
        /* Method support */
        HRESULT Evaluate(IWbemClassObject* pObj, IWbemClassObject* pOutInstance);
        HRESULT BatchEvaluate(IWbemClassObject* pObj, IWbemClassObject* pOutClass, IWbemServices* pPolicyNamespace);
		HRESULT EvaluateRule(IWbemServices*& pNamespace, BSTR& namespaceName, IWbemClassObject* pRule, bool& bResult);

        /* class object management */
        IWbemClassObject* GetSomClass();
        IWbemClassObject* GetSomInstance();

		/* communication w/ winmgmt management */
		HRESULT GetLocator(IWbemLocator*& pLocator);
		HRESULT GetNewNamespace(BSTR namespaceName, IWbemServices*& pNamespace);

        HRESULT ValidateRules(IWbemClassObject* pInst, IWbemClassObject*& pErrorObject);


    private:
       	// templates for each type of object we support
    	// NULL until we need it
	    IWbemClassObject* m_pSOMClassObject;

		// NULL until we need it -
		// access through GetLocator;
		IWbemLocator* m_pLocator;

        /* IWbemServices */
    public:

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) 
			{return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CPolicySOM>
    {
    public:
        XInit(CPolicySOM* pObj)
            : CImpl<IWbemProviderInit, CPolicySOM>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;

private:

    // pointer back to win management
    IWbemServices* m_pWMIMgmt; 

    // pointer to AD policy template table
    IADsContainer* m_pADMgmt[AD_MAX_CONTEXT];

  CComVariant
    m_vDsConfigContext,
    m_vDsLocalContext;

    // a little something to keep our threads from getting tangled
    // will use a single critical section to protect all instance variables
    CCritSec m_CS;   
};


#endif // __WBEM_POLICY_SOM__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policstatus.h ===
#ifndef __WBEM_POLICY_STATUS__H_
#define __WBEM_POLICY_STATUS__H_

#define STATUS_CLASS L"MSFT_SomFilterStatus"

class CPolicyStatus : public CUnk
{
public:

    CPolicyStatus(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this),
        m_pWMIMgmt(NULL) { }
    
	~CPolicyStatus() {};

    void* GetInterface(REFIID riid);

  CComPtr<IWbemServices>& GetWMIServices();
  IADsContainer* GetADServices(wchar_t *pADDomain, HRESULT &hres);
  bool SetWMIServices(IWbemServices* pServices);

  IWbemClassObject* GetStatusClass(void);
  IWbemClassObject* GetStatusInstance(void);

protected:
    class XProvider : public CImpl<IWbemServices, CPolicyStatus>
    {
    public:
        /* construction & de- */

        XProvider(CPolicyStatus* pObj) 
            : CImpl<IWbemServices, CPolicyStatus>(pObj) 
        { /* this page intentionally left blank */ }

        ~XProvider() {};
		
    private:
        // NULL until we need it -
        // access through GetLocator;

        CComPtr<IWbemLocator> 
          m_pLocator;

        /* IWbemServices */
    public:

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) 
			{return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};

    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CPolicyStatus>
    {
    public:
        XInit(CPolicyStatus* pObj)
            : CImpl<IWbemProviderInit, CPolicyStatus>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;

private:

    // templates for each type of object we support
    // NULL until we need it

    CComPtr<IWbemClassObject>
      m_pStatusClassObject;

    // pointer back to win management
    CComPtr<IWbemServices> m_pWMIMgmt; 

  CComVariant
    m_vDsLocalContext;

    // a little something to keep our threads from getting tangled
    // will use a single critical section to protect all instance variables
    CCritSec m_CS;   
};


#endif // __WBEM_POLICY_STATUS__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\polictempl.cpp ===
#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <atlbase.h>
#include <sync.h>
#include <ql.h>
#include "activeds.h"
#include "genlex.h"
#include "objpath.h"
#include "Utility.h" 

#include "polictempl.h"

/******************************\
**** POLICY PROVIDER HELPERS ***
\******************************/

#define TEMPLATE_RDN L"CN=PolicyTemplate,CN=WMIPolicy,CN=System"

// returns addref'd pointer back to m_pWMIMgmt
IWbemServices* CPolicyTemplate::GetWMIServices(void)
{
  CInCritSec lock(&m_CS);

  if (NULL != m_pWMIMgmt)
    m_pWMIMgmt->AddRef();

  return m_pWMIMgmt;
}

// returns addref'd pointer back to m_pADMgmt
IADsContainer *CPolicyTemplate::GetADServices(wchar_t *pDomain)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [PolicyTemplate] GetADServices (%S)\n", pDomain));

  CInCritSec lock(&m_CS);
  IADsContainer *pADsContainer = NULL;
  HRESULT hres;

  QString
    DistDomainName;

  if(NULL == pDomain)
    DistDomainName = m_vDsLocalContext.bstrVal;
  else
    hres = DistNameFromDomainName(QString(pDomain), DistDomainName);

  hres = ADsGetObject(QString(L"LDAP://") << TEMPLATE_RDN << L"," << DistDomainName, 
                      IID_IADsContainer, 
                      (void**) &pADsContainer);

  if(NULL == pADsContainer)
    pADsContainer = CreateContainers(DistDomainName, QString(TEMPLATE_RDN));

  return pADsContainer;
}

// returns false if services pointer has already been set
bool CPolicyTemplate::SetWMIServices(IWbemServices* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull = FALSE; 

  if (bOldOneNull = (m_pWMIMgmt == NULL))
  {
    m_pWMIMgmt = pServices;
    if(pServices) pServices->AddRef();
  }

  return bOldOneNull;
}

// returns false if services pointer has already been set
bool CPolicyTemplate::SetADServices(IADsContainer* pServices, unsigned context)
{
  CInCritSec lock(&m_CS);
  bool 
    bOldOneNull = TRUE;

  switch(context)
  {
    case AD_LOCAL_CONTEXT :
    case AD_GLOBAL_CONTEXT :
      m_pADMgmt[context] = pServices;
      pServices->AddRef();
      bOldOneNull = (m_pADMgmt[context] == NULL);
      break;

    default : ;
  }

  return bOldOneNull;
}

CPolicyTemplate::~CPolicyTemplate()
{
  // **** WMI services object

  if (NULL != m_pWMIMgmt)
  {
    m_pWMIMgmt->Release();
    m_pWMIMgmt= NULL;
  }

  // **** AD services object

  if (NULL != m_pADMgmt)
  {
    for(int i = 0; i < AD_MAX_CONTEXT; i++)
    {
      if(NULL != m_pADMgmt[i]) 
      {
        m_pADMgmt[i]->Release();
        m_pADMgmt[i] = NULL;
      }
    }
  }
};

void* CPolicyTemplate::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}

/*********************************************\
*** Policy Template Specific Implementation ***
\*********************************************/

// returns addref'd pointer to class object
IWbemClassObject* CPolicyTemplate::XProvider::GetPolicyTemplateClass()
{
  CInCritSec lock(&m_pObject->m_CS);

  if(NULL == m_pWMIPolicyClassObject)
  {
    IWbemServices* pWinMgmt = NULL;

    if(pWinMgmt = m_pObject->GetWMIServices())
    {
      CReleaseMe relMgmt(pWinMgmt);
      pWinMgmt->GetObject(g_bstrClassMergeablePolicy, 
                          WBEM_FLAG_RETURN_WBEM_COMPLETE, 
                          NULL, 
                          &m_pWMIPolicyClassObject, 
                          NULL);
    }
  }

  if (m_pWMIPolicyClassObject)
    m_pWMIPolicyClassObject->AddRef();

  return m_pWMIPolicyClassObject;
}

// returns addref'd pointer to emply class instance
IWbemClassObject* CPolicyTemplate::XProvider::GetPolicyTemplateInstance()
{
  IWbemClassObject* pObj = NULL;
  IWbemClassObject* pClass = NULL;

  if (pClass = GetPolicyTemplateClass())
  {
    CReleaseMe releaseClass(pClass);
    pClass->SpawnInstance(0, &pObj);
  }

  return pObj;
}


CPolicyTemplate::XProvider::~XProvider()
{
// I fixed it! - HMH  ;-)  
// CInCritSec lock(&m_pObject->m_CS);

  if(NULL != m_pWMIPolicyClassObject)
  {
    m_pWMIPolicyClassObject->Release();
    m_pWMIPolicyClassObject = NULL;
  }
}

/*************************\
***  IWbemProviderInit  ***
\*************************/

STDMETHODIMP CPolicyTemplate::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices* pServices, IWbemContext* pCtxt, 
            IWbemProviderInitSink* pSink)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [PolicyTemplate] IWbemProviderInit::Initialize\n"));

  CComPtr<IADs>
    pRootDSE;

  CComPtr<IADsContainer>
    pObject;

  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    hres = WBEM_S_ACCESS_DENIED;
  }
  else
  {
    // **** safe WMI name space pointer

    m_pObject->SetWMIServices(pServices);
	
    // **** get pointer to AD policy template table

    hres = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pRootDSE);
    if (FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not get object: LDAP://rootDSE, 0x%08X\n", hres));
      hres = WBEM_E_NOT_FOUND;
    }
    else
    {
      hres = pRootDSE->Get(L"defaultNamingContext",&m_pObject->m_vDsLocalContext);
      if(FAILED(hres))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: (IADs::Get) could not get defaultNamingContext, 0x%08X\n", hres));
        hres = WBEM_E_NOT_FOUND;
      }
    }
  }
  
  hres2 = pSink->SetStatus(hres, 0);
  if(FAILED(hres2))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
    if(SUCCEEDED(hres)) hres = hres2;
  }

  return hres;
}

/*******************\
*** IWbemServices ***
\*******************/

STDMETHODIMP CPolicyTemplate::XProvider::GetObjectAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponse)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [PolicyTemplate] IWbemServices::GetObjectAsync(%S, 0x%x, 0x%x, 0x%x)\n", ObjectPath, lFlags, pCtx, pResponse));

  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  VARIANT
    *pvDomain = NULL,
    *pvkeyID = NULL;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IWbemClassObject>
    pObj;

  CComPtr<IDirectoryObject>
    pDirObj;

  CComPtr<IWbemServices>
    pNamespace;

  CComPtr<IADsContainer>
    pADsContainer;

  // **** impersonate client

  hres = CoImpersonateClient();
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    pNamespace = m_pObject->GetWMIServices();

    if(pNamespace == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: WMI services not initialized\n"));
      hres = WBEM_E_NOT_FOUND;
    }
    else
    {
      // **** Check arguments

      if(ObjectPath == NULL || pResponse == NULL)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: object path and/or return object are NULL\n"));
        hres = WBEM_E_INVALID_PARAMETER;
      }
      else
      {
        // **** parse object path

        CObjectPathParser
          ObjPath(e_ParserAcceptRelativeNamespace);

        ParsedObjectPath
          *pParsedObjectPath = NULL;

        if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
           ((0 != _wcsicmp(g_bstrClassMergeablePolicy, pParsedObjectPath->m_pClass)) &&
            (0 != _wcsicmp(g_bstrClassSimplePolicy, pParsedObjectPath->m_pClass))) ||
           (2 != pParsedObjectPath->m_dwNumKeys))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
          hres = WBEM_E_INVALID_QUERY;
        }
        else
        {
          int x;
 
          // **** only grab ID key for now

          for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
          {
            if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrID))
              pvkeyID = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
            else if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
              pvDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
          }

          try
          {
            pADsContainer = m_pObject->GetADServices(pvDomain->bstrVal);
            if(pADsContainer == NULL) 
            {
              ERRORTRACE((LOG_ESS, "POLICMAN: Could not find domain: %S\n", V_BSTR(pvDomain)));
              return WBEM_E_ACCESS_DENIED;
            }

            // **** Get pointer to instance in AD

            hres = pADsContainer->GetObject(NULL, QString(L"CN=") << V_BSTR(pvkeyID), &pDisp);
            if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

            hres = pDisp->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
            if(FAILED(hres)) return hres;

            // **** HACK **** do quick check to see if object is of correct type

            {
              CComVariant
                vObjType;

              CComQIPtr<IADs, &IID_IADs>
                pADsObj = pDirObj;

              hres2 = pADsObj->Get(g_bstrADNormalizedClass, &vObjType);
              if(FAILED(hres2)) return hres2;

              if(_wcsicmp(vObjType.bstrVal, pParsedObjectPath->m_pClass))
                return WBEM_E_NOT_FOUND;
            }
              
            // **** Get the instance and send it back

            hres = Policy_ADToCIM(&pObj, pDirObj, pNamespace);
            if(pObj == NULL) return WBEM_E_FAILED;

            // **** Set object

            pResponse->Indicate(1, &pObj);
          }
          catch(long hret)
          {
            hres = ADSIToWMIErrorCodes(hret);
            ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
          }
          catch(wchar_t *swErrString)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
            hres = WBEM_E_FAILED;
          }
          catch(...)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
            hres = WBEM_E_FAILED;
          }
        }

        ObjPath.Free(pParsedObjectPath);
        hres2 = pResponse->SetStatus(0,hres, NULL, NULL);
        if(FAILED(hres2))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
          if(SUCCEEDED(hres)) hres = hres2;
        }
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicyTemplate::XProvider::CreateInstanceEnumAsync(/* [in] */ const BSTR Class,
                                                                 /* [in] */ long lFlags,
                                                                 /* [in] */ IWbemContext __RPC_FAR *pCtx,
                                                                 /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

STDMETHODIMP CPolicyTemplate::XProvider::PutInstanceAsync( 
  /* [in] */ IWbemClassObject __RPC_FAR *pInst,
  /* [in] */ long lFlags,
  /* [in] */ IWbemContext __RPC_FAR *pCtx,
  /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [PolicyTemplate] IWbemServices::PutInstanceAsync(0x%x, 0x%x, 0x%x, 0x%x)\n", pInst, lFlags, pCtx, pResponseHandler));

  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDirectoryObject>
    pDirObj;

  CComVariant
    v1, vRelPath;

  // **** impersonate client

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** check arguments 

    if((NULL == pInst) || (NULL == pResponseHandler))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object handle and/or return status object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** put policy obj into AD

      try
      {
        EnsureID(pInst, NULL);
          
        // **** aquire AD path in which to place object

        hres = pInst->Get(g_bstrDomain, 0, &v1, NULL, NULL);
        if(FAILED(hres)) return hres;

        if(VT_BSTR == v1.vt)
          pADsContainer = m_pObject->GetADServices(v1.bstrVal);
        else
          pADsContainer = m_pObject->GetADServices(NULL);

        if(pADsContainer == NULL)
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Could not find or connect to domain: %S\n", V_BSTR(&v1)));
          return WBEM_E_ACCESS_DENIED;
        }

        hres = pADsContainer->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
        if(FAILED(hres)) return hres;

        // **** copy policy obj into AD
  
        hres = Policy_CIMToAD(lFlags, pInst, pDirObj);
        if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
      }
      catch(long hret)
      {
        hres = ADSIToWMIErrorCodes(hret);
        ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from WMI to AD generated HRESULT 0x%08X\n", hres));
      }
      catch(wchar_t *swErrString)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
        hres = WBEM_E_FAILED;
      }
      catch(...)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
        hres = WBEM_E_FAILED;
      }

      // **** send it back as we may have added keys
      if (SUCCEEDED(hres))
          pResponseHandler->Indicate(1, &pInst);

      // **** indicate return status

      pInst->Get(L"__RELPATH", 0, &vRelPath, NULL, NULL);
      if(FAILED(pResponseHandler->SetStatus(0, hres, V_BSTR(&vRelPath), NULL)))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicyTemplate::XProvider::DeleteInstanceAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [PolicyTemplate] IWbemServices::DeleteInstanceAsync(%S, 0x%x, 0x%x, 0x%x)\n", ObjectPath, lFlags, pCtx, pResponseHandler));

  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IADsDeleteOps>
    pDelObj;

  VARIANT
    *pvDomain = NULL,
    *pvkeyID = NULL;

  ParsedObjectPath
    *pParsedObjectPath = NULL;

  // **** impersonate client

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** check arguments

    if((ObjectPath == NULL) || (pResponseHandler == NULL))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object handle and/or return status object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse WMI object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         ((0 != _wcsicmp(g_bstrClassMergeablePolicy, pParsedObjectPath->m_pClass)) &&
          (0 != _wcsicmp(g_bstrClassSimplePolicy, pParsedObjectPath->m_pClass))) ||
         (2 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        int x;

        // **** only grab ID key for now

        for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
        {
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrID))
            pvkeyID = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
          else if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
            pvDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
        }

        pADsContainer = m_pObject->GetADServices(pvDomain->bstrVal);
        if(pADsContainer == NULL)
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Could not find domain: %S\n", V_BSTR(pvDomain)));;
          hres = WBEM_E_ACCESS_DENIED;
        }
        else
        {
          // **** Get pointer to instance in AD

          BSTR pADClassName;
          if(0 == _wcsicmp(g_bstrClassMergeablePolicy, pParsedObjectPath->m_pClass))
            pADClassName = g_bstrADClassMergeablePolicy;
          else if(0 == _wcsicmp(g_bstrClassSimplePolicy, pParsedObjectPath->m_pClass))
            pADClassName = g_bstrADClassSimplePolicy;

          hres = pADsContainer->GetObject(NULL, QString(L"CN=") << V_BSTR(pvkeyID), &pDisp);
          if(FAILED(hres))
          {
            hres = ADSIToWMIErrorCodes(hres);
            ERRORTRACE((LOG_ESS, "POLICMAN: (IADsContainer::GetObject) could not get object in AD %S, 0x%08X\n", V_BSTR(pvkeyID), hres));
          }
          else
          {
            hres = pDisp->QueryInterface(IID_IADsDeleteOps, (void **)&pDelObj);
            if(FAILED(hres))
            {
              ERRORTRACE((LOG_ESS, "POLICMAN: (IDispatch::QueryInterface) could not get IID_IADsDeleteOps interface on object\n"));
            }
            else
            {
              // **** delete the instance and all its children in AD

              hres = pDelObj->DeleteObject(0);
              if(FAILED(hres))
              {
                hres = ADSIToWMIErrorCodes(hres);
                ERRORTRACE((LOG_ESS, "POLICMAN: (IADsDeleteOps::DeleteObject) could not delete object\n"));
              }
            }
          }
        }

        ObjPath.Free(pParsedObjectPath);
      }

      // **** Set Status

      hres2 = pResponseHandler->SetStatus(0,hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

HRESULT GetADContainerInDomain(wchar_t *wcsDomain, wchar_t *wcsPath, IDirectorySearch **pObj);

STDMETHODIMP CPolicyTemplate::XProvider::ExecQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  DEBUGTRACE((LOG_ESS, "POLICMAN: [PolicyTemplate] IWbemServices::ExecQueryAsync(%S, %S, 0x%x, 0x%x, 0x%x)\n", QueryLanguage, Query, lFlags, pCtx, pResponseHandler));

  HRESULT
    hres = WBEM_E_FAILED;

  CComPtr<IWbemServices>
    pNameSpace = m_pObject->GetWMIServices();

  QL_LEVEL_1_TOKEN
    *pToken = NULL;

  CComPtr<IDirectorySearch>
    pDirectorySearch;

  QString
    LDAPQuery;

  wchar_t
    objPath[1024];

  ADS_SEARCH_HANDLE
    searchHandle;

  ADS_SEARCH_COLUMN
    searchColumn;

  wchar_t
    *pszDistName[] = { L"distinguishedName" };

  // ****  parse WQL expression

  CTextLexSource
    src(Query);

  QL1_Parser
    parser(&src);

  QL_LEVEL_1_RPN_EXPRESSION
    *pExp = NULL;

  AutoDelete<QL_LEVEL_1_RPN_EXPRESSION>
    AutoExp(&pExp);

  int
    nRes;

  if(nRes = parser.Parse(&pExp))
    return WBEM_E_INVALID_QUERY;

  // **** find domain attribute

  for(int iToken = 0; (iToken < pExp->nNumTokens) && (NULL == pToken); iToken++)
  {
    pToken = &pExp->pArrayOfTokens[iToken];

    if(_wcsicmp(g_bstrDomain, pToken->PropertyName.GetStringAt(pToken->PropertyName.GetNumElements() - 1)))
      pToken = NULL;
  }

  if(NULL == pToken)
  {
    if(pResponseHandler != NULL)
      hres = pResponseHandler->SetStatus(0, WBEMESS_E_REGISTRATION_TOO_BROAD, 0, 0);

    return WBEMESS_E_REGISTRATION_TOO_BROAD;
  }

  if((QL_LEVEL_1_TOKEN::OP_EXPRESSION != pToken->nTokenType) ||
     (QL_LEVEL_1_TOKEN::OP_EQUAL != pToken->nOperator) ||
     (TRUE == pToken->m_bPropComp) ||
     (VT_BSTR != pToken->vConstValue.vt))
    return WBEM_E_INVALID_QUERY;

  // **** connect to LDAP location

  hres = GetADContainerInDomain(pToken->vConstValue.bstrVal, TEMPLATE_RDN, &pDirectorySearch);
  if(FAILED(hres) || (pDirectorySearch == NULL))
    return WBEM_E_ACCESS_DENIED;

  // **** build LDAP query to execute on container pADs

  if(0 == _wcsicmp(g_bstrClassMergeablePolicy, pExp->bsClassName))
    LDAPQuery << L"(|(objectCategory=msWMI-MergeablePolicyTemplate)(&(objectCategory=msWMI-SimplePolicyTemplate)(msWMI-NormalizedClass=msWMI-MergeablePolicyTemplate)))";
  else
    LDAPQuery << L"(&(objectCategory=msWMI-SimplePolicyTemplate)(|(msWMI-NormalizedClass=msWMI-SimplePolicyTemplate)(msWMI-NormalizedClass=MSFT_MergeablePolicyTemplate)))";

  // **** set search preferences

  ADS_SEARCHPREF_INFO
    SearchPreferences[1];

  SearchPreferences[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  SearchPreferences[0].vValue.dwType = ADSTYPE_INTEGER;
  SearchPreferences[0].vValue.Integer = 1000;

  hres = pDirectorySearch->SetSearchPreference(SearchPreferences, 1);

  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Could not set search preferences, returned error: 0x%08X\n", (LPWSTR)LDAPQuery, hres));
    return WBEM_E_FAILED;
  }

  // **** execute query

  hres = pDirectorySearch->ExecuteSearch(LDAPQuery, pszDistName, 1, &searchHandle);

  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Could execute query: (%s) returned error: 0x%08X\n", (LPWSTR)LDAPQuery, hres));
    return WBEM_E_FAILED;
  }

  // **** build result list

  try
  {
    while(SUCCEEDED(hres = pDirectorySearch->GetNextRow(searchHandle)) && (S_ADS_NOMORE_ROWS != hres))
    {
      CComPtr<IDirectoryObject>
        pDirectoryObject;

      CComPtr<IWbemClassObject>
        pWbemClassObject;

      // **** get path to object

      hres = pDirectorySearch->GetColumn(searchHandle, pszDistName[0], &searchColumn);
      if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

      // **** get pointer to object

      wcscpy(objPath, L"LDAP://");
      wcscat(objPath, searchColumn.pADsValues->CaseIgnoreString);
      pDirectorySearch->FreeColumn(&searchColumn);


      hres = ADsGetObject(objPath, IID_IDirectoryObject, (void **)&pDirectoryObject);
      if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

      hres = Policy_ADToCIM(&pWbemClassObject, pDirectoryObject, pNameSpace);
      if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
      if(pWbemClassObject == NULL) return WBEM_E_FAILED;

      hres = pResponseHandler->Indicate(1, &pWbemClassObject);
    }
  }
  catch(long hret)
  {
    hres = ADSIToWMIErrorCodes(hret);
    ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
  }
  catch(wchar_t *swErrString)
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
    hres = WBEM_E_FAILED;
  }
  catch(...)
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
    hres = WBEM_E_FAILED;
  }

  hres = pDirectorySearch->CloseSearchHandle(searchHandle);

  if(pResponseHandler != NULL)
    hres = pResponseHandler->SetStatus(0, hres, 0, 0);

  return hres;
}

//TODO: clean up bstrs & variants upon raising an exception (maybe theres a CVariantClearMe or some such?)
HRESULT CPolicyTemplate::XProvider::ResolveMergeable(IWbemClassObject* pResolveMe, 
													 IWbemClassObject* pClassDef,
                                                     IWbemServices* pPolicyNamespace,
                                                     IWbemContext __RPC_FAR* pCtx, 
                                                     IWbemClassObject __RPC_FAR* pOutParams, 
                                                     IWbemObjectSink __RPC_FAR* pResponseHandler)
{
    HRESULT hr = WBEM_E_FAILED;
    DEBUGTRACE((LOG_ESS, "POLICMAN: CPolicyTemplate::ResolveMergeable\n"));
    
    // instanciate instance of target class (pClassDef)
    // loop through all range params & place each in out obj

    CComVariant
      vTable,
      vGazinta;

	CComPtr<IWbemClassObject>
		pTargetInstance,
		pRangeParamClass,       // class object for range param & in & out params to RangeParam::Resolve
		pResolveParamClass,
		pResolveParamIn,
		pResolveParamOut;

    if (SUCCEEDED(hr = pClassDef->SpawnInstance(0, &pTargetInstance)) &&

        // **** get MSFT_RangeParam::Resolve() input parameter object

        SUCCEEDED(hr = pPolicyNamespace->GetObject(L"MSFT_RangeParam", 0, pCtx, &pRangeParamClass, NULL)) &&
        SUCCEEDED(hr = pRangeParamClass->GetMethod(L"Resolve", 0, &pResolveParamClass, NULL)) &&
        SUCCEEDED(hr = pResolveParamClass->SpawnInstance(0, &pResolveParamIn))
        )
    {
        // **** set keys from object path

        CComVariant
          vTargetPath;

        if(SUCCEEDED(hr = pResolveMe->Get(g_bstrTargetPath, 0, &vTargetPath, NULL, NULL)))
        {
          CObjectPathParser
            ObjPath(e_ParserAcceptRelativeNamespace);

          ParsedObjectPath
            *pParsedObjectPath = NULL;

          if(ObjPath.NoError != ObjPath.Parse(vTargetPath.bstrVal, &pParsedObjectPath))
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", vTargetPath.bstrVal));
            return WBEM_E_INVALID_OBJECT_PATH;
          }
          else
          {
            for(int x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
            {
              if((NULL != (*(pParsedObjectPath->m_paKeys + x))->m_pName) && 
                 ((*(pParsedObjectPath->m_paKeys + x))->m_vValue.vt != VT_NULL))
              {
                CComVariant
                  vCurVal;

                hr = pTargetInstance->Get((*(pParsedObjectPath->m_paKeys + x))->m_pName, 0, &vCurVal, NULL, NULL);
                if(FAILED(hr))
                {
                  if(WBEM_E_NOT_FOUND == hr)
                    ERRORTRACE((LOG_ESS, "POLICMAN: Policy key setting %S not in target object\n", (*(pParsedObjectPath->m_paKeys + x))->m_pName));

                  return hr;
                }

                if(vCurVal.vt != VT_NULL)
                {
                  ERRORTRACE((LOG_ESS, "POLICMAN: Attempt to set policy key setting %S more than once\n", (*(pParsedObjectPath->m_paKeys + x))->m_pName));
                  return WBEM_E_FAILED;
                }

                hr = pTargetInstance->Put((*(pParsedObjectPath->m_paKeys + x))->m_pName, 0, 
                                        &((*(pParsedObjectPath->m_paKeys + x))->m_vValue), NULL);
                if(FAILED(hr)) return hr;
              }
            }
          }
        }

        // get the array of settings we're setting

        pResolveMe->Get(L"RangeSettings", 0, &vTable, NULL, NULL);

        SafeArray<IUnknown*, VT_UNKNOWN> 
          settings(&vTable);

        vGazinta = pTargetInstance;

        for (int i = 0; i < settings.Size(); i++)
        {
          CComVariant
            vSetting,
            vName;

          CComPtr<IWbemClassObject>
            pResolveParamOut,
            pRange;

          // **** an in/out param in WMI winds up being copied from the in to the out
          // **** so we need to put the new one in every time through the loop

          vSetting = settings[i];

          hr = pResolveParamIn->Put(L"obj", 0, &vGazinta, NULL);
          if(FAILED(hr)) return hr;

          hr = pResolveParamIn->Put(L"mergedRange", 0, &vSetting, NULL);
          if(FAILED(hr)) return hr;

          hr = vSetting.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pRange);
          if(FAILED(hr)) return hr;

          hr = pRange->Get(L"__CLASS", 0, &vName, NULL, NULL);
          if(FAILED(hr)) return hr;

          hr = pPolicyNamespace->ExecMethod(vName.bstrVal, L"Resolve", 0, pCtx, pResolveParamIn, &pResolveParamOut, NULL);
          if(FAILED(hr)) return hr;
           
          hr = pResolveParamOut->Get(L"obj",0, &vGazinta, NULL, NULL);
          if(FAILED(hr)) return hr;
        }

        // <whew> at this point, our new, improved & merge-ified object is held inside the vGazinta variant
        pOutParams->Put(L"obj", 0, &vGazinta, NULL);
        hr = WBEM_S_NO_ERROR;
        pResponseHandler->Indicate(1, &pOutParams);
    }
    else
        ERRORTRACE((LOG_ESS, "POLICMAN: Failed to create target instance to resolve, 0x%08X\n", hr));    

    return hr;
}

// extract out class instance from PolicyTemplate in param
HRESULT CPolicyTemplate::XProvider::DoResolve(IWbemServices* pPolicyNamespace,
                                              IWbemContext __RPC_FAR *pCtx,
                                              IWbemClassObject __RPC_FAR *pInParams,
                                              IWbemClassObject __RPC_FAR *pOutParams,
                                              IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
    hr = WBEM_E_FAILED;

  DEBUGTRACE((LOG_ESS, "POLICMAN: CPolicyTemplate::DoResolve\n"));

  CComVariant
    vTemplate, vClass, vObj, vClassDef;

  CComPtr<IWbemClassObject>
    pResolveMe, pClassDef;      

  if(SUCCEEDED(hr = pInParams->Get(L"template", 0, &vTemplate, NULL, NULL)) &&
	 SUCCEEDED(hr = pInParams->Get(L"classObject", 0, &vClassDef, NULL, NULL)))
  {
    // **** the instance from which we'll pull our object

    if(SUCCEEDED(hr = vTemplate.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pResolveMe)) &&
	   SUCCEEDED(hr = vClassDef.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pClassDef)))
    {    
      // **** find out what, exactly we are.
      // **** we're either a simple policy template, a mergeable policy template
      // **** or we're derived from one of those.

      pResolveMe->Get(L"__CLASS", 0, &vClass, NULL, NULL);

      // **** simple case first

      if((_wcsicmp(L"MSFT_SimplePolicyTemplate", vClass.bstrVal) == 0) ||
         (pResolveMe->InheritsFrom(L"MSFT_SimplePolicyTemplate") == WBEM_S_NO_ERROR))
      {
        // **** this one's easy - what's in the input goes into the output

        if (SUCCEEDED(hr = pResolveMe->Get(L"TargetObject", 0, &vObj, NULL, NULL)))
        {
          hr = pOutParams->Put(L"obj", 0, &vObj, NULL);

          pResponseHandler->Indicate(1, &pOutParams);
        }
      }
      else if((_wcsicmp(L"MSFT_MergeablePolicyTemplate", vClass.bstrVal) == 0) ||
              (pResolveMe->InheritsFrom(L"MSFT_MergeablePolicyTemplate") == WBEM_S_NO_ERROR))
      {
        hr = ResolveMergeable(pResolveMe, pClassDef, pPolicyNamespace, pCtx, pOutParams, pResponseHandler);
      }
      else
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Invalid class passed to Resolve\n"));

        hr = WBEM_E_INVALID_PARAMETER;    
      }
    }
  }

  DEBUGTRACE((LOG_ESS, "POLICMAN: CPolicyTemplate::DoResolve returning 0x%08X\n", hr));


  return hr;
}

HRESULT CPolicyTemplate::XProvider::DoSet(IWbemClassObject* pInParams,
                                          IWbemClassObject* pOutParams, 
                                          IWbemClassObject* pClass,
                                          IWbemObjectSink*  pResponseHandler,
                                          IWbemServices*    pPolicyNamespace)
{
  HRESULT 
    hr = WBEM_S_NO_ERROR;

  CComVariant 
    v;
  
  CComPtr<IWbemClassObject> 
    pTemplate,
    pObj;

  if(SUCCEEDED(pInParams->Get(L"base",0,&v,NULL,NULL)) &&
    (v.vt == VT_UNKNOWN) &&
    (v.punkVal != NULL))
  {
    if (SUCCEEDED(hr = v.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pObj)))
    {
      if (SUCCEEDED(hr = pClass->SpawnInstance(0, &pTemplate)))
      {
        if (SUCCEEDED(pObj->Get(L"__CLASS", 0, &v, NULL, NULL)))
          pTemplate->Put(L"TargetClass", 0, &v, NULL);
        VariantClear(&v);

        if (SUCCEEDED(pObj->Get(L"__NAMESPACE", 0, &v, NULL, NULL)))
          pTemplate->Put(L"TargetNamespace", 0, &v, NULL);
        VariantClear(&v);
       
        if (SUCCEEDED(pObj->Get(L"__RELPATH", 0, &v, NULL, NULL)))
          pTemplate->Put(L"TargetPath", 0, &v, NULL);
        VariantClear(&v);

        // loop through properties, any that are not NULL
        // get set into the template object as range params
        pObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
      
        BSTR propName = NULL;

        while (SUCCEEDED(hr = pObj->Next(0, &propName, &v, NULL, NULL)) && (hr != WBEM_S_NO_MORE_DATA))
        {
          CSysFreeMe freeProp(propName);
        
          // TODO: tighten up error checking here!
          if (v.vt != VT_NULL)
            pObj->Put(propName, 0, &v, NULL);

          VariantClear(&v);
        }

        pObj->EndEnumeration();

        if (SUCCEEDED(hr))
        {
          v = (IUnknown*)pTemplate;

          if (SUCCEEDED(hr = pOutParams->Put(L"PolicyObj", 0, &v, NULL)))
            pResponseHandler->Indicate(1, &pOutParams);
        }
      }
    }
    VariantClear(&v);  
   
  }
  else
    hr = WBEM_E_INVALID_PARAMETER;

  return hr;
}

// get safearray out of variant
// if safearray doesn't exist, create it & stuff it into the variant
// in either case, the array you get back is a pointer to the array in the variant
HRESULT CPolicyTemplate::XProvider::GetArray(VARIANT& vArray, SAFEARRAY*& pArray)
{
  HRESULT hr = WBEM_S_NO_ERROR;

  if ((vArray.vt == (VT_UNKNOWN | VT_ARRAY))
    &&
    (vArray.parray != NULL))
    pArray = vArray.parray;
  else
  {
    VariantClear(&vArray);
    vArray.vt = (VT_UNKNOWN | VT_ARRAY);

    SAFEARRAYBOUND bounds = {0,0};
    vArray.parray = pArray = SafeArrayCreate(VT_UNKNOWN, 1, &bounds);

    if (!pArray)
      hr = WBEM_E_OUT_OF_MEMORY;
  }
  
  return hr;
}

// walk through array - if param of same name exists, replace, else add
// assumptions: pRange is instance of a MSFT_RangeParam & pArray is an array of range params.
HRESULT CPolicyTemplate::XProvider::SetSettingInOurArray(const WCHAR* pName, IWbemClassObject* pRange, SAFEARRAY* pArray)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    long bound;
    SafeArrayGetUBound(pArray, 1, &bound);    

    // walk through array looking for our goodie
    bool bFound = false;
    for (long i = 0; (i < bound) && !bFound; i++)
    {
        // get pointer
        IWbemClassObject* pOldRange = NULL;
        SafeArrayGetElement(pArray, &i, &pOldRange);
        CReleaseMe relOldRange(pOldRange);

        // get name
        VARIANT vName;
        VariantInit(&vName);
        pOldRange->Get(L"PropertyName", 0, &vName, NULL, NULL);

        // compare name; if same: do game
        if ((vName.bstrVal != NULL)
            &&
            (_wcsicmp(vName.bstrVal, pName) == 0))
        {
            hr = SafeArrayPutElement(pArray, &i, pRange);
            bFound = true;
        }
            
        VariantClear(&vName);
    }

    // okay, wasn't there, grow the array & set it at end
    if (!bFound)
    {
        SAFEARRAYBOUND b = {bound + 2, 0};
        if (SUCCEEDED(hr = SafeArrayRedim(pArray, &b)))
		{
			bound++;
			hr = SafeArrayPutElement(pArray, &bound, pRange);
		}
    }

    return hr;
}

// in the inparams there should be a rangeparam
// we'll walk through our array of range params, delete any that have the same name
// and stuff this new one in!
HRESULT CPolicyTemplate::XProvider::DoSetRange(IWbemClassObject* pInParams,
                                               IWbemClassObject* pOutParams, 
                                               IWbemObjectSink*  pResponseHandler)
{
    HRESULT hr = WBEM_E_FAILED;
    DEBUGTRACE((LOG_ESS, "POLICMAN: CPolicyTemplate::DoSetRange\n"));

    IWbemClassObject* pRange = NULL;
    IWbemClassObject* pThis = NULL;

    VARIANT vRange;
    VARIANT vThis;

    VariantInit(&vRange);
    VariantInit(&vThis);

    if (SUCCEEDED(hr = pInParams->Get(L"rangeSetting", 0, &vRange, NULL, NULL))
        &&
        (vRange.vt == VT_UNKNOWN)
        &&
        (vRange.punkVal != NULL)
        &&
        SUCCEEDED(hr = pInParams->Get(L"PolicyObj", 0, &vThis, NULL, NULL))
        &&
        (vThis.vt == VT_UNKNOWN)
        &&
        (vThis.punkVal != NULL)
        )
    {
        if (SUCCEEDED(hr = vThis.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pThis)))
        {
            CReleaseMe relThis(pThis);

            hr = vRange.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pRange);
            CReleaseMe relRange(pRange);
        
            VARIANT vName;
            VariantInit(&vName);

            if (SUCCEEDED(pRange->Get(L"PropertyName", 0, &vName, NULL, NULL))
                &&
                (vName.vt == VT_BSTR)
                &&
                (vName.bstrVal != NULL)
                &&
                (wcslen(vName.bstrVal) != 0)
                )
            {
                VARIANT vArray;
                VariantInit(&vArray);

                SAFEARRAY* pArray = NULL;

                // get current state of range settings
                if (SUCCEEDED(hr = pThis->Get(L"RangeSettings", 0, &vArray, NULL, NULL))
                    &&
                    SUCCEEDED(hr = GetArray(vArray, pArray)))
                {
                    // walk through pArray
                    if (SUCCEEDED(hr = SetSettingInOurArray(vName.bstrVal, pRange, pArray)))
                    {
                        hr = pThis->Put(L"RangeSettings", 0, &vArray, NULL);
                        hr = pOutParams->Put(L"PolicyObj", 0, &vThis, NULL);
                        
						pResponseHandler->Indicate(1, &pOutParams);
                    }

                }
                VariantClear(&vArray);
                VariantClear(&vName);
            }
            else
                hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        DEBUGTRACE((LOG_ESS, "POLICMAN: failed to retrieve input parameters 0x%08X\n", hr));
        hr = WBEM_E_INVALID_PARAMETER;
    }

    VariantClear(&vThis);
    VariantClear(&vRange);

    return hr;
}


HRESULT CPolicyTemplate::XProvider::DoMerge(IWbemServices* pNamespace,
                                            const BSTR strObjectPath, 
                                            IWbemContext __RPC_FAR *pCtx,
                                            IWbemClassObject __RPC_FAR *pInParams,
                                            IWbemClassObject __RPC_FAR *pOutParams,
                                            IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
    hres = WBEM_E_FAILED;

  CComPtr<IUnknown>
    pUnk;

  CComPtr<IWbemClassObject> 
    pOutResult;

  ParsedObjectPath
    *pParsedObjectPath = NULL;

  CComVariant
    v1;

  // **** parse object path

  CObjectPathParser
    ObjPath(e_ParserAcceptRelativeNamespace);

  if((ObjPath.NoError != ObjPath.Parse(strObjectPath, &pParsedObjectPath)) ||
     (0 != _wcsicmp(pParsedObjectPath->m_pClass, g_bstrClassMergeablePolicy)))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", strObjectPath));
    hres = WBEM_E_INVALID_QUERY;
  }
  else
  {
    // **** get input array

    hres = pInParams->Get(L"templateList", 0, &v1, NULL, NULL);
    if(FAILED(hres)) return hres;

    // **** perform merge

    SafeArray<IUnknown*, VT_UNKNOWN>
      InputArray(&v1);

    hres = Policy_Merge(InputArray, pOutResult, pNamespace);
    if(FAILED(hres)) return  hres;
    if(pOutResult == NULL) return WBEM_E_FAILED;

    // **** insert output of merge

    hres = pOutResult->QueryInterface(IID_IUnknown, (void **)&pUnk);
    if(FAILED(hres)) return hres;

    v1 = pUnk;
    hres = pOutParams->Put(L"mergedTemplate", 0, &v1, 0);
    if(FAILED(hres)) return hres;

    // **** put status in return value

    v1 = hres;
    hres = pOutParams->Put(L"ReturnValue", 0, &v1, 0);

    // **** send output back to client

    hres = pResponseHandler->Indicate(1, &pOutParams);
    if(FAILED(hres)) return hres;
  }

  ObjPath.Free(pParsedObjectPath);
  
  return hres;
};

STDMETHODIMP CPolicyTemplate::XProvider::ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  IWbemServices* pNamespace = m_pObject->GetWMIServices();
  CReleaseMe RelpNamespace(pNamespace);

  // **** impersonate client
  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    hres = WBEM_S_ACCESS_DENIED;
  }
  else
  {
    if((NULL == strObjectPath) || 
      (NULL == strMethodName) || 
      (NULL == pInParams) ||
      (NULL == pResponseHandler))
    {
       ERRORTRACE((LOG_ESS, "POLICMAN: object handle and/or return status objects are NULL\n"));
       hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      try
      {
        // **** get policy template class definition
        IWbemClassObject* pClass = NULL;
        hres = pNamespace->GetObject(g_bstrClassMergeablePolicy, 0, pCtx, &pClass, NULL);
        if(FAILED(hres)) return WBEM_E_NOT_FOUND;
        CReleaseMe relClass(pClass);

        // **** get output object
        IWbemClassObject* pOutClass = NULL;
        IWbemClassObject* pOutParamsObj = NULL;

        CReleaseMe relOutClass(pOutClass);
        CReleaseMe relOutObj(pOutParamsObj);

        hres = pClass->GetMethod(strMethodName, 0, NULL, &pOutClass);
        if(FAILED(hres)) return hres;

        hres = pOutClass->SpawnInstance(0, &pOutParamsObj);
        if(FAILED(hres)) return hres;

        // figure out which method we're here to service
        if (_wcsicmp(strMethodName, L"Merge") == 0)
          hres = DoMerge(pNamespace, strObjectPath, pCtx, pInParams, pOutParamsObj, pResponseHandler);
        else if (_wcsicmp(strMethodName, L"SetRange") == 0)
          hres = DoSetRange(pInParams, pOutParamsObj, pResponseHandler);
        else if (_wcsicmp(strMethodName, L"Set") == 0)
          hres = DoSet(pInParams, pOutParamsObj, pClass, pResponseHandler, pNamespace);
        else if (_wcsicmp(strMethodName, L"Resolve") == 0)
          hres = DoResolve(pNamespace, pCtx, pInParams, pOutParamsObj, pResponseHandler);
        else
          hres = WBEM_E_INVALID_PARAMETER;
            
      }
      catch(long hret)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: caught exception with HRESULT 0x%08X\n", hret));
        hres = hret;
      }
      catch(wchar_t *swErrString)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
        hres = WBEM_E_FAILED;
      }
      catch(...)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
        hres = WBEM_E_FAILED;
      }
    }

    hres2 = pResponseHandler->SetStatus(0, hres, NULL, NULL);
    if(FAILED(hres2))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
      if(SUCCEEDED(hres)) hres = hres2;
    }
    
    CoRevertToSelf();
  }

  return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policsom.cpp ===
#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <atlbase.h>
#include <sync.h>
#include <activeds.h>
#include <genlex.h>
#include <objpath.h>
#include <Utility.h>
#include <ql.h>

#include "PolicSOM.h"

#ifdef TIME_TRIALS
#include <StopWatch.h>
#pragma message("!! Including time trial code !!")
	StopWatch EvaluateTimer(L"Somfilter Evaluation", L"C:\\Som.Evaluate.log");
#endif

/******************************\
**** POLICY PROVIDER HELPERS ***
\******************************/

#define SOM_RDN L"CN=SOM,CN=WMIPolicy,CN=System"

// returns addref'd pointer back to WinMgmt
IWbemServices* CPolicySOM::GetWMIServices()
{
    CInCritSec lock(&m_CS);

	if (m_pWMIMgmt)
		m_pWMIMgmt->AddRef();

	return m_pWMIMgmt;
}

// returns addref'd pointer back to m_pADMgmt
IADsContainer *CPolicySOM::GetADServices(wchar_t *pDomain, HRESULT &hres)
{
  CInCritSec lock(&m_CS);
  IADsContainer *pADsContainer = NULL;

  QString
    SomDN(SOM_RDN),
    DistDomainName,
    ObjPath(L"LDAP://");

  if(NULL == pDomain)
  {
    // **** if this is the 1st time through, get name of domain controller

    if(VT_BSTR != m_vDsLocalContext.vt)
    {
      CComPtr<IADs>
        pRootDSE;

      // **** get pointer to AD policy template table

      hres = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pRootDSE);
      if(FAILED(hres))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not get object: LDAP://rootDSE, 0x%08X\n", hres));
        return NULL;
      }
      else
      {
        hres = pRootDSE->Get(L"defaultNamingContext",&m_vDsLocalContext);

        if(FAILED(hres))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: (IADs::Get) could not get defaultNamingContext, 0x%08X\n", hres));
          return NULL;
        }
      }
    }

    DistDomainName = m_vDsLocalContext.bstrVal;
  }
  else
    hres = DistNameFromDomainName(QString(pDomain), DistDomainName);

  ObjPath << SOM_RDN << L"," << DistDomainName;

  hres = ADsGetObject(ObjPath, IID_IADsContainer, (void**) &pADsContainer);

  if(NULL == pADsContainer)
    pADsContainer = CreateContainers(DistDomainName, SomDN);

  return pADsContainer;
}

// returns false if services pointer has already been set
bool CPolicySOM::SetWMIServices(IWbemServices* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull = FALSE;

  if (bOldOneNull = (m_pWMIMgmt == NULL))
  {
    m_pWMIMgmt = pServices;
    if(pServices) pServices->AddRef();
  }

  return bOldOneNull;
}

// returns false if services pointer has already been set
bool CPolicySOM::SetADServices(IADsContainer* pServices, unsigned context)
{
  CInCritSec lock(&m_CS);
  bool 
    bOldOneNull = TRUE;

  switch(context)
  {
    case AD_LOCAL_CONTEXT :
    case AD_GLOBAL_CONTEXT :
      m_pADMgmt[context] = pServices;
      pServices->AddRef();
      bOldOneNull = (m_pADMgmt[context] == NULL);
      break;

    default : ;
  }

  return bOldOneNull;
}

CPolicySOM::~CPolicySOM()
{
	// WMI services object

	if (m_pWMIMgmt)
	{
		m_pWMIMgmt->Release();
		m_pWMIMgmt= NULL;
	}

	// AD services object

  if (NULL != m_pADMgmt)
  {
    for(int i = 0; i < AD_MAX_CONTEXT; i++)
    {
      if(NULL != m_pADMgmt[i])
      {
        m_pADMgmt[i]->Release();
        m_pADMgmt[i] = NULL;
      }
    }
  }
};

void* CPolicySOM::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}
/*********************************\
*** Som Specific Implementation ***
\*********************************/

// returns addref'd pointer to class object
IWbemClassObject* CPolicySOM::XProvider::GetSomClass()
{
    CInCritSec lock(&m_pObject->m_CS);

    if (m_pSOMClassObject == NULL)
    {
        IWbemServices* pWinMgmt = NULL;

        if (pWinMgmt = m_pObject->GetWMIServices())
        {
            CReleaseMe relMgmt(pWinMgmt);
            pWinMgmt->GetObject(g_bstrClassSom, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &m_pSOMClassObject, NULL);
        }
    }

    if (m_pSOMClassObject)
        m_pSOMClassObject->AddRef();

    return m_pSOMClassObject;
}

// returns addref'd pointer to emply class instance
IWbemClassObject* CPolicySOM::XProvider::GetSomInstance()
{
    IWbemClassObject* pObj = NULL;
    IWbemClassObject* pClass = NULL;

    if (pClass = GetSomClass())
    {
        CReleaseMe releaseClass(pClass);
        pClass->SpawnInstance(0, &pObj);
    }

    return pObj;
}


CPolicySOM::XProvider::~XProvider()
{
    if (m_pSOMClassObject)
	{
		m_pSOMClassObject->Release();
		m_pSOMClassObject= NULL;
	}

    if (m_pLocator)
	{
		m_pLocator->Release();
		m_pLocator = NULL;
	}

}

HRESULT CPolicySOM::XProvider::GetLocator(IWbemLocator*& pLocator)
{
	HRESULT hr = WBEM_S_NO_ERROR;
    CInCritSec lock(&m_pObject->m_CS);	

	if (!m_pLocator)
		hr = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL, CLSCTX_ALL, IID_IWbemLocator, (void**)&m_pLocator);	  
 
	if (m_pLocator)
	{
		m_pLocator->AddRef();
		pLocator = m_pLocator;
	}

	return hr;
}

// get namespace denoted by namespaceName
// will release pNamespace if non-null on way in
HRESULT CPolicySOM::XProvider::GetNewNamespace(BSTR namespaceName, IWbemServices*& pNamespace)
{
	HRESULT hr = WBEM_E_FAILED;
	
	if (pNamespace)
	{
		pNamespace->Release();
		pNamespace = NULL;
	}

	IWbemLocator* pLocator = NULL;
	if (SUCCEEDED(hr = GetLocator(pLocator)))
	{
		CReleaseMe relLocator(pLocator);
		hr = pLocator->ConnectServer(namespaceName, NULL, NULL, NULL, 0, NULL, NULL, &pNamespace);
	}

	return hr;
}

// evaulate a single rule
// pNamespace & namespaceName may be NULL on entry
// may be different upon exit
// this is a rudimentary caching mechanism, 
// assuming that most of the namespaces in the rules will be the same.
HRESULT CPolicySOM::XProvider::EvaluateRule(IWbemServices*& pNamespace, BSTR& namespaceName, IWbemClassObject* pRule, bool& bResult)
{
	VARIANT v;
	VariantInit(&v);

	// assume failure
	HRESULT hr = WBEM_E_FAILED;
	bResult = false;

	// check to see	if we're still on the same namespace
	if (FAILED(hr = pRule->Get(L"TargetNamespace", 0, &v, NULL, NULL)))
		bResult = false;
	else
	{				
		if ((pNamespace == NULL) || (_wcsicmp(namespaceName, v.bstrVal) != 0))
			if (SUCCEEDED(hr = GetNewNamespace(v.bstrVal, pNamespace)))
			{
				// keep copy of name
				if (namespaceName)
				{
					if (!SysReAllocString(&namespaceName, v.bstrVal))
						hr = WBEM_E_OUT_OF_MEMORY;
				}
				else
					if (NULL == (namespaceName = SysAllocString(v.bstrVal)))
						hr = WBEM_E_OUT_OF_MEMORY;
			}
			
		VariantClear(&v);
	}

	// if we're still on track...
	if (SUCCEEDED(hr) && SUCCEEDED(hr = pRule->Get(L"Query", 0, &v, NULL, NULL)))
	{

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::AtomicTimer);
#endif
		IEnumWbemClassObject *pEnumerator = NULL;
		if (SUCCEEDED(hr = pNamespace->ExecQuery(L"WQL", v.bstrVal, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumerator)))
		{

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::ProviderTimer);
#endif
			ULONG uReturned = 0;
			IWbemClassObject* pWhoCares = NULL;

			if (SUCCEEDED(hr = pEnumerator->Next(WBEM_INFINITE, 1, &pWhoCares, &uReturned)) && uReturned > 0)
			{
				// we don't care at all about the result set
				// just whether there is anything *in* the result set
				bResult = true;
				pWhoCares->Release();
			}			
			pEnumerator->Release();
		}
#ifdef TIME_TRIALS
		else
			EvaluateTimer.Start(StopWatch::ProviderTimer);
#endif
		VariantClear(&v);
	}

	// s_false returned when no objects are returned from 'next'
	// THIS function has successfully determined that the query failed.
	if (hr == WBEM_S_FALSE)
		hr = WBEM_S_NO_ERROR;

	return hr;
}
					

// loop through all rules
// grab namespace & try each query
// TODO: Optimize by caching namespace pointers.
HRESULT CPolicySOM::XProvider::Evaluate(IWbemClassObject* pObj, IWbemClassObject* pOutInstance)
{	
	HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrEval = WBEM_S_NO_ERROR;
    
	// innocent until proven guilty
	bool bResult = true;

	VARIANT v;
	VariantInit(&v);

	if (SUCCEEDED(hr = pObj->Get(L"Rules", 0, &v, NULL, NULL)))
	{
		SafeArray<IUnknown*, VT_UNKNOWN> rules(&v);
		long nRules = rules.Size();

		// first run optimization: we'll hold onto each namespace as it comes in
		// in hopes that the NEXT one will be in the same namespace
		// in practice - it probably will be
		IWbemServices* pNamespace = NULL;
		BSTR namespaceName = NULL;

		// with each rule:
		//    get namespace name
		//		if different than the one we're currently playing with
		//			get namespace
		//    issue query
		//    count results
		for(UINT i = 0; (i < nRules) && bResult && SUCCEEDED(hrEval); i++)
		{

			if (rules[i])
			{
				IWbemClassObject* pRule = NULL;

				if (SUCCEEDED(rules[i]->QueryInterface(IID_IWbemClassObject, (void**)&pRule)))
				{
					hrEval = EvaluateRule(pNamespace, namespaceName, pRule, bResult);
					
					pRule->Release();
					pRule = NULL;
				}
				else
				{
					bResult = FALSE;
					hrEval = hr = WBEM_E_INVALID_PARAMETER;                    
				}
			}
		}

		// clean up after yourself
		VariantClear(&v);
		if (pNamespace)
			pNamespace->Release();
		if (namespaceName)
			SysFreeString(namespaceName);
	}

    // we done - tell somebody about it!
    if (SUCCEEDED(hr))
    {
        HRESULT hrDebug;
        
        VARIANT v;
        VariantInit(&v);
        v.vt = VT_I4;

        if (SUCCEEDED(hrEval))
            v.lVal = bResult ? S_OK : S_FALSE;
        else
            v.lVal = hrEval;
        
        hrDebug = pOutInstance->Put(L"ReturnValue", 0, &v, NULL);
    }

    return hr;
}

// loop through each of the references in input obj
// call evaluate for each, 
// TODO: Optimize w/ ExecMethodASYNC
HRESULT CPolicySOM::XProvider::BatchEvaluate(IWbemClassObject* pObj, IWbemClassObject* pOutInstance, IWbemServices* pPolicyNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    if (pObj == NULL)
        return WBEM_E_INVALID_PARAMETER;

    VARIANT vFilters;
    VariantInit(&vFilters);

    BSTR methodName = SysAllocString(L"Evaluate");
    CSysFreeMe freeEvil(methodName);

    SAFEARRAY* pResults = NULL;

    if (SUCCEEDED(hr = pObj->Get(L"filters", 0, &vFilters, NULL, NULL)))
    {        
        if ((vFilters.parray == NULL)    || 
            (vFilters.parray->cDims != 1) ||
            (vFilters.parray->rgsabound[0].cElements == 0))
            hr = WBEM_E_INVALID_PARAMETER;
        else
        {
            long index, lUbound = 0;
            SafeArrayGetUBound(vFilters.parray, 1, &lUbound);

            SAFEARRAYBOUND bounds = {lUbound +1, 0};

            pResults = SafeArrayCreate(VT_I4, 1, &bounds);
            if (!pResults)
                return WBEM_E_OUT_OF_MEMORY;

            for (index = 0; (index <= lUbound) && SUCCEEDED(hr); index++)
            {
                BSTR path = NULL;

                if (SUCCEEDED(hr = SafeArrayGetElement(vFilters.parray, &index, &path)))
                {
                    IWbemClassObject* pGazotta = NULL;
                    if (SUCCEEDED(hr = pPolicyNamespace->ExecMethod(path, methodName, 0, NULL, NULL, &pGazotta, NULL)))
                    {
                        CReleaseMe relGazotta(pGazotta);
                        VARIANT v;
                        VariantInit(&v);

                        hr = pGazotta->Get(L"ReturnValue", 0, &v, NULL, NULL);
                        hr = SafeArrayPutElement(pResults, &index, &v.lVal);
                    }
                }

                SysFreeString(path);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        VARIANT v;
        VariantInit(&v);
        v.vt = VT_I4 | VT_ARRAY;
        v.parray = pResults;
        hr = pOutInstance->Put(L"Results", 0, &v, NULL);

        // no clear - array is deleted separately.
        VariantInit(&v);
        v.vt = VT_I4;
        v.lVal = hr;
        
        hr = pOutInstance->Put(L"ReturnValue", 0, &v, NULL);

    }

    if (pResults)
        SafeArrayDestroy(pResults);

    VariantClear(&vFilters);
    return hr;
}

/*************************\
***  IWbemProviderInit  ***
\*************************/

STDMETHODIMP CPolicySOM::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices* pServices, IWbemContext* pCtxt, 
            IWbemProviderInitSink* pSink)
{
  HRESULT
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    return WBEM_S_ACCESS_DENIED;
  }
  else
  {
    // **** save WMI name space pointer

    m_pObject->SetWMIServices(pServices);
  }

  hres2 = pSink->SetStatus(hres, 0);
  if(FAILED(hres2))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
    if(SUCCEEDED(hres)) hres = hres2;
  }

  return hres;
}

/*******************\
*** IWbemServices ***
\*******************/

STDMETHODIMP CPolicySOM::XProvider::GetObjectAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
   hres = WBEM_S_NO_ERROR,
   hres2 = WBEM_S_NO_ERROR;

  CComPtr<IWbemServices>
    pNamespace;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IWbemClassObject>
    pObj;

  CComPtr<IDirectoryObject>
    pDirObj;

  VARIANT
    *pvkeyID = NULL,
    *pvDomain = NULL;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** Check arguments

    if(ObjectPath == NULL || pResponseHandler == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object path and/or return object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      ParsedObjectPath
        *pParsedObjectPath = NULL;

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         (0 != _wcsicmp(g_bstrClassSom, pParsedObjectPath->m_pClass)) ||
         (2 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        int x;

        for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
        {
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
            pvDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
          else if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrID))
            pvkeyID = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
        }

        pNamespace.Attach(m_pObject->GetWMIServices());
        pADsContainer.Attach(m_pObject->GetADServices(pvDomain->bstrVal, hres));

        if((FAILED(hres)) || (pNamespace == NULL) || (pADsContainer == NULL))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: WMI and/or AD services not initialized\n"));
          hres = ADSIToWMIErrorCodes(hres);
        }
        else
        {
          try
          {
            // **** Get pointer to instance in AD

            hres = pADsContainer->GetObject(g_bstrADClassSom, QString(L"CN=") << V_BSTR(pvkeyID), &pDisp);
            if(FAILED(hres))
              hres = ADSIToWMIErrorCodes(hres);
            else
            {
              hres = pDisp->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
              if(SUCCEEDED(hres))
              {
                // **** Get the instance and send it back

                hres = Som_ADToCIM(&pObj, pDirObj, pNamespace);
                if(FAILED(hres)) hres = ADSIToWMIErrorCodes(hres);
                if(pObj == NULL) hres = WBEM_E_FAILED;

                // **** Set object

                pResponseHandler->Indicate(1, &pObj);
              }
            }
          }
          catch(long hret)
          {
            hres = ADSIToWMIErrorCodes(hret);
            ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
          }
          catch(wchar_t *swErrString)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
            hres = WBEM_E_FAILED;
          }
          catch(...)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught UNKNOWN Exception\n"));
            hres = WBEM_E_FAILED;
          }
        }
      }

      ObjPath.Free(pParsedObjectPath);
      hres2 = pResponseHandler->SetStatus(0,hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicySOM::XProvider::CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return WBEM_E_NOT_SUPPORTED;
}

// validate that the rules contained in pInst are proper syntax
// if they are not, an error object is created & an error returned
HRESULT CPolicySOM::XProvider::ValidateRules(IWbemClassObject* pInst, IWbemClassObject*& pErrorObject)
{
    // init the toys we'll be playing with
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bBadQuery = false;

    VARIANT vRules;
    VariantInit(&vRules);

    SAFEARRAY* pResults = NULL;

    if (FAILED(pInst->Get(L"Rules", 0, &vRules, NULL, NULL))
        || (vRules.vt != (VT_UNKNOWN | VT_ARRAY)))
        hr = WBEM_E_INVALID_PARAMETER;
    else
    {
        // good to go, we'll create the array to keep logic simple
        long index, lUbound = 0;
        SafeArrayGetUBound(vRules.parray, 1, &lUbound);
        SAFEARRAYBOUND bounds = {lUbound +1, 0};
        pResults = SafeArrayCreate(VT_I4, 1, &bounds);

        if (!pResults)
            hr = WBEM_E_OUT_OF_MEMORY;
        else
            for (index = 0; (index <= lUbound) && SUCCEEDED(hr); index++)
            {
                // get the MSFT_Rule out of the MSFT_SomFilter
                IWbemClassObject* pRule = NULL;
                if (SUCCEEDED(hr = SafeArrayGetElement(vRules.parray, &index, &pRule)))
                {
                    HRESULT hrParse = 0;
                    VARIANT vQueryLanguage;
                    VariantInit(&vQueryLanguage);
 
                    if (SUCCEEDED(hr = pRule->Get(L"QueryLanguage", 0, &vQueryLanguage, NULL, NULL))
                        && (vQueryLanguage.vt == VT_BSTR) && (vQueryLanguage.bstrVal != NULL))
                    {
                        if (0 != _wcsicmp(vQueryLanguage.bstrVal, L"WQL"))
                        {
                            hrParse = WBEM_E_INVALID_QUERY_TYPE;
                            bBadQuery = true;
                        }
                        else
                        {
                            VARIANT vQuery;
                            VariantInit(&vQuery);

                            // get the query out of the MSFT_Rule.
                            if (SUCCEEDED(hr = pRule->Get(L"Query", 0, &vQuery, NULL, NULL))
                                && (vQuery.vt == VT_BSTR) && (vQuery.bstrVal != NULL))
                            {    
                                CTextLexSource src(vQuery.bstrVal);
                                QL1_Parser parser(&src);
                                QL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;
    
                                // if it parses, we good, else we bad.
                                if(parser.Parse(&pExp))
                                {
                                    hrParse = WBEM_E_INVALID_QUERY;
                                    bBadQuery = true;
                                }
                        

                                if (pExp)
                                    delete pExp;
                            }
                            else
                                hrParse = WBEM_E_INVALID_PARAMETER;

                            VariantClear(&vQuery);
                        }
                    }
                    else
                        hrParse = WBEM_E_INVALID_PARAMETER;
                    

                    SafeArrayPutElement(pResults, &index, (void*)&hrParse);
                    pRule->Release();

                    VariantClear(&vQueryLanguage);
                }
            }
    }
    
    // if we found a bad query, we create an error object to hold the info
    if (bBadQuery)
    {
        IWbemServices* pSvc = m_pObject->GetWMIServices();
        IWbemClassObject* pErrorClass = NULL;
        BSTR name = SysAllocString(L"SomFilterPutStatus");

        if (pSvc && 
            name && 
            SUCCEEDED(hr = pSvc->GetObject(name, 0, NULL, &pErrorClass, NULL)) &&
            SUCCEEDED(hr = pErrorClass->SpawnInstance(0, &pErrorObject)))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            HRESULT hrDebug;

            // variant to hold array - don't clear it, the array is destroyed elsewhere
            VARIANT vResultArray;
            VariantInit(&vResultArray);
            vResultArray.vt = VT_I4 | VT_ARRAY;
            vResultArray.parray = pResults;

            hrDebug = pErrorObject->Put(L"RuleValidationResults", 0, &vResultArray, NULL);

            // other interesting error vals.
            VARIANT vTemp;
            vTemp.vt = VT_BSTR;
            
            vTemp.bstrVal = SysAllocString(L"PutInstance");
            hrDebug = pErrorObject->Put(L"Operation",0,&vTemp,NULL);
            SysFreeString(vTemp.bstrVal);
            
            vTemp.bstrVal = SysAllocString(L"PolicSOM");
            hrDebug = pErrorObject->Put(L"ProviderName",0,&vTemp,NULL);
            SysFreeString(vTemp.bstrVal);

            vTemp.vt = VT_I4;
            vTemp.lVal = WBEM_E_INVALID_QUERY;
            hrDebug = pErrorObject->Put(L"StatusCode",0,&vTemp,NULL);

			//BSTR debuggy = NULL;
			//pErrorObject->GetObjectText(0, &debuggy);
            
        }

        if (pSvc)
            pSvc->Release();
        if (name)
            SysFreeString(name);
        if (pErrorClass)
            pErrorClass->Release();
    }

    // cleanup
    VariantClear(&vRules);
    if (pResults)
        SafeArrayDestroy(pResults);

    return hr;
}

STDMETHODIMP CPolicySOM::XProvider::PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT 
        hres = WBEM_S_NO_ERROR,
        hres2 = WBEM_S_NO_ERROR;
    
    CComPtr<IADsContainer>
        pADsContainer;
    
    CComPtr<IDirectoryObject>
        pDirObj;
    
    CComVariant
        v1, vRelPath;
    
    ADsStruct<ADS_OBJECT_INFO>
        pInfo;
    
    // **** impersonate client
    
    hres = CoImpersonateClient();
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
        hres = WBEM_E_ACCESS_DENIED;
    }
    else
    {
        // **** check arguments
        
        if((NULL == pInst) || (NULL == pResponseHandler))
        {
            ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
            hres = WBEM_E_ACCESS_DENIED;
        }
        else
        {
            IWbemClassObject* pErrorObject = NULL;
            if SUCCEEDED(hres = ValidateRules(pInst, pErrorObject))
            {
            
                // **** put policy obj into AD
                try
                {
                
                    EnsureID(pInst, NULL);
                
                    // **** aquire AD path in which to place object
                
                    hres = pInst->Get(g_bstrDomain, 0, &v1, NULL, NULL);
                    if(FAILED(hres)) return hres;
                
                    if(VT_BSTR == v1.vt)
                        pADsContainer.Attach(m_pObject->GetADServices(v1.bstrVal, hres));
                    else
                        pADsContainer.Attach(m_pObject->GetADServices(NULL, hres));
                
                    if((FAILED(hres)) || (pADsContainer == NULL))
                    {
                        ERRORTRACE((LOG_ESS, "POLICMAN: Could not find or connect to domain: %S\n", V_BSTR(&v1)));
                        return ADSIToWMIErrorCodes(hres);
                    }
                
                    hres = pADsContainer->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
                    if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
                
                    // **** copy policy obj into AD
                
                    hres = Som_CIMToAD(pInst, pDirObj, lFlags);
                    if(FAILED(hres)) 
                    {
                      if(0x800700a == hres)
                        ERRORTRACE((LOG_ESS, "POLICMAN: Active Directory Schema for MSFT_SomFilter is invalid/missing\n"));

                      return ADSIToWMIErrorCodes(hres);
                    }
                }
                catch(long hret)
                {
                    hres = ADSIToWMIErrorCodes(hret);
                    ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from WMI to AD generated HRESULT 0x%08X\n", hres));
                }
                catch(wchar_t *swErrString)
                {
                    ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
                    hres = WBEM_E_FAILED;
                }
                catch(...)
                {
                    ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
                    hres = WBEM_E_FAILED;
                }
            
            }
            
            if(FAILED(hres) && pErrorObject)
            {
                if(FAILED(pResponseHandler->SetStatus(0,hres, NULL, pErrorObject)))
                    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
            }
            else
            {
                // **** indicate return status            
                pInst->Get(L"__RELPATH", 0, &vRelPath, NULL, NULL);
                if(FAILED(pResponseHandler->SetStatus(0,hres, vRelPath.bstrVal, NULL)))
                    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
            }
            
            if (pErrorObject)
                pErrorObject->Release();
            
        }
        
        CoRevertToSelf();
    }
    
    return hres;
}

STDMETHODIMP CPolicySOM::XProvider::DeleteInstanceAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IADsDeleteOps>
    pDelObj;

  VARIANT
    *pvDomain = NULL,
    *pvkeyID = NULL;

  ParsedObjectPath
    *pParsedObjectPath = NULL;

  // **** impersonate client

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** Check arguments

    if(ObjectPath == NULL || pResponseHandler == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object handle and/or return status object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         (0 != _wcsicmp(g_bstrClassSom, pParsedObjectPath->m_pClass)) ||
         (2 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        int x;

        for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
        {
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
            pvDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
          else if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrID))
            pvkeyID = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
        }

        pADsContainer.Attach(m_pObject->GetADServices(pvDomain->bstrVal, hres));
        if((FAILED(hres)) || (pADsContainer == NULL))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Could not find domain: %S\n", V_BSTR(pvDomain)));
          hres = ADSIToWMIErrorCodes(hres);
        }
        else
        {
          // **** get pointer to instance in AD

          hres = pADsContainer->GetObject(g_bstrADClassSom, QString(L"CN=") << V_BSTR(pvkeyID), &pDisp);
          if(FAILED(hres))
          {
            hres = ADSIToWMIErrorCodes(hres);
            ERRORTRACE((LOG_ESS, "POLICMAN: (IADsContainer::GetObject) could not get object in AD %S, 0x%08X\n", V_BSTR(pvkeyID), hres));
          }
          else
          {
            hres = pDisp->QueryInterface(IID_IADsDeleteOps, (void **)&pDelObj);
            if(FAILED(hres))
            {
              ERRORTRACE((LOG_ESS, "POLICMAN: (IDispatch::QueryInterface) could not get IID_IADsDeleteOps interface on object\n"));
            }
            else
            {
              // **** delete the instance and all its children in AD

              hres = pDelObj->DeleteObject(0);
              if(FAILED(hres))
              {
                ERRORTRACE((LOG_ESS, "POLICMAN: (IADsDeleteOps::DeleteObject) could not delete object (0x%08X)\n", hres));
                hres = WBEM_E_ACCESS_DENIED;
              }
            }
          }
        }
      }

      ObjPath.Free(pParsedObjectPath);
      hres2 = pResponseHandler->SetStatus(0,hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicySOM::XProvider::ExecQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT
    hres = WBEM_E_FAILED;

  CComPtr<IWbemServices>
    pNameSpace;

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    pNameSpace.Attach(m_pObject->GetWMIServices());
  
    hres = ExecuteWQLQuery(SOM_RDN,
                           Query,
                           pResponseHandler,
                           pNameSpace,
                           g_bstrADClassSom,
                           Som_ADToCIM);

    if(pResponseHandler != NULL)
      pResponseHandler->SetStatus(0, hres, 0, 0);
  }

  CoRevertToSelf();

  return hres;
}

STDMETHODIMP CPolicySOM::XProvider::ExecMethodAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_FAILED;

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::ProviderTimer);
#endif
    
    enum WhichMethod {Eval, BatchEval};
    WhichMethod whichMethod;

    // check for valid method name
    if (_wcsicmp(strMethodName, L"Evaluate") == 0)
        whichMethod = Eval;
    else if (_wcsicmp(strMethodName, L"BatchEvaluate") == 0)
        whichMethod = BatchEval;
    else
        return WBEM_E_INVALID_METHOD;
    
    // **** impersonate client for security
    hr = CoImpersonateClient();
    if (FAILED(hr))
        return hr;
    
    // retrieve target object
    CComPtr<IWbemServices> 
      pService;

    pService.Attach(m_pObject->GetWMIServices());
    if (pService == NULL)
        hr = WBEM_E_FAILED;
    else
    {
        IWbemClassObject* pObj = NULL;

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::WinMgmtTimer);
#endif

        if (SUCCEEDED(hr = pService->GetObject(strObjectPath, WBEM_FLAG_RETURN_WBEM_COMPLETE, pCtx, &pObj, NULL)))
        {

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::ProviderTimer);
#endif
            CReleaseMe releaseObj(pObj);

            // retreive class & output param object
            IWbemClassObject* pOurClass;
            if (NULL == (pOurClass = GetSomClass()))
                hr = WBEM_E_FAILED;
            else
            {
                CReleaseMe releaseClass(pOurClass);

                IWbemClassObject* pOutClass = NULL;
                if (SUCCEEDED(hr = pOurClass->GetMethod(strMethodName, 0, NULL, &pOutClass)))
                {        
                    CReleaseMe releaseOut(pOutClass);
                    IWbemClassObject* pOutInstance = NULL;
                    if (SUCCEEDED(pOutClass->SpawnInstance(0, &pOutInstance)))
                    {
                        CReleaseMe releaseInnerOut(pOutInstance);

                        if (whichMethod == Eval)
                            hr = Evaluate(pObj, pOutInstance);
                        else if (whichMethod == BatchEval)
                            hr = BatchEvaluate(pInParams, pOutInstance, pService);
                        else
                            hr = WBEM_E_INVALID_METHOD;

                        if (SUCCEEDED(hr))
                            hr = pResponseHandler->Indicate(1, &pOutInstance);

                    }
                }
            }                            
        }
        else hr = WBEM_E_NOT_FOUND;
    }    

#ifdef TIME_TRIALS
	EvaluateTimer.Stop();
	EvaluateTimer.LogResults();
	EvaluateTimer.Reset(); // for next time!
#endif

	// difficult call - do we put this before or after we take the timestamp?
    pResponseHandler->SetStatus(0,hr,NULL, NULL);
    CoRevertToSelf();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\polictype.h ===
#ifndef __WBEM_POLICY_TYPE__H_
#define __WBEM_POLICY_TYPE__H_

class CPolicyType : public CUnk
{
public:
    enum
    {
      AD_LOCAL_CONTEXT = 0,
      AD_GLOBAL_CONTEXT,
      AD_MAX_CONTEXT
    };


    CPolicyType(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this), 
		m_pWMIMgmt(NULL)
    {
        ZeroMemory( m_pADMgmt, sizeof(void*) * AD_MAX_CONTEXT);
    }
    
	~CPolicyType();

    void* GetInterface(REFIID riid);

	// stuff for our internal use
	IWbemServices* GetWMIServices();
    IADsContainer* GetADServices(wchar_t *pADDomain);
	bool SetWMIServices(IWbemServices* pServices);
    bool SetADServices(IADsContainer* ,unsigned);

protected:
    class XProvider : public CImpl<IWbemServices, CPolicyType>
    {
    public:
        /* construction & de- */

        XProvider(CPolicyType* pObj)
            : CImpl<IWbemServices, CPolicyType>(pObj), m_pPolicyTypeClassObject(NULL), m_pLocator(NULL)
		{ /* this page intentionally left blank */ }

        ~XProvider();
		
        /* Internals */

    protected:
        /* Method support */

        /* class object management */
        IWbemClassObject* GetPolicyTypeClass();
        IWbemClassObject* GetPolicyTypeInstance();

	/* communication w/ winmgmt management */
	HRESULT GetLocator(IWbemLocator*& pLocator);
	HRESULT GetNewNamespace(BSTR namespaceName, IWbemServices*& pNamespace);


    private:
       	// templates for each type of object we support
    	// NULL until we need it
	    IWbemClassObject* m_pPolicyTypeClassObject;

		// NULL until we need it -
		// access through GetLocator;
		IWbemLocator* m_pLocator;

        /* IWbemServices */
    public:

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) 
			{return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CPolicyType>
    {
    public:
        XInit(CPolicyType* pObj)
            : CImpl<IWbemProviderInit, CPolicyType>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;

private:

    // pointer back to win management
    IWbemServices* m_pWMIMgmt; 

    // pointer to AD policy template table
    IADsContainer* m_pADMgmt[AD_MAX_CONTEXT];

  CComVariant
    m_vDsConfigContext,
    m_vDsLocalContext;

    // a little something to keep our threads from getting tangled
    // will use a single critical section to protect all instance variables
    CCritSec m_CS;   
};


#endif // __WBEM_POLICY_TYPE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\polictype.cpp ===
#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <atlbase.h>
#include <sync.h>
#include "activeds.h"
#include "genlex.h"
#include "objpath.h"
#include "Utility.h"

#include "Polictype.h"

/***************i******************\
*** POLICY TYPE PROVIDER HELPERS ***
\********************i*************/

#define POLICYTYPE_RDN L"CN=PolicyType,CN=WMIPolicy,CN=System"

// returns addref'd pointer back to m_pWMIMgmt
IWbemServices* CPolicyType::GetWMIServices(void)
{
  CInCritSec lock(&m_CS);

  if (NULL != m_pWMIMgmt)
    m_pWMIMgmt->AddRef();

  return m_pWMIMgmt;
}

// returns addref'd pointer back to m_pADMgmt
IADsContainer *CPolicyType::GetADServices(wchar_t *pDomain)
{
  CInCritSec lock(&m_CS);
  IADsContainer *pADsContainer = NULL;
  HRESULT hres;

  QString
    DistDomainName;

  if(NULL == pDomain)
    DistDomainName = m_vDsLocalContext.bstrVal;
  else
    hres = DistNameFromDomainName(QString(pDomain), DistDomainName);

  hres = ADsGetObject(QString(L"LDAP://") << POLICYTYPE_RDN << L"," << DistDomainName,
                      IID_IADsContainer,
                      (void**) &pADsContainer);

  if(NULL == pADsContainer)
    pADsContainer = CreateContainers(DistDomainName, QString(POLICYTYPE_RDN));

  return pADsContainer;
}

// returns false if services pointer has already been set
bool CPolicyType::SetWMIServices(IWbemServices* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull = FALSE;

  if (bOldOneNull = (m_pWMIMgmt == NULL))
  {
    m_pWMIMgmt = pServices;
    if(pServices) pServices->AddRef();
  }

  return bOldOneNull;
}

// returns false if services pointer has already been set
bool CPolicyType::SetADServices(IADsContainer* pServices, unsigned context)
{
  CInCritSec lock(&m_CS);
  bool 
    bOldOneNull = TRUE;

  switch(context)
  {
    case AD_LOCAL_CONTEXT :
    case AD_GLOBAL_CONTEXT :
      m_pADMgmt[context] = pServices;
      pServices->AddRef();
      bOldOneNull = (m_pADMgmt[context] == NULL);
      break;
    default : ;
  }

  return bOldOneNull;
}
    
CPolicyType::~CPolicyType()
{
  // **** WMI services object

  if (NULL != m_pWMIMgmt)
  {
    m_pWMIMgmt->Release();
    m_pWMIMgmt= NULL;
  }

  // **** AD services object

  if (NULL != m_pADMgmt)
  {
    for(int i = 0; i < AD_MAX_CONTEXT; i++)
    {
      if(NULL != m_pADMgmt[i])
      {
        m_pADMgmt[i]->Release();
        m_pADMgmt[i] = NULL;
      }
    }
  }
};

void* CPolicyType::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}

/********************\
*** Object Support ***
\********************/

// returns addref'd pointer to class object
IWbemClassObject* CPolicyType::XProvider::GetPolicyTypeClass()
{
    CInCritSec lock(&m_pObject->m_CS);

    if (m_pPolicyTypeClassObject == NULL)
    {
        IWbemServices* pWinMgmt = NULL;
        if (pWinMgmt = m_pObject->GetWMIServices())
        {
            CReleaseMe relMgmt(pWinMgmt);
            pWinMgmt->GetObject(g_bstrClassPolicyType, 
                                WBEM_FLAG_RETURN_WBEM_COMPLETE, 
                                NULL, 
                                &m_pPolicyTypeClassObject, 
                                NULL);
        }
    }

    if (m_pPolicyTypeClassObject)
        m_pPolicyTypeClassObject->AddRef();

    return m_pPolicyTypeClassObject;
}

// returns addref'd pointer to emply class instance
IWbemClassObject* CPolicyType::XProvider::GetPolicyTypeInstance()
{
    IWbemClassObject* pObj = NULL;
    IWbemClassObject* pClass = NULL;

    if (pClass = GetPolicyTypeClass())
    {
        CReleaseMe releaseClass(pClass);
        pClass->SpawnInstance(0, &pObj);
    }

    return pObj;
}

CPolicyType::XProvider::~XProvider()
{
  if(NULL != m_pPolicyTypeClassObject)
  {
    m_pPolicyTypeClassObject->Release();
    m_pPolicyTypeClassObject = NULL;
  }
}

/*************************\
***  IWbemProviderInit  ***
\*************************/

STDMETHODIMP CPolicyType::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices* pServices, IWbemContext* pCtxt, 
            IWbemProviderInitSink* pSink)
{
  CComPtr<IADs>
    pRootDSE;

  CComPtr<IADsContainer>
    pObject;

  HRESULT
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    hres = WBEM_S_ACCESS_DENIED;
  }
  else
  {
    // **** safe WMI name space pointer

    m_pObject->SetWMIServices(pServices);

    // **** get pointer to AD policy template table

    hres = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pRootDSE);
    if (FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not get object: LDAP://rootDSE, 0x%08X\n", hres));
      return WBEM_E_NOT_FOUND;
    }
    else
    {
      hres = pRootDSE->Get(L"defaultNamingContext",&m_pObject->m_vDsLocalContext);
      if(FAILED(hres))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: (IADs::Get) could not get defaultNamingContext, 0x%08X\n", hres));
        hres = WBEM_E_NOT_FOUND;
      }

      hres = pRootDSE->Get(L"configurationNamingContext",&m_pObject->m_vDsConfigContext);
      if(FAILED(hres))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: (IADs::Get) could not get configurationNamingContext, 0x%08X\n", hres));
        hres = WBEM_E_NOT_FOUND;
      }
    }
  }

  pSink->SetStatus(hres, 0);
  return hres;
}

/*******************\
*** IWbemServices ***
\*******************/

STDMETHODIMP CPolicyType::XProvider::GetObjectAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponse)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  VARIANT
    *pvkeyID = NULL,
    *pvDomain = NULL;

  CComPtr<IWbemServices>
    pNamespace;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IWbemClassObject>
    pObj;

  CComPtr<IDirectoryObject>
    pDirObj;

  // **** impersonate client

  hres = CoImpersonateClient();
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** Check arguments

    if(ObjectPath == NULL || pResponse == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object path and/or return object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      ParsedObjectPath
        *pParsedObjectPath = NULL;

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         (0 != _wcsicmp(g_bstrClassPolicyType, pParsedObjectPath->m_pClass)) ||
         (2 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        int x;

        for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
        {
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
            pvDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
          else if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrID))
            pvkeyID = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
        }

        pNamespace = m_pObject->GetWMIServices();
        pADsContainer = m_pObject->GetADServices(pvDomain->bstrVal);

        if((pNamespace == NULL) || (pADsContainer == NULL))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: WMI and/or AD services not initialized\n"));
          hres = WBEM_E_NOT_FOUND;
        }
        else
        {
          try
          {
            // **** Get pointer to instance in AD

            hres = pADsContainer->GetObject(g_bstrADClassPolicyType, QString(L"CN=") << V_BSTR(pvkeyID), &pDisp);
            if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

            hres = pDisp->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
            if(FAILED(hres)) return hres;

            // **** Get the instance and send it back

            hres = PolicyType_ADToCIM(&pObj, pDirObj, pNamespace);
            if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
            if(pObj == NULL) return WBEM_E_FAILED;

            // **** Set object

            pResponse->Indicate(1, &pObj);
          }
          catch(long hret)
          {
            hres = ADSIToWMIErrorCodes(hret);
            ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
          }
          catch(wchar_t *swErrString)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
            hres = WBEM_E_FAILED;
          }
          catch(...)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
            hres = WBEM_E_FAILED;
          }
        }
      }

      ObjPath.Free(pParsedObjectPath);
      hres2 = pResponse->SetStatus(0,hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicyType::XProvider::CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  return WBEM_E_NOT_SUPPORTED;
}

STDMETHODIMP CPolicyType::XProvider::PutInstanceAsync( 
     /* [in] */ IWbemClassObject __RPC_FAR *pInst,
     /* [in] */ long lFlags,
     /* [in] */ IWbemContext __RPC_FAR *pCtx,
     /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDirectoryObject>
    pDirObj;

  CComVariant
    v1, vRelPath;

  ADsStruct<ADS_OBJECT_INFO>
    pInfo;

  // **** impersonate client

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** check arguments

    if((NULL == pInst) || (NULL == pResponseHandler))
    {
        ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
        hres = WBEM_E_ACCESS_DENIED;
    }
    else
    {
      // **** put policy obj into AD

      try
      {
        EnsureID(pInst, NULL);

        // **** aquire AD path in which to place object

        hres = pInst->Get(g_bstrDomain, 0, &v1, NULL, NULL);
        if(FAILED(hres)) return hres;

        if(VT_BSTR == v1.vt)
          pADsContainer = m_pObject->GetADServices(v1.bstrVal);
        else
          pADsContainer = m_pObject->GetADServices(NULL);

        if(pADsContainer == NULL)
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Could not find or connect to domain: %S\n", V_BSTR(&v1)));
          return WBEM_E_ACCESS_DENIED;
        }

        hres = pADsContainer->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
        if(FAILED(hres)) return hres;

        // **** copy policy obj into AD

        hres = PolicyType_CIMToAD(pInst, pDirObj);
        if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
      }
      catch(long hret)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy Type object from WMI to AD generated HRESULT 0x%08X\n", hret));
        hres = hret;
      }
      catch(wchar_t *swErrString)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
        hres = WBEM_E_FAILED;
      }
      catch(...)
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
        hres = WBEM_E_FAILED;
      }

      // send it back as we may have added keys
      if(SUCCEEDED(hres))
        pResponseHandler->Indicate(1, &pInst);

      // **** indicate return status

      pInst->Get(L"__RELPATH", 0, &vRelPath, NULL, NULL);
      if(FAILED(pResponseHandler->SetStatus(0, hres, vRelPath.bstrVal, NULL)))
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
    }
    
    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicyType::XProvider::DeleteInstanceAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IADsDeleteOps>
    pDelObj;

  VARIANT
    *pvkeyID = NULL,
    *pvDomain = NULL;

  // **** impersonate client

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** check arguments

    if(ObjectPath == NULL || pResponseHandler == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object handle and/or return status object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse WMI object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      ParsedObjectPath
        *pParsedObjectPath = NULL;

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         (0 != _wcsicmp(g_bstrClassPolicyType, pParsedObjectPath->m_pClass)) ||
         (2 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        int x;

        // **** only grab ID key for now

        for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
        {
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
            pvDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
          else if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrID))
            pvkeyID = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
        }
    
        pADsContainer = m_pObject->GetADServices(pvDomain->bstrVal);
        if(pADsContainer == NULL)
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: AD services not initialized\n"));
          hres = WBEM_E_NOT_FOUND;
        }
        else
        {
          // **** Get pointer to instance in AD

          hres = pADsContainer->GetObject(g_bstrADClassPolicyType, QString(L"CN=") << V_BSTR(pvkeyID), &pDisp);
          if(FAILED(hres))
          {
            hres = ADSIToWMIErrorCodes(hres);
            ERRORTRACE((LOG_ESS, "POLICMAN: (IADsContainer::GetObject) could not get object in AD %S, 0x%08X\n", V_BSTR(pvkeyID), hres));
          }
          else
          {
            hres = pDisp->QueryInterface(IID_IADsDeleteOps, (void **)&pDelObj);
            if(FAILED(hres))
            {
              ERRORTRACE((LOG_ESS, "POLICMAN: (IDispatch::QueryInterface) could not get IID_IADsDeleteOps interface on object\n"));
            }
            else
            {
              // **** delete the instance and all its children in AD

              hres = pDelObj->DeleteObject(0);
              if(FAILED(hres))
              {
                hres = ADSIToWMIErrorCodes(hres);
                ERRORTRACE((LOG_ESS, "POLICMAN: (IADsDeleteOps::DeleteObject) could not delete object\n"));
              }
            }
          }
        }
      }

      ObjPath.Free(pParsedObjectPath);
      hres2 = pResponseHandler->SetStatus(0,hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicyType::XProvider::ExecQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT
    hres = WBEM_E_FAILED;

  CComPtr<IWbemServices>
    pNameSpace;

  pNameSpace = m_pObject->GetWMIServices();

  hres = ExecuteWQLQuery(POLICYTYPE_RDN,
                         Query,
                         pResponseHandler,
                         pNameSpace,
                         g_bstrADClassPolicyType,
                         PolicyType_ADToCIM);

  if(pResponseHandler != NULL)
    pResponseHandler->SetStatus(0, hres, 0, 0);

  return hres;
}

STDMETHODIMP CPolicyType::XProvider::ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\polictempl.h ===
#ifndef __WBEM_POLICY_TEMPLATE__H_
#define __WBEM_POLICY_TEMPLATE__H_

class CPolicyTemplate : public CUnk
{
enum
{
  AD_LOCAL_CONTEXT = 0,
  AD_GLOBAL_CONTEXT,
  AD_MAX_CONTEXT
};

public:
  CPolicyTemplate(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
                 : CUnk(pControl, pOuter), 
                   m_XProvider(this), 
                   m_XInit(this), 
                   m_pWMIMgmt(NULL) 
  {
      ZeroMemory( m_pADMgmt, sizeof(void*) * AD_MAX_CONTEXT);
  }
    
  ~CPolicyTemplate();

  void* GetInterface(REFIID riid);

  // stuff for our internal use
  IWbemServices* GetWMIServices();
  IADsContainer* GetADServices(wchar_t *pADDomain);
  bool SetWMIServices(IWbemServices* pServices);
  bool SetADServices(IADsContainer* ,unsigned);

protected:

  class XProvider : public CImpl<IWbemServices, CPolicyTemplate>
  {
    IWbemClassObject* GetPolicyTemplateClass(void);
    IWbemClassObject* GetPolicyTemplateInstance(void);

  public:

    XProvider(CPolicyTemplate* pObj) 
              : CImpl<IWbemServices, CPolicyTemplate>(pObj),
                m_pWMIPolicyClassObject(NULL)
                {}

    ~XProvider(void);
    
    HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
    HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
    HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
      {return WBEM_E_NOT_SUPPORTED;};
        
    HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) 
      {return WBEM_E_NOT_SUPPORTED;}

    HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

private:
    IWbemClassObject *m_pWMIPolicyClassObject;
    
    HRESULT DoMerge(IWbemServices* pNamespace,
                    const BSTR strObjectPath, 
                    IWbemContext __RPC_FAR *pCtx,
                    IWbemClassObject __RPC_FAR *pInParams,
                    IWbemClassObject __RPC_FAR *pOutParams,
                    IWbemObjectSink __RPC_FAR *pResponseHandler);

    HRESULT DoResolve(IWbemServices* pPolicyNamespace,
                      IWbemContext __RPC_FAR *pCtx,
                      IWbemClassObject __RPC_FAR *pInParams,
                      IWbemClassObject __RPC_FAR *pOutParams,
                      IWbemObjectSink __RPC_FAR *pResponseHandler);

    HRESULT ResolveMergeable(IWbemClassObject* pResolveMe,
							 IWbemClassObject* pClassDef,
                             IWbemServices* pPolicyNamespace,
                             IWbemContext __RPC_FAR* pCtx, 
                             IWbemClassObject __RPC_FAR* pOutParams, 
                             IWbemObjectSink __RPC_FAR* pResponseHandler);

    HRESULT DoSet(IWbemClassObject* pInParams,
                  IWbemClassObject* pOutParams, 
                  IWbemClassObject* pClass,
                  IWbemObjectSink*  pResponseHandler,
                  IWbemServices*    pPolicyNamespace);

    HRESULT DoSetRange(IWbemClassObject* pInParams,
                       IWbemClassObject* pOutParams, 
                       IWbemObjectSink*  pResponseHandler);

    HRESULT GetArray(VARIANT& vArray, SAFEARRAY*& pArray);
    HRESULT SetSettingInOurArray(const WCHAR* pName, IWbemClassObject* pRange, SAFEARRAY* pArray);



  } m_XProvider;

  friend XProvider;

  class XInit : public CImpl<IWbemProviderInit, CPolicyTemplate>
  {
  public:
    XInit(CPolicyTemplate* pObj)
          : CImpl<IWbemProviderInit, CPolicyTemplate>(pObj){}
    
    HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
  } m_XInit;

  friend XInit;

private:
  // pointer back to win management
  IWbemServices* m_pWMIMgmt; 

  // pointer to AD policy template table
  IADsContainer* m_pADMgmt[AD_MAX_CONTEXT];

  // templates for each type of object we support
  // NULL until we need it
  IWbemClassObject* m_pWMIPolicyClassObject;

  CComVariant
    m_vDsConfigContext,
    m_vDsLocalContext;

  // a little something to keep our threads from getting tangled
  // will use a single critical section to protect all instance variables
  CCritSec m_CS;   
};


#endif // __WBEM_POLICY_TEMPLATE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\range_real.cpp ===
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>
#include <sys/timeb.h>
#include <comdef.h>
#include <comutil.h>
#include <atlbase.h>

#include "windows.h"
#include "stdio.h"
#include "activeds.h"
#include "tchar.h"

#include "Utility.h"

/*
  Creates an AD based parameter object under the specified policy object from a CIM based obj.
*/

#define MAX_ATTR 8

HRESULT Range_Real_Verify(IWbemClassObject *pSrcParamObj)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1, v2, v3, vDefaultValue, v5, v6;

  CComPtr<IDirectoryObject>
    pDestParamObj;

  CComPtr<IDispatch>
    pDisp;

  unsigned short buf[20];

  long
    nOptArgs = 0,
    nArgs = 0;

  nArgs++;

  // **** PropertyName

  hres = pSrcParamObj->Get(g_bstrPropertyName, 0, &v1, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_BSTR == V_VT(&v1)) && (NULL != V_BSTR(&v1))) 
    nArgs++;
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetType

  hres = pSrcParamObj->Get(g_bstrTargetType, 0, &v3, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_UI1 == V_VT(&v3)) 
    nArgs++;
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetClass

  hres = pSrcParamObj->Get(g_bstrTargetClass, 0, &v2, NULL, NULL);
  if(FAILED(hres)) return hres;

  if((VT_BSTR != V_VT(&v2)) || (NULL == V_BSTR(&v2)))
  {
    if(CIM_OBJECT == V_UI1(&v3)) return WBEM_E_ILLEGAL_NULL;
  }
  nArgs++;

  // **** Default

  hres = pSrcParamObj->Get(g_bstrDefault, 0, &vDefaultValue, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_R8 == V_VT(&vDefaultValue)) 
  {
    nOptArgs++;
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** Min

  hres = pSrcParamObj->Get(g_bstrMin, 0, &v5, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_R8 == V_VT(&v5))
  {
    nOptArgs++;
    nArgs++;

    if(V_R8(&vDefaultValue) < V_R8(&v5))
      return WBEM_E_INVALID_PARAMETER;
  }

  // **** Max

  hres = pSrcParamObj->Get(g_bstrMax, 0, &v6, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_R8 == V_VT(&v6))
  {
    nOptArgs++;
    nArgs++;

    if(V_R8(&vDefaultValue) > V_R8(&v6))
      return WBEM_E_INVALID_PARAMETER;
  }

  // **** check that at least one of Min, Max or Default is set

  if((nOptArgs < 1) || (nArgs < 5))
    hres = WBEM_E_INVALID_CLASS;

  return hres;
}

/*
  Creates a CIM based parameter object within the specified policy object from an AD object.
*/

HRESULT Range_Real_ADToCIM(IWbemClassObject **ppDestParamObj,
                           IDirectorySearch *pDirSrch, 
                           ADS_SEARCH_HANDLE SearchHandle, 
                           IWbemServices *pDestCIM) 
{
  HRESULT
    hres = WBEM_S_NO_ERROR;

  VARIANT
    v1;

  ADS_SEARCH_COLUMN
    Column;

  unsigned long c1;

  CComPtr<IUnknown>
    pUnknown;

  CComPtr<IWbemClassObject>
    pDestParamObj,
    pClassDef;

  IWbemContext *pCtx = 0;

  // **** create empty range object

  hres = pDestCIM->GetObject(g_bstrClassRangeReal, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef == NULL) return WBEM_E_INVALID_CLASS;

  hres = pClassDef->SpawnInstance(0, ppDestParamObj);
  if(FAILED(hres)) return hres;
  pDestParamObj = *ppDestParamObj;
  if(pDestParamObj == NULL) return WBEM_E_INVALID_CLASS;

  // **** get object attributes

  // **** PropertyName

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADPropertyName, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrPropertyName, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetClass

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADTargetClass, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrTargetClass, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetType

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADTargetType, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_UI1;
    V_UI1(&v1) = char(_wtoi(Column.pADsValues->CaseExactString));
    hres = pDestParamObj->Put(g_bstrTargetType, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** default

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADInt8Default, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_R8;
    memcpy((void*)&v1.dblVal, (void*)&Column.pADsValues->LargeInteger.QuadPart, 8);
    hres = pDestParamObj->Put(g_bstrDefault, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** Min

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADInt8Min, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_R8;
    memcpy((void*)&v1.dblVal, (void*)&Column.pADsValues->LargeInteger.QuadPart, 8);
    hres = pDestParamObj->Put(g_bstrMin, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** Max

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADInt8Max, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_R8;
    memcpy((void*)&v1.dblVal, (void*)&Column.pADsValues->LargeInteger.QuadPart, 8);
    hres = pDestParamObj->Put(g_bstrMax, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  return WBEM_S_NO_ERROR;
}

/*
  Merges one or more CIM based policy objects of like type into
  a single CIM based policy object.
*/

HRESULT Range_Real_Merge(SafeArray<IUnknown*, VT_UNKNOWN> &ParamArray,
                         CComPtr<IWbemClassObject> &pClassObjMerged,
                         int &conflict)
{
  HRESULT
    hres = WBEM_E_FAILED;

  long
    c1, c2, c3, firstValidObj = -1;

  CComVariant
    vName,
    vType,
    vClass,
    vMergedMin,
    vMergedMax,
    vMergedDefault;

  // **** create arrays for Max, Min, and Default values

  SafeArray<double, VT_R8>
    Default(0, ParamArray.Size());

  // **** copy contents of each object into arrays

  c2 = -1;
  for(c1 = 0; c1 < ParamArray.Size(); c1++)
  {
    CComVariant
      vMin, vMax, vDefault;

    CComPtr<IWbemClassObject>
      pClassObjCurrent;

    if(NULL == ParamArray[c1])
      continue;
    else
    {
      c2 += 1;
      c3 = c2 - 1;

      if(firstValidObj < 0) 
        firstValidObj = c1;
    }

    // **** copy contents of each object into arrays

    hres = ParamArray[c1]->QueryInterface(IID_IWbemClassObject, (void **)&pClassObjCurrent);

    hres = pClassObjCurrent->Get(g_bstrMin, 0, &vMin, NULL, NULL);
    hres = pClassObjCurrent->Get(g_bstrMax, 0, &vMax, NULL, NULL);
    hres = pClassObjCurrent->Get(g_bstrDefault, 0, &vDefault, NULL, NULL);

    // **** record default value

    Default[c1] = vDefault.dblVal;

    // **** check for conflict

    if(IsEmpty(vMin) && IsEmpty(vMax))
    {
      conflict = c1;
      return WBEM_E_FAILED;
    }

    // **** find merged range

    if(!IsEmpty(vMin))
    {
      if(!IsEmpty(vMergedMin))
        vMergedMin = V_R8(&vMergedMin) > V_R8(&vMin) ? V_R8(&vMergedMin) : V_R8(&vMin);
      else
        vMergedMin = vMin;
    }

    if(!IsEmpty(vMax))
    {
      if(!IsEmpty(vMergedMax))
        vMergedMax = V_R8(&vMergedMax) < V_R8(&vMax) ? V_R8(&vMergedMax) : V_R8(&vMax);
      else
        vMergedMax = vMax;
    }

    // **** check for conflict

    if((!IsEmpty(vMergedMin)) && (!IsEmpty(vMergedMax)) && (V_R8(&vMergedMin) > V_R8(&vMergedMax)))
    {
      conflict = c1;
      return WBEM_E_FAILED;
    }

    // **** check for conflict

    if((!IsEmpty(vMergedMin)) && (!IsEmpty(vMergedMax)) && (V_R8(&vMergedMin) > V_R8(&vMergedMax)))
    {
      conflict = c1;
      return WBEM_E_FAILED;
    }
  }

  // **** wind back up merge stack and find most local default

  for(c1 = ParamArray.IndexMax(); IsEmpty(vMergedDefault) && (c1 >= ParamArray.IndexMin()); c1--)
  {
    if((NULL != ParamArray[c1]) && (Default[c1] <= V_R8(&vMergedMax)) && (Default[c1] >= V_R8(&vMergedMin)))
      vMergedDefault = Default[c1];
  }

  if(IsEmpty(vMergedDefault))
  {
    if(!IsEmpty(vMergedMin))
      vMergedDefault = vMergedMin;
    else
      vMergedDefault = vMergedMax;
  }

  // **** create new merged range object

  if(firstValidObj >= 0)
  {
    CComPtr<IWbemClassObject>
      pFirstValidObj;

    hres = ParamArray[firstValidObj]->QueryInterface(IID_IWbemClassObject, (void **)&pFirstValidObj);
    hres = pFirstValidObj->SpawnInstance(0, &pClassObjMerged);

    hres = pFirstValidObj->Get(g_bstrPropertyName, 0, &vName, NULL, NULL);
    hres = pClassObjMerged->Put(g_bstrPropertyName, 0, &vName, 0);

    hres = pFirstValidObj->Get(g_bstrTargetType, 0, &vType, NULL, NULL);
    hres = pClassObjMerged->Put(g_bstrTargetType, 0, &vType, 0);

    hres = pFirstValidObj->Get(g_bstrTargetClass, 0, &vClass, NULL, NULL);
    hres = pClassObjMerged->Put(g_bstrTargetClass, 0, &vClass, 0);

    hres = pClassObjMerged->Put(g_bstrMin, 0, &vMergedMin, 0);
    hres = pClassObjMerged->Put(g_bstrMax, 0, &vMergedMax, 0);
    hres = pClassObjMerged->Put(g_bstrDefault, 0, &vMergedDefault, 0);
  }

  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\policy.cpp ===
#include <wbemidl.h>
#include <wbemprov.h>
#include <wbemtime.h>
#include <atlbase.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>

#include <buffer.h>

#include <genlex.h>
#include <qllex.h>
#include <ql.h>

#include "objpath.h"
#include "iads.h"
#include "adshlp.h"

#include "Utility.h"


#define MAX_ATTR 25

//***************************************************************************
// Function:   Init
//
// Purpose:   1 - Create an instance of the WbemLocator interface
//            2 - Use the pointer returned in step two to connect to
//                the server using the specified namespace.
//***************************************************************************

HRESULT ConnectToNameSpace(IWbemServices **ppIWbemServices, WCHAR *pNamespace)
{
  HRESULT dwRes;
  IWbemLocator *pIWbemLocator = NULL;

  CReleaseMe
    RelpIWbemLocator(pIWbemLocator);

  // **** Create an instance of the WbemLocator interface

  dwRes = CoCreateInstance(CLSID_WbemLocator,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IWbemLocator,
                           (LPVOID *) &pIWbemLocator);

  // **** connect to the server using the passed in namespace.

  if(SUCCEEDED(dwRes))
  {
    dwRes = pIWbemLocator->ConnectServer(QString(pNamespace),  // Namespace
                                       NULL,                 // Userid
                                       NULL,                 // PW
                                       NULL,                 // Locale
                                       NULL,                 // flags
                                       NULL,                 // Authority
                                       NULL,                 // Context
                                       ppIWbemServices);
  }

  return dwRes;
}

/*********************************************************************
************** Active Directory Methods ******************************
*********************************************************************/

HRESULT Policy_CIMToAD(long lFlags, IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer)
{
    HRESULT 
      hres = WBEM_S_NO_ERROR;

    CComVariant
      vPolicyType,
      v[MAX_ATTR];

    long 
      lIsSimple = 0,
      c1,
      nOptArgs = 0,
      nArgs = 0;
    
  DWORD
    dwReturn;

  CComQIPtr<IDirectoryObject, &IID_IDirectoryObject>
    pDestPolicyObj,
    pDirObj;

  BYTE defaultBuffer[2048];
  ULONG bWritten = 0;
  LARGE_INTEGER offset;

  CBuffer
    ClassDefBuffer(defaultBuffer, 2048, FALSE);

  CIMTYPE vtType1;
    
  CComPtr<IDispatch>
      pDisp;
    
  CComPtr<IWbemClassObject>
      pParamObj;
    
  CComQIPtr<IADsContainer, &IID_IADsContainer>
    pADsContainer = pDestContainer;

  CComQIPtr<IADs, &IID_IADs>
    pADsLegacyObj;

  ADSVALUE
    AdsValue[MAX_ATTR];

  ADS_ATTR_INFO 
    attrInfo[MAX_ATTR];

  WBEMTime
    wtCurrentTime;

  SYSTEMTIME
    SystemTime;

  GetSystemTime(&SystemTime);

  wtCurrentTime = SystemTime;

    // **** determine which class we are putting (Simple or Mergeable)

    hres = pSrcPolicyObj->Get(L"__CLASS", 0, &vPolicyType, NULL, NULL);
    if(FAILED(hres) || (NULL == V_BSTR(&vPolicyType))) return hres;
    if(0 == _wcsicmp(g_bstrClassSimplePolicy, V_BSTR(&vPolicyType)))
      lIsSimple = 1;

    // **** set policy object type

    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     g_bstrADObjectClass, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs], 
                     1);

    AdsValue[nArgs].CaseIgnoreString = g_bstrADClassSimplePolicy;
    int lTypeIndex = nArgs++;
    
    // **** security descriptor

    PSECURITY_DESCRIPTOR
      pSD = GetADSecurityDescriptor(pDestContainer);

    if(NULL == pSD)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: could not create security descriptor for policy object\n"));
      return WBEM_E_OUT_OF_MEMORY;
    }

    CNtSecurityDescriptor
      cSD(pSD, TRUE);

    if(CNtSecurityDescriptor::NoError != cSD.GetStatus()) return WBEM_E_FAILED;

    hres = RestrictSecurityDescriptor(cSD);

    AdsValue[nArgs].SecurityDescriptor.dwLength = cSD.GetSize();
    AdsValue[nArgs].SecurityDescriptor.lpValue = (LPBYTE) cSD.GetPtr();

    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     L"ntSecurityDescriptor", 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_NT_SECURITY_DESCRIPTOR, 
                     &AdsValue[nArgs], 
                     1);

    nArgs++;

    // **** ID
    
    hres = pSrcPolicyObj->Get(g_bstrID, 0, &v[nArgs], NULL, NULL);
    if(FAILED(hres)) return hres;
    if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
    {
      Init_AdsAttrInfo(&attrInfo[nArgs], 
                       g_bstrADID, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs], 
                       1);

      AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);
    }
    else
        return WBEM_E_ILLEGAL_NULL;
    int lIDIndex = nArgs++;

  // **** if object already exists, get a pointer to it

  CComBSTR
    PolicyName(L"CN=");

  PolicyName.Append(AdsValue[lIDIndex].CaseIgnoreString);

  // **** LEGACY code to delete existing mergeable policy AD objects

  if(SUCCEEDED(hres = pADsContainer->GetObject(NULL, PolicyName, &pDisp)))
  {
    pADsLegacyObj = pDisp;

    CComBSTR
      bstrClassName;

    hres = pADsLegacyObj->get_Class(&bstrClassName);
    if(FAILED(hres)) return hres;

    if(0 != _wcsicmp(g_bstrADClassMergeablePolicy, bstrClassName))
      pADsLegacyObj.Release();
  }

    // **** Description
    
    hres = pSrcPolicyObj->Get(g_bstrDescription, 0, &v[nArgs], NULL, NULL);
    if(FAILED(hres)) return hres;
    if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
    {
        Init_AdsAttrInfo(&attrInfo[nArgs], 
                         g_bstrADDescription, 
                         ADS_ATTR_UPDATE, 
                         ADSTYPE_CASE_IGNORE_STRING, 
                         &AdsValue[nArgs], 
                         1);

        AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

        nArgs++;
    }
    
    // **** TargetType
    
    hres = pSrcPolicyObj->Get(g_bstrTargetType, 0, &v[nArgs], NULL, NULL);
    if(FAILED(hres)) return hres;

    if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
    {
      Init_AdsAttrInfo(&attrInfo[nArgs], 
                       g_bstrADTargetType, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs], 
                       1);

      AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

      nArgs++;
    }
    
    // **** Name
    
    hres = pSrcPolicyObj->Get(g_bstrName, 0, &v[nArgs], NULL, NULL);
    if(FAILED(hres)) return hres;

    if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
    {
      Init_AdsAttrInfo(&attrInfo[nArgs], 
                       g_bstrADName, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs], 
                       1);

      AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

      nArgs++;
    }
    
    // **** TargetNameSpace
    
    hres = pSrcPolicyObj->Get(g_bstrTargetNameSpace, 0, &v[nArgs], NULL, NULL);
    if(FAILED(hres)) return hres;

    if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
    {
      Init_AdsAttrInfo(&attrInfo[nArgs], 
                       g_bstrADTargetNameSpace, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs], 
                       1);

      AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

      nArgs++;
    }
    else
      return WBEM_E_ILLEGAL_NULL;
    
    // **** TargetClass
    
    hres = pSrcPolicyObj->Get(g_bstrTargetClass, 0, &v[nArgs], NULL, NULL);
    if(FAILED(hres)) return hres;

    if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
    {
      Init_AdsAttrInfo(&attrInfo[nArgs], 
                       g_bstrADTargetClass, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs], 
                       1);

      AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

      nArgs++;
    }
    
    // **** TargetPath
    
    if(lIsSimple)
    {
      CComPtr<IWbemClassObject>
        pTargetObj;

      CComVariant
       vTargetObj;

      hres = pSrcPolicyObj->Get(g_bstrTargetObject, 0, &vTargetObj, NULL, NULL);
      if(FAILED(hres)) return hres;
      if((vTargetObj.vt != VT_UNKNOWN) || (vTargetObj.punkVal == NULL)) 
        return WBEM_E_ILLEGAL_NULL;

      hres = vTargetObj.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pTargetObj);
      if(FAILED(hres)) return hres;

      hres = pTargetObj->Get(L"__RELPATH", 0, &v[nArgs], NULL, NULL);
      if(FAILED(hres)) return hres;
      if ((v[nArgs].vt != VT_BSTR) || (v[nArgs].bstrVal == NULL))
        return WBEM_E_ILLEGAL_NULL;
    }
    else
    {
      hres = pSrcPolicyObj->Get(g_bstrTargetPath, 0, &v[nArgs], NULL, NULL);
      if(FAILED(hres)) return hres;
    }

    {
      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      ParsedObjectPath
        *pParsedObjectPath = NULL;

      if(ObjPath.NoError != ObjPath.Parse(v[nArgs].bstrVal, &pParsedObjectPath))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error target path: %S\n", v[nArgs].bstrVal));
        return WBEM_E_INVALID_PARAMETER;
      }

      if(NULL != pParsedObjectPath) 
        ObjPath.Free(pParsedObjectPath);
    }

    if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
    {
      Init_AdsAttrInfo(&attrInfo[nArgs], 
                       g_bstrADTargetPath, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs], 
                       1);

      AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

      nArgs++;
    }

    // **** NormalizedClass
    
    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     g_bstrADNormalizedClass, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs], 
                     1);

    if(lIsSimple)
      AdsValue[nArgs].CaseIgnoreString = g_bstrADClassSimplePolicy;
    else
      AdsValue[nArgs].CaseIgnoreString = g_bstrADClassMergeablePolicy;
    nArgs++;
    
    // **** SourceOrganization
    
    hres = pSrcPolicyObj->Get(g_bstrSourceOrganization, 0, &v[nArgs], NULL, NULL);
    if(FAILED(hres)) return hres;

    if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
    {
      Init_AdsAttrInfo(&attrInfo[nArgs], 
                       g_bstrADSourceOrganization, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs], 
                       1);

      AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

      nArgs++;
    }
    
    // **** Author
    
    hres = pSrcPolicyObj->Get(g_bstrAuthor, 0, &v[nArgs], NULL, NULL);
    if(FAILED(hres)) return hres;

    if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
    {
      Init_AdsAttrInfo(&attrInfo[nArgs], 
                       g_bstrADAuthor, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs], 
                       1);

      AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

      nArgs++;
    }
    
    // **** ChangeDate
    
    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     g_bstrADChangeDate, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs], 
                     1);

    AdsValue[nArgs].CaseIgnoreString = wtCurrentTime.GetDMTF(FALSE);

    nArgs++;
    
    // **** CreationDate
    
  if(NULL == pDisp.p)
  {
    AdsValue[nArgs].CaseIgnoreString = wtCurrentTime.GetDMTF(FALSE);

    Init_AdsAttrInfo(&attrInfo[nArgs],
                   g_bstrADCreationDate,
                   ADS_ATTR_UPDATE,
                   ADSTYPE_CASE_IGNORE_STRING,
                   &AdsValue[nArgs],
                   1);

    nArgs++;
  }

  // **** LEGACY code to delete existing mergeable policy AD objects

  else if(NULL != pADsLegacyObj.p)
  {
    VARIANT
      vCreationDate;

    hres = pADsLegacyObj->Get(g_bstrADCreationDate, &vCreationDate);
    if(FAILED(hres)) return hres;

    AdsValue[nArgs].CaseIgnoreString = vCreationDate.bstrVal;

    Init_AdsAttrInfo(&attrInfo[nArgs],
                  g_bstrADCreationDate,
                  ADS_ATTR_UPDATE,
                  ADSTYPE_CASE_IGNORE_STRING,
                  &AdsValue[nArgs],
                  1);

    nArgs++;
  }

   // **** Target Object/Range Settings

   offset.LowPart = 0;
   offset.HighPart = 0;

   hres = ClassDefBuffer.Seek(offset, STREAM_SEEK_SET, NULL);
   if(FAILED(hres)) return hres;

   if(lIsSimple)
   {
     hres = pSrcPolicyObj->Get(g_bstrTargetObject, 0, &v[nArgs], NULL, NULL);
     if(FAILED(hres)) return hres;

     hres = CoMarshalInterface(&ClassDefBuffer, 
                               IID_IWbemClassObject, 
                               v[nArgs].punkVal, 
                               MSHCTX_NOSHAREDMEM, 
                               NULL, 
                               MSHLFLAGS_TABLESTRONG);

     if(FAILED(hres)) return hres;
   }
   else
   {
     CComVariant
       vRangeParams;

     SafeArray<IUnknown*, VT_UNKNOWN>
       Array1;

     wchar_t
       swArraySize[20];

     hres = pSrcPolicyObj->Get(g_bstrRangeSettings, 0, &vRangeParams, NULL, NULL);
     if(FAILED(hres)) return hres;
     if(vRangeParams.vt != (VT_ARRAY | VT_UNKNOWN)) return WBEM_E_INVALID_PARAMETER;

     Array1 = &vRangeParams;
        
     _itow(Array1.Size(), swArraySize, 10);
     ClassDefBuffer.Write(swArraySize, sizeof(wchar_t) * 20, NULL);

     for(c1 = 0; c1 < Array1.Size(); c1++)
     {
       CComVariant
         vParamType;

       CComQIPtr<IWbemClassObject, &IID_IWbemClassObject>
         pParamObj = Array1[c1];

       // **** verify valid range parameter

       hres = pParamObj->Get(L"__CLASS", 0, &vParamType, NULL, NULL);
 
       if(0 == _wcsicmp(V_BSTR(&vParamType), g_bstrClassRangeSint32))
         hres = Range_Sint32_Verify(pParamObj);
       else if(0 == _wcsicmp(V_BSTR(&vParamType), g_bstrClassRangeUint32))
         hres = Range_Uint32_Verify(pParamObj);
       else if(0 == _wcsicmp(V_BSTR(&vParamType), g_bstrClassRangeReal))
         hres = Range_Real_Verify(pParamObj);
       else if(0 == _wcsicmp(V_BSTR(&vParamType), g_bstrClassSetSint32))
         hres = Set_Sint32_Verify(pParamObj);
       else if(0 == _wcsicmp(V_BSTR(&vParamType), g_bstrClassSetUint32))
         hres = Set_Uint32_Verify(pParamObj);
       else if(0 == _wcsicmp(V_BSTR(&vParamType), g_bstrClassSetString))
         hres = Set_String_Verify(pParamObj);
       else
         hres = Param_Unknown_Verify(pParamObj);

       if(FAILED(hres)) return hres;

       // **** pack range parameter into TargetObject

       hres = CoMarshalInterface(&ClassDefBuffer, IID_IUnknown, Array1[c1], 
                                 MSHCTX_NOSHAREDMEM, NULL, MSHLFLAGS_TABLESTRONG);
       if(FAILED(hres)) return hres;
     }
   }

   Init_AdsAttrInfo(&attrInfo[nArgs], 
                    g_bstrADTargetObject, 
                    ADS_ATTR_UPDATE, 
                    ADSTYPE_OCTET_STRING, 
                    &AdsValue[nArgs], 
                    1);

   AdsValue[nArgs].OctetString.dwLength = ClassDefBuffer.GetIndex();
   AdsValue[nArgs].OctetString.lpValue = ClassDefBuffer.GetRawData();
   nArgs++;

  // **** create AD policy object
    
  if(NULL != pDisp.p)
  {
    if(WBEM_FLAG_CREATE_ONLY & lFlags) return WBEM_E_ALREADY_EXISTS;

    if(NULL != pADsLegacyObj.p)
    {
      CComQIPtr<IADsDeleteOps, &IID_IADsDeleteOps>
        pDelObj = pADsLegacyObj;

      pDisp = NULL;
      pADsLegacyObj.Release();
      pDelObj->DeleteObject(0);

      hres = pDestContainer->CreateDSObject(PolicyName, attrInfo, nArgs, &pDisp);
      if(FAILED(hres)) return hres;
    }
    else
    {
      pDirObj = pDisp;
  
      hres = pDirObj->SetObjectAttributes(&attrInfo[2], nArgs - 2, &dwReturn);
      if(FAILED(hres)) return hres;
    }
  }
  else
  {
    if(WBEM_FLAG_UPDATE_ONLY & lFlags)
      return WBEM_E_NOT_FOUND;

    hres = pDestContainer->CreateDSObject(PolicyName, attrInfo, nArgs, &pDisp);
    if(FAILED(hres)) return hres;
  }

  return WBEM_S_NO_ERROR;
}

HRESULT Policy_ADToCIM(IWbemClassObject * *ppDestPolicyObj,
                       IDirectoryObject *pSrcPolicyObj, 
                       IWbemServices *pDestCIM)
{
    HRESULT 
      hres = WBEM_S_NO_ERROR;

    CComVariant
      v1;
 
    wchar_t* AttrNames[] = 
    { 
        g_bstrADID, 
        g_bstrADDescription,
        g_bstrADName,
        g_bstrADTargetNameSpace, 
        g_bstrADTargetClass, 
        g_bstrADTargetPath, 
        g_bstrADTargetType, 
        g_bstrADNormalizedClass,
        g_bstrADSourceOrganization, 
        g_bstrADAuthor,
        g_bstrADChangeDate,
        g_bstrADCreationDate,
        g_bstrADTargetObject
    };
    
    wchar_t* AttrType[] =
    {
      g_bstrADNormalizedClass
    };

    wchar_t* AttrTypeLegacy[] =
    {
      g_bstrADObjectClass
    };

  BYTE defaultBuffer[2048];
  ULONG bWritten = 0;
  LARGE_INTEGER offset;

  CBuffer
    ClassDefBuffer(defaultBuffer, 2048, FALSE);

    ADsStruct<ADS_ATTR_INFO>
        pAttrTypeInfo,
        pAttrTypeInfoLegacy,
        pAttrInfo;
    
    unsigned long
        ulIsLegacy = 0,
        ulIsSimple = 0,
        c1, 
        dwReturn;
    
    CComPtr<IUnknown>
        pUnknown;
    
    CComPtr<IWbemClassObject>
        pClassDef,
        pDestPolicyObj,
        pDestParamObj;
    
    CComPtr<IWbemContext>
        pCtx;
    
    ADsStruct<ADS_OBJECT_INFO>
        pInfo;
 
    // **** determine policy object type

    hres = pSrcPolicyObj->GetObjectAttributes(AttrTypeLegacy, 1, &pAttrTypeInfoLegacy, &dwReturn);
    if(FAILED(hres)) return hres;
    if(pAttrTypeInfoLegacy == NULL) return WBEM_E_NOT_FOUND;
    if(0 == _wcsicmp(g_bstrADClassMergeablePolicy, (pAttrTypeInfoLegacy->pADsValues + pAttrTypeInfoLegacy->dwNumValues - 1)->CaseIgnoreString))
      ulIsLegacy = 1;
    else
    {
      hres = pSrcPolicyObj->GetObjectAttributes(AttrType, 1, &pAttrTypeInfo, &dwReturn);
      if(FAILED(hres)) return hres;
      if(pAttrTypeInfo == NULL) return WBEM_E_NOT_FOUND;
      if(0 == _wcsicmp(g_bstrADClassSimplePolicy, (pAttrTypeInfo->pADsValues + pAttrTypeInfo->dwNumValues - 1)->CaseIgnoreString))
        ulIsSimple = 1;

      else if(0 == _wcsicmp(g_bstrClassMergeablePolicy, (pAttrTypeInfo->pADsValues + pAttrTypeInfo->dwNumValues - 1)->CaseIgnoreString))
        ulIsSimple = 1;
    }

    // **** create empty class policy
    
    if(ulIsSimple)
      hres = pDestCIM->GetObject(g_bstrClassSimplePolicy, 0, pCtx, &pClassDef, NULL);
    else
      hres = pDestCIM->GetObject(g_bstrClassMergeablePolicy, 0, pCtx, &pClassDef, NULL);

    if(FAILED(hres)) return hres;
    if(pClassDef == NULL) return WBEM_E_FAILED;
    
    hres = pClassDef->SpawnInstance(0, ppDestPolicyObj);
    if(FAILED(hres)) return hres;
    pDestPolicyObj = *ppDestPolicyObj;
    if(pDestPolicyObj == NULL) return WBEM_E_INVALID_CLASS;
    
    // **** get object attributes

    hres = pSrcPolicyObj->GetObjectAttributes(AttrNames, (ulIsLegacy ? 12 : 13), &pAttrInfo, &dwReturn);
    if(FAILED(hres)) return hres;
    if(pAttrInfo == NULL) return WBEM_E_NOT_FOUND;
    
    // **** Domain
    
    hres = pSrcPolicyObj->GetObjectInformation(&pInfo);
    if(SUCCEEDED(hres) && (pInfo != NULL))
    {
      QString
        DomainName;

      hres = DomainNameFromDistName(DomainName, QString(pInfo->pszObjectDN));

      v1 = (wchar_t*)DomainName;
      hres = pDestPolicyObj->Put(g_bstrDomain, 0, &v1, 0);
    }

    if(pInfo == NULL) return WBEM_E_FAILED;
    if(FAILED(hres)) return hres;
    
    for(c1 = 0; c1 < dwReturn; c1++)
    {
        // **** ID
        
        if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADID))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrID, 0, &v1, 0);
        }
        
        // **** Description
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADDescription))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrDescription, 0, &v1, 0);
        }
        
        // **** TargetType
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADTargetType))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrTargetType, 0, &v1, 0);
        }
        
        // **** Name
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADName))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrName, 0, &v1, 0);
        }
        
        // **** TargetNameSpace
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADTargetNameSpace))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrTargetNameSpace, 0, &v1, 0);
        }
        
        // **** TargetClass
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADTargetClass))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrTargetClass, 0, &v1, 0);
        }
        
        // **** TargetPath
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADTargetPath))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrTargetPath, 0, &v1, 0);
        }
        
        // **** SourceOrganization
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADSourceOrganization))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrSourceOrganization, 0, &v1, 0);
        }
        
        // **** Author
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADAuthor))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrAuthor, 0, &v1, 0);
        }
        
        // **** ChangeDate
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADChangeDate))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrChangeDate, 0, &v1, 0);
            // dates are easy to mess up, we won't bail out for it
            if (hres == WBEM_E_TYPE_MISMATCH)
            {
                ERRORTRACE((LOG_ESS, "POLICMAN: Type mismatch on date property\n"));
                hres = WBEM_S_NO_ERROR;
            }
        }
        
        // **** CreationDate
        
        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADCreationDate))
        {
            v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
            hres = pDestPolicyObj->Put(g_bstrCreationDate, 0, &v1, 0);

            // dates are easy to mess up, we won't bail out for it
            if (hres == WBEM_E_TYPE_MISMATCH)
            {
                ERRORTRACE((LOG_ESS, "POLICMAN: Type mismatch on date property\n"));
                hres = WBEM_S_NO_ERROR;
            }
        }

        // **** TargetObject

        else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADTargetObject))
        {
          ADSVALUE
            *pADsObj = (pAttrInfo + c1)->pADsValues;

          offset.LowPart = 0;
          offset.HighPart = 0;

          if(NULL == pADsObj) continue;

          hres = ClassDefBuffer.Seek(offset, STREAM_SEEK_SET, NULL);
          if(SUCCEEDED(hres))
          { 
            hres = ClassDefBuffer.Write(pADsObj->OctetString.lpValue, pADsObj->OctetString.dwLength, &bWritten);
            if(SUCCEEDED(hres))
            {
              hres = ClassDefBuffer.Seek(offset, STREAM_SEEK_SET, NULL);
              if(SUCCEEDED(hres))
              {
                if(ulIsSimple)
                {
                  hres = CoUnmarshalInterface(&ClassDefBuffer, IID_IWbemClassObject, (void**)&pDestParamObj);
                  if(SUCCEEDED(hres))
                  {
                    v1 = pDestParamObj;
                    hres = pDestPolicyObj->Put(g_bstrTargetObject, 0, &v1, 0);
                  }
                }
                else if(! ulIsLegacy)
                {
                  SafeArray<IUnknown*, VT_UNKNOWN>
                    Array1;

                  IUnknown
                    *pUnknown = NULL;

                  wchar_t
                    swArraySize[20];

                  ClassDefBuffer.Read(swArraySize, sizeof(wchar_t) * 20, NULL);
                  int nElts = _wtoi(swArraySize);

                  while(nElts-- && SUCCEEDED(hres = CoUnmarshalInterface(&ClassDefBuffer, IID_IUnknown, (void**)&pUnknown)))
                  {
                    Array1.ReDim(0, Array1.Size() + 1);
                    Array1[Array1.IndexMax()] = pUnknown;
                    pUnknown = NULL;
                  }

                  if(0 < Array1.Size())
                  {
                    V_VT(&v1) = (VT_UNKNOWN | VT_ARRAY);
                    V_ARRAY(&v1) = Array1.Data();
                    hres = pDestPolicyObj->Put(g_bstrRangeSettings, 0, &v1, 0);
                  }
                }
              }
            }
          }
        }

        if(FAILED(hres)) return hres;

        VariantClear(&v1);
    }

  if(ulIsLegacy)
  {
    CComQIPtr<IDirectorySearch, &IID_IDirectorySearch>
      pDirSrch;

    ADS_SEARCH_HANDLE
        SearchHandle;
    
    ADS_SEARCH_COLUMN
        SearchColumn;
    
    // **** now, get RangeSettings that are the children of this policy object in AD

    pDirSrch = pSrcPolicyObj;

    hres = pDirSrch->ExecuteSearch(L"(cn=*)", NULL, -1, &SearchHandle);
    if(FAILED(hres)) return hres;

    while(S_OK == (hres = pDirSrch->GetNextRow(SearchHandle)))
    {
      hres = pDirSrch->GetColumn(SearchHandle, g_bstrADObjectClass, &SearchColumn);
      if(FAILED(hres)) return hres;

      int x = SearchColumn.dwNumValues - 1;

      if(0 == _wcsicmp((SearchColumn.pADsValues + x)->CaseIgnoreString, g_bstrADClassRangeSint32))
          hres = Range_Sint32_ADToCIM(&pDestParamObj, pDirSrch, SearchHandle, pDestCIM);
      else if(0 == _wcsicmp((SearchColumn.pADsValues + x)->CaseIgnoreString, g_bstrADClassRangeUint32))
          hres = Range_Uint32_ADToCIM(&pDestParamObj, pDirSrch, SearchHandle, pDestCIM);
      else if(0 == _wcsicmp((SearchColumn.pADsValues + x)->CaseIgnoreString, g_bstrADClassRangeReal))
          hres = Range_Real_ADToCIM(&pDestParamObj, pDirSrch, SearchHandle, pDestCIM);
      else if(0 == _wcsicmp((SearchColumn.pADsValues + x)->CaseIgnoreString, g_bstrADClassSetSint32))
          hres = Set_Sint32_ADToCIM(&pDestParamObj, pDirSrch, SearchHandle, pDestCIM);
      else if(0 == _wcsicmp((SearchColumn.pADsValues + x)->CaseIgnoreString, g_bstrADClassSetUint32))
          hres = Set_Uint32_ADToCIM(&pDestParamObj, pDirSrch, SearchHandle, pDestCIM);
      else if(0 == _wcsicmp((SearchColumn.pADsValues + x)->CaseIgnoreString, g_bstrADClassSetString))
          hres = Set_String_ADToCIM(&pDestParamObj, pDirSrch, SearchHandle, pDestCIM);
      else if(0 == _wcsicmp((SearchColumn.pADsValues + x)->CaseIgnoreString, g_bstrADClassParamUnknown))
          hres = Param_Unknown_ADToCIM(&pDestParamObj, pDirSrch, &SearchHandle, pDestCIM);

      // **** place pDestParamObj in pDestPolicyObj

      if(SUCCEEDED(hres) && (pDestParamObj != NULL))
      {
          hres = pDestPolicyObj->Get(g_bstrRangeSettings, 0, &v1, NULL, NULL);
          if(FAILED(hres)) return hres;

          SafeArray<IUnknown*, VT_UNKNOWN>
              ValidValues(&v1);

          hres = pDestParamObj.QueryInterface(&pUnknown);
          if(FAILED(hres)) return hres;
          pDestParamObj = NULL;

          ValidValues.ReDim(0, ValidValues.Size() + 1);
          ValidValues[ValidValues.IndexMax()] = pUnknown.Detach();

          VariantClear(&v1);
          V_VT(&v1) = (VT_ARRAY | ValidValues.Type());
          V_ARRAY(&v1) = ValidValues.Data();
          hres = pDestPolicyObj->Put(g_bstrRangeSettings, 0, &v1, 0);
          if(FAILED(hres)) return hres;

          VariantClear(&v1);
      }

      pDirSrch->FreeColumn(&SearchColumn);
    }

    pDirSrch->CloseSearchHandle(SearchHandle);
  }

  return WBEM_S_NO_ERROR;
}

inline int _NextIndex(long &cIndex, SafeArray<long, VT_I4> &ValidObjs)
{
  if((cIndex < -1) || (cIndex >= ValidObjs.Size()))
    return 0;

  while((++cIndex < ValidObjs.Size()) && (ValidObjs[cIndex] == FALSE));

  if(cIndex >= ValidObjs.Size())
    return 0;

  return 1;
}

HRESULT Policy_Merge(SafeArray<IUnknown*, VT_UNKNOWN> &PolicyArray, 
                     CComPtr<IWbemClassObject> &pMergedPolicy,
                     IWbemServices *pDestCIM)
{
  HRESULT 
    hres = WBEM_E_FAILED;

  ULONG 
    nValidObjects = 0;

  CComVariant
    vFirstPolicyType,
    vPolicyAttr;

  long 
    boolFinished = FALSE, boolNotMergeable = FALSE, c1, c2, c3;

  CComPtr<IWbemClassObject>
    pFirstPolicy,
    pClassRangeParam,
    pClassInParams,
    pInParams;

  SafeArray<BSTR, VT_BSTR>
    RangeNames;

  if(PolicyArray.Size() < 1)
    return NULL;

  DEBUGTRACE((LOG_ESS, "POLICMAN(merge): # of objects to merge: %d\n", PolicyArray.Size()));

  // **** get input parameter for MSFT_RangeParam.Merge()

  hres = pDestCIM->GetObject(g_bstrClassRangeParam, 0, NULL, &pClassRangeParam, NULL);
  if(FAILED(hres)) return hres;

  hres = pClassRangeParam->GetMethod(L"Merge", 0, &pClassInParams, NULL);
  if(FAILED(hres)) return hres;

  hres = pClassInParams->SpawnInstance(0, &pInParams);
  if(FAILED(hres)) return hres;

  // **** check to see if 1st obj is Simple Policy Template

  if((0 == PolicyArray.Size()) || (NULL == PolicyArray[0])) return WBEM_E_INVALID_PARAMETER;
  hres = PolicyArray[0]->QueryInterface(IID_IWbemClassObject, (void **)&pFirstPolicy);
  if(FAILED(hres)) return WBEM_E_FAILED;

  if(pFirstPolicy->InheritsFrom(L"MSFT_PolicyTemplate") != WBEM_S_NO_ERROR)
    return WBEM_E_INVALID_PARAMETER;

  // **** create array of Policy objects to be merged

  SafeArray<long, VT_I4>
    ValidPolicyObjects(0, PolicyArray.Size());

  hres = pFirstPolicy->Get(L"__CLASS", 0, &vFirstPolicyType, NULL, NULL);
  if(FAILED(hres)) return WBEM_E_FAILED;

  if((_wcsicmp(g_bstrClassMergeablePolicy, vFirstPolicyType.bstrVal) == 0) ||
     (pFirstPolicy->InheritsFrom(g_bstrClassMergeablePolicy) == WBEM_S_NO_ERROR))
  {
    for(c1 = 0; c1 < PolicyArray.Size(); c1++)
    {
      if(NULL != PolicyArray[c1])
      {
        CComVariant
          vPolicyType,
          vPolicyGenus;

        CComPtr<IWbemClassObject>
          pCurrentPolicy;

        hres = PolicyArray[c1]->QueryInterface(IID_IWbemClassObject, (void**)&pCurrentPolicy);
        if(FAILED(hres)) return WBEM_E_FAILED;

        hres = pCurrentPolicy->Get(L"__CLASS", 0, &vPolicyType, NULL, NULL);
        if(FAILED(hres)) return WBEM_E_FAILED;

        hres = pCurrentPolicy->Get(L"__GENUS", 0, &vPolicyGenus, NULL, NULL);
        if(FAILED(hres)) return WBEM_E_FAILED;
        if(0x2 != vPolicyGenus.lVal) 
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Policy Object %d is not an instance\n", c1));
          return WBEM_E_INVALID_PARAMETER;
        }

        if((_wcsicmp(g_bstrClassMergeablePolicy, vPolicyType.bstrVal) == 0) ||
           (pCurrentPolicy->InheritsFrom(g_bstrClassMergeablePolicy) == WBEM_S_NO_ERROR))
        {
          ValidPolicyObjects[c1] = TRUE;
          nValidObjects++;
        }
        else
          ValidPolicyObjects[c1] = FALSE;
      }
      else
        ValidPolicyObjects[c1] = FALSE;
    }

    DEBUGTRACE((LOG_ESS, "POLICMAN(merge): %d out of %d template objects are of type MSFT_MergeablePolicyTemplate\n", nValidObjects, PolicyArray.Size()));
  }
  else
  {
    boolFinished = TRUE;
    boolNotMergeable = TRUE;

    DEBUGTRACE((LOG_ESS, "POLICMAN(merge): 1st object is not mergeable policy template object\n"));
  }

  // **** create empty array for merged range parameters, one element per parameter name

  SafeArray<IUnknown*, VT_UNKNOWN>
    MergedParameters;

  // ****  build list of merged range params and place them in MergedParameters

  while((FALSE == boolFinished) && (0 < nValidObjects))
  {
    DEBUGTRACE((LOG_ESS, "POLICMAN(merge): ---- Start Merge Cycle ----\n"));

    // **** get list of attribute names from all policy objects

    c1 = -1;
    while(_NextIndex(c1, ValidPolicyObjects))
    {
      CComQIPtr<IWbemClassObject, &IID_IWbemClassObject>
        pCurrentPolicy;

      CComVariant
        vRangeSettings;

      pCurrentPolicy = PolicyArray[c1];

      hres = pCurrentPolicy->Get(g_bstrRangeSettings, 0, &vRangeSettings, NULL, NULL);
      if(FAILED(hres)) return hres;

      SafeArray<IUnknown*, VT_UNKNOWN>
        RangeSettings(&vRangeSettings);

      for(c2 = 0; c2 < RangeSettings.Size(); c2++)
      {
        CComQIPtr<IWbemClassObject, &IID_IWbemClassObject>
          pCurrentRange;

        CComVariant
          vRangeName;

        pCurrentRange = RangeSettings[c2];

        hres = pCurrentRange->Get(g_bstrPropertyName, 0, &vRangeName, NULL, NULL);
        if(FAILED(hres)) return hres;

        c3 = -1; 
        while((++c3 < RangeNames.Size()) && (0 != _wcsicmp(V_BSTR(&vRangeName), RangeNames[c3])));

        if(c3 > RangeNames.IndexMax())
        {
          RangeNames.ReDim(0, RangeNames.Size() + 1);
          RangeNames[RangeNames.IndexMax()] = SysAllocString(V_BSTR(&vRangeName));
        }
      }
    }

    DEBUGTRACE((LOG_ESS, "POLICMAN(merge): Merging %d parameters accross %d template objects\n", RangeNames.Size(), nValidObjects));

    // **** create and init array for matching parameters from each policy

    SafeArray<IUnknown*, VT_UNKNOWN>
      ParameterObjects(0, PolicyArray.Size());

    // **** resize MergedParameters to contain a slot for each parameter name

    MergedParameters.ReDim(0, RangeNames.Size());

    // **** assemble a list and merge for each parameter in RangeNames

    for(c1 = 0; c1 < RangeNames.Size(); c1++)
    {
      CComPtr<IWbemClassObject>
        pOutParams;

      CComVariant
        vRangeParamType,
        vRangeParamType2,
        vConflict = -1,
        vRanges,
        vReturnValue,
        vMergedParameter;

      // **** build list of parameters from policy objects with name RangeNames[c1]

      c2 = -1;
      while((_NextIndex(c2, ValidPolicyObjects)) && (-1 == vConflict.lVal))
      {
        CComQIPtr<IWbemClassObject, &IID_IWbemClassObject>
          pCurrentPolicyObject = PolicyArray[c2];

        CComVariant
          vCurrentParams;

        // **** walk through parameter settings for c2th policy object looking for a match

        hres = pCurrentPolicyObject->Get(g_bstrRangeSettings, 0, &vCurrentParams, NULL, NULL);
        if(FAILED(hres)) return hres;

        SafeArray<IUnknown*, VT_UNKNOWN>
          CurrentParams(&vCurrentParams);

        c3 = 0;
        ParameterObjects[c2] = NULL;
        while((c3 < CurrentParams.Size()) && (NULL == ParameterObjects[c2]))
        {
          CComQIPtr<IWbemClassObject, &IID_IWbemClassObject>
            pCurrentParameterObject = CurrentParams[c3];

          CComVariant
            vName;

          hres = pCurrentParameterObject->Get(g_bstrPropertyName, 0, &vName, NULL, NULL);
          if(FAILED(hres)) return hres;

          if(0 == _wcsicmp(V_BSTR(&vName), RangeNames[c1]))
          {
            ParameterObjects[c2] = CurrentParams[c3];
            ParameterObjects[c2]->AddRef();

            // **** check that all subsequent parameter objects are of the same type

            if(VT_BSTR != vRangeParamType.vt)
            {
              hres = pCurrentParameterObject->Get(L"__CLASS", 0, &vRangeParamType, NULL, NULL);
              if(FAILED(hres)) return hres;
            }
            else
            {
              hres = pCurrentParameterObject->Get(L"__CLASS", 0, &vRangeParamType2, NULL, NULL);
              if(FAILED(hres)) return hres;

              if((0 != _wcsicmp(V_BSTR(&vRangeParamType), V_BSTR(&vRangeParamType2))) ||
                 (WBEM_S_NO_ERROR != pCurrentParameterObject->InheritsFrom(vRangeParamType.bstrVal)))
              {
                ERRORTRACE((LOG_ESS, "POLICMAN: Type Mismatch on element %d of type %S and type %S\n", c3, V_BSTR(&vRangeParamType), V_BSTR(&vRangeParamType2)));
                vConflict = c2;
                vReturnValue = WBEM_E_TYPE_MISMATCH;
                break;
              }
            }

            DEBUGTRACE((LOG_ESS, "POLICMAN(merge): Got Parameter %S in template object %d\n", V_BSTR(&vName), c2));
          }
  
          c3 += 1;
        }
      }

      // **** now build merged parameter from list

      if(-1 == vConflict.lVal)
      {
        V_VT(&vRanges) = (VT_UNKNOWN | VT_ARRAY);
        V_ARRAY(&vRanges) = ParameterObjects.Data();
        hres = pInParams->Put(L"ranges", 0, &vRanges, 0);
        if(FAILED(hres)) return hres;

        hres = pDestCIM->ExecMethod(V_BSTR(&vRangeParamType), L"Merge", 0, NULL, pInParams, &pOutParams, NULL);
        if(FAILED(hres)) return hres;

        hres = pOutParams->Get(L"mergedRange", 0, &vMergedParameter, NULL, NULL);
        if(FAILED(hres)) return hres;

        hres = pOutParams->Get(L"conflict", 0, &vConflict, NULL, NULL);
        if(FAILED(hres)) return hres;

        hres = pOutParams->Get(L"ReturnValue", 0, &vReturnValue, NULL, NULL);
        if(FAILED(hres)) return hres;
      }

      DEBUGTRACE((LOG_ESS, "POLICMAN(merge): Merge Complete : HRESULT = 0x%d\n", vReturnValue.lVal));

      // **** clean out parameter object array

      for(c2 = 0; c2 < ParameterObjects.Size(); c2++)
        if(NULL != ParameterObjects[c2])
        {
          ParameterObjects[c2]->Release();
          ParameterObjects[c2] = NULL;
        }

      // **** check for conflict

      if((vConflict.lVal >= 0) && (vConflict.lVal < ValidPolicyObjects.Size()))
      {
        DEBUGTRACE((LOG_ESS, " CONFLICT on obj %d\n", vConflict.lVal));

        // **** remove policy object containing offending parameter and start over

        RangeNames.ReDim(0,0);
        MergedParameters.ReDim(0,0);

        ValidPolicyObjects[vConflict.lVal] = FALSE;
        nValidObjects--;

        boolFinished = FALSE;

        // **** log merge conflict

        ERRORTRACE((LOG_ESS, "POLICMAN: Policy Object %d create merge conflict\n", vConflict.lVal));

        break;
      }
      else
      {
        DEBUGTRACE((LOG_ESS, " no conflict\n"));

        hres = (V_UNKNOWN(&vMergedParameter))->QueryInterface(IID_IWbemClassObject, (void **)&(MergedParameters[c1]));
        if(FAILED(hres)) return hres;

        boolFinished = TRUE;
      }
    }
  }

  if(FALSE == boolNotMergeable)
  {
    CComPtr<IWbemClassObject>
      pClassPolicy;

    // **** create new merged policy object

    hres = pDestCIM->GetObject(g_bstrClassMergeablePolicy, 0, NULL, &pClassPolicy, NULL);
    if(FAILED(hres)) return hres;

    hres = pClassPolicy->SpawnInstance(0, &pMergedPolicy);
    if(FAILED(hres)) return hres;

    // **** Pack TargetType

    hres = pFirstPolicy->Get(g_bstrTargetType, 0, &vPolicyAttr, NULL, NULL);
    if(FAILED(hres)) return hres;
    hres = pMergedPolicy->Put(g_bstrTargetType, 0, &vPolicyAttr, 0);
    if(FAILED(hres)) return hres;
    VariantClear(&vPolicyAttr);

    // **** Pack TargetClass

    hres = pFirstPolicy->Get(g_bstrTargetClass, 0, &vPolicyAttr, NULL, NULL);
    if(FAILED(hres)) return hres;
    hres = pMergedPolicy->Put(g_bstrTargetClass, 0, &vPolicyAttr, 0);
    if(FAILED(hres)) return hres;
    VariantClear(&vPolicyAttr);

    // **** Pack TargetPath

    hres = pFirstPolicy->Get(g_bstrTargetPath, 0, &vPolicyAttr, NULL, NULL);
    if(FAILED(hres)) return hres;
    hres = pMergedPolicy->Put(g_bstrTargetPath, 0, &vPolicyAttr, 0);
    if(FAILED(hres)) return hres;
    VariantClear(&vPolicyAttr);

    // **** Pack TargetNamespace

    hres = pFirstPolicy->Get(g_bstrTargetNameSpace, 0, &vPolicyAttr, NULL, NULL);
    if(FAILED(hres)) return hres;
    hres = pMergedPolicy->Put(g_bstrTargetNameSpace, 0, &vPolicyAttr, 0);
    if(FAILED(hres)) return hres;
    VariantClear(&vPolicyAttr);

    // **** pack RangeSettings

    V_VT(&vPolicyAttr) = (VT_ARRAY | VT_UNKNOWN);
    V_ARRAY(&vPolicyAttr) = MergedParameters.Data();

    hres = pMergedPolicy->Put(g_bstrRangeSettings, 0, &vPolicyAttr, 0);
    if(FAILED(hres)) return hres;
    VariantClear(&vPolicyAttr);

    // **** clean out merged parameter object array

    for(c1 = 0; c1 < MergedParameters.Size(); c1++)
      if(NULL != MergedParameters[c1])
      {
        MergedParameters[c1]->Release();
        MergedParameters[c1] = NULL;
      }
  }
  else
    pMergedPolicy = pFirstPolicy;

  {
    CComBSTR
      pBstr;

    hres = pMergedPolicy->GetObjectText(0, &pBstr);

    DEBUGTRACE((LOG_ESS, "POLICMAN(merge): Merged Policy: %S\n", (BSTR)pBstr));
  }

  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\range_sint32.cpp ===
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>
#include <sys/timeb.h>
#include <comdef.h>
#include <comutil.h>
#include <atlbase.h>

#include "windows.h"
#include "stdio.h"
#include "activeds.h"
#include "tchar.h"

#include "Utility.h"

/*
  Creates an AD based parameter object under the specified policy object from a CIM based obj.
*/

#define MAX_ATTR 8

HRESULT Range_Sint32_Verify(IWbemClassObject *pSrcParamObj)
{
  HRESULT
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1, v2, v3, vDefaultValue, v5, v6;

  unsigned short buf[20];

  long
    nOptArgs = 0,
    nArgs = 0;

  nArgs++;

  // **** PropertyName

  hres = pSrcParamObj->Get(g_bstrPropertyName, 0, &v1, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_BSTR == V_VT(&v1)) && (NULL != V_BSTR(&v1)))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetType

  hres = pSrcParamObj->Get(g_bstrTargetType, 0, &v3, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_UI1 == V_VT(&v3))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetClass

  hres = pSrcParamObj->Get(g_bstrTargetClass, 0, &v2, NULL, NULL);
  if(FAILED(hres)) return hres;

  if((VT_BSTR != V_VT(&v2)) || (NULL == V_BSTR(&v2)))
  {
    if(CIM_OBJECT == V_UI1(&v3)) return WBEM_E_ILLEGAL_NULL;
  }
  nArgs++;

  // **** Default

  hres = pSrcParamObj->Get(g_bstrDefault, 0, &vDefaultValue, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_I4 == V_VT(&vDefaultValue))
  {
    nOptArgs++;
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** Min

  hres = pSrcParamObj->Get(g_bstrMin, 0, &v5, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_I4 == V_VT(&v5))
  {
    nOptArgs++;
    nArgs++;

    if(V_I4(&vDefaultValue) < V_I4(&v5))
      return WBEM_E_INVALID_PARAMETER;
  }

  // **** Max

  hres = pSrcParamObj->Get(g_bstrMax, 0, &v6, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_I4 == V_VT(&v6))
  {
    nOptArgs++;
    nArgs++;

    if(V_I4(&vDefaultValue) > V_I4(&v6))
      return WBEM_E_INVALID_PARAMETER;
  }

  // **** check that at least one of ValidValues or Default has been set

  if((nOptArgs < 1) || (nArgs < 5))
    hres = WBEM_E_INVALID_CLASS;

  return hres;
}

/*
  Creates a CIM based parameter object within the specified policy object from an AD object.
*/

HRESULT Range_Sint32_ADToCIM(IWbemClassObject **ppDestParamObj,
                             IDirectorySearch *pDirSrch, 
                             ADS_SEARCH_HANDLE SearchHandle, 
                             IWbemServices *pDestCIM) 
{
  HRESULT
    hres = WBEM_S_NO_ERROR;

  VARIANT
    v1;

  ADS_SEARCH_COLUMN
    Column;

  unsigned long c1;

  CComPtr<IUnknown>
    pUnknown;

  CComPtr<IWbemClassObject>
    pDestParamObj,
    pClassDef;

  IWbemContext *pCtx = 0;

  // **** create empty range object

  hres = pDestCIM->GetObject(g_bstrClassRangeSint32, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef == NULL) return WBEM_E_INVALID_CLASS;

  hres = pClassDef->SpawnInstance(0, ppDestParamObj);
  if(FAILED(hres)) return hres;
  pDestParamObj = *ppDestParamObj;
  if(pDestParamObj == NULL) return WBEM_E_INVALID_CLASS;

  // **** get object attributes

  // **** PropertyName

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADPropertyName, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrPropertyName, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetClass

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADTargetClass, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrTargetClass, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetType

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADTargetType, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_UI1;
    V_UI1(&v1) = char(_wtoi(Column.pADsValues->CaseExactString));
    hres = pDestParamObj->Put(g_bstrTargetType, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** default

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADIntDefault, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_I4;
    V_I4(&v1) = Column.pADsValues->Integer;
    hres = pDestParamObj->Put(g_bstrDefault, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** Min

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADIntMin, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_I4;
    V_I4(&v1) = Column.pADsValues->Integer;
    hres = pDestParamObj->Put(g_bstrMin, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** Max

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADIntMax, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_I4;
    V_I4(&v1) = Column.pADsValues->Integer;
    hres = pDestParamObj->Put(g_bstrMax, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }
  
  return WBEM_S_NO_ERROR;
}

/*
  Merges one or more CIM based policy objects of like type into
  a single CIM based policy object.
*/

HRESULT Range_Sint32_Merge(SafeArray<IUnknown*, VT_UNKNOWN> &ParamArray,
                         CComPtr<IWbemClassObject> &pClassObjMerged,
                         int &conflict)
{
  HRESULT
    hres = WBEM_E_FAILED;

  long
    c1, c2, c3, firstValidObj = -1;

  CComVariant
    vName,
    vType,
    vClass,
    vMergedMin,
    vMergedMax,
    vMergedDefault;

  // **** create arrays for Max, Min, and Default values

  SafeArray<int, VT_I4>
    Default(0, ParamArray.Size());

  // **** copy contents of each object into arrays

  c2 = -1;
  for(c1 = 0; c1 < ParamArray.Size(); c1++)
  {
    CComVariant
      vMin, vMax, vDefault;

    CComPtr<IWbemClassObject>
      pClassObjCurrent;

    if(NULL == ParamArray[c1])
      continue;
    else
    {
      c2 += 1;
      c3 = c2 - 1;

      if(firstValidObj < 0) 
        firstValidObj = c1;
    }

    // **** copy contents of each object into arrays

    hres = ParamArray[c1]->QueryInterface(IID_IWbemClassObject, (void **)&pClassObjCurrent);

    hres = pClassObjCurrent->Get(g_bstrMin, 0, &vMin, NULL, NULL);
    hres = pClassObjCurrent->Get(g_bstrMax, 0, &vMax, NULL, NULL);
    hres = pClassObjCurrent->Get(g_bstrDefault, 0, &vDefault, NULL, NULL);

    // **** record default value

    Default[c1] = vDefault.lVal;

    // **** check for conflict

    if(IsEmpty(vMin) && IsEmpty(vMax))
    {
      conflict = c1;
      return WBEM_E_FAILED;
    }

    // **** find merged range

    if(!IsEmpty(vMin))
    {
      if(!IsEmpty(vMergedMin))
        vMergedMin = V_I4(&vMergedMin) > V_I4(&vMin) ? V_I4(&vMergedMin) : V_I4(&vMin);
      else
        vMergedMin = vMin;
    }

    if(!IsEmpty(vMax))
    {
      if(!IsEmpty(vMergedMax))
        vMergedMax = V_I4(&vMergedMax) < V_I4(&vMax) ? V_I4(&vMergedMax) : V_I4(&vMax);
      else
        vMergedMax = vMax;
    }

    // **** check for conflict

    if((!IsEmpty(vMergedMin)) && (!IsEmpty(vMergedMax)) && (V_I4(&vMergedMin) > V_I4(&vMergedMax)))
    {
      conflict = c1;
      return WBEM_E_FAILED;
    }
  }

  // **** wind back up merge stack and find most local default

  for(c1 = ParamArray.IndexMax(); IsEmpty(vMergedDefault) && (c1 >= ParamArray.IndexMin()); c1--)
  {
    if((NULL != ParamArray[c1]) && (Default[c1] <= V_I4(&vMergedMax)) && (Default[c1] >= V_I4(&vMergedMin)))
      vMergedDefault = Default[c1];
  }

  if(IsEmpty(vMergedDefault))
  {
    if(!IsEmpty(vMergedMin))
      vMergedDefault = vMergedMin;
    else
      vMergedDefault = vMergedMax;
  }

  // **** create new merged range object

  if(firstValidObj >= 0)
  {
    CComPtr<IWbemClassObject>
      pFirstValidObj;

    hres = ParamArray[firstValidObj]->QueryInterface(IID_IWbemClassObject, (void **)&pFirstValidObj);
    hres = pFirstValidObj->SpawnInstance(0, &pClassObjMerged);

    hres = pFirstValidObj->Get(g_bstrPropertyName, 0, &vName, NULL, NULL);
    hres = pClassObjMerged->Put(g_bstrPropertyName, 0, &vName, 0);

    hres = pFirstValidObj->Get(g_bstrTargetType, 0, &vType, NULL, NULL);
    hres = pClassObjMerged->Put(g_bstrTargetType, 0, &vType, 0);

    hres = pFirstValidObj->Get(g_bstrTargetClass, 0, &vClass, NULL, NULL);
    hres = pClassObjMerged->Put(g_bstrTargetClass, 0, &vClass, 0);

    hres = pClassObjMerged->Put(g_bstrMin, 0, &vMergedMin, 0);
    hres = pClassObjMerged->Put(g_bstrMax, 0, &vMergedMax, 0);
    hres = pClassObjMerged->Put(g_bstrDefault, 0, &vMergedDefault, 0);
  }

  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\range_uint32.cpp ===
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>
#include <sys/timeb.h>
#include <comdef.h>
#include <comutil.h>
#include <atlbase.h>

#include "windows.h"
#include "stdio.h"
#include "activeds.h"
#include "tchar.h"

#include "Utility.h"

/*
  Creates an AD based parameter object under the specified policy object from a CIM based obj.
*/

#define MAX_ATTR 8

HRESULT Range_Uint32_Verify(IWbemClassObject *pSrcParamObj)
{
  HRESULT
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1, v2, v3, vDefaultValue, v5, v6;

  unsigned int
    uDefaultValue, uOtherValue;

  unsigned short buf[20];

  long
    nOptArgs = 0,
    nArgs = 0;

  nArgs++;

  // **** PropertyName

  hres = pSrcParamObj->Get(g_bstrPropertyName, 0, &v1, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_BSTR == V_VT(&v1)) && (NULL != V_BSTR(&v1)))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetType

  hres = pSrcParamObj->Get(g_bstrTargetType, 0, &v3, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_UI1 == V_VT(&v3))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetClass

  hres = pSrcParamObj->Get(g_bstrTargetClass, 0, &v2, NULL, NULL);
  if(FAILED(hres)) return hres;

  if((VT_BSTR != V_VT(&v2)) || (NULL == V_BSTR(&v2)))
  {
    if(CIM_OBJECT == V_UI1(&v3)) return WBEM_E_ILLEGAL_NULL;
  }
  nArgs++;

  // **** Default

  hres = pSrcParamObj->Get(g_bstrDefault, 0, &vDefaultValue, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_I4 == V_VT(&vDefaultValue))
  {
    nOptArgs++;
    nArgs++;

    memcpy((void*)&uDefaultValue, (void*)&(vDefaultValue.lVal), sizeof(vDefaultValue.lVal));
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** Min

  hres = pSrcParamObj->Get(g_bstrMin, 0, &v5, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_I4 == V_VT(&v5))
  {
    nOptArgs++;
    nArgs++;

    memcpy((void*)&uOtherValue, (void*)&(v5.lVal), sizeof(vDefaultValue.lVal));
    if(uDefaultValue < uOtherValue)
      return WBEM_E_INVALID_PARAMETER;
  }

  // **** Max

  hres = pSrcParamObj->Get(g_bstrMax, 0, &v6, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_I4 == V_VT(&v6))
  {
    nOptArgs++;
    nArgs++;

    memcpy((void*)&uOtherValue, (void*)&(v6.lVal), sizeof(vDefaultValue.lVal));
    if(uDefaultValue > uOtherValue)
      return WBEM_E_INVALID_PARAMETER;
  }

  // **** check that at least one of ValidValues or Default has been set

  if((nOptArgs < 1) || (nArgs < 5))
    hres = WBEM_E_INVALID_CLASS;

  return hres;
}


/*
  Creates a CIM based parameter object within the specified policy object from an AD object.
*/

HRESULT Range_Uint32_ADToCIM(IWbemClassObject **ppDestParamObj,
                             IDirectorySearch *pDirSrch, 
                             ADS_SEARCH_HANDLE SearchHandle, 
                             IWbemServices *pDestCIM) 
{
  HRESULT
    hres = WBEM_S_NO_ERROR;

  VARIANT
    v1;

  ADS_SEARCH_COLUMN
    Column;

  unsigned long c1;

  CComPtr<IUnknown>
    pUnknown;

  CComPtr<IWbemClassObject>
    pDestParamObj,
    pClassDef;

  IWbemContext *pCtx = 0;

  // **** create empty range object

  hres = pDestCIM->GetObject(g_bstrClassRangeUint32, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef == NULL) return WBEM_E_INVALID_CLASS;

  hres = pClassDef->SpawnInstance(0, ppDestParamObj);
  if(FAILED(hres)) return hres;
  pDestParamObj = *ppDestParamObj;
  if(pDestParamObj == NULL) return WBEM_E_INVALID_CLASS;

  // **** get object attributes

  // **** PropertyName

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADPropertyName, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrPropertyName, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetClass

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADTargetClass, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrTargetClass, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetType

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADTargetType, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_UI1;
    V_UI1(&v1) = char(_wtoi(Column.pADsValues->CaseExactString));
    hres = pDestParamObj->Put(g_bstrTargetType, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** default

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADIntDefault, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_I4;
    V_I4(&v1) = Column.pADsValues->Integer;
    hres = pDestParamObj->Put(g_bstrDefault, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** Min

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADIntMin, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_I4;
    V_I4(&v1) = Column.pADsValues->Integer;
    hres = pDestParamObj->Put(g_bstrMin, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** Max

  hres = pDirSrch->GetColumn(SearchHandle, g_bstrADIntMax, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_I4;
    V_I4(&v1) = Column.pADsValues->Integer;
    hres = pDestParamObj->Put(g_bstrMax, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  return WBEM_S_NO_ERROR;
}

/*
  Merges one or more CIM based policy objects of like type into
  a single CIM based policy object.
*/

HRESULT Range_Uint32_Merge(SafeArray<IUnknown*, VT_UNKNOWN> &ParamArray,
                         CComPtr<IWbemClassObject> &pClassObjMerged,
                         int &conflict)
{
  HRESULT
    hres = WBEM_E_FAILED;

  long
    c1, c2, c3, firstValidObj = -1;

  CComVariant
    vName,
    vType,
    vClass,
    vMergedMin,
    vMergedMax,
    vMergedDefault;

  // **** create arrays for Max, Min, and Default values

  SafeArray<int, VT_I4>
    Default(0, ParamArray.Size());

  // **** copy contents of each object into arrays

  c2 = -1;
  for(c1 = 0; c1 < ParamArray.Size(); c1++)
  {
    CComVariant
      vMin, vMax, vDefault;

    CComPtr<IWbemClassObject>
      pClassObjCurrent;

    if(NULL == ParamArray[c1])
      continue;
    else
    {
      c2 += 1;
      c3 = c2 - 1;

      if(firstValidObj < 0) 
        firstValidObj = c1;
    }

    // **** copy contents of each object into arrays

    hres = ParamArray[c1]->QueryInterface(IID_IWbemClassObject, (void **)&pClassObjCurrent);

    hres = pClassObjCurrent->Get(g_bstrMin, 0, &vMin, NULL, NULL);
    hres = pClassObjCurrent->Get(g_bstrMax, 0, &vMax, NULL, NULL);
    hres = pClassObjCurrent->Get(g_bstrDefault, 0, &vDefault, NULL, NULL);

    // **** record default value

    Default[c1] = vDefault.lVal;

    // **** check for conflict

    if(IsEmpty(vMin) && IsEmpty(vMax))
    {
      conflict = c1;
      return WBEM_E_FAILED;
    }

    // **** find merged range

    if(!IsEmpty(vMin))
    {
      if(!IsEmpty(vMergedMin))
        vMergedMin = V_I4(&vMergedMin) > V_I4(&vMin) ? V_I4(&vMergedMin) : V_I4(&vMin);
      else
        vMergedMin = vMin;
    }

    if(!IsEmpty(vMax))
    {
      if(!IsEmpty(vMergedMax))
        vMergedMax = V_I4(&vMergedMax) < V_I4(&vMax) ? V_I4(&vMergedMax) : V_I4(&vMax);
      else
        vMergedMax = vMax;
    }

    // **** check for conflict

    if((!IsEmpty(vMergedMin)) && (!IsEmpty(vMergedMax)) && (V_I4(&vMergedMin) > V_I4(&vMergedMax)))
    {
      conflict = c1;
      return WBEM_E_FAILED;
    }
  }

  // **** wind back up merge stack and find most local default

  for(c1 = ParamArray.IndexMax(); IsEmpty(vMergedDefault) && (c1 >= ParamArray.IndexMin()); c1--)
  {
    if((NULL != ParamArray[c1]) && (Default[c1] <= V_I4(&vMergedMax)) && (Default[c1] >= V_I4(&vMergedMin)))
      vMergedDefault = Default[c1];
  }

  if(IsEmpty(vMergedDefault))
  {
    if(!IsEmpty(vMergedMin))
      vMergedDefault = vMergedMin;
    else
      vMergedDefault = vMergedMax;
  }

  // **** create new merged range object

  if(firstValidObj >= 0)
  {
    CComPtr<IWbemClassObject>
      pFirstValidObj;

    hres = ParamArray[firstValidObj]->QueryInterface(IID_IWbemClassObject, (void **)&pFirstValidObj);
    hres = pFirstValidObj->SpawnInstance(0, &pClassObjMerged);

    hres = pFirstValidObj->Get(g_bstrPropertyName, 0, &vName, NULL, NULL);
    hres = pClassObjMerged->Put(g_bstrPropertyName, 0, &vName, 0);

    hres = pFirstValidObj->Get(g_bstrTargetType, 0, &vType, NULL, NULL);
    hres = pClassObjMerged->Put(g_bstrTargetType, 0, &vType, 0);

    hres = pFirstValidObj->Get(g_bstrTargetClass, 0, &vClass, NULL, NULL);
    hres = pClassObjMerged->Put(g_bstrTargetClass, 0, &vClass, 0);

    hres = pClassObjMerged->Put(g_bstrMin, 0, &vMergedMin, 0);
    hres = pClassObjMerged->Put(g_bstrMax, 0, &vMergedMax, 0);
    hres = pClassObjMerged->Put(g_bstrDefault, 0, &vMergedDefault, 0);
  }

  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\set_sint32.cpp ===
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>
#include <sys/timeb.h>
#include <comdef.h>
#include <comutil.h>
#include <atlbase.h>

// **** includes for AD

#include "windows.h"
#include "stdio.h"
#include "activeds.h"
#include "tchar.h"
 
#include "Utility.h"

/*
  Creates an AD based parameter object under the specified policy object from a CIM based obj.
*/

#define MAX_ATTR 8

HRESULT Set_Sint32_Verify(IWbemClassObject *pSrcParamObj)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant 
    v1, v2, v3, vDefaultValue, v5, v6, v7, v8;

  wchar_t buf[20];

  SafeArray<int, VT_I4>
    Array1;

  long
    c1,
    nOptArgs = 0,
    nArgs = 0;

  nArgs++;

  // **** PropertyName

  hres = pSrcParamObj->Get(g_bstrPropertyName, 0, &v1, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_BSTR == V_VT(&v1)) && (NULL != V_BSTR(&v1)))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetType

  hres = pSrcParamObj->Get(g_bstrTargetType, 0, &v3, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_UI1 == V_VT(&v3))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetClass

  hres = pSrcParamObj->Get(g_bstrTargetClass, 0, &v2, NULL, NULL);
  if(FAILED(hres)) return hres;

  if((VT_BSTR != V_VT(&v2)) || (NULL == V_BSTR(&v2)))
  {
    if(CIM_OBJECT == V_UI1(&v3)) return WBEM_E_ILLEGAL_NULL;
  }
  nArgs++;

  // **** Default

  hres = pSrcParamObj->Get(g_bstrDefault, 0, &vDefaultValue, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_I4 == V_VT(&vDefaultValue))
  {
    nOptArgs++;
    nArgs++;
  }

  // **** ValidValues

  int
    DefInSet = 0;

  hres = pSrcParamObj->Get(g_bstrValidValues, 0, &v5, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_ARRAY | VT_I4) == V_VT(&v5))
  {
    Array1 = &v5;

    for(c1 = 0; c1 < Array1.Size(); c1++)
    {
      if(V_I4(&vDefaultValue) == Array1[c1])
        DefInSet = 1;
    }

    nArgs++;
    nOptArgs++;

    if(DefInSet != 1)
      return WBEM_E_INVALID_PARAMETER;
  }

  // **** check that at least one of ValidValues or Default has been set

  if((nOptArgs < 1) || (nArgs < 5))
    hres = WBEM_E_INVALID_CLASS;

  return hres;
}

HRESULT Set_Sint32_ADToCIM(IWbemClassObject **ppDestParamObj, 
                           IDirectorySearch *pDirSrch, 
                           ADS_SEARCH_HANDLE pHandle, 
                           IWbemServices *pDestCIM)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  VARIANT
    v1;

  ADS_SEARCH_COLUMN
    Column;

  unsigned long c1;

  CComPtr<IUnknown>
    pUnknown;

  CComPtr<IWbemClassObject>
    pDestParamObj,
    pClassDef;

  IWbemContext *pCtx = 0;

  // **** create empty set object

  hres = pDestCIM->GetObject(g_bstrClassSetSint32, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef == NULL) return WBEM_E_INVALID_CLASS;

  hres = pClassDef->SpawnInstance(0, ppDestParamObj);
  if(FAILED(hres)) return hres;
  pDestParamObj = *ppDestParamObj;
  if(pDestParamObj == NULL) return WBEM_E_INVALID_CLASS;

  // **** get object attributes

  // **** PropertyName

  hres = pDirSrch->GetColumn(pHandle, g_bstrADPropertyName, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrPropertyName, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetClass

  hres = pDirSrch->GetColumn(pHandle, g_bstrADTargetClass, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrTargetClass, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetType

  hres = pDirSrch->GetColumn(pHandle, g_bstrADTargetType, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_UI1;
    V_UI1(&v1) = char(_wtoi(Column.pADsValues->CaseExactString));
    hres = pDestParamObj->Put(g_bstrTargetType, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** default

  hres = pDirSrch->GetColumn(pHandle, g_bstrADIntDefault, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_I4;
    V_I4(&v1) = Column.pADsValues->Integer;
    hres = pDestParamObj->Put(g_bstrDefault, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** ValidValues

  hres = pDirSrch->GetColumn(pHandle, g_bstrADIntValidValues, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    SafeArray<int, VT_I4>
      Array1(0, Column.dwNumValues);

    for(c1 = 0; c1 < Column.dwNumValues; c1++)
    {
      Array1[c1] = (Column.pADsValues + c1)->Integer;
    }

    pDirSrch->FreeColumn(&Column);

    V_VT(&v1) = VT_ARRAY | VT_I4;
    V_ARRAY(&v1) = Array1.Data();
    hres = pDestParamObj->Put(g_bstrValidValues, 0, &v1, 0);
    if(FAILED(hres)) return hres;
  }
  
  return WBEM_S_NO_ERROR;
}

HRESULT Set_Sint32_Merge(SafeArray<IUnknown*, VT_UNKNOWN> &ParamArray,
                         CComPtr<IWbemClassObject> &pClassObjMerged,
                         int &conflict)
{
  HRESULT
    hres = WBEM_E_FAILED;

  CComVariant
    vTopSet;

  CComPtr<IWbemClassObject>
    pClassObjFirst;

  long
    FirstElement, FoundElement, lNumInMerge, c1, c2, c3; 

  // **** initialize array for merged set

  for(FirstElement = 0; 
      (FirstElement < ParamArray.Size()) && (NULL == ParamArray[FirstElement]); 
      FirstElement++);

  if(FirstElement >= ParamArray.Size())
    return WBEM_E_FAILED;

  hres = ParamArray[FirstElement]->QueryInterface(IID_IWbemClassObject, (void **)&pClassObjFirst);
  hres = pClassObjFirst->Get(g_bstrValidValues, 0, &vTopSet, NULL, NULL);

  SafeArray<int, VT_I4>
    TopSet(&vTopSet),
    DefaultValues(0, ParamArray.Size());

  if((TopSet.Size() < 1) || (ParamArray.Size() < 1)) return WBEM_E_INVALID_PARAMETER;

  // **** init array of flags indicating which members of TopSet are in the final merge set

  SafeArray<int, VT_I4>
    InBoth(TopSet.IndexMin(), TopSet.Size());

  lNumInMerge = TopSet.Size();

  for(c1 = InBoth.IndexMin(); c1 <= InBoth.IndexMax(); c1++)
    InBoth[c1] = TRUE;

  // **** itterate from most to least significant set

  for(c1 = FirstElement; c1 < ParamArray.Size(); c1++)
  {
    CComVariant
      vCurrentSet,
      vDefault;

    CComPtr<IWbemClassObject>
      pClassObjCurrent;

    if(NULL == ParamArray[c1])
      continue;

    // **** get ValidValues array for c1th element

    hres = ParamArray[c1]->QueryInterface(IID_IWbemClassObject, (void **)&pClassObjCurrent);
    hres = pClassObjCurrent->Get(g_bstrValidValues, 0, &vCurrentSet, NULL, NULL);

    SafeArray<int, VT_I4>
      CurrentSet(&vCurrentSet);

    // **** get c1th default value

    hres = pClassObjCurrent->Get(g_bstrDefault, 0, &vDefault, NULL, NULL);
    DefaultValues[c1] = V_I4(&vDefault);

    // **** find intersection of set (c1) with (c1 - 1)

    for(c2 = 0; c2 < TopSet.Size(); c2++)
    {
      // **** find element TopSet[c2] in the CurrentSet

      if(TRUE == InBoth[c2])
      {
        // **** find c2th element of merge set in the current set

        FoundElement = FALSE;
        c3 = 0;
        while((FALSE == FoundElement) && (c3 < CurrentSet.Size()))
        {
          if(TopSet[c2] == CurrentSet[c3])
            FoundElement = TRUE;
          else
            c3 += 1;
        }

        if(FALSE == FoundElement)
        {
          InBoth[c2] = FALSE;
          lNumInMerge -= 1;
        }

        // **** check for empty set, if yes, indicate conflict

        if(lNumInMerge < 1)
        {
          conflict = c1;
          return WBEM_E_FAILED;
        }
      }
    }
  }

  SafeArray<int, VT_I4>
    MergedSet(0, lNumInMerge);

  CComVariant
    vName,
    vClass,
    vType,
    vMergedDefault,
    vMergedSet;

  // **** now create set of merged elements

  c2 = -1;
  for(c1 = 0; c1 < lNumInMerge; c1++)
  {
    do
    {
      c2 += 1;
    } while((c2 < InBoth.Size()) && (FALSE == InBoth[c2]));
  
    MergedSet[c1] = TopSet[c2];
  }

  // **** find first matching default value

  for(c1 = ParamArray.Size() - 1; (c1 >= FirstElement) && (VT_EMPTY == V_VT(&vMergedDefault)); c1--)
  {
    // **** determine if c1th default value is within MergedSet

    if((NULL != ParamArray[c1]))
    {
      c2 = 0;
      while((c2 < MergedSet.Size()) && 
            (DefaultValues[c1] != MergedSet[c2]))
        c2 += 1;

      if(c2 < MergedSet.Size())
        vMergedDefault = DefaultValues[c1];
    }
  }

  if(VT_EMPTY == V_VT(&vMergedDefault))
  {
    vMergedDefault = MergedSet[0];
  }

  // **** create new merged set object

  hres = pClassObjFirst->SpawnInstance(0, &pClassObjMerged);

  hres = pClassObjFirst->Get(g_bstrPropertyName, 0, &vName, NULL, NULL);
  hres = pClassObjMerged->Put(g_bstrPropertyName, 0, &vName, 0);

  hres = pClassObjFirst->Get(g_bstrTargetClass, 0, &vClass, NULL, NULL);
  hres = pClassObjMerged->Put(g_bstrTargetClass, 0, &vClass, 0);

  hres = pClassObjFirst->Get(g_bstrTargetType, 0, &vType, NULL, NULL);
  hres = pClassObjMerged->Put(g_bstrTargetType, 0, &vType, 0);

  hres = pClassObjMerged->Put(g_bstrDefault, 0, &vMergedDefault, 0);

  V_VT(&vMergedSet) = (VT_ARRAY | VT_I4);
  V_ARRAY(&vMergedSet) = MergedSet.Data();
  hres = pClassObjMerged->Put(g_bstrValidValues, 0, &vMergedSet, 0);

  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\set_uint32.cpp ===
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>
#include <sys/timeb.h>
#include <comdef.h>
#include <comutil.h>
#include <atlbase.h>

// **** includes for AD

#include "windows.h"
#include "stdio.h"
#include "activeds.h"
#include "tchar.h"
 
#include "Utility.h"

/*
  Creates an AD based parameter object under the specified policy object from a CIM based obj.
*/

#define MAX_ATTR 8

HRESULT Set_Uint32_Verify(IWbemClassObject *pSrcParamObj)
{
  HRESULT
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1, v2, v3, vDefaultValue, v5, v6, v7, v8;

  wchar_t buf[20];

  SafeArray<int, VT_I4>
    Array1;

  long
    c1,
    nOptArgs = 0,
    nArgs = 0;

  nArgs++;

  // **** PropertyName

  hres = pSrcParamObj->Get(g_bstrPropertyName, 0, &v1, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_BSTR == V_VT(&v1)) && (NULL != V_BSTR(&v1)))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetType

  hres = pSrcParamObj->Get(g_bstrTargetType, 0, &v3, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_UI1 == V_VT(&v3))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetClass

  hres = pSrcParamObj->Get(g_bstrTargetClass, 0, &v2, NULL, NULL);
  if(FAILED(hres)) return hres;

  if((VT_BSTR != V_VT(&v2)) || (NULL == V_BSTR(&v2)))
  {
    if(CIM_OBJECT == V_UI1(&v3)) return WBEM_E_ILLEGAL_NULL;
  }
  nArgs++;

  // **** Default

  hres = pSrcParamObj->Get(g_bstrDefault, 0, &vDefaultValue, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_I4 == V_VT(&vDefaultValue))
  {
    nOptArgs++;
    nArgs++;
  }

  // **** ValidValues

  int
    DefInSet = 0;

  hres = pSrcParamObj->Get(g_bstrValidValues, 0, &v5, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_ARRAY | VT_I4) == V_VT(&v5))
  {
    Array1 = &v5;

      for(c1 = 0; c1 < Array1.Size(); c1++)
      {
        if(V_I4(&vDefaultValue) == Array1[c1])
          DefInSet = 1;
      }

      nArgs++;
      nOptArgs++;

    if(DefInSet != 1)
      return WBEM_E_INVALID_PARAMETER;
  }

  // **** check that at least one of ValidValues or Default has been set

  if((nOptArgs < 1) || (nArgs < 5))
    hres = WBEM_E_INVALID_CLASS;

  return hres;
}

HRESULT Set_Uint32_ADToCIM(IWbemClassObject **ppDestParamObj,
                           IDirectorySearch *pDirSrch, 
                           ADS_SEARCH_HANDLE pHandle, 
                           IWbemServices *pDestCIM)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  VARIANT	
    v1;

  ADS_SEARCH_COLUMN
    Column;

  unsigned long c1;

  CComPtr<IUnknown>
    pUnknown;

  CComPtr<IWbemClassObject>
    pDestParamObj,
    pClassDef;

  IWbemContext *pCtx = 0;

  // **** create empty set object

  hres = pDestCIM->GetObject(g_bstrClassSetUint32, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef == NULL) return WBEM_E_INVALID_CLASS;

  hres = pClassDef->SpawnInstance(0, ppDestParamObj);
  if(FAILED(hres)) return hres;
  pDestParamObj = *ppDestParamObj;
  if(pDestParamObj == NULL) return WBEM_E_INVALID_CLASS;

  // **** get object attributes

  // **** PropertyName

  hres = pDirSrch->GetColumn(pHandle, g_bstrADPropertyName, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrPropertyName, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetClass

  hres = pDirSrch->GetColumn(pHandle, g_bstrADTargetClass, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseExactString;
    hres = pDestParamObj->Put(g_bstrTargetClass, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetType

  hres = pDirSrch->GetColumn(pHandle, g_bstrADTargetType, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_UI1;
    V_UI1(&v1) = char(_wtoi(Column.pADsValues->CaseExactString));
    hres = pDestParamObj->Put(g_bstrTargetType, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** default

  hres = pDirSrch->GetColumn(pHandle, g_bstrADIntDefault, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_I4;
    V_I4(&v1) = Column.pADsValues->Integer;
    hres = pDestParamObj->Put(g_bstrDefault, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** ValidValues

  hres = pDirSrch->GetColumn(pHandle, g_bstrADIntValidValues, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    SafeArray<int, VT_I4>
      Array1(0, Column.dwNumValues);

    for(c1 = 0; c1 < Column.dwNumValues; c1++)
    {
      Array1[c1] = (Column.pADsValues + c1)->Integer;
    }

    pDirSrch->FreeColumn(&Column);

    V_VT(&v1) = VT_ARRAY | VT_I4;
    V_ARRAY(&v1) = Array1.Data();
    hres = pDestParamObj->Put(g_bstrValidValues, 0, &v1, 0);
    if(FAILED(hres)) return hres;
  }

  return WBEM_S_NO_ERROR;
}

HRESULT Set_Uint32_Merge(SafeArray<IUnknown*, VT_UNKNOWN> &ParamArray,
                         CComPtr<IWbemClassObject> &pClassObjMerged,
                         int &conflict)
{
  HRESULT
    hres = WBEM_E_FAILED;

  CComVariant
    vTopSet;

  CComPtr<IWbemClassObject>
    pClassObjFirst;

  long
    FirstElement, FoundElement, lNumInMerge, c1, c2, c3; 

  // **** initialize array for merged set

  for(FirstElement = 0; 
      (FirstElement < ParamArray.Size()) && (NULL == ParamArray[FirstElement]); 
      FirstElement++);

  if(FirstElement >= ParamArray.Size())
    return WBEM_E_FAILED;

  hres = ParamArray[FirstElement]->QueryInterface(IID_IWbemClassObject, (void **)&pClassObjFirst);
  hres = pClassObjFirst->Get(g_bstrValidValues, 0, &vTopSet, NULL, NULL);

  SafeArray<int, VT_I4>
    TopSet(&vTopSet),
    DefaultValues(0, ParamArray.Size());

  if((TopSet.Size() < 1) || (ParamArray.Size() < 1)) return WBEM_E_INVALID_PARAMETER;

  // **** init array of flags indicating which members of TopSet are in the final merge set

  SafeArray<int, VT_I4>
    InBoth(TopSet.IndexMin(), TopSet.Size());

  lNumInMerge = TopSet.Size();

  for(c1 = InBoth.IndexMin(); c1 <= InBoth.IndexMax(); c1++)
    InBoth[c1] = TRUE;

  // **** itterate from most to least significant set

  for(c1 = FirstElement; c1 < ParamArray.Size(); c1++)
  {
    CComVariant
      vCurrentSet,
      vDefault;

    CComPtr<IWbemClassObject>
      pClassObjCurrent;

    if(NULL == ParamArray[c1])
      continue;

    // **** get ValidValues array for c1th element

    hres = ParamArray[c1]->QueryInterface(IID_IWbemClassObject, (void **)&pClassObjCurrent);
    hres = pClassObjCurrent->Get(g_bstrValidValues, 0, &vCurrentSet, NULL, NULL);

    SafeArray<int, VT_I4>
      CurrentSet(&vCurrentSet);

    // **** get c1th default value

    hres = pClassObjCurrent->Get(g_bstrDefault, 0, &vDefault, NULL, NULL);
    DefaultValues[c1] = V_I4(&vDefault);

    // **** find intersection of set (c1) with (c1 - 1)

    for(c2 = 0; c2 < TopSet.Size(); c2++)
    {
      // **** find element TopSet[c2] in the CurrentSet

      if(TRUE == InBoth[c2])
      {
        // **** find c2th element of merge set in the current set

        FoundElement = FALSE;
        c3 = 0;
        while((FALSE == FoundElement) && (c3 < CurrentSet.Size()))
        {
          if(TopSet[c2] == CurrentSet[c3])
            FoundElement = TRUE;
          else
            c3 += 1;
        }

        if(FALSE == FoundElement)
        {
          InBoth[c2] = FALSE;
          lNumInMerge -= 1;
        }

        // **** check for empty set, if yes, indicate conflict

        if(lNumInMerge < 1)
        {
          conflict = c1;
          return WBEM_E_FAILED;
        }
      }
    }
  }

  SafeArray<int, VT_I4>
    MergedSet(0, lNumInMerge);

  CComVariant
    vName,
    vClass,
    vType,
    vMergedDefault,
    vMergedSet;

  // **** now create set of merged elements

  c2 = -1;
  for(c1 = 0; c1 < lNumInMerge; c1++)
  {
    do
    {
      c2 += 1;
    } while((c2 < InBoth.Size()) && (FALSE == InBoth[c2]));
  
    MergedSet[c1] = TopSet[c2];
  }

  // **** find first matching default value

  for(c1 = ParamArray.Size() - 1; (c1 >= FirstElement) && (VT_EMPTY == V_VT(&vMergedDefault)); c1--)
  {
    // **** determine if c1th default value is within MergedSet

    if((NULL != ParamArray[c1]))
    {
      c2 = 0;
      while((c2 < MergedSet.Size()) && 
            (DefaultValues[c1] != MergedSet[c2]))
        c2 += 1;

      if(c2 < MergedSet.Size())
        vMergedDefault = DefaultValues[c1];
    }
  }

  if(VT_EMPTY == V_VT(&vMergedDefault))
  {
    vMergedDefault = MergedSet[0];
  }

  // **** create new merged set object

  hres = pClassObjFirst->SpawnInstance(0, &pClassObjMerged);

  hres = pClassObjFirst->Get(g_bstrPropertyName, 0, &vName, NULL, NULL);
  hres = pClassObjMerged->Put(g_bstrPropertyName, 0, &vName, 0);

  hres = pClassObjFirst->Get(g_bstrTargetClass, 0, &vClass, NULL, NULL);
  hres = pClassObjMerged->Put(g_bstrTargetClass, 0, &vClass, 0);

  hres = pClassObjFirst->Get(g_bstrTargetType, 0, &vType, NULL, NULL);
  hres = pClassObjMerged->Put(g_bstrTargetType, 0, &vType, 0);

  hres = pClassObjMerged->Put(g_bstrDefault, 0, &vMergedDefault, 0);

  V_VT(&vMergedSet) = (VT_ARRAY | VT_I4);
  V_ARRAY(&vMergedSet) = MergedSet.Data();
  hres = pClassObjMerged->Put(g_bstrValidValues, 0, &vMergedSet, 0);

  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\type.cpp ===
#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <activeds.h>
#include <ArrTempl.h>
#include <comutil.h>
#undef _ASSERT
#include <atlbase.h>
#include <activeds.h>
#include <buffer.h>

#include "Utility.h"

/*********************************************************************
************** Active Directory Methods ******************************
*********************************************************************/

#define MAX_ATTR 9

HRESULT PolicyType_CIMToAD(IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    vClassDef,
    v[MAX_ATTR];

  long 
    numRules = 0,
    c1, c2,
    nArgs = 0,
    nOptArgs = 0;

  CIMTYPE vtType1;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IWbemClassObject>
    pRuleObj;

  CComPtr<IDirectoryObject>
    pDestPolicyTypeObj;

  LARGE_INTEGER 
    offset;

  BYTE 
    defaultBuffer[2048];

  CBuffer
    ClassDefBuffer(defaultBuffer, 2048, FALSE);

  ADSVALUE
    AdsValue[MAX_ATTR];
 
  ADS_ATTR_INFO 
    attrInfo[MAX_ATTR];

  wchar_t
    swArraySize[20]; 

  Init_AdsAttrInfo(&attrInfo[nArgs], 
                   g_bstrADObjectClass, 
                   ADS_ATTR_UPDATE, 
                   ADSTYPE_CASE_IGNORE_STRING, 
                   &AdsValue[nArgs], 
                   1);

  AdsValue[nArgs].CaseIgnoreString = g_bstrADClassPolicyType;
  int lTypeIndex = nArgs++;

  // **** security descriptor

  PSECURITY_DESCRIPTOR
    pSD = GetADSecurityDescriptor(pDestContainer);

  if(NULL == pSD)
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: could not create security descriptor for policy type object\n"));
    return WBEM_E_OUT_OF_MEMORY;
  }

  CNtSecurityDescriptor
    cSD(pSD, TRUE);

  if(NULL != pSD)
  {
    if(CNtSecurityDescriptor::NoError == cSD.GetStatus())
    {
      hres = RestrictSecurityDescriptor(cSD);

      AdsValue[nArgs].SecurityDescriptor.dwLength = cSD.GetSize();
      AdsValue[nArgs].SecurityDescriptor.lpValue = (LPBYTE) cSD.GetPtr();

      Init_AdsAttrInfo(&attrInfo[nArgs],
                       L"ntSecurityDescriptor",
                       ADS_ATTR_UPDATE,
                       ADSTYPE_NT_SECURITY_DESCRIPTOR,
                       &AdsValue[nArgs],
                       1);

      nArgs++;
    }
  }

  // **** ID

  hres = pSrcPolicyObj->Get(g_bstrID, 0, &v[nArgs], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     g_bstrADID, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs], 
                     1);

    AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);
  }
  else
    return WBEM_E_ILLEGAL_NULL;
  int lIDIndex = nArgs++;

  // **** Description

  hres = pSrcPolicyObj->Get(g_bstrDescription, 0, &v[nArgs], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     g_bstrADDescription, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs], 
                     1);

    AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

    nArgs++;
  }

  // **** ClassDefinition and InstanceDefinitions

  hres = pSrcPolicyObj->Get(g_bstrClassDefinition, 0, &vClassDef, NULL, NULL);
  if(FAILED(hres)) return hres;

  hres = pSrcPolicyObj->Get(L"InstanceDefinitions", 0, &v[nArgs], NULL, NULL);
  if(FAILED(hres)) return hres;

  offset.LowPart = 0;
  offset.HighPart = 0;

  hres = ClassDefBuffer.Seek(offset, STREAM_SEEK_SET, NULL);
  if(FAILED(hres)) return hres;

  SafeArray<IUnknown*, VT_UNKNOWN>
    Array1(&v[nArgs]);

  _itow(Array1.Size(), swArraySize, 10);

  ClassDefBuffer.Write(swArraySize, sizeof(wchar_t) * 20, NULL);

  if((vClassDef.vt == VT_UNKNOWN) && (vClassDef.punkVal != NULL))
  {
    hres = CoMarshalInterface(&ClassDefBuffer, 
                              IID_IWbemClassObject, 
                              vClassDef.punkVal, 
                              MSHCTX_NOSHAREDMEM, 
                              NULL, 
                              MSHLFLAGS_TABLESTRONG);

    if(FAILED(hres)) return hres;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  for(c1 = 0; c1 < Array1.Size(); c1++)
  {
    hres = CoMarshalInterface(&ClassDefBuffer, 
                              IID_IUnknown, 
                              Array1[c1], 
                              MSHCTX_NOSHAREDMEM, 
                              NULL, 
                              MSHLFLAGS_TABLESTRONG);

    if(FAILED(hres)) return hres;
  }

  Init_AdsAttrInfo(&attrInfo[nArgs], 
                   g_bstrADTargetObject, 
                   ADS_ATTR_UPDATE, 
                   ADSTYPE_OCTET_STRING, 
                   &AdsValue[nArgs], 
                   1);

  AdsValue[nArgs].OctetString.dwLength = ClassDefBuffer.GetIndex();
  AdsValue[nArgs].OctetString.lpValue = ClassDefBuffer.GetRawData();
  nArgs++;

  // **** SourceOrganization

  hres = pSrcPolicyObj->Get(g_bstrSourceOrganization, 0, &v[nArgs], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     g_bstrADSourceOrganization, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs], 
                     1);

    AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

    nArgs++;
  }

  // **** Author

  hres = pSrcPolicyObj->Get(g_bstrAuthor, 0, &v[nArgs], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     g_bstrADAuthor, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs], 
                     1);

    AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

    nArgs++;
  }

  // **** ChangeDate

  hres = pSrcPolicyObj->Get(g_bstrChangeDate, 0, &v[nArgs], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     g_bstrADChangeDate, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs], 
                     1);

    AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

    nArgs++;
  }

  // **** CreationDate

  hres = pSrcPolicyObj->Get(g_bstrCreationDate, 0, &v[nArgs], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs].vt == VT_BSTR) && (v[nArgs].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs], 
                     g_bstrADCreationDate, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs], 
                     1);

    AdsValue[nArgs].CaseIgnoreString = V_BSTR(&v[nArgs]);

    nArgs++;
  }

  // **** create AD PolicyType object

  hres = pDestContainer->CreateDSObject(QString(L"CN=") << AdsValue[lIDIndex].CaseIgnoreString, attrInfo, nArgs, &pDisp);
  if(FAILED(hres)) return hres;
  if(pDisp == NULL) return WBEM_E_FAILED;

  return WBEM_S_NO_ERROR;
}

HRESULT PolicyType_ADToCIM(IWbemClassObject **ppDestPolicyTypeObj,
                           IDirectoryObject *pSrcPolicyTypeObj, 
                           IWbemServices *pDestCIM)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1, v2, v3;

  wchar_t* AttrNames[] =
  {
    g_bstrADID,
    g_bstrADDescription,
    g_bstrADTargetObject,
    g_bstrADSourceOrganization,
    g_bstrADAuthor,
    g_bstrADChangeDate,
    g_bstrADCreationDate
  };

  BYTE defaultBuffer[2048];
  ULONG bWritten = 0;
  LARGE_INTEGER offset;

  CBuffer
    ClassDefBuffer(defaultBuffer, 2048, FALSE);

  ADsStruct<ADS_ATTR_INFO>
    pAttrInfo;

  ADS_SEARCH_HANDLE
    SearchHandle;
 
  ADS_SEARCH_COLUMN
    SearchColumn;

  unsigned long
    c1, c2, 
    dwReturn;

  CComPtr<IDirectorySearch>
    pDirSrch;

  CComPtr<IWbemClassObject>
    pClassDef,
    pDestPolicyTypeObj,
    pDestClassDefinitionObj;

  IWbemContext 
    *pCtx = 0;

  ADsStruct<ADS_OBJECT_INFO>
    pInfo;

  SafeArray<IUnknown*, VT_UNKNOWN>
    Array1;

  wchar_t
    swArraySize[20]; 

  // **** create empty PolicyType object

  hres = pDestCIM->GetObject(g_bstrClassPolicyType, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef == NULL) return WBEM_E_FAILED;

  hres = pClassDef->SpawnInstance(0, ppDestPolicyTypeObj);
  if(FAILED(hres)) return hres;
  pDestPolicyTypeObj = *ppDestPolicyTypeObj;
  if(pDestPolicyTypeObj == NULL) return WBEM_E_INVALID_CLASS;

  // **** get object attributes

  hres = pSrcPolicyTypeObj->GetObjectAttributes(AttrNames, 7, &pAttrInfo, &dwReturn);
  if(FAILED(hres)) return hres;
  if(pAttrInfo == NULL) return WBEM_E_NOT_FOUND;

  // **** Domain

  hres = pSrcPolicyTypeObj->GetObjectInformation(&pInfo);
  if(SUCCEEDED(hres) && (pInfo != NULL))
  {
    QString
      DomainName;

    hres = DomainNameFromDistName(DomainName, QString(pInfo->pszObjectDN));

    v1 = (wchar_t*)DomainName;
    hres = pDestPolicyTypeObj->Put(g_bstrDomain, 0, &v1, 0);
  }

  if(pInfo == NULL) return WBEM_E_FAILED;
  if(FAILED(hres)) return hres;

  for(c1 = 0; c1 < dwReturn; c1++)
  {
    // **** ID

    if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADID))
    {
      v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
      hres = pDestPolicyTypeObj->Put(g_bstrID, 0, &v1, 0);
    }

    // **** Description

    else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADDescription))
    {
      v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
      hres = pDestPolicyTypeObj->Put(g_bstrDescription, 0, &v1, 0);
    }

    // **** ClassDefinition

    else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADTargetObject))
    {
      ADSVALUE
        *pADsObj = (pAttrInfo + c1)->pADsValues;

      IUnknown
        *pUnknown = NULL;

      offset.LowPart = 0;
      offset.HighPart = 0;

      if(NULL != pADsObj)
      {
        hres = ClassDefBuffer.Seek(offset, STREAM_SEEK_SET, NULL);
        if(SUCCEEDED(hres))
        {
          hres = ClassDefBuffer.Write(pADsObj->OctetString.lpValue, pADsObj->OctetString.dwLength, &bWritten);
          if(SUCCEEDED(hres))
          {
            hres = ClassDefBuffer.Seek(offset, STREAM_SEEK_SET, NULL);
            if(SUCCEEDED(hres))
            {
              ClassDefBuffer.Read(swArraySize, sizeof(wchar_t) * 20, NULL);
              int
                nElts = _wtoi(swArraySize);

              hres = CoUnmarshalInterface(&ClassDefBuffer, IID_IWbemClassObject, (void**)&pDestClassDefinitionObj);
              if(SUCCEEDED(hres))
              {
                v1 = pDestClassDefinitionObj.p;
                hres = pDestPolicyTypeObj->Put(g_bstrClassDefinition, 0, &v1, 0);
                VariantClear(&v1);

                if(SUCCEEDED(hres))
                {
                  // **** InstanceDefinitions

                  while(nElts-- && SUCCEEDED(hres = CoUnmarshalInterface(&ClassDefBuffer, IID_IUnknown, (void**)&pUnknown)))
                  {
                    Array1.ReDim(0, Array1.Size() + 1);
                    Array1[Array1.IndexMax()] = pUnknown;
                    // Array1[Array1.IndexMax()]->AddRef();
                    pUnknown = NULL;
                  }

                  if(0 < Array1.Size())
                  {
                    V_VT(&v1) = (VT_UNKNOWN | VT_ARRAY);
                    V_ARRAY(&v1) = Array1.Data();
                    hres = pDestPolicyTypeObj->Put(L"InstanceDefinitions", 0, &v1, 0);
                  }
                }
              }
            }
          }
        }
      }
    }

    // **** SourceOrganization

    else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADSourceOrganization))
    {
      v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
      hres = pDestPolicyTypeObj->Put(g_bstrSourceOrganization, 0, &v1, 0);
    }

    // **** Author

    else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADAuthor))
    {
      v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
      hres = pDestPolicyTypeObj->Put(g_bstrAuthor, 0, &v1, 0);
    }

    // **** ChangeDate

    else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADChangeDate))
    {
      v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
      hres = pDestPolicyTypeObj->Put(g_bstrChangeDate, 0, &v1, 0);
      // dates are easy to mess up, we won't bail out for it
      if (hres == WBEM_E_TYPE_MISMATCH)
      {
          ERRORTRACE((LOG_ESS, "POLICMAN: Type mismatch on date property\n"));
          hres = WBEM_S_NO_ERROR;
      }
    }

    // **** CreationDate

    else if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADCreationDate))
    {
      v1 = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;
      hres = pDestPolicyTypeObj->Put(g_bstrCreationDate, 0, &v1, 0);
      // dates are easy to mess up, we won't bail out for it
      if (hres == WBEM_E_TYPE_MISMATCH)
      {
          ERRORTRACE((LOG_ESS, "POLICMAN: Type mismatch on date property\n"));
          hres = WBEM_S_NO_ERROR;
      }
    }

    if(FAILED(hres)) return hres;
  }

  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\som.cpp ===
#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <wbemtime.h>
#include <activeds.h>
#include <ArrTempl.h>
#include <comutil.h>
#undef _ASSERT
#include <atlbase.h>
#include <activeds.h>
#include <string.h>
#include "Utility.h"

/*********************************************************************
************** Active Directory Methods ******************************
*********************************************************************/

#define MAX_ATTR_SOM 20
#define MAX_ATTR_RULE 5

#define DELIMITER L';'
#define DELIMITER_STR L";"

HRESULT Som_CIMToAD(IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer, long lFlags)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v[MAX_ATTR_SOM];

  long 
    nArgs_SOM = 0,
    c1;

  CComPtr<IDispatch>
    pDisp; 

  CComPtr<IDirectoryObject>
    pDestSomObj;

  ADsObjAutoDelete
    AutoDelete;

  CComQIPtr<IADsContainer, &IID_IADsContainer>
    pADsContainer = pDestContainer;

  SafeArray<IUnknown*, VT_UNKNOWN>
    Array1;

  BYTE defaultBuffer[2048];
  ULONG bWritten = 0;
  LARGE_INTEGER offset;

  ADSVALUE
    AdsValue[MAX_ATTR_SOM];
 
  ADS_ATTR_INFO 
    attrInfo[MAX_ATTR_SOM];

  WBEMTime
    wtCurrentTime;

  SYSTEMTIME
    SystemTime;

  CComBSTR
    bstrID,
    bstrCurrentTimeDTMF,
    RulesBuffer,
    NULL_STRING(L"\0"),
    SomName(L"CN=");

  // **** get current time
  
  GetSystemTime(&SystemTime);

  wtCurrentTime = SystemTime;
  bstrCurrentTimeDTMF.Attach(wtCurrentTime.GetDMTF(FALSE));

  Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                   g_bstrADObjectClass, 
                   ADS_ATTR_UPDATE, 
                   ADSTYPE_CASE_IGNORE_STRING, 
                   &AdsValue[nArgs_SOM], 
                   1);

  AdsValue[nArgs_SOM].CaseIgnoreString = g_bstrADClassSom;
  int lTypeIndex = nArgs_SOM++;


  // **** ID

  hres = pSrcPolicyObj->Get(g_bstrID, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;
  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
      Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                       g_bstrADID, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs_SOM], 
                       1);

      AdsValue[nArgs_SOM].CaseIgnoreString = V_BSTR(&v[nArgs_SOM]);
  }
  else
      return WBEM_E_ILLEGAL_NULL;
  int lIDIndex = nArgs_SOM++;

  SomName.Append(AdsValue[lIDIndex].CaseIgnoreString);

  // **** security descriptor

 // PSECURITY_DESCRIPTOR
 //   pSD = GetADSecurityDescriptor(pDestContainer);

 // CNtSecurityDescriptor
 //   cSD(pSD, TRUE);

//  if(NULL == pSD)
//  {
//    ERRORTRACE((LOG_ESS, "POLICMAN: could not create security descriptor for som filter object\n"));
//    return WBEM_E_OUT_OF_MEMORY;
//  }

  ADsStruct<ADS_ATTR_INFO>
    SecDescValue;

  CNtSecurityDescriptor cSD;

  // flag to indicate whether we're updating an existing object as opposed to creating a new one.
  bool bEditExisting = false;

  pDisp.Release();
  if(SUCCEEDED(hres = pADsContainer->GetObject(g_bstrADClassSom, SomName, &pDisp)))
  {
    bEditExisting = true;

    if(lFlags & WBEM_FLAG_CREATE_ONLY) return WBEM_E_ALREADY_EXISTS;

    // HACK HACK HACK!
    // okay, at this point we know that we're editing an existing object.
    // therefor, we do *not* want to set the id or type
    // back up the array pointer - all the ATL classes should clean up after themselves with no problem.
    nArgs_SOM = 0;

    
    // we'll simply leave the existing security descriptor in place

    /*************************************************
    CComQIPtr<IDirectoryObject, &IID_IDirectoryObject>
      pDirObj = pDisp;

    PADS_ATTR_INFO pAttrInfo = NULL;
    pDisp = NULL;

    LPWSTR pAttrName = L"ntSecurityDescriptor";
    DWORD dwReturn;

    hres = pDirObj->GetObjectAttributes(&pAttrName, 1, &pAttrInfo, &dwReturn);
    if((dwReturn != 1) || (pAttrInfo->dwADsType != ADSTYPE_NT_SECURITY_DESCRIPTOR)) return WBEM_E_FAILED;
    SecDescValue = pAttrInfo;
    if(FAILED(hres)) return hres;

    Init_AdsAttrInfo(&attrInfo[nArgs_SOM],
                   L"ntSecurityDescriptor",
                   ADS_ATTR_UPDATE,
                   ADSTYPE_NT_SECURITY_DESCRIPTOR,
                   pAttrInfo->pADsValues,
                   1);
    ***************************************************/
  }
  else
  {
      if(WBEM_FLAG_UPDATE_ONLY & lFlags)
          return WBEM_E_NOT_FOUND;

      bEditExisting = false;

      
      hres = GetOwnerSecurityDescriptor(cSD);
      if (FAILED(hres)) return hres;

    if(CNtSecurityDescriptor::NoError == cSD.GetStatus())
    {

      AdsValue[nArgs_SOM].SecurityDescriptor.dwLength = cSD.GetSize();
      AdsValue[nArgs_SOM].SecurityDescriptor.lpValue = (LPBYTE) cSD.GetPtr();

      Init_AdsAttrInfo(&attrInfo[nArgs_SOM],
                   L"ntSecurityDescriptor",
                   ADS_ATTR_UPDATE,
                   ADSTYPE_NT_SECURITY_DESCRIPTOR,
                   &AdsValue[nArgs_SOM],
                   1);
    }
    else
        return WBEM_E_FAILED;
        
    nArgs_SOM++;
  }

  pDisp.Release();
  
  // **** Name

  hres = pSrcPolicyObj->Get(g_bstrName, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADName, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = V_BSTR(&v[nArgs_SOM]);

    nArgs_SOM++;
  }
  else
      return WBEM_E_ILLEGAL_NULL;

  // **** Description

  hres = pSrcPolicyObj->Get(g_bstrDescription, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADDescription, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = V_BSTR(&v[nArgs_SOM]);

    nArgs_SOM++;
  }
  else if (bEditExisting)
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADDescription, 
                     ADS_ATTR_CLEAR, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = NULL_STRING;

    nArgs_SOM++;
  }

  // **** SourceOrganization

  hres = pSrcPolicyObj->Get(g_bstrSourceOrganization, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADSourceOrganization, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = V_BSTR(&v[nArgs_SOM]);

    nArgs_SOM++;
  }
  else if (bEditExisting)
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADSourceOrganization, 
                     ADS_ATTR_CLEAR, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = NULL_STRING;

    nArgs_SOM++;
  }

  // **** Author

  hres = pSrcPolicyObj->Get(g_bstrAuthor, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADAuthor, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = V_BSTR(&v[nArgs_SOM]);

    nArgs_SOM++;
  }
  else if (bEditExisting)
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADAuthor, 
                     ADS_ATTR_CLEAR, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = NULL_STRING;

    nArgs_SOM++;

  }

  // **** ChangeDate

  Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                   g_bstrADChangeDate, 
                   ADS_ATTR_UPDATE, 
                   ADSTYPE_CASE_IGNORE_STRING, 
                   &AdsValue[nArgs_SOM], 
                   1);

  AdsValue[nArgs_SOM].CaseIgnoreString = bstrCurrentTimeDTMF;

  nArgs_SOM++;

  // **** CreationDate

  // **** if object already exists, leave it be

  //  CComVariant
  //    vCreationDate;

  BSTR creationDate = NULL;

  if (!bEditExisting)
  {
      Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                       g_bstrADCreationDate, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs_SOM], 
                       1);
      AdsValue[nArgs_SOM].CaseIgnoreString = bstrCurrentTimeDTMF;

      nArgs_SOM++;
  }


  /***********************************
  if(SUCCEEDED(hres = pADsContainer->GetObject(NULL, SomName, &pDisp)))
  {
    CComQIPtr<IADs, &IID_IADs>
      pADsLegacyObj = pDisp;

    hres = pADsLegacyObj->Get(g_bstrADCreationDate, &vCreationDate);
    if (SUCCEEDED(hres))
        creationDate = vCreationDate.bstrVal;
    else if (hres == E_ADS_PROPERTY_NOT_FOUND)
    // support for legacy objects, might not have creation date filled
        creationDate = NULL;
    else return hres;

  }
  else
    creationDate = wtCurrentTime.GetDMTF(FALSE);

  if (creationDate != NULL)
  {
      AdsValue[nArgs_SOM].CaseIgnoreString = creationDate;

      Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                       g_bstrADCreationDate, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs_SOM], 
                       1);
      nArgs_SOM++;
  }
  **********************************/

  // **** Rules

  hres = pSrcPolicyObj->Get(g_bstrRules, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if(v[nArgs_SOM].vt != (VT_ARRAY | VT_UNKNOWN)) return WBEM_E_TYPE_MISMATCH;

  Array1 = &v[nArgs_SOM];

  wchar_t
    swArraySize[20];

  _itow(Array1.Size(), swArraySize, 10);
  RulesBuffer = swArraySize;
  RulesBuffer += DELIMITER_STR;

  for(c1 = 0; c1 < Array1.Size(); c1++)
  {
    CComVariant
      vLanguage,
      vNameSpace,
      vQuery;

    int
      languageLength,
      nameSpaceLength,
      queryLength;

    CComPtr<IWbemClassObject>
      pRuleObj;

    hres = Array1[c1]->QueryInterface(IID_IWbemClassObject, (void **)&pRuleObj);
    if(FAILED(hres)) return hres;
    if(pRuleObj == NULL) return WBEM_E_FAILED;

    // **** QueryLanguage

    hres = pRuleObj->Get(g_bstrQueryLanguage, 0, &vLanguage, NULL, NULL);
    if(FAILED(hres)) return hres;
    if((vLanguage.vt != VT_BSTR) || (vLanguage.bstrVal == NULL))
      return WBEM_E_ILLEGAL_NULL;

    languageLength = wcslen(vLanguage.bstrVal);
    _itow(languageLength, swArraySize, 10);
    RulesBuffer += swArraySize;
    RulesBuffer += DELIMITER_STR;

    // **** NameSpace

    hres = pRuleObj->Get(g_bstrTargetNameSpace, 0, &vNameSpace, NULL, NULL);
    if(FAILED(hres)) return hres;
    if((vNameSpace.vt != VT_BSTR) || (vNameSpace.bstrVal == NULL))
      return WBEM_E_ILLEGAL_NULL;

    nameSpaceLength = wcslen(vNameSpace.bstrVal);
    _itow(nameSpaceLength, swArraySize, 10);
    RulesBuffer += swArraySize;
    RulesBuffer += DELIMITER_STR;

    // **** Query

    hres = pRuleObj->Get(g_bstrQuery, 0, &vQuery, NULL, NULL);
    if(FAILED(hres)) return hres;
    if((vQuery.vt != VT_BSTR) || (vQuery.bstrVal == NULL))
      return WBEM_E_ILLEGAL_NULL;

    queryLength = wcslen(vQuery.bstrVal);
    _itow(queryLength, swArraySize, 10);
    RulesBuffer += swArraySize;
    RulesBuffer += DELIMITER_STR;

    // **** write the contents of the current rule

    RulesBuffer += vLanguage.bstrVal;
    RulesBuffer += DELIMITER_STR;
    RulesBuffer += vNameSpace.bstrVal;
    RulesBuffer += DELIMITER_STR;
    RulesBuffer += vQuery.bstrVal;
    RulesBuffer += DELIMITER_STR;
  }

  Init_AdsAttrInfo(&attrInfo[nArgs_SOM],
                   g_bstrADParam2,
                   ADS_ATTR_UPDATE,
                   ADSTYPE_CASE_IGNORE_STRING,
                   &AdsValue[nArgs_SOM],
                   1);

  AdsValue[nArgs_SOM].CaseIgnoreString = (BSTR)RulesBuffer;
  nArgs_SOM++;

  // **** create AD SOM object

  pDisp.Release();
  if (bEditExisting && SUCCEEDED(hres = pADsContainer->GetObject(g_bstrADClassSom, SomName, &pDisp)))
  {
    if(!pDisp) return WBEM_E_FAILED;
    
    CComQIPtr<IDirectoryObject>
      pDirObj = pDisp;

    DWORD dwAttrsModified;
    hres = pDirObj->SetObjectAttributes(attrInfo, nArgs_SOM, &dwAttrsModified);

    if(FAILED(hres)) 
    {
	    ERRORTRACE((LOG_ESS, "POLICMAN: SetObjectAttributes failed: 0x%08X\n", hres));
	    return hres;
    }
  }
  else
  {
      pDisp.Release(); hres = pDestContainer->CreateDSObject(SomName, attrInfo, nArgs_SOM, &pDisp);

      if(FAILED(hres) || (!pDisp)) 
      {
		    ERRORTRACE((LOG_ESS, "POLICMAN: CreateDSObject failed: 0x%08X\n", hres));
	      return hres;
      }
  }

  return WBEM_S_NO_ERROR;
}

struct ReleaseSearchHandle
{
  ADS_SEARCH_HANDLE
    pHandle;

  CComPtr<IDirectorySearch>
    pDirSrch;

  ReleaseSearchHandle(ADS_SEARCH_HANDLE pIHandle, CComPtr<IDirectorySearch> &pIDirSrch)
  { pDirSrch = pIDirSrch; pHandle = pIHandle; }

  ~ReleaseSearchHandle(void)
  {if(pHandle) pDirSrch->CloseSearchHandle(pHandle); }
};

HRESULT Som_ADToCIM(IWbemClassObject **ppDestSomObj,
                    IDirectoryObject *pSrcSomObj, 
                    IWbemServices *pDestCIM)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1;

  wchar_t
    *AttrNames[] =
    {
      g_bstrADID,
      g_bstrADName,
      g_bstrADDescription,
      g_bstrADSourceOrganization,
      g_bstrADAuthor,
      g_bstrADChangeDate,
      g_bstrADCreationDate
    },
    *AttrNames2[] = 
    {
      g_bstrADParam2
    };

  ADsStruct<ADS_ATTR_INFO>
    pAttrInfo,
    pAttrInfo2;

  unsigned long
    c1, c2, dwReturn, dwReturn2;

  CComPtr<IWbemClassObject>
    pClassDef,
    pClassDef_RULE,
    pDestSomObj;

  IWbemContext 
    *pCtx = 0;

  ADsStruct<ADS_OBJECT_INFO>
    pInfo;

  // **** create empty som object

  hres = pDestCIM->GetObject(g_bstrClassSom, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef == NULL) return WBEM_E_FAILED;

  hres = pClassDef->SpawnInstance(0, ppDestSomObj);
  if(FAILED(hres)) return hres;
  pDestSomObj = *ppDestSomObj;
  if(pDestSomObj == NULL) return WBEM_E_NOT_FOUND;

  // **** get object attributes

  hres = pSrcSomObj->GetObjectAttributes(AttrNames, 7, &pAttrInfo, &dwReturn);
  if(FAILED(hres)) return hres;
  if(pAttrInfo == NULL) return WBEM_E_NOT_FOUND;

  // **** get Param2 attribute

  hres = pSrcSomObj->GetObjectAttributes(AttrNames2, 1, &pAttrInfo2, &dwReturn2);
  if(FAILED(hres)) return hres;

  // **** Domain

  hres = pSrcSomObj->GetObjectInformation(&pInfo);
  if(SUCCEEDED(hres) && (pInfo != NULL))
  {
    QString
      LDAPName(pInfo->pszObjectDN),
      DomainName;

    hres = DomainNameFromDistName(DomainName, LDAPName);

    v1 = (wchar_t*)DomainName;
    hres = pDestSomObj->Put(g_bstrDomain, 0, &v1, 0);
  }

  if(pInfo == NULL) return WBEM_E_FAILED;
  if(FAILED(hres)) return hres;

  for(c1 = 0; c1 < dwReturn; c1++)
  {
    if((pAttrInfo + c1) == NULL)
      return WBEM_E_OUT_OF_MEMORY;

    BSTR
      bstrName = (pAttrInfo + c1)->pszAttrName,
      bstrValue = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;

    if((NULL == bstrName) || (NULL == bstrValue))
      return WBEM_E_OUT_OF_MEMORY;

    v1 = bstrValue;

    // **** ID

    if(0 == _wcsicmp(bstrName, g_bstrADID))
    {
      hres = pDestSomObj->Put(g_bstrID, 0, &v1, 0);
    }

    // **** Name

    else if(0 == _wcsicmp(bstrName, g_bstrADName))
    {
      hres = pDestSomObj->Put(g_bstrName, 0, &v1, 0);
    }

    // **** Description

    else if(0 == _wcsicmp(bstrName, g_bstrADDescription))
    {
      hres = pDestSomObj->Put(g_bstrDescription, 0, &v1, 0);
    }

    // **** SourceOrganization

    else if(0 == _wcsicmp(bstrName, g_bstrADSourceOrganization))
    {
      hres = pDestSomObj->Put(g_bstrSourceOrganization, 0, &v1, 0);
    }

    // **** Author

    else if(0 == _wcsicmp(bstrName, g_bstrADAuthor))
    {
      hres = pDestSomObj->Put(g_bstrAuthor, 0, &v1, 0);
    }

    // **** ChangeDate

    else if(0 == _wcsicmp(bstrName, g_bstrADChangeDate))
    {
      hres = pDestSomObj->Put(g_bstrChangeDate, 0, &v1, 0);
    }

    // **** CreationDate

    else if(0 == _wcsicmp(bstrName, g_bstrADCreationDate))
    {
      hres = pDestSomObj->Put(g_bstrCreationDate, 0, &v1, 0);
    }

    if(FAILED(hres)) return hres;
  }

  // **** cache rule class definition

  hres = pDestCIM->GetObject(g_bstrClassRule, 0, pCtx, &pClassDef_RULE, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef_RULE == NULL) return hres;

  // **** now, get Rule objects that are children of this som object

  if(dwReturn2)
  {
    CComBSTR
      RulesBuffer = pAttrInfo2->pADsValues->CaseIgnoreString;

    wchar_t
      *pBeginChar = RulesBuffer,
      *pEndChar = RulesBuffer;

    if(NULL == pEndChar) return WBEM_S_NO_ERROR;

    // **** get number of rules

    pEndChar = wcschr(pEndChar, DELIMITER);
    if(NULL == pEndChar) return WBEM_S_NO_ERROR;
    *pEndChar = L'\0';
    int 
      cElt = 0,
      nElts = _wtoi(pBeginChar);

    for(cElt = 0; (pEndChar) && (cElt < nElts); cElt++)
    {
      CComVariant
        vLanguage,
        vTargetNameSpace,
        vQuery,
        vRules1,
        vRules2;

      int
        numScanned,
        langLength,
        nameSpaceLength,
        queryLength;

      CComPtr<IWbemClassObject>
        pDestRuleObj;

      CComPtr<IUnknown>
        pUnknown;

      // **** get length of fields

      pBeginChar = pEndChar + 1;
      numScanned = swscanf(pBeginChar, L"%d;%d;%d;", &langLength, &nameSpaceLength, &queryLength);
      if(3 != numScanned) break;
      pEndChar = wcschr(pEndChar + 1, DELIMITER);
      pEndChar = wcschr(pEndChar + 1, DELIMITER);
      pEndChar = wcschr(pEndChar + 1, DELIMITER);

      // **** create new rule object 

      hres = pClassDef_RULE->SpawnInstance(0, &pDestRuleObj);
      if(FAILED(hres)) return hres;
      if(pDestRuleObj == NULL) return WBEM_E_NOT_FOUND;

      // **** QueryLanguage

      pBeginChar = pEndChar + 1;
      pEndChar = pBeginChar + langLength;
      if(pEndChar)
      {
        *pEndChar = L'\0';
        vLanguage = pBeginChar;
        hres = pDestRuleObj->Put(g_bstrQueryLanguage, 0, &vLanguage, 0);
        if(FAILED(hres)) return hres;
      }
      else break;

      // **** NameSpace

      pBeginChar = pEndChar + 1;
      pEndChar = pBeginChar + nameSpaceLength;
      if(pEndChar)
      {
        *pEndChar = L'\0';
        vTargetNameSpace = pBeginChar;
        hres = pDestRuleObj->Put(g_bstrTargetNameSpace, 0, &vTargetNameSpace, 0);
        if(FAILED(hres)) return hres;
      }
      else break;

      // **** QueryLanguage

      pBeginChar = pEndChar + 1;
      pEndChar = pBeginChar + queryLength;
      if(pEndChar)
      {
        *pEndChar = L'\0';
        vQuery = pBeginChar;
        hres = pDestRuleObj->Put(g_bstrQuery, 0, &vQuery, 0);
        if(FAILED(hres)) return hres;
      }
      else break;

      // **** stuff new rule object into SOM object

      hres = pDestSomObj->Get(g_bstrRules, 0, &vRules1, NULL, NULL);
      if(FAILED(hres)) return hres;

      SafeArray<IUnknown*, VT_UNKNOWN>
        Rules(&vRules1);

      hres = pDestRuleObj->QueryInterface(IID_IUnknown, (void**)&pUnknown);
      if(FAILED(hres)) return hres;
      if(pUnknown == NULL) return WBEM_E_FAILED;

      Rules.ReDim(0, Rules.Size() + 1);
      Rules[Rules.IndexMax()] = pUnknown;
      Rules[Rules.IndexMax()]->AddRef();

      // **** place array in dest som object

      V_VT(&vRules2) = (VT_ARRAY | Rules.Type());
      V_ARRAY(&vRules2) = Rules.Data();
      hres = pDestSomObj->Put(g_bstrRules, 0, &vRules2, 0);
      if(FAILED(hres)) return hres;
    }
  }
  else
  {
    ADS_SEARCH_HANDLE
      SearchHandle;
 
    ADS_SEARCH_COLUMN
      SearchColumn;

    CComPtr<IDirectorySearch>
      pDirSrch;

    hres = pSrcSomObj->QueryInterface(IID_IDirectorySearch, (void **)&pDirSrch);
    if(FAILED(hres)) return hres;

    CComBSTR
      qsQuery(L"(objectClass=");

    qsQuery.Append(g_bstrADClassRule);
    qsQuery.Append(L")");

    hres = pDirSrch->ExecuteSearch(qsQuery, NULL, -1, &SearchHandle);
    if(FAILED(hres)) return hres;

    ReleaseSearchHandle
      HandleReleaseMe(SearchHandle, pDirSrch);

    while(S_OK == (hres = pDirSrch->GetNextRow(SearchHandle)))
    {
      CComVariant
        vLanguage,
        vNameSpace,
        vQuery,
        vRules1,
        vRules2;
  
      CComPtr<IUnknown>
        pUnknown;
  
      CComPtr<IWbemClassObject>
        pDestRuleObj;
  
      // **** create empty rule object
  
      hres = pClassDef_RULE->SpawnInstance(0, &pDestRuleObj);
      if(FAILED(hres)) return hres;
      if(pDestRuleObj == NULL) return WBEM_E_NOT_FOUND;
  
      // **** QueryLanguage
  
      hres = pDirSrch->GetColumn(SearchHandle, g_bstrADQueryLanguage, &SearchColumn);
      if((SUCCEEDED(hres)) && (ADSTYPE_INVALID != SearchColumn.dwADsType) && (NULL != SearchColumn.pADsValues))
      {
        vLanguage = SearchColumn.pADsValues->CaseIgnoreString;
  
        hres = pDestRuleObj->Put(g_bstrQueryLanguage, 0, &vLanguage, 0);
        pDirSrch->FreeColumn(&SearchColumn);
        if(FAILED(hres)) return hres;
      }
  
      // **** TargetNameSpace
  
      hres = pDirSrch->GetColumn(SearchHandle, g_bstrADTargetNameSpace, &SearchColumn);
      if((SUCCEEDED(hres)) && (ADSTYPE_INVALID != SearchColumn.dwADsType) && (NULL != SearchColumn.pADsValues))
      {
        vNameSpace = SearchColumn.pADsValues->CaseIgnoreString;
  
        hres = pDestRuleObj->Put(g_bstrTargetNameSpace, 0, &vNameSpace, 0);
        pDirSrch->FreeColumn(&SearchColumn);
        if(FAILED(hres)) return hres;
      }
  
      // **** Query
  
      hres = pDirSrch->GetColumn(SearchHandle, g_bstrADQuery, &SearchColumn);
      if((SUCCEEDED(hres)) && (ADSTYPE_INVALID != SearchColumn.dwADsType) && (NULL != SearchColumn.pADsValues))
      {
        vQuery = SearchColumn.pADsValues->CaseIgnoreString;
  
        hres = pDestRuleObj->Put(g_bstrQuery, 0, &vQuery, 0);
        hres = pDirSrch->FreeColumn(&SearchColumn);
        if(FAILED(hres)) return hres;
      }
  
      // **** stuff new rule object into SOM object
  
      hres = pDestSomObj->Get(g_bstrRules, 0, &vRules1, NULL, NULL);
      if(FAILED(hres)) return hres;
  
      SafeArray<IUnknown*, VT_UNKNOWN>
        Rules(&vRules1);
  
      hres = pDestRuleObj->QueryInterface(IID_IUnknown, (void**)&pUnknown);
      if(FAILED(hres)) return hres;
      if(pUnknown == NULL) return WBEM_E_FAILED;
  
      Rules.ReDim(0, Rules.Size() + 1);
      Rules[Rules.IndexMax()] = pUnknown;
      Rules[Rules.IndexMax()]->AddRef();
  
      // **** place array in dest som object
  
      V_VT(&vRules2) = (VT_ARRAY | Rules.Type());
      V_ARRAY(&vRules2) = Rules.Data();
      hres = pDestSomObj->Put(g_bstrRules, 0, &vRules2, 0);
      if(FAILED(hres)) return hres;
    }
  }
  
  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\test\gpoctrl\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__400CD0AF_5C4C_447E_8278_2AC250EC4A44__INCLUDED_)
#define AFX_DLLDATAX_H__400CD0AF_5C4C_447E_8278_2AC250EC4A44__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__400CD0AF_5C4C_447E_8278_2AC250EC4A44__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\test\gpoctrl\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "wmigpo_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\set_string.cpp ===
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>
#include <sys/timeb.h>
#include <comdef.h>
#include <comutil.h>
#include <atlbase.h>

// **** includes for AD

#include "windows.h"
#include "stdio.h"
#include "activeds.h"
#include "tchar.h"
 
#include "Utility.h"

/*
  Creates an AD based parameter object under the specified policy object from a CIM based obj.
*/

#define MAX_ATTR 8

HRESULT Set_String_Verify(IWbemClassObject *pSrcParamObj)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant 
    v1, v2, v3, vDefaultValue, v5;

  wchar_t buf[20];

  SafeArray<wchar_t*, VT_BSTR>
    Array1;
 
  long
    c1,
    nOptArgs = 0,
    nArgs = 0;

  nArgs++;

  // **** PropertyName

  hres = pSrcParamObj->Get(g_bstrPropertyName, 0, &v1, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_BSTR == V_VT(&v1)) && (NULL != V_BSTR(&v1)))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetType

  hres = pSrcParamObj->Get(g_bstrTargetType, 0, &v3, NULL, NULL);
  if(FAILED(hres)) return hres;
  if(VT_UI1 == V_VT(&v3))
  {
    nArgs++;
  }
  else
    return WBEM_E_ILLEGAL_NULL;

  // **** TargetClass

  hres = pSrcParamObj->Get(g_bstrTargetClass, 0, &v2, NULL, NULL);
  if(FAILED(hres)) return hres;

  if((VT_BSTR != V_VT(&v2)) || (NULL == V_BSTR(&v2)))
  {
    if(CIM_OBJECT == V_UI1(&v3)) return WBEM_E_ILLEGAL_NULL;
  }
  nArgs++;

  // **** Default

  hres = pSrcParamObj->Get(g_bstrDefault, 0, &vDefaultValue, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_BSTR == V_VT(&vDefaultValue)) && (NULL != V_BSTR(&vDefaultValue)))
  {
    nOptArgs++;
    nArgs++;
  }

  // **** ValidValues

  int
    DefInSet = 0;

  hres = pSrcParamObj->Get(g_bstrValidValues, 0, &v5, NULL, NULL);
  if(FAILED(hres)) return hres;
  if((VT_ARRAY | VT_BSTR) == V_VT(&v5))
  {
    Array1 = &v5;

      for(c1 = 0; c1 < Array1.Size(); c1++)
      {
        if(0 == _wcsicmp(V_BSTR(&vDefaultValue), Array1[c1]))
          DefInSet = 1;
      }

      nOptArgs++;
      nArgs++;

    if(DefInSet != 1)
      return WBEM_E_INVALID_PARAMETER;
  }

  // **** check that at least one of ValidValues or Default has been set

  if((nOptArgs < 1) || (nArgs < 5))
    hres = WBEM_E_INVALID_CLASS;

  return hres;
}

HRESULT Set_String_ADToCIM(IWbemClassObject **ppDestParamObj,
                           IDirectorySearch *pDirSrch, 
                           ADS_SEARCH_HANDLE pHandle, 
                           IWbemServices *pDestCIM)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  VARIANT
    v1;

  ADS_SEARCH_COLUMN
    Column;

  unsigned long c1;

  CComPtr<IUnknown>
    pUnknown;

  CComPtr<IWbemClassObject>
    pDestParamObj,
    pClassDef;

  IWbemContext 
    *pCtx = 0;

  // **** create empty set object

  hres = pDestCIM->GetObject(g_bstrClassSetString, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef == NULL) return WBEM_E_INVALID_CLASS;

  hres = pClassDef->SpawnInstance(0, ppDestParamObj);
  if(FAILED(hres)) return hres;
  pDestParamObj = *ppDestParamObj;
  if(pDestParamObj == NULL) return WBEM_E_INVALID_CLASS;

  // **** get object attributes

  // **** PropertyName

  hres = pDirSrch->GetColumn(pHandle, g_bstrADPropertyName, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseIgnoreString;
    hres = pDestParamObj->Put(g_bstrPropertyName, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetClass

  hres = pDirSrch->GetColumn(pHandle, g_bstrADTargetClass, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseIgnoreString;
    hres = pDestParamObj->Put(g_bstrTargetClass, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** TargetType

  hres = pDirSrch->GetColumn(pHandle, g_bstrADTargetType, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_UI1;
    V_UI1(&v1) = char(_wtoi(Column.pADsValues->CaseIgnoreString));
    hres = pDestParamObj->Put(g_bstrTargetType, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** default

  hres = pDirSrch->GetColumn(pHandle, g_bstrADStringDefault, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    V_VT(&v1) = VT_BSTR;
    V_BSTR(&v1) = Column.pADsValues->CaseIgnoreString;
    hres = pDestParamObj->Put(g_bstrDefault, 0, &v1, 0);
    pDirSrch->FreeColumn(&Column);
    if(FAILED(hres)) return hres;
  }

  // **** ValidValues

  hres = pDirSrch->GetColumn(pHandle, g_bstrADStringValidValues, &Column);
  if(SUCCEEDED(hres) && (ADSTYPE_INVALID != Column.dwADsType) && (NULL != Column.pADsValues))
  {
    SafeArray<wchar_t*, VT_BSTR>
      Array1(0, Column.dwNumValues);

    for(c1 = 0; c1 < Column.dwNumValues; c1++)
    {
      Array1[c1] = SysAllocString((Column.pADsValues + c1)->CaseIgnoreString);
    }

    V_VT(&v1) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&v1) = Array1.Data();
    hres = pDestParamObj->Put(g_bstrValidValues, 0, &v1, 0);

    pDirSrch->FreeColumn(&Column);
    VariantClear(&v1);

    if(FAILED(hres)) return hres;
  }

  return WBEM_S_NO_ERROR;
}

HRESULT Set_String_Merge(SafeArray<IUnknown*, VT_UNKNOWN> &ParamArray,
                         CComPtr<IWbemClassObject> &pClassObjMerged,
                         int &conflict)
{
  HRESULT
    hres = WBEM_E_FAILED;

  CComVariant
    vTopSet;

  CComPtr<IWbemClassObject>
    pClassObjFirst;

  long
    FirstElement, FoundElement, lNumInMerge, c1, c2, c3; 

  // **** initialize array for merged set

  for(FirstElement = 0; 
      (FirstElement < ParamArray.Size()) && (NULL == ParamArray[FirstElement]); 
      FirstElement++);

  if(FirstElement >= ParamArray.Size())
    return WBEM_E_FAILED;

  hres = ParamArray[FirstElement]->QueryInterface(IID_IWbemClassObject, (void **)&pClassObjFirst);
  hres = pClassObjFirst->Get(g_bstrValidValues, 0, &vTopSet, NULL, NULL);

  SafeArray<wchar_t*, VT_BSTR>
    TopSet(&vTopSet),
    DefaultValues(0, ParamArray.Size());

  if((TopSet.Size() < 1) || (ParamArray.Size() < 1)) return WBEM_E_INVALID_PARAMETER;

  // **** init array of flags indicating which members of TopSet are in the final merge set

  SafeArray<int, VT_I4>
    InBoth(TopSet.IndexMin(), TopSet.Size());

  lNumInMerge = TopSet.Size();

  for(c1 = InBoth.IndexMin(); c1 <= InBoth.IndexMax(); c1++)
    InBoth[c1] = TRUE;

  // **** itterate from most to least significant set

  for(c1 = FirstElement; c1 < ParamArray.Size(); c1++)
  {
    CComVariant
      vCurrentSet,
      vDefault;

    CComPtr<IWbemClassObject>
      pClassObjCurrent;

    if(NULL == ParamArray[c1])
      continue;

    // **** get ValidValues array for c1th element

    hres = ParamArray[c1]->QueryInterface(IID_IWbemClassObject, (void **)&pClassObjCurrent);
    hres = pClassObjCurrent->Get(g_bstrValidValues, 0, &vCurrentSet, NULL, NULL);

    SafeArray<wchar_t*, VT_BSTR>
      CurrentSet(&vCurrentSet);

    // **** get c1th default value

    hres = pClassObjCurrent->Get(g_bstrDefault, 0, &vDefault, NULL, NULL);
    DefaultValues[c1] = SysAllocString(V_BSTR(&vDefault));

    // **** find intersection of set (c1) with (c1 - 1)

    for(c2 = 0; c2 < TopSet.Size(); c2++)
    {
      // **** find element TopSet[c2] in the CurrentSet

      if(TRUE == InBoth[c2])
      {
        // **** find c2th element of merge set in the current set

        FoundElement = FALSE;
        c3 = 0;
        while((FALSE == FoundElement) && (c3 < CurrentSet.Size()))
        {
          if(0 == _wcsicmp(TopSet[c2], CurrentSet[c3]))
            FoundElement = TRUE;
          else
            c3 += 1;
        }

        if(FALSE == FoundElement)
        {
          InBoth[c2] = FALSE;
          lNumInMerge -= 1;
        }

        // **** check for empty set, if yes, indicate conflict

        if(lNumInMerge < 1)
        {
          conflict = c1;
          return WBEM_E_FAILED;
        }
      }
    }
  }

  SafeArray<wchar_t*, VT_BSTR>
    MergedSet(0, lNumInMerge);

  CComVariant
    vName,
    vClass,
    vType,
    vMergedDefault,
    vMergedSet;

  // **** now create set of merged elements

  c2 = -1;
  for(c1 = 0; c1 < lNumInMerge; c1++)
  {
    do
    {
      c2 += 1;
    } while((c2 < InBoth.Size()) && (FALSE == InBoth[c2]));
  
    MergedSet[c1] = SysAllocString(TopSet[c2]);
  }

  // **** find first matching default value

  for(c1 = ParamArray.Size() - 1; (c1 >= FirstElement) && (VT_EMPTY == V_VT(&vMergedDefault)); c1--)
  {
    // **** determine if c1th default value is within MergedSet

    if((NULL != ParamArray[c1]) && (NULL != DefaultValues[c1]))
    {
      c2 = 0;
      while((c2 < MergedSet.Size()) && 
            (NULL != MergedSet[c2]) &&
            (0 != _wcsicmp(DefaultValues[c1], MergedSet[c2])))
        c2 += 1;

      if(c2 < MergedSet.Size())
        vMergedDefault = DefaultValues[c1];
    }
  }

  if(VT_EMPTY == V_VT(&vMergedDefault))
  {
    vMergedDefault = MergedSet[0];
  }

  // **** create new merged set object

  hres = pClassObjFirst->SpawnInstance(0, &pClassObjMerged);

  hres = pClassObjFirst->Get(g_bstrPropertyName, 0, &vName, NULL, NULL);
  hres = pClassObjMerged->Put(g_bstrPropertyName, 0, &vName, 0);

  hres = pClassObjFirst->Get(g_bstrTargetClass, 0, &vClass, NULL, NULL);
  hres = pClassObjMerged->Put(g_bstrTargetClass, 0, &vClass, 0);

  hres = pClassObjFirst->Get(g_bstrTargetType, 0, &vType, NULL, NULL);
  hres = pClassObjMerged->Put(g_bstrTargetType, 0, &vType, 0);

  hres = pClassObjMerged->Put(g_bstrDefault, 0, &vMergedDefault, 0);

  V_VT(&vMergedSet) = (VT_ARRAY | VT_BSTR);
  V_ARRAY(&vMergedSet) = MergedSet.Data();
  hres = pClassObjMerged->Put(g_bstrValidValues, 0, &vMergedSet, 0);

  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\test\gpoctrl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\provider\wmigpo.cpp ===
#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <activeds.h>
#include <ArrTempl.h>
#include <comutil.h>
#undef _ASSERT
#include <atlbase.h>
#include <activeds.h>
#include "Utility.h"

/*********************************************************************
************** Active Directory Methods ******************************
*********************************************************************/
#define MAX_ATTR 4

HRESULT WMIGPO_CIMToAD(IWbemClassObject *pSrcWMIGPOObj, IDirectoryObject *pDestContainer, long lFlags)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1, v2, v3;

  long 
    nArgs = 0,
    numRules = 0,
    c1;

  CIMTYPE vtType1;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IWbemClassObject>
    pRuleObj;

  CComPtr<IDirectoryObject>
    pDestSomObj;

  CComPtr<IADsContainer>
    pADsContainer;

  ADSVALUE
    AdsValue[MAX_ATTR];
 
  ADS_ATTR_INFO 
    attrInfo[MAX_ATTR];

  Init_AdsAttrInfo(&attrInfo[nArgs], g_bstrADObjectClass, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING, &AdsValue[nArgs], 1);
  AdsValue[nArgs].CaseIgnoreString = g_bstrADClassWMIGPO;
  nArgs++;

  // **** TargetClass

  hres = pSrcWMIGPOObj->Get(L"PolicyTemplate", 0, &v1, NULL, NULL);
  if(FAILED(hres)) return hres;

  if(v1.vt != (VT_ARRAY | VT_BSTR))
  {
    return WBEM_E_ILLEGAL_NULL;
  }
  else
  {
    SafeArray<BSTR, VT_BSTR>
      Array1(&v1);

    QString
      references;

    for(c1 = 0; c1 < Array1.Size(); c1++)
    {
      references << Array1[c1] << L";";
    }

    Init_AdsAttrInfo(&attrInfo[nArgs], g_bstrADTargetClass, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING, &AdsValue[nArgs], 1);
    AdsValue[nArgs].CaseIgnoreString = references;
    nArgs++;

    // **** create AD WMIGPO object
 
    hres = pDestContainer->QueryInterface(IID_IADsContainer, (void**)&pADsContainer);
    if(FAILED(hres) || (pADsContainer == NULL)) return WBEM_E_FAILED;

    if(SUCCEEDED(hres = pADsContainer->GetObject(g_bstrADClassWMIGPO, L"CN=SINGLE_WMIGPO", &pDisp)))
    {
      if(pDisp == NULL) return WBEM_E_FAILED;
      if(lFlags & WBEM_FLAG_CREATE_ONLY) return WBEM_E_ALREADY_EXISTS;

      CComPtr<IADsDeleteOps>
        pDeleteOps;

      hres = pDisp->QueryInterface(IID_IADsDeleteOps, (void **)&pDeleteOps);
      if(FAILED(hres) || (pDeleteOps == NULL)) return WBEM_E_FAILED;

      hres = pDeleteOps->DeleteObject(0);
    }
    else
    {
      if(WBEM_FLAG_UPDATE_ONLY & lFlags) return WBEM_E_NOT_FOUND;
    }

    hres = pDestContainer->CreateDSObject(L"CN=SINGLE_WMIGPO", attrInfo, nArgs, &pDisp);
  }

  return hres;
}

HRESULT WMIGPO_ADToCIM(IWbemClassObject **ppDestWMIGPOObj, IDirectoryObject *pSrcWMIGPOObj, IWbemServices *pDestCIM)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1;

  wchar_t* AttrNames[] =
  {
    g_bstrADTargetClass
  };

  ADsStruct<ADS_ATTR_INFO>
   pAttrInfo;

  ADS_SEARCH_HANDLE
    SearchHandle;
 
  ADS_SEARCH_COLUMN
    SearchColumn;

  unsigned long
    c1, c2, dwReturn;

  CComPtr<IUnknown>
    pUnknown;

  CComPtr<IDirectorySearch>
    pDirSrch;

  CComPtr<IWbemClassObject>
    pClassDef,
    pDestWMIGPOObj;

  IWbemContext 
    *pCtx = 0;

  ADsStruct<ADS_OBJECT_INFO>
    pInfo;

  // **** create empty WMIGPO object

  hres = pDestCIM->GetObject(g_bstrClassWMIGPO, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(pClassDef == NULL) return WBEM_E_FAILED;

  hres = pClassDef->SpawnInstance(0, ppDestWMIGPOObj);
  if(FAILED(hres)) return hres;
  pDestWMIGPOObj = *ppDestWMIGPOObj;
  if(pDestWMIGPOObj == NULL) return WBEM_E_INVALID_CLASS;

  // **** get object attributes

  hres = pSrcWMIGPOObj->GetObjectAttributes(AttrNames, 1, &pAttrInfo, &dwReturn);
  if(FAILED(hres)) return hres;
  if(pAttrInfo == NULL) return WBEM_E_NOT_FOUND;

  // **** DsPath

  hres = pSrcWMIGPOObj->GetObjectInformation(&pInfo);
  if(SUCCEEDED(hres) && (pInfo != NULL))
  {
    v1 = pInfo->pszParentDN;
    hres = pDestWMIGPOObj->Put(g_bstrDsPath, 0, &v1, 0);
  }

  if(pInfo == NULL) return WBEM_E_FAILED;
  if(FAILED(hres)) return hres;

  for(c1 = 0; c1 < dwReturn; c1++)
  {
    // **** TargetClass

    if(0 == _wcsicmp((pAttrInfo + c1)->pszAttrName, g_bstrADTargetClass))
    {
      wchar_t
        *pStrBegin = NULL,
        *pStrEnd = NULL;

      pStrBegin = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;

      if(NULL != pStrBegin)
      {
        pStrEnd = wcsstr(pStrBegin, L";");

        while(NULL != pStrBegin)
        {
          if(NULL != pStrEnd)
            *pStrEnd = L'\0';

          hres = pDestWMIGPOObj->Get(L"PolicyTemplate", 0, &v1, NULL, NULL);
          if(FAILED(hres)) return hres;

          SafeArray<BSTR, VT_BSTR>
            TargetClasses(&v1);

          VariantClear(&v1);

          TargetClasses.ReDim(0, TargetClasses.Size() + 1);
          TargetClasses[TargetClasses.IndexMax()] = SysAllocString(pStrBegin);

          V_VT(&v1) = (VT_ARRAY | VT_BSTR);
          V_ARRAY(&v1) = TargetClasses.Data();
          hres = pDestWMIGPOObj->Put(L"PolicyTemplate", 0, &v1, 0);
          if(FAILED(hres)) return hres;
  
          VariantClear(&v1);
          pStrBegin = pStrEnd + 1;

          if(L'\0' == *pStrBegin)
            pStrBegin = NULL;
          else
            pStrEnd = wcsstr(pStrBegin, L";");
        }
      }
    }

    VariantClear(&v1);
  }

  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\test\gpoctrl\gpohlpr.cpp ===
#include "precomp.h"
#include "wmigpo.h"
#include "gpohlpr.h"
#include <initguid.h>
#include <prsht.h>
#include <iads.h>
#include <adshlp.h>
#include <adserr.h>

HRESULT HandleError( HRESULT hres )
{
    HRESULT hr;
    CComPtr<ICreateErrorInfo> pCreateErrInfo;
    CreateErrorInfo( &pCreateErrInfo );
    pCreateErrInfo->SetGUID( IID_IWmiGpoHelper );
    /*	FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, 0, 0, 
	pErrInfo->SetDesciption(  ); */
    CComPtr<IErrorInfo> pErrInfo;
    pCreateErrInfo->QueryInterface( IID_IErrorInfo, (void**)&pErrInfo );
    SetErrorInfo( 0, pErrInfo.p );
    return hres;
}

// {AAEAE720-0328-4763-8ECB-23422EDE2DB5}
static GUID guidCSE = { 0xaaeae720, 0x328, 0x4763, 
                        {0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5}};

/////////////////////////////////////////////////////////////////////////////
// CGPOHelper

CGPOHelper::CGPOHelper() : m_pGPO(NULL) 
{

}

HRESULT CGPOHelper::FinalConstruct()
{
    return CoCreateInstance( CLSID_GroupPolicyObject, 
                             NULL,
                             CLSCTX_SERVER, 
                             IID_IGroupPolicyObject,
                             (void **)&m_pGPO );
}

CGPOHelper::~CGPOHelper()
{
    if ( m_pGPO != NULL )
    {
        m_pGPO->Release();
    }
}

STDMETHODIMP CGPOHelper::Create( BSTR bstrName, 
                                 BSTR bstrDomainPath, 
                                 BSTR *pbstrPath )
{
    HRESULT hr;	
    *pbstrPath = NULL;

    hr = m_pGPO->New( bstrDomainPath, bstrName, 0 );

    if ( FAILED(hr) )
    {
        return HandleError( hr );
    }

    hr = m_pGPO->Save( TRUE, TRUE, &guidCSE, &guidCSE );

    if ( FAILED(hr) )
    {
        return HandleError( hr );
    }

    WCHAR awchGPOPath[1024];

    hr = m_pGPO->GetPath( awchGPOPath, 1024 );

    if ( FAILED(hr) )
    {
        return HandleError( hr );
    }

    *pbstrPath = SysAllocString( awchGPOPath );

    return S_OK;
}

STDMETHODIMP CGPOHelper::Delete( BSTR bstrPath )
{
    HRESULT hr;

    hr = m_pGPO->OpenDSGPO( bstrPath, 0 );

    if ( FAILED(hr) )
    {
        return HandleError( hr );
    }
    
    hr = m_pGPO->Delete();

    if ( FAILED(hr) )
    {
        return HandleError( hr );
    }

    return S_OK;
}

STDMETHODIMP CGPOHelper::GetPath( BSTR bstrName, 
                                  BSTR bstrDomainPath, 
                                  BSTR *pbstrPath )
{
    HRESULT hr;
    *pbstrPath = NULL;

    WCHAR* pch = bstrDomainPath + 7; // eat off "LDAP://"

    CComBSTR bsContainerPath = L"LDAP://CN=Policies,CN=System,";

    bsContainerPath += pch;

    CComPtr<IDirectorySearch> pSearch;

    BSTR bstrContainerPath = bsContainerPath;

    hr = ADsGetObject( bstrContainerPath, 
                       IID_IDirectorySearch,
                       (void **)&pSearch );	

    if ( FAILED(hr) )
    {
        return HandleError(hr);
    }

    CComBSTR bsSearch = L"(displayName=";
    bsSearch += bstrName;
    bsSearch += L")";
    
    LPWSTR pszAttr = L"distinguishedName";
    ADS_SEARCH_HANDLE hSearch;

    hr = pSearch->ExecuteSearch( bsSearch, &pszAttr, 1, &hSearch );

    if ( FAILED(hr) )
    {
        return HandleError( hr );
    }
    
    hr = pSearch->GetNextRow( hSearch );

    if ( FAILED(hr) )
    {
        pSearch->CloseSearchHandle( hSearch );
        return HandleError( hr );
    }

    if ( hr == S_ADS_NOMORE_ROWS )
    {
        pSearch->CloseSearchHandle( hSearch );
        return HandleError( E_ADS_UNKNOWN_OBJECT );
    }

    ADS_SEARCH_COLUMN Column;

    hr = pSearch->GetColumn( hSearch, L"distinguishedName", &Column );    
    
    if ( FAILED(hr) )
    {
        pSearch->CloseSearchHandle( hSearch );
        return HandleError( hr );
    }

    CComBSTR bsPath = L"LDAP://";

    bsPath += Column.pADsValues->CaseIgnoreString;

    *pbstrPath = SysAllocString( bsPath );

    pSearch->FreeColumn( &Column );
    pSearch->CloseSearchHandle( hSearch );

    return S_OK;
}

STDMETHODIMP CGPOHelper::Link( BSTR bstrPath, BSTR bstrOUPath )
{
    HRESULT hr = CreateGPOLink( bstrPath, bstrOUPath, FALSE );

    if ( FAILED(hr) )
    {
        return HandleError(hr);
    }

    return S_OK;
}

STDMETHODIMP CGPOHelper::Unlink( BSTR bstrPath, BSTR bstrOUPath )
{
    HRESULT hr = DeleteGPOLink( bstrPath, bstrOUPath );

    if ( FAILED(hr) )
    {
        return HandleError(hr);
    }

    return S_OK;    
}

STDMETHODIMP CGPOHelper::UnlinkAll( BSTR bstrPath )
{
    HRESULT hr = DeleteAllGPOLinks( bstrPath );
    
    if ( FAILED(hr) )
    {
        return HandleError(hr);
    }

    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\test\gpoctrl\precomp.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__964A65E2_2075_4564_BFA3_6CC438F7BF28__INCLUDED_)
#define AFX_STDAFX_H__964A65E2_2075_4564_BFA3_6CC438F7BF28__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__964A65E2_2075_4564_BFA3_6CC438F7BF28__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\test\gpoctrl\gpohlpr.h ===
#ifndef __GPOHELPER_H_
#define __GPOHELPER_H_

#include "resource.h"       // main symbols
#include <gpedit.h>

/////////////////////////////////////////////////////////////////////////////
// CGPOHelper

class ATL_NO_VTABLE CGPOHelper : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CGPOHelper, &CLSID_WmiGpoHelper>,
    public ISupportErrorInfoImpl< &IID_IWmiGpoHelper >,
    public IDispatchImpl<IWmiGpoHelper, &IID_IWmiGpoHelper, &LIBID_WmiGpoHelperLib>
{
    IGroupPolicyObject* m_pGPO;

public:

    CGPOHelper();
    ~CGPOHelper();
    HRESULT FinalConstruct();

    DECLARE_REGISTRY_RESOURCEID(IDR_GPOHELPER)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CGPOHelper)
        COM_INTERFACE_ENTRY(IWmiGpoHelper)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    // IWmiGpoHelper
public:

    STDMETHOD(UnlinkAll)( BSTR bstrPath);
    STDMETHOD(Unlink)( BSTR bstrPath, BSTR bstrOUPath );
    STDMETHOD(Link)( BSTR bstrPath, BSTR bstrOUPath);
    STDMETHOD(GetPath)( BSTR bstrName, BSTR bstrDomainPath, BSTR* pbstrPath);
    STDMETHOD(Delete)( BSTR bstrPath);
    STDMETHOD(Create)( BSTR bstrName, BSTR bstrDomainPath, BSTR* pbstrPath);
};

#endif //__GPOHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\test\gpoctrl\main.cpp ===
// main.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for wmigpo.idl by adding the following 
//      files to the Outputs.
//          wmigpo_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f GPOps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include <initguid.h>
#include "wmigpo.h"
#include "dlldatax.h"

#include "wmigpo_i.c"
#include "gpohlpr.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_WmiGpoHelper, CGPOHelper)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WmiGpoHelperLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\dmitest\datatypes.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* ABSTRACT: The datatypes module contain the code for the classes and methods used for
*           manipulating the OLE datatypes used by the dmitest application.
* 
*
*/



#include "defines.h"
#include <windows.h>
#include <stdio.h>     
#include "datatypes.h"


BSTR CSafeArray::Bstr(LONG index)
{
	if( FAILED (SafeArrayGetElement(m_p, &index, &m_bstr) )) 
		return L"\"\"";

	return m_bstr;
}


LPWSTR CVariant::GetAsString()
{
	static WCHAR buff[512];

	switch (m_var.vt)
	{
		case VT_NULL:
			return L"NULL";
		case VT_I4:
		{
			swprintf(buff, L"%lu", m_var.lVal);
			return buff;
		}
		case VT_BSTR:
		{
			swprintf(buff, L"\"%s\"", m_var.bstrVal);
			return buff;
		}
		case VT_BOOL:
		{
			if (m_var.boolVal == TRUE || m_var.boolVal == -1)
				return L"TRUE";
			else
				return L"FALSE";
		}
		default:
			return L"Variant Type Not handled";
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\policman\test\gpoctrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wmigpo.rc
//
#define IDS_PROJNAME                    100
#define IDR_GPOHELPER                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\dmitest\defines.h ===
#define INITGUID        // this must come before windows.h
// Turns off sections of windows.h

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NODRAWTEXT
#define NOKERNEL
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOSCROLL
#define NOSERVICE
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NOMCX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\dmitest\dmitest.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* ABSTRACT: header file for the DMITEST.CPP module.
*
* 
*
*/


class CApp
{
private:
	FILE*	m_fScript;
	FILE*	m_fOut;

	BOOL	m_bRun;
	BOOL	m_bPrintToScreen;
	BOOL	m_bPrintToFile;

	BOOL	m_bQualifiers;
	BOOL	m_bProperties;

	IWbemServices*	m_pIServices;
public:
	SCODE GetObject(LPWSTR);
			CApp();
			~CApp();
	void	Run(int, WCHAR**);

	LPWSTR	GetBetweenQuotes(LPWSTR pString, LPWSTR pBuffer);
	LPWSTR	GetInstancePath(LPWSTR, LPWSTR);
	LPWSTR	GetPropertyFromBetweenQuotes(LPWSTR pString, LPWSTR pName, LPWSTR pValue);
	BOOL	GetPropertyAndValue( LPWSTR , CVariant& , LPWSTR*);


	BOOL	ParseCommandLine(int, WCHAR**);
	void	ProcessScriptFile(void);

	SCODE	Connect(LPWSTR pNameSpace);
	SCODE	Disconnect();
	SCODE	EnumClasses(LPWSTR, LONG lFlag);
	SCODE	StartRecurseClasses(LPWSTR);
	SCODE	RecurseClasses(LPWSTR, LONG);
	SCODE	EnumInstances(LPWSTR, LONG);
	SCODE	ExecMethod(LPWSTR);
	SCODE	ModifyInstance(LPWSTR);
	SCODE	DeleteInstance(LPWSTR);
	SCODE	DeleteClass(LPWSTR);
	SCODE	PutInstance(LPWSTR);

	SCODE	DumpQualifiers(IWbemQualifierSet* pIQualifiers, LONG tabs);
	SCODE	DumpObject(IWbemClassObject* pIObject, LONG tabs);


	void	print(LPWSTR);
	void	print(LPCSTR sz)						{WCHAR wsz[8000];MultiByteToWideChar(CP_OEMCP, 0, sz, -1, wsz, 512); print(wsz);}	
	void	print(LPWSTR format, LPWSTR wsz)		
													{WCHAR buff[8000]; swprintf(buff, format, wsz); print(buff); }
	void	print(LPWSTR format, LPWSTR wsz1, LPWSTR wsz2)
													{WCHAR buff[8000]; swprintf(buff, format, wsz1, wsz2); print(buff); }
	void	print(LPWSTR format, LPWSTR wsz1, LPWSTR wsz2, LPWSTR wsz3)
													{WCHAR buff[8000]; swprintf(buff, format, wsz1, wsz2, wsz3); print(buff); }
	void	print(LPWSTR format, LPWSTR wsz1, LPWSTR wsz2, LPWSTR wsz3, LPWSTR wsz4)
													{WCHAR buff[8000]; swprintf(buff, format, wsz1, wsz2, wsz3, wsz4); print(buff); }
	void	print(LPWSTR format, LPWSTR wsz1, LPWSTR wsz2, LPWSTR wsz3, LPWSTR wsz4, LPWSTR wsz5)
													{WCHAR buff[8000]; swprintf(buff, format, wsz1, wsz2, wsz3, wsz4, wsz5); print(buff); }


	void	print(LPWSTR, SCODE);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\dmitest\datatypes.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* ABSTRACT: header file for the DATATYPES.H module.  Contains various classes and methods
*           for manipulating the OLE data types used by the DMITEST application.
*
* 
*
*/





class CBstr
{
private:
	BSTR		m_bstr;

public:	
				CBstr()					{m_bstr = NULL;};
				CBstr(LPWSTR wstr)		{m_bstr = SysAllocString(wstr);};

				~CBstr()				{Clear();};

	void		Clear()					{SysFreeString(m_bstr);};
	void 		Set(LPWSTR olestr)		{if(m_bstr) SysFreeString(m_bstr); m_bstr = SysAllocString(olestr);};				

	operator	BSTR()					{return m_bstr;};
	operator	LPBSTR()				{return &m_bstr;};

};

class CVariant
{
private:
	VARIANT		m_var;

				
public:
				CVariant()				{VariantInit(&m_var);}
				CVariant(LPWSTR str)	{CVariant();Set(str);}

				~CVariant()				{VariantClear(&m_var);}

	void		Clear()					{VariantClear(&m_var);}
	void		Set(LPWSTR str)			{Clear(); m_var.vt = VT_BSTR; m_var.bstrVal = SysAllocString(str);}
	void		Set(ULONG ul)			{Clear(); m_var.vt = VT_I4; m_var.lVal = ul;}
	void		Set(LONG l)				{Clear(); m_var.vt = VT_I4; m_var.lVal = l;}
	void		Set(LPVARIANT pv)		{Clear(); VariantCopy(&m_var, pv);}
	void		SetBool(BOOL bool)		{Clear(); m_var.vt = VT_BOOL; m_var.boolVal = bool;}
	LPUNKNOWN	GetDispId()				{return m_var.pdispVal;}

	BOOL		Bool()					{if (m_var.boolVal == 0) return TRUE; else return FALSE;}
	
	operator	LPVARIANT()				{return &m_var;}
	operator	VARIANT()				{return m_var;}
	BSTR		GetBstr()				{return m_var.bstrVal;}
	VARTYPE		GetType () {	return m_var.vt ; }
	LPWSTR		GetAsString();
};


class CSafeArray
{
private:
	SAFEARRAY*	m_p;
	BSTR		m_bstr;
	LONG		m_lLower;
	LONG		m_lUpper;
public:
			CSafeArray()			{m_p = NULL; m_lLower = m_lUpper = 0;}
			~CSafeArray()			{SafeArrayDestroy(m_p);}

	BOOL		BoundsOk()			{ if (FAILED ( SafeArrayGetLBound(m_p,1,&m_lLower)) || FAILED(SafeArrayGetUBound(m_p,1,&m_lUpper)) ) return FALSE; else return TRUE;}
	LONG		LBound()			{return m_lLower;}
	LONG		UBound()			{return m_lUpper;}
	BSTR		Bstr(LONG index);

	operator	SAFEARRAY**()		{return &m_p;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\asyncjob.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#include "dmipch.h"					// precompiled header for dmi provider

#include "WbemDmiP.h"				// project wide include

#include "Strings.h"

#include "CimClass.h"

#include "DmiData.h"

#include "WbemLoopBack.h"

#include "AsyncJob.h"

#include "Mapping.h"

#include "ThreadMgr.h"

#include "trace.h"

#include "Exception.h"

//***************************************************************************
//		PROJECT SCOPE GLOBALS


// Project scope global _gMappings collects instantiated CMapping objects.
// the collection is used so only one mapping is generated for any one
// namespace / dminode.  CMapping instances should always be obtained by
// users from the _gMappings never newed or created automatically.  See
// the CMappings description for more information. This object next to be
// global because it is also used by the event subsytem.  the object is
// created when CServices is created ( when wbem first logs in to a namespace
// and is destroyed when CServices is destroyed ( when the wbem service closes )


CMappings*	_gMappings = NULL ;


//***************************************************************************
//		FILE SCOPE DEFINES

// The CATCHALL define is used to turn on and off the catch (...).  Turning
// the CATCHALL off ( setting to 0 ) is usefull for debugging.   The CATCHALL
// should be on ( set to 1 ) release builds.  with proper operatin the 
// catch (...) should never be entered.

#define CATCHALL	1

//***************************************************************************
//		FILE SCOPE GLOBALS

// File scope global _fThreadMgr is the instantiation of the thread manager.  see
// the CThreadManager description for information on the CThreadManager.  The 
// object is created when the dll is loaded and is destroyed when the dll is 
// unloaded.

CThreadManager		*_fThreadMgr = NULL ;


//***************************************************************************
//	Func:		CAsyncJob::CAsyncJob()
//	Purpose:	Constructor for CAsyncJob
//	Returns:	None
//	In Params:	None
//  Out Params:	None
//	Note:		Called by CIMOM calling thread
//***************************************************************************
CAsyncJob::CAsyncJob()
{
	DEV_TRACE ( L"\tCAsyncJob Created" ) ;

	m_pMapping = NULL;
	m_pICtx = NULL;

	m_bEvent = FALSE;

	m_pWbem = NULL;
}


//***************************************************************************
//	Func:		CAsyncJob::~CAsyncJob()
//	Purpose:	Destructor for CAsyncJob
//	Returns:	None
//	In Params:	None
//  Out Params:	None
//	Note:		Called by CIMOM calling thread
//***************************************************************************
CAsyncJob::~CAsyncJob()
{
	DEV_TRACE ( L"\tCAsyncJob Destroyed\n" ) ;

	if ( m_pICtx )
	{
		LONG l = m_pICtx->Release ();

		//MOT_TRACE ( L"pICtx Release %lu" , l );
	}	
}


//***************************************************************************
//	Func:		CAsyncJob::InitCreateClass
//	Purpose:	Init's a CreateClassEnumAsync job context.
//
//	Returns:	SCODE eventually returned to cimom cservices call
//
//	In Params:	cszNamespace , the current cimom namespace
//				bstrSuperClass , super class for class enum (can be empty)
//				pISink , sink to send enum to
//				pICtx , cimom context for any loopbacks required
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by CIMOM calling thread
//***************************************************************************
SCODE CAsyncJob::InitCreateClass ( CString& cszNamespace , BSTR bstrSuperClass , 
				 IWbemObjectSink* pISink , LONG lFlags , IWbemContext* pICtx ,
				 CWbemLoopBack* pWbem )
{

	// Init the job specific data

	if ( bstrSuperClass )
		m_cszSuperClass.Set( bstrSuperClass );	

	m_lFlags = lFlags;

	// Init the common job data and submit job to thread mgr

	return Init ( IDS_CLASSENUM ,  cszNamespace , pISink , pICtx , pWbem );
}		

//***************************************************************************
//	Func:		CAsyncJob::InitGetObject
//	Purpose:	Init's a GetObjectAsync job context
//
//	Returns:	SCODE eventually returned cimom cservices call
//
//	In Params:	cszNamespace , the current cimom namespace
//				bstrObjectPath , path of object to be got
//				pISink , sink to send result 
//				lFlags , reserved - there won't be any
//				pICtx , cimom context for any loopbacks required
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by CIMOM calling thread
//***************************************************************************
SCODE CAsyncJob::InitGetObject ( CString& cszNamespace , BSTR bstrObjectPath , 
				IWbemObjectSink* pISink , LONG lFlags , IWbemContext* pICtx ,
				CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_lFlags = lFlags;

	m_cszPath.Set( bstrObjectPath );	

	// Init the common job data and submit job to thread mgr

	return Init ( IDS_GETOBJECT , cszNamespace , pISink , pICtx , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::InitInstanceEnum
//	Purpose:	Init's a CreateInstanceEnumAsync job context.
//
//	Returns:	SCODE eventually returned cimom cservices call
//
//	In Params:	cszNamespace , the current cimom namespace
//				bstrClass , class for which instances are returned
//				pISink , sink to send enum to
//				lFlags , deep or shallow
//				pICtx , cimom context for any loopbacks required
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by CIMOM calling thread
//***************************************************************************
SCODE CAsyncJob::InitInstanceEnum ( CString& cszNamespace , BSTR bstrClass , 
				 IWbemObjectSink* pISink , LONG lFlags , IWbemContext* pICtx ,
				 CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_cszClass.Set ( bstrClass );
	m_cszPath.Set ( bstrClass );
	m_lFlags = lFlags;

	// Init the common job data and submit job to thread mgr

	return Init (  IDS_INSTANCEENUM , cszNamespace , pISink , pICtx  , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::InitDeleteInstace
//	Purpose:	Init's a DeleteInstanceAsync job context.  Called by cimom to
//				delete a row or a component.
//
//	Returns:	SCODE eventually returned cimom cservices call
//
//	In Params:	cszNamespace , the current cimom namespace
//				bstrObjectPath , intance to be deleted
//				pISink , sink to send result 
//				lFlags , none
//				pICtx , cimom context for any loopbacks required
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by CIMOM calling thread
//***************************************************************************
SCODE CAsyncJob::InitDeleteInstace ( CString& cszNamespace , BSTR bstrObjectPath,
				 IWbemObjectSink* pISink , LONG lFlags , IWbemContext* pICtx,
				 CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_lFlags = lFlags;

	m_cszPath.Set( bstrObjectPath );	

	// Init the common job data and submit job to thread mgr

	return Init ( IDS_DELETEINSTANCE , cszNamespace , pISink , pICtx  , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::InitPutInstance
//	Purpose:	Init's a PutInstanceAsync job context.  Called by cimom to 
//				to add row or modify.
//
//	Returns:	SCODE eventually returned cimom cservices call
//
//	In Params:	cszNamespace , the current cimom namespace
//				pInst , intance to be put
//				pISink , sink to send result 
//				lFlags, update or create see wbem docs
//				pICtx , cimom context for any loopbacks required
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by CIMOM calling thread
//***************************************************************************
SCODE CAsyncJob::InitPutInstance (  CString& cszNamespace , 
				IWbemClassObject* pInst, IWbemObjectSink* pISink , 
				IWbemContext* pICtx , CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_Instance.Set ( pInst );

	// Init the common job data and submit job to thread mgr

	return Init ( IDS_PUTINSTANCE ,  cszNamespace , pISink , pICtx  , pWbem  );
}


//***************************************************************************
//	Func:		CAsyncJob::InitExecMethod
//	Purpose:	Init's a ExecMethodAsync job context
//
//	Returns:	SCODE eventually returned cimom cservices call.  This is
//				called by cimom to get an enum, add component , add a group , 
//				add a language and set language
//
//	In Params:	cszNamespace , the current cimom namespace
//				bstrMethod , method name
//				bstrObjectPath , object on which to exec method
//				pISink , sink to send result 
//				pInParams, object containing any input parameters,
//				pICtx , cimom context for any loopbacks required
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by CIMOM calling thread
//***************************************************************************
SCODE CAsyncJob::InitExecMethod ( CString& cszNamespace , BSTR bstrMethod , 
				BSTR bstrObjectPath , IWbemObjectSink* pISink , 
				IWbemClassObject* pInParams, IWbemContext* pICtx , 
				CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_cszMethod.Set ( bstrMethod );

	m_cszPath.Set ( bstrObjectPath );

	m_InParams.Set ( pInParams ) ;

	// Init the common job data and submit job to thread mgr

	return Init ( IDS_EXECMETHOD , cszNamespace , pISink , pICtx , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::InitDeleteClass
//	Purpose:	Init's a DeleteClassAsync job context, this is used to delete
//				groups.
//
//	Returns:	SCODE eventually returned cimom cservices call
//
//	In Params:	cszNamespace , the current cimom namespace
//				bstrClass , name of class to delete
//				pISink , sink to send result 
//				lFlags, see wbem api docs
//				pICtx , cimom context for any loopbacks required
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by CIMOM calling thread
//***************************************************************************
SCODE CAsyncJob::InitDeleteClass (  CString& cszNamespace , BSTR bstrClass , 
				 IWbemObjectSink* pISink , LONG lFlags , IWbemContext* pICtx ,
				 CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_lFlags = lFlags;

	m_cszClass.Set ( bstrClass );

	// Init the common job data and submit job to thread mgr

	return Init ( IDS_DELETECLASS , cszNamespace , pISink , pICtx , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::InitEvent
//	Purpose:	Init's a job context that will cause a recieved dmi event
//				to be sent cimom.
//
//	Returns:	SCODE of no interest, the caller has not used for the return 
//				code.
//
//	In Params:	Event , object containing the event data
//				cszNamespace , the namespace in which the event occured
//				pISink , sink to send result 
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by dmi event reciever
//***************************************************************************
SCODE CAsyncJob::InitEvent (  CEvent& Event , CString& cszNamespace , 
							IWbemObjectSink* pISink , CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_Event.Copy ( Event);

	m_bEvent = TRUE;

	// Init the common job data and submit job to thread mgr

	return InitAsync ( IDS_EVENT , cszNamespace , pISink , NULL  , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::InitAddComponentNotification
//	Purpose:	Init's a job context that will signal the cimom sink with
//				a component added notification.
//
//	Returns:	SCODE of no interest, the caller has not used for the return 
//				code.
//
//	In Params:	Component , component class describing component added.
//				Row , component id group row for the component added
//				cszNamespace , the namespace in which the event occured
//				pISink , sink to send result 
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by dmi event reciever
//***************************************************************************
SCODE CAsyncJob::InitAddComponentNotification (  CComponent& Component, 
							CRow& Row ,CString& cszNamespace ,  
							IWbemObjectSink* pISink , CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_Component.Copy ( Component );

	m_Row.Copy ( Row );

	m_bEvent = TRUE;

	// Init the common job data and submit job to thread mgr

	return InitAsync ( IDS_COMPONENTADDNOTIFY , cszNamespace , pISink , NULL , pWbem);
}


//***************************************************************************
//	Func:		CAsyncJob::InitDeleteComponentNotification
//	Purpose:	Init's a job context that will signal the cimom sink with
//				a component deleted notification.
//
//	Returns:	SCODE of no interest, the caller has not used for the return 
//				code.
//
//	In Params:	Component , component class describing component deleted.
//				Row , component id group row for the component dleted
//				cszNamespace , the namespace in which the event occured
//				pISink , sink to send result 
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by dmi event reciever
//***************************************************************************
SCODE CAsyncJob::InitDeleteComponentNotification (  CComponent& Component ,
												  CRow& Row ,
												  CString& cszNamespace ,
												  IWbemObjectSink* pISink,
												  CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_Component.Copy ( Component );

	m_Row.Copy ( Row );

	m_bEvent = TRUE;

	// Init the common job data and submit job to thread mgr

	return InitAsync ( IDS_COMPONENTDELETENOTIFY , cszNamespace , pISink , NULL , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::InitAddGroupNotification
//	Purpose:	Init's a job context that will signal the cimom sink with
//				a group added notification.
//
//	Returns:	SCODE of no interest, the caller has not used for the return 
//				code.
//
//	In Params:	Group , group class describing group added.
//				cszNamespace , the namespace in which the event occured
//				pISink , sink to send result 
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by dmi event reciever.  cimom has issues with class
//				added events.
//***************************************************************************
SCODE CAsyncJob::InitAddGroupNotification ( CGroup& Group  , 
										   CString& cszNamespace , 
										   IWbemObjectSink* pISink ,
										   CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_Group.Copy ( Group );

	m_bEvent = TRUE;

	// Init the common job data and submit job to thread mgr

	return InitAsync ( IDS_GROUPADDNOTIFY , cszNamespace , pISink , NULL , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::InitDeleteGroupNotification
//	Purpose:	Init's a job context that will signal the cimom sink with
//				a group deleted notification.
//
//	Returns:	SCODE of no interest, the caller has not used for the return 
//				code.
//
//	In Params:	Group , group class describing group deleted ( to the fullest
//					(extent possible )
//				cszNamespace , the namespace in which the event occured
//				pISink , sink to send result 
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by dmi event reciever. cimom has issues with class 
//				deleted events
//***************************************************************************
SCODE CAsyncJob::InitDeleteGroupNotification (  CGroup& Group , 
											  CString& cszNamespace , 
											  IWbemObjectSink* pISink ,
											  CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_Group.Copy ( Group );

	m_bEvent = TRUE;

	// Init the common job data and submit job to thread mgr

	return InitAsync ( IDS_GROUPDELETENOTIFY , cszNamespace , pISink , NULL , pWbem);
}


//***************************************************************************
//	Func:		CAsyncJob::InitAddLanguageNotification
//	Purpose:	Init's a job context that will signal the cimom sink with
//				a language added notification.
//
//	Returns:	SCODE of no interest, the caller has not used for the return 
//				code.
//
//	In Params:	cvLangauge , variant containing string of language added
//				cszNamespace , the namespace in which the event occured
//				pISink , sink to send result 
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by dmi event reciever.  not enabled in mot.
//***************************************************************************
SCODE CAsyncJob::InitAddLanguageNotification ( CVariant& cvLanguage , 
											  CString& cszNamespace , 
											  IWbemObjectSink* pISink ,
											  CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_cvLanguage.Set ( (LPVARIANT)cvLanguage );

	m_bEvent = TRUE;

	// Init the common job data and submit job to thread mgr

	return InitAsync ( IDS_LANGUAGEADDNOTIFY , cszNamespace , pISink , NULL , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::InitDeleteLanguageNotification
//	Purpose:	Init's a job context that will signal the cimom sink with
//				a language deleted notification.
//
//	Returns:	SCODE of no interest, the caller has not used for the return 
//				code.
//
//	In Params:	cvLangauge , variant containing string of language deleted
//				cszNamespace , the namespace in which the event occured
//				pISink , sink to send result 
//				pWbem , a pointer to the wbem loop back wrapper
//
//  Out Params: None
//
//	Note:		Called by dmi event reciever.  not enabled in mot.
//***************************************************************************
SCODE CAsyncJob::InitDeleteLanguageNotification (  CVariant& cvLanguage ,
												 CString& cszNamespace ,
												 IWbemObjectSink* pISink ,
												 CWbemLoopBack* pWbem )
{
	// Init the job specific data

	m_cvLanguage.Set ( (LPVARIANT)cvLanguage );

	m_bEvent = TRUE;

	// Init the common job data and submit job to thread mgr

	return InitAsync ( IDS_LANGUAGEDELETENOTIFY , cszNamespace , pISink , NULL , pWbem );
}


//***************************************************************************
//	Func:		CAsyncJob::Init
//	Purpose:	Finish initializing a job context, with the job data common
//				to all types of jobs.
//
//	Returns:	SCODE eventually returned cimom cservices call
//
//	In Params:	ulType , type of job 
//				cszNamespace , the current cimom namespace
//				pISink , sink to send result 
//				pICtx , cimom context for any loopbacks required
//
//  Out Params: None
//
//	Note:		Called by CIMOM calling thread
//***************************************************************************
SCODE CAsyncJob::Init( ULONG ulType , CString& cszNamespace , 
					  IWbemObjectSink* pISink , 
					  IWbemContext* pICtx , CWbemLoopBack* pWbemLoopBack )
{
	// set the type of job to be performed, the types are set by the
	// string table id's of a description of the job type so you can
	// load string m_ulType and get the job type description as a string
	m_ulType = ulType;	

	// set the pointer to the wbem loop back wrapper object.

	m_pWbem = pWbemLoopBack;

	
	// namepace in which job is beeing conducted b
	m_cszNamespace.Set( cszNamespace );	
	
	m_pISink = pISink;

	if ( !m_bEvent )
	{
		// note, when init event can't addref in apartement thread
		// the addref is done in the cmotevent::init
		m_pISink->AddRef();
	}


	if ( pICtx )
	{
		m_pICtx = pICtx;
		m_pICtx->AddRef();
	}

	this->Execute () ;

	delete this ;

	return S_OK ;

//	return ( _fThreadMgr->AddJob( this ) ) ? WBEM_NO_ERROR : WBEM_E_FAILED;


}

//***************************************************************************
//	Func:		CAsyncJob::Init
//	Purpose:	Finish initializing a job context, with the job data common
//				to all types of jobs.
//
//	Returns:	SCODE eventually returned cimom cservices call
//
//	In Params:	ulType , type of job 
//				cszNamespace , the current cimom namespace
//				pISink , sink to send result 
//				pICtx , cimom context for any loopbacks required
//
//  Out Params: None
//
//	Note:		Called by CIMOM calling thread
//***************************************************************************
SCODE CAsyncJob::InitAsync( ULONG ulType , CString& cszNamespace , 
					  IWbemObjectSink* pISink , 
					  IWbemContext* pICtx , CWbemLoopBack* pWbemLoopBack )
{
	// set the type of job to be performed, the types are set by the
	// string table id's of a description of the job type so you can
	// load string m_ulType and get the job type description as a string
	m_ulType = ulType;	

	// set the pointer to the wbem loop back wrapper object.

	m_pWbem = pWbemLoopBack;

	
	// namepace in which job is beeing conducted b
	m_cszNamespace.Set( cszNamespace );	
	
	m_pISink = pISink;

	if ( !m_bEvent )
	{
		// note, when init event can't addref in apartement thread
		// the addref is done in the cmotevent::init
		m_pISink->AddRef();
	}


	if ( pICtx )
	{
		m_pICtx = pICtx;
		m_pICtx->AddRef();
	}

	return ( _fThreadMgr->AddJob( this ) ) ? WBEM_NO_ERROR : WBEM_E_FAILED;

}

//***************************************************************************
//	Func:		CAsyncJob::Execute
//	Purpose:	Executes a job context
//
//	Returns:	none
//
//	In Params:	none
//
//  Out Params: None
//
//	Note:		Called by a worker thread.  Contains mother try-
//				Catch block for other modules.
//***************************************************************************
void CAsyncJob::Execute()
{

	
	CCimObject		Instance;			// for the final indicate that sends
										// the notifiy status instance

	CString cszType;
	CBstr cbEmpty;

	cbEmpty.Set ( EMPTY_STR );


	cszType.LoadString ( m_ulType );

	STAT_TRACE ( L"\tjob ( %lX ) started , %s", this , cszType );

	try 
	{
		// 1. get a mapping corresponding to the current namespace.

		EnterCriticalSection(&_gcsJobCriticalSection);	
		_gMappings->Get( m_pWbem , m_cszNamespace, &m_pMapping, m_pICtx);
		LeaveCriticalSection(&_gcsJobCriticalSection);

		// 2. perform the job

		DispatchJob();									

	 	// 3. signal the sink with the result

		m_pMapping->GetNotifyStatusInstance( Instance, WBEM_NO_ERROR, m_pICtx);


		STAT_TRACE ( L"\tJob ( %lX ) Setting Status", this );
		// 4. tell the sink that the job is complete 

		m_pISink->SetStatus ( NO_FLAGS , WBEM_NO_ERROR , NULL , Instance );


	}
	catch ( CException& e )
	{
		// we enter the catch if a called func experiances a known error
		// condition that we want to tell cimom about

		if ( e.WbemError() == WBEM_S_NO_ERROR )
		{
			// acceptable handling conditions just carry on
			// sometime cimom will task the provider with
			// from wich it should just return no_error
		}
		else
		{
			ERROR_TRACE ( L"" );
			
			CString cszT;

			cszT.LoadString ( m_ulType );

			ERROR_TRACE ( L"%s job ( %lX ) failed " , cszT , this );
			ERROR_TRACE ( L"\tJob Context\tPath is %s" , m_cszPath );
			ERROR_TRACE ( L"\t\t\tClass is %s" , m_cszClass );
			ERROR_TRACE ( L"\t\t\tParent class is %s" , m_cszSuperClass );
			ERROR_TRACE ( L"\t\t\tMethod is %s" , m_cszMethod );

			
			ERROR_TRACE ( L"\tError Object\tWbemError = %lX" , e.WbemError() ) ; 			

			cszT.LoadString ( e.DescriptionId() );

			ERROR_TRACE ( L"\t\t\tDescription = %s ", ( LPWSTR )cszT);

			cszT.LoadString ( e.OperationId() );

			ERROR_TRACE ( L"\t\t\tOperation = %s ", ( LPWSTR )cszT);
			ERROR_TRACE ( L"\t\t\tParam = %s ", e.Data() );

			ERROR_TRACE ( L"" );
		}

		// It is possible that an exception is thrown before the mapping 
		// is established in this case it is impossable for the provider 
		// to signal the CIMOM
		ULONG ulerror = e.WbemError();
		if (m_pMapping)
		{
			m_pISink->SetStatus ( NO_FLAGS , e.WbemError () , NULL , NULL );
		}
		else
		{
			// If there is no mapping there is nothing we can do
		}

	}

#if CATCHALL
	catch ( ... )
	{
		// we enter this catch if the job causes an execption that we
		// did not throw

		CString cszT;

		cszT.LoadString ( m_ulType );			

		
		ERROR_TRACE ( 
			L"\t%sjob ( %lX ) WARNING !!!  CAUGHT UNHANDLED EXCEPTION (...)" ,
			cszT , this);

		// It is possible that an exceptionis is thrown before the mapping is 
		// established in this case it is impossable for the provider to signal
		// the CIMOM
		
		if (m_pMapping)
		{
			m_pISink->SetStatus ( NO_FLAGS , WBEM_E_PROVIDER_FAILURE , NULL , NULL );
		}
		else
		{
			// If there is no mapping there is nothing we can do
		}
	}
#endif // catchall

	// job and mapping cleanup	

	if ( !m_bEvent )
	{
		LONG l = m_pISink->Release();

		//MOT_TRACE ( L"pISink Release %lu" , l );
	}

	EnterCriticalSection(&_gcsJobCriticalSection);
	if ( m_pMapping )
	{
		_gMappings->Release( m_pMapping );
	}
	LeaveCriticalSection(&_gcsJobCriticalSection);

	STAT_TRACE ( L"\tjob ( %lX ) finished\n", this);



}


//***************************************************************************
//	Func:		CAsyncJob::DispatchJob
//	Purpose:	perform a job based on the context's type
//
//	Returns:	none
//
//	In Params:	none
//
//  Out Params: None
//
//	Note:		Called in a worker thread.  
//***************************************************************************
void CAsyncJob::DispatchJob()
{

	// dispatch job context to the appropreate func
	switch (m_ulType)
	{

	case IDS_GETOBJECT:
		{
			GetObject();
			
			break;
		}

	case IDS_INSTANCEENUM:
		{

			if(m_lFlags == WBEM_FLAG_DEEP)
				InstanceEnumDeep();

			if(m_lFlags == WBEM_FLAG_SHALLOW)
				InstanceEnumShallow();
			
			break;
		}
		
	case IDS_CLASSENUM:
		{
			if(m_lFlags == WBEM_FLAG_DEEP)
				ClassEnumDeep();
		
			else if(m_lFlags == WBEM_FLAG_SHALLOW)
				ClassEnumShallow();
			
			break;
		}

	case IDS_EXECMETHOD:			
		{
		
			ExecMethod();			

			break;
		}

	case IDS_DELETEINSTANCE:
		{
			DeleteInstance();

			break;
		}

	case IDS_DELETECLASS:
		{
			DeleteClass();

			break;
		}

	case IDS_PUTINSTANCE:
		{
			PutInstance();

			break;
		}

	case IDS_EVENT:
		{
			DoEvent ();

			break;
		}

	case IDS_COMPONENTADDNOTIFY:
		{
			DoComponentAddNotify ();

			break;
		}
	case IDS_COMPONENTDELETENOTIFY:
		{
			DoComponentDeleteNotify ();

			break;
		}

	case IDS_GROUPADDNOTIFY:
		{
			DoGroupAddNotify ( );

			break;
		}

	case IDS_GROUPDELETENOTIFY:
		{
			DoGroupDeleteNotify ();

			break;
		}

	case IDS_LANGUAGEADDNOTIFY:   
		{
			DoLanguageAddNotify ();

			break;
		}

	case IDS_LANGUAGEDELETENOTIFY:        
		{
			DoLanguageDeleteNotify ();

			break;
		}
			
	default:
		{
			CString csz;

			csz.Set ( m_ulType );

			throw CException(  WBEM_E_NOT_SUPPORTED , IDS_ASYDISP_FAIL ,
				IDS_BAD_METHOD , csz );
		}
	}
}



//***************************************************************************
//	Func:		CAsyncJob::GetObject
//	Purpose:	performs a GetObjectAsync job
//
//	Returns:	none
//
//	In Params:	none
//
//  Out Params: None
//
//	Note:		Called in a worker thread.  
//***************************************************************************
void CAsyncJob::GetObject()
{	
	CCimObject		Class;
	CIterator*		pIterator = NULL;
	LONG			lObjectType;

	lObjectType = GetObjectType( m_cszPath );

	switch ( lObjectType )
	{
		// Fall through cases.  CIMOM should not call us with 
		// objectpath of "DmiNode". If it does return without error
		case DMI_NODE_C:
		case DMI_NODE_I:
		{
			// for wbem sdk browser
			//throw CException ( WBEM_S_NO_ERROR , IDS_SYSTEM_CLASS , NO_STRING ,
			//m_cszPath);
			throw CException ( WBEM_S_NO_ERROR , 0, NO_STRING ,
			0);
		}

		case CLASSVIEW_C :
		{
			// for wbem sdk browser
			throw CException( WBEM_E_INVALID_CLASS , IDS_GETOBJECT_FAIL , 
				IDS_OBJECT_NOT_FOUND , m_cszPath );
		}
		case DMIEVENT_I :
		{		
			// instance providing for DMIEVENT_CLASS not supported

			throw CException ( WBEM_E_INVALID_OPERATION , 
				IDS_GETOBJECT_FAIL , IDS_CANT_GETINSTANCES_DMIEVENT );
		}
		case DMIEVENT_C :
		{
			m_pMapping->GetDmiEventClass( m_pICtx , Class);

			break;
		}
		case ADDMOTHODPARAMS_I:
		{
			throw CException ( WBEM_E_INVALID_OPERATION , 
				IDS_GETOBJECT_FAIL , IDS_ONLY_WITH_CIE  );
		}
		
		case ADDMOTHODPARAMS_C:
		{
			m_pMapping->GetAddParamsClass( Class, m_pICtx );		

			break;
		}
		
		case LANGUAGEPARAMS_I:
		{
			throw CException ( WBEM_E_INVALID_OPERATION , 
				IDS_GETOBJECT_FAIL , IDS_ONLY_WITH_CIE  );
		}
		
		case LANGUAGEPARAMS_C:
		{
			m_pMapping->GetDeleteLanguageParamsClass( Class, m_pICtx );
		
			break;
		}

		case  GETENUMPARAMS_C :
		{
			m_pMapping->GetEnumParamsClass( Class , m_pICtx);

			break;
		}
		case  GETENUMPARAMS_I :
		{
			throw CException ( WBEM_E_INVALID_OPERATION , 
				IDS_GETOBJECT_FAIL , IDS_ONLY_WITH_CIE  );
		}

		case DMIENUM_C:
		{
			m_pMapping->GetEnumClass( m_pICtx , Class );			
			
			break;
		}

		case DMIENUM_I:
		{
			throw CException ( WBEM_E_INVALID_OPERATION , IDS_GETOBJECT_FAIL,
				IDS_CANT_GETINSTANCES_DMIENUM );
		}
	
		case  COMPONENT_BINDING_C:
		{
			m_pMapping->GetComponentBindingClass( m_pICtx , Class);

			break;
		}

		case  COMPONENT_BINDING_I:
		{
				// TODO do we need this? check browser	
			throw CException ( WBEM_E_INVALID_OPERATION , 
				IDS_GETOBJECT_FAIL , IDS_ONLY_WITH_CIE  );
		}

		case COMPONENT_C:
		{
			m_pMapping->GetComponentClass( m_pICtx , Class);

			break;
		}

		case COMPONENT_I:
		{		
			//is the getobject for the component class
			m_pMapping->GetComponentInstance( m_cszPath, m_pICtx , Class );

			break;
		}

		case NODEDATA_BINDING_C:
		{
			m_pMapping->GetNodeDataBindingClass( Class, m_pICtx );

			break;
		}

		case NODEDATA_BINDING_I:
		{
				// TODO do we need this? check browser			
			throw CException ( WBEM_E_INVALID_OPERATION , 
				IDS_GETOBJECT_FAIL , IDS_ONLY_WITH_CIE  );
		}

		case NODEDATA_C:
		{
			m_pMapping->GetNodeDataClass( Class , m_pICtx);

			break;
		}

		case NODEDATA_I:
		{
			m_pMapping->GetNodeDataInstance( Class , m_pICtx);

			break;
		}

		case LANGUAGE_BINDING_C:		
		{
			m_pMapping->GetLanguageBindingClass( Class , m_pICtx);	

			break;
		}
		
		case LANGUAGE_BINDING_I:
		{
			// don't return Instance on purpose, there are no instances 
			// of this class for get object

			throw CException ( WBEM_E_INVALID_OPERATION , 
				IDS_GETOBJECT_FAIL , IDS_ONLY_WITH_CIE  );
		}

		case LANGUAGE_C:
		{
			m_pMapping->GetLanguageClass( m_pICtx , Class );

			break;
		}

		case LANGUAGE_I:
		{
			m_pMapping->GetLanguageInstance( m_cszPath, m_pICtx , Class);

			break;
		}
		
		case BINDING_ROOT_C:
		{
			m_pMapping->GetBindingRootClass( Class , m_pICtx);

			break;		
		}	

		case BINDING_ROOT_I:
		{
			// abstract class
			break;
		}
	
		case GROUP_ROOT_C:
		{
			m_pMapping->GetGroupRootClass( Class, m_pICtx );

			break;
		}	
	
		case GROUP_ROOT_I:
		{
			// abstract class

			break;
		}
		case DYN_GROUP_C:
		{
			m_pMapping->GetNewCGAIterator( m_pICtx , &pIterator );

			m_pMapping->GetDynamicClassByName( m_cszPath, Class, pIterator, m_pICtx );

			break;
		}

		case DYN_GROUP_I:
		{
			m_pMapping->GetNewCGAIterator( m_pICtx ,  &pIterator );	

			m_pMapping->GetInstanceByPath( m_cszPath, Class, pIterator , m_pICtx );

			break;
		}
	}
	
	if( ! Class.IsEmpty() )
	{
		m_pISink->Indicate(1, Class);
	}
	else
	{
		throw CException( WBEM_E_INVALID_OBJECT , IDS_GETOBJECT_FAIL , 
			IDS_OBJECT_NOT_FOUND , m_cszPath );
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAsyncJob::ExecMethod()
{
	LONG			lObjectType;

	STAT_TRACE ( L"\tjob ( %lX ) ExecMethod()" , this ) ;

	// Methods must be executed on instnaces

	lObjectType = GetObjectType( m_cszPath );

	switch ( lObjectType )
	{
		case COMPONENT_I:
		{

			//	Methods supported for instances of DmiComponent are addlanguage 
			//	and addgroup
			if ( m_cszMethod.Equals ( ADD_LANGUAGE ) )
			{
				m_pMapping->AddLanguage(  m_cszPath , m_InParams , m_pICtx );
			}
			else if ( m_cszMethod.Equals ( ADD_GROUP ) )
			{
				m_pMapping->AddGroup( m_cszPath , m_InParams , m_pICtx );
			}
			else if ( m_cszMethod.Equals ( DELETE_LANGUAGE ) )
			{
				m_pMapping->DeleteLanguage( m_cszPath , m_InParams , m_pICtx );
			}
			else if ( m_cszMethod.Equals ( GET_ENUM ) )
			{
				CCimObject		OutParamsInstance;			

				m_pMapping->ComponentGetEnum( m_cszPath, m_InParams, OutParamsInstance , m_pICtx );
			
				m_pISink->Indicate(1, OutParamsInstance);			
			}
			else 
			{
				throw CException( WBEM_E_INVALID_PARAMETER , 
					IDS_EXECMETHOD_FAIL , 
					IDS_BADMETHOD );
			}

			m_pISink->SetStatus( NO_FLAGS , WBEM_NO_ERROR , NULL, NULL);

			return;
		}

		case NODEDATA_I:
		{			
			if ( m_cszMethod.Equals ( ADD_COMPONENT) )
			{
				m_pMapping->AddComponent( m_pICtx , m_InParams );
			}
			else if ( m_cszMethod.Equals ( SET_LANGUAGE ) )
			{
				m_pMapping->SetDefaultLanguage( m_pICtx , m_InParams );

			}
			else
			{
				throw CException ( WBEM_E_INVALID_PARAMETER , 
					IDS_EXECMETHOD_FAIL , IDS_BADMETHOD);
			}

			m_pISink->SetStatus( NO_FLAGS , WBEM_NO_ERROR , NULL, NULL);	

			return;
		}	

		case DYN_GROUP_C:
		{

			if ( m_cszMethod.Equals ( GET_ENUM ) )
			{
				CCimObject		OutParamsInstance;			

				m_pMapping->DynamicGroupGetEnum( m_cszPath,
					m_InParams, OutParamsInstance , m_pICtx );
			
				m_pISink->Indicate(1, OutParamsInstance);

				m_pISink->SetStatus( NO_FLAGS , WBEM_NO_ERROR , NULL, NULL);

				return;
			}
		}
	}
			

	throw CException ( WBEM_E_INVALID_PARAMETER , IDS_EXECMETHOD_FAIL ,
		IDS_BADMETHOD);
			
}

	


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAsyncJob::ClassEnumShallow()
{	

// No need to check for system classes here, because we're checking for them
// in CreateClassEnumAsynch() and GetObjectAsynch().  By the time we get here
// we shouldn't have any system classes to check for.	
//	SystemClass( m_cszSuperClass);

	STAT_TRACE( L"\tjob ( %lX ) ClassEnumShallow()", this);	

	if( m_cszSuperClass.Equals ( EMPTY_STR ))
	{		
		EnumTopClasses();

		return;
	}

	//
	if( m_cszSuperClass.Equals ( BINDING_ROOT ))
	{
		EnumBindingClasses();

		return;
	}

	if( m_cszSuperClass.Equals (  GROUP_ROOT))
	{

		EnumDynamicGroupClasses();

		return;
	}

	return;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAsyncJob::ClassEnumDeep()
{	
	CIterator*	pIterator;
// No need to check for system classes here, because we're checking for them
// in CreateClassEnumAsynch() and GetObjectAsynch().  By the time we get here
// we shouldn't have any system classes to check for.
//	SystemClass( m_cszSuperClass );

	STAT_TRACE ( L"\tjob ( %lX ) ClassEnumDeep()" , this);

	if ( m_cszSuperClass.Contains ( NODEDATA_CLASS ) ||  
		m_cszSuperClass.Contains ( BINDING_SUFFIX )	||
		m_cszSuperClass.Contains ( COMPONENT_CLASS ) ||
		m_cszSuperClass.Contains ( LANGUAGE_CLASS ) ||
		m_cszSuperClass.Contains ( LANGUAGE_BINDING_CLASS ) ||
		m_cszSuperClass.Contains ( COMPONENT_BINDING_CLASS ) ||
		m_cszSuperClass.Contains ( NODEDATA_BINDING_CLASS ) ||
		m_cszSuperClass.Contains ( ENUM_BINDING_CLASS ) ||
		m_cszSuperClass.Contains ( ADDMOTHODPARAMS_CLASS ) ||
		m_cszSuperClass.Contains ( LANGUAGEPARAMS_CLASS ) ||
		m_cszSuperClass.Contains ( DMIEVENT_CLASS ) ||
		m_cszSuperClass.Contains ( NODE_CLASS ) ||
		m_cszSuperClass.Contains ( GETENUMPARAMS_CLASS ) 		)
	{
		return;
	}

	if( m_cszSuperClass.Equals ( EMPTY_STR ))
	{		
		EnumTopClasses();
		EnumDynamicGroupClasses();
		EnumBindingClasses();

	}	
	else if( m_cszSuperClass.Equals ( BINDING_ROOT))
	{
		EnumBindingClasses();
	}
	else if ( m_cszSuperClass.Equals ( GROUP_ROOT))
	{
		EnumDynamicGroupClasses();
	}
	else
	{	// at this point be a dynamic class or not one of ours
		CCimObject Class;

		m_pMapping->GetNewCGAIterator( m_pICtx , &pIterator );

		m_pMapping->GetDynamicClassByName( m_cszSuperClass, Class, pIterator , m_pICtx );		
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAsyncJob::InstanceEnumShallow()
{
	CIterator*	pIterator;
	CCimObject	Class;


	STAT_TRACE ( L"\tjob ( %lX ) InstanceEnumShallow()" , this );
	
	// Make sure we are an instance provider of the the class specified

	if ( m_cszClass.Contains ( ADDMOTHODPARAMS_CLASS ) || 
			m_cszClass.Contains ( GETENUMPARAMS_CLASS ) || 
			m_cszClass.Contains ( GROUP_ROOT ) || 
			m_cszClass.Contains ( BINDING_ROOT ) || 
			m_cszClass.Contains ( LANGUAGEPARAMS_CLASS ) || 
			m_cszClass.Contains ( DMIEVENT_CLASS ) || 
			m_cszClass.Contains ( DMIENUM_CLASS ) )
	{
		return;
	}
	
	// Get the instances for the class of interest

	m_pMapping->GetNewCGAIterator( m_pICtx , &pIterator );

	if( m_cszPath.Contains ( NODEDATA_CLASS) )
	{
		m_pMapping->GetNodeDataInstance( Class , m_pICtx );

		m_pISink->Indicate(1, Class);

		return;
	}

	if( m_cszPath.Contains ( NODEDATA_BINDING_CLASS))
	{
		m_pMapping->GetNodeDataBindingInstance ( Class , m_pICtx ) ;
		
		m_pISink->Indicate(1, Class);

		return;
	}

	
	// NOTE: we do one at a time for performance
	m_pMapping->NextDynamicInstance(m_cszClass, pIterator, m_pICtx , Class);

	while( !Class.IsEmpty() )
	{
		SCODE result = m_pISink->Indicate(1, Class);

		//MOT_TRACE ( L"\t\tIndicate %lX error = %lu" , Class , result);
		
		m_pMapping->NextDynamicInstance(m_cszClass, pIterator, m_pICtx , Class);
	}
}


void CAsyncJob::InstanceEnumDeep()
{
	CIterator*	pIterator;
	CCimObject Class;

	STAT_TRACE ( L"\tjob ( %lX ) InstanceEnumDeep()" , this );

	if ( m_cszClass.Contains ( ADDMOTHODPARAMS_CLASS ) || 
		m_cszClass.Contains ( DMIEVENT_CLASS ) || 
		m_cszClass.Contains ( GETENUMPARAMS_CLASS ) || 
		m_cszClass.Contains ( LANGUAGEPARAMS_CLASS )  )
	{
		return;
	}

	m_pMapping->GetNewCGAIterator( m_pICtx ,  &pIterator );

	if( m_cszClass.Contains ( NODEDATA_CLASS)  )
	{
		if ( m_cszClass.Equals ( NODEDATA_BINDING_CLASS ) )
		{
			m_pMapping->GetNodeDataBindingInstance( Class , m_pICtx );
		}
		else		
		{
			m_pMapping->GetNodeDataInstance( Class , m_pICtx );
		}

		m_pISink->Indicate(1, Class);

		return;
	}

	if( m_cszClass.Equals ( BINDING_ROOT))
	{
		m_pMapping->GetNodeDataBindingInstance ( Class , m_pICtx ) ;
		
		m_pISink->Indicate(1, Class);

// TODO enum instances of lang and component bindings
		m_pMapping->NextDynamicBindingInstance( m_pICtx , Class, pIterator);

		while( !Class.IsEmpty() )
		{
			m_pISink->Indicate(1, Class);

			m_pMapping->NextDynamicBindingInstance( m_pICtx , Class, pIterator);
		}
	}
	else if( m_cszClass.Equals ( GROUP_ROOT))
	{
		m_pMapping->NextDynamicGroupInstance( m_pICtx , Class, pIterator);

		while( !Class.IsEmpty() )
		{		
			
			CBstr cb;

			((IWbemClassObject*)Class)->GetObjectText ( 0 , cb );

			SCODE result = m_pISink->Indicate(1, Class);

			//MOT_TRACE ( L"\t\tIndicate %lX error = %lu , %s" , Class , result , cb);			

			m_pMapping->NextDynamicGroupInstance( m_pICtx , Class, pIterator);
		}
		
	}
	else
	{		
		m_pMapping->NextDynamicInstance(m_cszClass, pIterator, m_pICtx , Class);

		while( !Class.IsEmpty() )
		{
			CBstr cb;

			((IWbemClassObject*)Class)->GetObjectText ( 0 , cb );

			SCODE result = m_pISink->Indicate(1, Class);
			
			//MOT_TRACE ( L"\t\tIndicate %lX error = %lu , %s" , Class , result , cb);			

			m_pMapping->NextDynamicInstance(m_cszClass, pIterator, m_pICtx , Class);
		}		
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
// NOTE: cannot delete instances of bindings, they are removed as 
// components, group , rows , and languages are removed
void CAsyncJob::DeleteInstance()
{
	CVariant			cvDmiPath;
	CIterator*			pIterator = NULL;

	STAT_TRACE ( L"\tjob ( %lX ) DeleteInstance()" , this );

	m_pMapping->DeleteInstance( m_cszPath, m_pICtx );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAsyncJob::PutInstance()
{
	// Note the only time putinstance is used is to modify writable attribute
	// and to add rows

	STAT_TRACE ( L"Called CAsyncJob PutInstance" );

	CVariant	cvSuperClassName;
	CString		cszSuperClassName;

	m_Instance.GetProperty( PARENT_NAME, cvSuperClassName);

	cszSuperClassName.Set( cvSuperClassName.GetBstr() );

	if ( cszSuperClassName.Contains ( GROUP_ROOT ))
	{
		m_pMapping->ModifyInstanceOrAddRow( m_pICtx , m_Instance );

		return;
	}

	throw CException ( WBEM_E_INVALID_OPERATION , 
		IDS_PUTINSTANCE_FAIL , IDS_ONLY_CHILDRED_OF_DMIGROUPROOT ) ;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAsyncJob::DeleteClass()
{
	CIterator*		pIterator = NULL;

	STAT_TRACE ( L"\tjob (%lX ) DeleteClass()" , this );

	if(
			 m_cszClass.Contains (  COMPONENT_CLASS )
			||  m_cszClass.Contains (  LANGUAGE_CLASS )
			||  m_cszClass.Contains (  LANGUAGE_BINDING_CLASS )
			||  m_cszClass.Contains (  COMPONENT_BINDING_CLASS )
			||  m_cszClass.Contains (  NODEDATA_BINDING_CLASS )
			||  m_cszClass.Contains (  ADDMOTHODPARAMS_CLASS ) 
			||  m_cszClass.Contains (  BINDING_ROOT ) 
			||  m_cszClass.Contains (  GROUP_ROOT ) 
			||  m_cszClass.Contains (  GETENUMPARAMS_CLASS ) 
			||  m_cszClass.Contains (  BINDING_SUFFIX)
			||  m_cszClass.Contains (  LANGUAGEPARAMS_CLASS) 
			||  m_cszClass.Contains (  DMIEVENT_CLASS ) 
		)

	{
		throw CException ( WBEM_E_INVALID_OPERATION , IDS_DELCLASS_FAIL , 
			IDS_NO_DEL_THIS_CLASS  , m_cszClass);
	}

	m_pMapping->DeleteDynamicGroupClass(m_cszClass, m_pICtx );	
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
// is CIMOM trying to enum a system class?
BOOL CAsyncJob::SystemClass( CString& csz )
{	
	BOOL bSystemClass = FALSE;
	
	if( !csz.IsEmpty())
	{	
		// system class if class name starts with __
		if(csz.GetAt( FIRST_CHAR ) == 0x5F && csz.GetAt ( SECOND_CHAR ) == 0x5F ) 
		{
			throw CException ( WBEM_S_NO_ERROR , IDS_SYSTEM_CLASS , NO_STRING ,
				csz);
		}
	}
	return( bSystemClass );
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
// is CIMOM trying to enum a system class?
BOOL CAsyncJob::SystemClass( BSTR bstrClassName )
{	
	BOOL bSystemClass = FALSE;
	CString cszClassName( bstrClassName );
	if( !cszClassName.IsEmpty())
	{	
		// system class if class name starts with __
		if(cszClassName.GetAt( FIRST_CHAR ) == 0x5F && cszClassName.GetAt ( SECOND_CHAR ) == 0x5F ) 
		{
			bSystemClass = TRUE;
		}
	}
	return( bSystemClass );
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAsyncJob::EnumTopClasses()
{
	// this next line is remarked becuase it cause an access viol
	// in release builds if the function is the first one called after startup
	//STAT_TRACE ( L"\tjob ( %lX ) EnumTopClasses" , this );

	CCimObject	Class;	

	m_pMapping->GetComponentClass( m_pICtx , Class );

	m_pISink->Indicate(1, Class);

	m_pMapping->GetLanguageClass( m_pICtx , Class);

	m_pISink->Indicate(1, Class);		

	m_pMapping->GetGroupRootClass( Class, m_pICtx );

	m_pISink->Indicate(1, Class);

	m_pMapping->GetBindingRootClass( Class , m_pICtx );

	m_pISink->Indicate(1, Class);

	m_pMapping->GetAddParamsClass( Class, m_pICtx );	

	m_pISink->Indicate(1, Class);

	m_pMapping->GetEnumParamsClass( Class , m_pICtx);

	m_pISink->Indicate(1, Class);

	m_pMapping->GetDeleteLanguageParamsClass( Class , m_pICtx);	

	m_pISink->Indicate(1, Class);

	m_pMapping->GetNodeDataClass( Class , m_pICtx);

	m_pISink->Indicate(1, Class);

	m_pMapping->GetDmiEventClass( m_pICtx , Class);

	m_pISink->Indicate(1, Class);	
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAsyncJob::EnumDynamicGroupClasses()
{	
	CIterator*		pIterator;
	CCimObject		Class;

	m_pMapping->GetNewCGAIterator( m_pICtx , &pIterator );

	// NOTE: we do one at a time for performance
	m_pMapping->NextDynamicGroup( Class, pIterator, m_pICtx );

	while( !Class.IsEmpty() )
	{
		m_pISink->Indicate(1, Class);

		m_pMapping->NextDynamicGroup( Class, pIterator, m_pICtx );
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAsyncJob::EnumBindingClasses()
{
	CIterator*		pIterator;
	CCimObject		Class;

	m_pMapping->GetNewCGAIterator( m_pICtx ,  &pIterator );

	m_pMapping->GetLanguageBindingClass( Class, m_pICtx );

	m_pISink->Indicate( 1, Class );

	m_pMapping->GetComponentBindingClass( m_pICtx ,  Class);

	m_pISink->Indicate( 1, Class );

	m_pMapping->GetNodeDataBindingClass( Class, m_pICtx );

	m_pISink->Indicate( 1, Class );

	// NOTE: we do one at a time for performance
	m_pMapping->NextDynamicBinding( Class, pIterator , m_pICtx );

	while( !Class.IsEmpty() )
	{
		m_pISink->Indicate(1, Class);

		m_pMapping->NextDynamicBinding( Class, pIterator , m_pICtx );
	}
}



void CAsyncJob::DoEvent ()
{
	CCimObject	EventObject;

	// create the instance of the extrinsic event object

	m_pWbem->GetExtrinsicEventInstance ( m_Event , EventObject );	

	// signal cimom	

	m_pISink->Indicate ( 1, EventObject );

}

void  CAsyncJob::DoComponentAddNotify ()
{
	CCimObject	EventObject;
	CCimObject	CimComponent;
	CCimObject	Class;

	// create the event objects 

	m_pWbem->GetObject( COMPONENT_CLASS, Class, NULL );

	m_pMapping->cimMakeComponentInstance ( Class , m_Component , m_Row , CimComponent );

	m_pWbem->GetInstanceCreationInstance ( EventObject, 
		 ( IWbemClassObject * ) CimComponent, NULL );


	// signal the cimom client

	m_pISink->Indicate ( 1, EventObject );

}

void  CAsyncJob::DoComponentDeleteNotify ()
{
	CCimObject	EventObject;
	CCimObject	CimComponent;
	CCimObject	Class;

	m_pWbem->GetObject( COMPONENT_CLASS, Class, NULL );

	m_pMapping->cimMakeComponentInstance ( Class , m_Component , m_Row , CimComponent );

	// signal the cimom client

	m_pWbem->GetInstanceDeletionInstance ( EventObject, 
		( IWbemClassObject* ) CimComponent, NULL );

	m_pISink->Indicate ( 1, EventObject );

}

void  CAsyncJob::DoGroupAddNotify ( )
{
	CCimObject	EventObject;
	CCimObject	CimGroup;

	m_pMapping->GetDynamicGroupClass ( m_Group.Component() , m_Group, CimGroup );

	// signal the cimom client

	m_pWbem->GetClassCreationInstance ( EventObject, 
		( IWbemClassObject* ) CimGroup , NULL );

	m_pISink->Indicate ( 1, EventObject );
}

void  CAsyncJob::DoGroupDeleteNotify ()
{
	CCimObject	EventObject;
	CCimObject	CimGroup;

	m_pMapping->GetDynamicGroupClass ( m_Group.Component () , m_Group, CimGroup );

	// signal the cimom client

	m_pWbem->GetClassDeletionInstance ( EventObject, 
		( IWbemClassObject* ) CimGroup, NULL );

	m_pISink->Indicate ( 1, EventObject );

}

void  CAsyncJob::DoLanguageAddNotify ()
{
	CCimObject	EventObject;
	CCimObject	Language;

	// create the instance of DmiLanguage added

	m_pMapping->MakeLanguageInstance( m_cvLanguage, NULL , Language);

	// signal cimom

	m_pWbem->GetInstanceCreationInstance ( EventObject, ( IWbemClassObject* ) Language, NULL );

	m_pISink->Indicate ( 1, EventObject );

}

void  CAsyncJob::DoLanguageDeleteNotify ()
{
	CCimObject	EventObject;
	CCimObject	Language;

	// create the instance of DmiLanguage deleted
	
	m_pMapping->MakeLanguageInstance( m_cvLanguage, NULL , Language);

	// signal cimom

	m_pWbem->GetInstanceDeletionInstance ( EventObject, ( IWbemClassObject* ) Language, NULL );

	m_pISink->Indicate ( 1, EventObject );

}




//***************************************************************************
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//***************************************************************************
LONG CAsyncJob::GetObjectType( CString& cszObjectPath )
{

	if  ( cszObjectPath.Contains ( CLASSVIEW_CLASS )  )
	{		
		if( cszObjectPath.Contains ( EQUAL_STR ) )							
			return CLASSVIEW_I;

		return CLASSVIEW_C;
	}


	if  ( cszObjectPath.Contains ( DMIEVENT_CLASS )  )
	{		
		if( cszObjectPath.Contains ( EQUAL_STR ) )							
			return DMIEVENT_I;

		return DMIEVENT_C;
	}

	if( cszObjectPath.Equals ( ADDMOTHODPARAMS_CLASS ) )	
	{
		if( cszObjectPath.Contains ( EQUAL_STR ) )							
			return ADDMOTHODPARAMS_I;

		return ADDMOTHODPARAMS_C;
	}

	if( cszObjectPath.Equals ( LANGUAGEPARAMS_CLASS ) )	
	{
		if( cszObjectPath.Contains ( EQUAL_STR ) )							
			return LANGUAGEPARAMS_I;

		return LANGUAGEPARAMS_C;
	}

	if( cszObjectPath.Equals ( GETENUMPARAMS_CLASS ) )	
	{
 		if( cszObjectPath.Contains ( EQUAL_STR ) )							
			return GETENUMPARAMS_I;

		return GETENUMPARAMS_C;
	}

	if ( cszObjectPath.Contains ( DMIENUM_CLASS )  )
	{
		if( cszObjectPath.Contains ( EQUAL_STR ) ) 							
			return DMIENUM_I;

		return DMIENUM_C;
	}

	if( cszObjectPath.Contains ( COMPONENT_CLASS ) )		
	{
		// is for component binding
		if ( cszObjectPath.Contains ( COMPONENT_BINDING_CLASS ) ) 
		{
			if ( cszObjectPath.Contains ( EQUAL_STR ) )		// if instance
				return COMPONENT_BINDING_I;
			
			return COMPONENT_BINDING_C;
		}
		else
		{		
			//is the getobject for the component class
			if ( cszObjectPath.Contains ( EQUAL_STR ) )		// if instance
				return COMPONENT_I;
			
			return COMPONENT_C;
		}
	}	

	if( cszObjectPath.Contains ( NODEDATA_CLASS ) ) 
	{
		if ( cszObjectPath.Contains( NODEDATA_BINDING_CLASS ) ) 
		{
			if ( cszObjectPath.Contains ( EQUAL_STR ) ) 		// if instance
				return NODEDATA_BINDING_I;

			return NODEDATA_BINDING_C;
		}
		else
		{
			if( cszObjectPath.Equals ( NODEDATA_CLASS) )
				return NODEDATA_C;

			return NODEDATA_I;
		}
	}	

	if( cszObjectPath.Contains ( LANGUAGE_CLASS ) )	
	{
		if ( cszObjectPath.Contains ( LANGUAGE_BINDING_CLASS ) ) 
		{
			if( cszObjectPath.Equals ( LANGUAGE_BINDING_CLASS ) )
				return LANGUAGE_BINDING_C;
			
			return LANGUAGE_BINDING_I;			
		}

		if ( cszObjectPath.Contains ( EQUAL_STR ) )		// if instance
			return LANGUAGE_I;
		
		return LANGUAGE_C;

	}

	// is the getobject for the bindingroot class

	if( cszObjectPath.Contains ( BINDING_ROOT ) )			
	{
		if( cszObjectPath.Equals ( BINDING_ROOT ) )			
			return BINDING_ROOT_C;

		return BINDING_ROOT_I;
	}	

	// is the getobject for the grouproot class

	if( cszObjectPath.Contains ( GROUP_ROOT ) )			
	{
		if( cszObjectPath.Equals ( GROUP_ROOT ) )			
			return GROUP_ROOT_C;

		return GROUP_ROOT_I;
	}
	
	if( cszObjectPath.Contains ( DMI_NODE ) )			
	{
		if( cszObjectPath.Equals ( DMI_NODE ) )			
			return DMI_NODE_C;

		return DMI_NODE_I;
	}


	if( cszObjectPath.Contains ( EQUAL_STR ) ) 							
		return DYN_GROUP_I;

	// all that is left ...

	return DYN_GROUP_C;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\asyncjob.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__ASYNCJOB_H__)
#define __ASYNCJOB_H__

class CMapping;


class CAsyncJob
{
public:
						~CAsyncJob();
						CAsyncJob();
	void				Execute();

	CWbemLoopBack*		m_pWbem;
	
	LONG				m_lFlags;
	ULONG				m_ulType;
	IWbemObjectSink*	m_pISink;
	CCimObject			m_InParams;		// for ExecMethod;
	CCimObject			m_Instance;
	IWbemContext*		m_pICtx;
	CString				m_cszMethod;		// for ExecMethod
	CString				m_cszSuperClass;	// for CreateClassEnumAsync
	CString				m_cszPath;			// for GetObject
	CString				m_cszClass;			// for InstanceEnum
	CString 			m_cszNamespace;		// the CIMOM path in from which this job was started

	SCODE				InitCreateClass ( CString& , BSTR  , IWbemObjectSink* ,
									LONG  , IWbemContext* , CWbemLoopBack* );

	SCODE				InitGetObject ( CString& , BSTR  , IWbemObjectSink* , 
									LONG  , IWbemContext* , CWbemLoopBack*   );

	SCODE				InitInstanceEnum ( CString& , BSTR  ,IWbemObjectSink* ,
									LONG  , IWbemContext* , CWbemLoopBack*   );

	SCODE				InitDeleteInstace ( CString& , BSTR ,IWbemObjectSink* ,
									LONG  , IWbemContext* , CWbemLoopBack*   );

	SCODE				InitPutInstance (  CString& , IWbemClassObject* , 
									IWbemObjectSink*  , IWbemContext* , CWbemLoopBack*  );

	SCODE				InitExecMethod ( CString& , BSTR  , BSTR  , 
									IWbemObjectSink* , IWbemClassObject* ,
									IWbemContext*  , CWbemLoopBack*  );

	SCODE				InitDeleteClass (  CString& , BSTR  , IWbemObjectSink*  , 
									LONG  , IWbemContext* , CWbemLoopBack*   );

	SCODE				Init( ULONG , CString& , IWbemObjectSink*  , 
									IWbemContext* , CWbemLoopBack*  );

	SCODE				InitAsync( ULONG , CString& , IWbemObjectSink*  , 
									IWbemContext* , CWbemLoopBack*  );
	
	SCODE				InitEvent (  CEvent& , CString& cszNamespace , 
								IWbemObjectSink* pISink , CWbemLoopBack*  );

	SCODE				InitAddComponentNotification (  
								CComponent& Component , CRow& , 
								CString& cszNamespace , 
								IWbemObjectSink* pISink  , CWbemLoopBack* );


	SCODE				InitDeleteComponentNotification (  
								CComponent& Component , CRow& , 
								CString& cszNamespace , IWbemObjectSink* pISink  ,
								CWbemLoopBack* );


	SCODE				InitAddGroupNotification ( 
								CGroup& Group  , CString& cszNamespace , 
								IWbemObjectSink* pISink  , CWbemLoopBack* );


	SCODE				InitDeleteGroupNotification (  CGroup& Group ,
								CString& cszNamespace , IWbemObjectSink* pISink ,
								CWbemLoopBack* );


	SCODE				InitAddLanguageNotification ( CVariant& cvLanguage  , 
								CString& cszNamespace ,  IWbemObjectSink* pISink ,
								CWbemLoopBack* );


	SCODE				InitDeleteLanguageNotification (  
								CVariant& cvLanguage , CString& cszNamespace ,
								IWbemObjectSink* pISink  , CWbemLoopBack* );
	static BOOL			SystemClass( BSTR);


private:

	CRow				m_Row;
	CComponent			m_Component;
	CEvent				m_Event;
	CGroup				m_Group;
	CVariant			m_cvLanguage;
	BOOL				m_bEvent;

	void				DeleteClass();
	void				DeleteInstance();
	void				PutInstance();

	void				EnumBindingClasses();	
	void				EnumDynamicGroupClasses();
	void				EnumTopClasses();


	BOOL				SystemClass( CString&);
	
	void				DispatchJob();

	LONG				GetObjectType( CString& );
	void				GetObject();

	void				InstanceEnumDeep();
	void				InstanceEnumShallow();
	void				ClassEnumDeep();
	void				ClassEnumShallow();
	void				ExecMethod();

	SCODE				InitJob ( );

	CMapping*			m_pMapping;
	
	void			DoEvent ();
	void			DoComponentAddNotify ();
	void 			DoComponentDeleteNotify ();
	void 			DoGroupAddNotify ( );
	void			DoGroupDeleteNotify ();
	void			DoLanguageAddNotify ();
	void			DoLanguageDeleteNotify ();

};

#endif //__ASYNCJOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\dmitest\dmitest.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* ABSTRACT: The dmitest application is a Microsoft WBEM(TM) client application that 
*			demonstrates how a WBEM application can access the DMI database on a DMI enabled
*		    machine.  The program reads command scripts from dmitest.scr input file, processes
*			the command scripts, constructs DMI requests and submits it to WBEM.  It then 
*			stores the output data into dmitest.out.  This program demonstrates how the DMI
*           database can be accesses programatically through the WBEM API.  
* 
*
* ASSUMPTIONS:	It is assumed that the DMI service provider is running on the 
*               system that is going to be accessed by the DMI provider.  It is also
*               assumed that the wbemdmip.mof file has already been compiled by the WBEM
*               mof compiler (mofcomp.exe) and is installed in the WBEM schema.
*
*
*/


#include "defines.h"
#include <windows.h>
#include <fstream.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <objbase.h>
#include <initguid.h>
#include <wbemidl.h>     // CIMOM interface declarations
#include "datatypes.h"
#include "dmitest.h"


#define RELEASE(a)		if (a) {(a)->Release(); (a)=NULL;}
#define PPVOID			void**
#define MATCH			0

BOOL _gbSysProps;			
BOOL _gbEcho;

LPWSTR HmmErrorString(SCODE sc);






///////////////////////////
//*****************************************************************************
// Function:   WbemErrorString
// Purpose:    Turns sc into a text string
//*****************************************************************************
LPWSTR HmmErrorString(SCODE sc)
{
	LPWSTR psz;

	switch(sc) {
	case WBEM_S_ALREADY_EXISTS					: psz = L"WBEM_S_ALREADY_EXISTS " ;			break;
	case WBEM_S_RESET_TO_DEFAULT				: psz = L"WBEM_S_RESET_TO_DEFAULT";			break; 
	case WBEM_S_DIFFERENT						: psz = L"WBEM_S_DIFFERENT";				break; 
	case WBEM_E_FAILED							: psz = L"WBEM_E_FAILED ";					break;				// 80041001
	case WBEM_E_NOT_FOUND						: psz = L"WBEM_E_NOT_FOUND" ;				break;				// 80041002
	case WBEM_E_ACCESS_DENIED					: psz = L"WBEM_E_ACCESS_DENIED " ;			break;				// 80041003
	case WBEM_E_PROVIDER_FAILURE					: psz = L"WBEM_E_PROVIDER_FAILURE " ;	break;				// 80041004
	case WBEM_E_TYPE_MISMATCH					: psz = L"WBEM_E_TYPE_MISMATCH" ;			break;				// 80041005
	case WBEM_E_OUT_OF_MEMORY					: psz = L"WBEM_E_OUT_OF_MEMORY " ;			break;				// 80041006
	case WBEM_E_INVALID_CONTEXT					: psz = L"WBEM_E_INVALID_CONTEXT " ;		break;				// 80041007
	case WBEM_E_INVALID_PARAMETER				: psz = L"WBEM_E_INVALID_PARAMETER ";		break; 				// 80041008
	case WBEM_E_NOT_AVAILABLE					: psz = L"WBEM_E_NOT_AVAILABLE " ;			break;				// 80041009
	case WBEM_E_CRITICAL_ERROR					: psz = L"WBEM_E_CRITICAL_ERROR " ;			break;				// 8004100a
	case WBEM_E_INVALID_STREAM					: psz = L"WBEM_E_INVALID_STREAM " ;			break;				// 8004100b
	case WBEM_E_NOT_SUPPORTED					: psz = L"WBEM_E_NOT_SUPPORTED " ;			break;				// 8004100c
	case WBEM_E_INVALID_SUPERCLASS				: psz = L"WBEM_E_INVALID_SUPERCLASS " ;		break;				// 8004100d
	case WBEM_E_INVALID_NAMESPACE				: psz = L"WBEM_E_INVALID_NAMESPACE " ;		break;				// 8004100e
	case WBEM_E_INVALID_OBJECT					: psz = L"WBEM_E_INVALID_OBJECT " ;			break;				// 8004100f
	case WBEM_E_INVALID_CLASS					: psz = L"WBEM_E_INVALID_CLASS ";			break;				// 80041010
	case WBEM_E_PROVIDER_NOT_FOUND				: psz = L"WBEM_E_PROVIDER_NOT_FOUND";			break;			// 80041011
	case WBEM_E_INVALID_PROVIDER_REGISTRATION	: psz = L"WBEM_E_INVALID_PROVIDER_REGISTRATION ";break;			// 80041012
	case WBEM_E_PROVIDER_LOAD_FAILURE			: psz = L"WBEM_E_PROVIDER_LOAD_FAILURE ";		break;			// 80041013
	case WBEM_E_INITIALIZATION_FAILURE			: psz = L"WBEM_E_INITIALIZATION_FAILURE";		break;			// 80041014
	case WBEM_E_TRANSPORT_FAILURE				: psz = L"WBEM_E_TRANSPORT_FAILURE" ;			break;			// 80041015
	case WBEM_E_INVALID_OPERATION				: psz = L"WBEM_E_INVALID_OPERATION" ;			break;			// 80041016
	case WBEM_E_INVALID_QUERY					: psz = L"WBEM_E_INVALID_QUERY " ;				break;			// 80041017
	case WBEM_E_INVALID_QUERY_TYPE				: psz = L"WBEM_E_INVALID_QUERY_TYPE ";			break; 			// 80041018
	case WBEM_E_ALREADY_EXISTS					: psz = L"WBEM_E_ALREADY_EXISTS " ;				break; 			// 80041019
	case WBEM_E_OVERRIDE_NOT_ALLOWED			: psz = L"WBEM_E_OVERRIDE_NOT_ALLOWED " ;		break; 			// 8004101a
	case WBEM_E_PROPAGATED_QUALIFIER			: psz = L"WBEM_E_PROPAGATED_QUALIFIER "	;		break; 			// 8004101b
	case WBEM_E_PROPAGATED_PROPERTY				: psz = L"WBEM_E_PROPAGATED_PROPERTY" ;			break; 			// 8004101c
	case WBEM_E_UNEXPECTED						: psz = L"WBEM_E_UNEXPECTED ";					break; 			// 8004101d
	case WBEM_E_ILLEGAL_OPERATION				: psz = L"WBEM_E_ILLEGAL_OPERATION";			break; 			// 8004101e
	case WBEM_E_CANNOT_BE_KEY					: psz = L"WBEM_E_CANNOT_BE_KEY";				break; 			// 8004101f
	case WBEM_E_INCOMPLETE_CLASS				: psz = L"WBEM_E_INCOMPLETE_CLASS";				break; 			// 80041020
	case WBEM_E_INVALID_SYNTAX					: psz = L"WBEM_E_INVALID_SYNTAX ";				break; 			// 80041021
	case WBEM_E_NONDECORATED_OBJECT				: psz = L"WBEM_E_NONDECORATED_OBJECT";			break;	 		// 80041022
	case WBEM_E_READ_ONLY						: psz = L"WBEM_E_READ_ONLY ";					break;
	case WBEM_E_PROVIDER_NOT_CAPABLE			: psz = L"WBEM_E_PROVIDER_NOT_CAPABLE";			break;
	case WBEM_E_CLASS_HAS_CHILDREN				: psz = L"WBEM_E_CLASS_HAS_CHILDREN";			break;
	case WBEM_E_CLASS_HAS_INSTANCES				: psz = L"WBEM_E_CLASS_HAS_INSTANCES";			break;
	case WBEM_E_QUERY_NOT_IMPLEMENTED			: psz = L"WBEM_E_QUERY_NOT_IMPLEMENTED ";		break;
	case WBEM_E_ILLEGAL_NULL					: psz = L"WBEM_E_ILLEGAL_NULL";					break;
	case WBEM_E_INVALID_QUALIFIER_TYPE			: psz = L"WBEM_E_INVALID_QUALIFIER_TYPE";		break;
	case WBEM_E_INVALID_PROPERTY_TYPE			: psz = L"WBEM_E_INVALID_PROPERTY_TYPE ";		break;
	case WBEM_E_VALUE_OUT_OF_RANGE				: psz = L"WBEM_E_VALUE_OUT_OF_RANGE";			break;
	case WBEM_E_CANNOT_BE_SINGLETON				: psz = L"WBEM_E_CANNOT_BE_SINGLETON";			break;
	case WBEM_E_INVALID_CIM_TYPE				: psz = L"WBEM_E_INVALID_CIM_TYPE";				break;
	case WBEM_E_INVALID_METHOD					: psz = L"WBEM_E_INVALID_METHOD";				break;
	case WBEM_E_INVALID_METHOD_PARAMETERS		: psz = L"WBEM_E_INVALID_METHOD_PARAMETERS";				break;
	case WBEM_E_SYSTEM_PROPERTY					: psz = L"WBEM_E_SYSTEM_PROPERTY";    break;
	case WBEM_E_INVALID_PROPERTY			    : psz = L"WBEM_E_INVALID_PROPERTY";				break;
	case WBEM_E_CALL_CANCELLED					: psz = L"WBEM_E_CALL_CANCELLED";				break;
	case WBEM_E_SHUTTING_DOWN					: psz = L"WBEM_E_SHUTTING_DOWN";				break;
	case WBEM_E_PROPAGATED_METHOD				: psz = L"WBEM_E_PROPAGATED_METHOD";				break;
//	case WBEM_E_UNSUPPORTED_FLAGS				: psz = L"WBEM_E_UNSUPPORTED_FLAGS";			break;
	case WBEMESS_E_REGISTRATION_TOO_BROAD		: psz = L"WBEMESS_E_REGISTRATION_TOO_BROAD";			break;			// 0x80042001
	case WBEMESS_E_REGISTRATION_TOO_PRECISE	    : psz = L"WBEMESS_E_REGISTRATION_TOO_PRECISE";	break;
	default:									psz = L"Error Code Not Recognized";				break;
	}
	return psz;
}



///////////////////////////
LPWSTR gettabs(LONG lCount)
{
	switch (lCount)
	{
	case 1: 		return L"  ";
	case 2: 		return L"   ";
	case 3: 		return L"    ";
	case 4: 		return L"     ";
	case 5:			return L"      ";
	case 6:			return L"       ";
	case 7:			return L"        ";
	case 8:			return L"         ";
	case 9:			return L"          ";
	case 10:		return L"           ";
	case 11:		return L"            ";
	case 12:		return L"             ";
	case 13:		return L"              ";
	case 14:		return L"               ";
	case 15:		return L"                ";
	default:		return L"                  ";
	}
}


LPWSTR CApp::GetBetweenQuotes(LPWSTR pString, LPWSTR pBuffer)
{
	LPWSTR p = pString;
	LPWSTR q = pBuffer;
	
	while(*p && *p != 34)		// go to open qoute
		p++;

	if (!*p)
		return NULL;

	p++;

	while(*p != 34)		// copy till close qyoute
		*q++ = *p++;

	*q = NULL;

	return ++p;	
}

LPWSTR CApp::GetInstancePath(LPWSTR pString, LPWSTR pBuffer)
{
	LPWSTR p = pString;
	LPWSTR q = pBuffer;
	BOOL	bKeyIsString = FALSE;
	
	while(*p != 34)		// go to open qoute
		p++;

	if (!*p++)
		return NULL;

	do 
	{
		*q++ = *p++;
	}
	while(*p != 61);		// copy till equal
		
	*q++ = *p++;
	
	if ( *p == 34 )		// if Instance key is string
	{
		*q++ = *p++;
		bKeyIsString = TRUE;
	}

	while( TRUE )		// copy till closeing qyoute
	{
		if (*p == 34)
		{
			if (bKeyIsString)
				*q++ = *p++;

			break;
		}
	
		*q++ = *p++;
	}

	*q = NULL;

	return ++p;	
}
LPWSTR CApp::GetPropertyFromBetweenQuotes(LPWSTR pString, LPWSTR pName, LPWSTR pValue)
{
	LPWSTR p = pString;
	LPWSTR pN = pName;
	LPWSTR pV = pValue;
	
	while(*p != 34)		// go to open qoute
		p++;
	p++;

	while(*p != 61)		// copy till Equal
		*pN++ = *p++;
	*pN = NULL;

	p++;

	while(*p != 34)		// copy till End Quoute
		*pV++ = *p++;
	*pV = NULL;

	return ++p;	
}

BOOL CApp::GetPropertyAndValue( LPWSTR wcsProperty, CVariant& cvarValue, LPWSTR* pp) 
{
	WCHAR		wcsValue[8000];	
	LPWSTR		p = *pp;
	LPWSTR		pN = wcsProperty;
	LPWSTR		pV = wcsValue;

	// walk off white space
	while (*p )
	{
		if ( *p < 32 )
			return FALSE;

		if (*p == 44)
			p++;

		if ( *p == 32)
			p++;

		if (*p > 32)
			break;
	}

	if ( !*p ) 
		return FALSE;

	while ( *p != 61 )
		*pN++ = *p++;

	*pN = NULL;

	if (*(++p) == 34)
	{
		p++;

		while(*p != 34)		// copy till End Quoute
			*pV++ = *p++;

		*pV = NULL;

		cvarValue.Set( wcsValue );

		*pp = ++p;

		return TRUE;
	}
	else
	{
		while( *p && *p != 0Xa)
		{
			if ( *p == 32)		// copy till space
				break;

			*pV++ = *p++;
		}

		*pV = NULL;

		cvarValue.Set( wcsValue );

		*pp = p;

		return TRUE;
	}

	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////
void CApp::print(LPWSTR wsz)
{
	WCHAR	szBuff [8000];
	LPWSTR	p , q;
	LONG	lCount = 0;


	// escape any enclose quotes we have contained in the string

	p = wsz;

	while ( *p )
	{
		if ( *p++ == 34 )
			lCount++;
	}

	p = wsz;
	q = szBuff;


	
	while ( *p )
	{
		/*
		if ( *p == 34 &&  lCount > 4 )
		{
			*q++ = 92; // '\ char'
		}
		*/

		*q++ =  *p++;			
	}

	*q = 0;

	
	
	if(m_bPrintToFile)
	{
		if(!m_fOut)
			m_fOut = fopen("dmitest.out", "w");

		fwprintf(m_fOut, L"%s\n", szBuff);

		fflush(m_fOut);
	}

	if(m_bPrintToScreen)
		wprintf(L"%s\n", szBuff );
}

void CApp::print(LPWSTR wszFailureReason, SCODE result)
{
	WCHAR buff[8000];

	swprintf(buff, L"%s: %s(0x%08lx)\n", wszFailureReason, HmmErrorString(result), result);

	print(buff);
}
////////////////////////////////////////////////////////////////////////////////////

CApp::CApp()
{
	m_bRun = FALSE;
	m_bPrintToFile = TRUE;
	m_bPrintToScreen = TRUE;	
	m_fScript = NULL; 
	m_fOut = NULL;
	_gbEcho = TRUE;
	_gbSysProps = FALSE;

	if( OleInitialize(NULL) != S_OK)
	{
		print( "OleInitialize Failed\n"); 
		return;
	}

	m_bRun = TRUE;
	m_pIServices = NULL;
}

CApp::~CApp()
{
	OleUninitialize();               

	if(m_fOut)
		fclose(m_fOut);

	if(m_fScript)
		fclose(m_fScript);
}

////////////////////////////////////////////////////////////////////////////////////
void CApp::Run(int argc, WCHAR** argv)
{
	
	if(!m_bRun)
		return;

	if ( ParseCommandLine(argc, argv) )
		ProcessScriptFile();

}


////////////////////////////////////////////////////////////////////////////////////
void CApp::ProcessScriptFile(void)
{
	#define BUFFER_LEN 2048
	WCHAR			pScriptLine[8000];



	m_fScript = fopen("dmitest.scr", "r");	

	if(!m_fScript)
	{
		printf("%s", "ERROR - could not open DMITEST.SCR.");
		return;
	}	

	while(fgetws( pScriptLine, BUFFER_LEN, m_fScript))
	{
		LPWSTR p;
		
		//if( wcsstr( pScriptLine, L"") )
			//continue;

		if( wcsstr( pScriptLine, L"list properties") )
			m_bProperties = TRUE;
		else
			m_bProperties = FALSE;

		if( wcsstr( pScriptLine, L"list qualifiers") )
			m_bQualifiers = TRUE;
		else
			m_bQualifiers = FALSE;


		//OS(pScriptLine);
		if(pScriptLine[0] == 47 && pScriptLine[1] == 47) // if script line starts with //
		{
			if (_gbEcho )
				print ( pScriptLine );

			continue;
		}


		if( wcsstr(pScriptLine, L"disconnect") )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );

			Disconnect();
			continue;
		}

		if( wcsstr(pScriptLine, L"connect") )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );

			Connect(pScriptLine);
			continue;
		}

		if (wcsstr( pScriptLine, L"dump classes all" ) )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );

			EnumClasses(pScriptLine, WBEM_FLAG_DEEP);
			continue;
		}

		if (wcsstr( pScriptLine, L"dump classes top" ) )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );


			EnumClasses(pScriptLine, WBEM_FLAG_SHALLOW);
			continue;
		}

		if (wcsstr( pScriptLine, L"dump classes recurse" ) )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );

			StartRecurseClasses(pScriptLine);
			continue;
		}

		if (wcsstr( pScriptLine, L"dump instances of subs" ) )		
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );


			EnumInstances( pScriptLine, WBEM_FLAG_DEEP);
			continue;
		}

		if (wcsstr( pScriptLine, L"dump instances" ) )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );

			EnumInstances(pScriptLine, WBEM_FLAG_SHALLOW);
			continue;
		}

		if (wcsstr( pScriptLine, L"getobject" ) )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );
			GetObject(pScriptLine);
			continue;
		}
		
		if (p = wcsstr( pScriptLine, L"ExecMethod(" ) )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );

			ExecMethod(p);
			continue;
		}

		if (wcsstr( pScriptLine, L"modify instance" ) )
		{
		    print ( L" " );
			print ( L" " );
			print ( pScriptLine );
			ModifyInstance(pScriptLine);
			continue;
		}

		if (wcsstr( pScriptLine, L"delete instance" ) )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );

			DeleteInstance(pScriptLine);
			continue;
		}

		if (wcsstr( pScriptLine, L"delete class" ) )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );


			DeleteClass(pScriptLine);
			continue;
		}

		if ( p = wcsstr( pScriptLine, L"AddRow" ) )
		{
			print ( L" " );
			print ( L" " );
			print ( pScriptLine );

			PutInstance(p);
			continue;
		}		
	}	// end while loop
}

////////////////////////////////////////////////////////////////////////////////////
BOOL CApp::ParseCommandLine(int argc, LPWSTR* Array)
{

	for( int i = 0; i < argc; i++)
	{
		if( MATCH == wcsicmp(Array[i], L"/noconsole") )
			m_bPrintToScreen = FALSE;
		
		if ( MATCH == wcsicmp(Array[i], L"/nofile") )
			m_bPrintToFile = FALSE;	

		if ( MATCH == wcsicmp(Array[i], L"/noecho") )
			_gbEcho = FALSE;			

		if ( MATCH == wcsicmp(Array[i], L"/systemproperties") )
			_gbSysProps = TRUE;			

		if ( MATCH == wcsicmp(Array[i], L"/?") || MATCH == wcsicmp(Array[i], L"-?"))
		{
			print ( L"DmiTest Command line parameters" );
			print ( L"/noconsole -- Don't show the dmitest results in the console" );
			print ( L"/nofile -- Don't produce a dmitest.out file");
			print ( L"/systemproperties -- Show all classes sytem properties");
			print ( L"/noecho -- Don't echo comment lines to output files " );
			
			return FALSE;		
		}
	}

	return TRUE;

}


////////////////////////////////////////////////////////////////////////////////////

extern "C" int wmain(int argc, wchar_t *argv[])
{

	CApp theApp;
	
	theApp.Run(argc, argv);

	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////
SCODE CApp::Connect(LPWSTR pScriptLine)
{
	SCODE			result;
	IWbemLocator*	pIWbemLocator = NULL;	
	WCHAR			NameSpace[8000];
	LPWSTR			p = pScriptLine,
					q = NameSpace;

	while(*p)
	{
		if(*p++ == 32) // a space		
			break;
	}

	while(*p < 123 && *p > 47)
		*q++ = *p++;

	*q = NULL;

	
	if (FAILED (result = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pIWbemLocator) ))
	{
		print(L"Failed to create IWbemLocator object", result); 
		return result;
	}

	
	if (FAILED (result = pIWbemLocator->ConnectServer( NameSpace, NULL, NULL, NULL, 0L, NULL, NULL, &m_pIServices) ))
	{
		print(L"Failed to ConnectServer", result); // exits program
		return result;
	}

	RELEASE(pIWbemLocator);

	print(L"\nConnected to %s", NameSpace);

	return NO_ERROR;
}

SCODE CApp::Disconnect()
{
	
	RELEASE(m_pIServices);

	print("Disconnected");

	return NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
SCODE CApp::DumpQualifiers(IWbemQualifierSet* pIQualifiers, LONG tabs)
{
	SCODE result = NO_ERROR;
	CBstr	cbstrName;
	CVariant	cvarValue;	

	if(!m_bQualifiers)
		return result;

	if (FAILED ( result = pIQualifiers->BeginEnumeration( 0L ) ))
	{
		print(L"BeginEnumeration Failed", result);
		return result;
	}

	while ( WBEM_NO_ERROR == pIQualifiers->Next( 0L, cbstrName, cvarValue, NULL  ) )
	{
		print(L"%s%s=%s", gettabs(tabs), cbstrName, cvarValue.GetAsString());
		cbstrName.Clear();
		cvarValue.Clear();
	}

	return result;
}

//////////////////////////////////////////////////////////////////////////////////////////
SCODE CApp::DumpObject(IWbemClassObject* pIObject, LONG tabs)
{
IWbemQualifierSet*	pIQualifiers = NULL;
	SCODE				result = NO_ERROR;	
	CSafeArray			saProperties;

	if(!m_bProperties)
		return result;

	// print class qualifiers

	if (FAILED (result = pIObject->GetQualifierSet(&pIQualifiers) ))
	{
		print(L"GetQualiferSet failed", result);
		return result;
	}
	
	DumpQualifiers(pIQualifiers, tabs + 2);	

	RELEASE ( pIQualifiers );
   
	// print properties

	LONG lFlags = WBEM_FLAG_NONSYSTEM_ONLY;

	if ( _gbSysProps )
		lFlags = 0;

	if (FAILED( pIObject->GetNames( NULL, lFlags, NULL, saProperties) ))
	{
		print(L"GetNames failed", result);
		return result;
	}

	if (saProperties.BoundsOk())
	{
		for(int i = saProperties.LBound(); i <= saProperties.UBound(); i++)
		{
			CVariant varValue;

			result = pIObject->Get(saProperties.Bstr(i), 0, varValue, NULL, NULL);

			if (FAILED( result ))
			{
				print(L"Get failed", result);
				continue;
			}

			switch ( varValue.GetType () )
			{
				case VT_ARRAY | VT_BSTR :
				{
					if ( SafeArrayGetDim ( ((VARIANT)varValue).parray ) == 1 )
					{
						LONG dimension = 1 ; 
						LONG lower ;
						SafeArrayGetLBound ( ((VARIANT)varValue).parray, dimension , & lower ) ;
						LONG upper ;
						SafeArrayGetUBound ( ((VARIANT)varValue).parray, dimension , & upper ) ;
						LONG count = ( upper - lower ) + 1 ;

						for ( LONG elementIndex = lower ; elementIndex <= upper ; elementIndex ++ )
						{
							BSTR element ;
							SafeArrayGetElement ( ((VARIANT)varValue).parray, &elementIndex , & element ) ;
							print(L"\n%s%s=%s,", gettabs(tabs + 10), saProperties.Bstr(i), element ) ;
						}
					}
				}
				break;

				case VT_ARRAY | VT_I4 :
				{
					if ( SafeArrayGetDim ( ((VARIANT)varValue).parray ) == 1 )
					{
						LONG dimension = 1 ; 
						LONG lower ;
						SafeArrayGetLBound ( ((VARIANT)varValue).parray, dimension , & lower ) ;
						LONG upper ;
						SafeArrayGetUBound ( ((VARIANT)varValue).parray, dimension , & upper ) ;
						LONG count = ( upper - lower ) + 1 ;

						for ( LONG elementIndex = lower ; elementIndex <= upper ; elementIndex ++ )
						{
							ULONG element ;
							SafeArrayGetElement ( ((VARIANT)varValue).parray, &elementIndex , & element ) ;
							wchar_t t_Int [ 16 ] ;
							wsprintfW ( t_Int , L"%ld" , element ) ;
							print(L"\n%s%s=%ls,", gettabs(tabs + 10), saProperties.Bstr(i), t_Int ) ;
						}
					}
				}
				break;

				default:
				{
					print(L"\n%s%s=%s,", gettabs(tabs + 10), saProperties.Bstr(i), varValue.GetAsString() );
				}
				break ;
			}
			
			result = pIObject->GetPropertyQualifierSet( saProperties.Bstr(i), &pIQualifiers);

			if (SUCCEEDED ( result ))
				DumpQualifiers(pIQualifiers, tabs + 10 + 2);				

			RELEASE ( pIQualifiers );
		}
	}

	return result;
}

//////////////////////////////////////////////////////////////////////////////////////////
SCODE CApp::EnumClasses(LPWSTR pScriptLine, LONG lFlag)
{
	SCODE				result = 0;
	ULONG				ulReturned = 0;
	IWbemClassObject*	pIClass = NULL;
	VARIANT				var;
	LONG				tabs = 1;
	WCHAR				wcsClassName[8000];
	LPWSTR				pszSuperClass = NULL;
	CBstr				cbstrSuperClass(NULL);

	if(!m_pIServices)
	{
		print(L"ERROR cannot - dump classes not connected");
		return result;
	}

	IEnumWbemClassObject* pIEnum = NULL;

	pszSuperClass = GetBetweenQuotes( pScriptLine, wcsClassName);

	if(lFlag == WBEM_FLAG_DEEP)
		print(L"\n Start Complete Class Listing ------------\n");
	else
		print(L"\n Start Top Level Class Listing ------------\n");

	if (pszSuperClass)
		cbstrSuperClass.Set(wcsClassName);
	
	if (FAILED ( result = m_pIServices->CreateClassEnum( cbstrSuperClass, lFlag, NULL, &pIEnum) ))		
	{
		print(L"CreateClassEnum failed", result);
		return result;
	}
 
	VariantInit(&var);

	while (TRUE)
	{
		pIEnum->Next(10000, 1, &pIClass, &ulReturned);

		if(! ulReturned)
			break;

		VariantClear(&var);

		pIClass->Get(L"__CLASS", 0L, &var, NULL, NULL);

		if( var.bstrVal[0] != 95 && var.bstrVal[1] != 95)
		{
			print(L"%s%s", gettabs(tabs), var.bstrVal);
			
			DumpObject(pIClass, tabs);
		}

		RELEASE (pIClass );

	}

	RELEASE ( pIEnum );

	if(lFlag == WBEM_FLAG_DEEP)
		print(L"\n End Complete Class Listing ------------\n");
	else
		print(L"\n End Top Level Class Listing ------------\n");

	return result;
}

//////////////////////////////////////////////////////////////////////////////////////////
SCODE CApp::RecurseClasses(LPWSTR pClassName, LONG nTabCount)
{
	SCODE					result;
	IEnumWbemClassObject*	pIEnum = NULL;	
	IWbemClassObject*		pIClass = NULL;
	ULONG					ulReturned = 0;
	VARIANT					var;

	VariantInit(&var);

	nTabCount ++;	

	if (FAILED ( result = m_pIServices->CreateClassEnum( CBstr( pClassName ) , WBEM_FLAG_SHALLOW, NULL, &pIEnum) ))		
	{
		print(L"CreateClassEnum failed", result);
		return result;
	}

	while (TRUE)
	{
		pIEnum->Next(1000, 1, &pIClass, &ulReturned);

		if(! ulReturned)
			break;		

		pIClass->Get(L"__CLASS", 0L, &var, NULL, NULL);
		
		if( var.bstrVal[0] != 95 && var.bstrVal[1] != 95)
		{
			print(L"%s%s", gettabs(nTabCount), var.bstrVal);

			DumpObject(pIClass, nTabCount);

			RecurseClasses(var.bstrVal, nTabCount);
		}

		VariantClear(&var);

		RELEASE ( pIClass );
	}
	
	RELEASE ( pIClass );
	RELEASE ( pIEnum );

	return result;
}

SCODE CApp::StartRecurseClasses(LPWSTR wcsScriptLine)
{
	SCODE		result = NO_ERROR;
	WCHAR		wcsParentClass[8000];

	if(!m_pIServices)
	{
		print(L"ERROR cannot - dump classes recurse - not connected");
		return result;
	}

	print(L"\n Start Class Recursion --------------------\n");
		
	if ( wcsstr(wcsScriptLine, L"parentclass=") )
		GetBetweenQuotes(wcsScriptLine, wcsParentClass);
	else
		wcscpy(wcsParentClass,L"");

	print(L"ParentClass is %s", wcsParentClass);

	CBstr cbstrSuperClass;
	cbstrSuperClass.Set(wcsParentClass);

	result = RecurseClasses( cbstrSuperClass, 1);

	print(L"\n End Class Recursion ----------------------\n");

	return result;


}


//////////////////////////////////////////////////////////////////////////////////////////
SCODE CApp::EnumInstances(LPWSTR wcsScriptLine, LONG lFlag)
{
	ULONG					ulReturned;
	SCODE					result = NO_ERROR;
	WCHAR					wcsClassName[8000];
	WCHAR					wcsInstance[8000];
	IWbemClassObject*		pIInstance = NULL;
	IEnumWbemClassObject*	pIEnum = NULL;
	LONG					tabs = 1;

	if(!m_pIServices)
	{
		print(L"ERROR cannot - dump instances - not connected");
		return result;
	}

	// parse class name;
	GetBetweenQuotes( wcsScriptLine, wcsClassName);

	print(L"\n Start Instance Enumeration -----------------------------") ;
	print(L"Class Name is %s\n", wcsClassName); 

	
	if (FAILED ( result = m_pIServices->CreateInstanceEnum( CBstr(wcsClassName), lFlag, NULL, &pIEnum) ))		
	{
		print(L"Failed to create CreateInstanceEnum", result);
		return result;
	}	

	for (int i = 1; TRUE; i++)
	{
		CSafeArray	saKeys;
		CVariant	varName;

		pIEnum->Next(10000, 1, &pIInstance, &ulReturned);

		if(! ulReturned)
			break;		

		if (FAILED( pIInstance->Get(L"__CLASS", 0L, varName, NULL, NULL) ))
			continue;

		swprintf(wcsInstance, L"\n%s%s", gettabs(tabs), varName.GetBstr());

		// dump key set
		if (FAILED( pIInstance->GetNames( NULL, WBEM_FLAG_KEYS_ONLY, NULL, saKeys) ))
			continue;

		if (saKeys.BoundsOk())
		{
			for(int i = saKeys.LBound(); i <= saKeys.UBound(); i++)
			{
				CVariant varValue;

				if (FAILED( pIInstance->Get(saKeys.Bstr(i), 0, varValue, NULL, NULL) ))
					continue;

				swprintf(wcsInstance, L"%s.%s=%s,", wcsInstance, saKeys.Bstr(i), varValue.GetAsString());
			}
		}

		print(wcsInstance);
		// dump rest of object

		DumpObject(pIInstance, tabs);		

		RELEASE ( pIInstance );
	}

	RELEASE ( pIEnum );

	print(L"\n End Instance Enumeration -----------------------------\n");

	return result;
}


SCODE CApp::GetObject(LPWSTR wcsScriptLine)
{
	SCODE	result = NO_ERROR;
	WCHAR	wcsObjectPath[8000];
	LPWSTR	p = wcsScriptLine, q = wcsObjectPath;
	IWbemClassObject*		pIObject = NULL;
	LONG	tabs = 1;

	if(!m_pIServices)
	{
		print(L"ERROR cannot - GetObject - not connected");
		return result;
	}

	// parse object path
	while(*p != 34 )	// the open quote
		p++;

	p++;

	while (*p)			// copy remnants to object path
		*q++ = *p++;

	*q-- = NULL;
	
	// need to go backwards to parse the close qoute as other qoutes could appear in string
	while ( q > wcsObjectPath && *q != 34) // close quote
		q--;

	*q = NULL;


	print(L"\n Start GetObject ----------------------------------------");
	print(L"Object path is %s\n", wcsObjectPath );

	if (FAILED ( result = m_pIServices->GetObject( CBstr( wcsObjectPath), 0L, NULL, &pIObject, NULL ) ))		
	{
		print(L"Failed to GetObject", result);
		return result;
	}	

	CVariant var;

	if (FAILED ( result = pIObject->Get(L"__CLASS", 0L, var, NULL, NULL) ))
	{
		print(L"Failed to Get", result);
		return result;
	}
		
	// print class names
	print(L"%s%s", gettabs(tabs), var.GetAsString());

	DumpObject(pIObject, tabs + 2);

	RELEASE ( pIObject );

	print(L"\n End GetObject -----------------------------------------\n");

	return result;
}


SCODE CApp::ModifyInstance(LPWSTR wcsScriptLine)
{
	SCODE				result = NO_ERROR;
	WCHAR				wcsInstancePath[8000];
	WCHAR				wcsProperty[8000];
	WCHAR				wcsPropertyValue[8000];
	IWbemClassObject*	pIInstance = NULL;
	LONG				tabs = 1;
	LPWSTR				p;
	CVariant			cvarValue;
	
	print(L"\n Start ModifyInstance -----------------------------------------");
	
	p = wcsstr(wcsScriptLine, L"property");

	if (p)
		GetPropertyFromBetweenQuotes(p, wcsProperty, wcsPropertyValue);

	p = wcsScriptLine;

	
	// determine instance path from script line.

	while ( *p != 34 )
		p++;
	
	p++;

	wcscpy ( wcsInstancePath , p );

	p = wcsstr(wcsInstancePath, L"property");

	p--;
	p--;
	*p = 0;

	print(L"Instance = %s\n, Property = %s\n, New Value = %s\n", wcsInstancePath, wcsProperty, wcsPropertyValue);

	if(!m_pIServices)
	{
		print(L"ERROR cannot - GetObject - not connected");
		return result;
	}

	if (FAILED ( result = m_pIServices->GetObject( CBstr ( wcsInstancePath ), 0L, NULL, &pIInstance, NULL ) ))		
	{
		print(L"Failed to GetObject", result);
		return result;
	}	
	
	cvarValue.Set(wcsPropertyValue);
	if (FAILED ( result = pIInstance->Put( CBstr (wcsProperty) , 0L, cvarValue, NULL) ))
	{
		print(L"Failed to Put", result);
		return result;
	}

	CSafeArray saKeys;

	if (FAILED( pIInstance->GetNames( NULL, WBEM_FLAG_KEYS_ONLY, NULL, saKeys) ))
	{
		print(L"GetNames failed", result);
		return result;
	}

	if(FAILED (result = m_pIServices->PutInstance(pIInstance, WBEM_FLAG_UPDATE_ONLY, NULL, NULL) ))
	{
		print(L"Failed to PutInstance", result);
		return result;
	}	

	RELEASE(pIInstance);

	print(L"%s%s", gettabs(tabs), L"PutInstance Success");

	print(L"\n End PutInstance -----------------------------------------\n" );

	return result;

}

SCODE CApp::ExecMethod(LPWSTR wcsScriptLine)
{
	SCODE				result = NO_ERROR;
	WCHAR				wszObjectPath[8000], wszMethod[8000], wszInParams[8000];
	IWbemClassObject*	pIClass = NULL;
	IWbemClassObject*	pIInstance = NULL;
	LONG				tabs = 1, i = 0;
	LPWSTR				p = NULL, pInProp = NULL, pInPropValue = NULL;
	CVariant			cvarPropertyValue;
	
	print(L"\n Start ExecMethod -----------------------------------------");
	p = GetBetweenQuotes(wcsScriptLine, wszObjectPath);
	p = GetBetweenQuotes(p, wszMethod);	
	p = GetBetweenQuotes(p, wszInParams);

	p = wszInParams;

	while(*p && *p != 46)
		p++;

	if (!*p)
	{
		print(L"Failed to parse command");
		return 0;
	}

	*p = NULL;

	pInProp = ++p;

	while( *p && *p != 61 )
		p++;

	if (!*p)
	{
		print(L"Failed to parse command");
		return 0;
	}

	*p = NULL;

	pInPropValue = ++p;

	print(L"ObjectPath is %s\n Method is %s\n InParams = %s\n %s = %s", wszObjectPath, wszMethod, wszInParams, pInProp, pInPropValue );

	if(!m_pIServices)
	{
		print(L"ERROR cannot - ExecMethod - not connected");
		return result;
	}

	if (FAILED ( result = m_pIServices->GetObject( CBstr ( wszInParams ), 0L, NULL, &pIClass, NULL ) ))		
	{
		print(L"Failed to GetObject", result);
		return result;
	}	
	
	if (FAILED ( result = pIClass->SpawnInstance(0L, &pIInstance) ))
	{
		print(L"Failed to SpawnInstance", result);
		return result;
	}

	RELEASE(pIClass);

	if (FAILED ( result = pIInstance->Put( CBstr ( pInProp ) , 0L, CVariant ( pInPropValue ), NULL ) ))
	{
		RELEASE ( pIInstance ) ;
		print(L"Failed to Put InParams", result);
		return result;
	}		

	print(L"\n%s Calling ExecMethod \n", gettabs(tabs));	
	IWbemClassObject* pIOut = NULL;
	IWbemCallResult* pIResult = NULL;

	result = m_pIServices->ExecMethod( CBstr( wszObjectPath ), CBstr( wszMethod ), 0L, NULL, pIInstance, &pIOut, &pIResult );

	RELEASE ( pIInstance ) ;

	m_bProperties = TRUE;

	if (pIOut)
		DumpObject(pIOut, tabs + 2);
	else
		print(L"%sNo Out Params Object\n", gettabs(tabs +2));
	
	RELEASE(pIOut);
	RELEASE(pIResult)
	
	if ( FAILED ( result ) )
	{
		print(L"Failed to ExecMethod", result);
		return result;
	}

	print(L"%s ExecMethod Success", gettabs(tabs)) ;

	print(L"\n End ExecMethod -----------------------------------------\n");

	return result;
}


SCODE CApp::DeleteInstance(LPWSTR wcsScriptLine)
{
	SCODE				result = NO_ERROR;
	WCHAR				wcsInstance[8000];

	LONG				tabs = 1;
	
	print(L"\n Start DeleteInstance -----------------------------------------");

	GetInstancePath(wcsScriptLine, wcsInstance);

	print(L"Instance Path = %s", wcsInstance);

	if(!m_pIServices)
	{
		print(L"ERROR cannot -- not connected");
		return result;
	}

	if (FAILED ( result = m_pIServices->DeleteInstance( CBstr( wcsInstance ), 0L, NULL, NULL ) ))		
	{
		print(L"Failed to DeleteInstance", result);
		return result;
	}	
	

	print(L"%s%s", gettabs(tabs), L"DeleteInstance Success");

	print(L"\n End DeleteInstance -----------------------------------------\n");

	return 0;
}

SCODE CApp::PutInstance(LPWSTR wcsScriptLine)
{
	LPWSTR				p;
	SCODE				result = NO_ERROR;
	WCHAR				wcsClassName[8000];
	LONG				tabs = 1;
	IWbemClassObject*	pIInstance = NULL;
	IWbemClassObject*	pIClass = NULL;
	WCHAR				wszProperty[8000];
	
	print(L"\n Start PutInstance -----------------------------------------" );

	p = GetBetweenQuotes(wcsScriptLine, wcsClassName);

	print(L"%sClass Name = %s", gettabs(2), wcsClassName);

	if(!m_pIServices)
	{
		print(L"ERROR cannot -- not connected");
		return result;
	}

	if (FAILED ( result = m_pIServices->GetObject( CBstr ( wcsClassName ), 0L, NULL, &pIClass, NULL ) ))		
	{
		print(L"Failed to GetObject", result);
		return result;
	}	
	
	if (FAILED ( result = pIClass->SpawnInstance(0L, &pIInstance) ))
	{
		print(L"Failed to SpawnInstance", result);
		return result;
	}

	RELEASE(pIClass);

	CVariant cvarValue;

	while ( GetPropertyAndValue( wszProperty, cvarValue, &p) )
	{
		
		if (FAILED ( result = pIInstance->Put( CBstr ( wszProperty ) , 0L, cvarValue, NULL ) ))
		{
			print(L"Failed to Put On Instance", result);
			return result;
		}		
	}

	IWbemCallResult* pIResult = NULL;
	if (FAILED ( result = m_pIServices->PutInstance( pIInstance, WBEM_FLAG_CREATE_ONLY, NULL, &pIResult) ))
	{
		print(L"Failed to PutInstance", result);
		return result;
	}		
	else
	{
		print( L"%sPutInstance() Success.", gettabs( 2 ) );
	}

	RELEASE(pIInstance);

	print(L"\n End PutInstance -----------------------------------------" );

	return result;
 
}


SCODE CApp::DeleteClass(LPWSTR wcsScriptLine)
{
	SCODE				result = NO_ERROR;
	WCHAR				wcsClass[8000];
	LONG				tabs = 1;
	
	print(L"\n Start DeleteClass -----------------------------------------" );

	GetBetweenQuotes(wcsScriptLine, wcsClass);

	print(L"Class Name = %s", wcsClass);

	if(!m_pIServices)
	{
		print(L"ERROR cannot -- not connected");
		return result;
	}

	if (FAILED ( result = m_pIServices->DeleteClass( CBstr( wcsClass ), 0L, NULL, NULL ) ))		
	{
		print(L"Failed to DeleteClass", result);
		return result;
	}		

	print(L"%s%s", gettabs(tabs), L"DeleteClass Success");

	print(L"\n End DeleteClass -----------------------------------------\n");

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\cimclass.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/

#include "dmipch.h"			// precompiled header for dmi provider

#include "WbemDmiP.h"		// project wide include

#include "Strings.h"

#include "CimClass.h"

#include "DmiData.h"

#include "WbemLoopBack.h"

#include "Trace.h"

#include "Exception.h"


#define QUAL_FLAGS 	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE \
						| WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

#define NON_INHERIT_QUAL_FLAGS 	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE 
						

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CCimObject::CCimObject()
{
	m_pCimObject = NULL;
	m_pIUnk = NULL;
	m_pIDispatch = NULL;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CCimObject::~CCimObject()
{
	RELEASE ( m_pIUnk );
	RELEASE ( m_pIDispatch );
	
	Release ();

};

void CCimObject::Release ()
{
	
	if ( m_pCimObject) 
	{
		LONG l;
		
		l = m_pCimObject->Release ();

		m_pCimObject = NULL;

		//STAT_TRACE ( L"CIM Object %lx Release %lu" , this , l );
	}
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::AddProperty(LPWSTR wszName, CVariant& varVal, LONG lAccess )
{
	//DEV_TRACE (  L"\t\tCCimClassWrap::AddProperty(%lX, %s)", m_pCimObject, 
	//	wszName );

//	STAT_TRACE(L"[%s],[%s]" , wszName , varVal.GetValue () ) ;
	SCODE result = m_pCimObject->Put( wszName, NO_FLAGS , varVal, 
		EMPTY_VARIANT );	

	if (FAILED(result))
	{
		throw CException ( WBEM_E_FAILED, IDS_ADDPROP_FAIL , NO_STRING , 
			wszName );
	}

	CVariant var( ( VARIANT_BOOL ) VARIANT_TRUE);

	if ( lAccess == READ_ONLY || lAccess == READ_WRITE )
		AddPropertyQualifier( wszName, READ_QUALIFIER, var );

	if ( lAccess == WRITE_ONLY || lAccess == READ_WRITE )
		AddPropertyQualifier( wszName, WRITE_QUALIFIER, var);

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::AddProperty(LPWSTR wszName, VARTYPE vt, LONG lAccess )
{
	CVariant		var;
	var.Null();

	//DEV_TRACE ( L"\t\tCCimClassWrap::AddProperty(%lX, %s)", m_pCimObject, 
	//	wszName ) ;

	SCODE result = m_pCimObject->Put( wszName, NO_FLAGS , var, vt);	

	if (FAILED(result))
	{
		throw CException ( WBEM_E_FAILED, IDS_ADDPROP_FAIL , NO_STRING , 
			wszName );
	}

	var.Set( ( VARIANT_BOOL ) VARIANT_TRUE);
	
	if ( lAccess == READ_ONLY || lAccess == READ_WRITE )
		AddPropertyQualifier( wszName, READ_QUALIFIER, var );

	if( lAccess == WRITE_ONLY || lAccess == READ_WRITE )
		AddPropertyQualifier( wszName, WRITE_QUALIFIER, var);

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::AddPropertyQualifier( LPWSTR wszName, LPWSTR wszQualifier,
									  CVariant& cvValue)
{
	SCODE				result = NO_ERROR;
	IWbemQualifierSet	*pIQS = NULL;
	
//	STAT_TRACE(L"[%s],[%s],[%s]" , wszName , wszQualifier , cvValue.GetValue () ) ;

	if( FAILED ( result = m_pCimObject->GetPropertyQualifierSet( wszName, 
		&pIQS ) ) )
	{
		CString cszT;

		cszT.LoadString ( IDS_TO );
		
		cszT.Prepend ( wszQualifier );
		cszT.Append ( wszName ) ;

		throw CException ( WBEM_E_FAILED, IDS_ADDPROPQUAL_FAIL , NO_STRING ,
			cszT );
	}
	
	result = pIQS->Put( wszQualifier, cvValue, QUAL_FLAGS );
		
	RELEASE(pIQS);

	if( FAILED(result) )
	{
		CString cszT;

		cszT.LoadString ( IDS_TO );

		cszT.Prepend ( wszQualifier );

		cszT.Append ( wszName ) ;

		throw CException ( WBEM_E_FAILED, IDS_ADDPROPQUAL_FAIL , NO_STRING ,
			cszT );
	}

	//DEV_TRACE ( L"\t\tCCimClassWrap::AddPropertyQualifier()" );
	//DEV_TRACE ( L"\t\t\tprop name = %s" , wszName);
	//DEV_TRACE ( L"\t\t\tqual name = %s" , wszQualifier);
	//DEV_TRACE ( L"\t\t\tpIClass = %lX" , m_pCimObject);

}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::AddClassQualifier(LPWSTR wszQualifier, CVariant& cvValue )
{
	SCODE				result = NO_ERROR;
	IWbemQualifierSet	*pIQS = NULL;
	CVariant			var;
	
	if ( FAILED ( result = m_pCimObject->GetQualifierSet( &pIQS ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDCLASSQUAL , NO_STRING ,
			wszQualifier );
	}

	result = pIQS->Put( wszQualifier, cvValue, QUAL_FLAGS );

	RELEASE(pIQS);

	if ( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDCLASSQUAL , NO_STRING ,
			wszQualifier );
	}

/*	DEV_TRACE ( L"\t\tCCimClassWrap::AddClassQualifier()\n\tqual name \
= %s\n\tpIClass = %lX", wszQualifier, m_pCimObject ) ;
*/
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::AddNonInheritClassQualifier(LPWSTR wszQualifier, CVariant& cvValue )
{
	SCODE				result = NO_ERROR;
	IWbemQualifierSet	*pIQS = NULL;
	CVariant			var;
	
	if ( FAILED ( result = m_pCimObject->GetQualifierSet( &pIQS ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDCLASSQUAL , NO_STRING ,
			wszQualifier );
	}

	result = pIQS->Put( wszQualifier, cvValue, NON_INHERIT_QUAL_FLAGS );

	RELEASE(pIQS);

	if ( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDCLASSQUAL , NO_STRING ,
			wszQualifier );
	}

/*	DEV_TRACE ( L"\t\tCCimClassWrap::AddClassQualifier()\n\tqual name \
= %s\n\tpIClass = %lX", wszQualifier, m_pCimObject ) ;
*/
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::AddMethod( 
						   
	CWbemLoopBack*pWbem, 
	IWbemContext *pCtx , 
	LPWSTR wszMethodName, 
	LPWSTR wszInParamsClassName,
	CCimObject &ccimParamsClass
)
{
	SCODE				result = WBEM_NO_ERROR;
	IWbemQualifierSet *iwqQualifierSet = NULL ;
	CVariant			cvValue;
	CBstr				cbName;

	cbName.Set ( wszMethodName );
	cvValue.Set ( VARIANT_TRUE );

	if ( FAILED ( result =  m_pCimObject->Put( cbName ,  NO_FLAGS , 
		cvValue , NULL ) ))
	{

		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	CBstr t_PropertyName = NULL ;
	CIMTYPE t_Type = 0 ;
	long t_Flavor = 0 ;
	CVariant t_Variant ;
 
	result = m_pCimObject->PutMethod ( wszMethodName , 0 , 
							(IWbemClassObject*) ccimParamsClass, NULL ) ;
	if ( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	result = m_pCimObject->GetMethodQualifierSet ( wszMethodName ,
							 &iwqQualifierSet ) ;
	if ( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	t_Variant.Set ( VARIANT_TRUE ) ;
	result = iwqQualifierSet->Put ( L"Implemented" , t_Variant , 0 ) ;
	if ( FAILED ( result ) )
	{
		RELEASE(iwqQualifierSet);
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	t_Variant.Set ( VARIANT_TRUE ) ;
	result = iwqQualifierSet->Put ( L"Static" , t_Variant , 0 ) ;
	if ( FAILED ( result ) )
	{
		RELEASE(iwqQualifierSet);
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	cbName.Set ( INPARAMS_QUALIFIER );
	cvValue.Set ( wszInParamsClassName );

	if(FAILED( iwqQualifierSet->Put( cbName , cvValue , QUAL_FLAGS )))
	{
		RELEASE(iwqQualifierSet);
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	cbName.Set ( OUTPARAMS_QUALIFIER );
	cvValue.Set ( NONE_STR );

	result = iwqQualifierSet->Put( cbName , cvValue , QUAL_FLAGS);
	
	RELEASE(iwqQualifierSet);

	if( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING ,
			wszMethodName );		
	}

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::AddInOutMethod( 
						   
	CWbemLoopBack*pWbem, 
	IWbemContext *pCtx , 
	LPWSTR wszMethodName, 
	LPWSTR wszInParamsClassName,
	CCimObject &ccimInParamsClass,
	LPWSTR wszOutParamsClassName,
	CCimObject &ccimOutParamsClass
)
{
	SCODE				result = WBEM_NO_ERROR;
	IWbemQualifierSet *iwqQualifierSet = NULL ;
	CVariant			cvValue;
	CBstr				cbName;

	cbName.Set ( wszMethodName );
	cvValue.Set ( VARIANT_TRUE );

	if ( FAILED ( result =  m_pCimObject->Put( cbName ,  NO_FLAGS , 
		cvValue , NULL ) ))
	{

		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	CBstr t_PropertyName = NULL ;
	CIMTYPE t_Type = 0 ;
	long t_Flavor = 0 ;
	CVariant t_Variant ;

	result = m_pCimObject->PutMethod ( wszMethodName , 0 , 
							(IWbemClassObject*) ccimInParamsClass  , (IWbemClassObject*) ccimOutParamsClass ) ;
	if ( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	result = m_pCimObject->GetMethodQualifierSet ( wszMethodName ,
							 &iwqQualifierSet ) ;
	if ( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	t_Variant.Set ( VARIANT_TRUE ) ;
	result = iwqQualifierSet->Put ( L"Implemented" , t_Variant , 0 ) ;
	if ( FAILED ( result ) )
	{
		RELEASE(iwqQualifierSet);
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	t_Variant.Set ( VARIANT_TRUE ) ;
	result = iwqQualifierSet->Put ( L"Static" , t_Variant , 0 ) ;
	if ( FAILED ( result ) )
	{
		RELEASE(iwqQualifierSet);
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}
#if 0
	cbName.Set ( CIMTYPE_QUALIFIER );
	cvValue.Set ( METHOD_QUAL_VAL );

	if(FAILED( iwqQualifierSet->Put( cbName , cvValue , QUAL_FLAGS )))
	{
		RELEASE(iwqQualifierSet);
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );
	}
#endif 0

	cbName.Set ( INPARAMS_QUALIFIER );
	cvValue.Set ( wszInParamsClassName );

	if(FAILED( iwqQualifierSet->Put( cbName , cvValue , QUAL_FLAGS )))
	{
		RELEASE(iwqQualifierSet);
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	cbName.Set ( OUTPARAMS_QUALIFIER );
	cvValue.Set ( wszOutParamsClassName );

	if(FAILED( iwqQualifierSet->Put( cbName , cvValue , QUAL_FLAGS )))
	{
		RELEASE(iwqQualifierSet);
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING , 
			wszMethodName );		
	}

	RELEASE(iwqQualifierSet);

	if( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_ADDMETHOD_FAIL , NO_STRING ,
			wszMethodName );		
	}

}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::Set(IWbemClassObject* pI)
{
	m_pCimObject = pI;
	m_pCimObject->AddRef();
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::GetProperty( LPWSTR  wszName, CVariant& cvValue)
{
	SCODE	result = WBEM_NO_ERROR ;

	if ( FAILED ( result = m_pCimObject->Get( wszName, NO_FLAGS , cvValue, 
		NULL, NULL) ))
	{

		throw CException ( WBEM_E_FAILED , IDS_GETPROP_FAIL , NO_STRING , 
			CString ( result ) );		
	}

	/* MOT_TRACE ( L"\tMOT... Read CIM Object property %s = %s)" ,
		wszName , cvValue.GetBstr() ) ;
		*/

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::GetPropertyQualifer( BSTR bstrPropertyName, 
									 BSTR bstrQualifierName, CVariant& cvValue)
{
	IWbemQualifierSet*	pIQs= NULL;
	SCODE				result = WBEM_NO_ERROR;

	if ( SUCCEEDED ( result = m_pCimObject->GetPropertyQualifierSet( 
		bstrPropertyName, &pIQs) ))
	{
		result = pIQs->Get( bstrQualifierName, NO_FLAGS , cvValue, NULL);
	}

	RELEASE(pIQs);

	if ( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_GETPROPQUAL_FAIL , NO_STRING ,
			bstrPropertyName );
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::PutPropertyValue(LPWSTR  wszName, CVariant& cvValue)
{	
	SCODE	result = WBEM_NO_ERROR;

	CBstr cbName;

	cbName.Set ( wszName );

	if ( FAILED ( result = m_pCimObject->Put( cbName, NO_FLAGS , cvValue, 
		NULL) ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_PUTPROPVAL_FAIL , NO_STRING , 
			wszName );		
	}

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::Create(CWbemLoopBack* pWbem, CVariant& varName, 
						IWbemContext* pICtx )
{
	STAT_TRACE ( L"\t\tCreating CIM class %s", varName.GetBstr() );

	SCODE	result = WBEM_NO_ERROR;

	Release();

	pWbem->CreateNewClass(&m_pCimObject, pICtx );
	
	if ( FAILED ( result = m_pCimObject->Put( CLASS_NAME, NO_FLAGS , varName, 
		NULL) ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_CREATECLASS_FAIL , NO_STRING ,
			varName.GetBstr() );		
	}	

	CVariant cvValue;
	
	cvValue.Set ( ( VARIANT_BOOL ) VARIANT_TRUE);

	AddClassQualifier( DYNAMIC_QUALIFIER, cvValue );

	cvValue.Set ( PROVIDER_NAME );
	
	AddClassQualifier( PROVIDER_QUALIFIER, cvValue );

	//STAT_TRACE ( L"CIM Object %lx created create 2" , this );
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::CreateAbstract(CWbemLoopBack* pWbem, CVariant& varName, 
						IWbemContext* pICtx )
{
	STAT_TRACE ( L"\t\tCreating CIM class %s", varName.GetBstr() );

	SCODE	result = WBEM_NO_ERROR;

	Release();

	pWbem->CreateNewClass(&m_pCimObject, pICtx );
	
	if ( FAILED ( result = m_pCimObject->Put( CLASS_NAME, NO_FLAGS , varName, 
		NULL) ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_CREATECLASS_FAIL , NO_STRING ,
			varName.GetBstr() );		
	}	

	CVariant cvValue;
	
	cvValue.Set ( ( VARIANT_BOOL ) VARIANT_TRUE);

	AddNonInheritClassQualifier( ABSTRACT_QUALIFIER, cvValue );

	//STAT_TRACE ( L"CIM Object %lx created create 2" , this );
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::Create(CWbemLoopBack* pWbem, LPWSTR wszSuperClass, 
						CVariant& varName, IWbemContext* pICtx )
{
	STAT_TRACE ( L"\t\tCreating CIM class %s derived from %s", varName.GetBstr() ,
		wszSuperClass);

	SCODE result = WBEM_NO_ERROR;

	Release();

	pWbem->CreateNewDerivedClass( &m_pCimObject, wszSuperClass, pICtx );
	
	if ( FAILED ( result = m_pCimObject->Put( CLASS_NAME, NO_FLAGS , varName,
		NULL) ))
	{
		CString cszT;

		cszT.LoadString ( IDS_DERIVED_FROM );

		cszT.Prepend ( varName.GetBstr() ) ;
		
		cszT.Append ( wszSuperClass );

		throw CException ( WBEM_E_FAILED , IDS_CREATEDCLASS_FAIL , NO_STRING ,
			cszT );
	}	

	CVariant cvValue;
	
	cvValue.Set ( ( VARIANT_BOOL ) VARIANT_TRUE);

	AddClassQualifier( DYNAMIC_QUALIFIER, cvValue );

	cvValue.Set ( PROVIDER_NAME );
	
	AddClassQualifier( PROVIDER_QUALIFIER, cvValue );

	//STAT_TRACE ( L"CIM Object %lx created create 1" , this  );
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::Spawn( CCimObject& Class )
{

	SCODE result = WBEM_NO_ERROR;

	RELEASE ( m_pCimObject ) ;

	if ( FAILED ( result = ( (IWbemClassObject*) Class)->
		SpawnInstance( 0L, &m_pCimObject) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_SPAWN_FAIL , NO_STRING , 
			CString ( result ) );	
	}
	
	//STAT_TRACE ( L"CIM Instance %lX spawned from %lX " , (LPWSTR)this , &Class );
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CCimObject::GetNames ( CBstr& cbQualifier , LONG lFlags , 
						   SAFEARRAY** ppsa )
{

	SCODE result = WBEM_NO_ERROR;

	if (FAILED (result = m_pCimObject->GetNames( cbQualifier, lFlags, NULL, 
		ppsa ) ) )
	{
		throw CException ( result ,IDS_GETNAMES_FAIL , NO_STRING , 
			CString ( result ) );
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\cimclass.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/




#if !defined(__CIMCLASS_H__)
#define __CIMCLASS_H__

class CWbemLoopBack;


class CCimObject
{
private:
	IWbemClassObject*	m_pCimObject;
	IDispatch*			m_pIDispatch;
	IUnknown*			m_pIUnk;

public:
				CCimObject();
				~CCimObject();
	BOOL		IsEmpty()						{ return ( m_pCimObject == NULL ) ? TRUE : FALSE;}
	void		Release();				

	void		AddProperty( LPWSTR, CVariant&, LONG );
	void		AddProperty(LPWSTR, VARTYPE, LONG );
	void		AddPropertyQualifier( LPWSTR, LPWSTR, CVariant&);
	void		AddClassQualifier( LPWSTR, CVariant&);
	void		AddNonInheritClassQualifier( LPWSTR, CVariant&);
	void		AddMethod( CWbemLoopBack*, IWbemContext *pCtx , LPWSTR, LPWSTR, CCimObject&);
	void		AddInOutMethod( CWbemLoopBack*, IWbemContext *pCtx , LPWSTR, LPWSTR, CCimObject&,LPWSTR, CCimObject&);
	void		Set(IWbemClassObject*);
	void 		GetProperty( LPWSTR, CVariant&);
	void		GetPropertyQualifer( BSTR, BSTR, CVariant&);
	void		PutPropertyValue( LPWSTR , CVariant&);

	void		GetNames ( CBstr& cbQualifier , LONG lFlags , SAFEARRAY** ppsa );

	void		Create(CWbemLoopBack*, CVariant&, IWbemContext*);
	void		CreateAbstract(CWbemLoopBack*, CVariant&, IWbemContext*);
	void		Create(CWbemLoopBack*, LPWSTR, CVariant&, IWbemContext*);
	void		Spawn( CCimObject& );

	operator	IWbemClassObject**()						{return &m_pCimObject;}
	operator	IWbemClassObject*()							{return m_pCimObject;}

};

#endif // __CIMCLASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\classfac.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/











//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: CIMOM DMI Instance provider
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//
//***************************************************************************


#include "dmipch.h"					// precompiled header for dmi provider

#include "WbemDmiP.h"

#include "ClassFac.h"

#include "CimClass.h"

#include "DmiData.h"

#include "AsyncJob.h"		// must preeced ThreadMgr.h

#include "ThreadMgr.h"

#include "WbemLoopBack.h"

#include "Services.h"

#include "EventProvider.h"


//***************************************************************************
//
// CClassFactory::CClassFactory
// CClassFactory::~CClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CClassFactory::CClassFactory()
{
    m_cRef=0L;
    return;
}

CClassFactory::~CClassFactory(void)
{
    return;
}


//***************************************************************************
//
// CClassFactory::QueryInterface
// CClassFactory::AddRef
// CClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void** ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid )
	{
        *ppv=this;
	}

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
		
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
	return InterlockedIncrement ( & m_cRef );

}


STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
	if ( 0L != InterlockedDecrement ( & m_cRef ) )
        return m_cRef;

    delete this;

    return 0L;
}

//***************************************************************************
//
// CClassFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          void** in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, 
										   void** ppvObj)
{
    HRESULT			hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.
    if( NULL != pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

	//Create the object passing function to notify on destruction.
    CServices * pServices = new CServices;

    if( NULL == pServices)
		return ResultFromScode(E_OUTOFMEMORY);

    hr = pServices->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if( SUCCEEDED(hr))
	{
		return hr;
	}

	MYDELETE ( pServices );

	return hr;        
}

//***************************************************************************
//
// CClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{	
	if (fLock)
	{
        InterlockedIncrement(&_gcLock);
	}
    else
	{
		InterlockedDecrement(&_gcLock);	
	}

    return NOERROR;
}




//***************************************************************************
//
// CEventClassFactory::CEventClassFactory
// CEventClassFactory::~CEventClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CEventClassFactory::CEventClassFactory()
{
    m_cRef=0L;
    return;
}

CEventClassFactory::~CEventClassFactory(void)
{
    return;
}


//***************************************************************************
//
// CEventClassFactory::QueryInterface
// CEventClassFactory::AddRef
// CEventClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CEventClassFactory::QueryInterface(REFIID riid, void** ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid )
	{
        *ppv=this;
	}

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
		
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CEventClassFactory::AddRef(void)
{
	return InterlockedIncrement ( & m_cRef );
}


STDMETHODIMP_(ULONG) CEventClassFactory::Release(void)
{	
	if ( 0L != InterlockedDecrement ( & m_cRef ) )
        return m_cRef;

    delete this;

    return 0L;
}

//***************************************************************************
//
// CEventClassFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          void** in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CEventClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, 
												REFIID riid, void** ppvObj)
{
    HRESULT			hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.
    if( NULL != pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

	//Create the object passing function to notify on destruction.
    IWbemEventProvider* pEventProvider = new CEventProvider();

    if( NULL == pEventProvider)
		return ResultFromScode(E_OUTOFMEMORY);

    hr = pEventProvider->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if( SUCCEEDED(hr))
		return hr;

	MYDELETE ( pEventProvider );

	return hr;        
}

//***************************************************************************
//
// CEventClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CEventClassFactory::LockServer(BOOL fLock)
{	
	if (fLock)
	{
        InterlockedIncrement(&_gcEventLock);
	}
    else
	{
        InterlockedDecrement(&_gcEventLock);
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\classfac.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__CLASSFAC_H__)
#define __CLASSFAC_H__

class CClassFactory : public IClassFactory
{
protected:
    LONG           m_cRef;

public:
    CClassFactory(void);
    ~CClassFactory(void);

    //IUnknown Methods
    STDMETHODIMP         QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory Methods
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void**);
    STDMETHODIMP         LockServer(BOOL);
};

typedef CClassFactory *PCClassFactory;

class CEventClassFactory : public IClassFactory
{
protected:
    LONG           m_cRef;

public:
    CEventClassFactory(void);
    ~CEventClassFactory(void);

    //IUnknown Methods
    STDMETHODIMP         QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory Methods
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void**);
    STDMETHODIMP         LockServer(BOOL);
};

#endif // __CLASSFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmiinterfaceerror.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\datatypes.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/





#include "dmipch.h"			// precompiled header for dmip
#include "WbemDmiP.h"		// project wide include
#include "Strings.h"
#include "Exception.h"

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CBstr::Set(LPWSTR olestr)
{
	ASSERT( olestr );	// Assert if NULL pointer
	if(m_bstr)
		FREE ( m_bstr );
	

	m_bstr = SYSALLOC( olestr );
}


long CBstr::GetComponentIdFromGroupPath ()
{
	LPWSTR p = NULL;

	if ( m_bstr == NULL )
		return 0;

	p = m_bstr;

	while (*p)
		p++;

	p--;

	while (*p )
	{
		if ( *p == PIPE_CODE )
		{
			*p-- = 0;

			break;
		}

		p--;
	}


	while ( *p )
	{
		if ( *p == PIPE_CODE )
		{
			long l;

			*p++ = 0;

			swscanf ( p , L"%u" , & l );

			return l;			

		}		

		p--;
	}

	

	return 0;	

}

long CBstr::GetLastIdFromPath(  )
{
	LPWSTR p = NULL;

	if ( m_bstr == NULL )
		return 0;

	p = m_bstr;

	while (*p)
		p++;

	p--;

	while (*p )
	{
		if ( *p == PIPE_CODE )
		{
			*p-- = 0;

			while ( *p )
			{
				if ( *p == PIPE_CODE )
				{
					LONG l = 0;

					*p++ = 0;

					swscanf ( p , L"%u" , & l );

					return l;
				}
				p--;
			}
		}		

		p--;
	}	

	return 0;	
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CVariant::CVariant(LPWSTR str)
{
	ASSERT( str );	// Assert if NULL pointer
	CVariant();
	Set(str);
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
#if 0
BSTR CVariant :: GetValue () 
{
	BSTR t_BStr = NULL ;

	if ( m_var.vt == VT_BSTR )
	{
		t_BStr = SysAllocString ( GetBstr () ) ;
	}
	else if ( m_var.vt == VT_BOOL )
	{
		t_BStr = SysAllocString ( Bool () ? L"TRUE" : L"FALSE" ) ;
	}
	else if ( m_var.vt == VT_I4 )
	{
		wchar_t t_Buffer [ 16 ] ;
		swprintf ( t_Buffer , L"%ld" , GetLong ( ) ) ;
		t_BStr = SysAllocString ( t_Buffer ) ;
	}
	else
	{
		t_BStr = SysAllocString ( L"" ) ;
	}

	return t_BStr ;
}
#endif

BOOL CVariant::Equal ( CVariant& cv2 )
{
	if ( m_var.vt == VT_BSTR )
	{
		if ( !m_var.bstrVal )
		{
			if (!cv2.GetBstr() )
				return TRUE;
			else
				return FALSE;
		}

		if ( MATCH == wcscmp ( m_var.bstrVal , cv2.GetBstr ( ) ) )
			return TRUE;
	}

	if ( m_var.vt == VT_I4 )
	{
		if ( GetLong ( ) == cv2.GetLong ( ) )
			return TRUE;
	}

	return FALSE;
	
}


void CVariant::Set(LPWSTR str)
{

	if( !IsEmpty() )
		Clear();

	m_var.vt = VT_BSTR;

	m_var.bstrVal = SYSALLOC(str);
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CVariant::Set(ULONG ul)
{
	Clear();
	m_var.vt = VT_I4;
	m_var.lVal = ul;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CVariant::Set( IDispatch* p)
{
	ASSERT( p );	// Assert if NULL pointer	
	
	// addref because the VariantClear will release
	p->AddRef ();

	Clear();
	m_var.vt = VT_DISPATCH;
	m_var.pdispVal = p;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CVariant::Set( CSafeArray * p)
{
	ASSERT( p );	// Assert if NULL pointer	
	Clear();
	m_var.vt = p->GetType () | VT_ARRAY ;

	SAFEARRAY *t_Copy ;
	SafeArrayCopy ( *p , & t_Copy ) ;
	m_var.parray = t_Copy ;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CVariant::Set( IUnknown* p)
{
	ASSERT( p );	// Assert if NULL pointer	
	// addref because the VariantClear will release
	p->AddRef ();

	Clear();
	m_var.vt = VT_UNKNOWN;
	m_var.punkVal = p;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CVariant::Set(LONG l)
{
	Clear();
	m_var.vt = VT_I4;
	m_var.lVal = l;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CVariant::Set(LPVARIANT pv)
{
	ASSERT( pv );	// Assert if NULL pointer
	Clear();
	VariantCopy(&m_var, pv);
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CVariant::Set( VARIANT_BOOL b)
{
	Clear();
	m_var.vt = VT_BOOL;
	m_var.boolVal = b;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CVariant::Bool()
{
	if (m_var.boolVal == 0) 
		return TRUE;
	else
		return FALSE;
}	

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BSTR CVariant::GetBstr()
{
	if(m_var.vt == VT_BSTR)
		return m_var.bstrVal;
	else
		return NULL;	
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
LONG CVariant::GetLong()
{
	if(m_var.vt == VT_I4)
		return m_var.lVal;
	else
		return WBEM_NO_ERROR;	
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CString::Set(LPWSTR pString)
{

	
	LONG lLen = 0;

	if ( m_pString )
	{
		ARRAYDELETE(m_pString);
	}

	if(pString == NULL)
	{
		m_pString = NULL;
		return;
	}
	lLen = wcslen(pString);
	m_pString = new WCHAR[lLen + 1];
	wcsncpy( m_pString, pString, lLen + 1);

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
// case insensitive case compare
BOOL CString::Equals ( LPWSTR pTestString )
{
	ASSERT( pTestString );	// Assert if NULL pointer	
	if ( MATCH == wcsicmp ( m_pString , pTestString ) )
		return TRUE;

	return FALSE;

}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
// case insensitive string compare
BOOL CString::Contains ( LPWSTR pTestString )
{
	ASSERT( pTestString );	// Assert if NULL pointer	
	
	CString cszT;

	cszT.Set ( m_pString );


	cszT.TruncateAtFirst ( COMMA_CODE );
	
	LPWSTR	pBuff = NULL;

	
	// todo figure out debug error when using new
	
	/*
	USHORT	nLen1 = wcslen ( m_pString ) + 1 ;
	USHORT	nLen2 = wcslen ( pTestString ) + 1;

	WCHAR* pBuff1 = new WCHAR ( nLen1 );
	LPWSTR pBuff2 = new WCHAR ( nLen2);
	
	*/
	WCHAR	szBuff1[256];
	WCHAR	szBuff2[256];

	LPWSTR pBuff1 = szBuff1;
	LPWSTR pBuff2 = szBuff2;

	LPWSTR pSrc = cszT;
	LPWSTR pDest = pBuff1;

	LONG lLen = wcslen(pSrc);
	wcsncpy( pDest, pSrc, lLen + 1);

	pSrc = pTestString;
	pDest = pBuff2;

	lLen = wcslen(pSrc);
	wcsncpy( pDest, pSrc, lLen + 1);
	

	wcslwr ( pBuff1 );
	wcslwr ( pBuff2 );

	BOOL	bRet = FALSE;

	if ( wcsstr ( pBuff1 , pBuff2 ) )
		bRet = TRUE;

	return bRet;

}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CString::Alloc ( long nAlloc )
{
	
	ARRAYDELETE(m_pString);

	m_pString = new WCHAR[ nAlloc];

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CString::Set(long lVal)
{
	WCHAR sz[256];

	swprintf(sz, ULONG_FORMAT_STR, lVal);

	Set(sz);
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
LPWSTR CString::Prepend(LPWSTR pPrepend)
{
	ASSERT( pPrepend );	// Assert if NULL pointer
	
	LPWSTR	p = pPrepend, q, pNew;
	LONG	lCount = 0 ;	

	while(*p++)
		lCount++;

	p = m_pString;

	while(*p++)
		lCount++;

	pNew = new WCHAR[lCount + 1];

	p = pPrepend;
	q = pNew;

	while(*p)				// insert prepend string
		*q++ = *p++;

	p = m_pString;

	while(*p)				// append old string
		*q++ = *p++;

	*q = NULL;

	ARRAYDELETE(m_pString);
	m_pString = pNew;

	return m_pString;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
LPWSTR CString::Append(LPWSTR pAppend)
{
	
	ASSERT( pAppend );	// Assert if NULL pointer	
	LPWSTR	p = pAppend, q, pNew;
	LONG	lCount = 0 ;	

	while(*p++)
		lCount++;

	p = m_pString;

	while(*p++)
		lCount++;

	pNew = new WCHAR[lCount + 1];

	p = m_pString;
	q = pNew;

	while(*p)				// insert old string
		*q++ = *p++;

	p = pAppend;

	while(*p)				// append old string
		*q++ = *p++;

	*q = NULL;

	ARRAYDELETE(m_pString);

	m_pString = pNew;

	return m_pString;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
LPWSTR CString::Append(long lVal)
{
	WCHAR szT[256];

	swprintf(szT, ULONG_FORMAT_STR, lVal);

	return Append(szT);
}



/***************************************************************************
 * NAME:
 *   _WideCharToString
 *
 * ABSTRACT:
 *   Converts a Wide char string to a single char string
 *
 * SCOPE:
 *   Public
 *
 * SIDE EFFECTS:
 *   None.
 *   
 * ASSUMPTIONS:
 *   The caller needs to free up the memory allocated for the string.
 *
 * RETURN VALUE(S):
 *   Returns the string in multi byte form. If the function fails, it returns
 *   a NULL pointer.
 ****************************************************************************/
LPSTR CString::WideCharToString( 
	LPWSTR lpWideChar)	// IN: Wide string to be converted
{
	ASSERT( lpWideChar );	// Assert if NULL pointer
	if ( m_pMultiByteStr )
	{
		delete [] m_pMultiByteStr;
		m_pMultiByteStr = NULL;
	}
	if ( NULL != lpWideChar )
	{
	
		int iLenOfMultiByteStr = 0;
		BOOL bConverted = FALSE;		// TRUE means function failed to translate
		// See how much space is needed to hold the converted string
		iLenOfMultiByteStr = WideCharToMultiByte( 
								CP_ACP,	// Ansi code page
								0,				  // Don't use any mapping flags
								lpWideChar,		  // String to be converted
								-1,				  // Translate all chars
								m_pMultiByteStr,	  // Destination string
								0,				  // No buffer size.  Function will
								NULL,			  // the required size
								(LPBOOL)&bConverted); // Conversion status


		// Allocate a buffer to hold the converted string
		m_pMultiByteStr = new char[iLenOfMultiByteStr];
		iLenOfMultiByteStr = WideCharToMultiByte( 
								CP_ACP,	// Ansi code page
								0,				  // Don't use any mapping flags
								lpWideChar,		  // String to be converted
								-1,				  // Translate all chars
								m_pMultiByteStr,	  // Destination string
								iLenOfMultiByteStr,// Size of destination buffer
								NULL,			  // the required size
								(LPBOOL)&bConverted); // Conversion status

		if ( TRUE == bConverted )
		{
			m_pMultiByteStr = 0;	// function failed.	
		}
	} // EndIf NULL != lpWideChar

	return( m_pMultiByteStr );	// return the converted string
}	// CString::WideCharToString()


/***************************************************************************
 * NAME:
 *   StringToWideChar
 *
 * ABSTRACT:
 *   Converts a single char string to a wide char string
 *
 * SCOPE:
 *   Public
 *
 * SIDE EFFECTS:
 *   None.
 *   
 * ASSUMPTIONS:
 *
 * RETURN VALUE(S):
 *   Returns the string in wide char form. If function fails, it returns a NULL
 *	 pointer.
 *
 ****************************************************************************/
LPWSTR CString::StringToWideChar( 
	LPCSTR lpSourceStr )	// IN/OUT: Converted string to be returned
{
	
	ASSERT( lpSourceStr );	// Assert if NULL pointer	
	int iLenOfWideCharStr = 0;
	int iStatus = 0;	// A zero value means function failed to translate.

	if ( m_pString )
	{
		ARRAYDELETE(m_pString);
	}
	if ( NULL != lpSourceStr )
	{
		// See how much space is needed to hold the converted string
		iLenOfWideCharStr = MultiByteToWideChar( CP_ACP,	// Ansi code page
				0,						// Use default character mapping
				lpSourceStr,			// String to be converted
				-1,						// Translate all chars
				m_pString,				// Destination string
				0);						// No buffer size. Function will
										// return the required size

		// Allocate a buffer to hold the converted string
		m_pString = new WCHAR[iLenOfWideCharStr];
		iStatus = MultiByteToWideChar( CP_ACP,	// Ansi code page
				0,						// Use default character mapping
				lpSourceStr,			// String to be converted
				-1,						// Translate all chars
				m_pString,				// Destination string
				iLenOfWideCharStr);		// Size required for the converted string

		if ( 0 == iStatus )
		{
			m_pString = NULL;	// Function failed to translate	
		} 
	} // EndIf NULL != lpSourceStr

	return( m_pString );
	
}	// CString::StringToWideChar()





//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
long CString::GetAt(long lIndex)
{
	LPWSTR	p = m_pString;
	long	lCtr = 0;

	while ( lIndex != lCtr && *p++)
	{
		lCtr ++ ;
	}

	if( lIndex == lCtr )
		return *p;

	return 0L;
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CString::GetObjectPathFromMachinePath(LPWSTR pString)
{
	LPWSTR p = pString;
	LPWSTR pN = pString;
		
	while(*p != 58)		// go to colon character 
		p++;
	p++;

		while(*p != NULL)		// copy till End of string
		*pN++ = *p++;
	*pN = NULL;
	
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CString::TruncateAtFirst(short iChar)
{
	LPWSTR p = m_pString;

	while(*p)	
	{
		if ( *p == iChar)
		{
			*p = NULL;
			break;
		}

		p++;

	}

}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CString::TruncateAtLast(short iChar)
{
	LPWSTR p = m_pString;

	while (*p)
		p++;

	p--;

	while (*p != iChar )
		p--;

	*p = NULL;

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
long CString::GetLen ( )
{
	return wcslen ( m_pString );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CString::LoadString ( long nStringId )
{
	char	szBuffer [ BUFFER_SIZE ];
	WCHAR   szwBuffer[ BUFFER_SIZE ];

	if ( nStringId == NO_STRING )
	{
		Set ( EMPTY_STR );
		return;
	}

	// TODO figure out error handling. cant throw out of here
	// The UNICODE form of LoadString() is not supported on Win95.  We will
	// use the ASCII version of the function, passing a "char" buffer and
	// then later we will convert the buffer to "wchar" before calling
	// the SET function.

	if ( STRING_DOES_NOT_EXIST == ::LoadString( _ghModule , nStringId , 
		szBuffer , BUFFER_SIZE ) )
	{
		return;
	}
	mbstowcs( szwBuffer, szBuffer, BUFFER_SIZE );	
	Set ( szwBuffer );

}


//***************************************************************************
//
//	Func: RemoveNonAN
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CString::RemoveNonAN (  )
{
	LPWSTR p = m_pString;

	if ( !p )
		return;
	
	// If any chars in the name string are not valid C name chars change them 
	// to undescore.
	
	while(*p)
	{

		if ( 48 > *p  || 122 < *p)
			*p = 0x5F;					// change to underscore
			
		if ( 57 < *p && 65 > *p )		
			*p = 0x5F;					// change to underscore

		if ( 90 < *p && 97 > *p)
			*p = 0x5F;					// change to underscore

		p++;
	}
}

CSafeArray :: CSafeArray ( 
						  
	LONG size , 
	VARTYPE variantType 

) : m_lLower ( 0 ) , m_lUpper ( size - 1 ) , m_varType ( variantType )
{
	SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
	safeArrayBounds[0].lLbound = 0 ;
	safeArrayBounds[0].cElements = size ;

	m_pArray = SafeArrayCreate ( variantType , 1 , safeArrayBounds ) ;
}

CVariant CSafeArray::Get (LONG index)
{
	CVariant t_Variant ;

	switch ( m_varType )
	{
		case VT_BSTR:
		{
			BSTR t_Bstr = NULL ;
			if( FAILED (SafeArrayGetElement( m_pArray, &index, &t_Bstr ) )) 
				throw CException ( WBEM_E_FAILED , IDS_SAFEARRAY_FAIL, NO_STRING , 0);
			else
			{
				t_Variant.Set ( t_Bstr ) ;
			}
		}
		break ;

		case VT_I4:
		{
			LONG t_Long = NULL ;
			if( FAILED (SafeArrayGetElement( m_pArray, &index, &t_Long ) )) 
			{
				throw CException ( WBEM_E_FAILED , IDS_SAFEARRAY_FAIL, NO_STRING , 0);
			}
			else
			{
				t_Variant.Set ( t_Long ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	return t_Variant ;
}

void CSafeArray::Set (LONG index , CVariant &a_Variant )
{
	CVariant t_Variant ;

	switch ( m_varType )
	{
		case VT_BSTR:
		{
			switch ( a_Variant.GetType () )
			{
				case VT_BSTR:
				{
					BSTR t_Bstr = a_Variant.GetBstr () ;
					if( FAILED (SafeArrayPutElement( m_pArray, &index, t_Bstr ) )) 
					{
						throw CException ( WBEM_E_FAILED , IDS_SAFEARRAY_FAIL, NO_STRING , 0);
					}
				}
				break ;

				default:
				{
				}
				break ;
			}
		}
		break ;

		case VT_I4:
		{
			switch ( a_Variant.GetType () )
			{
				case VT_I4:
				{
					LONG t_Long = a_Variant.GetLong () ;
					if( FAILED (SafeArrayPutElement( m_pArray, &index, &t_Long ) )) 
					{
						throw CException ( WBEM_E_FAILED , IDS_SAFEARRAY_FAIL, NO_STRING , 0);
					}
				}
				break ;

				default:
				{
				}
				break ;
			}
			break;

			default:
			{
			}
			break ;
		}
		break ;
	}
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BSTR CSafeArray::Bstr(LONG index)
{
	if( FAILED (SafeArrayGetElement( m_pArray, &index, &m_bstr ) )) 
		return EMPTY_QUOUTES_STR L"\"\"";

	return m_bstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\datatypes.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__DATATYPES_H__)
#define __DATATYPES_H__

class CBstr
{
private:
	BSTR		m_bstr;

	// At this time we are not copying or assigning CBstr objects.
	// The copy constructor and assignment operators are placed here
	// to prevent that.
	CBstr(const CBstr&);
	CBstr& operator=(const CBstr&);
public:	
				CBstr()					{m_bstr = NULL;}
				CBstr(LPWSTR wstr)		{ m_bstr = SYSALLOC ( wstr );}

				~CBstr()				{Clear();}

				void		Clear()		{ FREE ( m_bstr );}
	void 		Set(LPWSTR olestr);

	operator	BSTR()					{return m_bstr;}
	operator	LPBSTR()				{return &m_bstr;}	

	long		GetLastIdFromPath(  );
	long		GetComponentIdFromGroupPath ( );

};

class CSafeArray;

class CVariant
{
private:

				
public:

		VARIANT		m_var;	

				CVariant()					{VariantInit(&m_var);}
				CVariant(LPWSTR str);
				CVariant(VARIANT_BOOL b)	{ VariantInit(&m_var); Set(b); }
				CVariant(LONG l)			{ VariantInit(&m_var); Set(l); }
				CVariant( LPVARIANT v)		{ VariantInit(&m_var); Set(v); }
				CVariant( IDispatch* p)		{ VariantInit(&m_var); Set(p); }
				CVariant( IUnknown* p)		{ VariantInit(&m_var); Set(p); }
				CVariant( CSafeArray* p)		{ VariantInit(&m_var); Set(p); }
				~CVariant()					{ VariantClear(&m_var);}

	void		Clear()						{VariantClear(&m_var);}
	void		Set( LPWSTR );
	void		Set( ULONG );
	void		Set( LONG );
	void		Set( LPVARIANT );
	void		Set( IDispatch* );
	void		Set( IUnknown* );
	void		Set( VARIANT_BOOL );
	void		Set( CSafeArray * );
	BOOL		IsEmpty()				{ return (m_var.vt == VT_EMPTY || m_var.vt == 99 ) ? TRUE : FALSE;}	
	void		Null()					{m_var.vt = VT_NULL;}
	

	BOOL		Bool();
	
	operator	LPVARIANT()				{return &m_var;}
	operator	VARIANT()				{return m_var;}
	operator	IDispatch*()			{return (IDispatch*) m_var.pdispVal; }
	LPUNKNOWN	GetDispId()				{return m_var.pdispVal;}
	
	LONG		GetLong();
	BSTR		GetBstr();
	LONG		GetType ()				{ return m_var.vt; }

	BOOL		Equal ( CVariant& );

//    BSTR GetValue () ;	
		
};


class CString
{
private:
	LPWSTR		m_pString;
	LPSTR		m_pMultiByteStr;

	// At this time we are not copying or assigning CString objects.
	// The copy constructor and assignment operators are placed here
	// to prevent that.
	CString(const CString&);
	CString& operator=(const CString&);
public:
		
				CString() { m_pString = NULL; m_pMultiByteStr = NULL; }
				~CString() 			{delete [] m_pString; m_pString = NULL;
									 delete [] m_pMultiByteStr; m_pMultiByteStr = NULL;}
				CString(LPWSTR p)	{ m_pString = NULL; m_pMultiByteStr = NULL; Set(p);}
				CString ( long l ) 	{ m_pString = NULL; m_pMultiByteStr = NULL; Set ( l ) ; }


	void		Set(LPWSTR);
	void		Set(long);	
	void		Alloc ( long );

	LPWSTR		Prepend(LPWSTR);
	LPWSTR		Append(LPWSTR);
	LPWSTR		Append(long);
	LPWSTR 		StringToWideChar( LPCSTR );
	LPSTR		WideCharToString( LPWSTR );	
	LPSTR		GetMultiByte() { return (WideCharToString( m_pString)); }
	LPWSTR		GetWideChar() { return (StringToWideChar( (LPCSTR)m_pMultiByteStr )); }	
	BOOL		Equals( LPWSTR );
	BOOL		Contains ( LPWSTR );
	
	BOOL		IsEmpty()				{ return ( m_pString == NULL) ?  TRUE : FALSE; }

	long		GetAt(long);
	
	void		TruncateAtFirst( short );
	void		TruncateAtLast ( short );

	void		LoadString ( LONG );

	long		GetLen ( );
	void		GetObjectPathFromMachinePath(LPWSTR);

	void		RemoveNonAN ( );

				operator	LPWSTR()				{return m_pString;}
				operator	BYTE*()					{return (BYTE*)m_pString;}
				operator	const char *()				{return (const char *)m_pString;}
};

class CSafeArray
{
private:
	VARTYPE		m_varType;
	SAFEARRAY*	m_pArray;
	BSTR		m_bstr;
	LONG		m_lLower;
	LONG		m_lUpper;
public:
				CSafeArray ( LONG size , VARTYPE variantType ) ; 
				CSafeArray()			{ m_pArray = NULL; m_lLower = m_lUpper = 0; }
				~CSafeArray()			{ SafeArrayDestroy( m_pArray ); }				

	VARTYPE		GetType ()			{ return m_varType ; }
	BOOL		BoundsOk()			{ if (FAILED ( SafeArrayGetLBound(m_pArray,1,&m_lLower)) || FAILED(SafeArrayGetUBound( m_pArray ,1,&m_lUpper)) ) return FALSE; else return TRUE;}
	LONG		Size()				{return m_lUpper - m_lLower + 1 ; }
	LONG		LBound()			{return m_lLower;}
	LONG		UBound()			{return m_lUpper;}
	CVariant	Get (LONG index) ;
	void		Set (LONG index , CVariant &a_Variant ) ;

	BSTR		Bstr(LONG index);

	operator	SAFEARRAY**()		{return &m_pArray;};
	operator	SAFEARRAY*()		{return m_pArray;};
};

#endif // __DATATYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmiactx_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Dec 01 17:04:01 1997
 */
/* Compiler settings for D:\test\mot\dmiengin\src\DmiActx.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_MOTDMIEngine = {0xF45FB440,0xC9DA,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IEventFilter = {0x6313BC6E,0xAEBF,0x11D0,{0xB8,0x65,0x00,0xA0,0xC9,0x24,0x79,0xE2}};


const IID IID_IDualEventFilter = {0x48EC0E24,0xAEC2,0x11d0,{0xB8,0x65,0x00,0xA0,0xC9,0x24,0x79,0xE2}};


const CLSID CLSID_DMIEventFilter = {0x6313BC6F,0xAEBF,0x11D0,{0xB8,0x65,0x00,0xA0,0xC9,0x24,0x79,0xE2}};


const IID DIID_IColLanguages = {0xA24E5B80,0x7AC3,0x11D0,{0x88,0x45,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualColLanguages = {0x13AE3E40,0x7B54,0x11d0,{0x88,0x45,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMILanguages = {0xA24E5B81,0x7AC3,0x11D0,{0x88,0x45,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IEnumeration = {0xF1DC8AE2,0x36FE,0x11D0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualEnumeration = {0x9EACD1E0,0x3703,0x11d0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIEnumeration = {0xF1DC8AE3,0x36FE,0x11D0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IColEnumerations = {0xF1DC8AE4,0x36FE,0x11D0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualColEnumerations = {0x2C7E6960,0x3714,0x11d0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIEnumerations = {0xF1DC8AE5,0x36FE,0x11D0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IAttribute = {0xF45FB448,0xC9DA,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualAttribute = {0x61DB0E60,0xCAAE,0x11cf,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIAttribute = {0xF45FB449,0xC9DA,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IColAttributes = {0x1A10B900,0xCDD7,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualColAttributes = {0xE2239A00,0xCE60,0x11cf,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIAttributes = {0x1A10B901,0xCDD7,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IRow = {0x3AB30761,0xE3B9,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualRow = {0x87DFD221,0xE3D7,0x11cf,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIRow = {0x3AB30762,0xE3B9,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IColRows = {0x7BF7A480,0xE3D5,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualColRows = {0x87DFD220,0xE3D7,0x11cf,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIRows = {0x7BF7A481,0xE3D5,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IGroup = {0xDA6FAB60,0xDF21,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualGroup = {0xB9C1FDE0,0xE152,0x11cf,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIGroup = {0xDA6FAB61,0xDF21,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IColGroups = {0xDA6FAB62,0xDF21,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualColGroups = {0xB9C1FDE1,0xE152,0x11cf,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIGroups = {0xDA6FAB63,0xDF21,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IComponent = {0x445360E0,0xDF26,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualComponent = {0xB9C1FDE2,0xE152,0x11cf,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIComponent = {0x445360E1,0xDF26,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IColComponents = {0x445360E2,0xDF26,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualColComponents = {0xB9C1FDE3,0xE152,0x11cf,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIComponents = {0x445360E3,0xDF26,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IMgmtNode = {0x165125A0,0xDFC2,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualMgmtNode = {0xDDAE04C0,0xE3C7,0x11cf,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIMgmtNode = {0x165125A1,0xDFC2,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_IColMgmtNodes = {0xF1DC8AE0,0x36FE,0x11D0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID_IDualColMgmtNodes = {0x2C7E6961,0x3714,0x11d0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIMgmtNodes = {0xF1DC8AE1,0x36FE,0x11D0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID_INotification = {0x5847E2F7,0xA2E4,0x11D0,{0xB8,0x4F,0x00,0xA0,0xC9,0x24,0x79,0xE2}};


const CLSID CLSID_DMINotification = {0x5847E2F8,0xA2E4,0x11D0,{0xB8,0x4F,0x00,0xA0,0xC9,0x24,0x79,0xE2}};


const IID DIID_IEvent = {0x20A41620,0x33EB,0x11D0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_DMIEvent = {0x20A41621,0x33EB,0x11D0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID__DDualint = {0xF45FB441,0xC9DA,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID IID__DualDMIEngine = {0x45D155A0,0x3CAD,0x11d0,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const IID DIID__DDualintEvents = {0xF45FB442,0xC9DA,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


const CLSID CLSID_MOTDmiEngine = {0xF45FB443,0xC9DA,0x11CF,{0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmidata.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__DMIDATA_H__)
#define __DMIDATA_H__

#include "Dual.h"

class CObjectPath;

///////////////////////////////////////////////////////////
class CEnumElement
{
	CString			m_cszString;
	LONG			m_lValue;

public:
					CEnumElement()			{ m_lValue = 0; m_pNext = NULL;}

	CEnumElement*	m_pNext;
	
	void			Read( IDualEnumeration* );

	CString&		GetString()				{return m_cszString;}
	LONG			GetValue()				{return m_lValue;}
};


class CEnum
{
	CString			m_cszNWA;
	LONG			m_lComponent;
	LONG			m_lGroup;
	LONG			m_lAttribute;

public:

	CEnumElement*	m_pFirst;
	CEnumElement*	m_pCurrent;

					CEnum()					{ m_pFirst = m_pCurrent = NULL;}
					~CEnum();

	void			Read ( IDualColEnumerations* );


	void			Add( CEnumElement* );
	void 			MoveToHead()			{m_pCurrent = m_pFirst;}
	LONG			GetCount();
	
	CEnumElement*		Next();

	void			SetNWA ( LPWSTR p )		{ m_cszNWA.Set ( p ); }
	void			SetComponent ( LONG l )	{ m_lComponent = l ; }
	void			SetGroup ( LONG l )		{ m_lGroup = l; }
	void			SetAttrib ( LONG l )		{ m_lAttribute = l ; }

	void			Get ( CString& , LONG , LONG , LONG );	

};

///////////////////////////////////////////////////////////
class CAttribute
{
private:

	VARIANT_BOOL	m_vbIsKey;
	VARIANT_BOOL	m_vbIsEnum;
	LONG			m_lId;
	CVariant		m_cvValue;
	LONG			m_lAccess;
	CBstr			m_cbDescription;
	CBstr			m_cbName;
	LONG			m_lType;
	LONG			m_lStorage;
	LONG			m_lMaxSize;

public:
	CAttribute()										{m_pNext = NULL;m_vbIsKey=VARIANT_FALSE;m_vbIsEnum=VARIANT_FALSE;}
	~CAttribute()										{;}

	CAttribute*		m_pNext;

	LONG			Id()								{ return m_lId; } 
	void			SetId( LONG l )						{ m_lId = l; }
	LPWSTR			Description()						{ return m_cbDescription; }
	LONG			Access()							{ return m_lAccess; }
	LONG			Storage()							{ return m_lStorage; }
	LONG			Type()								{ return m_lType; }

	LONG			MaxSize()							{ return m_lMaxSize; }
	CVariant&		Value()								{ return m_cvValue; }
	void			SetValue(LPVARIANT va)				{ m_cvValue.Set(va); }		
	BOOL			IsKey()								{ return (m_vbIsKey == VARIANT_FALSE) ?  FALSE : TRUE; }		// type VARIANT_BOOL shaningans
	BOOL			IsEnum()							{ return (m_vbIsEnum == VARIANT_FALSE) ? FALSE : TRUE; }		// type VARIANT_BOOL shaningans
	void			MakeKey()							{ m_vbIsKey = VARIANT_TRUE; }
	LPWSTR			Name()								{ return m_cbName; }
	void			SetName(LPWSTR p)					{ m_cbName.Set(p); }
	BOOL			Read(IDualAttribute* , BOOL );
	BOOL			IsWritable()						{ return ( m_lAccess == 2 || m_lAccess == 3 ) ? TRUE : FALSE;}

	void			Copy ( CAttribute* );

	BOOL			Equal ( CAttribute* );
};


///////////////////////////////////////////////////////////
class CAttributes
{
private:
	CAttribute*		m_pFirst;
	CAttribute*		m_pCurrent;

	
public:	
					CAttributes()						{m_pFirst = NULL;m_pCurrent = NULL;}
					~CAttributes();

	void 			MoveToHead()						{m_pCurrent = m_pFirst;}

	CAttribute*		Next();
	CAttribute*		Get(BSTR);
	void			Read(IDualColAttributes*, BOOL );
	void			Copy ( CAttributes& );
	void			Add(CAttribute*);
	LONG			GetCount()							{LONG l = 0; MoveToHead(); while (Next()) l++; return l;}
	void			GetMOTPath ( CString& );

	void			ReadCimPath ( CObjectPath& );
	BOOL			Equal ( CAttributes& );

	BOOL			Empty ( )				{ return ( m_pFirst ) ? FALSE : TRUE ;}


};

///////////////////////////////////////////////////////////
class CRow
{
private:
	CString			m_cszNWA;
	LONG			m_lComponent;
	LONG			m_lGroup;
	CString			m_csNode;
	
	BOOL			m_bFoundOneWritable;

public:
	CAttributes		m_Keys;
	CAttributes		m_Attributes;

	CRow*			m_pNext;

					CRow();
					~CRow();
	void			SetData ( LPWSTR  , LONG , LONG );

	void			Get ( CString& , LONG , LONG , CAttributes& , BOOL* );
	void			UpdateAttribute( CVariant& , CVariant& );

	BOOL			ReadOnly()				{return !m_bFoundOneWritable;}

	void			Delete ( );

	LONG			Component()						{return m_lComponent;}
	CString&		Node ( )						{ return m_csNode; }
	LPWSTR			NWA()							{ return m_cszNWA;}
	LONG			Group ( )						{ return m_lGroup; }

	void			CommitChanges ( );

	void			Read ( IDualRow* );

	void			Copy ( CRow& );

	BOOL			Empty ( )			{return m_Attributes.Empty() ;}

};

///////////////////////////////////////////////////////////
class CRows
{
private:
	CRow*	m_pFirst;
	CRow*	m_pCurrent;
	LONG 	m_lComponent;
	LONG	m_lGroup;
	CString m_cszNWA;

	BOOL	m_bFilled;
public:
			CRows();					
			~CRows();

	void	SetData ( LPWSTR , LONG , LONG);
	
	void	Read ( IDualColRows* );

	void	Get( LPWSTR , LONG , LONG );

	void	MoveToHead()				{m_pCurrent = m_pFirst;}
	void 	Add(CRow*);
	CRow*	Next();
	CRow*	GetFirst()					{return m_pFirst;}
};

///////////////////////////////////////////////////////////
class CGroup
{
private:
	CString			m_cszNWA;
	LONG			m_lComponent;	
	BOOL			m_bRead;

	LONG			m_lId;
	CBstr			m_cbName;
	CBstr			m_cbPragma;
	CBstr			m_cbDescription;
	CBstr			m_cbClassString;
	VARIANT_BOOL	m_vbIsTable;
	BOOL			m_bFilled;
	
public:
	CRows			m_Rows;
	CAttributes		m_Attributes;
	CGroup*			m_pNext;	

					CGroup();
					~CGroup()						{ ;}

	void			Read( IDualGroup*, BOOL , BOOL*);
	void			Get ( CString& , LONG , LONG );

	BSTR			Name()							{ return m_cbName;}
	BSTR			ClassString()					{ return m_cbClassString;}
	LONG			Id()							{ return m_lId;}
	LPWSTR			NWA  ( )						{ return m_cszNWA ; }
	LONG			Component ()					{ return m_lComponent ; }
	BSTR			Pragma()						{ return m_cbPragma;}
	BSTR			Description()					{ return m_cbDescription;}
	void			GetValue(BSTR, CVariant&);					// returns value of Attribute in bstr
	VARIANT_BOOL	IsTable()						{ return m_vbIsTable;}
	
	void			Delete ( );

	void			AddRow ( CRow& );

	void			SetNWA ( LPWSTR p)				{m_cszNWA.Set ( p ); }
	void			SetComponent ( LONG l)			{m_lComponent = l; }

	BOOL			IsEmpty()						{ return !m_bRead;}

	void			Copy ( CGroup& );
};

///////////////////////////////////////////////////////////
class CGroups
{
private:
	CString			m_cszNWA;
	LONG			m_lComponent;

	CGroup*			m_pCurrent;
	BOOL			m_bFilled;


	void			Add(CGroup*);
public:	
					CGroups();		
					~CGroups();

	CGroup*			m_pFirst;


	void 			MoveToHead()							{m_pCurrent = m_pFirst;}

	void			Get ( LPWSTR , LONG );


	CGroup*			Next();	

	void			Read ( IDualColGroups* );

	void			SetNWA ( LPWSTR );
	void			SetComponent ( LONG );
};

class CLanguage
{
	CString			m_cszLanguage;
public:
					CLanguage()							{m_pNext = NULL;}


	LPWSTR			Language()							{return m_cszLanguage;}
	void			Set(BSTR b)							{m_cszLanguage.Set(b);}

	CLanguage*		m_pNext;
};


class CLanguages
{
	CString			m_cszNWA;
	LONG			m_lComponent;

	void			Add(CLanguage*);
	BOOL			m_bFilled;


public:
					~CLanguages();
					CLanguages()							
						{m_pFirst = NULL;m_pCurrent = NULL; m_bFilled = FALSE;}


	CLanguage*		Next();
	void			MoveToHead()					{m_pCurrent = m_pFirst;}
	void			Get( LPWSTR pNWA , LONG lComponent );

	void			Read ( IDualColLanguages* );

	CLanguage*		m_pFirst;
	CLanguage*		m_pCurrent;
};

///////////////////////////////////////////////////////////
class CComponent
{
private:
	CString			m_cszNWA;
	LONG			m_lComponent;
	CBstr			m_cbName;
	CBstr			m_cbPragma;
	CBstr			m_cbDescription;

	CBstr			m_cbLanguages;

public:
	void			Read(IDualComponent*);
	
	void			Get( LPWSTR );
	void			Get ( CString& , LONG );
										
					CComponent()			{m_pNext = NULL;}
					~CComponent()			{;}

	BSTR			Name()					{ return m_cbName;}
	LONG			Id()					{ return m_lComponent;}
	BSTR			Pragma()				{ return m_cbPragma;}
	BSTR			Description()			{ return m_cbDescription;}
	LPWSTR			NWA ( )					{ return m_cszNWA; }


	void			GetComponentIDGroup( CRow* );	

	void			Delete ( );
	void			AddGroup ( CVariant& );
	void			AddLanguage ( CVariant& );
	void			DeleteLanguage ( CVariant& );

	CGroups			m_Groups;
	CLanguages		m_Languages;
	CComponent*		m_pNext;

	void			SetNWA ( LPWSTR p );				

	void			Copy ( CComponent& );
};

///////////////////////////////////////////////////////////
class CComponents 
{
private:
	CString			m_cszNWA;
	CComponent*		m_pCurrent;


public:	
	BOOL			m_bFilled;

	CComponent*		m_pFirst;

	void			Add(CComponent*);
					CComponents();
					~CComponents();

	void 			MoveToHead()					{ m_pCurrent = m_pFirst;}
	void			GetFromID(UINT, CComponent**);
	CComponent*		Next( );
	void			Get( LPWSTR );

	void			Empty();
	LONG			GetCount();

	void			SetNWA ( LPWSTR );

};

///////////////////////////////////////////////////////////
class CNode
{
	CString			m_cszNWA;
	CString			cszVersion;
	CString			cszLanguage;
	CString			cszDescription;

public:


	LPWSTR			Version()		{ return ( LPWSTR ) cszVersion; }
	LPWSTR			Language()		{ return ( LPWSTR ) cszLanguage; }
	LPWSTR			Description ()	{ return ( LPWSTR )	cszDescription; }

	void			Get ( CString& );
	void			SetDefaultLanguage ( CVariant& );
	void			AddComponent ( CVariant& );

	void			SetNWA ( LPWSTR p)	{m_cszNWA.Set ( p ); }


	void			Read ( IDualMgmtNode* );
};

/////////////////////////////////////////////////////////////

class CEvents
{
	CString		m_cszNWA;

public:

	void		Enable ( LPWSTR pNWA , IWbemObjectSink*	pIClientSink );

};



class CEvent
{
	LONG	m_lComponent;
	LONG	m_lGroup;
	CString	m_cszTime;
	CString m_cszLanguage;
	CString m_cszNWA;
	
public:
	CRow	m_Row;

			CEvent ( )			{ m_lGroup = m_lComponent = 0; }

	void SetGroup ( LONG l)		{ m_lGroup = l;}
	void SetComponent ( LONG l ) { m_lComponent = l;}
	void SetTime ( LPWSTR p )	{ m_cszTime.Set ( p );}
	void SetLanguage ( LPWSTR p ){ m_cszLanguage.Set ( p );}
	void SetNWA ( LPWSTR p)			{m_cszNWA.Set ( p );}

	void	Copy ( CEvent& );

	BOOL	IsEmpty ( )			{ return ( m_lComponent == 0 ) ? TRUE : FALSE ; }

	LONG	Group ( )			{ return m_lGroup; }
	LONG	Component ( )		{ return m_lComponent;}
	LPWSTR	Time ()				{ return m_cszTime;}
	LPWSTR  Language ()			{ return m_cszLanguage;}
	LPWSTR	NWA ()				{ return m_cszNWA; }

};

#endif // __DMIDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmidata.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/



#include "dmipch.h"	// precompiled header for DMI provider

#include "WbemDmiP.h"

#include "Strings.h"

#include "DmiData.h"

#include "Exception.h"

#include "Trace.h"

#include "ObjectPath.h"

#include "DmiInterface.h"

#include "MotObjects.h"

CDmiInterface* _gDmiInterface = NULL ;

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CEnum::Add( CEnumElement* pAdd)
{
	if (!m_pFirst)
	{
		m_pFirst = pAdd;
		return;
	}

	CEnumElement* p = m_pFirst;

	while (p->m_pNext)
		p = p->m_pNext;

	p->m_pNext = pAdd;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
LONG CEnum::GetCount()
{
	LONG i = 0;

	if(!m_pFirst)
		return 0L;

	m_pCurrent = m_pFirst;	

	while(m_pCurrent)
	{
		m_pCurrent = m_pCurrent->m_pNext;
		i++;
	}

	return i;
}


void CEnum::Read ( IDualColEnumerations* pI )
{
	CUnknownI			Unk;	
	CEnumVariantI		EnumI;
	SCODE				result = WBEM_NO_ERROR;	
	CVariant			va;

	result = pI->get__NewEnum( Unk );

	if ( FAILED ( result ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_GETATTRIBENUM_FAIL ,
			IDS_MOT_GETNEWENUM_FAIL , CString ( result ) );	
	}
	
	// Get pointer to IEnumVariant interface of from IUNKNOWN

	Unk.GetEnum ( EnumI );	

	while ( EnumI.Next( va ) )
	{			
		CDEnumI		DEI;		

		if ( FAILED ( va.GetDispId()->QueryInterface( 
			IID_IDualEnumeration, DEI ) ))
		{
			throw CException ( WBEM_E_FAILED , IDS_GETATTRIBENUM_FAIL ,
				IDS_QI_FAIL );	
		}

		CEnumElement* pElement =  new CEnumElement;

		if(!pElement)
		{
			throw CException ( WBEM_E_OUT_OF_MEMORY , IDS_GETATTRIBENUM_FAIL ,
				IDS_NO_MEM );	
		}
		
		pElement->Read( DEI );

		Add(pElement);

		va.Clear ( );
			
	}	


}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CEnumElement::Read( IDualEnumeration* pI )
{
	CBstr	cbString;

	if ( FAILED ( pI->get_EnumValue( &m_lValue ) ))
	{
		throw CException ( WBEM_E_FAILED, 
			IDS_MOT_ENUM_READ , IDS_MOT_GETENUMVALUE );
	}

	if ( FAILED ( pI->get_EnumString( cbString ) ))
	{
		throw CException ( WBEM_E_FAILED, 
			IDS_MOT_ENUM_READ , IDS_MOT_GETENUMSTRING );
	}

	m_cszString.Set(cbString);	

}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CEnumElement* CEnum::Next()
{
	if(!m_pCurrent)
	{
 		// there are no items in the list on start or we have gone 
		// through the entire list
		return NULL;
	}
	
	CEnumElement* p = m_pCurrent;  // p is the item we will return
	
	m_pCurrent = m_pCurrent->m_pNext; // get ready for next pass through
		
	return p;

}

void CEnum::Get ( CString& cszNWA , LONG lComponent , LONG lGroup , 			
				 LONG lAttribute )
{
	_gDmiInterface->GetEnum ( cszNWA , lComponent , lGroup , 
		lAttribute , this );		
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CEnum::~CEnum()
{
	if(!m_pFirst)
		return;

	m_pCurrent = m_pFirst;

	CEnumElement* p = NULL;

	while(m_pCurrent)
	{
		p = m_pCurrent;

		m_pCurrent = m_pCurrent->m_pNext;

		MYDELETE ( p );
	}
}

//////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CAttribute::Read(IDualAttribute* pIAttribute , BOOL bGroupRead )
{	
	SCODE		result = WBEM_NO_ERROR;
	CVariant	cvTemp;
		
	if ( FAILED ( result = pIAttribute->get_Name( m_cbName ) ))
		return FALSE ;

	pIAttribute->get_id( &m_lId );		

	if ( !bGroupRead )
	{
		pIAttribute->get_Value( cvTemp );

		m_cvValue.Set( cvTemp.GetBstr() );
	}
	
	if(m_cvValue.IsEmpty())
		m_cvValue.Set( EMPTY_STR );
		
	pIAttribute->get_Access( &m_lAccess );
		
	pIAttribute->get_Description( m_cbDescription );

	pIAttribute->get_Type( &m_lType );

	pIAttribute->get_Storage( &m_lStorage );		

	pIAttribute->get_IsEnumeration( &m_vbIsEnum );
	
	pIAttribute->get_MaxSize( &m_lMaxSize );
	
	pIAttribute->get_IsKey( &m_vbIsKey);

	//MOT_TRACE ( L"\t\t\t\tRead Attribute %lu %s bKey = %lu , Access = %lu", Id() , Name(), IsKey() , m_lAccess);

	return TRUE;
}

void CAttribute::Copy ( CAttribute* pSource )
{
	m_vbIsKey = pSource->m_vbIsKey;
	m_vbIsEnum = pSource->m_vbIsEnum;
	m_lId = pSource->m_lId;
	m_cvValue.Set ( ( LPVARIANT )pSource->m_cvValue);
	m_lAccess = pSource->m_lAccess;
	m_cbDescription.Set ( pSource->m_cbDescription );
	m_cbName.Set ( pSource->m_cbName );
	m_lType = pSource->m_lType;
	m_lStorage = pSource->m_lStorage;
	m_lMaxSize = pSource->m_lMaxSize;	
}


BOOL CAttribute::Equal ( CAttribute* pAttribute2 )
{
/*	MOT_TRACE ( L"\t\tComparing Attribute %lu = %s with Attribute %lu = %s" ,
		m_lId , m_cvValue.GetBstr () , pAttribute2->m_lId , pAttribute2->m_cvValue.GetBstr () );
*/
	if  ( 
			( m_lId == pAttribute2->m_lId ) && 
			(  m_cvValue.Equal ( pAttribute2->m_cvValue ) )
		)
	{
		return TRUE;
	}
	
	return FALSE;
}


//////////////////////////////////////////////////////////////////
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CAttributes::~CAttributes()
{
	if(!m_pFirst)
		return;

	m_pCurrent = m_pFirst;

	CAttribute* p = NULL;

	while(m_pCurrent)
	{
		p = m_pCurrent;

		m_pCurrent = m_pCurrent->m_pNext;

		MYDELETE ( p );
	}
}

// put the new attriubte in the list
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAttributes::Add(CAttribute* pAdd)
{	
	if (!m_pFirst)
	{
		m_pFirst = pAdd;
	}
	else
	{
		CAttribute* p = m_pFirst;

		while (p->m_pNext)
			p = p->m_pNext;

		p->m_pNext = pAdd;
	}
}

void CAttributes::ReadCimPath( CObjectPath& Path )
{	
	for ( int i = 0 ; i < Path.KeyCount() ; i++ )
	{
		// Extract the Id from the attribute name
		CString cszT;

		cszT.Set ( Path.KeyName ( i ) );

		cszT.TruncateAtFirst ( UNDER_CODE );

		long l = 0;

		if ( 0 == swscanf ( cszT , L"Attribute%u" , &l )  )
			throw CException ( WBEM_E_INVALID_OBJECT , 0 , 0 );

		CAttribute* pAttribute = new CAttribute;

		pAttribute->SetId ( l );

		CVariant cvValue;
		
		cvValue.Set ( (LPWSTR) Path.KeyValue ( i ) );

		pAttribute->SetValue ( cvValue );		

		Add ( pAttribute );
	}
}



BOOL CAttributes::Equal ( CAttributes& Set2 )
{
	MoveToHead ( );

	Set2.MoveToHead ( );

	CAttribute* p1;
	CAttribute* p2;

	while ( p1 = Next () )
	{
		p2 = Set2.Next ( );

		if ( p2->Equal ( p1 ) )
			continue;

		return FALSE;

	}

	// there all keys not exausted set does not match
	if ( p2 = Set2.Next ( ) )
		return FALSE;

	return TRUE;
}

void CAttributes::GetMOTPath ( CString& cszPath )
{
	BOOL	bFirst = TRUE;

	MoveToHead ( );

	cszPath.Set ( L"|" );

	CAttribute* pAttribute = NULL;

	while ( pAttribute = Next () )
	{
		WCHAR	wszT[256];

		if ( !bFirst )
			cszPath.Append ( L",");

		cszPath.Append ( pAttribute->Id() );		

		if ( pAttribute->Value().GetBstr() )
		{
			swprintf ( wszT , L"=\"%s\"", pAttribute->Value().GetBstr());
		}
		else
		{
			swprintf ( wszT , L"=\"\"");
		}

		cszPath.Append ( wszT);

		bFirst = FALSE;		
	}
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CAttribute*	CAttributes::Get(BSTR bstrName)
{
	CAttribute* p = m_pFirst;

	while(p)
	{
		if(MATCH == wcsicmp(bstrName, p->Name()))
			return p;

		p = p->m_pNext;
	}

	return NULL;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CAttribute* CAttributes::Next()
{
	if(!m_pCurrent)
	{
		// there are no items in the list on start or we have gone through 
		// the entire list
		return NULL; 			
	}
	
	CAttribute* p = m_pCurrent;  
	
	// get ready for next pass through

	m_pCurrent = m_pCurrent->m_pNext; 
		
	return p;
}

// used to add attributes into a row
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CAttributes::Read(IDualColAttributes* pIAttributes ,BOOL bGroupRead )
{	
	CUnknownI		Unk;	
	CEnumVariantI	Enum;	
	CVariant		va;	


	if ( FAILED ( pIAttributes->get__NewEnum( Unk ) )) 	
	{
		throw CException ( WBEM_E_FAILED , 
			IDS_MOT_ATTRIBUTES_FAIL , IDS_MOT_GETNEWENUM_FAIL );
	}

	// Get pointer to IEnumVariant interface of from IUNKNOWN

	Unk.GetEnum( Enum );

	while( Enum.Next ( va ) )
	{
		CDAttributeI	DAI;

		if ( FAILED ( va.GetDispId()->QueryInterface( IID_IDualAttribute, 
			DAI )))
		{
			throw CException ( WBEM_E_FAILED , IDS_MOT_ATTRIBUTES_FAIL , 
				IDS_QI_FAIL );
		}

		CAttribute* pAttribute = (CAttribute*) new CAttribute;

		if(!pAttribute)
		{
			throw CException ( WBEM_E_OUT_OF_MEMORY , 
				IDS_MOT_ATTRIBUTES_FAIL , NO_STRING );
		}
		
		if ( !pAttribute->Read( DAI , bGroupRead ) )
		{
			MYDELETE(pAttribute);

			throw CException ( WBEM_E_OUT_OF_MEMORY , 
				IDS_MOT_ATTRIBUTES_FAIL , NO_STRING );
		}

		Add(pAttribute);		

		DAI.Release ( );
	}

}

void CAttributes::Copy ( CAttributes& Set2)
{
	Set2.MoveToHead ( );
	
	CAttribute* pAttribute;

	while ( pAttribute = Set2.Next () )
	{
		CAttribute* pNewAttribute = new CAttribute ;

		pNewAttribute->Copy ( pAttribute );

		Add ( pNewAttribute );
	}
}


//////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CRow::CRow()
{	
	m_pNext = NULL;

	m_bFoundOneWritable = FALSE;

	m_lComponent = 0;
	m_lGroup = 0;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CRow::~CRow()
{
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************

void CRow::Copy ( CRow& Source )
{
	m_cszNWA.Set ( Source.NWA () );

	m_lComponent = Source.Component () ;

	m_lGroup = Source.Group ( ); 

	m_csNode.Set ( Source.Node () );

	m_bFoundOneWritable = m_bFoundOneWritable;

	m_Keys.Copy ( Source.m_Keys );

	m_Attributes.Copy ( Source.m_Attributes );

	m_pNext = NULL ;

}

void CRow::Read( IDualRow* pIRow )
{
	SCODE				result = WBEM_NO_ERROR;
	CDAttributesI		DASIAttributes;
	CDAttributesI		DASIKeys;


	//MOT_TRACE ( L"\t\t\tRow Read by IDualRow*" );

	// start debug only
	BSTR b;
	pIRow->get_Path ( &b );
	SysFreeString ( b );
	// end debug only
	
		if ( FAILED ( result = pIRow->get_KeyList( DASIKeys ) ))
	{
		throw CException ( WBEM_E_FAILED, IDS_ROWREAD_FAIL , IDS_GETID_FAIL , 
			CString ( result ) ) ;		
	}

	if ( FAILED ( result = pIRow->get_Attributes( DASIAttributes ) ))	
	{
		throw CException ( WBEM_E_FAILED, IDS_ROWREAD_FAIL, 
			IDS_GETATTRIBUTES_FAIL , CString ( result ) );		
	}

	m_Attributes.Read( DASIAttributes , FALSE );	

	m_Keys.Read ( DASIKeys , FALSE );
}




// update just updates the local row object not the sl
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CRow::UpdateAttribute( CVariant& cvAttribute, CVariant& cvNewValue)
{
	CAttribute*		pAttribute;	

	pAttribute = m_Attributes.Get( cvAttribute.GetBstr() );	

	if (!pAttribute)
	{
		// Non existant attribute included in the class

		throw CException ( WBEM_E_INVALID_CLASS , 
			IDS_UPDATEATTRIB_FAIL ,
			IDS_GETATTRIB_FAIL , 
			cvAttribute.GetBstr() );
	}

	if ( pAttribute->IsWritable() )
	{
		m_bFoundOneWritable = TRUE;
		// if the attribute is writable we will try to commit it
		// regardless of the value

		pAttribute->SetValue ( cvNewValue );

		return;
	}

	
}



void CRow::Delete ( )
{
	_gDmiInterface->DeleteRow ( m_cszNWA , m_lComponent , m_lGroup , m_Keys );		
}


void CRow::CommitChanges ( )
{
	_gDmiInterface->UpdateRow ( m_cszNWA , m_lComponent , m_lGroup , m_Keys ,
		this );		
}


void CRow::Get ( CString& cszNWA , LONG lComponent , LONG lGroup , 
				CAttributes& Keys , BOOL* pbFound)
{

	_gDmiInterface->GetRow ( cszNWA , lComponent , lGroup , Keys ,
		this );		

	if ( Empty() )
		*pbFound = FALSE;
	else
		*pbFound = TRUE;

}

void CRow::SetData ( LPWSTR wszNWA , LONG lComponent , LONG lGroup )
{
	m_lComponent = lComponent;
	m_lGroup = lGroup;
	m_cszNWA.Set ( wszNWA );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CRows::CRows()
{
	m_pFirst = NULL;
	m_pCurrent = NULL; 
	m_bFilled = FALSE; 
 	m_lComponent = 0;
	m_lGroup = 0;

}

CRows::~CRows()
{
	if(!m_pFirst)
		return;

	m_pCurrent = m_pFirst;

	CRow* p = NULL;

	while(m_pCurrent)
	{
		p = m_pCurrent;

		m_pCurrent = m_pCurrent->m_pNext;

		MYDELETE  ( p )
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CRows::Get( LPWSTR wszNWA , LONG lComponent , LONG lGroup  )
{

	if ( !m_bFilled )
	{
		_gDmiInterface->GetRows ( wszNWA , lComponent , lGroup , this );

		MoveToHead ( );

		m_bFilled = TRUE;
	}
}


void CRows::SetData ( LPWSTR wszNWA , LONG lComponent , LONG lGroup )
{
	MoveToHead ( );

	while(m_pCurrent)
	{		
		m_pCurrent->SetData ( wszNWA , lComponent , lGroup);
		
		Next ( );
	}

	m_lComponent = lComponent;
	m_lGroup = lGroup;
	m_cszNWA.Set ( wszNWA );

}


void CRows::Read ( IDualColRows* pIRows )
{
	CGroup*				pGroup = NULL;
	CEnumVariantI		Enum;
	CDGroupI			DGI;
	CDRowsI				DRSI;
	CDRowI				DRI;
	CVariant			va;

	if(m_bFilled)
		return;

	//MOT_TRACE ( L"\t\t\tRows Read");

	// a table may contain 0 or more rows. The GetFirstRow() method returns 
	// the first Row. If there are no rows, the pIRow is NULL and the 
	// HRESULT will be E_ERROR.  We then exit the loop. access the next row
	// by using GetNextRow() Again if the HRESULT = E_ERROR, we exit the loop.


	LONG lCount;

	if ( FAILED ( pIRows->get_Count ( &lCount ) ) )
	{
		MOT_TRACE ( L"\t\tFailed to get rows count from MOT");

		throw CException ( WBEM_E_FAILED , 0 , 0 );
	}
	
		// walk through rows 
	BOOL bFirst = TRUE;

	for ( int i = 0 ; i < lCount ; i++ )
	{
		if ( bFirst )
		{
			bFirst = FALSE;

			if(FAILED ( pIRows->GetFirstRow( va, DRI ) ))
			{
				// Note: according to sample code , only fails on when enum 
				// is empty, not really error		

				break;
			}
		}
		else
		{
			if ( FAILED ( pIRows->GetNextRow( DRI ) ) )
			{
				// Note: according to sample code , getnext row only fails 
				// when enum is done, not actually on error

				break;
			}
		}

		CRow* pRow = (CRow*) new CRow();

		pRow->Read( DRI );
			
		DRI.Release( ) ;

		Add(pRow);			
	 }
 
	m_bFilled = TRUE;

	MoveToHead();	
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CRows::Add(CRow* pAdd)
{

	if (!m_pFirst)
	{
		m_pFirst = pAdd;
	}
	else
	{
		CRow* p = m_pFirst;

		while (p->m_pNext)
			p = p->m_pNext;

		p->m_pNext = pAdd;
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CRow* CRows::Next()
{
	if(!m_pCurrent)
	{
 		// there are no items in the list on start or we have gone through
		// the entire list

		return NULL;
	}

	// p is the item we will return

	CRow* p = m_pCurrent;  

	// get ready for next pass through

	m_pCurrent = m_pCurrent->m_pNext;

	return p;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CGroup::CGroup()
{
	m_pNext = NULL;
	m_vbIsTable = VARIANT_FALSE;
	m_bRead = FALSE;
	m_lComponent = 0;
	m_lId = 0;
	m_bFilled = FALSE;
}

//////////////////////////////////////////////////////////////////
// returns value of Attribute in bstr only used on component id group
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************

void CGroup::Copy ( CGroup& Source )
{
	if ( Source.IsEmpty ( ) )
		return;

	m_cszNWA.Set ( Source.NWA() );
	m_lComponent = Source.Component () ;	
	m_bRead = TRUE;
	m_lId = Source.Id() ;
	m_cbName.Set ( Source.Name () );
	m_cbPragma.Set ( Source.Pragma () );
	m_cbDescription.Set ( Source.Description () );
	m_cbClassString.Set ( Source.ClassString () );
	m_vbIsTable = Source.IsTable();
	m_bFilled = TRUE;
	m_Attributes.Copy ( Source.m_Attributes );	
}

void CGroup::GetValue(BSTR bstrAttributeName, CVariant& varReturn)
{	
	CAttribute* pAttribute = m_Attributes.Get(bstrAttributeName);

	if(!pAttribute)
	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_GETVALUE_FAIL , 
			NO_STRING , bstrAttributeName );
	}

	varReturn.Set( (LPVARIANT) pAttribute->Value());	
}

//////////////////////////////////////////////////////////////////
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CGroup::Read( IDualGroup* pIGroup, BOOL bGroupDelHack , BOOL* pbComponentIdGroup )
{
	CBstr			bstrVal;	
	CVariant		va;	
	long			lRowCntr = 1;	
	CDAttributesI	DASI;

	*pbComponentIdGroup = FALSE;	

	pIGroup->get_id( &m_lId );
	
	if(m_lId == 1)			// don't waste time with the component ID group
	{
		*pbComponentIdGroup = TRUE;
		return;
	}

	pIGroup->get_Name( m_cbName );

	//MOT_TRACE  ( L"\t\t\tGroup Read %lu %s" , m_lId , m_cbName );

	pIGroup->get_Pragma( m_cbPragma );
	pIGroup->get_Description( m_cbDescription );
	pIGroup->get_ClassString( m_cbClassString );
	pIGroup->get_IsTable(&m_vbIsTable);

	if ( !bGroupDelHack )
	{
		//MOT_TRACE  ( L"\t\t\tReading group's Attribute %lu %s" , m_lId , m_cbName );

		pIGroup->get_Attributes( DASI );

		m_Attributes.Read( DASI , TRUE );
	}

	m_bRead = TRUE;
}

void CGroup::Delete ( )
{
	_gDmiInterface->DeleteGroup ( m_cszNWA , m_lComponent , m_lId );

}

void CGroup::AddRow ( CRow& Row )
{
	_gDmiInterface->AddRow ( m_cszNWA , m_lComponent , m_lId , Row);
}

void CGroup::Get ( CString& cszNWA , LONG lComponent , LONG lGroup )
{
	if ( 1 == lGroup )
	{
		throw CException ( WBEM_E_INVALID_OBJECT , 0 , 0);
	}

	if ( m_bFilled )
		return;

	_gDmiInterface->GetGroup ( cszNWA , lComponent , lGroup , this );

	m_bFilled = TRUE;

}
//////////////////////////////////////////////////////////////////
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CGroups::CGroups()
{
	m_pFirst = NULL;
	m_pCurrent = NULL;
	m_bFilled = FALSE;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CGroups::~CGroups()
{

	if(!m_pFirst)
		return;

	m_pCurrent = m_pFirst;

	CGroup* p = NULL;

	while(m_pCurrent)
	{
		p = m_pCurrent;

		m_pCurrent = m_pCurrent->m_pNext;

		MYDELETE  ( p )
	}
}


////////////////////////////////////////////////////
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CGroup*	CGroups::Next()			
{
	CGroup*	pGroup = NULL;

	if(!m_pCurrent)							
		return NULL;						
	
	pGroup = m_pCurrent;					
	
	// get ready for next pass through

	m_pCurrent = m_pCurrent->m_pNext;		

	return pGroup;
}

////////////////////////////////////////////////////
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CGroups::Add(CGroup* pAdd)
{
	// put the new group in the list
	if (!m_pFirst)
	{
		m_pFirst = pAdd;
	}
	else
	{
		CGroup* p = m_pFirst;

		while (p->m_pNext)
			p = p->m_pNext;

		p->m_pNext = pAdd;
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CGroups::Get ( LPWSTR wszNWA , LONG lComponent )
{
	if ( !m_bFilled )
	{
		_gDmiInterface->GetGroups ( wszNWA , lComponent , this );

		m_bFilled = TRUE;
	}
}


void CGroups::Read( IDualColGroups* pIGS )
{
	SCODE			result = NO_ERROR;
	CUnknownI		Unk;
	CEnumVariantI	Enum;
	CVariant		va;

	//MOT_TRACE ( L"\t\t\tGroups Read");
	
	if ( FAILED (  result = pIGS->get__NewEnum( Unk ) ))
	{
		CString cszT ( result );

		throw CException ( WBEM_E_FAILED, IDS_MOT_GETGROUPS_FAIL , 
			IDS_MOT_GETNEWENUM_FAIL , cszT );
	}

	// Get pointer to IEnumVariant interface of from IUNKNOWN

	Unk.GetEnum ( Enum );

	while ( Enum.Next ( va ) )
	{
		CBstr		bstrVal;
		CDGroupI	DGI;
		BOOL		bComponentIdGroup;

		DGI.QI ( va );

		CGroup* pGroup = new CGroup;

		if(!pGroup)
		{
			throw CException ( WBEM_E_OUT_OF_MEMORY , 
				IDS_MOT_GETGROUPS_FAIL , IDS_NO_MEM );
		}
	
		pGroup->Read( DGI, FALSE , &bComponentIdGroup);

		if (pGroup)
			pGroup->m_Rows.MoveToHead();

		if (!bComponentIdGroup)
			Add(pGroup);
		else
			MYDELETE(pGroup);

		va.Clear ( );
	}
	
	m_bFilled = TRUE;

	MoveToHead();
}


void CGroups::SetNWA( LPWSTR wszNWA )
{
	MoveToHead ( );

	while(m_pCurrent)
	{
		m_pCurrent->SetNWA ( wszNWA );
		
		Next ( );
	}
}


void CGroups::SetComponent( LONG lComponent )
{
	MoveToHead ( );

	while(m_pCurrent)
	{
		m_pCurrent->SetComponent ( lComponent );
		
		Next ( );
	}

	m_lComponent = lComponent;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CLanguages::~CLanguages()
{
	if(!m_pFirst)
		return;

	m_pCurrent = m_pFirst;

	CLanguage* p = NULL;

	while(m_pCurrent)
	{
		p = m_pCurrent;

		m_pCurrent = m_pCurrent->m_pNext;

		MYDELETE  ( p )
	}
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************

void CLanguages::Get( LPWSTR wszNWA , LONG lComponent )
{
	if ( !m_bFilled )
	{
		_gDmiInterface->GetLanguages ( wszNWA , lComponent ,  this );

		m_bFilled = TRUE;
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CLanguage*	CLanguages::Next()			
{
	CLanguage*	pLanguage = NULL;

	// there are no items in the list on start or we have gone through
	// the entire list

	if(!m_pCurrent)							
		return NULL;						
	
	// pGroup is the item we will return

	pLanguage = m_pCurrent;					
	
	// get ready for next pass through

	m_pCurrent = m_pCurrent->m_pNext;		

	return pLanguage;
}




//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CLanguages::Add(CLanguage* pAdd)
{	
	// put the new group in the list
	if (!m_pFirst)
	{
		m_pFirst = pAdd;
	}
	else
	{
		CLanguage* p = m_pFirst;

		while (p->m_pNext)
			p = p->m_pNext;

		p->m_pNext = pAdd;
	}
}



void CLanguages::Read ( IDualColLanguages* pI)
{	

	CUnknownI				Unk;
	CEnumVariantI			Enum;
	CDComponentI			DCI;
	CVariant				vaLanguage;

	//MOT_TRACE ( L"\tMOT... Reading languages on Component %lu" , m_lComponent );

	if ( FAILED ( pI->get__NewEnum( Unk ) ) )
	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_LANGUAGES_READ_FAIL ,
			IDS_MOT_GETNEWENUM_FAIL );
	}
	
	// Get pointer to IEnumVariant interface of from IUNKNOWN

	Unk.GetEnum ( Enum );

	while ( Enum.Next( vaLanguage ) )
	{				
		CLanguage*		pLanguage = NULL;
	
		pLanguage = new CLanguage();

		if(!pLanguage)
		{
			throw CException ( WBEM_E_OUT_OF_MEMORY , 
				IDS_MOT_LANGUAGES_READ_FAIL , IDS_NO_MEM );
		}

		//MOT_TRACE ( L"\tMOT...\tlanguage %s" , vaLanguage.GetBstr() );

		pLanguage->Set( vaLanguage.GetBstr() );

		Add(pLanguage);

		vaLanguage.Clear ( );
	}

	MoveToHead();

}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CComponent::Read(IDualComponent*  pIComponent)
{	
	pIComponent->get_Name( m_cbName );
	pIComponent->get_id( &m_lComponent );	
	pIComponent->get_Pragma( m_cbPragma );
	pIComponent->get_Description( m_cbDescription );	

	STAT_TRACE ( L"\t\tComponent Read %lu  %s" , m_lComponent , m_cbName );
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CComponent::Copy( CComponent& Source)
{
	m_cszNWA.Set ( Source.NWA ( ) );

	m_lComponent = Source.Id ( );

	m_cbName.Set ( Source.Name( )  );

	m_cbPragma.Set ( Source.Pragma ( ) );

	m_cbDescription.Set ( Source.m_cbDescription );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CComponent::GetComponentIDGroup( CRow* pRow )			
{
	CAttributes Keys;

	// sending empty keys list means scalar group

	_gDmiInterface->GetRow ( m_cszNWA , m_lComponent , COMPONENTID_GROUP , Keys , pRow );
	
}


void CComponent::Get ( CString& cszNWA , LONG lComponent )
{
	_gDmiInterface->GetComponent ( cszNWA , lComponent , this );
}


void CComponent::AddGroup ( CVariant& cvMifFile )
{

	_gDmiInterface->AddGroup ( m_cszNWA , m_lComponent , cvMifFile );

}

void CComponent::AddLanguage ( CVariant& cvMifFile )
{

	_gDmiInterface->AddLanguage ( m_cszNWA , m_lComponent , cvMifFile );

}

void CComponent::Delete ( )
{

	_gDmiInterface->DeleteComponent ( m_cszNWA , m_lComponent );

}

void CComponent::DeleteLanguage ( CVariant& cvLanguage)
{

	_gDmiInterface->DeleteLanguage ( m_cszNWA , m_lComponent , cvLanguage );

}


void CComponent::SetNWA ( LPWSTR p )
{ 
	m_cszNWA.Set ( p ); 
}
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CComponents::CComponents()
{
	m_pFirst = NULL;
	m_pCurrent = NULL;
	m_bFilled = FALSE;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CComponents::~CComponents()
{
	if(!m_pFirst)
		return;

	m_pCurrent = m_pFirst;

	while(m_pFirst)
	{
		m_pCurrent = m_pFirst;	
		m_pFirst = m_pCurrent->m_pNext;
		delete m_pCurrent;
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
LONG CComponents::GetCount()
{
	LONG i = 0;

	if(!m_pFirst)
		return 0L;

	m_pCurrent = m_pFirst;	

	while(m_pCurrent)
	{
		m_pCurrent = m_pCurrent->m_pNext;
		i++;
	}

	return i;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CComponents::Get( LPWSTR wszNWA )
{
	if ( !m_bFilled )
	{
		_gDmiInterface->GetComponents ( wszNWA , this );
	}

	m_bFilled = TRUE;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CComponents::Add(CComponent* pAdd)
{

	// put the new component in the list
	if (!m_pFirst)
	{
		m_pFirst = pAdd;
	}
	else
	{
		CComponent* p = m_pFirst;

		while (p->m_pNext)
			p = p->m_pNext;

		p->m_pNext = pAdd;
	}

}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CComponent*	CComponents::Next( )
{

	if(!m_pCurrent)
	{
		// there are no items in the list on start or we have gone through 
		// the entire list

		return NULL;				
	}
	
	// p is the item we will return

	CComponent* p = m_pCurrent;		
	
	// get ready for next pass through

	m_pCurrent = m_pCurrent->m_pNext;	
	
	return p;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CComponents::GetFromID(UINT iId, CComponent** ppComponent)
{
	m_pCurrent = m_pFirst;

	while(m_pCurrent)
	{
		if (m_pCurrent->Id() == (long)iId)
		{
			*ppComponent = m_pCurrent;
			return;
		}

		m_pCurrent = m_pCurrent->m_pNext;
	}

	throw CException ( WBEM_E_INVALID_CLASS , IDS_GETFROMID_FAIL , NO_STRING ,
		CString ( iId )  );
}


void CComponents::SetNWA ( LPWSTR wszNWA )
{
	MoveToHead ( );


	while(m_pCurrent)
	{
		m_pCurrent->SetNWA ( wszNWA );
		
		Next ( );
	}
}


void CNode::Get ( CString& cszNWA )
{
	_gDmiInterface->GetNode ( cszNWA , this);		
}

void CNode::SetDefaultLanguage ( CVariant& cvLanguage )
{
	_gDmiInterface->SetDefLanguage ( m_cszNWA , cvLanguage );		
}

void CNode::AddComponent ( CVariant& cvMifFile )
{
	_gDmiInterface->AddComponent ( m_cszNWA , cvMifFile );		
}

void CNode::Read( IDualMgmtNode* pIN )
{
	CBstr cbstr;

	pIN->get_Language ( cbstr );	
	
	cszLanguage.Set( cbstr );

	cbstr.Clear ( );

	pIN->get_Version( cbstr );

	cszVersion.Set( cbstr );

	cbstr.Clear ( );

	pIN->get_Path( cbstr );

	CString cszPath;

	cszPath.Set ( cbstr );

	// get the sl description, if fails just don't fill in 
	// value

	try
	{
		CDAttributeI	DAI;		
		CAttribute		Attribute;

		DAI.CoCreate ( );

		cszPath.Append ( VERSION_ATTRIBUTE_PATH_STR );

		DAI.Read ( cszPath );

		Attribute.Read ( DAI , FALSE );

		cszDescription.Set ( Attribute.Value().GetBstr() );
	}
	catch (...)
	{
		// the ops in the above try block are not essentail
		// so just continue on.
		//MOT_TRACE ( L"\tMOT... In ReadNode catch ...");
	}
	
}

void CEvent::Copy ( CEvent& Source )
{
	if ( Source.IsEmpty () )
		return;

	m_lComponent = Source.Component ( ) ;
	m_lGroup = Source.Group ( ) ;
	m_cszTime.Set ( Source.Time ( ) ) ;
	m_cszLanguage.Set ( Source.Language ( ) );
	m_cszNWA.Set ( Source.NWA ( ) );
	
	m_Row.Copy ( Source.m_Row );
}
////////////////////////////////////////////////////////

void CEvents::Enable ( LPWSTR pNWA , IWbemObjectSink*	pIClientSink )
{
	m_cszNWA.Set ( pNWA );

	_gDmiInterface->EnableEvents ( pNWA , pIClientSink );		
}
////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmiinterface.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/



#include "dmipch.h"	// precompiled header for dmi provider

#include "WbemDmiP.h"

#include "DmiData.h"

#include "DmiInterface.h"

#include "Exception.h"

#include "strings.h"

#include "Trace.h"


#define WMU_GETCOMPONENT	WM_USER+1000
#define WMU_GETCOMPONENTS	WMU_GETCOMPONENT + 1
#define WMU_GETROW			WMU_GETCOMPONENTS + 1
#define WMU_GETNODE			WMU_GETROW + 1
#define WMU_ADDCOMPONENT	WMU_GETNODE + 1
#define WMU_DELETECOMPONENT	WMU_ADDCOMPONENT + 1
#define WMU_ADDGROUP		WMU_DELETECOMPONENT + 1
#define WMU_GETGROUPS		WMU_ADDGROUP + 1
#define WMU_GETGROUP		WMU_GETGROUPS + 1
#define WMU_DELETEGROUP		WMU_GETGROUP + 1
#define WMU_ADDLANGUAGE		WMU_DELETEGROUP + 1
#define WMU_DELETELANGUAGE	WMU_ADDLANGUAGE + 1
#define WMU_GETENUM			WMU_DELETELANGUAGE + 1
#define WMU_SETLANG			WMU_GETENUM + 1
#define WMU_GETLANGUAGES	WMU_SETLANG + 1
#define WMU_GETROWS			WMU_GETLANGUAGES + 1
#define WMU_ENABLEEVENTS	WMU_GETROWS + 1
#define WMU_DELETEROW		WMU_ENABLEEVENTS  + 1
#define WMU_UPDATEROW		WMU_DELETEROW + 1
#define WMU_ADDROW			WMU_UPDATEROW + 1
#define WMU_SHUTDOWN		WMU_ADDROW  + 1



class CDmiInterfaceJobContext
{
public:

					CDmiInterfaceJobContext();

	LPWSTR			pNWA;
	LONG			lComponent;
	LONG			lGroup;
	LONG			lAttribute;
	CNode*			pNode;
	CComponents*	pComponents;
	CComponent*		pComponent;
	CGroups*		pGroups;
	CGroup*			pGroup;
	CRows*			pRows;
	CRow*			pRow;
	CAttributes*	pKeys;
	CAttributes*	pAttributes;
	CLanguages*		pLanguages;
	CEnum*			pEnum;
	LPWSTR			pszData;
	CDmiError*		pError;	
	IWbemObjectSink*	pIClientSink;
};


CDmiInterfaceJobContext::CDmiInterfaceJobContext()
{
	pNWA = NULL ;
	lComponent = 0 ;
	lGroup = 0 ;
	lAttribute = 0 ;
	pNode = NULL ;
	pComponents = NULL ;
	pComponent = NULL ;
	pGroups = NULL ;
	pGroup = NULL ;
	pRows = NULL ;
	pRow = NULL ;
	pAttributes = NULL ;
	pEnum = NULL;
	pError = NULL ;
	pszData = NULL;
	pLanguages = NULL;

}

//////////////////////////////////////////////////////////////////

CDmiInterfaceThreadContext::CDmiInterfaceThreadContext()
{
	m_hStopThread = CreateEvent(NULL, FALSE, FALSE, NULL );
	m_hComplete = CreateEvent(NULL, FALSE, FALSE, NULL );

	// Create this as a manual reset event.  This event will be signaled in 
	// the Run() function to make sure that the Run() function is called
	// to create the thread's message loop before the SendThreadMessage() is called.
	// In SendThreadMessage() we will wait for this handle to be signaled before we
	// send any message to the threads.
	m_Started = CreateEvent(NULL, TRUE, FALSE, NULL );
	m_bRunning = FALSE;
}

void CDmiInterfaceThreadContext::StartThread ()
{
	_beginthread ( ApartmentThread , 0 , (void *)this );

	m_bRunning = TRUE;
}


CDmiInterfaceThreadContext::~CDmiInterfaceThreadContext()
{
	KillThread ( );

	CloseHandle ( m_hStopThread );

	CloseHandle ( m_hComplete );
	CloseHandle ( m_Started );
}

void CDmiInterfaceThreadContext::KillThread()
{
	if ( !m_bRunning )
		return;

	SetEvent ( m_hStopThread );	
	
	PostThreadMessage ( m_dwThreadId , WM_QUIT , 0 , 0 );

	WaitForSingleObject ( m_hComplete , INFINITE );

	m_bRunning = FALSE;
}


//////////////////////////////////////////////////////////////////

class CDmiInterfaceThread 
{
public:
				CDmiInterfaceThread();
				~CDmiInterfaceThread();

	void		Run ( CDmiInterfaceThreadContext* pTC );

private:
	//void		MakeConnectString( LPWSTR, CString& );
	BOOL		m_bRun;

	void		HandleWMU( MSG& msg );
	void		MessageLoop ( );



	friend void dmiReadNode ( LPWSTR , CNode* , CDmiError* );

	friend void dmiReadComponents ( LPWSTR pNWA , 
		CComponents* pNewComponents , CDmiError* );

	friend void dmiReadComponent ( LPWSTR pNWA , LONG lComponent , 
		CComponent* pNewComponent  , CDmiError* );

	friend void dmiReadGroups ( LPWSTR pNWA , LONG lComponent , 
		CGroups* pNewGroups  , CDmiError* );

	friend void dmiReadGroup ( LPWSTR pNWA , LONG lComponent , LONG lGroup , 
		CGroup* pNewGroup  , CDmiError* );

	friend void dmiReadRows ( LPWSTR wszNWA , LONG lComponent , LONG lGroup ,
		CRows* pNewRows  , CDmiError* );

	friend void dmiReadRow ( LPWSTR wszNWA , LONG lComponent , LONG lGroup ,
		CAttributes* pKeys , CRow* pNewRow  , CDmiError* );

	friend void dmiReadEnum ( LPWSTR pNWA , LONG lComponent , LONG lGroup ,
		LONG lAttribute , CEnum* pNewEnum  , CDmiError* );

	friend void dmiReadLanguages ( LPWSTR pNWA , LONG lComponent , 
		CLanguages* pNewLanguages  , CDmiError* );

	friend void dmiAddComponent ( LPWSTR wszNWA , LPWSTR pMifFile , 
		CDmiError* );
	
	friend void dmiDeleteComponent ( LPWSTR wszNWA , LONG  , CDmiError* );

	friend void dmiAddLanguage ( LPWSTR pNWA , LONG lComponent , 
		LPWSTR pMifFile  , CDmiError* );

	friend void dmiDeleteLanguage ( LPWSTR pNWA , LONG lComponent , 
		LPWSTR pszLanguage  , CDmiError* );

	friend void dmiAddGroup ( LPWSTR wszNWA , LONG lComponent , 
		LPWSTR wszMifFile , CDmiError* );

	friend void dmiDeleteGroup ( LPWSTR , LONG , LONG , CDmiError* );

	friend void dmiAddRow ( LPWSTR , LONG lComponent , LONG lGroup , CRow* ,
		CDmiError* );

	friend void dmiModifyRow ( LPWSTR , LONG lComponent , LONG lGroup , 
		CAttributes* pKeys , CRow* , CDmiError* );

	friend void dmiDeleteRow ( LPWSTR , LONG lComponent , LONG lGroup , 
		CAttributes* pKeys , CDmiError* );

	friend void dmiSetDefaultLanguage ( LPWSTR , LPWSTR , CDmiError* );

	friend void dmiEnableEvents ( LPWSTR , IWbemObjectSink* );

	
};


//////////////////////////////////////////////////////////////////

void ApartmentThread ( void* pTC)
{
	CDmiInterfaceThread DDT;

	DDT.Run ( (CDmiInterfaceThreadContext* ) pTC );	

	_endthread ( );

	return;

}

CDmiInterfaceThread::CDmiInterfaceThread()
{
	m_bRun = TRUE;
}


CDmiInterfaceThread::~CDmiInterfaceThread()
{
	m_bRun = FALSE;	
}


void CDmiInterfaceThread::Run ( CDmiInterfaceThreadContext* pTC )
{		
	MSG	msg;

	pTC->m_dwThreadId = GetCurrentThreadId ( );

	// force the creation of the message loop 
	PeekMessage( &msg, NULL, WM_USER, WM_USER, PM_NOREMOVE );	

	// Signal that we have a valid thread ID and the thread message loop has 
	// been created.  It is now safe to call PostThreadMessage() to send 
	// messages to the threads.
	SetEvent ( pTC->m_Started ) ;

	// Initialize this thread as an apartment thread
	CoInitialize ( NULL );

	// run the message loop
	while ( m_bRun )
	{
		DWORD t_Event = MsgWaitForMultipleObjects ( 1, &((pTC)->m_hStopThread) , FALSE ,
			10000 , QS_ALLINPUT ) ;
	switch ( t_Event ) 
		{
			
		case WAIT_OBJECT_0:
			{
				m_bRun = FALSE;

				break;
			}
		case WAIT_OBJECT_0 + 1:
			{
				MessageLoop ( );

				break;
			}
		case WAIT_TIMEOUT:
			{
				m_bRun = TRUE;

				break;
			}
		default:
			{
				break;
			}
		}
	};

	SetEvent ( pTC->m_hComplete );

	CoUninitialize ( );
}


void CDmiInterfaceThread::MessageLoop ( )
{
	MSG msg;
	while ( PeekMessage ( &msg , NULL , 0 , 0 , PM_REMOVE ) )
	{
		HandleWMU ( msg );
	}
}



void CDmiInterfaceThread::HandleWMU( MSG& msg )
{

// Dump the messages that we've received for the thread.  The output will go
// to \\wbem\logs\messages.log
#if defined(TRACE_MESSAGES)
#if 0
	STAT_MESSAGE ( L"Called HandleWMU( m_dwThreadId = %lX, msg.message = %lX, \
msg.wParam = %lX, msg.lParam = %lX )\n\n", GetCurrentThreadId (),msg.message, msg.wParam, \
msg.lParam);
#else
		STAT_MESSAGE ( L"Receive ( msg = %lX, \
wParam = %lX, lParam = %lX )", msg.message, msg.wParam, \
msg.lParam);
#endif

#endif // TRACE_MESSAGES

	CDmiInterfaceJobContext* pJob = ( CDmiInterfaceJobContext*) msg.wParam;	

	try 
	{
		switch ( msg.message )
		{
		case WMU_GETCOMPONENT:
			{	
				dmiReadComponent ( pJob->pNWA , pJob->lComponent , pJob->pComponent ,
					pJob->pError );

				pJob->pComponent->SetNWA ( pJob->pNWA );				

				break;
			}
		case WMU_GETCOMPONENTS:
			{
				dmiReadComponents ( pJob->pNWA , pJob->pComponents , pJob->pError );

				pJob->pComponents->SetNWA ( pJob->pNWA );

				break;
			}							
		case WMU_GETROW:
			{
				dmiReadRow ( pJob->pNWA , pJob->lComponent , pJob->lGroup , 
 					pJob->pKeys , pJob->pRow , pJob->pError);

				pJob->pRow->SetData ( pJob->pNWA , pJob->lComponent , 
					pJob->lGroup );				

				break;
			}
		case WMU_GETNODE:
			{
				dmiReadNode ( pJob->pNWA , pJob->pNode , pJob->pError);

				pJob->pNode->SetNWA ( pJob->pNWA );

				break;
			}
			
		case WMU_ADDCOMPONENT:
			{
				dmiAddComponent ( pJob->pNWA , pJob->pszData , pJob->pError );

				break;
			}

		case WMU_DELETECOMPONENT:
			{
				dmiDeleteComponent ( pJob->pNWA , pJob->lComponent , pJob->pError);

				break;
			}

		case WMU_ADDGROUP:
			{
				dmiAddGroup ( pJob->pNWA , pJob->lComponent , pJob->pszData ,
					pJob->pError );				

				break;
			}
		case WMU_GETGROUPS:
			{
				dmiReadGroups ( pJob->pNWA , pJob->lComponent , pJob->pGroups ,
					pJob->pError );				

				pJob->pGroups->SetNWA ( pJob->pNWA );
				pJob->pGroups->SetComponent ( pJob->lComponent );

				break;
			}

		case WMU_GETGROUP:
			{
				dmiReadGroup ( pJob->pNWA , pJob->lComponent , pJob->lGroup ,
					pJob->pGroup , pJob->pError);				

				pJob->pGroup->SetNWA ( pJob->pNWA );
				pJob->pGroup->SetComponent ( pJob->lComponent );

				break;
			}

		case WMU_DELETEGROUP:
			{
				dmiDeleteGroup ( pJob->pNWA , pJob->lComponent , pJob->lGroup , 
					pJob->pError);

				break;
			}

		case WMU_ADDLANGUAGE:
			{
				dmiAddLanguage ( pJob->pNWA , pJob->lComponent , pJob->pszData , 
					pJob->pError);

				break;

			}

		case WMU_DELETELANGUAGE:
			{
				dmiDeleteLanguage ( pJob->pNWA , pJob->lComponent , pJob->pszData , 
					pJob->pError);

				break;
			}

		case WMU_GETENUM:
			{
				dmiReadEnum ( pJob->pNWA , pJob->lComponent , pJob->lGroup , 
					pJob->lAttribute , pJob->pEnum , pJob->pError);				

				pJob->pEnum->SetNWA ( pJob->pNWA );
				pJob->pEnum->SetComponent ( pJob->lComponent);
				pJob->pEnum->SetGroup ( pJob->lGroup );
				pJob->pEnum->SetAttrib ( pJob->lAttribute );

				break;
			}
		case WMU_SETLANG:
			{
				dmiSetDefaultLanguage ( pJob->pNWA , pJob->pszData , pJob->pError);

				break;
			}
		case WMU_GETLANGUAGES:
			{
				dmiGetLanguages ( pJob->pNWA , pJob->lComponent , pJob->pLanguages , 
					pJob->pError);

				break;
			}

		case WMU_GETROWS:
			{
				dmiReadRows ( pJob->pNWA , pJob->lComponent , pJob->lGroup , 
					pJob->pRows , pJob->pError);

				pJob->pRows->SetData ( pJob->pNWA , pJob->lComponent , 
					pJob->lGroup );

				break;
			}
		case WMU_ENABLEEVENTS:
			{
				dmiEnableEvents ( pJob->pNWA , pJob->pIClientSink );

				break;
			}	

		case WMU_DELETEROW:
			{
				dmiDeleteRow ( pJob->pNWA , pJob->lComponent , pJob->lGroup , 
					pJob->pKeys , pJob->pError);

				break;

			}
		case WMU_UPDATEROW:
			{
				dmiModifyRow ( pJob->pNWA , pJob->lComponent , pJob->lGroup , 
					pJob->pKeys , pJob->pRow , pJob->pError);

				break;
			}

		case WMU_ADDROW:
			{
				dmiAddRow ( pJob->pNWA , pJob->lComponent , pJob->lGroup , 
					pJob->pRow , pJob->pError );

				break;
			}

		default:

			{
			DispatchMessage ( &msg );

			break;
			}
		}
	}  // end try
	catch ( CException& e )
	{
		pJob->pError->SetWbemError ( e.WbemError () );
		pJob->pError->SetDescription ( e.DescriptionId () );
		pJob->pError->SetOperation ( e.OperationId () );
	}

	SetEvent ( ( HANDLE ) msg.lParam );
}

//////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////

CDmiInterface::CDmiInterface()
{
	m_bInit = FALSE;

	m_TC.StartThread ( );
}


CDmiInterface::~CDmiInterface()
{

}

void CDmiInterface::ShutDown ()
{
	m_TC.KillThread ();
}

void CDmiInterface::SendThreadMessage ( UINT msg , WPARAM wparam )
{
	LPARAM		lparam;
	CDmiError	Error;


	((CDmiInterfaceJobContext*)wparam)->pError = &Error;

	lparam = ( LONG ) CreateEvent ( NULL , FALSE , FALSE , NULL );

	// Wait to make sure that the we have a valid m_dwThreadID obtained in 
	// the Run() method before we attempt sending messages to the threads.
	if ( ! ( WaitForSingleObject ( m_TC.m_Started , INFINITE ) == WAIT_OBJECT_0 ) ) 
	{
		throw CException ( Error.WbemError() , Error.Description () , 
			Error.Reason () );
	}

// Dump the messages that we are going to send to the thread.  The output
// will go to \\wbem\logs\messages.log
#if defined(TRACE_MESSAGES)
#if 0
	STAT_MESSAGE ( L"Called SendThreadMessage( m_dwThreadId = %lX, \
msg = %lX, wParam = %lX, lparam = %lX )\n\n", m_TC.m_dwThreadId, msg, wparam, lparam );
#else
	STAT_MESSAGE ( L"Sending ( msg = %lX, wParam = %lX, lparam = %lX )", msg, wparam, lparam );
#endif

#endif // TRACE_MESSAGES

	
	BOOL t_PostStatus = PostThreadMessage ( m_TC.m_dwThreadId , msg , wparam , lparam);
	if ( ! t_PostStatus ) 
	{
		DWORD t_GetLastError = GetLastError () ;
		throw CException ( Error.WbemError() , Error.Description () , 
			Error.Reason () );
	}

	WaitForSingleObject ( ( HANDLE ) lparam , INFINITE );

	CloseHandle ( ( HANDLE ) lparam );

	if ( Error.HaveError () )
	{
		throw CException ( Error.WbemError() , Error.Description () , 
			Error.Reason () );
	}
}


void CDmiInterface::GetComponent ( LPWSTR pNWA  , LONG lComponent , 
								  CComponent* pComponent )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.pComponent = pComponent;

	SendThreadMessage ( WMU_GETCOMPONENT , ( WPARAM ) &DmiC );
}


void CDmiInterface::GetComponents ( LPWSTR pNWA , 
								   CComponents* pNewComponents )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.pComponents = pNewComponents;

	SendThreadMessage ( WMU_GETCOMPONENTS , ( WPARAM ) &DmiC );

}


void CDmiInterface::AddComponent ( LPWSTR pNWA  , CVariant& cvMifFile )
{	
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.pszData = cvMifFile.GetBstr();

	SendThreadMessage ( WMU_ADDCOMPONENT , ( WPARAM ) &DmiC );

}


void CDmiInterface::DeleteComponent ( LPWSTR pNWA  , LONG lComponent )
{		
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	SendThreadMessage ( WMU_DELETECOMPONENT , ( WPARAM ) &DmiC );

}


void CDmiInterface::AddGroup ( LPWSTR pNWA  , LONG lComponent , 
							  CVariant& cvMifFile )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.pszData = cvMifFile.GetBstr();

	SendThreadMessage ( WMU_ADDGROUP , ( WPARAM ) &DmiC );

}


void CDmiInterface::AddLanguage ( LPWSTR pNWA , LONG lComponent , 
							  CVariant& cvMifFile )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.pszData = cvMifFile.GetBstr();

	SendThreadMessage ( WMU_ADDLANGUAGE , ( WPARAM ) &DmiC );

}



void CDmiInterface::DeleteLanguage ( LPWSTR pNWA , LONG lComponent , 
							  CVariant& cvLanguage )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.pszData = cvLanguage.GetBstr();

	SendThreadMessage ( WMU_DELETELANGUAGE , ( WPARAM ) &DmiC );

}


void CDmiInterface::GetEnum ( LPWSTR pNWA  , LONG lComponent , LONG lGroup ,
				LONG lAttribute , CEnum* pNewEnum )		
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.lGroup = lGroup;

	DmiC.lAttribute = lAttribute;

	DmiC.pEnum = pNewEnum;

	SendThreadMessage ( WMU_GETENUM , ( WPARAM ) &DmiC );
}



void CDmiInterface::DeleteRow ( LPWSTR pNWA  , LONG lComponent , LONG lGroup ,
				CAttributes& Keys )		
{

	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.lGroup = lGroup;

	DmiC.pKeys = &Keys;

	SendThreadMessage ( WMU_DELETEROW , ( WPARAM ) &DmiC );
}


void CDmiInterface::UpdateRow ( LPWSTR pNWA  , LONG lComponent , LONG lGroup ,
				CAttributes& Keys , CRow* pNewRowValues )		
{

	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.lGroup = lGroup;

	DmiC.pKeys = &Keys;

	DmiC.pRow = pNewRowValues;

	SendThreadMessage ( WMU_UPDATEROW , ( WPARAM ) &DmiC );

	


}

void CDmiInterface::GetRows ( LPWSTR pNWA  , LONG lComponent , LONG lGroup ,
				CRows* pNewRows )		 
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.lGroup = lGroup;

	DmiC.pRows = pNewRows;

	SendThreadMessage ( WMU_GETROWS , ( WPARAM ) &DmiC );

}

void CDmiInterface::GetRow ( LPWSTR pNWA  , LONG lComponent , LONG lGroup ,
				CAttributes& Keys , CRow* pNewRow )		
{
	
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.lGroup = lGroup;

	DmiC.pKeys = &Keys;

	DmiC.pRow = pNewRow;

	SendThreadMessage ( WMU_GETROW , ( WPARAM ) &DmiC );

}



void CDmiInterface::DeleteGroup ( LPWSTR pNWA , LONG lComponent , 
				LONG lGroup )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.lGroup = lGroup;

	SendThreadMessage ( WMU_DELETEGROUP , ( WPARAM ) &DmiC );
}



void CDmiInterface::AddRow ( LPWSTR pNWA  , LONG lComponent , LONG lGroup , 
				CRow& Row)
{

	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.lGroup = lGroup;

	DmiC.pRow = &Row;

	SendThreadMessage ( WMU_ADDROW , ( WPARAM ) &DmiC );



}



void CDmiInterface::GetGroup ( LPWSTR pNWA , LONG lComponent , LONG lGroup ,
				CGroup* pNewGroup )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.lGroup = lGroup;

	DmiC.pGroup = pNewGroup;

	SendThreadMessage ( WMU_GETGROUP , ( WPARAM ) &DmiC );

}


void CDmiInterface::GetGroups ( LPWSTR pNWA , LONG lComponent , CGroups* pNewGroups )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.pGroups = pNewGroups;

	SendThreadMessage ( WMU_GETGROUPS , ( WPARAM ) &DmiC );
}


void CDmiInterface::GetNode ( LPWSTR pNWA  , CNode* pNewNode )
{	
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.pNode = pNewNode;

	SendThreadMessage ( WMU_GETNODE , ( WPARAM ) &DmiC );

}



void CDmiInterface::SetDefLanguage ( LPWSTR pNWA  , CVariant& cvLanguage )
{
	
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.pszData = cvLanguage.GetBstr();

	SendThreadMessage ( WMU_SETLANG , ( WPARAM ) &DmiC );
}


void CDmiInterface::GetLanguages ( LPWSTR pNWA , LONG lComponent , 
								  CLanguages* pNewLanguage )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;

	DmiC.lComponent = lComponent;

	DmiC.pLanguages = pNewLanguage;

	SendThreadMessage ( WMU_GETLANGUAGES , ( WPARAM ) &DmiC );
}			

void CDmiInterface::EnableEvents ( LPWSTR pNWA , IWbemObjectSink*	pIClientSink )
{
	CDmiInterfaceJobContext		DmiC;

	DmiC.pNWA = pNWA;
	DmiC.pIClientSink = pIClientSink;

	SendThreadMessage ( WMU_ENABLEEVENTS , ( WPARAM ) &DmiC );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmipch.cpp ===
#include "dmipch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmilayer.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#include "dmipch.h"

#include "WbemDmiP.h"

#include "ocidl.h"

#include "DmiData.h"

#include "DmiInterface.h"

#include "Strings.h"

#include "Exception.h"

#include "Trace.h"

#include "CimClass.h"

#include "WbemLoopBack.h"

#include "Mapping.h"

#include "MOTObjects.h"

#include "AsyncJob.h"


// the HOLD_CONNECTION constant is used to set weather or not
// the DMIP holds a connected IDualMgmt Node for it's life time.
// If HOLD_CONNECTION 
#define HOLD_CONNECTION 1


void MakeConnectString( LPWSTR wszNWA, CString& cszConnectString )
{
	CString cszConnectPath(wszNWA);

	// If it's not a local connection, it must be 
	// a TCP|IP connection.  See if it contains the 
	// DCE|TCP|IP string.
	if(MATCH != wcsicmp(wszNWA, LOCAL))
	{
		// Add the DCE|TPC|IP| prefix if the path does
		// not already have it.
		if ( !cszConnectPath.Contains( CONNECT_PREFIX ) )
		{
			cszConnectString.Set( CONNECT_PREFIX );
			cszConnectString.Append( wszNWA );
		}
		else
			cszConnectString.Set( wszNWA );	
	}
	else
		cszConnectString.Set( wszNWA );	
}


CConnection::CConnection ()
{
	m_pINode = NULL;
	m_pNext = NULL;
}

void CConnection::Init ( LPWSTR pNode )
{
	CString cszPath;
	VARIANT_BOOL	vbConnect = FALSE;
	SCODE			result;

	m_cszNWA.Set ( pNode );

	MakeConnectString ( pNode , cszPath );

	if ( FAILED ( CoCreateInstance (CLSID_DMIMgmtNode, NULL, EXE_TYPE, 
				IID_IDualMgmtNode, (void**) &m_pINode ) ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_GETNODE_FAIL , 
			IDS_CC_FAIL );	
	}

	CBstr	cbPath;

	cbPath.Set ( cszPath );

	result = m_pINode->Connect ( cbPath , &vbConnect);

	if ( vbConnect == VARIANT_FALSE || FAILED ( result ) )
	{
		// todo fix error
		throw CException ( WBEM_E_FAILED , IDS_GETNODE_FAIL , 
			IDS_CC_FAIL );	
	}

	MOT_TRACE ( L"\tMOT Node Connect");

}

void CConnection::Disconnect ( )
{
	VARIANT_BOOL	vbDone;		
	SCODE			result;

	result = m_pINode->Disconnect ( &vbDone );

	MOT_TRACE ( L"\tMOT Node Disconnect vbDone = %lu result = %lu " , vbDone , result );
	
}

CConnection::~CConnection ()
{	
	if ( m_pINode )
	{
		long l = m_pINode->Release ( );

		MOT_TRACE ( L"\tMOT Node Release = %lu" , l );

		m_pINode = NULL;
	}
}


CConnections::CConnections( )
{
	m_pFirst = NULL;
	
	m_pCurrent = NULL;
}

CConnections::~CConnections ( )
{
	ClearAll( );
}


void CConnections::ClearAll ( )
{
	if(!m_pFirst)
		return;

	MoveToHead( );

	CConnection* p = NULL;

	while(m_pCurrent)
	{
		p = m_pCurrent;

		m_pCurrent->Disconnect();

		m_pCurrent = m_pCurrent->m_pNext;

		MYDELETE ( p );
	}

	m_pFirst = NULL;
}


void CConnections::MoveToHead ()
{
	m_pCurrent = m_pFirst;
}

CConnection* CConnections::Next ()
{
	if(!m_pCurrent)
	{
		// there are no items in the list on start or we have gone through 
		// the entire list
		return NULL; 			
	}
	
	CConnection* p = m_pCurrent;  
	
	// get ready for next pass through

	m_pCurrent = m_pCurrent->m_pNext; 
		
	return p;

}

void CConnections::Add ( CConnection* pAdd , LPWSTR pNWA )
{
	pAdd->Init( pNWA );

	if (!m_pFirst)
	{
		m_pFirst = pAdd;
	}
	else
	{
		CConnection* p = m_pFirst;

		while (p->m_pNext)
			p = p->m_pNext;

		p->m_pNext = pAdd;
	}
	
}

void CConnections::Remove (  LPWSTR pNWA)
{
}

BOOL CConnections::CheckIfAlready ( LPWSTR pNWA )
{
#if HOLD_CONNECTION
	MoveToHead ();

	while( m_pCurrent )
	{
		if ( m_pCurrent->NWA().Equals ( pNWA ) )
			return TRUE;	// Node exists in the list

		Next();
	}

	CConnection* pNew = new CConnection;

	Add ( pNew , pNWA );
	return FALSE;	// Node does not exist.  It's newly created
	
#endif

}



////////////////////////////////////////////////////////////////

CConnections* _fConnections = NULL ;


////////////////////////////////////////////////////////////////
void dmiReadComponent ( LPWSTR wszNWA , LONG lComponent , 
					   CComponent* pComponent , CDmiError* pError )
{
	CDComponentI	IDC;
	CString			cszPath;
	SCODE			result = WBEM_NO_ERROR;

	_fConnections->CheckIfAlready ( wszNWA );

	//MOT_TRACE ( L"\tdmiReadComponent ( %s , %lu )" , wszNWA , lComponent );

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append( PIPE_STR );

	cszPath.Append( lComponent );	

	IDC.CoCreate ( );
	
	IDC.Read( cszPath );
	
	pComponent->Read ( IDC );

	IDC.Release ( );
}


void dmiReadComponents ( LPWSTR wszNWA , CComponents* pNewComponents  ,
						CDmiError* pError )
{
	CDMgmtNodeI			DMNI;
	CDComponentsI		DCSI;
	CUnknownI			Unk;
	CEnumVariantI		Enum;
	CString				cszPath;	

	_fConnections->CheckIfAlready ( wszNWA );

	MOT_TRACE ( L"\tdmiReadComponents ( %s )" , wszNWA );

	DMNI.CoCreate ( );

	MakeConnectString( wszNWA, cszPath );

	DMNI.Read ( cszPath );

	DMNI.GetComponents( DCSI );

	DCSI.GetUnk ( Unk );

	// Get pointer to IEnumVariant interface of from IUNKNOWN
	Unk.GetEnum ( Enum);

	CVariant	cvComponent;	
	
	while ( Enum.Next( cvComponent ) )
	{
		CDComponentI		DCI;

		// Get pointer to IDualComponents interface

		DCI.QI ( cvComponent );

		CComponent* pComponent = (CComponent*) new CComponent();

		if( !pComponent )
		{
			throw CException ( WBEM_E_OUT_OF_MEMORY , 
				IDS_MOT_COMPONENTS_READ , IDS_NO_MEM );
		}

		pComponent->Read( DCI );

		pNewComponents->Add(pComponent);

		DCI.Release();

		cvComponent.Clear( );
	}

	pNewComponents->MoveToHead();	

	pNewComponents->m_bFilled = TRUE;

	Enum.Release ( );
	Unk.Release ( );
	DCSI.Release ( );
	DMNI.Release ( );
}


void dmiReadRow ( LPWSTR wszNWA , LONG lComponent , LONG lGroup ,
				CAttributes* pKeys , CRow* pNewRow ,  CDmiError* pError )		
{
	_fConnections->CheckIfAlready ( wszNWA );

	MOT_TRACE ( L"\tdmiReadRow ( %s , %lu , %lu )" , wszNWA , lComponent, lGroup );

	CString cszPath;

	// 1. contruct path

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lComponent );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lGroup );	
	
	if ( pKeys->Empty () )
	{
		cszPath.Append ( PIPE_STR );

		// if row is scalar	
		cszPath.Append ( SCALAR_STR );
	}
	else
	{
		 CString cszT;

		 pKeys->GetMOTPath ( cszT );

		cszPath.Append ( cszT );
	}

	// Contruct and read the row
	CDRowI		DRI;

	DRI.CoCreate ( );

	if ( DRI.Read ( cszPath ) )
	{

		pNewRow->Read ( DRI );

		return;
	}

	//don't throw error here incase read was for modify row

	DRI.Release ();
}


void dmiReadNode ( LPWSTR wszNWA , CNode* pNewNode , CDmiError* pError )
{
	_fConnections->CheckIfAlready ( wszNWA );

	MOT_TRACE ( L"\tdmiReadNode ( %s )" , wszNWA );

	CString cszPath;

	// 1. contruct path

	MakeConnectString( wszNWA, cszPath );

	// 2. Construct the node object
	CDMgmtNodeI		DNI;

	DNI.CoCreate ( );

	// 3. Read the node object

	DNI.Read ( cszPath );

	pNewNode->Read ( DNI );
}


void dmiAddComponent ( LPWSTR wszNWA , LPWSTR wszMif  , CDmiError* pError )
{
	_fConnections->CheckIfAlready ( wszNWA );

	CString cszPath;
	CVariant cvMifFile;

	cvMifFile.Set ( wszMif );

	// 1. contruct path

	MakeConnectString( wszNWA, cszPath );

	// 2. Construct the node object
	CDMgmtNodeI		DNI;

	DNI.CoCreate ( );

	// 3. Read the node object

	DNI.Read ( cszPath );
	
	// 4. Add the component

	DNI.AddComponent ( cvMifFile );

}


void dmiDeleteComponent ( LPWSTR wszNWA , LONG lComponent  , CDmiError* pError )
{
	_fConnections->CheckIfAlready ( wszNWA );

	CString cszPath;

	// 1. contruct path

	MakeConnectString( wszNWA, cszPath );

	// 2. Construct the node object
	CDMgmtNodeI		DNI;

	DNI.CoCreate ( );

	// 3. Read the node object

	DNI.Read ( cszPath );
	
	// 4. Add the component

	DNI.DeleteComponent ( lComponent );
}


void dmiAddGroup ( LPWSTR wszNWA , LONG lComponent , 
				LPWSTR wszMif  , CDmiError* pError )
{
	_fConnections->CheckIfAlready ( wszNWA );

	CDComponentI	IDC;
	CDGroupsI		IDGS;
	CString			cszPath;
	SCODE			result = WBEM_NO_ERROR;
	CVariant		cvMifFile;

	cvMifFile.Set ( wszMif );

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append( PIPE_STR );

	cszPath.Append( lComponent );	

	IDC.CoCreate ( );

	IDC.Read( cszPath );
	
	IDC.GetGroups ( IDGS );

	IDGS.Add ( cvMifFile );
}


void dmiReadGroups ( LPWSTR wszNWA , LONG lComponent , 
				CGroups* pNewGroups  , CDmiError* pError )
{
	_fConnections->CheckIfAlready ( wszNWA );

	MOT_TRACE ( L"\tdmiReadGroups ( %s , %lu )" , wszNWA , lComponent );

	CDComponentI	IDC;
	CDGroupsI		IDGS;
	CString			cszPath;

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append( PIPE_STR );

	cszPath.Append( lComponent );	

	IDC.CoCreate ( );

	IDC.Read( cszPath );
	
	IDC.GetGroups ( IDGS );

	pNewGroups->Read ( IDGS );
}


void dmiReadGroup ( LPWSTR wszNWA , LONG lComponent , 
							LONG lGroup , CGroup* pNewGroup  , CDmiError* pError )
{
	_fConnections->CheckIfAlready ( wszNWA );

	MOT_TRACE ( L"\tdmiReadGroup ( %s , %lu , %lu )" , wszNWA , lComponent, lGroup );

	CDGroupI		IDG;
	CString			cszPath;
	SCODE			result = WBEM_NO_ERROR;

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append( PIPE_STR );

	cszPath.Append( lComponent );	

	cszPath.Append( PIPE_STR );

	cszPath.Append( lGroup );	

	IDG.CoCreate ( );

	IDG.Read( cszPath );
	
	BOOL	bComponentIdGroup;

	pNewGroup->Read ( IDG , FALSE , &bComponentIdGroup );
}

void dmiDeleteGroup ( LPWSTR wszNWA , LONG lComponent , LONG lGroup ,
					 CDmiError* pError )
{
	_fConnections->CheckIfAlready ( wszNWA );

	CDComponentI	IDC;
	CDGroupsI		IDGS;
	CString			cszPath;

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append( PIPE_STR );

	cszPath.Append( lComponent );	


	IDC.CoCreate ( );

	IDC.Read( cszPath );
	
	IDC.GetGroups ( IDGS );

	IDGS.Remove ( lGroup );
}


void dmiAddLanguage ( LPWSTR wszNWA , LONG lComponent , LPWSTR wszMifFile  ,
					 CDmiError* pError )
{
	_fConnections->CheckIfAlready ( wszNWA );

	CDComponentI	IDC;
	CDLanguagesI		IDLS;
	CString			cszPath;
	CString			cszMifFile ( wszMifFile );

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append( PIPE_STR );

	cszPath.Append( lComponent );	

	IDC.CoCreate ( );

	IDC.Read( cszPath );
	
	IDC.GetLanguages ( IDLS );

	IDLS.Add ( cszMifFile );
}

void dmiDeleteLanguage ( LPWSTR wszNWA , LONG lComponent , LPWSTR wszLanguage  ,
						CDmiError* )
{
	CDComponentI	IDC;
	CDLanguagesI		IDLS;
	CString			cszPath;
	CString			cszLanguage( wszLanguage );

	_fConnections->CheckIfAlready ( wszNWA );

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append( PIPE_STR );

	cszPath.Append( lComponent );	

	IDC.CoCreate ( );

	IDC.Read( cszPath );
	
	IDC.GetLanguages ( IDLS );

	IDLS.Remove ( cszLanguage );
}

void dmiReadEnum ( LPWSTR wszNWA , LONG lComponent , LONG lGroup ,
				  LONG lAttribute , CEnum* pNewEnum  , CDmiError* pError )
{
	_fConnections->CheckIfAlready ( wszNWA );

	CDAttributeI		DAI;
	CDAttributesI		DASI;
	CDEnumColI			DECI;
	CDGroupI			DGI;
	CString				cszPath;

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append( PIPE_STR );

	cszPath.Append( lComponent );	

	cszPath.Append( PIPE_STR );

	cszPath.Append( lGroup );	

	DGI.CoCreate ( );

	DGI.Read ( cszPath );

	DGI.GetAttributes ( DASI );

	DASI.Item ( lAttribute , DAI );

	DAI.GetDmiEnum ( DECI );

	pNewEnum->Read ( DECI );	
}


void dmiSetDefaultLanguage ( LPWSTR wszNWA , LPWSTR wszLanguage, 
							CDmiError* pError )
{	
	CString cszPath;

	_fConnections->CheckIfAlready ( wszNWA );

	// 1. contruct path

	MakeConnectString( wszNWA, cszPath );

	// 2. Construct the node object
	CDMgmtNodeI		DNI;

	DNI.CoCreate ( );

	// 3. Read the node object

	DNI.Read ( cszPath );
	
	// 4. set the language

	CBstr cbLanguage ( wszLanguage );

	DNI.PutLanguage (  cbLanguage );
}

void dmiGetLanguages ( LPWSTR wszNWA , LONG lComponent, 
					  CLanguages* pNewLanguages , CDmiError* pError )
{
	CDComponentI	IDC;
	CDLanguagesI	IDLS;
	CString			cszPath;

	_fConnections->CheckIfAlready ( wszNWA );

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append( PIPE_STR );

	cszPath.Append( lComponent );	

	IDC.CoCreate ( );

	IDC.Read( cszPath );
	
	IDC.GetLanguages ( IDLS );

	pNewLanguages->Read ( IDLS );
}



void dmiReadRows ( LPWSTR wszNWA , LONG lComponent, LONG lGroup , 
				  CRows* pNewRows , CDmiError* pError )
{
	CString cszPath;

	_fConnections->CheckIfAlready ( wszNWA );

	MOT_TRACE ( L"\tdmiReadRows ( %s , %lu , %lu )" , wszNWA , lComponent, lGroup );

	// 1. contruct path

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lComponent );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lGroup );

	// Contruct and read the rows
	CDGroupI		DGI;
	CDRowsI			DRSI;

	DGI.CoCreate ( );

	DGI.Read ( cszPath );

	DGI.GetRows ( DRSI );

	pNewRows->Read ( DRSI );
}


/////////////// MOT EVENTS /////////////////////////////////////////////////
#define		DISPID_DMI_EVENT				1
#define		DISPID_DMI_NOTIFICATION			2

#define		DISPID_DESCRIPTION				1
#define		DISPID_NOTIFICATION_LANGUAGE	2
#define		DISPID_NOTIFICATION				3

#define		DISPID_EVENT_LANGUAGE			1
#define		DISPID_ROWS						2
#define		DISPID_COMPID					3
#define		DISPID_EVENT_TIME				4
#define		DISPID_PATH						5


class CMOTEvent : public IDispatch
{
public:
	LONG				m_cRef;												//Object reference count
	_DualDMIEngine*		m_pIEngine;
	IConnectionPoint*	m_pConnPt;
	IDualMgmtNode*		m_pINode;
	DWORD				m_dwEventCookie;
	CString				m_cszNamespace;
	//CString				m_cszNWA;
	
						CMOTEvent ();
						~CMOTEvent ();

	void				Init ( LPWSTR wszNWA , IWbemObjectSink* pIWbemSink);

	IWbemObjectSink*	m_pCimomClient;

	void				HandleEvent( LCID, DISPPARAMS * );
	void				HandleNotification(  LCID, DISPPARAMS * );

	// IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch methods
	STDMETHODIMP		 GetTypeInfoCount(THIS_ UINT * );
	STDMETHODIMP		 GetTypeInfo(THIS_ UINT, LCID, ITypeInfo ** );
	STDMETHODIMP		 GetIDsOfNames(THIS_ REFIID , OLECHAR ** , UINT , LCID , DISPID* );

	STDMETHODIMP		 Invoke(THIS_ DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*);

	void				ExtrinsicEvent ( CVariant& cvCompId, CVariant& cvEventTime, CVariant& cvLanguage , CVariant& cvPath, IDualColRows* pIDRows ) ;
	void				AddComponentNotification( IDualComponent* pIDComponent );
	void				DeleteComponentNotification( IDualComponent* pIDComponent );
	void				AddGroupNotification( IDualGroup* pIDGroup );
	void				DeleteGroupNotification( IDualGroup* pIDGroup );
	void				AddLanguageNotification( CVariant& cvLanuguage );
	void				DeleteLanguageNotification( CVariant& cvLanuguage );

	CWbemLoopBack		m_Wbem;
};

CMOTEvent::CMOTEvent ( )
{
	m_cRef = 0;
	m_pIEngine = NULL;
	m_pConnPt = NULL;
	m_pINode = NULL;
	m_dwEventCookie =0;
	m_pCimomClient = NULL;
}

CMOTEvent::~CMOTEvent ( )
{
	m_cRef = 0;

	RELEASE ( m_pINode );
	RELEASE ( m_pConnPt );
	RELEASE ( m_pIEngine );

	// m_pCimomClient released by async trhead
}


void CMOTEvent::Init ( LPWSTR pNamespace , IWbemObjectSink* pIWbemSink)
{
	m_pCimomClient = pIWbemSink;

	// note need to do this addref in a free thread

	m_pCimomClient->AddRef ( );

	m_cszNamespace.Set ( pNamespace );

	m_Wbem.Init ( pNamespace );	
}


////////////// start mot events

//***************************************************************************
//								IUNKNOWN
//
// CDmiInterface::QueryInterface
// CDmiInterface::AddRef
// CDmiInterface::Release
//
// Purpose:
//  IUnknown members for CNotify object.
//***************************************************************************
STDMETHODIMP CMOTEvent::QueryInterface(REFIID riid, void** ppv)
{
    *ppv=NULL;

    if (IID_IUnknown == riid || IID_IDispatch == riid)
        *ppv = this;

    if (NULL != *ppv)
    {
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CMOTEvent::AddRef(void)
{

	return InterlockedIncrement ( & m_cRef );

}


STDMETHODIMP_(ULONG) CMOTEvent::Release(void)
{

	if ( 0L != InterlockedDecrement ( & m_cRef ) )
        return m_cRef;

    delete this;

    return WBEM_NO_ERROR;
}

//***************************************************************************
//								IDISPATCH
//
// CMOTEvent::GetTypeInfoCount
// CMOTEvent::GetTypeInfo
// CMOTEvent::GetIDsOfNames
// CMOTEvent::Invoke
//
// Purpose:
//			IDispatch members for CNotify object.
//***************************************************************************

STDMETHODIMP CMOTEvent::GetTypeInfoCount(UINT *pctInfo)
{
	// we don't support type information
	*pctInfo = 0;

	return WBEM_NO_ERROR;
}

STDMETHODIMP CMOTEvent::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
	pptinfo = NULL;
	return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP CMOTEvent::GetIDsOfNames(THIS_ REFIID riid, OLECHAR ** rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)			
{
	SCODE	result = ResultFromScode(DISP_E_UNKNOWNNAME);

	if(IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	rgdispid[0] = DISPID_UNKNOWN;
	
	return NO_ERROR;
}


STDMETHODIMP CMOTEvent::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, 
								   DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)					
{

	STAT_TRACE (  L"CMOTEvent::Invoke(), Event or Notification Recieved" ) ;


	if(IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);


	switch (dispidMember)
	{
	case DISPID_DMI_EVENT:
		{
			HandleEvent( lcid, pdispparams );

			break;
		}
	case DISPID_DMI_NOTIFICATION:	
		{
			HandleNotification( lcid, pdispparams );

			break;
		}
	default:
		{
			
		}
	}

	return NOERROR;
}


////////////////////////////////////////////////////////////////////////////////////////

void CMOTEvent::HandleEvent ( LCID lcid,  DISPPARAMS* dpParams )
{
	SCODE			result = WBEM_NO_ERROR;
	IEvent*			pIEvent = NULL;
	IDispatch*		pIDispatch = NULL;
	DISPPARAMS		dispparamsNoArgs = {NULL, NULL, 0, 0};
	IUnknown*		pIUnk = NULL;
	CVariant		cvEventTime, cvCompId, cvLanguage, cvPath, cvRows;
	IDualColRows*	pIDRows = NULL;				
	
			
	if ( FAILED ( ( ( IDispatch* )dpParams->rgvarg[0].pdispVal )->QueryInterface ( IID_IUnknown, (void **) &pIUnk )  ))
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );

			
	// Verify we are dealing with an event object.

	result = pIUnk->QueryInterface ( DIID_IEvent , (void **) &pIEvent );

	RELEASE ( pIEvent );

	if ( FAILED (  result  ))
	{
		RELEASE ( pIUnk );

		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );
	}

	
	// Get the dispatch interface so we can access the properites

	result = pIUnk->QueryInterface ( IID_IDispatch, (void **) &pIDispatch  ) ;

	RELEASE ( pIUnk );

	if ( FAILED ( result ) )
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );	

	// Get the CompId (LONG) 
	
	if ( FAILED ( pIDispatch->Invoke( DISPID_COMPID, IID_NULL, lcid, DISPATCH_PROPERTYGET, &dispparamsNoArgs, cvCompId, NULL, NULL ) ))
	{
		RELEASE ( pIDispatch );

		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );	
	}

	
	// Get the EventTime (STRING )

	if ( FAILED ( pIDispatch->Invoke( DISPID_EVENT_TIME, IID_NULL, lcid, DISPATCH_PROPERTYGET, &dispparamsNoArgs, cvEventTime, NULL, NULL ) ))
	{
		RELEASE ( pIDispatch );

		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );	
	}
	
	// Get the Language (STRING )

	if ( FAILED ( pIDispatch->Invoke( DISPID_EVENT_LANGUAGE, IID_NULL, lcid, DISPATCH_PROPERTYGET, &dispparamsNoArgs, cvLanguage, NULL, NULL ) ))
	{
		RELEASE ( pIDispatch );

		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );	
	}
	
	// Get the MachinePath ( STRING )
	
	if ( FAILED ( pIDispatch->Invoke( DISPID_PATH, IID_NULL, lcid, DISPATCH_PROPERTYGET, &dispparamsNoArgs, cvPath, NULL, NULL ) ))
	{
		RELEASE ( pIDispatch );

		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );	
	}

	// Get the Rows Object ( IDualColRows* )

	if ( FAILED ( pIDispatch->Invoke( DISPID_ROWS, IID_NULL, lcid, DISPATCH_PROPERTYGET, &dispparamsNoArgs, cvRows, NULL, NULL ) ))
	{
		RELEASE ( pIDispatch );

		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );	
	}

	// Now we are doing accessing the events properties release the Dispatch 
	// ptr

	RELEASE ( pIDispatch );
		
	if ( FAILED ( result ))
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );	
	
	if FAILED ( ( (IDispatch *)cvRows )->QueryInterface ( IID_IUnknown, (void **) &pIUnk  ) )
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );	

	result = pIUnk->QueryInterface ( IID_IDualColRows, (void **) &pIDRows  );

	RELEASE ( pIUnk );

	if ( FAILED (  result  ))
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );


	// send object to cimom client


	ExtrinsicEvent ( cvCompId, cvEventTime, cvLanguage , cvPath, pIDRows ) ;

	RELEASE ( pIDRows );

}

void CMOTEvent::HandleNotification ( LCID lcid,  DISPPARAMS* dpParams )
{	
	SCODE			result = WBEM_NO_ERROR;
	IDispatch*		pIDispatch = NULL;
	CVariant		cvDescription;
	CVariant		cvNotificationObject;
	CVariant		cvLanuguage;
	DISPPARAMS		dispparamsNoArgs = {NULL, NULL, 0, 0};
	IUnknown*		pIUnk = NULL;
	INotification*	pINotification = NULL;
	
			
	if ( FAILED ( ( ( IDispatch* )dpParams->rgvarg[0].pdispVal )->QueryInterface ( IID_IUnknown, (void **) &pIUnk )  ))
		throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );

			
	// Verify we are dealing with a notification object.

	result = pIUnk->QueryInterface ( DIID_INotification, (void **) &pINotification );

	RELEASE ( pINotification );

	if ( FAILED (  result  ))
	{
		RELEASE ( pIUnk );

		throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );
	}

	
	// Get the dispatch interface so we can access the properites

	result = pIUnk->QueryInterface ( IID_IDispatch, (void **) &pIDispatch  ) ;

	RELEASE ( pIUnk );


	if ( FAILED ( result ) )
		throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );

	/// Get the description string 
				
	if ( FAILED ( pIDispatch->Invoke( DISPID_DESCRIPTION, IID_NULL, lcid, DISPATCH_PROPERTYGET, &dispparamsNoArgs, cvDescription, NULL, NULL ) ))
	{
		RELEASE ( pIDispatch );

		throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );
	}

	
	// Get the Notification object

	CString cszDescription;

	cszDescription.Set ( cvDescription.GetBstr() ) ;

	if ( cszDescription.Contains (  L"component") )
	{
		// component added or deleted notification
		IDualComponent*pIDComponent = NULL;

		// get the component notification object
				
		result = pIDispatch->Invoke( DISPID_NOTIFICATION, IID_NULL, lcid, DISPATCH_PROPERTYGET, &dispparamsNoArgs, cvNotificationObject, NULL, NULL );

		RELEASE ( pIDispatch );
		
		if ( FAILED ( result ))
			throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );		
	
		// Get the IDualComponentInterface

		if FAILED ( ( (IDispatch *)cvNotificationObject )->QueryInterface ( IID_IUnknown, (void **) &pIUnk  ) )
			throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );			

		result = pIUnk->QueryInterface ( IID_IDualComponent, (void **) &pIDComponent  );

		RELEASE ( pIUnk );

		if ( FAILED (  result  ))
			throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );

		// call the mapping to create the appropreate objects	

		if ( cszDescription.Contains ( L"add") )
		{
			// component added

			AddComponentNotification( pIDComponent );
		}
		else
		{

			// component deleted

			DeleteComponentNotification( pIDComponent );
		}

		RELEASE ( pIDComponent );

		return;
	}


	if ( cszDescription.Contains ( L"group") )
	{
		// group added or deleted

		IDualGroup*	pIDGroup = NULL;

		// get the component notification object

		result = pIDispatch->Invoke( DISPID_NOTIFICATION, IID_NULL, lcid, DISPATCH_PROPERTYGET, &dispparamsNoArgs, cvNotificationObject, NULL, NULL );

		RELEASE ( pIDispatch );
		
		if ( FAILED ( result ))
			throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );		
	
		// Get the IDualComponentInterface

		if ( FAILED (  ( (IDispatch *)cvNotificationObject )->QueryInterface ( IID_IUnknown, (void **) &pIUnk  )  ))
			throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );			

		result = pIUnk->QueryInterface ( IID_IDualGroup , (void **) &pIDGroup  );

		RELEASE ( pIUnk );

		if ( FAILED ( result ))
			throw CException ( WBEM_E_FAILED , IDS_HANDLENOTIFICATION_FAIL , IDS_GEN );

		// call the mapping to create the appropreate objects		

		if ( cszDescription.Contains ( L"add") )
		{
			// group added

			AddGroupNotification( pIDGroup );
		}
		else
		{

			// group deleted

			DeleteGroupNotification( pIDGroup );
		}

		RELEASE ( pIDGroup );

		return;

	}

	// must be language

	/// Get the Language string 
				
	result = pIDispatch->Invoke( DISPID_NOTIFICATION_LANGUAGE , IID_NULL, lcid, DISPATCH_PROPERTYGET, &dispparamsNoArgs, cvLanuguage, NULL, NULL );

	RELEASE ( pIDispatch );
	
	if ( FAILED (  result ) )
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );	

	if ( cszDescription.Contains (  L"add") )
	{
		// Language added

		AddLanguageNotification( cvLanuguage );
	}
	else
	{

		// Language deleted

		DeleteLanguageNotification( cvLanuguage );
	}

}


//////////////////////////////////////////////////////////////////////////////////////////
void CMOTEvent::ExtrinsicEvent ( CVariant& cvCompId, CVariant& cvEventTime, CVariant& cvLanguage , 
																	CVariant& cvPath, IDualColRows* pIDRows ) 

{
	CVariant	cvKeys;
	IDualRow*	pIDRow = NULL;
	CEvent		Event;

	Event.SetComponent ( cvCompId.GetLong() );
	Event.SetTime ( cvEventTime.GetBstr () );
	Event.SetLanguage ( cvLanguage.GetBstr() );
	
	if ( FAILED ( pIDRows->GetFirstRow( cvKeys, &pIDRow ) ) )
		return;

	// next lines remarked because mot does not return expected row object
#if 0
	Event.m_Row.Read ( pIDRow );		

	CBstr	cbPath;

	pIDRow->get_Path ( cbPath );
		
	Event.SetGroup ( cbPath.GetLastIdFromPath(  ) ) ;

	Event.m_Row.SetData ( NULL , cvCompId.GetLong () , Event.Group () );

#endif

	Event.SetNWA ( m_Wbem.NWA( NULL ) );

	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data

	pJob->InitEvent ( Event , m_cszNamespace , m_pCimomClient , &m_Wbem );

}


void CMOTEvent::AddComponentNotification( IDualComponent* pIDComponent )
{
	CComponent	Component;

	// Create the instance of component that has been created	

	Component.Read ( pIDComponent );

	Component.SetNWA ( m_Wbem.NWA(  NULL )  );

	CString cszPath;

	// contruct path to component id group

	MakeConnectString( m_Wbem.NWA(  NULL )  , cszPath );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( Component.Id ( ) );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( 1 );

	cszPath.Append ( PIPE_STR );
	
	cszPath.Append ( SCALAR_STR );

	CDRowI		DRI;

	DRI.CoCreate ( );

	if ( ! DRI.Read ( cszPath ) )
		throw CException ( WBEM_E_FAILED , 0 , 0 );

	CRow	Row;

	Row.Read ( DRI );	

	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data

	pJob->InitAddComponentNotification ( Component , Row , m_cszNamespace
		, m_pCimomClient,  &m_Wbem  );
}


void CMOTEvent::DeleteComponentNotification( IDualComponent* pIDComponent )
{
	CComponent	Component;

	// Create the instance of component that has deleted to the greateset extent possible

	Component.Read ( pIDComponent );

	Component.SetNWA ( m_Wbem.NWA(  NULL )  );

	// contruct path to component id group

	CString cszPath;

	MakeConnectString( m_Wbem.NWA(  NULL )  , cszPath );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( Component.Id ( ) );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( 1 );

	cszPath.Append ( PIPE_STR );
	
	cszPath.Append ( SCALAR_STR );

	CDRowI		DRI;

	DRI.CoCreate ( );

	DRI.Read ( cszPath );

	CRow	Row;

	Row.Read ( DRI );	

	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data

	pJob->InitDeleteComponentNotification ( Component , Row
		, m_cszNamespace , m_pCimomClient , &m_Wbem  );
}


void CMOTEvent::AddGroupNotification( IDualGroup* pIDGroup )
{
	CGroup		Group;
	LONG		lComponentId;
	CBstr		cbPath;
	BOOL		bComponentId;

	// Create the group class

	Group.Read ( pIDGroup , FALSE , &bComponentId);

	Group.SetNWA ( m_Wbem.NWA(  NULL )  );

	pIDGroup->get_Path ( cbPath );

	lComponentId  = cbPath.GetComponentIdFromGroupPath ( );	

	Group.SetComponent ( lComponentId);

		// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data

	pJob->InitAddGroupNotification ( Group , m_cszNamespace ,
		m_pCimomClient  , &m_Wbem );

}

void CMOTEvent::DeleteGroupNotification( IDualGroup* pIDGroup )
{
	CGroup		Group;
	CComponent	Component;
	BOOL		bComponentId;
	CBstr		cbPath;
	long		lComponentId;

	// create the group class to the greatest extent possible

	Group.Read ( pIDGroup , TRUE , &bComponentId);

	Group.SetNWA ( m_Wbem.NWA(  NULL )  );

	pIDGroup->get_Path ( cbPath );

	lComponentId  = cbPath.GetComponentIdFromGroupPath ( );	

	Group.SetComponent ( lComponentId);

	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data

	pJob->InitDeleteGroupNotification ( Group , m_cszNamespace ,
		m_pCimomClient  , &m_Wbem );
}


void CMOTEvent::AddLanguageNotification( CVariant& cvLanguage )
{
	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data

	pJob->InitAddLanguageNotification ( cvLanguage , m_cszNamespace ,
		m_pCimomClient  , &m_Wbem );
}


void CMOTEvent::DeleteLanguageNotification( CVariant& cvLanguage )
{
	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data

	pJob->InitDeleteLanguageNotification ( cvLanguage , m_cszNamespace ,
		m_pCimomClient  , &m_Wbem );
}

/// end mot events




/////////////// End MOT EVENTS /////////////////////////////////////////////////


void dmiEnableEvents ( LPWSTR wszNamespace , IWbemObjectSink* pIWbemSink )
{
	SCODE			result = WBEM_NO_ERROR;
	VARIANT_BOOL	vbResult;


	CMOTEvent*		pEvents = new CMOTEvent;

	pEvents->Init ( wszNamespace , pIWbemSink );

	CString	cszConnect;
	MakeConnectString ( pEvents->m_Wbem.NWA ( NULL ) , cszConnect );

	// If the node already exists, we don't want to resubscribe for
	// events.
	if ( _fConnections->CheckIfAlready ( cszConnect ) )
	{
		delete pEvents;
		pEvents = NULL;
		return;
	}
	
	
//	pEvents->Init ( wszNamespace , pIWbemSink );
		
	if ( FAILED ( CoCreateInstance (CLSID_MOTDmiEngine, NULL , 
		CLSCTX_INPROC_SERVER , IID__DualDMIEngine, ( void ** )  &pEvents->m_pIEngine)))
	{
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );
	}

	// 2. register our sink with the engine

	IConnectionPointContainer*	pCPC = NULL;

	if ( FAILED ( pEvents->m_pIEngine->QueryInterface( 
		IID_IConnectionPointContainer, ( void ** )  &pCPC)))
	{
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );
	}

	result = pCPC->FindConnectionPoint(DIID__DDualintEvents, &pEvents->m_pConnPt);

	RELEASE ( pCPC );

	if ( FAILED ( result ) )
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );

	if ( FAILED ( pEvents->m_pConnPt->Advise( pEvents , &pEvents->m_dwEventCookie) ))
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );		

	pEvents->m_pConnPt->AddRef() ;

	if ( FAILED ( CoCreateInstance (CLSID_DMIMgmtNode, NULL , EXE_TYPE , 
		IID_IDualMgmtNode , ( void ** )  &pEvents->m_pINode )))
	{		
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );		
	}		

	
	CBstr cbConnect;

	cbConnect.Set ( cszConnect );

	result = pEvents->m_pINode->Connect( cbConnect , &vbResult);	

	if ( FAILED ( result ) || vbResult == VARIANT_FALSE)
	{		
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );		
	}		
	
	// Register to recieve events

	result = pEvents->m_pIEngine->EnableEvents ( pEvents->m_pINode, &vbResult );

	if ( FAILED ( result ) || vbResult == VARIANT_FALSE )
	{		
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );		
	}		

	result = pEvents->m_pIEngine->EnableNotifications ( pEvents->m_pINode, &vbResult );

	if ( FAILED ( result ) || vbResult == VARIANT_FALSE )
	{		
		throw CException ( WBEM_E_FAILED , IDS_EVENT_INIT_FAIL , IDS_GEN );		
	}		

}



void dmiDisableEvents ( )
{
}

void dmiDeleteRow ( LPWSTR wszNWA , LONG lComponent , LONG lGroup , 
		CAttributes* pKeys , CDmiError* pError )
{
	CRow	Row;
	CRows	Rows;
	CString cszPath;

	_fConnections->CheckIfAlready ( wszNWA );

	// 1. contruct path to the group;

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lComponent );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lGroup );

	// 2. read the group
	CDGroupI	DGI;
	CDRowsI		DRSI;

	DGI.CoCreate ();

	DGI.Read ( cszPath );

	// 3. Get the rows collection from which
	// row is to be remove

	DGI.GetRows ( DRSI );

	// 5. now do the the remove

	DRSI.Remove ( pKeys );

}


void dmiModifyRow ( LPWSTR wszNWA , LONG lComponent , LONG lGroup , 
		CAttributes* pKeys , CRow* pNewRow, CDmiError* )
{
	SCODE	result;
	CString cszPath;

	_fConnections->CheckIfAlready ( wszNWA );

	// 1. contruct path to the row;

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lComponent );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lGroup );

	if ( pKeys->Empty () )
	{
		cszPath.Append ( PIPE_STR );

		// if row is scalar	
		cszPath.Append ( SCALAR_STR );
	}
	else
	{
		 CString cszT;

		 pKeys->GetMOTPath ( cszT );

		cszPath.Append ( cszT );
	}

	// Contruct and read the row
	CDRowI		DRI;

	DRI.CoCreate ( );

	DRI.Read ( cszPath );

	CDAttributesI DASI;

	DRI.GetAttributes ( DASI );

	pNewRow->m_Attributes.MoveToHead();

	CAttribute* pAttribute = NULL;

	CVariant		cvId;
	CVariant		cvNewValue;
	CVariant		cvT;

	while ( pAttribute = pNewRow->m_Attributes.Next() )
	{
		CDAttributeI	DAI;

		cvId.Clear ( );
		cvNewValue.Clear ( );
		cvT.Clear ( );

		
		// change the sp data

		if ( pAttribute->IsWritable () && VT_NULL != pAttribute->Value().GetType() )
		{
			cvId.Set ( pAttribute->Id() );

			if ( FAILED ( result = DASI.p->get_Item ( cvId , DAI ) ) )
			{
				throw CException ( WBEM_E_FAILED , IDS_COMMITROW_FAIL ,
					IDS_GETITEM_FAIL , CString ( result ) ) ;
			}
			
			cvNewValue.Set ( (LPVARIANT)pAttribute->Value() );

			// debug only 
			// verify object by getting current value
			result = DAI.p->get_Value ( cvT );

			MOT_TRACE ( L"\tMOT...\tcurrent value of %s is %s" , pAttribute->Name() , cvT.GetBstr() );
			// end debug

			if ( FAILED ( result = DAI.p->put_Value( cvNewValue ) ))
			{
				MOT_TRACE ( L"\tMOT...\tput_Value ( %lu ) on %s returned %lX" , 
					pAttribute->Value().GetLong() ,  pAttribute->Name() , result );

				throw CException ( WBEM_E_FAILED , IDS_COMMITROW_FAIL ,
					IDS_PUTVALUE_FAIL , CString ( result ) ) ;
			}

			MOT_TRACE ( L"\tMOT...\t%s = %s written without error" , pAttribute->Name() , cvNewValue.GetBstr() );
		}
		else
		{

			MOT_TRACE ( L"\tMOT...\t%s not writable" , pAttribute->Name() );
		}

		DAI.Release ( );
	}
}


void dmiAddRow ( LPWSTR wszNWA , LONG lComponent , LONG lGroup , 
		CRow* pNewRow, CDmiError* )
{
		
	/////////////////////////////////

	_fConnections->CheckIfAlready ( wszNWA );

	CString cszPath;

	MakeConnectString( wszNWA, cszPath );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lComponent );

	cszPath.Append ( PIPE_STR );

	cszPath.Append ( lGroup );

	STAT_TRACE ( L"\t\tMOT adding row to %s" , cszPath );

	// Create the row object that will be added
	CDRowI				DRINewRow;
	CDAttributesI		DASINewRow;
	
	DRINewRow.CoCreate ( );

	// Populate the new row object
	LONG				lIndex = 0;
	CAttribute*			pAttribute = NULL;
	LONG				lTemp = 0;	

	DRINewRow.GetAttributes( DASINewRow);

	LONG lCount = pNewRow->m_Attributes.GetCount(); 

	pNewRow->m_Attributes.MoveToHead();

	IDualAttribute**	IAttributeArray = new IDualAttribute*[lCount];

	while( pAttribute = pNewRow->m_Attributes.Next() )
	{

		DEV_TRACE ( 
			L"\t\t Attribute %lu = %s attribute.value= %s",
			pAttribute->Id(), pAttribute->Name(), 
			pAttribute->Value().GetBstr() );


		if ( FAILED ( CoCreateInstance (CLSID_DMIAttribute, NULL , EXE_TYPE ,
			IID_IDualAttribute , ( void ** )  &IAttributeArray[lIndex])))
		{
			throw CException ( WBEM_E_FAILED , IDS_ADD_ROW_FAIL , 
				IDS_CC_FAIL );	
		}

		CBstr cbName;

		cbName.Set ( pAttribute->Name() );

		IAttributeArray[lIndex]->put_Name( cbName );
		IAttributeArray[lIndex]->put_Value( pAttribute->Value() );
		IAttributeArray[lIndex]->put_id( pAttribute->Id() );

		DASINewRow.p->Add(IAttributeArray[lIndex], &lTemp);
		
		lIndex++;
	}	

	// Get Group Object that will recieve new row

	CDGroupI			DGI;
	CDRowsI				DRSI;

	DGI.CoCreate ();

	DGI.Read ( cszPath );	

	DGI.GetRows( DRSI );

	DRSI.Add ( DRINewRow );

	/// release the attributes array

	/* gpf's does the row release free the attribute I's
	for( lIndex = 0;  lIndex < lCount; lIndex++)
	{
		LONG l = IAttributeArray[lIndex]->Release ( );	

		MOT_TRACE ( L"IAttriubte relase returned %lu" , l );

		delete [] IAttributeArray ;
	}
	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmiinterface.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__DMINTERFACE_H__)
#define __DMINTERFACE_H__

class CConnection
{
public:
	CString			m_cszNWA;
	IDualMgmtNode*	m_pINode;

	CConnection*	m_pNext;

					CConnection ( );
					~CConnection ( );
	void			Init ( LPWSTR );
	void			Disconnect( );
	CString&		NWA ( )		{ return m_cszNWA ;}
};


class CConnections
{
	void			Add ( CConnection* , LPWSTR );

public:
	CConnection*	m_pFirst;
	CConnection*	m_pCurrent;

					CConnections ();
					~ CConnections ( );


	void			Remove ( LPWSTR );

	BOOL			CheckIfAlready ( LPWSTR );

	void			ClearAll ( );

	CConnection*	Next ( );
	void			MoveToHead ( );
};






class CDmiError
{
private:

	LONG	lDmiError;
	LONG	lMotError;
	LONG	lWbemError;
	LONG	lReason;
	LONG	lDescription;
	LONG	lOperation;

	CString	cszCall;
	CString	cszExtraData;

public:
			CDmiError()		{ lReason = lDescription = lWbemError = lDmiError = lMotError = 0 ;}
	void	SetDmiError ( LONG );
	void	SetMotError ( LONG );

	void	SetCallString ( LPWSTR );
	void	SetExtraData ( LPWSTR );
	void	SetWbemError ( long l ) { lWbemError = l ;}

	void	SetDescription ( LONG l) { lDescription = l;}
	void	SetReason ( LONG l )	{ lReason = l ;}
	void	SetOperation ( LONG l )	{ lOperation = l; }

	LONG	WbemError ()	{ return lWbemError ; }
	LONG	Reason ()		{ return lReason; }
	LONG	Description ()	{ return lDescription; }
	LONG	MotError ()		{ return lMotError ; }

	BOOL	HaveError ()	{if ( lWbemError || lDmiError || lMotError ) return TRUE ; return FALSE;}
};


void dmiReadNode ( LPWSTR , CNode* , CDmiError* );

void dmiReadComponents ( LPWSTR pNWA , CComponents* pNewComponents , 
						CDmiError* );

void dmiReadComponent ( LPWSTR pNWA , LONG lComponent , 
					CComponent* pNewComponent  , CDmiError* );

void dmiReadGroups ( LPWSTR pNWA , LONG lComponent , CGroups* pNewGroups  ,
				 CDmiError* );

void dmiReadGroup ( LPWSTR pNWA , LONG lComponent , LONG lGroup , 
					CGroup* pNewGroup  , CDmiError* );

void dmiReadRows ( LPWSTR wszNWA , LONG lComponent , LONG lGroup ,
					CRows* pNewRows  , CDmiError* );

void dmiReadRow ( LPWSTR wszNWA , LONG lComponent , LONG lGroup ,
					CAttributes* pKeys , CRow* pNewRow  , CDmiError* );

void dmiReadEnum ( LPWSTR pNWA , LONG lComponent , LONG lGroup ,
					LONG lAttribute , CEnum* pNewEnum  , CDmiError* );

void dmiReadLanguages ( LPWSTR pNWA , LONG lComponent , 
					CLanguages* pNewLanguages  , CDmiError* );

void dmiAddComponent ( LPWSTR wszNWA , LPWSTR pMifFile , CDmiError* );
	
void dmiDeleteComponent ( LPWSTR wszNWA , LONG  , CDmiError* );

void dmiAddLanguage ( LPWSTR pNWA , LONG lComponent , CVariant* pcvMifFile  ,
					 CDmiError* );

void dmiDeleteLanguage ( LPWSTR pNWA , LONG lComponent , CVariant* pcvMifFile  ,
						CDmiError* );

void dmiAddGroup ( LPWSTR wszNWA , LONG lComponent , LPWSTR pszMifFile ,
			   CDmiError* );

void dmiDeleteGroup ( LPWSTR , LONG , LONG , CDmiError* );

void dmiAddRow ( LPWSTR , LONG lComponent , LONG lGroup , CRow* , CDmiError* );

void dmiModifyRow ( LPWSTR , LONG lComponent , LONG lGroup , CAttributes* pKeys
				   , CRow* , CDmiError* );

void dmiDeleteRow ( LPWSTR , LONG lComponent , LONG lGroup , CAttributes* pKeys
				   , CDmiError* );

void dmiSetDefaultLanguage ( LPWSTR , LPWSTR , CDmiError* );

void dmiGetLanguages ( LPWSTR , LONG , CLanguages* , CDmiError* );




class CDmiInterfaceThreadContext
{
public:
			CDmiInterfaceThreadContext();
			~CDmiInterfaceThreadContext();

	void	KillThread ( );

	void	StartThread ();

	BOOL	m_bRunning;

	HANDLE	m_hStopThread;
	HANDLE  m_hComplete;
	HANDLE  m_Started;

	DWORD	m_dwThreadId;


private:

};


class CDmiInterface 
{
private:
	BOOL	m_bInit;

	CDmiInterfaceThreadContext m_TC;	

	/// for events /////////


	////////////////////////

	void	SendThreadMessage ( UINT msg , WPARAM  );

	friend void	ApartmentThread ( void *);

public:
			CDmiInterface() ;
			~CDmiInterface() ;

	void	ShutDown ();
	
	void	GetComponents ( LPWSTR pNWA , CComponents* pNewComponents );

	void	GetComponent ( LPWSTR pNWA , LONG , CComponent* pNewComponent );

	void	AddGroup ( LPWSTR pNWA , LONG , CVariant& );

	void	AddLanguage ( LPWSTR pNWA , LONG , CVariant& );

	void	DeleteLanguage ( LPWSTR pNWA, LONG , CVariant& );

	void	DeleteComponent ( LPWSTR pNWA, LONG );

	void	GetEnum ( LPWSTR pNWA, LONG lComponent , LONG lGroup ,
				LONG lAttribute , CEnum* pNewEnum );		

	void	DeleteRow ( LPWSTR pNWA , LONG lComponent , LONG lGroup ,
				CAttributes& m_Keys );		

	void	UpdateRow ( LPWSTR pNWA , LONG lComponent , LONG lGroup ,
				CAttributes& Keys , CRow* pNewRowValues );		

	void	GetRow ( LPWSTR pNWA , LONG lComponent , LONG lGroup ,
				CAttributes& m_Keys , CRow* pNewRow );		

	void	GetRows ( LPWSTR pNWA , LONG lComponent , LONG lGroup ,
				CRows* pNewRows );		

	void	DeleteGroup ( LPWSTR pNWA , LONG lComponent , 
				LONG m_lGroup );

	void	AddRow ( LPWSTR pNWA , LONG lComponent , LONG lGroup , 
				CRow& Row);

	void	GetGroup ( LPWSTR pNWA , LONG lComponent , LONG lGroup ,
				CGroup* pNewGroup );

	void	GetGroups ( LPWSTR pNWA , LONG lComponent , CGroups* );

	void	GetNode ( LPWSTR pNWA , CNode* pNewNode );		

	void	SetDefLanguage ( LPWSTR pNWA , CVariant& cvLanguage );		

	void	AddComponent ( LPWSTR pNWA , CVariant& cvMifFile );			

	void	GetLanguages ( LPWSTR pNWA , LONG lComponent , CLanguages* );			

	void	EnableEvents ( LPWSTR , IWbemObjectSink* );
};


#endif //__DMINTERFACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmipch.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__DMIPCH_H__)
#define __DMIPCH_H__

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <winuser.h>
#include <wbemidl.h>			// CIMOM header
#include <objbase.h>			// Component object model defintions.
#include <winbase.h>
#include <fstream.h>
#include <io.h>
#include <clidmi.h>		// For DmiRegister() and other header files
#include <dmi2com.h>	// For Dmi data types


/////////////////////////////////////////////////////////////////////
//			DEBUG STUFF




#ifdef _DEBUG
	#include <assert.h>
	#define ASSERT(a)	assert(a)
#else // _DEBUG
	#define ASSERT(a)	((void)(a))

#endif // _DEBUG



#endif // __DMIPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dmilayer.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* ABSTRACT: header file specific to the DMILAYER module.  Provides prototypes for
*			private functions and data used by the DMILAYER module.  
*
*
*
*/

#if !defined(__DMILAYER_H__)
#define __DMILAYER_H__

#include "dmipch.h"		// precompiled header for dmi provider


#define FILE_LEN 256

// Indication subscription related information
#define FAILURE_THRESHOLD			1000
#define MONITOR_ALL_EVENTS			0x3F
#define SP_COMPONENT_ID   			1
#define SUBSCRIPTION_GROUP_CLASS	"DMTF|SP Indication Subscription|"
#define FILTER_GROUP_CLASS			"DMTF|SPFilterInformation|"
#define GROUP_CLASS_FILTER			"||"
#define SUBSCRIPTION_KEY_COUNT		4
#define SUBSCRIPTION_VALUE_COUNT	7
#define FILTER_KEY_COUNT			6
#define FILTER_VALUE_COUNT			7
#define DCE_RPC_TYPE				"dce"
#define TCP_IP_TRANSPORT_TYPE		"ncacn_ip_tcp"
#define NULL_ADDRESS				""	// Node address for local connection
#define NULL_TRANSPORT_TYPE			""	// Tramsport type for local connection
#define LOCAL_RPC_TYPE				"local" // RPC type for local connection
#define WARN_TIME         			"29991230000000.000000+000\0\0\0"
#define EXPIRE_TIME					"29991231000000.000000+000\0\0\0"


// Function prototypes


static DmiErrorStatus_t _SubscribeForEvents( DmiHandle_t );

static DmiErrorStatus_t _SetIndicationEntryPoints( void );

static DmiGroupInfo_t * _GetGroupInfo( DmiId_t, const char *, DmiHandle_t );

static DmiErrorStatus_t _FillSubscriptionGroupInfo( DmiMultiRowData_t *, DmiHandle_t );	

static DmiErrorStatus_t _FillFilterGroupInfo( DmiMultiRowData_t *, DmiHandle_t );	

static DmiErrorStatus_t _RegisterWithDmiSp( LPTSTR, DmiHandle_t * );	

static void _UnRegisterWithDmiSp( DmiHandle_t );

static DmiHandle_t _GetHandleFromNodeName( LPTSTR, CDmiError * );

static DmiErrorStatus_t _GetNumberOfRows( DmiHandle_t, LONG,	LONG, DWORD *);

static DmiErrorStatus_t _GetRowKeysOrValues( CAttributes *, 
											 DmiAttributeValues_t ** );

static DmiErrorStatus_t _FindRow( DmiHandle_t, LONG, LONG, CAttributes*,
						     	  DmiMultiRowData_t **);

DmiErrorStatus_t CreateKeyListFromIds( DmiAttributeIds_t *,
									 DmiAttributeValues_t **);

#endif // __DMILAYER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\eventprovider.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#include "dmipch.h"			// precompiled header for dmi provider

#include "WbemDmiP.h"		// project wide include

#include "String.h"

#include "CimClass.h"

#include "EventProvider.h"

#include "Trace.h"

#include "Exception.h"

#include "DmiData.h"


//***************************************************************************
//
// CEventProvider::CEventProvider
// CEventProvider::~CEventProvider
//
//***************************************************************************

CEventProvider::CEventProvider()
{
	m_cRef = 0;

    return;
}

CEventProvider::~CEventProvider(void)
{

	STAT_TRACE ( L"CEventProvider::~CEventProvider()");

	return;
}

//***************************************************************************
//
// CEventProvider::QueryInterface
// CEventProvider::AddRef
// CEventProvider::Release
//
// Purpose: IUnknown members for CEventProvider object.
//***************************************************************************
STDMETHODIMP CEventProvider::QueryInterface(REFIID riid, void** ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid )
	{
        *ppv=this;
	}
	else if ( IID_IWbemEventProvider == riid)
	{
		*ppv = ( IWbemEventProvider * ) this ;
	}
	else if ( IID_IWbemProviderInit == riid)
	{
		*ppv = ( IWbemProviderInit * ) this ;
	}

    if (NULL!=*ppv) 
	{
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CEventProvider::AddRef(void)
{

	return InterlockedIncrement ( & m_cRef );

}

STDMETHODIMP_(ULONG) CEventProvider::Release(void)
{

	if ( 0L != InterlockedDecrement ( & m_cRef ) )
        return m_cRef;

    // refernce count is zero, delete this object.

	SetEvent ( m_hStopThreadEvent );		
    
    delete this;

    return WBEM_NO_ERROR;
}


//***************************************************************************
//
// CEventProvider
//
// Purpose: 
//          
//
//***************************************************************************

STDMETHODIMP CEventProvider::ProvideEvents(

	IWbemObjectSink* pISink,
    LONG lFlags
)
{
	SCODE	result = WBEM_NO_ERROR;

	STAT_TRACE ( L"CEventProvider::ProvideEvents()");

	// Check for requried Params

	if(pISink == NULL || lFlags != 0 )
        return WBEM_E_INVALID_PARAMETER;

	try
	{		
		// create the sink that will recive events from the motdmiengine	

		CEvents* m_pEvents = new CEvents;

		m_pEvents->Enable ( m_csNamespace , pISink );

	}
	catch ( CException& e )
	{
		return e.WbemError();
	}
	catch ( ... ) 
	{
		return WBEM_E_FAILED;
	}

	return 0L;

}

HRESULT CEventProvider::Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR wszNamespaceName,
	LPWSTR pszLocale,
	IWbemServices *ppNamespace,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
	SCODE	result = WBEM_NO_ERROR;

	STAT_TRACE ( L"CEventProvider::Initialize ( %s )", wszNamespaceName);

	// Check for requried Params

	if(lFlags != 0 || !wszNamespaceName )
        return WBEM_E_INVALID_PARAMETER;

	try
	{		
		m_csNamespace.Set ( wszNamespaceName );
	}
	catch ( CException& e )
	{
		return e.WbemError();
	}
	catch ( ... ) 
	{
		return WBEM_E_FAILED;
	}

	pInitSink->SetStatus ( result , 0 ) ;

	return 0L;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\dual.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Dec 01 17:04:01 1997
 */
/* Compiler settings for D:\test\mot\dmiengin\src\DmiActx.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __dual_h__
#define __dual_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEventFilter_FWD_DEFINED__
#define __IEventFilter_FWD_DEFINED__
typedef interface IEventFilter IEventFilter;
#endif 	/* __IEventFilter_FWD_DEFINED__ */


#ifndef __IDualEventFilter_FWD_DEFINED__
#define __IDualEventFilter_FWD_DEFINED__
typedef interface IDualEventFilter IDualEventFilter;
#endif 	/* __IDualEventFilter_FWD_DEFINED__ */


#ifndef __DMIEventFilter_FWD_DEFINED__
#define __DMIEventFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIEventFilter DMIEventFilter;
#else
typedef struct DMIEventFilter DMIEventFilter;
#endif /* __cplusplus */

#endif 	/* __DMIEventFilter_FWD_DEFINED__ */


#ifndef __IColLanguages_FWD_DEFINED__
#define __IColLanguages_FWD_DEFINED__
typedef interface IColLanguages IColLanguages;
#endif 	/* __IColLanguages_FWD_DEFINED__ */


#ifndef __IDualColLanguages_FWD_DEFINED__
#define __IDualColLanguages_FWD_DEFINED__
typedef interface IDualColLanguages IDualColLanguages;
#endif 	/* __IDualColLanguages_FWD_DEFINED__ */


#ifndef __DMILanguages_FWD_DEFINED__
#define __DMILanguages_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMILanguages DMILanguages;
#else
typedef struct DMILanguages DMILanguages;
#endif /* __cplusplus */

#endif 	/* __DMILanguages_FWD_DEFINED__ */


#ifndef __IEnumeration_FWD_DEFINED__
#define __IEnumeration_FWD_DEFINED__
typedef interface IEnumeration IEnumeration;
#endif 	/* __IEnumeration_FWD_DEFINED__ */


#ifndef __IDualEnumeration_FWD_DEFINED__
#define __IDualEnumeration_FWD_DEFINED__
typedef interface IDualEnumeration IDualEnumeration;
#endif 	/* __IDualEnumeration_FWD_DEFINED__ */


#ifndef __DMIEnumeration_FWD_DEFINED__
#define __DMIEnumeration_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIEnumeration DMIEnumeration;
#else
typedef struct DMIEnumeration DMIEnumeration;
#endif /* __cplusplus */

#endif 	/* __DMIEnumeration_FWD_DEFINED__ */


#ifndef __IColEnumerations_FWD_DEFINED__
#define __IColEnumerations_FWD_DEFINED__
typedef interface IColEnumerations IColEnumerations;
#endif 	/* __IColEnumerations_FWD_DEFINED__ */


#ifndef __IDualColEnumerations_FWD_DEFINED__
#define __IDualColEnumerations_FWD_DEFINED__
typedef interface IDualColEnumerations IDualColEnumerations;
#endif 	/* __IDualColEnumerations_FWD_DEFINED__ */


#ifndef __DMIEnumerations_FWD_DEFINED__
#define __DMIEnumerations_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIEnumerations DMIEnumerations;
#else
typedef struct DMIEnumerations DMIEnumerations;
#endif /* __cplusplus */

#endif 	/* __DMIEnumerations_FWD_DEFINED__ */


#ifndef __IAttribute_FWD_DEFINED__
#define __IAttribute_FWD_DEFINED__
typedef interface IAttribute IAttribute;
#endif 	/* __IAttribute_FWD_DEFINED__ */


#ifndef __IDualAttribute_FWD_DEFINED__
#define __IDualAttribute_FWD_DEFINED__
typedef interface IDualAttribute IDualAttribute;
#endif 	/* __IDualAttribute_FWD_DEFINED__ */


#ifndef __DMIAttribute_FWD_DEFINED__
#define __DMIAttribute_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIAttribute DMIAttribute;
#else
typedef struct DMIAttribute DMIAttribute;
#endif /* __cplusplus */

#endif 	/* __DMIAttribute_FWD_DEFINED__ */


#ifndef __IColAttributes_FWD_DEFINED__
#define __IColAttributes_FWD_DEFINED__
typedef interface IColAttributes IColAttributes;
#endif 	/* __IColAttributes_FWD_DEFINED__ */


#ifndef __IDualColAttributes_FWD_DEFINED__
#define __IDualColAttributes_FWD_DEFINED__
typedef interface IDualColAttributes IDualColAttributes;
#endif 	/* __IDualColAttributes_FWD_DEFINED__ */


#ifndef __DMIAttributes_FWD_DEFINED__
#define __DMIAttributes_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIAttributes DMIAttributes;
#else
typedef struct DMIAttributes DMIAttributes;
#endif /* __cplusplus */

#endif 	/* __DMIAttributes_FWD_DEFINED__ */


#ifndef __IRow_FWD_DEFINED__
#define __IRow_FWD_DEFINED__
typedef interface IRow IRow;
#endif 	/* __IRow_FWD_DEFINED__ */


#ifndef __IDualRow_FWD_DEFINED__
#define __IDualRow_FWD_DEFINED__
typedef interface IDualRow IDualRow;
#endif 	/* __IDualRow_FWD_DEFINED__ */


#ifndef __DMIRow_FWD_DEFINED__
#define __DMIRow_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIRow DMIRow;
#else
typedef struct DMIRow DMIRow;
#endif /* __cplusplus */

#endif 	/* __DMIRow_FWD_DEFINED__ */


#ifndef __IColRows_FWD_DEFINED__
#define __IColRows_FWD_DEFINED__
typedef interface IColRows IColRows;
#endif 	/* __IColRows_FWD_DEFINED__ */


#ifndef __IDualColRows_FWD_DEFINED__
#define __IDualColRows_FWD_DEFINED__
typedef interface IDualColRows IDualColRows;
#endif 	/* __IDualColRows_FWD_DEFINED__ */


#ifndef __DMIRows_FWD_DEFINED__
#define __DMIRows_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIRows DMIRows;
#else
typedef struct DMIRows DMIRows;
#endif /* __cplusplus */

#endif 	/* __DMIRows_FWD_DEFINED__ */


#ifndef __IGroup_FWD_DEFINED__
#define __IGroup_FWD_DEFINED__
typedef interface IGroup IGroup;
#endif 	/* __IGroup_FWD_DEFINED__ */


#ifndef __IDualGroup_FWD_DEFINED__
#define __IDualGroup_FWD_DEFINED__
typedef interface IDualGroup IDualGroup;
#endif 	/* __IDualGroup_FWD_DEFINED__ */


#ifndef __DMIGroup_FWD_DEFINED__
#define __DMIGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIGroup DMIGroup;
#else
typedef struct DMIGroup DMIGroup;
#endif /* __cplusplus */

#endif 	/* __DMIGroup_FWD_DEFINED__ */


#ifndef __IColGroups_FWD_DEFINED__
#define __IColGroups_FWD_DEFINED__
typedef interface IColGroups IColGroups;
#endif 	/* __IColGroups_FWD_DEFINED__ */


#ifndef __IDualColGroups_FWD_DEFINED__
#define __IDualColGroups_FWD_DEFINED__
typedef interface IDualColGroups IDualColGroups;
#endif 	/* __IDualColGroups_FWD_DEFINED__ */


#ifndef __DMIGroups_FWD_DEFINED__
#define __DMIGroups_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIGroups DMIGroups;
#else
typedef struct DMIGroups DMIGroups;
#endif /* __cplusplus */

#endif 	/* __DMIGroups_FWD_DEFINED__ */


#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif 	/* __IComponent_FWD_DEFINED__ */


#ifndef __IDualComponent_FWD_DEFINED__
#define __IDualComponent_FWD_DEFINED__
typedef interface IDualComponent IDualComponent;
#endif 	/* __IDualComponent_FWD_DEFINED__ */


#ifndef __DMIComponent_FWD_DEFINED__
#define __DMIComponent_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIComponent DMIComponent;
#else
typedef struct DMIComponent DMIComponent;
#endif /* __cplusplus */

#endif 	/* __DMIComponent_FWD_DEFINED__ */


#ifndef __IColComponents_FWD_DEFINED__
#define __IColComponents_FWD_DEFINED__
typedef interface IColComponents IColComponents;
#endif 	/* __IColComponents_FWD_DEFINED__ */


#ifndef __IDualColComponents_FWD_DEFINED__
#define __IDualColComponents_FWD_DEFINED__
typedef interface IDualColComponents IDualColComponents;
#endif 	/* __IDualColComponents_FWD_DEFINED__ */


#ifndef __DMIComponents_FWD_DEFINED__
#define __DMIComponents_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIComponents DMIComponents;
#else
typedef struct DMIComponents DMIComponents;
#endif /* __cplusplus */

#endif 	/* __DMIComponents_FWD_DEFINED__ */


#ifndef __IMgmtNode_FWD_DEFINED__
#define __IMgmtNode_FWD_DEFINED__
typedef interface IMgmtNode IMgmtNode;
#endif 	/* __IMgmtNode_FWD_DEFINED__ */


#ifndef __IDualMgmtNode_FWD_DEFINED__
#define __IDualMgmtNode_FWD_DEFINED__
typedef interface IDualMgmtNode IDualMgmtNode;
#endif 	/* __IDualMgmtNode_FWD_DEFINED__ */


#ifndef __DMIMgmtNode_FWD_DEFINED__
#define __DMIMgmtNode_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIMgmtNode DMIMgmtNode;
#else
typedef struct DMIMgmtNode DMIMgmtNode;
#endif /* __cplusplus */

#endif 	/* __DMIMgmtNode_FWD_DEFINED__ */


#ifndef __IColMgmtNodes_FWD_DEFINED__
#define __IColMgmtNodes_FWD_DEFINED__
typedef interface IColMgmtNodes IColMgmtNodes;
#endif 	/* __IColMgmtNodes_FWD_DEFINED__ */


#ifndef __IDualColMgmtNodes_FWD_DEFINED__
#define __IDualColMgmtNodes_FWD_DEFINED__
typedef interface IDualColMgmtNodes IDualColMgmtNodes;
#endif 	/* __IDualColMgmtNodes_FWD_DEFINED__ */


#ifndef __DMIMgmtNodes_FWD_DEFINED__
#define __DMIMgmtNodes_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIMgmtNodes DMIMgmtNodes;
#else
typedef struct DMIMgmtNodes DMIMgmtNodes;
#endif /* __cplusplus */

#endif 	/* __DMIMgmtNodes_FWD_DEFINED__ */


#ifndef __INotification_FWD_DEFINED__
#define __INotification_FWD_DEFINED__
typedef interface INotification INotification;
#endif 	/* __INotification_FWD_DEFINED__ */


#ifndef __DMINotification_FWD_DEFINED__
#define __DMINotification_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMINotification DMINotification;
#else
typedef struct DMINotification DMINotification;
#endif /* __cplusplus */

#endif 	/* __DMINotification_FWD_DEFINED__ */


#ifndef __IEvent_FWD_DEFINED__
#define __IEvent_FWD_DEFINED__
typedef interface IEvent IEvent;
#endif 	/* __IEvent_FWD_DEFINED__ */


#ifndef __DMIEvent_FWD_DEFINED__
#define __DMIEvent_FWD_DEFINED__

#ifdef __cplusplus
typedef class DMIEvent DMIEvent;
#else
typedef struct DMIEvent DMIEvent;
#endif /* __cplusplus */

#endif 	/* __DMIEvent_FWD_DEFINED__ */


#ifndef ___DDualint_FWD_DEFINED__
#define ___DDualint_FWD_DEFINED__
typedef interface _DDualint _DDualint;
#endif 	/* ___DDualint_FWD_DEFINED__ */


#ifndef ___DualDMIEngine_FWD_DEFINED__
#define ___DualDMIEngine_FWD_DEFINED__
typedef interface _DualDMIEngine _DualDMIEngine;
#endif 	/* ___DualDMIEngine_FWD_DEFINED__ */


#ifndef ___DDualintEvents_FWD_DEFINED__
#define ___DDualintEvents_FWD_DEFINED__
typedef interface _DDualintEvents _DDualintEvents;
#endif 	/* ___DDualintEvents_FWD_DEFINED__ */


#ifndef __MOTDmiEngine_FWD_DEFINED__
#define __MOTDmiEngine_FWD_DEFINED__

#ifdef __cplusplus
typedef class MOTDmiEngine MOTDmiEngine;
#else
typedef struct MOTDmiEngine MOTDmiEngine;
#endif /* __cplusplus */

#endif 	/* __MOTDmiEngine_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __MOTDMIEngine_LIBRARY_DEFINED__
#define __MOTDMIEngine_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MOTDMIEngine
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [control][helpstring][helpcontext][helpfile][version][uuid] */ 



DEFINE_GUID(LIBID_MOTDMIEngine,0xF45FB440,0xC9DA,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#ifndef __IEventFilter_DISPINTERFACE_DEFINED__
#define __IEventFilter_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IEventFilter
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IEventFilter,0x6313BC6E,0xAEBF,0x11D0,0xB8,0x65,0x00,0xA0,0xC9,0x24,0x79,0xE2);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6313BC6E-AEBF-11D0-B865-00A0C92479E2")
    IEventFilter : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IEventFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventFilter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventFilter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventFilter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventFilter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IEventFilterVtbl;

    interface IEventFilter
    {
        CONST_VTBL struct IEventFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventFilter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IEventFilter_DISPINTERFACE_DEFINED__ */


#ifndef __IDualEventFilter_INTERFACE_DEFINED__
#define __IDualEventFilter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualEventFilter
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualEventFilter,0x48EC0E24,0xAEC2,0x11d0,0xB8,0x65,0x00,0xA0,0xC9,0x24,0x79,0xE2);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("48EC0E24-AEC2-11d0-B865-00A0C92479E2")
    IDualEventFilter : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExpirationDate( 
            /* [retval][out] */ BSTR __RPC_FAR *bstrExpiredate) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ExpirationDate( 
            /* [in] */ BSTR bstrExpiredate) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExpirationWarningDate( 
            /* [retval][out] */ BSTR __RPC_FAR *bstrExpireWarn) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ExpirationWarningDate( 
            /* [in] */ BSTR bstrExpireWarn) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FailOnRetryNum( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FailOnRetryNum( 
            /* [in] */ long lretrycnt) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ComponentID( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ComponentID( 
            /* [in] */ long lCompId) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClassStringFilter( 
            /* [retval][out] */ BSTR __RPC_FAR *bstrClassString) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ClassStringFilter( 
            /* [in] */ BSTR bstrClassString) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SeverityMask( 
            /* [retval][out] */ long __RPC_FAR *lmask) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SeverityMask( 
            /* [in] */ long lmask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualEventFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualEventFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualEventFilter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualEventFilter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpirationDate )( 
            IDualEventFilter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *bstrExpiredate);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpirationDate )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ BSTR bstrExpiredate);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpirationWarningDate )( 
            IDualEventFilter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *bstrExpireWarn);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpirationWarningDate )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ BSTR bstrExpireWarn);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FailOnRetryNum )( 
            IDualEventFilter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FailOnRetryNum )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ long lretrycnt);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ComponentID )( 
            IDualEventFilter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ComponentID )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ long lCompId);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClassStringFilter )( 
            IDualEventFilter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *bstrClassString);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ClassStringFilter )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ BSTR bstrClassString);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SeverityMask )( 
            IDualEventFilter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *lmask);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SeverityMask )( 
            IDualEventFilter __RPC_FAR * This,
            /* [in] */ long lmask);
        
        END_INTERFACE
    } IDualEventFilterVtbl;

    interface IDualEventFilter
    {
        CONST_VTBL struct IDualEventFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualEventFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualEventFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualEventFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualEventFilter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualEventFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualEventFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualEventFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualEventFilter_get_ExpirationDate(This,bstrExpiredate)	\
    (This)->lpVtbl -> get_ExpirationDate(This,bstrExpiredate)

#define IDualEventFilter_put_ExpirationDate(This,bstrExpiredate)	\
    (This)->lpVtbl -> put_ExpirationDate(This,bstrExpiredate)

#define IDualEventFilter_get_ExpirationWarningDate(This,bstrExpireWarn)	\
    (This)->lpVtbl -> get_ExpirationWarningDate(This,bstrExpireWarn)

#define IDualEventFilter_put_ExpirationWarningDate(This,bstrExpireWarn)	\
    (This)->lpVtbl -> put_ExpirationWarningDate(This,bstrExpireWarn)

#define IDualEventFilter_get_FailOnRetryNum(This,retval)	\
    (This)->lpVtbl -> get_FailOnRetryNum(This,retval)

#define IDualEventFilter_put_FailOnRetryNum(This,lretrycnt)	\
    (This)->lpVtbl -> put_FailOnRetryNum(This,lretrycnt)

#define IDualEventFilter_get_ComponentID(This,retval)	\
    (This)->lpVtbl -> get_ComponentID(This,retval)

#define IDualEventFilter_put_ComponentID(This,lCompId)	\
    (This)->lpVtbl -> put_ComponentID(This,lCompId)

#define IDualEventFilter_get_ClassStringFilter(This,bstrClassString)	\
    (This)->lpVtbl -> get_ClassStringFilter(This,bstrClassString)

#define IDualEventFilter_put_ClassStringFilter(This,bstrClassString)	\
    (This)->lpVtbl -> put_ClassStringFilter(This,bstrClassString)

#define IDualEventFilter_get_SeverityMask(This,lmask)	\
    (This)->lpVtbl -> get_SeverityMask(This,lmask)

#define IDualEventFilter_put_SeverityMask(This,lmask)	\
    (This)->lpVtbl -> put_SeverityMask(This,lmask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_get_ExpirationDate_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *bstrExpiredate);


void __RPC_STUB IDualEventFilter_get_ExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_put_ExpirationDate_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [in] */ BSTR bstrExpiredate);


void __RPC_STUB IDualEventFilter_put_ExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_get_ExpirationWarningDate_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *bstrExpireWarn);


void __RPC_STUB IDualEventFilter_get_ExpirationWarningDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_put_ExpirationWarningDate_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [in] */ BSTR bstrExpireWarn);


void __RPC_STUB IDualEventFilter_put_ExpirationWarningDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_get_FailOnRetryNum_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualEventFilter_get_FailOnRetryNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_put_FailOnRetryNum_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [in] */ long lretrycnt);


void __RPC_STUB IDualEventFilter_put_FailOnRetryNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_get_ComponentID_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualEventFilter_get_ComponentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_put_ComponentID_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [in] */ long lCompId);


void __RPC_STUB IDualEventFilter_put_ComponentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_get_ClassStringFilter_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *bstrClassString);


void __RPC_STUB IDualEventFilter_get_ClassStringFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_put_ClassStringFilter_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [in] */ BSTR bstrClassString);


void __RPC_STUB IDualEventFilter_put_ClassStringFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_get_SeverityMask_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *lmask);


void __RPC_STUB IDualEventFilter_get_SeverityMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualEventFilter_put_SeverityMask_Proxy( 
    IDualEventFilter __RPC_FAR * This,
    /* [in] */ long lmask);


void __RPC_STUB IDualEventFilter_put_SeverityMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualEventFilter_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIEventFilter,0x6313BC6F,0xAEBF,0x11D0,0xB8,0x65,0x00,0xA0,0xC9,0x24,0x79,0xE2);

class DECLSPEC_UUID("6313BC6F-AEBF-11D0-B865-00A0C92479E2")
DMIEventFilter;
#endif

#ifndef __IColLanguages_DISPINTERFACE_DEFINED__
#define __IColLanguages_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IColLanguages
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IColLanguages,0xA24E5B80,0x7AC3,0x11D0,0x88,0x45,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("A24E5B80-7AC3-11D0-8845-00AA006B21BF")
    IColLanguages : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IColLanguagesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColLanguages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColLanguages __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColLanguages __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IColLanguages __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IColLanguages __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IColLanguages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IColLanguages __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IColLanguagesVtbl;

    interface IColLanguages
    {
        CONST_VTBL struct IColLanguagesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColLanguages_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColLanguages_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColLanguages_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColLanguages_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColLanguages_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColLanguages_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColLanguages_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IColLanguages_DISPINTERFACE_DEFINED__ */


#ifndef __IDualColLanguages_INTERFACE_DEFINED__
#define __IDualColLanguages_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualColLanguages
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualColLanguages,0x13AE3E40,0x7B54,0x11d0,0x88,0x45,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("13AE3E40-7B54-11d0-8845-00AA006B21BF")
    IDualColLanguages : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrLanguage,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT varLang,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varLang,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLang) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT varLang,
            /* [in] */ BSTR __RPC_FAR *pbstrNewLang) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualColLanguagesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualColLanguages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualColLanguages __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualColLanguages __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualColLanguages __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualColLanguages __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualColLanguages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualColLanguages __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDualColLanguages __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDualColLanguages __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDualColLanguages __RPC_FAR * This,
            /* [in] */ BSTR bstrLanguage,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDualColLanguages __RPC_FAR * This,
            /* [in] */ VARIANT varLang,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAll )( 
            IDualColLanguages __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IDualColLanguages __RPC_FAR * This,
            /* [in] */ VARIANT varLang,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLang);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IDualColLanguages __RPC_FAR * This,
            /* [in] */ VARIANT varLang,
            /* [in] */ BSTR __RPC_FAR *pbstrNewLang);
        
        END_INTERFACE
    } IDualColLanguagesVtbl;

    interface IDualColLanguages
    {
        CONST_VTBL struct IDualColLanguagesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualColLanguages_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualColLanguages_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualColLanguages_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualColLanguages_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualColLanguages_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualColLanguages_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualColLanguages_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualColLanguages_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define IDualColLanguages_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#define IDualColLanguages_Add(This,bstrLanguage,retval)	\
    (This)->lpVtbl -> Add(This,bstrLanguage,retval)

#define IDualColLanguages_Remove(This,varLang,retval)	\
    (This)->lpVtbl -> Remove(This,varLang,retval)

#define IDualColLanguages_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#define IDualColLanguages_get_Item(This,varLang,pbstrLang)	\
    (This)->lpVtbl -> get_Item(This,varLang,pbstrLang)

#define IDualColLanguages_putref_Item(This,varLang,pbstrNewLang)	\
    (This)->lpVtbl -> putref_Item(This,varLang,pbstrNewLang)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColLanguages_get_Count_Proxy( 
    IDualColLanguages __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColLanguages_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDualColLanguages_get__NewEnum_Proxy( 
    IDualColLanguages __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColLanguages_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColLanguages_Add_Proxy( 
    IDualColLanguages __RPC_FAR * This,
    /* [in] */ BSTR bstrLanguage,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColLanguages_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColLanguages_Remove_Proxy( 
    IDualColLanguages __RPC_FAR * This,
    /* [in] */ VARIANT varLang,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColLanguages_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColLanguages_RemoveAll_Proxy( 
    IDualColLanguages __RPC_FAR * This);


void __RPC_STUB IDualColLanguages_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColLanguages_get_Item_Proxy( 
    IDualColLanguages __RPC_FAR * This,
    /* [in] */ VARIANT varLang,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrLang);


void __RPC_STUB IDualColLanguages_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualColLanguages_putref_Item_Proxy( 
    IDualColLanguages __RPC_FAR * This,
    /* [in] */ VARIANT varLang,
    /* [in] */ BSTR __RPC_FAR *pbstrNewLang);


void __RPC_STUB IDualColLanguages_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualColLanguages_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMILanguages,0xA24E5B81,0x7AC3,0x11D0,0x88,0x45,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("A24E5B81-7AC3-11D0-8845-00AA006B21BF")
DMILanguages;
#endif

#ifndef __IEnumeration_DISPINTERFACE_DEFINED__
#define __IEnumeration_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IEnumeration
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IEnumeration,0xF1DC8AE2,0x36FE,0x11D0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("F1DC8AE2-36FE-11D0-8844-00AA006B21BF")
    IEnumeration : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IEnumerationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumeration __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumeration __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumeration __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEnumeration __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEnumeration __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEnumeration __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEnumeration __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IEnumerationVtbl;

    interface IEnumeration
    {
        CONST_VTBL struct IEnumerationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumeration_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumeration_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumeration_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumeration_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEnumeration_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEnumeration_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEnumeration_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IEnumeration_DISPINTERFACE_DEFINED__ */


#ifndef __IDualEnumeration_INTERFACE_DEFINED__
#define __IDualEnumeration_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualEnumeration
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualEnumeration,0x9EACD1E0,0x3703,0x11d0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9EACD1E0-3703-11d0-8844-00AA006B21BF")
    IDualEnumeration : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__EnumString( 
            /* [retval][out] */ BSTR __RPC_FAR *pbsEnumString) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put__EnumString( 
            /* [in] */ BSTR bsEnumString) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumString( 
            /* [retval][out] */ BSTR __RPC_FAR *pbsEnumString) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnumString( 
            /* [in] */ BSTR bsEnumString) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumValue( 
            /* [retval][out] */ long __RPC_FAR *pEnumValue) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnumValue( 
            /* [in] */ long EnumValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualEnumerationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualEnumeration __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualEnumeration __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualEnumeration __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualEnumeration __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualEnumeration __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualEnumeration __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualEnumeration __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__EnumString )( 
            IDualEnumeration __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbsEnumString);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put__EnumString )( 
            IDualEnumeration __RPC_FAR * This,
            /* [in] */ BSTR bsEnumString);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnumString )( 
            IDualEnumeration __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbsEnumString);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnumString )( 
            IDualEnumeration __RPC_FAR * This,
            /* [in] */ BSTR bsEnumString);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnumValue )( 
            IDualEnumeration __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pEnumValue);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnumValue )( 
            IDualEnumeration __RPC_FAR * This,
            /* [in] */ long EnumValue);
        
        END_INTERFACE
    } IDualEnumerationVtbl;

    interface IDualEnumeration
    {
        CONST_VTBL struct IDualEnumerationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualEnumeration_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualEnumeration_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualEnumeration_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualEnumeration_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualEnumeration_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualEnumeration_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualEnumeration_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualEnumeration_get__EnumString(This,pbsEnumString)	\
    (This)->lpVtbl -> get__EnumString(This,pbsEnumString)

#define IDualEnumeration_put__EnumString(This,bsEnumString)	\
    (This)->lpVtbl -> put__EnumString(This,bsEnumString)

#define IDualEnumeration_get_EnumString(This,pbsEnumString)	\
    (This)->lpVtbl -> get_EnumString(This,pbsEnumString)

#define IDualEnumeration_put_EnumString(This,bsEnumString)	\
    (This)->lpVtbl -> put_EnumString(This,bsEnumString)

#define IDualEnumeration_get_EnumValue(This,pEnumValue)	\
    (This)->lpVtbl -> get_EnumValue(This,pEnumValue)

#define IDualEnumeration_put_EnumValue(This,EnumValue)	\
    (This)->lpVtbl -> put_EnumValue(This,EnumValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualEnumeration_get__EnumString_Proxy( 
    IDualEnumeration __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbsEnumString);


void __RPC_STUB IDualEnumeration_get__EnumString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualEnumeration_put__EnumString_Proxy( 
    IDualEnumeration __RPC_FAR * This,
    /* [in] */ BSTR bsEnumString);


void __RPC_STUB IDualEnumeration_put__EnumString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualEnumeration_get_EnumString_Proxy( 
    IDualEnumeration __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbsEnumString);


void __RPC_STUB IDualEnumeration_get_EnumString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualEnumeration_put_EnumString_Proxy( 
    IDualEnumeration __RPC_FAR * This,
    /* [in] */ BSTR bsEnumString);


void __RPC_STUB IDualEnumeration_put_EnumString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualEnumeration_get_EnumValue_Proxy( 
    IDualEnumeration __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pEnumValue);


void __RPC_STUB IDualEnumeration_get_EnumValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualEnumeration_put_EnumValue_Proxy( 
    IDualEnumeration __RPC_FAR * This,
    /* [in] */ long EnumValue);


void __RPC_STUB IDualEnumeration_put_EnumValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualEnumeration_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIEnumeration,0xF1DC8AE3,0x36FE,0x11D0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("F1DC8AE3-36FE-11D0-8844-00AA006B21BF")
DMIEnumeration;
#endif

#ifndef __IColEnumerations_DISPINTERFACE_DEFINED__
#define __IColEnumerations_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IColEnumerations
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IColEnumerations,0xF1DC8AE4,0x36FE,0x11D0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("F1DC8AE4-36FE-11D0-8844-00AA006B21BF")
    IColEnumerations : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IColEnumerationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColEnumerations __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColEnumerations __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColEnumerations __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IColEnumerations __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IColEnumerations __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IColEnumerations __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IColEnumerations __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IColEnumerationsVtbl;

    interface IColEnumerations
    {
        CONST_VTBL struct IColEnumerationsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColEnumerations_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColEnumerations_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColEnumerations_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColEnumerations_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColEnumerations_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColEnumerations_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColEnumerations_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IColEnumerations_DISPINTERFACE_DEFINED__ */


#ifndef __IDualColEnumerations_INTERFACE_DEFINED__
#define __IDualColEnumerations_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualColEnumerations
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualColEnumerations,0x2C7E6960,0x3714,0x11d0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2C7E6960-3714-11d0-8844-00AA006B21BF")
    IDualColEnumerations : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT EnumValOrString,
            /* [retval][out] */ IDualEnumeration __RPC_FAR *__RPC_FAR *ppdEnum) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT EnumValOrString,
            /* [in] */ IDualEnumeration __RPC_FAR *pdEnum) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__Item( 
            /* [in] */ VARIANT EnumValOrString,
            /* [retval][out] */ IDualEnumeration __RPC_FAR *__RPC_FAR *ppdEnum) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref__Item( 
            /* [in] */ VARIANT EnumValOrString,
            /* [in] */ IDualEnumeration __RPC_FAR *pdEnum) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IDualEnumeration __RPC_FAR *lpDispEnum,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT EnumValOrString,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualColEnumerationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualColEnumerations __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualColEnumerations __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ VARIANT EnumValOrString,
            /* [retval][out] */ IDualEnumeration __RPC_FAR *__RPC_FAR *ppdEnum);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ VARIANT EnumValOrString,
            /* [in] */ IDualEnumeration __RPC_FAR *pdEnum);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__Item )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ VARIANT EnumValOrString,
            /* [retval][out] */ IDualEnumeration __RPC_FAR *__RPC_FAR *ppdEnum);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref__Item )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ VARIANT EnumValOrString,
            /* [in] */ IDualEnumeration __RPC_FAR *pdEnum);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ IDualEnumeration __RPC_FAR *lpDispEnum,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDualColEnumerations __RPC_FAR * This,
            /* [in] */ VARIANT EnumValOrString,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAll )( 
            IDualColEnumerations __RPC_FAR * This);
        
        END_INTERFACE
    } IDualColEnumerationsVtbl;

    interface IDualColEnumerations
    {
        CONST_VTBL struct IDualColEnumerationsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualColEnumerations_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualColEnumerations_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualColEnumerations_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualColEnumerations_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualColEnumerations_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualColEnumerations_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualColEnumerations_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualColEnumerations_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define IDualColEnumerations_get_Item(This,EnumValOrString,ppdEnum)	\
    (This)->lpVtbl -> get_Item(This,EnumValOrString,ppdEnum)

#define IDualColEnumerations_putref_Item(This,EnumValOrString,pdEnum)	\
    (This)->lpVtbl -> putref_Item(This,EnumValOrString,pdEnum)

#define IDualColEnumerations_get__Item(This,EnumValOrString,ppdEnum)	\
    (This)->lpVtbl -> get__Item(This,EnumValOrString,ppdEnum)

#define IDualColEnumerations_putref__Item(This,EnumValOrString,pdEnum)	\
    (This)->lpVtbl -> putref__Item(This,EnumValOrString,pdEnum)

#define IDualColEnumerations_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#define IDualColEnumerations_Add(This,lpDispEnum,retval)	\
    (This)->lpVtbl -> Add(This,lpDispEnum,retval)

#define IDualColEnumerations_Remove(This,EnumValOrString,retval)	\
    (This)->lpVtbl -> Remove(This,EnumValOrString,retval)

#define IDualColEnumerations_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColEnumerations_get_Count_Proxy( 
    IDualColEnumerations __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColEnumerations_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColEnumerations_get_Item_Proxy( 
    IDualColEnumerations __RPC_FAR * This,
    /* [in] */ VARIANT EnumValOrString,
    /* [retval][out] */ IDualEnumeration __RPC_FAR *__RPC_FAR *ppdEnum);


void __RPC_STUB IDualColEnumerations_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualColEnumerations_putref_Item_Proxy( 
    IDualColEnumerations __RPC_FAR * This,
    /* [in] */ VARIANT EnumValOrString,
    /* [in] */ IDualEnumeration __RPC_FAR *pdEnum);


void __RPC_STUB IDualColEnumerations_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColEnumerations_get__Item_Proxy( 
    IDualColEnumerations __RPC_FAR * This,
    /* [in] */ VARIANT EnumValOrString,
    /* [retval][out] */ IDualEnumeration __RPC_FAR *__RPC_FAR *ppdEnum);


void __RPC_STUB IDualColEnumerations_get__Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualColEnumerations_putref__Item_Proxy( 
    IDualColEnumerations __RPC_FAR * This,
    /* [in] */ VARIANT EnumValOrString,
    /* [in] */ IDualEnumeration __RPC_FAR *pdEnum);


void __RPC_STUB IDualColEnumerations_putref__Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDualColEnumerations_get__NewEnum_Proxy( 
    IDualColEnumerations __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColEnumerations_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColEnumerations_Add_Proxy( 
    IDualColEnumerations __RPC_FAR * This,
    /* [in] */ IDualEnumeration __RPC_FAR *lpDispEnum,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColEnumerations_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColEnumerations_Remove_Proxy( 
    IDualColEnumerations __RPC_FAR * This,
    /* [in] */ VARIANT EnumValOrString,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColEnumerations_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColEnumerations_RemoveAll_Proxy( 
    IDualColEnumerations __RPC_FAR * This);


void __RPC_STUB IDualColEnumerations_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualColEnumerations_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIEnumerations,0xF1DC8AE5,0x36FE,0x11D0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("F1DC8AE5-36FE-11D0-8844-00AA006B21BF")
DMIEnumerations;
#endif

#ifndef __IAttribute_DISPINTERFACE_DEFINED__
#define __IAttribute_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IAttribute
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IAttribute,0xF45FB448,0xC9DA,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("F45FB448-C9DA-11CF-8844-00AA006B21BF")
    IAttribute : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAttribute __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAttribute __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAttribute __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAttribute __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAttribute __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IAttributeVtbl;

    interface IAttribute
    {
        CONST_VTBL struct IAttributeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IAttribute_DISPINTERFACE_DEFINED__ */


#ifndef __IDualAttribute_INTERFACE_DEFINED__
#define __IDualAttribute_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualAttribute
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualAttribute,0x61DB0E60,0xCAAE,0x11cf,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("61DB0E60-CAAE-11cf-8844-00AA006B21BF")
    IDualAttribute : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR path) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Access( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Access( 
            /* [in] */ long id) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR description) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR name) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pragma( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Pragma( 
            /* [in] */ BSTR pragma) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ long type) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_id( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_id( 
            /* [in] */ long id) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxSize( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxSize( 
            /* [in] */ long maxsize) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enumerations( 
            /* [retval][out] */ IDualColEnumerations __RPC_FAR *__RPC_FAR *ppdEnumerations) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Enumerations( 
            /* [in] */ IDualColEnumerations __RPC_FAR *pdEnumerations) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Storage( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Storage( 
            /* [in] */ long newValue) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsEnumeration( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsEnumeration( 
            /* [in] */ VARIANT_BOOL retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsKey( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsKey( 
            /* [in] */ VARIANT_BOOL retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualAttribute __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualAttribute __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualAttribute __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ BSTR path);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Access )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Access )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ long id);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ BSTR description);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Pragma )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Pragma )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ BSTR pragma);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Type )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ long type);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ long id);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxSize )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxSize )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ long maxsize);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Enumerations )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ IDualColEnumerations __RPC_FAR *__RPC_FAR *ppdEnumerations);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Enumerations )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ IDualColEnumerations __RPC_FAR *pdEnumerations);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Storage )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Storage )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ long newValue);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsEnumeration )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsEnumeration )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsKey )( 
            IDualAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsKey )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IDualAttribute __RPC_FAR * This,
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        END_INTERFACE
    } IDualAttributeVtbl;

    interface IDualAttribute
    {
        CONST_VTBL struct IDualAttributeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualAttribute_get_Path(This,retval)	\
    (This)->lpVtbl -> get_Path(This,retval)

#define IDualAttribute_put_Path(This,path)	\
    (This)->lpVtbl -> put_Path(This,path)

#define IDualAttribute_get_Access(This,retval)	\
    (This)->lpVtbl -> get_Access(This,retval)

#define IDualAttribute_put_Access(This,id)	\
    (This)->lpVtbl -> put_Access(This,id)

#define IDualAttribute_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IDualAttribute_put_Description(This,description)	\
    (This)->lpVtbl -> put_Description(This,description)

#define IDualAttribute_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IDualAttribute_put_Name(This,name)	\
    (This)->lpVtbl -> put_Name(This,name)

#define IDualAttribute_get_Pragma(This,retval)	\
    (This)->lpVtbl -> get_Pragma(This,retval)

#define IDualAttribute_put_Pragma(This,pragma)	\
    (This)->lpVtbl -> put_Pragma(This,pragma)

#define IDualAttribute_get_Type(This,retval)	\
    (This)->lpVtbl -> get_Type(This,retval)

#define IDualAttribute_put_Type(This,type)	\
    (This)->lpVtbl -> put_Type(This,type)

#define IDualAttribute_get_id(This,retval)	\
    (This)->lpVtbl -> get_id(This,retval)

#define IDualAttribute_put_id(This,id)	\
    (This)->lpVtbl -> put_id(This,id)

#define IDualAttribute_get_MaxSize(This,retval)	\
    (This)->lpVtbl -> get_MaxSize(This,retval)

#define IDualAttribute_put_MaxSize(This,maxsize)	\
    (This)->lpVtbl -> put_MaxSize(This,maxsize)

#define IDualAttribute_get_Enumerations(This,ppdEnumerations)	\
    (This)->lpVtbl -> get_Enumerations(This,ppdEnumerations)

#define IDualAttribute_putref_Enumerations(This,pdEnumerations)	\
    (This)->lpVtbl -> putref_Enumerations(This,pdEnumerations)

#define IDualAttribute_get_Storage(This,retval)	\
    (This)->lpVtbl -> get_Storage(This,retval)

#define IDualAttribute_put_Storage(This,newValue)	\
    (This)->lpVtbl -> put_Storage(This,newValue)

#define IDualAttribute_get_Value(This,retval)	\
    (This)->lpVtbl -> get_Value(This,retval)

#define IDualAttribute_put_Value(This,value)	\
    (This)->lpVtbl -> put_Value(This,value)

#define IDualAttribute_get_IsEnumeration(This,retval)	\
    (This)->lpVtbl -> get_IsEnumeration(This,retval)

#define IDualAttribute_put_IsEnumeration(This,retval)	\
    (This)->lpVtbl -> put_IsEnumeration(This,retval)

#define IDualAttribute_get_IsKey(This,retval)	\
    (This)->lpVtbl -> get_IsKey(This,retval)

#define IDualAttribute_put_IsKey(This,retval)	\
    (This)->lpVtbl -> put_IsKey(This,retval)

#define IDualAttribute_Read(This,varReadParm,varReadMask,retval)	\
    (This)->lpVtbl -> Read(This,varReadParm,varReadMask,retval)

#define IDualAttribute_Write(This,varWriteParm,varWriteMask,retval)	\
    (This)->lpVtbl -> Write(This,varWriteParm,varWriteMask,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_Path_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_Path_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ BSTR path);


void __RPC_STUB IDualAttribute_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_Access_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_Access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_Access_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ long id);


void __RPC_STUB IDualAttribute_put_Access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_Description_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_Description_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ BSTR description);


void __RPC_STUB IDualAttribute_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_Name_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_Name_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ BSTR name);


void __RPC_STUB IDualAttribute_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_Pragma_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_Pragma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_Pragma_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ BSTR pragma);


void __RPC_STUB IDualAttribute_put_Pragma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_Type_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_Type_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ long type);


void __RPC_STUB IDualAttribute_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_id_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_id_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ long id);


void __RPC_STUB IDualAttribute_put_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_MaxSize_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_MaxSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_MaxSize_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ long maxsize);


void __RPC_STUB IDualAttribute_put_MaxSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_Enumerations_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ IDualColEnumerations __RPC_FAR *__RPC_FAR *ppdEnumerations);


void __RPC_STUB IDualAttribute_get_Enumerations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualAttribute_putref_Enumerations_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ IDualColEnumerations __RPC_FAR *pdEnumerations);


void __RPC_STUB IDualAttribute_putref_Enumerations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_Storage_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_Storage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_Storage_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ long newValue);


void __RPC_STUB IDualAttribute_put_Storage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_Value_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_Value_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ VARIANT value);


void __RPC_STUB IDualAttribute_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_IsEnumeration_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_IsEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_IsEnumeration_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL retval);


void __RPC_STUB IDualAttribute_put_IsEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualAttribute_get_IsKey_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_get_IsKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualAttribute_put_IsKey_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL retval);


void __RPC_STUB IDualAttribute_put_IsKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualAttribute_Read_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ VARIANT varReadParm,
    /* [optional][in] */ VARIANT varReadMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualAttribute_Write_Proxy( 
    IDualAttribute __RPC_FAR * This,
    /* [in] */ VARIANT varWriteParm,
    /* [optional][in] */ VARIANT varWriteMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualAttribute_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualAttribute_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIAttribute,0xF45FB449,0xC9DA,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("F45FB449-C9DA-11CF-8844-00AA006B21BF")
DMIAttribute;
#endif

#ifndef __IColAttributes_DISPINTERFACE_DEFINED__
#define __IColAttributes_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IColAttributes
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IColAttributes,0x1A10B900,0xCDD7,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("1A10B900-CDD7-11CF-8844-00AA006B21BF")
    IColAttributes : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IColAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColAttributes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColAttributes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IColAttributes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IColAttributes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IColAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IColAttributes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IColAttributesVtbl;

    interface IColAttributes
    {
        CONST_VTBL struct IColAttributesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColAttributes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IColAttributes_DISPINTERFACE_DEFINED__ */


#ifndef __IDualColAttributes_INTERFACE_DEFINED__
#define __IDualColAttributes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualColAttributes
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualColAttributes,0xE2239A00,0xCE60,0x11cf,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("E2239A00-CE60-11cf-8844-00AA006B21BF")
    IDualColAttributes : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IDualAttribute __RPC_FAR *lpDispAttrib,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT RemoveItem,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varAttrib,
            /* [retval][out] */ IDualAttribute __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__Item( 
            /* [in] */ VARIANT varAttrib,
            /* [retval][out] */ IDualAttribute __RPC_FAR *__RPC_FAR *newValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualColAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualColAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualColAttributes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualColAttributes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualColAttributes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualColAttributes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualColAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualColAttributes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDualColAttributes __RPC_FAR * This,
            /* [in] */ IDualAttribute __RPC_FAR *lpDispAttrib,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDualColAttributes __RPC_FAR * This,
            /* [in] */ VARIANT RemoveItem,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAll )( 
            IDualColAttributes __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDualColAttributes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IDualColAttributes __RPC_FAR * This,
            /* [in] */ VARIANT varAttrib,
            /* [retval][out] */ IDualAttribute __RPC_FAR *__RPC_FAR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDualColAttributes __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__Item )( 
            IDualColAttributes __RPC_FAR * This,
            /* [in] */ VARIANT varAttrib,
            /* [retval][out] */ IDualAttribute __RPC_FAR *__RPC_FAR *newValue);
        
        END_INTERFACE
    } IDualColAttributesVtbl;

    interface IDualColAttributes
    {
        CONST_VTBL struct IDualColAttributesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualColAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualColAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualColAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualColAttributes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualColAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualColAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualColAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualColAttributes_Add(This,lpDispAttrib,retval)	\
    (This)->lpVtbl -> Add(This,lpDispAttrib,retval)

#define IDualColAttributes_Remove(This,RemoveItem,retval)	\
    (This)->lpVtbl -> Remove(This,RemoveItem,retval)

#define IDualColAttributes_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#define IDualColAttributes_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define IDualColAttributes_get_Item(This,varAttrib,retval)	\
    (This)->lpVtbl -> get_Item(This,varAttrib,retval)

#define IDualColAttributes_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#define IDualColAttributes_get__Item(This,varAttrib,newValue)	\
    (This)->lpVtbl -> get__Item(This,varAttrib,newValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColAttributes_Add_Proxy( 
    IDualColAttributes __RPC_FAR * This,
    /* [in] */ IDualAttribute __RPC_FAR *lpDispAttrib,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColAttributes_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColAttributes_Remove_Proxy( 
    IDualColAttributes __RPC_FAR * This,
    /* [in] */ VARIANT RemoveItem,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColAttributes_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColAttributes_RemoveAll_Proxy( 
    IDualColAttributes __RPC_FAR * This);


void __RPC_STUB IDualColAttributes_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColAttributes_get_Count_Proxy( 
    IDualColAttributes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColAttributes_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColAttributes_get_Item_Proxy( 
    IDualColAttributes __RPC_FAR * This,
    /* [in] */ VARIANT varAttrib,
    /* [retval][out] */ IDualAttribute __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColAttributes_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDualColAttributes_get__NewEnum_Proxy( 
    IDualColAttributes __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColAttributes_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColAttributes_get__Item_Proxy( 
    IDualColAttributes __RPC_FAR * This,
    /* [in] */ VARIANT varAttrib,
    /* [retval][out] */ IDualAttribute __RPC_FAR *__RPC_FAR *newValue);


void __RPC_STUB IDualColAttributes_get__Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualColAttributes_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIAttributes,0x1A10B901,0xCDD7,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("1A10B901-CDD7-11CF-8844-00AA006B21BF")
DMIAttributes;
#endif

#ifndef __IRow_DISPINTERFACE_DEFINED__
#define __IRow_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IRow
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IRow,0x3AB30761,0xE3B9,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("3AB30761-E3B9-11CF-8844-00AA006B21BF")
    IRow : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IRowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IRowVtbl;

    interface IRow
    {
        CONST_VTBL struct IRowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IRow_DISPINTERFACE_DEFINED__ */


#ifndef __IDualRow_INTERFACE_DEFINED__
#define __IDualRow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualRow
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualRow,0x87DFD221,0xE3D7,0x11cf,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("87DFD221-E3D7-11cf-8844-00AA006B21BF")
    IDualRow : public IDispatch
    {
    public:
        virtual /* [helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Attributes( 
            /* [in] */ IDualColAttributes __RPC_FAR *attributes) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_id( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_id( 
            /* [in] */ long id) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR path) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeyList( 
            /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_KeyList( 
            /* [in] */ IDualColAttributes __RPC_FAR *pKeyList) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualRowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualRow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualRow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualRow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            IDualRow __RPC_FAR * This,
            /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Attributes )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ IDualColAttributes __RPC_FAR *attributes);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IDualRow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ long id);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IDualRow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ BSTR path);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_KeyList )( 
            IDualRow __RPC_FAR * This,
            /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_KeyList )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ IDualColAttributes __RPC_FAR *pKeyList);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IDualRow __RPC_FAR * This,
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        END_INTERFACE
    } IDualRowVtbl;

    interface IDualRow
    {
        CONST_VTBL struct IDualRowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualRow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualRow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualRow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualRow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualRow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualRow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualRow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualRow_get_Attributes(This,retval)	\
    (This)->lpVtbl -> get_Attributes(This,retval)

#define IDualRow_putref_Attributes(This,attributes)	\
    (This)->lpVtbl -> putref_Attributes(This,attributes)

#define IDualRow_get_id(This,retval)	\
    (This)->lpVtbl -> get_id(This,retval)

#define IDualRow_put_id(This,id)	\
    (This)->lpVtbl -> put_id(This,id)

#define IDualRow_get_Path(This,retval)	\
    (This)->lpVtbl -> get_Path(This,retval)

#define IDualRow_put_Path(This,path)	\
    (This)->lpVtbl -> put_Path(This,path)

#define IDualRow_get_KeyList(This,retval)	\
    (This)->lpVtbl -> get_KeyList(This,retval)

#define IDualRow_putref_KeyList(This,pKeyList)	\
    (This)->lpVtbl -> putref_KeyList(This,pKeyList)

#define IDualRow_Read(This,varReadParm,varReadMask,retval)	\
    (This)->lpVtbl -> Read(This,varReadParm,varReadMask,retval)

#define IDualRow_Write(This,varWriteParm,varWriteMask,retval)	\
    (This)->lpVtbl -> Write(This,varWriteParm,varWriteMask,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE IDualRow_get_Attributes_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualRow_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualRow_putref_Attributes_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [in] */ IDualColAttributes __RPC_FAR *attributes);


void __RPC_STUB IDualRow_putref_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualRow_get_id_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualRow_get_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualRow_put_id_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [in] */ long id);


void __RPC_STUB IDualRow_put_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualRow_get_Path_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualRow_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualRow_put_Path_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [in] */ BSTR path);


void __RPC_STUB IDualRow_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualRow_get_KeyList_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualRow_get_KeyList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualRow_putref_KeyList_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [in] */ IDualColAttributes __RPC_FAR *pKeyList);


void __RPC_STUB IDualRow_putref_KeyList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualRow_Read_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [in] */ VARIANT varReadParm,
    /* [optional][in] */ VARIANT varReadMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualRow_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualRow_Write_Proxy( 
    IDualRow __RPC_FAR * This,
    /* [in] */ VARIANT varWriteParm,
    /* [optional][in] */ VARIANT varWriteMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualRow_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualRow_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIRow,0x3AB30762,0xE3B9,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("3AB30762-E3B9-11CF-8844-00AA006B21BF")
DMIRow;
#endif

#ifndef __IColRows_DISPINTERFACE_DEFINED__
#define __IColRows_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IColRows
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IColRows,0x7BF7A480,0xE3D5,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("7BF7A480-E3D5-11CF-8844-00AA006B21BF")
    IColRows : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IColRowsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColRows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColRows __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColRows __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IColRows __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IColRows __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IColRows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IColRows __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IColRowsVtbl;

    interface IColRows
    {
        CONST_VTBL struct IColRowsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColRows_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColRows_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColRows_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColRows_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColRows_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColRows_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColRows_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IColRows_DISPINTERFACE_DEFINED__ */


#ifndef __IDualColRows_INTERFACE_DEFINED__
#define __IDualColRows_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualColRows
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualColRows,0x87DFD220,0xE3D7,0x11cf,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("87DFD220-E3D7-11cf-8844-00AA006B21BF")
    IDualColRows : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IDualRow __RPC_FAR *lpDualRow,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT RemoveItem,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFirstRow( 
            /* [optional][in] */ VARIANT varKeyList,
            /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *lpdRow) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNextRow( 
            /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *lpdRow) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varRow,
            /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__Item( 
            /* [in] */ VARIANT varRow,
            /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualColRowsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualColRows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualColRows __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualColRows __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualColRows __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualColRows __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualColRows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualColRows __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDualColRows __RPC_FAR * This,
            /* [in] */ IDualRow __RPC_FAR *lpDualRow,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDualColRows __RPC_FAR * This,
            /* [in] */ VARIANT RemoveItem,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAll )( 
            IDualColRows __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstRow )( 
            IDualColRows __RPC_FAR * This,
            /* [optional][in] */ VARIANT varKeyList,
            /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *lpdRow);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextRow )( 
            IDualColRows __RPC_FAR * This,
            /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *lpdRow);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDualColRows __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IDualColRows __RPC_FAR * This,
            /* [in] */ VARIANT varRow,
            /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__Item )( 
            IDualColRows __RPC_FAR * This,
            /* [in] */ VARIANT varRow,
            /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDualColRows __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        END_INTERFACE
    } IDualColRowsVtbl;

    interface IDualColRows
    {
        CONST_VTBL struct IDualColRowsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualColRows_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualColRows_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualColRows_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualColRows_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualColRows_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualColRows_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualColRows_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualColRows_Add(This,lpDualRow,retval)	\
    (This)->lpVtbl -> Add(This,lpDualRow,retval)

#define IDualColRows_Remove(This,RemoveItem,retval)	\
    (This)->lpVtbl -> Remove(This,RemoveItem,retval)

#define IDualColRows_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#define IDualColRows_GetFirstRow(This,varKeyList,lpdRow)	\
    (This)->lpVtbl -> GetFirstRow(This,varKeyList,lpdRow)

#define IDualColRows_GetNextRow(This,lpdRow)	\
    (This)->lpVtbl -> GetNextRow(This,lpdRow)

#define IDualColRows_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define IDualColRows_get_Item(This,varRow,retval)	\
    (This)->lpVtbl -> get_Item(This,varRow,retval)

#define IDualColRows_get__Item(This,varRow,retval)	\
    (This)->lpVtbl -> get__Item(This,varRow,retval)

#define IDualColRows_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColRows_Add_Proxy( 
    IDualColRows __RPC_FAR * This,
    /* [in] */ IDualRow __RPC_FAR *lpDualRow,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColRows_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColRows_Remove_Proxy( 
    IDualColRows __RPC_FAR * This,
    /* [in] */ VARIANT RemoveItem,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColRows_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColRows_RemoveAll_Proxy( 
    IDualColRows __RPC_FAR * This);


void __RPC_STUB IDualColRows_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColRows_GetFirstRow_Proxy( 
    IDualColRows __RPC_FAR * This,
    /* [optional][in] */ VARIANT varKeyList,
    /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *lpdRow);


void __RPC_STUB IDualColRows_GetFirstRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColRows_GetNextRow_Proxy( 
    IDualColRows __RPC_FAR * This,
    /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *lpdRow);


void __RPC_STUB IDualColRows_GetNextRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColRows_get_Count_Proxy( 
    IDualColRows __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColRows_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColRows_get_Item_Proxy( 
    IDualColRows __RPC_FAR * This,
    /* [in] */ VARIANT varRow,
    /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColRows_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColRows_get__Item_Proxy( 
    IDualColRows __RPC_FAR * This,
    /* [in] */ VARIANT varRow,
    /* [retval][out] */ IDualRow __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColRows_get__Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDualColRows_get__NewEnum_Proxy( 
    IDualColRows __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColRows_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualColRows_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIRows,0x7BF7A481,0xE3D5,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("7BF7A481-E3D5-11CF-8844-00AA006B21BF")
DMIRows;
#endif

#ifndef __IGroup_DISPINTERFACE_DEFINED__
#define __IGroup_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IGroup
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IGroup,0xDA6FAB60,0xDF21,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("DA6FAB60-DF21-11CF-8844-00AA006B21BF")
    IGroup : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGroup __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGroup __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGroup __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IGroupVtbl;

    interface IGroup
    {
        CONST_VTBL struct IGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IGroup_DISPINTERFACE_DEFINED__ */


#ifndef __IDualGroup_INTERFACE_DEFINED__
#define __IDualGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualGroup
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualGroup,0xB9C1FDE0,0xE152,0x11cf,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("B9C1FDE0-E152-11cf-8844-00AA006B21BF")
    IDualGroup : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_id( 
            /* [in] */ long GroupId) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_id( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR ClassName) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Pragma( 
            /* [in] */ BSTR Pragma) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pragma( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR Description) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR path) = 0;
        
        virtual /* [helpcontext][id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Rows( 
            /* [retval][out] */ IDualColRows __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][id][helpstring][propputref] */ HRESULT STDMETHODCALLTYPE putref_Rows( 
            /* [in] */ IDualColRows __RPC_FAR *rows) = 0;
        
        virtual /* [helpcontext][id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][id][helpstring][propputref] */ HRESULT STDMETHODCALLTYPE putref_Attributes( 
            /* [in] */ IDualColAttributes __RPC_FAR *attributes) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ClassString( 
            /* [in] */ BSTR ClassString) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClassString( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsTable( 
            /* [in] */ VARIANT_BOOL GroupId) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsTable( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Keys( 
            /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Keys( 
            /* [in] */ IDualColAttributes __RPC_FAR *pdattribs) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualGroup __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ long GroupId);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ BSTR ClassName);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Pragma )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ BSTR Pragma);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Pragma )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ BSTR Description);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ BSTR path);
        
        /* [helpcontext][id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rows )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ IDualColRows __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][id][helpstring][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Rows )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ IDualColRows __RPC_FAR *rows);
        
        /* [helpcontext][id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][id][helpstring][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Attributes )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ IDualColAttributes __RPC_FAR *attributes);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ClassString )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ BSTR ClassString);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClassString )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsTable )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL GroupId);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsTable )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Keys )( 
            IDualGroup __RPC_FAR * This,
            /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Keys )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ IDualColAttributes __RPC_FAR *pdattribs);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IDualGroup __RPC_FAR * This,
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        END_INTERFACE
    } IDualGroupVtbl;

    interface IDualGroup
    {
        CONST_VTBL struct IDualGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualGroup_put_id(This,GroupId)	\
    (This)->lpVtbl -> put_id(This,GroupId)

#define IDualGroup_get_id(This,retval)	\
    (This)->lpVtbl -> get_id(This,retval)

#define IDualGroup_put_Name(This,ClassName)	\
    (This)->lpVtbl -> put_Name(This,ClassName)

#define IDualGroup_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IDualGroup_put_Pragma(This,Pragma)	\
    (This)->lpVtbl -> put_Pragma(This,Pragma)

#define IDualGroup_get_Pragma(This,retval)	\
    (This)->lpVtbl -> get_Pragma(This,retval)

#define IDualGroup_put_Description(This,Description)	\
    (This)->lpVtbl -> put_Description(This,Description)

#define IDualGroup_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IDualGroup_get_Path(This,retval)	\
    (This)->lpVtbl -> get_Path(This,retval)

#define IDualGroup_put_Path(This,path)	\
    (This)->lpVtbl -> put_Path(This,path)

#define IDualGroup_get_Rows(This,retval)	\
    (This)->lpVtbl -> get_Rows(This,retval)

#define IDualGroup_putref_Rows(This,rows)	\
    (This)->lpVtbl -> putref_Rows(This,rows)

#define IDualGroup_get_Attributes(This,retval)	\
    (This)->lpVtbl -> get_Attributes(This,retval)

#define IDualGroup_putref_Attributes(This,attributes)	\
    (This)->lpVtbl -> putref_Attributes(This,attributes)

#define IDualGroup_put_ClassString(This,ClassString)	\
    (This)->lpVtbl -> put_ClassString(This,ClassString)

#define IDualGroup_get_ClassString(This,retval)	\
    (This)->lpVtbl -> get_ClassString(This,retval)

#define IDualGroup_put_IsTable(This,GroupId)	\
    (This)->lpVtbl -> put_IsTable(This,GroupId)

#define IDualGroup_get_IsTable(This,retval)	\
    (This)->lpVtbl -> get_IsTable(This,retval)

#define IDualGroup_get_Keys(This,retval)	\
    (This)->lpVtbl -> get_Keys(This,retval)

#define IDualGroup_putref_Keys(This,pdattribs)	\
    (This)->lpVtbl -> putref_Keys(This,pdattribs)

#define IDualGroup_Read(This,varReadParm,varReadMask,retval)	\
    (This)->lpVtbl -> Read(This,varReadParm,varReadMask,retval)

#define IDualGroup_Write(This,varWriteParm,varWriteMask,retval)	\
    (This)->lpVtbl -> Write(This,varWriteParm,varWriteMask,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualGroup_put_id_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ long GroupId);


void __RPC_STUB IDualGroup_put_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_id_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualGroup_put_Name_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ BSTR ClassName);


void __RPC_STUB IDualGroup_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_Name_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualGroup_put_Pragma_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ BSTR Pragma);


void __RPC_STUB IDualGroup_put_Pragma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_Pragma_Proxy( 
    IDualGroup __RPC_FAR * This,
  