                                        
                                           
    ParameterValuse - default parameter value

Return Value:

    NT Status

--*/
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    defaultParameterValue;   
    ULONG                    i;
    ULONG                    flag;

    PAGED_CODE();

    for (i=0; i<2; i++) {

        if (i == 0) {

            flag = PLUGPLAY_REGKEY_DRIVER | PLUGPLAY_REGKEY_CURRENT_HWPROFILE;

        } else {

            flag = PLUGPLAY_REGKEY_DRIVER;
        }
        //
        // open the given parameter
        //
        status = IoOpenDeviceRegistryKey(DeviceObject,
                                         flag,
                                         KEY_READ,
                                         &deviceParameterHandle);
    
        if(!NT_SUCCESS(status)) {
    
            continue;
        }
    
        RtlZeroMemory(queryTable, sizeof(queryTable));
    
        defaultParameterValue = *ParameterValue;
    
        queryTable->Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        queryTable->Name          = ParameterName;
        queryTable->EntryContext  = ParameterValue;
        queryTable->DefaultType   = REG_NONE;
        queryTable->DefaultData   = NULL;
        queryTable->DefaultLength = 0;
    
        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) deviceParameterHandle,
                                        queryTable,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status)) {
    
            *ParameterValue = defaultParameterValue;
        }
    
        //
        // close what we open
        //
        ZwClose(deviceParameterHandle);

        if (NT_SUCCESS(status)) {

            break;
        }
    }
    return status;

} // PciIdeXGetDeviceParameter


VOID
PciIdeUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    get ready to be unloaded

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PAGED_CODE();

    DebugPrint ((1, "PciIde: unloading...\n"));

    ASSERT (DriverObject->DeviceObject == NULL);
    return;
} // PciIdeUnload

NTSTATUS
PciIdeXSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  newIrpSp;
    PIRP                newIrp;
    KEVENT              event;
    NTSTATUS            status;

    ASSERT (TargetDeviceObject);
    ASSERT (IrpSp);
    PAGED_CODE();

    //
    // Allocate an IRP for below
    //
    newIrp = IoAllocateIrp (TargetDeviceObject->StackSize, FALSE);      // Get stack size from PDO
    if (newIrp == NULL) {

        DebugPrint ((0, "PciIdeXSyncSendIrp: Unable to get allocate an irp"));
        return STATUS_NO_MEMORY;
    }

    newIrpSp = IoGetNextIrpStackLocation(newIrp);
    RtlMoveMemory (newIrpSp, IrpSp, sizeof (*IrpSp));

    if (IoStatus) {

        newIrp->IoStatus.Status = IoStatus->Status;

    } else {

        newIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    }

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    IoSetCompletionRoutine (
        newIrp, 
        PciIdeXSyncSendIrpCompletionRoutine, 
        &event, 
        TRUE, 
        TRUE, 
        TRUE);
    status = IoCallDriver (TargetDeviceObject, newIrp);

    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(&event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
    }
    status = newIrp->IoStatus.Status;

    if (IoStatus) {

        *IoStatus = newIrp->IoStatus;
    }

    IoFreeIrp (newIrp);
    return status;
} // PciIdeXSyncSendIrp

NTSTATUS
PciIdeXSyncSendIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = Context;

    KeSetEvent(
        event,
        EVENT_INCREMENT,
        FALSE
        );

    return STATUS_MORE_PROCESSING_REQUIRED;
} // IdePortSyncSendIrpCompletionRoutine

#if DBG

NTSTATUS
PciIdeXSaveDeviceParameter (
    IN PVOID DeviceExtension,
    IN PWSTR ParameterName,
    IN ULONG ParameterValue
    )
/*++

Routine Description:

    save a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to save                                        
                                           
    ParameterValuse - parameter value to save

Return Value:

    NT Status

--*/
{
    NTSTATUS           status;
    HANDLE             deviceParameterHandle;
    PCTRLFDO_EXTENSION fdoExtension = ((PCTRLFDO_EXTENSION) DeviceExtension) - 1;

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(fdoExtension->AttacheePdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_WRITE,
                                     &deviceParameterHandle);

    if(!NT_SUCCESS(status)) {

        DebugPrint((1,
                    "PciIdeXSaveDeviceParameter: IoOpenDeviceRegistryKey() returns 0x%x\n",
                    status));

        return status;
    }

    //
    // write the parameter value
    //
    status = RtlWriteRegistryValue(
                 RTL_REGISTRY_HANDLE,
                 (PWSTR) deviceParameterHandle,
                 ParameterName,
                 REG_DWORD,
                 &ParameterValue,
                 sizeof (ParameterValue)
                 );


    if(!NT_SUCCESS(status)) {

        DebugPrint((1,
                    "PciIdeXSaveDeviceParameter: RtlWriteRegistryValue() returns 0x%x\n",
                    status));
    }

    //
    // close what we open
    //
    ZwClose(deviceParameterHandle);
    return status;
} // IdePortSaveDeviceParameter

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\power.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       power.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciIdeIssueSetPowerState)

#pragma alloc_text(NONPAGE, PciIdePowerCompletionRoutine)
#pragma alloc_text(NONPAGE, PciIdeSetPdoPowerState)
#pragma alloc_text(NONPAGE, PciIdeSetFdoPowerState)
#pragma alloc_text(NONPAGE, FdoContingentPowerCompletionRoutine)
#pragma alloc_text(NONPAGE, FdoPowerCompletionRoutine)
#pragma alloc_text(NONPAGE, FdoChildReportPowerDown)
#pragma alloc_text(NONPAGE, FdoChildRequestPowerUp)
#pragma alloc_text(NONPAGE, FdoChildRequestPowerUpCompletionRoutine)
#endif // ALLOC_PRAGMA


NTSTATUS
PciIdeIssueSetPowerState (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN POWER_STATE_TYPE   Type,
    IN POWER_STATE        State,
    IN BOOLEAN            Sync
    )
{
    PIRP                      irp = NULL;
    PIO_STACK_LOCATION        irpStack;
    SET_POWER_STATE_CONTEXT   context;
    NTSTATUS                  status;
    CCHAR                     stackSize;

    PAGED_CODE();

    if (Sync) {

        KeInitializeEvent(
            &context.Event,
            NotificationEvent,
            FALSE
            );
    }

    stackSize = (CCHAR) (FdoExtension->DeviceObject->StackSize + 1);

    irp = IoAllocateIrp(
            stackSize,
            FALSE
            );

    if (irp == NULL) {

        status = STATUS_NO_MEMORY;
        goto GetOut;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_POWER;
    irpStack->MinorFunction = IRP_MN_SET_POWER;

    irpStack->Parameters.Power.SystemContext = 0;
    irpStack->Parameters.Power.Type          = Type;
    irpStack->Parameters.Power.State         = State;

    IoSetCompletionRoutine(irp,
                           PciIdePowerCompletionRoutine,
                           Sync ? &context : NULL,
                           TRUE,
                           TRUE,
                           TRUE);

    status = PoCallDriver(FdoExtension->DeviceObject, irp);


    //
    //Wait for the completion routine. It will be called anyway.
    //
//    if ((status == STATUS_PENDING) && (Sync)) {
    if (Sync) {

        KeWaitForSingleObject(&context.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = context.Status;
    }

GetOut:

    return status;
} // PciIdeIssueSetPowerState

NTSTATUS
PciIdePowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PSET_POWER_STATE_CONTEXT context = Context;

    if (context) {

        context->Status = Irp->IoStatus.Status;

        KeSetEvent(
            &context->Event,
            EVENT_INCREMENT,
            FALSE
            );
    }

    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
} // PciIdePowerCompletionRoutine


NTSTATUS
PciIdeXQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;

    deviceExtensionHeader = DeviceObject->DeviceExtension;

#if defined (DONT_POWER_DOWN_PAGING_DEVICE)

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    if (!deviceExtensionHeader->CrashDumpPathCount ||
        ((irpStack->Parameters.Power.Type == SystemPowerState) &&
         (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking)) ||
        ((irpStack->Parameters.Power.Type == DevicePowerState) &&
         (irpStack->Parameters.Power.State.SystemState == PowerDeviceD0))) {

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_DEVICE_POWER_FAILURE;
    }
#else 

    status = STATUS_SUCCESS;

#endif // DONT_POWER_DOWN_PAGING_DEVICE


    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp (Irp);

    if (deviceExtensionHeader->AttacheeDeviceObject != NULL) {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        status = PoCallDriver (deviceExtensionHeader->AttacheeDeviceObject, Irp);
    }
    else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }


    return status;
}


NTSTATUS
PciIdeSetPdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack;
    PCHANPDO_EXTENSION pdoExtension;
    NTSTATUS           status;

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        irpStack = IoGetCurrentIrpStackLocation (Irp);
        status   = STATUS_SUCCESS;
    
        if (irpStack->Parameters.Power.Type == SystemPowerState) {
    
            if (pdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {
    
                POWER_STATE powerState;
    
                pdoExtension->SystemPowerState = irpStack->Parameters.Power.State.SystemState;
    
                DebugPrint ((1, "PciIdeX: New Pdo 0x%x system power state 0x%x\n", pdoExtension->ChannelNumber, irpStack->Parameters.Power.State.SystemState));
            }
    
        } else if (irpStack->Parameters.Power.Type == DevicePowerState) {
    
            if (pdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {
    
                //
                // checking old device state
                //
                if (pdoExtension->DevicePowerState == PowerDeviceD3) {
    
                    //
                    // waking up
                    //
                    IoMarkIrpPending(Irp);
                    Irp->IoStatus.Information = irpStack->Parameters.Power.State.DeviceState;
                    status  = FdoChildRequestPowerUp (
                                  pdoExtension->ParentDeviceExtension,
                                  pdoExtension,
                                  Irp
                                  );
                    ASSERT (NT_SUCCESS(status));
                    status = STATUS_PENDING;
    
                } else {
    
                    if (pdoExtension->DevicePowerState == PowerDeviceD0) {
    
                        //
                        // getting out of D0 state, better call PoSetPowerState now
                        //
                        PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State
                            );
                    } 
                    
                    DebugPrint ((1, "PciIdeX: New Pdo 0x%x device power state 0x%x\n", pdoExtension->ChannelNumber, irpStack->Parameters.Power.State.DeviceState));
    
                    pdoExtension->DevicePowerState = irpStack->Parameters.Power.State.DeviceState;
        
                    if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) {
        
                        //
                        // tell parent that we just fell to sleep
                        //
                        FdoChildReportPowerDown (
                            pdoExtension->ParentDeviceExtension,
                            pdoExtension
                            );
                    }
                }
            }
        } else {
    
            ASSERT (FALSE);
            status = STATUS_NOT_IMPLEMENTED;
        }
    }

    if (status != STATUS_PENDING) {

        if (NT_SUCCESS(status)) {

            Irp->IoStatus.Information = irpStack->Parameters.Power.State.SystemState;
        }
        Irp->IoStatus.Status = status;

        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
} // PciIdeSetPdoPowerState

NTSTATUS
PciIdeSetFdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status = STATUS_SUCCESS;
    PCTRLFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpStack;
    PFDO_POWER_CONTEXT context;
    BOOLEAN            noCompletionRoutine;
    BOOLEAN            systemPowerContext = FALSE;
    BOOLEAN            devicePowerContext = FALSE;

    fdoExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    //context = ExAllocatePool (NonPagedPool, sizeof(FDO_POWER_CONTEXT));

    //
    // We need two pre-alloced context structures. This is because a system power irp
    // would result in a device power irp to be issued before the former is completed.
    // 
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 1, 0) == 0);
        context = &(fdoExtension->FdoPowerContext[0]);
        systemPowerContext = TRUE;

    } else {

        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 1, 0) == 0);
        context = &(fdoExtension->FdoPowerContext[1]);
        devicePowerContext = TRUE;

    }

    if (context == NULL) {
        
        ASSERT(context);
        status = STATUS_NO_MEMORY;
    } else {

        RtlZeroMemory (context, sizeof(FDO_POWER_CONTEXT));

        //irpStack = IoGetCurrentIrpStackLocation (Irp);

        context->OriginalPowerIrp = Irp;
        context->newPowerType     = irpStack->Parameters.Power.Type;
        context->newPowerState    = irpStack->Parameters.Power.State;
    
        noCompletionRoutine = FALSE;

        if (irpStack->Parameters.Power.Type == SystemPowerState) {
    
            if (fdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

                POWER_STATE powerState;
                BOOLEAN requestPowerState = FALSE;

                if ((irpStack->Parameters.Power.State.SystemState == PowerSystemShutdown) &&
                    (irpStack->Parameters.Power.ShutdownType == PowerActionShutdownReset)) {

                    //
                    // spin up for BIOS POST
                    //
                    requestPowerState = TRUE;
                    powerState.DeviceState = PowerDeviceD0;

                } else if (fdoExtension->SystemPowerState == PowerSystemWorking) {

                    //
                    // we are getting out of working state...power down
                    //
                    requestPowerState = TRUE;
                    powerState.DeviceState = PowerDeviceD3;
                }

                if (requestPowerState) {

                    IoMarkIrpPending(Irp);
                       
                    PoRequestPowerIrp (
                        fdoExtension->DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        FdoContingentPowerCompletionRoutine,
                        context,
                        NULL
                        );
    
                    return STATUS_PENDING;
                }


            } else {

                //
                // We are already in the given state
                //
                noCompletionRoutine = TRUE;
            }
    
        } else if (irpStack->Parameters.Power.Type == DevicePowerState) {
    
            if (fdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {
    
                if (fdoExtension->DevicePowerState == PowerDeviceD0) {
    
                    //
                    // getting out of D0 state, better call PoSetPowerState now
                    //
                    PoSetPowerState (
                        DeviceObject,
                        DevicePowerState,
                        irpStack->Parameters.Power.State
                        );
                }

            } else {

                //
                // We are already in the given state
                //
                noCompletionRoutine = TRUE;
            }
        } else {
    
            ASSERT (FALSE);
            status = STATUS_NOT_IMPLEMENTED;
        }
    }

    if (NT_SUCCESS(status)) {
    
		IoMarkIrpPending (Irp);

        IoCopyCurrentIrpStackLocationToNext (Irp);
    
        if (!noCompletionRoutine) {
        
            IoSetCompletionRoutine(Irp,
                                   FdoPowerCompletionRoutine,
                                   context,
                                   TRUE,
                                   TRUE,
                                   TRUE);
        } else {
        
            if (context) {
                //ExFreePool (context);
                if (systemPowerContext) {
                    ASSERT(devicePowerContext == FALSE);
                    ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);

                }

                if (devicePowerContext) {
                    ASSERT(systemPowerContext == FALSE);
                    ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
                }
            }
            PoStartNextPowerIrp (Irp);
        }
    
        PoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
        return STATUS_PENDING;

    } else {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;

        if (context) {
            //ExFreePool (context);
            if (systemPowerContext) {
                ASSERT(devicePowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);

            }

            if (devicePowerContext) {
                ASSERT(systemPowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
            }
        }

        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
    }
} // PciIdeSetFdoPowerState

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PFDO_POWER_CONTEXT context = Context;
    PIRP irp;
    PCTRLFDO_EXTENSION fdoExtension;

    fdoExtension = DeviceObject->DeviceExtension;

    irp = context->OriginalPowerIrp;

    if (NT_SUCCESS(IoStatus->Status)) {


        IoCopyCurrentIrpStackLocationToNext (irp);
    
        IoSetCompletionRoutine(irp,
                               FdoPowerCompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);
    
        PoCallDriver (fdoExtension->AttacheeDeviceObject, irp);

    } else {

        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = IoStatus->Status;
        //ExFreePool (context);
        ASSERT(context->newPowerType == SystemPowerState);
        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);

        PoStartNextPowerIrp (irp);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return IoStatus->Status;
} // FdoContingentPowerCompletionRoutine


NTSTATUS
FdoPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFDO_POWER_CONTEXT context = Context;
    BOOLEAN            callPoSetPowerState = FALSE;
    PCTRLFDO_EXTENSION fdoExtension;
    POWER_STATE        newPowerState;
    POWER_STATE_TYPE   newPowerType;
    BOOLEAN            unlocked = FALSE;
	BOOLEAN			   moreProcessingRequired = FALSE;
	NTSTATUS		   status;

    fdoExtension = DeviceObject->DeviceExtension;
    newPowerType = context->newPowerType;
    newPowerState = context->newPowerState;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        callPoSetPowerState = TRUE;

        if (context->newPowerType == SystemPowerState) { 

            fdoExtension->SystemPowerState = context->newPowerState.SystemState;

            if (fdoExtension->SystemPowerState == PowerSystemWorking) {
                
                POWER_STATE powerState;

                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
                unlocked = TRUE;

				moreProcessingRequired = TRUE;

                //
                // initiate a D0 here to cause a re-enumuration
                //
                powerState.DeviceState = PowerDeviceD0;
				status = PoRequestPowerIrp ( 
									fdoExtension->DeviceObject, 
									IRP_MN_SET_POWER, 
									powerState,
									FdoSystemPowerUpCompletionRoutine,
									Irp,
									NULL
									);

				ASSERT(status == STATUS_PENDING);

            }

            DebugPrint ((1, "PciIdeX: New Fdo system power state 0x%x\n", fdoExtension->SystemPowerState));


        } else if (context->newPowerType == DevicePowerState) { 

            if (fdoExtension->DevicePowerState == PowerDeviceD0) {

                //
                // PoSetPowerState is called before we get out of D0
                //
                callPoSetPowerState = FALSE;
            }

            fdoExtension->DevicePowerState = context->newPowerState.DeviceState;

            if (fdoExtension->DevicePowerState == PowerDeviceD0) {

                //
                // Re-enumerate the devices on the channel
                //
                EnablePCIBusMastering (fdoExtension);

                IoInvalidateDeviceRelations (
                    fdoExtension->AttacheePdo,
                    BusRelations
                    );
            }

            DebugPrint ((1, "PciIdeX: New Fdo device power state 0x%x\n", fdoExtension->DevicePowerState));
        }

		if (callPoSetPowerState) {

			PoSetPowerState (
				DeviceObject,
				newPowerType,
				newPowerState                
				);
		}
    }

    //ExFreePool (Context);
    if (!unlocked) {

        if (context->newPowerType == SystemPowerState) {
            ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
        } else {
            ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
        }
    }

	//
	// wait for the device irp to complete
	//
	if (moreProcessingRequired) {
		return STATUS_MORE_PROCESSING_REQUIRED;
	}

    //
    // If pending has be returned for this irp then mark the current stack as
    // pending.
    //
   // if (Irp->PendingReturned) {
    //    IoMarkIrpPending(Irp);
    //}

	PoStartNextPowerIrp (Irp);
    return Irp->IoStatus.Status;
} // FdoPowerCompletionRoutine

                        
VOID
FdoChildReportPowerDown (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN PCHANPDO_EXTENSION PdoExtension
    )
{
    POWER_STATE powerState;
    ULONG       numChildrenPowerUp;

    ASSERT(FdoExtension->NumberOfChildrenPowerUp > 0);
    numChildrenPowerUp = InterlockedDecrement(&FdoExtension->NumberOfChildrenPowerUp);

    if (numChildrenPowerUp == 0) {

        DebugPrint ((1, "PciIdeX FdoChildReportPowerDown: sleep fdo 0x%x\n", FdoExtension));

        //
        // All the children are powered down, we can now power down 
        // the parent (the controller)
        //
        powerState.DeviceState = PowerDeviceD3;
        PoRequestPowerIrp (
            FdoExtension->DeviceObject,
            IRP_MN_SET_POWER,
            powerState,
            NULL,
            NULL,
            NULL
            );

    } 
   // else if (numChildrenPowerUp < 0) {

        //
        // should never happen. If it did, pretend it didn't
        //
    //    ASSERT (FALSE);
     //   InterlockedExchange(&FdoExtension->NumberOfChildrenPowerUp, 0);
    //}

    return;
} // FdoChildReportPowerDown
                        
                        
NTSTATUS
FdoChildRequestPowerUp (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN PCHANPDO_EXTENSION PdoExtension,
    IN PIRP               ChildPowerIrp
    )
{
    NTSTATUS            status;
    POWER_STATE         powerState;
    ULONG               numberOfChildrenPowerUp;
    IO_STATUS_BLOCK     IoStatus;

    status = STATUS_SUCCESS;

    numberOfChildrenPowerUp = InterlockedExchange (
                                  &FdoExtension->NumberOfChildrenPowerUp, 
                                  FdoExtension->NumberOfChildrenPowerUp
                                  );

    if (numberOfChildrenPowerUp == 0) {

        DebugPrint ((1, "PciIdeX FdoChildRequestPowerUp: wake up fdo 0x%x\n", FdoExtension));

        //
        // One of the children is coming out of sleep, 
        // we need to power up the parent (the controller)
        //
        powerState.DeviceState = PowerDeviceD0;
        status = PoRequestPowerIrp (
                     FdoExtension->DeviceObject,
                     IRP_MN_SET_POWER,
                     powerState,
                     FdoChildRequestPowerUpCompletionRoutine,
                     ChildPowerIrp,
                     NULL
                     );

        ASSERT (NT_SUCCESS(status));
        status = STATUS_PENDING;

    } else {

        powerState.DeviceState = PowerDeviceD0;
        IoStatus.Information   = PowerDeviceD0;
        IoStatus.Status        = STATUS_SUCCESS;

        FdoChildRequestPowerUpCompletionRoutine (
            FdoExtension->DeviceObject,
            IRP_MN_SET_POWER,
            powerState,
            ChildPowerIrp,
            &IoStatus
            );

        status = STATUS_PENDING;
    }

    return status;
} // FdoChildRequestPowerUp

NTSTATUS
FdoChildRequestPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PIRP                childPowerIrp = Context;
    PCTRLFDO_EXTENSION  fdoExtension;
    PCHANPDO_EXTENSION  pdoExtension;
    PIO_STACK_LOCATION  irpStack;

    fdoExtension = DeviceObject->DeviceExtension;

    if (NT_SUCCESS(IoStatus->Status)) {

        ULONG numberOfChildrenPowerUp;

        numberOfChildrenPowerUp = InterlockedIncrement (&fdoExtension->NumberOfChildrenPowerUp);

        irpStack = IoGetCurrentIrpStackLocation (childPowerIrp);
        pdoExtension = irpStack->DeviceObject->DeviceExtension;
        pdoExtension->DevicePowerState = irpStack->Parameters.Power.State.DeviceState;

        if (numberOfChildrenPowerUp > fdoExtension->NumberOfChildren) {

            //
            // should never happen. If it did, pretend it didn't
            //
            ASSERT (FALSE);
            fdoExtension->NumberOfChildrenPowerUp = fdoExtension->NumberOfChildren;
        }

        //
        // we are powering up
        //
        PoSetPowerState (
            pdoExtension->DeviceObject,
            pdoExtension->DevicePowerState,
            irpStack->Parameters.Power.State
            );

    }

    childPowerIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp (childPowerIrp);
    IoCompleteRequest(childPowerIrp, IO_NO_INCREMENT);

    return IoStatus->Status;
} // FdoChildRequestPowerUpCompletionRoutine
                        
                        
NTSTATUS
FdoSystemPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
	PIRP irp = Context; 

	//
	// start the next system power irp
	//
    PoStartNextPowerIrp (irp);

	if (!NT_SUCCESS(IoStatus->Status)) {
		irp->IoStatus.Status = IoStatus->Status;
	}
	IoCompleteRequest(irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\pciidex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pciidex.h
//
//--------------------------------------------------------------------------

#if !defined (___pciide_h___)
#define ___pciide_h___

#define _NTSRV_
//#define _NTDDK_

#include "stdarg.h"
#include "stdio.h"

#include "ntosp.h"
//#include "pci.h"
#include "wdmguid.h"
#include "zwapi.h"

//#include "ntddk.h"
//#include "ntimage.h"
//#include "ntexapi.h"
//#include "ntrtl.h"

#include "scsi.h"
#include <initguid.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <string.h>
#include "wdmguid.h"
#include "pciintrf.h"

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'XedI')
#endif

#define FULL_RESOURCE_LIST_SIZE(n) (sizeof (CM_FULL_RESOURCE_DESCRIPTOR) + (sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (n - 1)))

#if DBG

#ifdef DebugPrint
#undef DebugPrint
#endif // DebugPrint

#define DebugPrint(x)   PciIdeDebugPrint x

VOID
PciIdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#else

#define DebugPrint(x)

#endif // DBG


//#define MAX_IDE_CHANNEL     2
//#define MAX_IDE_DEVICE      2

#define DRIVER_OBJECT_EXTENSION_ID DriverEntry


#include "idep.h"
#include "ctlrfdo.h"
#include "chanpdo.h"
#include "bm.h"
#include "sync.h"
#include "power.h"
#include "msg.h"

extern PDRIVER_DISPATCH FdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];

extern PDRIVER_DISPATCH FdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];

extern PDRIVER_DISPATCH FdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];

//
// Controller Op Mode
//
#define PCIIDE_CHAN1_DUAL_MODE_CAPABLE      (1 << 3)
#define PCIIDE_CHAN1_IS_NATIVE_MODE         (1 << 2)
#define PCIIDE_CHAN0_DUAL_MODE_CAPABLE      (1 << 1)
#define PCIIDE_CHAN0_IS_NATIVE_MODE         (1 << 0)


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
PciIdeXInitialize(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath,
    IN PCONTROLLER_PROPERTIES   PciIdeGetControllerProperties,
    IN ULONG                    ExtensionSize
    );

NTSTATUS
PciIdeXAlwaysStatusSuccessIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
StatusSuccessAndPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
CompleteIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
NoSupportIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
AtapiHexToString (
    IN ULONG Value,
    IN OUT PCHAR *Buffer
    );

NTSTATUS
PciIdeXGetBusData(
    IN PVOID FdoExtension,
    IN PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

NTSTATUS
PciIdeXSetBusData(
    IN PVOID FdoExtension,
    IN PVOID Buffer,
    IN PVOID DataMask,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

NTSTATUS
PciIdeBusData(
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN OUT PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength,
    IN BOOLEAN ReadConfigData
    );

NTSTATUS
PciIdeBusDataCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
PciIdeInternalDeviceIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeXRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
);

NTSTATUS
PciIdeXGetDeviceParameterEx (
    IN     PDEVICE_OBJECT      DeviceObject,
    IN     PWSTR               ParameterName,
    IN OUT PVOID               *ParameterValue
    );

NTSTATUS
PciIdeXGetDeviceParameter (
    IN     PDEVICE_OBJECT      DeviceObject,
    IN     PWSTR               ParameterName,
    IN OUT PULONG              ParameterValue
    );

VOID
PciIdeUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PciIdeXSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
PciIdeXSyncSendIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#endif // ___pciide_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\inc\idedump.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    idedump.h

Abstract:

    Dump data structures used by IDE/ATA when generating IDE-specific dump
    information. These data structures are shared by ATAPI and the ATAPI
    debugger extension used to debug dump failures.

    NOTE: The structure is an on-disk structure, so it must be the same
    for x86 and all other architectures.

Author:

    Matthew D Hendel (math) 15-April-2002

Revision History:

--*/

// {CA01AC1C-9D65-42c9-8DAF-CF24EF8885C8}
DEFINE_GUID(ATAPI_DUMP_ID, 0xca01ac1c, 0x9d65, 0x42c9, 0x8d, 0xaf, 0xcf, 0x24, 0xef, 0x88, 0x85, 0xc8);

#ifndef _IDEDUMP_H_
#define _IDEDUMP_H_

#include <ntdddisk.h>

typedef ULONG ATAPI_DUMP_BMSTATUS;
#define ATAPI_DUMP_BMSTATUS_NO_ERROR                    (0)
#define ATAPI_DUMP_BMSTATUS_NOT_REACH_END_OF_TRANSFER   (1 << 0)
#define ATAPI_DUMP_BMSTATUS_ERROR_TRANSFER              (1 << 1)
#define ATAPI_DUMP_BMSTATUS_INTERRUPT                   (1 << 2)
#define ATAPI_DUMP_BMSTATUS_SUCCESS(x)\
            ((x & ~ATAPI_DUMP_BMSTATUS_INTERRUPT) == 0)

//
// Dead Meat Reasons
//

enum {
    DeadMeatEnumFailed = 1,
    DeadMeatReportedMissing,
    DeadMeatTooManyTimeout,
    DeadMeatByKilledPdo,
    DeadMeatReplacedByUser
};
    

#include <pshpack8.h>
typedef struct _ATAPI_DUMP_COMMAND_LOG {
    UCHAR Cdb[16];
    IDEREGS InitialTaskFile;
    IDEREGS FinalTaskFile;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    ATAPI_DUMP_BMSTATUS BmStatus;
    UCHAR SenseData[3];
    UCHAR SrbStatus;
} ATAPI_DUMP_COMMAND_LOG, *PATAPI_DUMP_COMMAND_LOG;
#include <poppack.h>

#define ATAPI_DUMP_COMMAND_LOG_COUNT    (40)

#define ATAPI_DUMP_RECORD_VERSION   (0x01)

#include <pshpack1.h>
typedef struct _ATAPI_DUMP_PDO_INFO {
    UCHAR Version : 7;
    UCHAR WriteCacheEnable : 1;
    UCHAR TargetId;
    UCHAR DriveRegisterStatus;
    UCHAR BusyStatus;
    UCHAR FullVendorProductId[41];
    UCHAR FullProductRevisionId[8 + 1];
    UCHAR FullSerialNumber[20 * 2 + 1];
    ULONG Reason;
    ULONG TransferModeSelected;
    ULONG ConsecutiveTimeoutCount;
    ULONG DmaTransferTimeoutCount;
    ULONG FlushCacheTimeoutCount;
    ULONG IdeCommandLogIndex; 
    ATAPI_DUMP_COMMAND_LOG CommandLog[ATAPI_DUMP_COMMAND_LOG_COUNT]; 
} ATAPI_DUMP_PDO_INFO, *PATAPI_DUMP_PDO_INFO;
#include <poppack.h>

#endif // _IDEDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\sync.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sync.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciIdeCreateSyncChildAccess)
#pragma alloc_text(PAGE, PciIdeDeleteSyncChildAccess)
#pragma alloc_text(PAGE, PciIdeQuerySyncAccessInterface)
#pragma alloc_text(PAGE, PciIdeSyncAccessRequired)

#pragma alloc_text(NONPAGE, PciIdeAllocateAccessToken)
#pragma alloc_text(NONPAGE, PciIdeFreeAccessToken)
#endif // ALLOC_PRAGMA


//
// Must match mshdc.inf
//                   
static PWCHAR SyncAccess = L"SyncAccess";

NTSTATUS
PciIdeCreateSyncChildAccess (
    PCTRLFDO_EXTENSION FdoExtension
)
{
    BOOLEAN syncAccessNeeded;

    PAGED_CODE();

    syncAccessNeeded = FALSE;

    if (FdoExtension->TranslatedBusMasterBaseAddress) {

        UCHAR    bmRawStatus;
    
        bmRawStatus = READ_PORT_UCHAR (&FdoExtension->TranslatedBusMasterBaseAddress->Status);

        if (bmRawStatus & BUSMASTER_DMA_SIMPLEX_BIT) {

            syncAccessNeeded = TRUE;
        }
    }

    if (syncAccessNeeded == FALSE) {

        syncAccessNeeded = PciIdeSyncAccessRequired (
                               FdoExtension
                               );
    }

    if (syncAccessNeeded) {

        DebugPrint ((1, "PCIIDEX: Serialize access to both channels\n"));

        FdoExtension->ControllerObject = IoCreateController (0);
    
        ASSERT (FdoExtension->ControllerObject);

        if (FdoExtension->ControllerObject) {
    
            return STATUS_SUCCESS;
        } else {
    
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return STATUS_SUCCESS;
} // PciIdeCreateSyncChildAccess

VOID
PciIdeDeleteSyncChildAccess (
    PCTRLFDO_EXTENSION FdoExtension
)
{
    PAGED_CODE();

    if (FdoExtension->ControllerObject) {

        IoDeleteController (FdoExtension->ControllerObject);

        FdoExtension->ControllerObject = NULL;
    }
    return;
} // PciIdeDeleteSyncChildAccess

NTSTATUS
PciIdeQuerySyncAccessInterface (
    PCHANPDO_EXTENSION             PdoExtension,
    PPCIIDE_SYNC_ACCESS_INTERFACE  SyncAccessInterface
)
{
    PAGED_CODE();

    if (SyncAccessInterface == NULL) {

        return STATUS_INVALID_PARAMETER;
    }


    if (!PdoExtension->ParentDeviceExtension->ControllerObject) {

        SyncAccessInterface->AllocateAccessToken = NULL;
        SyncAccessInterface->FreeAccessToken     = NULL;
        SyncAccessInterface->Token               = NULL;
        
    } else {

        SyncAccessInterface->AllocateAccessToken = PciIdeAllocateAccessToken;
        SyncAccessInterface->FreeAccessToken     = PciIdeFreeAccessToken;
        SyncAccessInterface->Token               = PdoExtension;
    }

    return STATUS_SUCCESS;
} // PciIdeQuerySyncAccessInterface


static ULONG tokenAccessCount=0;

//
// IRQL must be DISPATCH_LEVEL;
//
NTSTATUS
PciIdeAllocateAccessToken (
    PVOID              Token,
    PDRIVER_CONTROL    Callback,
    PVOID              CallbackContext
)
{
    PCHANPDO_EXTENSION pdoExtension = Token;
    PCTRLFDO_EXTENSION FdoExtension;

    ASSERT (Token);
    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    FdoExtension = pdoExtension->ParentDeviceExtension;

    tokenAccessCount++;

    IoAllocateController (
        FdoExtension->ControllerObject,
        FdoExtension->DeviceObject,
        Callback,
        CallbackContext
        );

    return STATUS_SUCCESS;
} // PciIdeAllocateAccessToken

NTSTATUS
PciIdeFreeAccessToken (
    PVOID              Token
)
{
    PCHANPDO_EXTENSION pdoExtension = Token;
    PCTRLFDO_EXTENSION FdoExtension;
    
    FdoExtension = pdoExtension->ParentDeviceExtension;

    tokenAccessCount--;

    IoFreeController (
        FdoExtension->ControllerObject
        );

    return STATUS_SUCCESS;
} // PciIdeFreeAccessToken


BOOLEAN
PciIdeSyncAccessRequired (
    IN PCTRLFDO_EXTENSION FdoExtension
)
{
    NTSTATUS status;
    ULONG syncAccess;

    PAGED_CODE();

    syncAccess = 0;
    status = PciIdeXGetDeviceParameter (
               FdoExtension->AttacheePdo,
               SyncAccess,
               &syncAccess
               );
    if (NT_SUCCESS(status)) {

        return (syncAccess != 0);

    } else {

        DebugPrint ((1, "PciIdeX: Unable to get SyncAccess flag from the registry\n"));
    }

    if (FdoExtension->ControllerProperties.PciIdeSyncAccessRequired) {

        return FdoExtension->ControllerProperties.PciIdeSyncAccessRequired (
                   FdoExtension->VendorSpecificDeviceEntension
                   );
    }

    DebugPrint ((1, "PciIdeX: assume sync access not required\n"));
    return FALSE;
} // PciIdeSyncAccessRequired
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\share\util.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       util.c
//
//--------------------------------------------------------------------------

#include "ide.h"

#pragma alloc_text(NONPAGE, IdePortChannelEmpty)
#pragma alloc_text(PAGE, DigestResourceList)
#pragma alloc_text(PAGE, AtapiBuildIoAddress)
#pragma alloc_text(PAGE, IdeGetDeviceCapabilities)

#pragma alloc_text(NONPAGE, IdePortpWaitOnBusyEx)

#pragma alloc_text(PAGE, IdeCreateIdeDirectory)

#ifdef  DPC_FOR_EMPTY_CHANNEL
BOOLEAN
IdePortIdentifyDevice(
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice
    )
{
    UCHAR statusByte1;
    ULONG retryCount=4;
    BOOLEAN emptyChannel=TRUE;
    ULONG deviceNumber=0;
    ULONG i;
    
    retryCount = 4;
    emptyChannel = TRUE;
    deviceNumber = 0;

retryIdentifier:

    //
    // Select the master device
    //
    SelectIdeDevice(CmdRegBase, deviceNumber, 0);

    //
    // write out indentifier to readable and writable io registers
    //
    WRITE_PORT_UCHAR (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
    WRITE_PORT_UCHAR (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

    //
    // Check if indentifier can be read back.
    //
    if ((READ_PORT_UCHAR (CmdRegBase->CylinderHigh) != SAMPLE_CYLINDER_HIGH_VALUE) ||
        (READ_PORT_UCHAR (CmdRegBase->CylinderLow)  != SAMPLE_CYLINDER_LOW_VALUE)) {

        statusByte1 = READ_PORT_UCHAR (CmdRegBase->Command);

        DebugPrint((2,
                    "IdePortChannelEmpty: status read back from Master (%x)\n",
                    statusByte1));

        if (statusByte1 & IDE_STATUS_BUSY) {

            i = 0;

            //
            // Could be the TEAC in a thinkpad. Their dos driver puts it in a sleep-mode that
            // warm boots don't clear.
            //

            do {
                KeStallExecutionProcessor(1000);
                statusByte1 = READ_PORT_UCHAR(CmdRegBase->Command);
                DebugPrint((3,
                            "IdePortChannelEmpty: First access to status %x\n",
                            statusByte1));
            } while ((statusByte1 & IDE_STATUS_BUSY) && ++i < 10);

            if (retryCount-- && (!(statusByte1 & IDE_STATUS_BUSY))) {
                goto retryIdentifier;
            }
        }

        //
        // Select slave.
        //
        deviceNumber++;

        SelectIdeDevice(CmdRegBase, deviceNumber, 0);

        //
        // write out indentifier to readable and writable io registers
        //
        WRITE_PORT_UCHAR (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
        WRITE_PORT_UCHAR (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

        //
        // Check if indentifier can be read back.
        //
        if ((READ_PORT_UCHAR (CmdRegBase->CylinderHigh) != SAMPLE_CYLINDER_HIGH_VALUE) ||
            (READ_PORT_UCHAR (CmdRegBase->CylinderLow)  != SAMPLE_CYLINDER_LOW_VALUE)) {

            statusByte1 = READ_PORT_UCHAR (CmdRegBase->Command);

            DebugPrint((2,
                        "IdePortChannelEmpty: status read back from Slave (%x)\n",
                        statusByte1));

        } else {

            emptyChannel = FALSE;
        }

    } else {

        emptyChannel = FALSE;
    }

    deviceNumber++;

    if ( (deviceNumber < MaxIdeDevice) && emptyChannel ) {
        goto retryIdentifier;
    }

    return emptyChannel;

} //IdePortIdentifyDevice

ULONG
IdePortChannelEmptyQuick (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice,
    IN PULONG           CurrentDevice,
    IN PULONG           moreWait,
    IN PULONG           NoRetry
)
{
    //
    // try EXECUTE_DIAGNOSTICS. No.
    //

    //
    // statusByte1 needs to be initialized to ff
    //
    UCHAR statusByte1=0xff;

    UCHAR statusByte2;
    ULONG i;
    BOOLEAN allStatusBytesAllFs;

    allStatusBytesAllFs = TRUE;

    DebugPrint((1, "ChannelEmptyQuick: wait=%d, Device=%d\n",
                    *moreWait, *CurrentDevice));
    if (*moreWait) {

        (*moreWait)--;

        SelectIdeDevice(CmdRegBase, (*CurrentDevice), 0);

        IdePortWaitOnBusyExK (CmdRegBase, statusByte1, 0xff);

        DebugPrint((1, "ATAPI: Status after first retry=%x\n", statusByte1));

        if (statusByte1==0xff) {
            (*CurrentDevice)++;
            *moreWait=0;
        }
    }

    if (*moreWait && (statusByte1 & IDE_STATUS_BUSY)) {
        
        return STATUS_RETRY;
    }

    if (!(*NoRetry) && (statusByte1 & IDE_STATUS_BUSY) && 
        ((statusByte1 != 0xfe) &&
         (statusByte1 != 0xff))) {

        DebugPrint((1,
                    "ATAPI: IdePortChannelEmpty: channel looks busy 0x%x.  try a reset\n",
                    statusByte1));

        //
        // channel look hung or busy
        //
        // try a hard reset to bring it to idle
        WRITE_PORT_UCHAR (CtrlRegBase->DeviceControl, IDE_DC_RESET_CONTROLLER);

        //
        // ATA-2 spec requires a minimum of 5 microsec stall here
        //
        KeStallExecutionProcessor (10);

        WRITE_PORT_UCHAR (CtrlRegBase->DeviceControl, IDE_DC_REENABLE_CONTROLLER);

        i=*CurrentDevice;
        SelectIdeDevice(CmdRegBase, i, 0);
        IdePortWaitOnBusyExK (CmdRegBase, statusByte1, 0xff);
        if ((statusByte1 & IDE_STATUS_BUSY) && (statusByte1 != 0xff)) {
            *moreWait=2; //wait for 2 more timer ticks
            *NoRetry=1;
            return STATUS_RETRY;
        }
    }

    if (statusByte1 != 0xFF) {
        allStatusBytesAllFs = FALSE;
        (*CurrentDevice)++;
    }

    for (i=*CurrentDevice; i<MaxIdeDevice && allStatusBytesAllFs; i++) {

        //
        // make sure device is not busy
        //

        //
        // Select the master device
        //
        SelectIdeDevice(CmdRegBase, i, 0);

        if (Is98LegacyIde(CmdRegBase)) {
            if (READ_PORT_UCHAR(CmdRegBase->DriveSelect) != (((i & 0x1) << 4) | 0xA0)) {
                //
                // Bad controller.
                //
                continue;
            }
        }

        GetStatus(CmdRegBase, statusByte1);
        DebugPrint((1, "ATAPI:status for device %d after GetStatus=%x\n",i, statusByte1));

        if (statusByte1 == 0xff) {
            continue;
        }

        if (statusByte1 == 0xfe) {
            continue;
        }

        IdePortWaitOnBusyExK (CmdRegBase, statusByte1, 0xff);

        if ((statusByte1 & 0xfe) == 0xfe) {
            continue;
        }

        if (statusByte1 & IDE_STATUS_BUSY) {
            DebugPrint((1, "ATAPI: Re-init the counts:device=%d, status=%x",
                                i, statusByte1));
            *CurrentDevice=i;
            *moreWait=2;
            *NoRetry=0;
            return STATUS_RETRY;
        }

        if (statusByte1 != 0xFF) {
            allStatusBytesAllFs = FALSE;
        }
    }

    if (allStatusBytesAllFs) {

        //
        // all status bytes are 0xff,
        // no controller at this location
        //
        return 1;
    }

    i=(IdePortIdentifyDevice(CmdRegBase, CtrlRegBase, MaxIdeDevice)) ? 1: 0;
    return i;

}//IdePortChannelEmptyQuick


#endif

BOOLEAN
IdePortChannelEmpty (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice
)
/*++

Routine Description:

    quickly check whether a IDE channel exist at the given io location

Arguments:

    CmdRegBase - command registers

    CtrlRegBase - control registers

    MaxIdeDevice - number of max devices

Return Value:

    TRUE - Yes, the channel is empty
    FALSE - No, the channel is not empty

--*/
{

    UCHAR statusByte1;
    UCHAR statusByte2;
    ULONG retryCount;
    ULONG i;
    BOOLEAN emptyChannel;
    ULONG deviceNumber;
    BOOLEAN allStatusBytesAllFs;

    allStatusBytesAllFs = TRUE;
    for (i=0; i<MaxIdeDevice; i++) {

        //
        // make sure device is not busy
        //

        //
        // Select the master device
        //
        SelectIdeDevice(CmdRegBase, i, 0);

        if (Is98LegacyIde(CmdRegBase)) {
            if (READ_PORT_UCHAR(CmdRegBase->DriveSelect) != (((i & 0x1) << 4) | 0xA0)) {
                //
                // Bad controller.
                //
                continue;
            }
        }

        GetStatus(CmdRegBase, statusByte1);

        if (statusByte1 == 0xff) {
            continue;
        }

        if (statusByte1 == 0xfe) {
            continue;
        }

        IdePortWaitOnBusyEx (CmdRegBase, &statusByte1, 0xff);

        if ((statusByte1 & IDE_STATUS_BUSY) &&
            ((statusByte1 != 0xfe) &&
             (statusByte1 != 0xff))) {

            DebugPrint((1,
                        "IdePortChannelEmpty: channel looks busy 0x%x.  try a reset\n",
                        statusByte1));


            //
            // channel look hung or busy
            //
            // try a hard reset to bring it to idle
            WRITE_PORT_UCHAR (CtrlRegBase->DeviceControl, IDE_DC_RESET_CONTROLLER);
            
            //
            // ATA-2 spec requires a minimum of 5 microsec stall here
            //
            KeStallExecutionProcessor (10);
    
            WRITE_PORT_UCHAR (CtrlRegBase->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
    
            SelectIdeDevice(CmdRegBase, i, 0);
            IdePortWaitOnBusyEx (CmdRegBase, &statusByte1, 0xff);
        }

        if (statusByte1 != 0xFF) {
            allStatusBytesAllFs = FALSE;
        }
    }

    if (allStatusBytesAllFs) {

        //
        // all status bytes are 0xff,
        // no controller at this location
        //
        return TRUE;
    }

#ifdef DPC_FOR_EMPTY_CHANNEL
    return IdePortIdentifyDevice(CmdRegBase, CtrlRegBase, MaxIdeDevice);
#endif
    retryCount = 4;
    emptyChannel = TRUE;
    deviceNumber = 0;

retryIdentifier:

    //
    // Select the master device
    //
    SelectIdeDevice(CmdRegBase, deviceNumber, 0);

    //
    // write out indentifier to readable and writable io registers
    //
    WRITE_PORT_UCHAR (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
    WRITE_PORT_UCHAR (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

    //
    // Check if indentifier can be read back.
    //
    if ((READ_PORT_UCHAR (CmdRegBase->CylinderHigh) != SAMPLE_CYLINDER_HIGH_VALUE) ||
        (READ_PORT_UCHAR (CmdRegBase->CylinderLow)  != SAMPLE_CYLINDER_LOW_VALUE)) {

        statusByte1 = READ_PORT_UCHAR (CmdRegBase->Command);

        DebugPrint((2,
                    "IdePortChannelEmpty: status read back from Master (%x)\n",
                    statusByte1));

        if (statusByte1 & IDE_STATUS_BUSY) {

            i = 0;

            //
            // Could be the TEAC in a thinkpad. Their dos driver puts it in a sleep-mode that
            // warm boots don't clear.
            //

            do {
                KeStallExecutionProcessor(1000);
                statusByte1 = READ_PORT_UCHAR(CmdRegBase->Command);
                DebugPrint((3,
                            "IdePortChannelEmpty: First access to status %x\n",
                            statusByte1));
            } while ((statusByte1 & IDE_STATUS_BUSY) && ++i < 10);

            if (retryCount-- && (!(statusByte1 & IDE_STATUS_BUSY))) {
                goto retryIdentifier;
            }
        }

        //
        // Select slave.
        //
        deviceNumber++;

        SelectIdeDevice(CmdRegBase, deviceNumber, 0);

        //
        // write out indentifier to readable and writable io registers
        //
        WRITE_PORT_UCHAR (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
        WRITE_PORT_UCHAR (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

        //
        // Check if indentifier can be read back.
        //
        if ((READ_PORT_UCHAR (CmdRegBase->CylinderHigh) != SAMPLE_CYLINDER_HIGH_VALUE) ||
            (READ_PORT_UCHAR (CmdRegBase->CylinderLow)  != SAMPLE_CYLINDER_LOW_VALUE)) {

            statusByte1 = READ_PORT_UCHAR (CmdRegBase->Command);

            DebugPrint((2,
                        "IdePortChannelEmpty: status read back from Slave (%x)\n",
                        statusByte1));

        } else {

            emptyChannel = FALSE;
        }

    } else {

        emptyChannel = FALSE;
    }

    deviceNumber++;

    if ( (deviceNumber < MaxIdeDevice) && emptyChannel ) {
        goto retryIdentifier;
    }

    return emptyChannel;

} //IdePortChannelEmpty

NTSTATUS
DigestResourceList (
    IN OUT PIDE_RESOURCE                IdeResource,
    IN  PCM_RESOURCE_LIST               ResourceList,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *IrqPartialDescriptors
    )
{
    NTSTATUS                        status;

    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    ULONG                           resourceListSize;
    ULONG                           i;
    ULONG                           j;

    BOOLEAN                         foundCommandBase;
    BOOLEAN                         foundControlBase;
    BOOLEAN                         foundIrqLevel;
    BOOLEAN                         resourceIsCommandPort;

    BOOLEAN                         AtdiskPrimaryClaimed;
    BOOLEAN                         AtdiskSecondaryClaimed;

    PHYSICAL_ADDRESS                tranlatedAddress;

    IDE_REGISTERS_1                 baseIoAddress1;
    ULONG                           baseIoAddress1Length;


    fullResourceList = ResourceList->List;
    resourceListSize = 0;

    DebugPrint ((5, "IdePort: DigestResourceList()\n"));

    foundCommandBase       = FALSE;
    foundControlBase       = FALSE;
    foundIrqLevel          = FALSE;
    *IrqPartialDescriptors = NULL;
    status                 = STATUS_SUCCESS;

    AtdiskPrimaryClaimed    = FALSE;
    AtdiskSecondaryClaimed  = FALSE;

    for (i = 0;
         (i < ResourceList->Count) && NT_SUCCESS(status);
         i++) {

        partialResourceList = &(fullResourceList->PartialResourceList);
        partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

        AtapiBuildIoAddress ((PUCHAR)partialDescriptors[0].u.Port.Start.QuadPart,
                             0,
                             &baseIoAddress1,
                             NULL,
                             &baseIoAddress1Length,
                             NULL,
                             NULL,
                             NULL);

        for (j = 0;
             (j < partialResourceList->Count) && NT_SUCCESS(status);
             j++) {

            resourceIsCommandPort = FALSE;

            if (!Is98LegacyIde(&baseIoAddress1)) {

                if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                    (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                    (partialDescriptors[j].u.Port.Length == baseIoAddress1Length)) {

                    resourceIsCommandPort = TRUE;

                }
            } else {

                if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                    (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                    (partialDescriptors[j].u.Port.Start.QuadPart == IDE_NEC98_COMMAND_PORT_ADDRESS)){

                    resourceIsCommandPort = TRUE;

                } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                            (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                           (partialDescriptors[j].u.Port.Start.QuadPart != IDE_NEC98_COMMAND_PORT_ADDRESS) &&
                           (partialDescriptors[j].u.Port.Start.QuadPart != (IDE_NEC98_COMMAND_PORT_ADDRESS + 0x10C))) {

                    //
                    // This is not the base port address for Legacy ide on NEC98;
                    //

                    continue;
                }
            }

            if (resourceIsCommandPort) {

                if (foundCommandBase) {

                    //
                    // got this before, just ignore it
                    //
                    // status = STATUS_INVALID_PARAMETER;

                } else {

                    if (!Is98LegacyIde(&baseIoAddress1)) {

                        if (partialDescriptors[j].u.Port.Start.QuadPart == IDE_STANDARD_PRIMARY_ADDRESS) {

                            AtdiskPrimaryClaimed = TRUE;

                        } else if (partialDescriptors[j].u.Port.Start.QuadPart == IDE_STANDARD_SECONDARY_ADDRESS) {

                            AtdiskSecondaryClaimed = TRUE;
                        }

                    } else {

                        AtdiskPrimaryClaimed = TRUE;
                        AtdiskSecondaryClaimed = TRUE;
                    }

                    if (partialDescriptors[j].Type == CmResourceTypePort) {

                        IdeResource->TranslatedCommandBaseAddress =
                            (PUCHAR)(ULONG_PTR)partialDescriptors[j].u.Port.Start.QuadPart;

                        IdeResource->CommandBaseAddressSpace = IO_SPACE;

                    } else if (partialDescriptors[j].Type == CmResourceTypeMemory) {

                        IdeResource->TranslatedCommandBaseAddress = MmMapIoSpace(
                                                                        partialDescriptors[j].u.Port.Start,
                                                                        baseIoAddress1Length,
                                                                        FALSE);

                        IdeResource->CommandBaseAddressSpace = MEMORY_SPACE;

                    } else {

                        IdeResource->TranslatedCommandBaseAddress = FALSE;
                        ASSERT (FALSE);
                    }

                    if (IdeResource->TranslatedCommandBaseAddress) {

                        foundCommandBase = TRUE;

                    } else {

                        status = STATUS_INVALID_PARAMETER;
                    }
                }

            } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                        (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                        ((partialDescriptors[j].u.Port.Length == 1) ||
                        (partialDescriptors[j].u.Port.Length == 2) ||
                        (partialDescriptors[j].u.Port.Length == 4))) {

                if (foundControlBase) {

                    //
                    // got this before, just ignore it
                    //
                    // status = STATUS_INVALID_PARAMETER;

                } else {

                    PHYSICAL_ADDRESS p;
                    //
                    // Probably the control block register
                    //

                    p = partialDescriptors[j].u.Port.Start;

                    if (partialDescriptors[j].u.Port.Length == 4) {

                        //
                        // this will happen only in native mode since 
                        // the range length is 1 for legacy systems
                        //
                        p.QuadPart += 2;
                    }

                    if (partialDescriptors[j].Type == CmResourceTypePort) {

                        IdeResource->TranslatedControlBaseAddress =
                            (PUCHAR)(ULONG_PTR)p.QuadPart;

                        IdeResource->ControlBaseAddressSpace = IO_SPACE;

                    } else if (partialDescriptors[j].Type == CmResourceTypeMemory) {

                        IdeResource->TranslatedControlBaseAddress = MmMapIoSpace(
                                                                         p,
                                                                         1,
                                                                         FALSE);

                        IdeResource->ControlBaseAddressSpace = MEMORY_SPACE;

                    } else {

                        IdeResource->TranslatedControlBaseAddress = FALSE;
                        ASSERT (FALSE);
                    }

                    if (IdeResource->TranslatedControlBaseAddress) {

                        foundControlBase = TRUE;

                    } else {

                        status = STATUS_INVALID_PARAMETER;
                    }
                }

            } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {

                if (foundIrqLevel) {

                    //
                    // got this before, just ignore it
                    //
                    // status = STATUS_INVALID_PARAMETER;

                } else {

                    //
                    // Probably the device IRQ
                    //

                    //
                    // May want to disable device interrupt here
                    //

                    //
                    // Save interrupt level.
                    //

                    IdeResource->InterruptLevel = partialDescriptors[j].u.Interrupt.Level;
                    IdeResource->InterruptMode  = partialDescriptors[j].Flags & CM_RESOURCE_INTERRUPT_LATCHED ?
                                                       Latched :
                                                       LevelSensitive;

                    *IrqPartialDescriptors       = partialDescriptors + j;

                    foundIrqLevel = TRUE;
                }

            } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                        (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                        ((partialDescriptors[j].u.Port.Length >= 16) &&
                         (partialDescriptors[j].u.Port.Length <= 32)) ) {

                if (foundControlBase || foundCommandBase) {

                    //
                    // got this before, just ignore it
                    //
                    // status = STATUS_INVALID_PARAMETER;

                } else {

                    PHYSICAL_ADDRESS ctrlAddr;

                    //
                    // Probably a pcmcia device that has its command and control
                    // registers lumped into one I/O range
                    //
                    // We are guessing the control block register is the second
                    // from the last i/o space.  Some standard!
                    //

                    ctrlAddr.QuadPart = partialDescriptors[j].u.Port.Start.QuadPart +
                                        partialDescriptors[j].u.Port.Length - 2;

                    if (partialDescriptors[j].Type == CmResourceTypePort) {

                        IdeResource->TranslatedCommandBaseAddress =
                            (PUCHAR)(ULONG_PTR)partialDescriptors[j].u.Port.Start.QuadPart;

                        IdeResource->CommandBaseAddressSpace = IO_SPACE;

                        IdeResource->TranslatedControlBaseAddress =
                            (PUCHAR)(ULONG_PTR)ctrlAddr.QuadPart;

                        IdeResource->ControlBaseAddressSpace = IO_SPACE;

                    } else if (partialDescriptors[j].Type == CmResourceTypeMemory) {

                        IdeResource->TranslatedCommandBaseAddress = MmMapIoSpace(
                                                                         partialDescriptors[j].u.Port.Start,
                                                                         baseIoAddress1Length,
                                                                         FALSE);

                        IdeResource->CommandBaseAddressSpace = MEMORY_SPACE;

                        IdeResource->TranslatedControlBaseAddress = MmMapIoSpace(
                                                                         ctrlAddr,
                                                                         1,
                                                                         FALSE);

                        IdeResource->ControlBaseAddressSpace = MEMORY_SPACE;

                    } else {

                        IdeResource->TranslatedCommandBaseAddress = FALSE;
                        IdeResource->TranslatedControlBaseAddress = FALSE;
                        ASSERT (FALSE);
                    }

                    if (IdeResource->TranslatedCommandBaseAddress) {

                        foundCommandBase = TRUE;

                    } else {

                        status = STATUS_INVALID_PARAMETER;
                    }

                    if (IdeResource->TranslatedControlBaseAddress) {

                        foundControlBase = TRUE;

                    } else {

                        status = STATUS_INVALID_PARAMETER;
                    }
                }
            }
        }
        fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
    }

    if (foundCommandBase && foundControlBase && NT_SUCCESS(status)) {

        IdeResource->AtdiskPrimaryClaimed   = AtdiskPrimaryClaimed;
        IdeResource->AtdiskSecondaryClaimed = AtdiskSecondaryClaimed;

        return STATUS_SUCCESS;

    } else {

        DebugPrint((0, "IdePort: pnp manager gave me bad ressources!\n"));

        if (foundCommandBase &&
            (IdeResource->CommandBaseAddressSpace == MEMORY_SPACE)) {

            MmUnmapIoSpace (
                IdeResource->TranslatedCommandBaseAddress,
                baseIoAddress1Length
                );

            IdeResource->TranslatedCommandBaseAddress = 0;
        }

        if (foundControlBase &&
            (IdeResource->ControlBaseAddressSpace == MEMORY_SPACE)) {

            MmUnmapIoSpace (
                IdeResource->TranslatedControlBaseAddress,
                1
                );

            IdeResource->TranslatedControlBaseAddress = 0;
        }

        return STATUS_INVALID_PARAMETER;
    }
} // DigestResourceList

VOID
AtapiBuildIoAddress (
    IN  PUCHAR            CmdBaseAddress,
    IN  PUCHAR            CtrlBaseAddress,
    OUT PIDE_REGISTERS_1  BaseIoAddress1,
    OUT PIDE_REGISTERS_2  BaseIoAddress2,
    OUT PULONG            BaseIoAddress1Length,
    OUT PULONG            BaseIoAddress2Length,
    OUT PULONG            MaxIdeDevice,
    OUT PULONG            MaxIdeTargetId
)
{
    PUCHAR      baseIoAddress;
    BOOLEAN     LegacyIdeOfNec98;

    LegacyIdeOfNec98 = FALSE;

    if (IsNEC_98) {
        if (CmdBaseAddress == (PUCHAR)IDE_NEC98_COMMAND_PORT_ADDRESS) {
            LegacyIdeOfNec98 = TRUE;
        }
    }

    if (!LegacyIdeOfNec98) {

        //
        // Build command registers.
        //

        baseIoAddress       = CmdBaseAddress;

        if (BaseIoAddress1) {
            BaseIoAddress1->RegistersBaseAddress = baseIoAddress;

            BaseIoAddress1->Data         = (PUSHORT)baseIoAddress;
            BaseIoAddress1->Error        = baseIoAddress + 1;
            BaseIoAddress1->BlockCount   = baseIoAddress + 2;
            BaseIoAddress1->BlockNumber  = baseIoAddress + 3;
            BaseIoAddress1->CylinderLow  = baseIoAddress + 4;
            BaseIoAddress1->CylinderHigh = baseIoAddress + 5;
            BaseIoAddress1->DriveSelect  = baseIoAddress + 6;
            BaseIoAddress1->Command      = baseIoAddress + 7;

        }

        //
        // Build control registers.
        //

        baseIoAddress = CtrlBaseAddress;

        if (BaseIoAddress2) {

            BaseIoAddress2->RegistersBaseAddress     = baseIoAddress;

            BaseIoAddress2->DeviceControl            = baseIoAddress;
            BaseIoAddress2->DriveAddress             = baseIoAddress + 1;
        }

        if (BaseIoAddress1Length) {
            *BaseIoAddress1Length                    = 8;
        }

        if (BaseIoAddress2Length) {
            *BaseIoAddress2Length                    = 1;
        }

        if (MaxIdeDevice) {
            *MaxIdeDevice                           = MAX_IDE_DEVICE;
        }

        if (MaxIdeTargetId) {
            *MaxIdeTargetId                         = MAX_IDE_DEVICE;
        }

    } else {

        //
        // Build command registers.
        //

        baseIoAddress = CmdBaseAddress;

        if (BaseIoAddress1) {
            BaseIoAddress1->RegistersBaseAddress = baseIoAddress;

            BaseIoAddress1->Data         = (PUSHORT)baseIoAddress;
            BaseIoAddress1->Error        = baseIoAddress + 2;
            BaseIoAddress1->BlockCount   = baseIoAddress + 4;
            BaseIoAddress1->BlockNumber  = baseIoAddress + 6;
            BaseIoAddress1->CylinderLow  = baseIoAddress + 8;
            BaseIoAddress1->CylinderHigh = baseIoAddress + 10;
            BaseIoAddress1->DriveSelect  = baseIoAddress + 12;
            BaseIoAddress1->Command      = baseIoAddress + 14;
        }

        //
        // Build control registers.
        //

        baseIoAddress = CtrlBaseAddress;

        if (BaseIoAddress2) {

            BaseIoAddress2->RegistersBaseAddress     = baseIoAddress;

            BaseIoAddress2->DeviceControl            = baseIoAddress;
            BaseIoAddress2->DriveAddress             = baseIoAddress + 2;
        }

        if (BaseIoAddress1Length) {
            *BaseIoAddress1Length                    = 1;
        }

        if (BaseIoAddress2Length) {
            *BaseIoAddress2Length                    = 1;
        }

        if (MaxIdeDevice) {
            *MaxIdeDevice                           = MAX_IDE_DEVICE * MAX_IDE_LINE;
        }

        if (MaxIdeTargetId) {
            *MaxIdeTargetId                         = MAX_IDE_DEVICE * MAX_IDE_LINE;
        }
    }

    return;

} // AtapiBuildIoAddress

NTSTATUS
IdePortpWaitOnBusyEx (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN OUT PUCHAR       Status,
    IN UCHAR            BadStatus
#if DBG
    ,
    IN PCSTR            FileName,
    IN ULONG            LineNumber
#endif
)
{
    UCHAR status;
    ULONG sec;
    ULONG i;

    for (sec=0; sec<2; sec++) {

        /**/
        /* one second loop */
        /**/

        for (i=0; i<200000; i++) {

            GetStatus(CmdRegBase, status);
            
            if (status == BadStatus) {

                break;

            } else if (status & IDE_STATUS_BUSY) {

                KeStallExecutionProcessor(5);
                continue;

            } else {

                break;
            }
        }

        if (status == BadStatus) {

           break;

        } else if (status & IDE_STATUS_BUSY) {

            DebugPrint ((1, "ATAPI: after 1 sec wait, device is still busy with 0x%x status = 0x%x\n", CmdRegBase->RegistersBaseAddress, (ULONG) (status)));

        } else {

            break;
        }
    }

    *Status = status;

    if ((status & IDE_STATUS_BUSY) && (status != BadStatus)) {

        DebugPrint ((0, "WaitOnBusy failed in %s line %u. 0x%x status = 0x%x\n", FileName, LineNumber, CmdRegBase->RegistersBaseAddress, (ULONG) (status)));

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
} // IdePortpWaitOnBusyEx

static PVOID IdeDirectory = NULL;
VOID
IdeCreateIdeDirectory(
    VOID
    )
{
    UNICODE_STRING unicodeDirectoryName;
    OBJECT_ATTRIBUTES objectAttributes;

    HANDLE directory;

    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString(
        &unicodeDirectoryName,
        DEVICE_OJBECT_BASE_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeDirectoryName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL);

    status = ZwCreateDirectoryObject(&directory,
                                     DIRECTORY_ALL_ACCESS,
                                     &objectAttributes);

    if(NT_SUCCESS(status)) {

        ObReferenceObjectByHandle(directory,
                                  FILE_READ_ATTRIBUTES,
                                  NULL,
                                  KernelMode,
                                  &IdeDirectory,
                                  NULL);
        ZwClose(directory);

    }
    return;
}

NTSTATUS
IdeGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine sends the get capabilities irp to the given stack

Arguments:

    DeviceObject        A device object in the stack whose capabilities we want
    DeviceCapabilites   Where to store the answer

Return Value:

    NTSTATUS

--*/
{
    IO_STATUS_BLOCK     ioStatus;
    KEVENT              pnpEvent;
    NTSTATUS            status;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                pnpIrp;

    PAGED_CODE();

    //
    // Initialize the capabilities that we will send down
    //
    RtlZeroMemory( DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = -1;
    DeviceCapabilities->UINumber = -1;
    //
    // Initialize the event
    //
    KeInitializeEvent( &pnpEvent, SynchronizationEvent, FALSE );

    //
    // Get the irp that we will send the request to
    //
    targetObject = IoGetAttachedDeviceReference( DeviceObject );

    //
    // Build an Irp
    //
    pnpIrp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        targetObject,
        NULL,
        0,
        NULL,
        &pnpEvent,
        &ioStatus
        );
    if (pnpIrp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto IdeGetDeviceCapabilitiesExit;

    }

    //
    // Pnp Irps all begin life as STATUS_NOT_SUPPORTED;
    //
    pnpIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    pnpIrp->IoStatus.Information = 0;

    //
    // Get the top of stack
    //
    irpStack = IoGetNextIrpStackLocation( pnpIrp );
    if (irpStack == NULL) {

        status = STATUS_INVALID_PARAMETER;
        goto IdeGetDeviceCapabilitiesExit;

    }

    //
    // Set the top of stack
    //
    RtlZeroMemory( irpStack, sizeof(IO_STACK_LOCATION ) );
    irpStack->MajorFunction = IRP_MJ_PNP;
    irpStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    irpStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    //
    // Make sure that there are no completion routines set
    //
    IoSetCompletionRoutine(
        pnpIrp,
        NULL,
        NULL,
        FALSE,
        FALSE,
        FALSE
        );

    //
    // Call the driver
    //
    status = IoCallDriver( targetObject, pnpIrp );
    if (status == STATUS_PENDING) {

        //
        // Block until the irp comes back
        //
        KeWaitForSingleObject(
            &pnpEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = ioStatus.Status;

    }

IdeGetDeviceCapabilitiesExit:
    //
    // Done with reference
    //
    ObDereferenceObject( targetObject );

    //
    // Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\sync.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sync.h
//
//--------------------------------------------------------------------------

#if !defined (___sync_h___)
#define ___sync_h___

NTSTATUS
PciIdeCreateSyncChildAccess (
    PCTRLFDO_EXTENSION FdoExtension
);

VOID
PciIdeDeleteSyncChildAccess (
    PCTRLFDO_EXTENSION FdoExtension
);

NTSTATUS
PciIdeQuerySyncAccessInterface (
    PCHANPDO_EXTENSION            PdoExtension,
    PPCIIDE_SYNC_ACCESS_INTERFACE SyncAccessInterface
    );

NTSTATUS
PciIdeAllocateAccessToken (
    PVOID              Token,
    PDRIVER_CONTROL    Callback,
    PVOID              CallbackContext
);

NTSTATUS
PciIdeFreeAccessToken (
    PVOID              Token
);

BOOLEAN
PciIdeSyncAccessRequired (
    IN PCTRLFDO_EXTENSION FdoExtension
);

#endif // ___sync_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\atapi\atapikd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    atapikd.c

Abstract:

    Debugger Extension Api for interpretting atapi structures

Author:


Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
#include "math.h"
#include "ideport.h"


const LARGE_INTEGER Magic10000    = {0xe219652c, 0xd1b71758};
#define SHIFT10000   13
#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

VOID
AtapiDumpPdoExtension(
    IN ULONG64 PdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
AtapiDumpFdoExtension(
    IN ULONG64 FdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
DumpPdoState(
    IN ULONG Depth,
    IN ULONG State
    );

VOID
DumpFdoState(
    IN ULONG Depth,
    IN ULONG State
    );

#ifdef ENABLE_COMMAND_LOG
    VOID
    DumpCommandLog(
          IN ULONG Depth,
          IN ULONG64 SrbDataAddr
          );
#else
    #define DumpCommandLog(a, b)
#endif


VOID
DumpIdentifyData(
      IN ULONG Depth, 
      IN PIDENTIFY_DATA IdData
      );

PUCHAR DMR_Reason[] = {
   "",
   "Enum Failed",
   "Reported Missing",
   "Too Many Timeout",
   "Killed PDO",
   "Replaced By User"
};

PUCHAR DeviceType[] = {
   "DIRECT_ACCESS_DEVICE",
   "SEQUENTIAL_ACCESS_DEVICE",
   "PRINTER_DEVICE",
   "PROCESSOR_DEVICE",
   "WRITE_ONCE_READ_MULTIPLE_DEVICE",
   "READ_ONLY_DIRECT_ACCESS_DEVICE",
   "SCANNER_DEVICE",
   "OPTICAL_DEVICE",
   "MEDIUM_CHANGER",
   "COMMUNICATION_DEVICE"
};

PUCHAR PdoState[] = {
   "PDOS_DEVICE_CLAIMED",
   "PDOS_LEGACY_ATTACHER",
   "PDOS_STARTED",
   "PDOS_STOPPED",
   "PDOS_SURPRISE_REMOVED",
   "PDOS_REMOVED",
   "PDOS_DEADMEAT",
   "PDOS_NO_POWER_DOWN",
   "PDOS_QUEUE_FROZEN_BY_POWER_DOWN",
   "PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM",
   "PDOS_QUEUE_FROZEN_BY_STOP_DEVICE",
   "PDOS_QUEUE_FROZEN_BY_PARENT",
   "PDOS_QUEUE_FROZEN_BY_START",
   "PDOS_DISABLED_BY_USER",
   "PDOS_NEED_RESCAN",
   "PDOS_REPORTED_TO_PNP",
   "PDOS_INITIALIZED"
};

PUCHAR FdoState[] = {
   "FDOS_DEADMEAT",
   "FDOS_STARTED",
   "FDOS_STOPPED"
};

#define MAX_PDO_STATES 16
#define MAX_FDO_STATES  3

DECLARE_API(pdoext)

/*++

Routine Description:

    Dumps the pdo extension for a given device object, or dumps the
    given pdo extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 devObjAddr = 0;
    ULONG64 detail = 0;

    ReloadSymbols("atapi.sys");

    if (GetExpressionEx(args, &devObjAddr, &args))
    {
        GetExpressionEx(args, &detail, &args);
    }

    if (devObjAddr){
        CSHORT objType = GetUSHORTField(devObjAddr, "nt!_DEVICE_OBJECT", "Type");

        if (objType == IO_TYPE_DEVICE){
            ULONG64 pdoExtAddr;

            pdoExtAddr = GetULONGField(devObjAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
            if (pdoExtAddr != BAD_VALUE){
                AtapiDumpPdoExtension(pdoExtAddr, (ULONG)detail, 0);
            }
        }
        else {
            dprintf("Error: 0x%08p is not a device object\n", devObjAddr);
        }
    }
    else {
        dprintf("\n usage: !atapikd.pdoext <atapi pdo> \n\n");
    }
    
    return S_OK;
}


VOID
AtapiDumpPdoExtension(
    IN ULONG64 PdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    UCHAR scsiDeviceType;
    ULONG pdoState;
    ULONG luFlags;
    ULONG64 attacheePdo;
    ULONG64 idleCounterAddr;
    ULONG64 srbDataAddr;
    ULONG devicePowerState, systemPowerState;
    
    xdprintf(Depth, ""), dprintf("\nATAPI physical device extension at address 0x%08p\n\n", PdoExtAddr);

    Depth++;

    scsiDeviceType = GetUCHARField(PdoExtAddr, "atapi!_PDO_EXTENSION", "ScsiDeviceType");
    pdoState = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "PdoState");
    luFlags = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "LuFlags");
    attacheePdo = GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "AttacheePdo");
    idleCounterAddr = GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "IdleCounter");
    srbDataAddr = GetFieldAddr(PdoExtAddr, "atapi!_PDO_EXTENSION", "SrbData");
    devicePowerState = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "DevicePowerState");
    systemPowerState = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "SystemPowerState");
    
    if ((scsiDeviceType != BAD_VALUE) && (pdoState != BAD_VALUE) && (luFlags != BAD_VALUE) &&
        (attacheePdo != BAD_VALUE) && (idleCounterAddr != BAD_VALUE) && (srbDataAddr != BAD_VALUE) &&
        (devicePowerState != BAD_VALUE) && (systemPowerState != BAD_VALUE)){

        ULONG idlecount;
        
        if ((scsiDeviceType >= 0) && (scsiDeviceType <= 9)) {
           xdprintf(Depth, ""), dprintf("SCSI Device Type : %s\n", DeviceType[scsiDeviceType]);
        } 
        else {
           xdprintf(Depth, ""), dprintf("Connected to Unknown Device\n");
        }

        DumpPdoState(Depth, pdoState);

        dprintf("\n");
        DumpFlags(Depth, "LU Flags", luFlags, LuFlags);

        xdprintf(Depth, ""), dprintf("PowerState (D%d, S%d)\n", devicePowerState-1, systemPowerState-1);

        if (idleCounterAddr){
            ULONG resultLen = 0;
            ReadMemory(idleCounterAddr, &idlecount, sizeof(ULONG), &resultLen);
            if (resultLen != sizeof(ULONG)){
                idlecount = 0;
            }
        } 
        else {
            idlecount = 0;
        }
        xdprintf(Depth, ""), dprintf("IdleCounter 0x%08x\n", idlecount);

        xdprintf(Depth, ""), dprintf("SrbData: (use ' dt atapi!_SRB_DATA %08p ')\n", srbDataAddr);
       
        dprintf("\n");
        xdprintf(Depth, ""), dprintf("(for more info, use ' dt atapi!_PDO_EXTENSION %08p ')\n", PdoExtAddr);
                    
        #ifdef LOG_DEADMEAT_EVENT
            {
                ULONG deadmeatReason;
                deadmeatReason = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "DeadmeatRecord.Reason");
                if ((deadmeatReason != BAD_VALUE) && (deadmeatReason > 0) && (deadmeatReason < sizeof(DMR_Reason)/sizeof(PUCHAR))){
                    dprintf("\n");
                    xdprintf(Depth, "Deadmeat Record: \n");
                    xdprintf(Depth+1, "Reason : %s\n", DMR_Reason[deadmeatReason]);
                    xdprintf(Depth+1, ""), dprintf("(for more info, use ' dt -r atapi!_PDO_EXTENSION %08p ')\n", PdoExtAddr);
                }
            }
        #endif 

        #ifdef ENABLE_COMMAND_LOG
            DumpCommandLog(Depth, srbDataAddr);
        #endif

    }
    
    dprintf("\n");

    
}


VOID DumpPdoState(IN ULONG Depth, IN ULONG State)
{
    int inx, statebit, count;

    count = 0;
    xdprintf(Depth, ""), dprintf("PDO State (0x%08x): \n", State);
   
    if (State & 0x80000000) {
        xdprintf(Depth+1, "Initialized ");
        count++;
    }

    for (inx = 0; inx < MAX_PDO_STATES; inx++) {
        statebit = (1 << inx);
        if (State & statebit) {
            xdprintf(Depth+1, "%s ", PdoState[inx]);
            count++;
            if ((count % 2) == 0) {
                dprintf("\n");
            }
        }
   }

   dprintf("\n");
}



DECLARE_API(fdoext)

/*++

Routine Description:

    Dumps the fdo extension for a given device object, or dumps the
    given fdo extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 devObjAddr = 0;
    ULONG64 detail = 0;

    ReloadSymbols("atapi.sys");
    
    if (GetExpressionEx(args, &devObjAddr, &args))
    {
        GetExpressionEx(args, &detail, &args);
    }

    if (devObjAddr){
        CSHORT objType = GetUSHORTField(devObjAddr, "nt!_DEVICE_OBJECT", "Type");

        if (objType == IO_TYPE_DEVICE){
            ULONG64 fdoExtAddr;

            fdoExtAddr = GetULONGField(devObjAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
            if (fdoExtAddr != BAD_VALUE){
                AtapiDumpFdoExtension(fdoExtAddr, (ULONG)detail, 0);
            }
        }
        else {
            dprintf("Error: 0x%08p is not a device object\n", devObjAddr);
        }
    }
    else {
        dprintf("\n usage: !atapikd.pdoext <atapi pdo> \n\n");
    }

    return S_OK;
}


DECLARE_API(miniext)

/*++

Routine Description:

    Dumps the Miniport device extension at the given address

Arguments:

    args - string containing the address of the miniport extension

Return Value:

    none

--*/

{
    ULONG64 hwDevExtAddr;
    ULONG Depth = 1;

    ReloadSymbols("atapi.sys");

    GetExpressionEx(args, &hwDevExtAddr, &args);
    
    if (hwDevExtAddr){
        ULONG64 deviceFlagsArrayAddr;
        ULONG64 lastLunArrayAddr;
        ULONG64 timeoutCountArrayAddr;
        ULONG64 numberOfCylindersArrayAddr;
        ULONG64 numberOHeadsArrayAddr;
        ULONG64 sectorsPerTrackArrayAddr;
        ULONG64 maxBlockTransferArrayAddr;
        ULONG64 identifyDataArrayAddr;
        
        deviceFlagsArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "DeviceFlags");
        lastLunArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "LastLun");
        timeoutCountArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "TimeoutCount");
        numberOfCylindersArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "NumberOfCylinders");
        numberOHeadsArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "NumberOfHeads");
        sectorsPerTrackArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "SectorsPerTrack");
        maxBlockTransferArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "MaximumBlockXfer");
        identifyDataArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "IdentifyData");

        if ((deviceFlagsArrayAddr != BAD_VALUE) && (lastLunArrayAddr != BAD_VALUE) &&
            (timeoutCountArrayAddr != BAD_VALUE) && (numberOfCylindersArrayAddr != BAD_VALUE) &&
            (numberOHeadsArrayAddr != BAD_VALUE) && (sectorsPerTrackArrayAddr != BAD_VALUE) &&
            (maxBlockTransferArrayAddr != BAD_VALUE) && (identifyDataArrayAddr != BAD_VALUE)){
            
            ULONG deviceFlagsArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG lastLunArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG timeoutCountArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG numberOfCylindersArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG numberOfHeadsArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG sectorsPerTrackArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            UCHAR maxBlockTransferArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            IDENTIFY_DATA identifyDataArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
                        
            ULONG resultLen;
            BOOLEAN ok;
            
            xdprintf(Depth, ""), dprintf("\nATAPI Miniport Device Extension at address 0x%08p\n\n", hwDevExtAddr);

            /*
             *  Read in arrays of info for child LUNs
             */
            ok = TRUE;
            if (ok) ok = (BOOLEAN)ReadMemory(deviceFlagsArrayAddr, (PVOID)deviceFlagsArray, sizeof(deviceFlagsArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(lastLunArrayAddr, (PVOID)lastLunArray, sizeof(lastLunArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(timeoutCountArrayAddr, (PVOID)timeoutCountArray, sizeof(timeoutCountArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(numberOfCylindersArrayAddr, (PVOID)numberOfCylindersArray, sizeof(numberOfCylindersArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(numberOHeadsArrayAddr, (PVOID)numberOfHeadsArray, sizeof(numberOfHeadsArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(sectorsPerTrackArrayAddr, (PVOID)sectorsPerTrackArray, sizeof(sectorsPerTrackArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(maxBlockTransferArrayAddr, (PVOID)maxBlockTransferArray, sizeof(maxBlockTransferArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(identifyDataArrayAddr, (PVOID)identifyDataArray, sizeof(identifyDataArray), &resultLen);
                
            if (ok){
                ULONG i;

                /*
                 *  Display details for each device
                 */
                dprintf("\n");
                for (i = 0; i < (MAX_IDE_DEVICE * MAX_IDE_LINE); i++) {
                    if (deviceFlagsArray[i] & DFLAGS_DEVICE_PRESENT){

                        xdprintf(Depth, "Device %d Details:\n", i);
                        
                        DumpFlags(Depth+1, "Device Flags", deviceFlagsArray[i], DevFlags);

                        xdprintf(Depth+1, "TimeoutCount %u, LastLun %u, MaxBlockXfer 0x%02x\n",
                                                    timeoutCountArray[i], lastLunArray[i], maxBlockTransferArray[i]);

                        xdprintf(Depth+1, "NumCylinders 0x%08x, NumHeads 0x%08x, SectorsPerTrack 0x%08x\n",
                                                    numberOfCylindersArray[i], numberOfHeadsArray[i], sectorsPerTrackArray[i]);

                        /*
                         *  Display DeviceParameters info
                         */
                        dprintf("\n");
                        if (IsPtr64()){
                            xdprintf(Depth+1, "(cannot display DeviceParameters[] info for 64-bit)\n");
                        }
                        else {
                            /*
                             *  DeviceParameters[] is an array of embedded structs.
                             *  Reading this in an architecture-agnostic way would be tricky, 
                             *  so we punt and only do it for 32-bit target and 32-bit debug extension.
                             */
                            #ifdef _X86_
                                HW_DEVICE_EXTENSION hwDevExt;
                                ok = (BOOLEAN)ReadMemory(hwDevExtAddr, (PVOID)&hwDevExt, sizeof(hwDevExt), &resultLen);
                                if (ok){
                                    #define IsInitXferMode(a) ((a == 0x7fffffff) ? -1 : a)
                                    xdprintf(Depth+1, "Device Parameters Summary :\n");
                                    xdprintf(Depth+2, "PioReadCommand 0x%02x, PioWriteCommand 0x%02x\n",
                                                                hwDevExt.DeviceParameters[i].IdePioReadCommand,
                                                                hwDevExt.DeviceParameters[i].IdePioWriteCommand);
                                    xdprintf(Depth+2, "IdeFlushCommand 0x%02x, MaxBytePerPioInterrupt %u\n",
                                                                hwDevExt.DeviceParameters[i].IdeFlushCommand,
                                                                hwDevExt.DeviceParameters[i].MaxBytePerPioInterrupt);
                                    xdprintf(Depth+2, "BestPioMode %d, BestSwDMAMode %d\n",
                                                                IsInitXferMode(hwDevExt.DeviceParameters[i].BestPioMode),
                                                                IsInitXferMode(hwDevExt.DeviceParameters[i].BestSwDmaMode));
                                    xdprintf(Depth+2, "BestMwDMAMode %d, BestUDMAMode %d\n",
                                                                IsInitXferMode(hwDevExt.DeviceParameters[i].BestMwDmaMode),
                                                                IsInitXferMode(hwDevExt.DeviceParameters[i].BestUDmaMode));
                                    xdprintf(Depth+2, "TMSupported 0x%08x, TMCurrent 0x%08x\n",
                                                                hwDevExt.DeviceParameters[i].TransferModeSupported,
                                                                hwDevExt.DeviceParameters[i].TransferModeCurrent);
                                    xdprintf(Depth+2, "TMMask 0x%08x, TMSelected 0x%08x\n",
                                                                hwDevExt.DeviceParameters[i].TransferModeMask,
                                                                hwDevExt.DeviceParameters[i].TransferModeSelected);
                                }
                                else {
                                    dprintf("\n failed to read HW_DEVICE_EXTENSION at 0x%08p\n", hwDevExtAddr);
                                }
                            #else
                                xdprintf(Depth+1, "(64-bit debug extension cannot display DeviceParameters[] info)\n");
                            #endif
                        }

                        /*
                         *  Display Identify Data
                         */
                        dprintf("\n");
                        xdprintf(Depth+1, ""), dprintf("Identify Data Summary :\n");
                        xdprintf(Depth+2, ""), dprintf("Word 1,3,6 (C-0x%04x, H-0x%04x, S-0x%04x) \n",
                                                                    identifyDataArray[i].NumCylinders,
                                                                    identifyDataArray[i].NumHeads,
                                                                    identifyDataArray[i].NumSectorsPerTrack);
                        xdprintf(Depth+2, ""), dprintf("Word 54,55,56 (C-0x%04x, H-0x%04x, S-0x%04x) \n",
                                                                    identifyDataArray[i].NumberOfCurrentCylinders,
                                                                    identifyDataArray[i].NumberOfCurrentHeads,
                                                                    identifyDataArray[i].CurrentSectorsPerTrack);
                        xdprintf(Depth+2, ""), dprintf("CurrentSectorCapacity 0x%08x, UserAddressableSectors 0x%08x\n",
                                                                    identifyDataArray[i].CurrentSectorCapacity,
                                                                    identifyDataArray[i].UserAddressableSectors);
                        xdprintf(Depth+2, ""), dprintf("Capabilities(word 49) 0x%04x, UDMASup 0x%02x, UDMAActive 0x%02x\n",
                                                                    identifyDataArray[i].Capabilities,
                                                                    identifyDataArray[i].UltraDMASupport,
                                                                    identifyDataArray[i].UltraDMAActive);
                        dprintf("\n");
                    }
                    else {
                        xdprintf(Depth, "Device %d not present\n", i);
                    }
                }
            }
            else {
                dprintf("\n ReadMemory failed to read one of the arrays from HW_DEVICE_EXTENSION @ 0x%08p\n", hwDevExtAddr);
            }
        }
        
        dprintf("\n");
        xdprintf(Depth+1, ""), dprintf("(for more info, use ' dt atapi!_HW_DEVICE_EXTENSION %08p ')\n", hwDevExtAddr);
    }
    else {
        dprintf("\n usage: !atapikd.miniext <PHW_DEVICE_EXTENSION> \n\n");
    }
    
    dprintf("\n");
    
    return S_OK;
}



VOID AtapiDumpFdoExtension(IN ULONG64 FdoExtAddr, IN ULONG Detail, IN ULONG Depth)
{
    ULONG devicePowerState, systemPowerState;
    ULONG flags, srbFlags, fdoState;
    ULONG64 interruptDataAddr;
    ULONG64 ideResourceAddr;
    
    xdprintf(Depth, ""), dprintf("\nATAPI Functional Device Extension @ 0x%08p\n\n", FdoExtAddr);

    devicePowerState = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "DevicePowerState");
    systemPowerState = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "SystemPowerState");
    flags = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "Flags");
    srbFlags = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "SrbFlags");
    fdoState = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "FdoState");
    interruptDataAddr = GetFieldAddr(FdoExtAddr, "atapi!_FDO_EXTENSION", "InterruptData");
    ideResourceAddr = GetFieldAddr(FdoExtAddr, "atapi!_FDO_EXTENSION", "IdeResource");
    
    if ((devicePowerState != BAD_VALUE) && (systemPowerState != BAD_VALUE) &&
        (flags  != BAD_VALUE) && (srbFlags != BAD_VALUE) && (fdoState != BAD_VALUE) &&
        (interruptDataAddr != BAD_VALUE) && (ideResourceAddr != BAD_VALUE)){

        ULONG interruptFlags, interruptMode, interruptLevel;
        BOOLEAN primaryDiskClaimed, secondaryDiskClaimed;
            
        xdprintf(Depth+1, "Power State (D%d, S%d)\n", devicePowerState-1, systemPowerState-1);

        DumpFlags(Depth+1, "Port Flags", flags, PortFlags);
        DumpFlags(Depth+1, "SRB Flags", srbFlags, SrbFlags);       

        DumpFdoState(Depth+1, fdoState);

        /*
         *  Display interrupt data
         */
        dprintf("\n");
        xdprintf(Depth+1, "Interrupt Data: \n");
        interruptFlags = (ULONG)GetULONGField(interruptDataAddr, "atapi!_INTERRUPT_DATA", "InterruptFlags");
        if (interruptFlags != BAD_VALUE){
            DumpFlags(Depth+2, "Port Flags", interruptFlags, PortFlags);
        }
        xdprintf(Depth+2, ""), dprintf("(for more info, use ' dt atapi!_INTERRUPT_DATA %08p ')\n", interruptDataAddr);

        /*
         *  Display IDE_RESOURCE info
         */
        dprintf("\n");
        xdprintf(Depth+1, " IDE Resources: \n");
        interruptMode = (ULONG)GetULONGField(ideResourceAddr, "atapi!_IDE_RESOURCE", "InterruptMode");
        interruptLevel = (ULONG)GetULONGField(ideResourceAddr, "atapi!_IDE_RESOURCE", "InterruptLevel");
        primaryDiskClaimed = (BOOLEAN)GetUCHARField(ideResourceAddr, "atapi!_IDE_RESOURCE", "AtdiskPrimaryClaimed");
        secondaryDiskClaimed = (BOOLEAN)GetUCHARField(ideResourceAddr, "atapi!_IDE_RESOURCE", "AtdiskSecondaryClaimed");
        if ((interruptMode != BAD_VALUE) && (interruptLevel != BAD_VALUE) &&
            (primaryDiskClaimed != BAD_VALUE) && (secondaryDiskClaimed != BAD_VALUE)){
            
            xdprintf(Depth+2, "Interrupt Mode : %s \n", interruptMode ? "Latched" : "Level Sensitive");
            xdprintf(Depth+2, "Interrupt Level 0x%x\n", interruptLevel);
            xdprintf(Depth+2, "Primary Disk %s.\n", primaryDiskClaimed ? "Claimed" : "Not Claimed");
            xdprintf(Depth+2, "Secondary Disk %s.\n", secondaryDiskClaimed ? "Claimed" : "Not Claimed");
        }
        xdprintf(Depth+2, ""), dprintf("(for more info use ' dt atapi!_IDE_RESOURCE %08p ')\n", ideResourceAddr);
        
    }

    dprintf("\n");
    xdprintf(Depth+1, ""), dprintf("(for more info, use ' dt atapi!_FDO_EXTENSION %08p ')\n", FdoExtAddr);
    
    dprintf("\n");
    
}

VOID DumpFdoState(IN ULONG Depth, IN ULONG State)
{
    int inx, count;

    count = 0;
    xdprintf(Depth, ""), dprintf("FDO State (0x%08x): \n", State);
   
    for (inx = 0; inx < MAX_FDO_STATES; inx++) {

        if (State & (1<<inx)) {
            xdprintf(Depth+1, "%s ", FdoState[inx]);
        }
    }

    dprintf("\n");
}


#ifdef ENABLE_COMMAND_LOG

/*
    VOID ShowCommandLog(ULONG Depth, PCOMMAND_LOG CmdLogEntry, ULONG LogNumber)
    {
        if ((CmdLogEntry->FinalTaskFile.bCommandReg & IDE_STATUS_ERROR) || (CmdLogEntry->Cdb[0] == SCSIOP_REQUEST_SENSE)){ 
            xdprintf(Depth,  "Log[%03d]: Cmd(%02x), SrbSts(%02x), Sts(%02x), BmStat(%02x), Sense(%02x/%02x/%02x)", 
                                    LogNumber, CmdLogEntry->Cdb[0], CmdLogEntry->SrbStatus,  CmdLogEntry->FinalTaskFile.bCommandReg, CmdLogEntry->BmStatus, 
                                    CmdLogEntry->SenseData[0], CmdLogEntry->SenseData[1], CmdLogEntry->SenseData[2]); 
        } 
        else { 
            xdprintf(Depth, "Log[%03d]: Cmd(%02x), SrbSts(%02x), Sts(%02x), BmStat(%02x)", 
                                    LogNumber, CmdLogEntry->Cdb[0], CmdLogEntry->SrbStatus, CmdLogEntry->FinalTaskFile.bCommandReg, CmdLogEntry->BmStatus); 
        }

        // 
        // For pass through commands print out the command register
        //
        if (CmdLogEntry->Cdb[0] == 0xc8){
            xdprintf(Depth, "CmdR(%02x)", CmdLogEntry->Cdb[7]); 
        } 
        dprintf("\n");
    }
    */

VOID
FileTimeToString(
    IN LARGE_INTEGER Time,
    OUT PCHAR Buffer
    )
{
    TIME_FIELDS TimeFields;
    TIME_ZONE_INFORMATION TimeZoneInfo;
    PWCHAR pszTz;
    ULONGLONG TzBias;
    DWORD Result;

    //
    // Get the local (to the debugger) timezone bias
    //
    Result = GetTimeZoneInformation(&TimeZoneInfo);
    if (Result == 0xffffffff) {
        pszTz = L"UTC";
    } else {
        //
        // Bias is in minutes, convert to 100ns units
        //
        TzBias = (ULONGLONG)TimeZoneInfo.Bias * 60 * 10000000;
        switch (Result) {
            case TIME_ZONE_ID_UNKNOWN:
                pszTz = L"unknown";
                break;
            case TIME_ZONE_ID_STANDARD:
                pszTz = TimeZoneInfo.StandardName;
                break;
            case TIME_ZONE_ID_DAYLIGHT:
                pszTz = TimeZoneInfo.DaylightName;
                break;
        }

        Time.QuadPart -= TzBias;
    }

    RtlTimeToTimeFields(&Time, &TimeFields);

    sprintf(Buffer, "%02d:%02d:%02d.%03d",
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second,
            TimeFields.Milliseconds);

}

VOID 
ShowCommandLog(
    ULONG Depth, 
    PCOMMAND_LOG CmdLogEntry, 
    ULONG LogNumber
)
{
    LARGE_INTEGER timeDiff;
    CHAR startTime[256] = {0};
    ULONG sector;

    sector = (CmdLogEntry->Cdb[5] |
                 CmdLogEntry->Cdb[4] << 8 |
                 CmdLogEntry->Cdb[3] << 16 |
                 CmdLogEntry->Cdb[2] << 24);

    FileTimeToString(CmdLogEntry->StartTime, startTime);

    dprintf ("%02x   %02x      %02x      %08x  %s ",
             CmdLogEntry->Cdb[0], 
             CmdLogEntry->SrbStatus,
             CmdLogEntry->FinalTaskFile.bCommandReg,
             sector,
             startTime
             );

    if (CmdLogEntry->EndTime.QuadPart >= CmdLogEntry->StartTime.QuadPart) {

        timeDiff.QuadPart = CmdLogEntry->EndTime.QuadPart - CmdLogEntry->StartTime.QuadPart; 

        timeDiff = Convert100nsToMilliseconds( timeDiff);

        dprintf ("(%4d ms)",
                 timeDiff.LowPart
                 );

    } 

    dprintf("\n");
}

    VOID DumpCommandLog(IN ULONG Depth, IN ULONG64 SrbDataAddr)
    {
        ULONG64 cmdLogAddr;
        ULONG cmdLogIndex;
       
        dprintf("\n");

        cmdLogAddr = GetULONGField(SrbDataAddr, "atapi!_SRB_DATA", "IdeCommandLog");
        cmdLogIndex = (ULONG)GetULONGField(SrbDataAddr, "atapi!_SRB_DATA", "IdeCommandLogIndex");

        if ((cmdLogAddr != BAD_VALUE) && (cmdLogIndex != BAD_VALUE)){
            UCHAR cmdLogBlock[MAX_COMMAND_LOG_ENTRIES*sizeof(COMMAND_LOG)];
            ULONG resultLen;
            BOOLEAN ok;
            
            xdprintf(Depth, ""), dprintf("Command Log Summary at %p\n\n", cmdLogAddr);

            ok = (BOOLEAN)ReadMemory(cmdLogAddr, (PVOID)cmdLogBlock, sizeof(cmdLogBlock), &resultLen);
            if (ok){
                PCOMMAND_LOG cmdLog = (PCOMMAND_LOG)cmdLogBlock;
                ULONG logIndex, logNumber;

                /*
                 *  Print the log in temporal order, starting at the correct point in the circular log buffer.
                 */
                xdprintf(Depth+1, "Log           Srb     Ata                         \n");
                xdprintf(Depth+1, "Offset   Cmd  Status  Status  Lba       Time Stamp\n");
                xdprintf(Depth+1, "------   ---  ------  ------  ---       ---- -----\n");

                logNumber = 0;
                for (logIndex=cmdLogIndex+1; logIndex< MAX_COMMAND_LOG_ENTRIES; logIndex++, logNumber++) {

                    xdprintf(Depth+1,"+%04x  : ", 
                             logIndex*GetTypeSize("atapi!_COMMAND_LOG")
                             );

                    ShowCommandLog(Depth+1, &cmdLog[logIndex], logNumber);
                }
                for (logIndex=0; logIndex <= cmdLogIndex; logIndex++, logNumber++) {

                    xdprintf(Depth+1,"+%04x  : ", 
                             logIndex*GetTypeSize("atapi!_COMMAND_LOG")
                             );

                    ShowCommandLog(Depth+1, &cmdLog[logIndex], logNumber);
                }
            }
            else {
                dprintf("\n Error reading command log at address 0x%08p\n", cmdLogAddr);
            }
        }
        
    }
#endif


/*
 *
 *      USAGE: !atapikd.findirp {pdo|fdo} [specificIrp]
 */
DECLARE_API(findirp)
{
    ULONG64 devObjAddr = 0;
    ULONG64 specificIrpAddr = 0;

    ReloadSymbols("atapi.sys");

    /*
     *  Make sure that the output buffers don't overflow by limiting the length of the input buffer that we process.
     */

    if (GetExpressionEx(args, &devObjAddr, &args))
    {
        GetExpressionEx(args, &specificIrpAddr, &args);
    }

    if (devObjAddr){
        if (IsAtapiPdo(devObjAddr)){
            /*
             *  Find the Irp or dump all Irps
             *  If specificIrpAddr is NULL, FindIrpInPdo will dump all Irps.
             */
            FindIrpInPdo(1, devObjAddr, specificIrpAddr, TRUE);
        }
        else if (IsAtapiFdo(devObjAddr)){
            /*
             *  Find the Irp or dump all Irps
             *  If specificIrpAddr is NULL, FindIrpInFdo will dump all Irps.
             */
            FindIrpInFdo(1, devObjAddr, specificIrpAddr);
        }
        else {
            dprintf("\n error: %08p is not an ATAPI Fdo or Pdo\n");
        }
    }
    else {
        dprintf("\n USAGE: !atapikd.findirp <pdo|fdo> [irp]\n");
    }
    
    return S_OK;
}


BOOLEAN IsAtapiPdo(ULONG64 DevObjAddr)
{
    ULONG64 devExtAddr;
    BOOLEAN isPdo = FALSE;
    
    devExtAddr = GetULONGField(DevObjAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
    if (devExtAddr != BAD_VALUE){
        ULONG64 attacheeDevObj = GetULONGField(devExtAddr, "atapi!_PDO_EXTENSION", "AttacheeDeviceObject");
        if (attacheeDevObj == (ULONG64)NULL){
            // BUGBUG FINISH
            isPdo = TRUE;
        }
    }
    
    return isPdo;
}


BOOLEAN IsAtapiFdo(ULONG64 DevObjAddr)
{
    ULONG64 devExtAddr;
    BOOLEAN isFdo = FALSE;
    
    devExtAddr = GetULONGField(DevObjAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
    if (devExtAddr != BAD_VALUE){
        ULONG64 attacheeDevObj = GetULONGField(devExtAddr, "atapi!_FDO_EXTENSION", "AttacheeDeviceObject");
        if (attacheeDevObj){
            // BUGBUG FINISH
            isFdo = TRUE;
        }        
    }
    
    return isFdo;
}


/*
 *  FindIrpInPdo
 *
 *      If IrpAddr is NULL, dump all IRPs. Otherwise, find only the given Irp.
 */
BOOLEAN FindIrpInPdo(ULONG Depth, ULONG64 PdoAddr, ULONG64 IrpAddr, BOOLEAN SearchParent)
{
    ULONG64 currentIrp;
    ULONG64 pdoExtAddr;
    ULONG64 deviceQueueAddr;
    BOOLEAN found = FALSE;
    
    xdprintf(Depth, ""), dprintf("Searching Atapi Pdo %08p ...\n", PdoAddr);
    
    currentIrp = GetULONGField(PdoAddr, "nt!_DEVICE_OBJECT", "CurrentIrp");
    if (currentIrp && (!IrpAddr || (currentIrp == IrpAddr))){
        xdprintf(Depth+1, ""), dprintf("- CurrentIrp of Pdo %08p = %08p\n", PdoAddr, currentIrp);
    }
    
    deviceQueueAddr = GetFieldAddr(PdoAddr, "nt!_DEVICE_OBJECT", "DeviceQueue");
    if (deviceQueueAddr != BAD_VALUE){
        ULONG64 devQueueListHeadAddr = GetFieldAddr(deviceQueueAddr, "nt!_KDEVICE_QUEUE", "DeviceListHead");
        if (devQueueListHeadAddr != BAD_VALUE){
            if (IrpAddr){
                if (FindIrpInDeviceQueue(devQueueListHeadAddr, IrpAddr)){
                    xdprintf(Depth+1, ""), dprintf("- Irp %08p is in DeviceQueue of Pdo %08p\n", IrpAddr, PdoAddr);
                }
            }
            else {
                DumpIrpDeviceQueue(Depth+1, "Pdo Irp Queue", devQueueListHeadAddr);
            }
        }
    }
    
    pdoExtAddr = GetULONGField(PdoAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
    if (pdoExtAddr != BAD_VALUE){
        ULONG64 pendingIrp = GetULONGField(pdoExtAddr, "atapi!_PDO_EXTENSION", "PendingRequest");
        ULONG64 busyIrp = GetULONGField(pdoExtAddr, "atapi!_PDO_EXTENSION", "BusyRequest");
        ULONG64 abortSrbAddr = GetULONGField(pdoExtAddr, "atapi!_PDO_EXTENSION", "AbortSrb");
        
        if (pendingIrp && (!IrpAddr || (pendingIrp == IrpAddr))){
            xdprintf(Depth+1, ""), dprintf("- PendingRequest of Pdo %08p = %08p\n", PdoAddr, pendingIrp);
            found = TRUE;
        }
        if (busyIrp && (!IrpAddr || (busyIrp == IrpAddr))){
            xdprintf(Depth+1, ""), dprintf("- BusyRequest of Pdo %08p = %08p\n", PdoAddr, busyIrp);
            found = TRUE;
        }

        if (abortSrbAddr && (abortSrbAddr != BAD_VALUE)){
            ULONG64 origRequestIrpAddr = GetULONGField(abortSrbAddr, "atapi!_SCSI_REQUEST_BLOCK", "OriginalRequest");
            if (origRequestIrpAddr && (!IrpAddr || (origRequestIrpAddr == IrpAddr))){
                xdprintf(Depth+1, ""), dprintf("- AbortSrb %08p of Pdo %08p has OriginalRequest Irp %08p\n", abortSrbAddr, PdoAddr, origRequestIrpAddr);
            }
        }
        
        if (SearchParent){
            ULONG64 fdoExtAddr = GetULONGField(pdoExtAddr, "atapi!_PDO_EXTENSION", "ParentDeviceExtension");
            if (fdoExtAddr != BAD_VALUE){
                ULONG64 fdoAddr = GetULONGField(fdoExtAddr, "atapi!_FDO_EXTENSION", "DeviceObject");
                if (FindIrpInFdo(Depth+1, fdoAddr, IrpAddr)){
                    found = TRUE;
                }
            }
        }
    }

    return found;
}


/*
 *  FindIrpInFdo
 *
 *      If IrpAddr is NULL, dump all IRPs. Otherwise, find only the given Irp.
 */
BOOLEAN FindIrpInFdo(ULONG Depth, ULONG64 FdoAddr, ULONG64 IrpAddr)
{
    ULONG64 fdoExtAddr;
    ULONG64 currentIrp;
    ULONG64 deviceQueueAddr;
    BOOLEAN found = FALSE;
    
    xdprintf(Depth, ""), dprintf("Searching Atapi Fdo %08p ...\n", FdoAddr);

    deviceQueueAddr = GetFieldAddr(FdoAddr, "nt!_DEVICE_OBJECT", "DeviceQueue");
    if (deviceQueueAddr != BAD_VALUE){
        ULONG64 devQueueListHeadAddr = GetFieldAddr(deviceQueueAddr, "nt!_KDEVICE_QUEUE", "DeviceListHead");
        if (devQueueListHeadAddr != BAD_VALUE){
            if (IrpAddr){
                if (FindIrpInDeviceQueue(devQueueListHeadAddr, IrpAddr)){
                    xdprintf(Depth+1, ""), dprintf("- Irp %08p is in DeviceQueue of Fdo %08p\n", IrpAddr, FdoAddr);
                }
            }
            else {
                DumpIrpDeviceQueue(Depth+1, "Fdo Irp Queue", devQueueListHeadAddr);
            }
        }
    }

    currentIrp = GetULONGField(FdoAddr, "nt!_DEVICE_OBJECT", "CurrentIrp");
    if (currentIrp && (!IrpAddr || (currentIrp == IrpAddr))){
        xdprintf(Depth+1, ""), dprintf("- CurrentIrp of Fdo %08p = %08p\n", FdoAddr, currentIrp);
    }

    fdoExtAddr = GetULONGField(FdoAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
    if (fdoExtAddr != BAD_VALUE){
        ULONG64 resetSrbAddr = GetULONGField(fdoExtAddr, "atapi!_FDO_EXTENSION", "ResetSrb");
        if (resetSrbAddr && (resetSrbAddr != BAD_VALUE)){
            ULONG64 origRequestIrpAddr = GetULONGField(resetSrbAddr, "atapi!_SCSI_REQUEST_BLOCK", "OriginalRequest");
            if (origRequestIrpAddr && (!IrpAddr || (origRequestIrpAddr == IrpAddr))){
                xdprintf(Depth+1, ""), dprintf("- ResetSrb %08p of Fdo %08p has OriginalRequest Irp %08p\n", resetSrbAddr, FdoAddr, origRequestIrpAddr);
                found = TRUE;
            }
        }
        
    }

    return found;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\atapi\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

// #define KDEXTMODE // BUGBUG ?


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <scsi.h>
#include <srb.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension) CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#undef ASSERT
#undef ASSERTMSG
#if DBG
    #define ASSERT( exp ) if (!(exp)){ RtlAssert( #exp, __FILE__, __LINE__, NULL ); }
    #define ASSERTMSG( msg, exp ) if (!(exp)){ RtlAssert( #exp, __FILE__, __LINE__, msg ); }
#else
    #define ASSERT( exp )
    #define ASSERTMSG( msg, exp )
#endif 


#define PCI_SLOT_NUMBER ULONG



#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "ntdddisk.h"
#include "ntddscsi.h"
#include "ntddstor.h"

#include "wmistr.h"

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

#define BAD_VALUE  (ULONG64)-1

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

extern FLAG_NAME SrbFlags[];
extern FLAG_NAME LuFlags[];
extern FLAG_NAME PortFlags[];
extern FLAG_NAME DevFlags[];

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

ULONG64 GetULONGField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
USHORT GetUSHORTField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
UCHAR GetUCHARField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
ULONG64 GetFieldAddr(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
ULONG64 GetContainingRecord(ULONG64 FieldAddr, LPCSTR StructType, LPCSTR FieldName);
ULONG DumpObjListQueue(ULONG Depth, PCHAR Title, PCHAR StructName, PCHAR ListEntryFieldName, ULONG64 ListHeadAddr);
ULONG DumpIrpQueue(ULONG Depth, PCHAR Title, ULONG64 ListHeadAddr);
ULONG DumpIrpDeviceQueue(ULONG Depth, PCHAR Title, ULONG64 ListHeadAddr);
BOOLEAN FindObjInListQueue(ULONG64 ListHeadAddr, ULONG64 SpecificObjAddr, PCHAR StructName, PCHAR ListEntryFieldName);
BOOLEAN FindIrpInQueue(ULONG64 ListHeadAddr, ULONG64 IrpAddr);
BOOLEAN FindIrpInDeviceQueue(ULONG64 ListHeadAddr, ULONG64 IrpAddr);
BOOLEAN IsAtapiPdo(ULONG64 DevObjAddr);
BOOLEAN IsAtapiFdo(ULONG64 DevObjAddr);
BOOLEAN FindIrpInPdo(ULONG Depth, ULONG64 PdoAddr, ULONG64 IrpAddr, BOOLEAN SearchParent);
BOOLEAN FindIrpInFdo(ULONG Depth, ULONG64 FdoAddr, ULONG64 IrpAddr);



extern WINDBG_EXTENSION_APIS ExtensionApis;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\atapi\crash.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

	crash.cpp
	
Abstract:

	Debugger extension to debug triage dump file.

Author:

	Matthew D Hendel (math) 15-April-2002

--*/

#include "pch.h"
#include <dbgeng.h>

#include <initguid.h>
#include <idedump.h>

typedef struct _ATAPI_DUMP_RECORD {
	ULONG Count;
	ATAPI_DUMP_PDO_INFO PdoRecords[4];
} ATAPI_DUMP_RECORD, *PATAPI_DUMP_RECORD;


NTSTATUS
GetAtapiDumpRecord(
	IN IDebugDataSpaces3* DataSpaces,
	OUT PATAPI_DUMP_RECORD DumpRecord
	)
/*++

Routine Description:

	Get the ATAPI dump record structure from the dump file.

Arguments:

	DebugSpaces - Supplies IDebugDataSpaces2 interface.

	DumpRecord - Supplies pointer to the dump record buffer that will be
		filled in by the client.

Return Value:

    NTSTATUS code

--*/
{
	HRESULT Hr;
	ULONG Count;

	if (DataSpaces == NULL) {
		return E_INVALIDARG;
	}

	RtlZeroMemory (DumpRecord->PdoRecords, sizeof (ATAPI_DUMP_PDO_INFO) * 4);

	
	Hr = DataSpaces->ReadTagged ((LPGUID)&ATAPI_DUMP_ID,
								 0,
								 DumpRecord->PdoRecords,
								 sizeof (ATAPI_DUMP_PDO_INFO) * 4,
								 NULL);


	if (Hr != S_OK) {
		return Hr;
	}
	
	//
	// Count the entries in the crash record.
	//
	
	Count = 0;
	while (DumpRecord->PdoRecords[Count].Version == ATAPI_DUMP_RECORD_VERSION) {
		Count++;
	}

	if (Count == 0) {
		return E_FAIL;
	}

	DumpRecord->Count = Count;

	return S_OK;
}

	

extern IDebugDataSpaces3* DebugDataSpaces;

DECLARE_API (test)
{
	ATAPI_DUMP_RECORD DumpRecord;

	GetAtapiDumpRecord (DebugDataSpaces, &DumpRecord);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\classsym\classpnp.c ===
#include "ntddk.h"
#include <classpnp.h> 
#include "classp.h" 
#include "cdrom.h"

//Class-Driver Data Structures

MEDIA_CHANGE_DETECTION_INFO    MediaChange;
FUNCTIONAL_DEVICE_EXTENSION    FunctionalDeviceExtension;
PHYSICAL_DEVICE_EXTENSION      PhysicalDeviceExtension; 
COMMON_DEVICE_EXTENSION	       CommonDeviceExtension;
CLASS_PRIVATE_FDO_DATA         ClassPrivateFdoData;
TRANSFER_PACKET                TransferPacket;
MEDIA_CHANGE_DETECTION_INFO    ChangeDetectionInfo;
DISK_GEOMETRY                  DiskGeometry;
SCSI_REQUEST_BLOCK             Srb;
CDB                            Cdb;
CLASS_ERROR_LOG_DATA           ClassErrorLogData;
STORAGE_DEVICE_DESCRIPTOR      StorageDeviceDescriptor;
SENSE_DATA                     SenseData;

int __cdecl main() { 
    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\atapi\util.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 2001

Module Name:

    util.c

Abstract:

    Utility library used for the various debugger extensions in this library.

Author:

    Peter Wieland (peterwie) 16-Oct-1995
    ervinp
    
Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
#include "ideport.h"

PUCHAR devicePowerStateNames[] = {
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum",
    "Invalid"
};

FLAG_NAME SrbFlags[] = {
    FLAG_NAME(SRB_FLAGS_QUEUE_ACTION_ENABLE),
    FLAG_NAME(SRB_FLAGS_DISABLE_DISCONNECT),
    FLAG_NAME(SRB_FLAGS_DISABLE_SYNCH_TRANSFER),
    FLAG_NAME(SRB_FLAGS_BYPASS_FROZEN_QUEUE),
    FLAG_NAME(SRB_FLAGS_DISABLE_AUTOSENSE),
    FLAG_NAME(SRB_FLAGS_DATA_IN),
    FLAG_NAME(SRB_FLAGS_DATA_OUT),
    FLAG_NAME(SRB_FLAGS_NO_DATA_TRANSFER),
    FLAG_NAME(SRB_FLAGS_UNSPECIFIED_DIRECTION),
    FLAG_NAME(SRB_FLAGS_NO_QUEUE_FREEZE),
    FLAG_NAME(SRB_FLAGS_ADAPTER_CACHE_ENABLE),
    FLAG_NAME(SRB_FLAGS_IS_ACTIVE),
    FLAG_NAME(SRB_FLAGS_ALLOCATED_FROM_ZONE),
    FLAG_NAME(SRB_FLAGS_SGLIST_FROM_POOL),
    FLAG_NAME(SRB_FLAGS_BYPASS_LOCKED_QUEUE),
    FLAG_NAME(SRB_FLAGS_NO_KEEP_AWAKE),
    {0,0}
};

FLAG_NAME LuFlags[] = {
   FLAG_NAME(PD_QUEUE_FROZEN),
   FLAG_NAME(PD_LOGICAL_UNIT_IS_ACTIVE),
   FLAG_NAME(PD_NEED_REQUEST_SENSE),
   FLAG_NAME(PD_LOGICAL_UNIT_IS_BUSY),
   FLAG_NAME(PD_QUEUE_IS_FULL),
   FLAG_NAME(PD_RESCAN_ACTIVE),
   {0, 0}
};

FLAG_NAME PortFlags[] = {
   FLAG_NAME(PD_DEVICE_IS_BUSY),
   FLAG_NAME(PD_NOTIFICATION_REQUIRED),
   FLAG_NAME(PD_READY_FOR_NEXT_REQUEST),
   FLAG_NAME(PD_FLUSH_ADAPTER_BUFFERS),
   FLAG_NAME(PD_MAP_TRANSFER),
   FLAG_NAME(PD_LOG_ERROR),
   FLAG_NAME(PD_RESET_HOLD),
   FLAG_NAME(PD_HELD_REQUEST),
   FLAG_NAME(PD_RESET_REPORTED),
   FLAG_NAME(PD_PENDING_DEVICE_REQUEST),
   FLAG_NAME(PD_DISCONNECT_RUNNING),
   FLAG_NAME(PD_DISABLE_CALL_REQUEST),
   FLAG_NAME(PD_DISABLE_INTERRUPTS),
   FLAG_NAME(PD_ENABLE_CALL_REQUEST),
   FLAG_NAME(PD_TIMER_CALL_REQUEST),
   FLAG_NAME(PD_ALL_DEVICE_MISSING),
   FLAG_NAME(PD_RESET_REQUEST),
   {0,0}
};

FLAG_NAME DevFlags[] = {
   FLAG_NAME(DFLAGS_DEVICE_PRESENT),
   FLAG_NAME(DFLAGS_ATAPI_DEVICE),
   FLAG_NAME(DFLAGS_TAPE_DEVICE),
   FLAG_NAME(DFLAGS_INT_DRQ),
   FLAG_NAME(DFLAGS_REMOVABLE_DRIVE),
   FLAG_NAME(DFLAGS_MEDIA_STATUS_ENABLED),
   FLAG_NAME(DFLAGS_USE_DMA),
   FLAG_NAME(DFLAGS_LBA),
   FLAG_NAME(DFLAGS_MULTI_LUN_INITED),
   FLAG_NAME(DFLAGS_MSN_SUPPORT),
   FLAG_NAME(DFLAGS_AUTO_EJECT_ZIP),
   FLAG_NAME(DFLAGS_WD_MODE),
   FLAG_NAME(DFLAGS_LS120_FORMAT),
   FLAG_NAME(DFLAGS_USE_UDMA),
   FLAG_NAME(DFLAGS_IDENTIFY_VALID),
   FLAG_NAME(DFLAGS_IDENTIFY_INVALID),
   FLAG_NAME(DFLAGS_RDP_SET),
   FLAG_NAME(DFLAGS_SONY_MEMORYSTICK), 
   FLAG_NAME(DFLAGS_48BIT_LBA), 
   {0,0}
};

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    )

{
    if(State > PowerDeviceMaximum) {
        return "Invalid";
    } else {
        return devicePowerStateNames[(UCHAR) State];
    }
}


/*
 *  xdprintf
 *
 *      Prints formatted text with leading spaces.
 *
 *      WARNING:  DOES NOT HANDLE ULONG64 PROPERLY.
 */
VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    ULONG i;
    CCHAR DebugBuffer[256] = {0};

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(ap, S);

    _vsnprintf(DebugBuffer, sizeof(DebugBuffer)-1, S, ap);

    dprintf (DebugBuffer);

    va_end(ap);
}

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;
    UCHAR prolog[64] = {0};

    _snprintf(prolog, sizeof(prolog)-1, "%s (0x%08x): ", Name, Flags);

    xdprintf(Depth, "%s", prolog);

    if(Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}


/*
 *  GetULONGField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
ULONG64 GetULONGField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(ULONG64), &result);
    if (dbgStat != 0){
        dprintf("\n GetULONGField: GetFieldData failed with %xh retrieving field '%s' of struct '%s' @ %08p, returning bogus field value %08xh.\n", 
                    dbgStat, FieldName, StructType, StructAddr, BAD_VALUE);
        result = BAD_VALUE;
    }

    return result;
}


/*
 *  GetUSHORTField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
USHORT GetUSHORTField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    USHORT result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(USHORT), &result);
    if (dbgStat != 0){
        dprintf("\n GetUSHORTField: GetFieldData failed with %xh retrieving field '%s' of struct '%s' @ %08p, returning bogus field value %08xh.\n", 
                    dbgStat, FieldName, StructType, StructAddr, BAD_VALUE);
        result = (USHORT)BAD_VALUE;
    }

    return result;
}


/*
 *  GetUCHARField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
UCHAR GetUCHARField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    UCHAR result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(UCHAR), &result);
    if (dbgStat != 0){
        dprintf("\n GetUCHARField: GetFieldData failed with %xh retrieving field '%s' of struct '%s' @ %08p, returning bogus field value %08xh.\n", 
                    dbgStat, FieldName, StructType, StructAddr, BAD_VALUE);
        result = (UCHAR)BAD_VALUE;
    }

    return result;
}

ULONG64 GetFieldAddr(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG offset;
    ULONG dbgStat;

    dbgStat = GetFieldOffset(StructType, FieldName, &offset);
    if (dbgStat == 0){
        result = StructAddr+offset;
    }
    else {
        dprintf("\n GetFieldAddr: GetFieldOffset failed with %xh retrieving offset of struct '%s' (@ %08p) field '%s'.\n", 
                    dbgStat, StructType, StructAddr, FieldName);
        result = BAD_VALUE;
    }
    
    return result;
}


ULONG64 GetContainingRecord(ULONG64 FieldAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG offset;
    ULONG dbgStat;
    
    dbgStat = GetFieldOffset(StructType, FieldName, &offset);
    if (dbgStat == 0){
        result = FieldAddr-offset;
    }
    else {
        dprintf("\n GetContainingRecord: GetFieldOffset failed with %xh retrieving offset of struct '%s' field '%s', returning bogus address %08xh.\n", dbgStat, StructType, FieldName, BAD_VALUE);
        result = BAD_VALUE;
    }

    return result;
}


/*
 *  DumpObjListQueue
 *
 *      Dump a list of objects queued by LIST_ENTRY's.
 *      Returns length of list.
 */
ULONG DumpObjListQueue(ULONG Depth, PCHAR Title, PCHAR StructName, PCHAR ListEntryFieldName, ULONG64 ListHeadAddr)
{
    ULONG64 listEntryAddr;
    ULONG numObjs= 0;

    if (Title){
        xdprintf(Depth, ""), dprintf("%s:\n", Title);
    }
    
    listEntryAddr = GetULONGField(ListHeadAddr, "nt!_LIST_ENTRY", "Flink");
    while ((listEntryAddr != ListHeadAddr) && (listEntryAddr != BAD_VALUE)){
        ULONG64 objAddr;

        objAddr = GetContainingRecord(listEntryAddr, StructName, ListEntryFieldName);
        if (objAddr == BAD_VALUE){
            break;
        }
        else {
            /*
             *  Dump this irp
             */
            xdprintf(Depth+1, ""), dprintf("%08p\n", objAddr);
            
            /*
             *  Go to the next irp
             */
            numObjs++;
            listEntryAddr = GetULONGField(listEntryAddr, "nt!_LIST_ENTRY", "Flink");                
        }

    }

    dprintf("\n");
    return numObjs;
}


/*
 *  DumpIrpQueue
 *
 *      Dump Irp queue linked by Irp->Tail.Overlay.ListEntry
 */
ULONG DumpIrpQueue(ULONG Depth, PCHAR Title, ULONG64 ListHeadAddr)
{
    return DumpObjListQueue(Depth, Title, "nt!_IRP", "Tail.Overlay.ListEntry", ListHeadAddr);
}


/*
 *  DumpIrpDeviceQueue
 *
 *      Dump Irp queue linked by Irp->Tail.Overlay.DeviceQueueEntry
 */
ULONG DumpIrpDeviceQueue(ULONG Depth, PCHAR Title, ULONG64 ListHeadAddr)
{
    return DumpObjListQueue(Depth, Title, "nt!_IRP", "Tail.Overlay.DeviceQueueEntry", ListHeadAddr);
}


/*
 *  FindObjInListQueue
 *
 *      Searches a list of objects queued by LIST_ENTRY's.
 *      Returns TRUE iff the given object is found.
 */
BOOLEAN FindObjInListQueue(ULONG64 ListHeadAddr, ULONG64 SpecificObjAddr, PCHAR StructName, PCHAR ListEntryFieldName)
{
    ULONG64 listEntryAddr;
    BOOLEAN found = FALSE;
    
    listEntryAddr = GetULONGField(ListHeadAddr, "nt!_LIST_ENTRY", "Flink");
    while ((listEntryAddr != ListHeadAddr) && (listEntryAddr != BAD_VALUE)){
        ULONG64 objAddr = GetContainingRecord(listEntryAddr, StructName, ListEntryFieldName);
        if (objAddr == BAD_VALUE){
            break;
        }
        else if (objAddr == SpecificObjAddr){
            found = TRUE;
            break;
        }
        else {
            listEntryAddr = GetULONGField(listEntryAddr, "nt!_LIST_ENTRY", "Flink");                
        }
    }

    return found;
}


/*
 *  FindIrpInQueue
 *
 *      Find Irp in Irp queue linked by Irp->Tail.Overlay.ListEntry
 */
BOOLEAN FindIrpInQueue(ULONG64 ListHeadAddr, ULONG64 IrpAddr)
{
    return FindObjInListQueue(ListHeadAddr, IrpAddr, "nt!_IRP", "Tail.Overlay.ListEntry");
}

/*
 *  FindIrpInDeviceQueue
 *
 *      Find Irp in Irp queue linked by Irp->Tail.Overlay.DeviceQueueEntry
 */
BOOLEAN FindIrpInDeviceQueue(ULONG64 ListHeadAddr, ULONG64 IrpAddr)
{
    return FindObjInListQueue(ListHeadAddr, IrpAddr, "nt!_IRP", "Tail.Overlay.DeviceQueueEntry");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\atapi\help.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    help.c

Abstract:

    i386kd Extension Api for interpretting ATAPI structures

Author:

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

typedef struct {
        char *extname;
        char *extdesc;
} exthelp;

exthelp extensions[] =  {
    {"help",        "displays this message"},
    {"fdoext",      "dumps the specified FDO extension"},
    {"pdoext",      "dumps the specified PDO extension"},
    {"miniext",     "dumps the specified miniport extension"},
    {"findirp",     "helps find irp queued in atapi"},
    {NULL,          NULL}
};

DECLARE_API( help )
{
        int i = 0;

        dprintf("\nATAPI Debugger Extension\n");
        while(extensions[i].extname != NULL)    {
                dprintf("\t%s - \t%s\n", extensions[i].extname, extensions[i].extdesc);
                i++;
        }
    dprintf("\n");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\atapi\kdext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

#include "pch.h"

#include <ntverp.h>

//
// Globals
//

EXT_API_VERSION ApiVersion = {
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER,
    0
};

WINDBG_EXTENSION_APIS  ExtensionApis;

IDebugDataSpaces3* DebugDataSpaces;

//
// Routines
//

#if 0
DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
#endif

EXTERN_C
HRESULT
CALLBACK
DebugExtensionInitialize(
    PULONG Version,
    PULONG Flags
    )
{
    HRESULT Hr;
    IDebugClient* DebugClient;
    IDebugControl* DebugControl;

    *Version = DEBUG_EXTENSION_VERSION (1, 0);
    *Flags = 0;


    Hr = DebugCreate (__uuidof(IDebugClient),
                      (PVOID*)&DebugClient);

    if (Hr != S_OK) {
        return Hr;
    }
    
    Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                     (PVOID*)&DebugControl);

    if (Hr != S_OK) {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    
    Hr = DebugControl->GetWindbgExtensionApis64 (&ExtensionApis);

    if (Hr != S_OK) {
        return Hr;
    }

    Hr = DebugClient->QueryInterface (__uuidof (IDebugDataSpaces3),
                                      (PVOID*) &DebugDataSpaces);

    DebugControl->Release();
    DebugClient->Release();

    return S_OK;
}


EXTERN_C
HRESULT
CALLBACK
DebugExtensionUninitialize(
    )
{
    if (DebugDataSpaces != NULL) {
        DebugDataSpaces->Release();
        DebugDataSpaces = NULL;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\inc\rbc.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    rbc.h

Abstract:

    These are the structures and defines used in the Reduced Block Command set

Authors:

    George Chrysanthakopoulos(georgioc) - April 1998

Revision History:

    Dan Knudson (DanKn), 23 Sep 1999 - updated per rev 10 of RBC spec

--*/
#ifndef _NTRBC_
#define _NTRBC_

#include "scsi.h"

//
// Command Descriptor Block. encapsulated under the bus/protocol specific request block
//

typedef union _CDB_RBC {

    //
    // format unit
    //
    
    struct _FORMAT_RBC {
        UCHAR OperationCode;
        UCHAR VendorSpecific;
        UCHAR Increment : 1;
        UCHAR Percent_Time : 1;
        UCHAR Reserved1 : 1;
        UCHAR VendorSpecific1 : 5;
        UCHAR Reserved2[2];
        UCHAR Control;
    } FORMAT_RBC, *PFORMAT_RBC;
    
    //
    // prevent/allow medium removal
    //

    struct _MEDIA_REMOVAL_RBC {
        UCHAR OperationCode;
        UCHAR Reserved[3];

        UCHAR Prevent : 1;
        UCHAR Persistant : 1;
        UCHAR Reserved3 : 6;

        UCHAR Control;
    } MEDIA_REMOVAL_RBC, *PMEDIA_REMOVAL_RBC;

    //
    // START_STOP_UNIT
    //

    struct _START_STOP_RBC {
        UCHAR OperationCode;
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 7;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 2;
        UCHAR PowerConditions : 4;
        UCHAR Control;
    } START_STOP_RBC, *PSTART_STOP_RBC;

    struct _SYNCHRONIZE_CACHE_RBC {

        UCHAR OperationCode;    // 0x35
        UCHAR Reserved[8];
        UCHAR Control;

    } SYNCHRONIZE_CACHE_RBC, *PSYNCHRONIZE_CACHE_RBC;


} CDB_RBC, *PCDB_RBC;


//
// START_STOP_UNIT Power Condition descriptions
//

#define START_STOP_RBC_POWER_CND_NO_CHANGE      0
#define START_STOP_RBC_POWER_CND_ACTIVE         1
#define START_STOP_RBC_POWER_CND_IDLE           2
#define START_STOP_RBC_POWER_CND_STANDBY        3
#define START_STOP_RBC_POWER_CND_SLEEP          5
#define START_STOP_RBC_POWER_CND_DEVICE_CTRL    7


//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_RBC_DEVICE_PARAMETERS 0x06


//
// DeviceType field in inquiry Data
//

#define RBC_DEVICE             0x0E

//
// Define Device Capabilities page.
//

typedef struct _MODE_RBC_DEVICE_PARAMETERS_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR WriteCacheDisable : 1;
    UCHAR Reserved1 : 7;
    UCHAR LogicalBlockSize[2];
    UCHAR NumberOfLogicalBlocks[5];
    UCHAR PowerPerformance;
    UCHAR LockDisabled : 1;
    UCHAR FormatDisabled : 1;
    UCHAR WriteDisabled : 1;
    UCHAR ReadDisabled : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;

}MODE_RBC_DEVICE_PARAMETERS_PAGE, *PMODE_RBC_DEVICE_PARAMETERS_PAGE;

typedef struct _MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE {

    MODE_PARAMETER_HEADER Header;
    MODE_RBC_DEVICE_PARAMETERS_PAGE Page;

}MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE,
    *PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE;


//
// unsolicited status sense code qualifier values
//

#define RBC_UNSOLICITED_STATUS              0x02
#define RBC_UNSOLICITED_SENSE_KEY           0x06

#define RBC_UNSOLICITED_SC_PWR_STATE_CHNG   0xFF
#define RBC_UNSOLICITED_SC_EVENT_STATUS     0xFE

#define RBC_UNSOLICITED_CLASS_ASQ_DEVICE    0x06
#define RBC_UNSOLICITED_CLASS_ASQ_MEDIA     0x04
#define RBC_UNSOLICITED_CLASS_ASQ_POWER     0x02




//
// Translation routine used to convert SCSI requests that differ from RBC
//

NTSTATUS
Rbc_Scsi_Conversion(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSCSI_REQUEST_BLOCK *OriginalSrb,
    IN PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE RbcHeaderAndPage,
    IN BOOLEAN OutgoingRequest,
    IN BOOLEAN RemovableMedia
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\minisym\makefile.inc ===
$(O)\minipkd.c : scsi.c
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\classsym\makefile.inc ===
$(O)\classpnp.c : classpnp.c
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\minipkd\util.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    util.c

Abstract:

    Utility library used for the various debugger extensions in this library.

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

PUCHAR devicePowerStateNames[] = {
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum",
    "Invalid"
};

FLAG_NAME SrbFlagsMap[] = {
    FLAG_NAME(SRB_FLAGS_QUEUE_ACTION_ENABLE),
    FLAG_NAME(SRB_FLAGS_DISABLE_DISCONNECT),
    FLAG_NAME(SRB_FLAGS_DISABLE_SYNCH_TRANSFER),
    FLAG_NAME(SRB_FLAGS_BYPASS_FROZEN_QUEUE),
    FLAG_NAME(SRB_FLAGS_DISABLE_AUTOSENSE),
    FLAG_NAME(SRB_FLAGS_DATA_IN),
    FLAG_NAME(SRB_FLAGS_DATA_OUT),
    FLAG_NAME(SRB_FLAGS_NO_QUEUE_FREEZE),
    FLAG_NAME(SRB_FLAGS_ADAPTER_CACHE_ENABLE),
    FLAG_NAME(SRB_FLAGS_IS_ACTIVE),
    FLAG_NAME(SRB_FLAGS_ALLOCATED_FROM_ZONE),
    FLAG_NAME(SRB_FLAGS_SGLIST_FROM_POOL),
    FLAG_NAME(SRB_FLAGS_BYPASS_LOCKED_QUEUE),
    FLAG_NAME(SRB_FLAGS_NO_KEEP_AWAKE),
    FLAG_NAME(SRB_FLAGS_PORT_DRIVER_ALLOCSENSE),
    FLAG_NAME(SRB_FLAGS_PORT_DRIVER_SENSEHASPORT),
    FLAG_NAME(SRB_FLAGS_DONT_START_NEXT_PACKET),
    FLAG_NAME(SRB_FLAGS_PORT_DRIVER_RESERVED),
    FLAG_NAME(SRB_FLAGS_CLASS_DRIVER_RESERVED),
    {0,0}
};



PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    )

{
    if(State > PowerDeviceMaximum) {
        return "Invalid";
    } else {
        return devicePowerStateNames[(UCHAR) State];
    }
}

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    ULONG i;
    CCHAR DebugBuffer[256] = {0};

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(ap, S);

    _vsnprintf(DebugBuffer, sizeof(DebugBuffer)-1, S, ap);

    dprintf (DebugBuffer);

    va_end(ap);
}

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;
    UCHAR prolog[64] = {0};

    _snprintf(prolog, sizeof(prolog)-1, "%s (0x%08x): ", Name, Flags);

    xdprintfEx(Depth, ("%s", prolog));

    if(Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    dprintf("\n");
                    xdprintfEx(Depth, ("%s", prolog));
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if((Flags & (~mask)) != 0) {
        xdprintfEx(Depth, ("%sUnknown flags %#010lx\n", prolog, (Flags & (~mask))));
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\minipkd\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <scsi.h>
#include <srb.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define MINIPKD_PRINT_ERROR(r)\
    dprintf("minipkd error (%x): %s @ line %d\n", (r), __FILE__, __LINE__);

#define RECUR  DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY   DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS
#define ADDROF DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

extern WINDBG_EXTENSION_APIS64 ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "wmistr.h"

#ifdef __cplusplus
extern "C" {
#endif

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

__inline 
VOID
xdindent(
    ULONG Depth
    )
{
    ULONG i;
    for (i=0; i<Depth; i++)
        dprintf("  ");
}

#define xdprintfEx(d, expr)\
    xdindent((d));\
    dprintf expr

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

extern FLAG_NAME SrbFlagsMap[];

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\minipkd\minipkd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       minipkd.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\minipkd\help.c ===
//depot/Lab01_N/drivers/storage/kdext/minipkd/help.c#2 - edit change 1877 (text)
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    help.c

Abstract:

    SCSI Miniport debugger extension

Author:

    John Strange (JohnStra) 12-April-2000

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

typedef struct {
        char *extname;
        char *extdesc;
} exthelp;

exthelp extensions[] =  {
    {"help",                    "displays this message"},
    {"adapters",                "dumps all the HBAs"},
    {"adapter <adapter>",       "dumps the specified Adapter Extension"},
    {"exports <adapter>",       "dumps the miniport exports for the given adapter"},
    {"lun <lun>",               "dumps the specified Logical Unit Extension"},
    {"portconfig <portconfig>", "dumps the specified PORT_CONFIGURATION_INFORMATION"},
    {"srb <srb>",               "dumps the specified SCSI_REQUEST_BLOCK"},
    {NULL, NULL}};

DECLARE_API (help)
{
        int i = 0;

        dprintf("\nSCSI Miniport Debugger Extension\n");
        while(extensions[i].extname != NULL)    {
                dprintf("%-25s - \t%s\n",
                        extensions[i].extname,
                        extensions[i].extdesc);
                i++;
        }
        dprintf("\n");
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\minipkd\kdext.cpp ===
//depot/Lab01_N/drivers/storage/kdext/minipkd/kdext.cpp#1 - add change 1876 (text)
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>

//
// globals
//

WINDBG_EXTENSION_APIS  ExtensionApis;


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}



extern "C" HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
//    g_ExcepCallbacks.Uninitialize();
//    g_FnProfCallbacks.Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\minipkd\minipkd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    minipkd.c

Abstract:

    SCSI miniport debugger dxtension api

Author:

    John Strange (johnstra) 7-Apr-2000
        (Adapted from PeterWie's scsikd)

Environment:

    User Mode

Revision History:

--*/

#include "pch.h"
#include "port.h"

FLAG_NAME LuFlags[] = {
    FLAG_NAME(LU_QUEUE_FROZEN),             // 0001
    FLAG_NAME(LU_LOGICAL_UNIT_IS_ACTIVE),   // 0002
    FLAG_NAME(LU_NEED_REQUEST_SENSE),       // 0004
    FLAG_NAME(LU_LOGICAL_UNIT_IS_BUSY),     // 0008
    FLAG_NAME(LU_QUEUE_IS_FULL),            // 0010
    FLAG_NAME(LU_PENDING_LU_REQUEST),       // 0020
    FLAG_NAME(LU_QUEUE_LOCKED),             // 0040
    FLAG_NAME(LU_QUEUE_PAUSED),             // 0080
    {0,0}
};

FLAG_NAME AdapterFlags[] = {
    FLAG_NAME(PD_DEVICE_IS_BUSY),            // 0X00001
    FLAG_NAME(PD_NOTIFICATION_REQUIRED),     // 0X00004
    FLAG_NAME(PD_READY_FOR_NEXT_REQUEST),    // 0X00008
    FLAG_NAME(PD_FLUSH_ADAPTER_BUFFERS),     // 0X00010
    FLAG_NAME(PD_MAP_TRANSFER),              // 0X00020
    FLAG_NAME(PD_LOG_ERROR),                 // 0X00040
    FLAG_NAME(PD_RESET_HOLD),                // 0X00080
    FLAG_NAME(PD_HELD_REQUEST),              // 0X00100
    FLAG_NAME(PD_RESET_REPORTED),            // 0X00200
    FLAG_NAME(PD_PENDING_DEVICE_REQUEST),    // 0X00800
    FLAG_NAME(PD_DISCONNECT_RUNNING),        // 0X01000
    FLAG_NAME(PD_DISABLE_CALL_REQUEST),      // 0X02000
    FLAG_NAME(PD_DISABLE_INTERRUPTS),        // 0X04000
    FLAG_NAME(PD_ENABLE_CALL_REQUEST),       // 0X08000
    FLAG_NAME(PD_TIMER_CALL_REQUEST),        // 0X10000
    FLAG_NAME(PD_WMI_REQUEST),               // 0X20000
    {0,0}
};

char *MiniInterruptMode[] = {
    "LevelSensitive",
    "Latched"
};

char *MiniInterfaceTypes[] = {
    "Internal",
    "Isa",
    "Eisa",
    "MicroChannel",
    "TurboChannel",
    "PCIBus",
    "VMEBus",
    "NuBus",
    "PCMCIABus",
    "CBus",
    "MPIBus",
    "MPSABus",
    "ProcessorInternal",
    "InternalPowerBus",
    "PNPISABus",
    "PNPBus"
};

char *MiniDmaWidths[] = {
    "Width8Bits",
    "Width16Bits",
    "Width32Bits"
};

char *MiniDmaSpeed[] = {
    "Compatible",
    "TypeA",
    "TypeB",
    "TypeC",
    "TypeF"
};

#define MINIKD_MAX_SCSI_FUNCTION 26
char *MiniScsiFunction[] = {
   "SRB_FUNCTION_EXECUTE_SCSI",       // 0x00
   "SRB_FUNCTION_CLAIM_DEVICE",       // 0x01
   "SRB_FUNCTION_IO_CONTROL",         // 0x02
   "SRB_FUNCTION_RECEIVE_EVENT",      // 0x03
   "SRB_FUNCTION_RELEASE_QUEUE",      // 0x04
   "SRB_FUNCTION_ATTACH_DEVICE",      // 0x05
   "SRB_FUNCTION_RELEASE_DEVICE",     // 0x06
   "SRB_FUNCTION_SHUTDOWN",           // 0x07
   "SRB_FUNCTION_FLUSH",              // 0x08
   "***",                             // 0x09
   "***",                             // 0x0a
   "***",                             // 0x0b
   "***",                             // 0x0c
   "***",                             // 0x0d
   "***",                             // 0x0e
   "***",                             // 0x0f
   "SRB_FUNCTION_ABORT_COMMAND",      // 0x10
   "SRB_FUNCTION_RELEASE_RECOVERY",   // 0x11
   "SRB_FUNCTION_RESET_BUS",          // 0x12
   "SRB_FUNCTION_RESET_DEVICE",       // 0x13
   "SRB_FUNCTION_TERMINATE_IO",       // 0x14
   "SRB_FUNCTION_FLUSH_QUEUE",        // 0x15
   "SRB_FUNCTION_REMOVE_DEVICE",      // 0x16
   "SRB_FUNCTION_WMI",                // 0x17
   "SRB_FUNCTION_LOCK_QUEUE",         // 0x18
   "SRB_FUNCTION_UNLOCK_QUEUE"        // 0x19
};

#define MINIKD_MAX_SRB_STATUS 49
char *MiniScsiSrbStatus[] = {
   "SRB_STATUS_PENDING",                // 0x00
   "SRB_STATUS_SUCCESS",                // 0x01
   "SRB_STATUS_ABORTED",                // 0x02
   "SRB_STATUS_ABORT_FAILED",           // 0x03
   "SRB_STATUS_ERROR",                  // 0x04
   "SRB_STATUS_BUSY",                   // 0x05
   "SRB_STATUS_INVALID_REQUEST",        // 0x06
   "SRB_STATUS_INVALID_PATH_ID",        // 0x07
   "SRB_STATUS_NO_DEVICE",              // 0x08
   "SRB_STATUS_TIMEOUT",                // 0x09
   "SRB_STATUS_SELECTION_TIMEOUT",      // 0x0a
   "SRB_STATUS_COMMAND_TIMEOUT",        // 0x0b
   "***",                               // 0x0c
   "SRB_STATUS_MESSAGE_REJECTED",       // 0x0d
   "SRB_STATUS_BUS_RESET",              // 0x0e
   "SRB_STATUS_STATUS_PARITY_ERROR",    // 0x0f
   "SRB_STATUS_REQUEST_SENSE_FAILED",   // 0x10
   "SRB_STATUS_NO_HBA",                 // 0x11
   "SRB_STATUS_DATA_OVERRUN",           // 0x12
   "SRB_STATUS_UNEXPECTED_BUS_FREE",    // 0x13
   "SRB_STATUS_PHASE_SEQUENCE_FAILURE", // 0x14
   "SRB_STATUS_BAD_SRB_BLOCK_LENGTH",   // 0x15
   "SRB_STATUS_REQUEST_FLUSHED",        // 0x16
   "***",                               // 0x17
   "***",                               // 0x18
   "***",                               // 0x19
   "***",                               // 0x1a
   "***",                               // 0x1b
   "***",                               // 0x1c
   "***",                               // 0x1d
   "***",                               // 0x1e
   "***",                               // 0x1f
   "SRB_STATUS_INVALID_LUN",            // 0x20
   "SRB_STATUS_INVALID_TARGET_ID",      // 0x21
   "SRB_STATUS_BAD_FUNCTION",           // 0x22
   "SRB_STATUS_ERROR_RECOVERY",         // 0x23
   "SRB_STATUS_NOT_POWERED",            // 0x24
   "***",                               // 0x25
   "***",                               // 0x26
   "***",                               // 0x27
   "***",                               // 0x28
   "***",                               // 0x29
   "***",                               // 0x2a
   "***",                               // 0x2b
   "***",                               // 0x2c
   "***",                               // 0x2d
   "***",                               // 0x2e
   "***",                               // 0x2f
   "SRB_STATUS_INTERNAL_ERROR"          // 0x30
};

#define DumpUcharField(name, value, depth) \
    xdprintfEx((depth), ("%s: 0x%02X\n", (name), (value)))

#define DumpUshortField(name, value, depth) \
    xdprintfEx((depth), ("%s: 0x%04X\n", (name), (value)))

#define DumpUlongField(name, value, depth) \
    xdprintfEx((depth), ("%s: 0x%08X\n", (name), (value)))

#define DumpPointerField(name, value, depth) \
    xdprintfEx((depth), ("%s: %08p\n", (name), (value)))

#define DumpBooleanField(name, value, depth) \
    xdprintfEx((depth), ("%s: %s\n", (name), (value) ? "YES" : "NO"))
    

typedef struct _CommonExtensionFlags {

    //
    // True if this device object is a physical device object
    //

    BOOLEAN IsPdo : 1;

    //
    // True if this device object has processed it's first start and
    // has been initialized.
    //

    BOOLEAN IsInitialized : 1;

    //
    // Has WMI been initialized for this device object?
    //

    BOOLEAN WmiInitialized : 1;

    //
    // Has the miniport associated with this FDO or PDO indicated WMI
    // support?
    //

    BOOLEAN WmiMiniPortSupport : 1;

} CommonExtensionFlags, *PCommonExtensionFlags;

VOID
MpDumpPdo(
    IN ULONG64 Address,
    IN OPTIONAL PADAPTER_EXTENSION Adapter,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
MpDumpFdoExtension(
    ULONG64 Address,
    ULONG64 DeviceObject,
    ULONG Detail,
    ULONG Depth
    );

VOID
MpDumpExtension(
    IN ULONG64 Address,
    IN ULONG64 DeviceExtension,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
MpDumpPortConfigurationInformation(
    IN ULONG64 PortConfigInfo,
    IN ULONG Depth
    );

VOID
MpDumpSrb(
    IN ULONG64 Srb,
    IN ULONG Depth
    );

VOID
MpDumpAdapters(
    IN PDEVICE_OBJECT *Adapters,
    IN ULONG Depth
    );

VOID
MpDumpActiveRequests(
    IN ULONG64 ListHead,
    IN ULONG TickCount,
    IN ULONG Depth
    );

VOID
MpDumpInterruptData(
    IN PINTERRUPT_DATA Data,
    IN PINTERRUPT_DATA RealData,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
MpDumpChildren(
    IN ULONG64 Adapter,
    IN ULONG Depth
    );

PUCHAR 
MpSecondsToString(
    ULONG Count
    );

VOID
MpDumpRequests(
    IN ULONG64 DeviceObject,
    IN ULONG TickCount,
    IN ULONG Depth
    );

VOID
MpDumpHwExports(
    IN ULONG64 Address
    );

ULONG64
MpGetOffsetOfField(
    IN PCCHAR Type,
    IN PCCHAR Field
    );

VOID
MpDumpExtReq(
    IN ULONG64 Address,
    IN ULONG TickCount
    );

VOID 
MpDumpSrb_Data(
    IN ULONG64 Request,
    IN ULONG TickCount
    );



DECLARE_API (exports)

/*++

Routine Description:

    Dumps the specified miniport's service routine pointers

Arguments:

Return Value:

    none

--*/

{
    ULONG64 address;
    ULONG64 DeviceExtension;
    ULONG64 Type;
    
    //
    // Get the address of the struct.
    //

    GetExpressionEx(args, &address, &args);

    //
    // If the supplied address points to a device, fixup the address to
    // that of the device's extension.
    //

    InitTypeRead(address, nt!_DEVICE_OBJECT);
    Type = ReadField(Type);
    DeviceExtension = address;
    
    if (Type == IO_TYPE_DEVICE) {
        DeviceExtension = ReadField(DeviceExtension);
        if (!DeviceExtension) {
            MINIPKD_PRINT_ERROR(0);
            return E_FAIL;
        }
        address = DeviceExtension;
    }

    //
    // Dump the PORT_CONFIGURATION_INFORMATION
    //

    MpDumpHwExports(address);

    return S_OK;
}

DECLARE_API (adapters)

/*++

Routine Description:

    Dumps adapter information.

Arguments:

Return Value:

    none

--*/

{
    ULONG64 address;
    ULONG result;
    CHAR NameBuffer[512] = {0};
    ULONG status;
    ULONG CurrentAdapter = 0;
    ULONG Adapters;
    ULONG64 DriverObjectAddr;
    ULONG64 DriverNameLength;
    ULONG64 DriverNameBuffer;
    ULONG64 DeviceExtension;
    ULONG64 AdapterAddr;
    ULONG RemoveStatus;
    ULONG Type;
    BOOLEAN ValidAdapter;
    ULONG64 *AdapterArr;
    ULONG i;
    

    //
    // Get the address of scsiport's global adapter list element count.
    // and read the count from the debuggee.  If we can't get the address
    // or if we can't read the count, we give up.
    //

    address = GetExpression("scsiport!ScsiGlobalAdapterListElements");
    if (address != 0) {
        Adapters = 0;
        status = ReadMemory(address, (PVOID) &Adapters, sizeof(ULONG), &result);
        if (!status) {
            MINIPKD_PRINT_ERROR(0);
            return E_FAIL;
        } else if (Adapters == 0) {
            dprintf("There are no configured SCSI adapters.\n");
            return S_OK;
        }
    } else {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    //
    // Get the address of scsiport's global adapter list and read
    // the address from the debuggee.  If we can't get the address
    // or read it, we can't continue.
    //

    address = GetExpression("scsiport!ScsiGlobalAdapterList");
    if (address) {
        status = ReadMemory(address, (PVOID) &address, sizeof(ULONG64), &result);
        if (!status) {
            MINIPKD_PRINT_ERROR(status);
            return E_FAIL;
        } else if (address == (ULONG64)-1 || address == (ULONG64)0) {
            dprintf("There are no configured SCSI adapters.\n");
            return S_OK;
        }
    } else {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    //
    // Allocate memory to hold an array of addresses.  We use the array to
    // check for duplicate device objects.
    //

    AdapterArr = malloc(sizeof(ULONG64) * Adapters);

    if(AdapterArr == NULL ) {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    //
    // Display adapter information.
    //

    while (CurrentAdapter < Adapters) {

        ValidAdapter = TRUE;

        //
        // Read the address of the device object (fdo) and update address
        // to point to the next one.  The amount by which we bump the address
        // depends on the size of a pointer on the debuggee.
        //

        ReadPtr(address, &AdapterAddr);
        address += (IsPtr64()) ? sizeof(ULONG64) : sizeof(ULONG);
        
        //
        // Save the address of the adapter.
        //

        AdapterArr[CurrentAdapter] = AdapterAddr;

        //
        // If this address is a duplicate, we don't need to display info on it
        // again.
        //

        if (CurrentAdapter > 0) {
            for (i=0; i<CurrentAdapter-1; i++) {
                if (AdapterAddr == AdapterArr[i]) {
                    ValidAdapter = FALSE;
                    goto ShowIt;
                }
            }
        }

        //
        // Read device object data.
        //
        
        if (InitTypeRead(AdapterAddr, nt!_DEVICE_OBJECT)) {
            ValidAdapter = FALSE;
            goto ShowIt;
        }

        //
        // Let's make sure this is a valid device object by checking that
        // the Type field is valid.
        //

        Type = (ULONG)ReadField(Type);
        if (Type != IO_TYPE_DEVICE) {
            ValidAdapter = FALSE;
        } else {
            //
            // The DriverObject field will be non-null for a valid device object.
            //

            DriverObjectAddr = ReadField(DriverObject);
            if (!DriverObjectAddr) {
                ValidAdapter = FALSE;
                goto ShowIt;
            }

            //
            // The DeviceExtension field should also be non-null.
            //

            DeviceExtension = ReadField(DeviceExtension);
            if (!DeviceExtension) {
                ValidAdapter = FALSE;
                goto ShowIt;
            }

            //
            // Let's do one more check to be sure we're dealing with a valid
            // device object.  If it's valid, the extension's DeviceObject
            // field will point back to the device object.
            // 

            if (InitTypeRead(DeviceExtension, scsiport!COMMON_EXTENSION)) {
                ValidAdapter = FALSE;
            } else {
                RemoveStatus = (ULONG)ReadField(IsRemoved);
                if (RemoveStatus != NO_REMOVE && RemoveStatus != REMOVE_PENDING) {
                    ValidAdapter = FALSE;
                } else {
                    
                    //
                    // Ok, we know the device object is valid.  Go ahead and
                    // get the rest of the information we need.
                    //
                    
                    InitTypeRead(DriverObjectAddr, scsiport!DRIVER_OBJECT);
                    DriverNameBuffer = ReadField(DriverName.Buffer);
                    if (!DriverNameBuffer) {
                        MINIPKD_PRINT_ERROR(0);
                        free(AdapterArr);
                        return E_FAIL;
                    }
                    
                    DriverNameLength = ReadField(DriverName.Length);
                    if (!DriverNameLength) {
                        MINIPKD_PRINT_ERROR(0);
                        free(AdapterArr);
                        return E_FAIL;
                    }

                    DriverNameLength = min(DriverNameLength, sizeof(NameBuffer)/sizeof(WCHAR)-1);
                    
                    status = ReadMemory(
                                 DriverNameBuffer,
                                 (PVOID) NameBuffer,
                                 (ULONG)DriverNameLength * sizeof(WCHAR),
                                 &result);
                    if (!status) {
                        PWCHAR NoName = L"Driver name paged out";
                        RtlMoveMemory(NameBuffer,
                                      NoName,
                                      21 * sizeof(WCHAR));
                    }                
                }
            }
        }
ShowIt:        
        //
        // Display some information about the adapter.
        //

        if (ValidAdapter) {
            dprintf("%S %-20S DO %-16p DevExt %-16p %s\n", 
                    L"Adapter",
                    NameBuffer, 
                    AdapterAddr,
                    DeviceExtension,
                    (RemoveStatus == REMOVE_PENDING) ? "REMOVE PENDING" : "");

            MpDumpChildren(DeviceExtension, 0);

        }

        //
        // Advance current adapter index.
        //

        ++CurrentAdapter;
    }

    free(AdapterArr);
    return S_OK;
}


DECLARE_API (portconfig)

/*++

Routine Description:

    Dumps supplied address as a PORT_CONFIGURATION_INFORMATION struct

Arguments:

    args - string containing the address of a 
           PORT_CONFIGURATION_INFORMATION struct
           
Return Value:

    none

--*/

{
    ULONG64 address;

    //
    // Get the address of the struct.
    //

    GetExpressionEx(args, &address, &args);

    //
    // Dump the PORT_CONFIGURATION_INFORMATION
    //

    MpDumpPortConfigurationInformation(
        address,
        0);

    return S_OK;
}


DECLARE_API (srb)

/*++

Routine Description:

    Dumps supplied address as a SCSI_REQUEST_BLOCK struct

Arguments:

    args - string containing the address of a 
           PORT_CONFIGURATION_INFORMATION struct
           
Return Value:

    none

--*/

{
    ULONG64 address;

    //
    // Get the address of the struct.
    //

    GetExpressionEx(args, &address, &args);

    //
    // Dump the PORT_CONFIGURATION_INFORMATION
    //

    MpDumpSrb(
        address,
        0);

    return S_OK;
}


DECLARE_API (adapter)

/*++

Routine Description:

    Dumps adapter information for the specified adapter.

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 Address;
    ULONG64 Type;
    ULONG64 DeviceExtension;
    ULONG detail = 0;
    UCHAR Block;
    PCommonExtensionFlags Flags = (PCommonExtensionFlags) &Block;

    //
    // Convert the argument string to an address.
    //

    GetExpressionEx(args, &Address, &args);

    //
    // If the supplied address points to a device, fixup the address to
    // that of the device's extension.
    //

    InitTypeRead(Address, nt!_DEVICE_OBJECT);
    Type = ReadField(Type);
    DeviceExtension = Address;
    
    if (Type == IO_TYPE_DEVICE) {
        DeviceExtension = ReadField(DeviceExtension);
        if (!DeviceExtension) {
            MINIPKD_PRINT_ERROR(0);
            return E_FAIL;
        }
        Address = DeviceExtension;
    }

    //
    // Make sure an ADAPTER_EXTENSION object lives at the address we have.
    //
    
    InitTypeRead(Address, scsiport!COMMON_EXTENSION);
    Block = (UCHAR)ReadField(IsPdo);
    if (Flags->IsPdo) {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    MpDumpExtension(Address,
                    DeviceExtension,
                    0,
                    0);

    return S_OK;
}


DECLARE_API (lun)

/*++

Routine Description:

    Dumps LUN extension information at the specified address.

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 Address;
    ULONG64 Type;
    ULONG64 DeviceExtension;
    ULONG detail = 0;
    UCHAR Block;
    PCommonExtensionFlags Flags = (PCommonExtensionFlags) &Block;

    //
    // Convert the argument string to an address.
    //

    GetExpressionEx(args, &Address, &args);

    //
    // If the supplied address points to a device, fixup the address to
    // that of the device's extension.
    //

    InitTypeRead(Address, nt!_DEVICE_OBJECT);
    Type = ReadField(Type);
    DeviceExtension = Address;
    
    if (Type == IO_TYPE_DEVICE) {
        DeviceExtension = ReadField(DeviceExtension);
        if (!DeviceExtension) {
            MINIPKD_PRINT_ERROR(0);
            return E_FAIL;
        }
        Address = DeviceExtension;
    }

    //
    // Make sure an LOGICAL_UNIT_EXTENSION object lives at the address we have.
    //
    
    InitTypeRead(Address, scsiport!COMMON_EXTENSION);
    Block = (UCHAR)ReadField(IsPdo);
    if (!Flags->IsPdo) {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    MpDumpExtension(Address,
                    DeviceExtension,
                    0,
                    0);
    return S_OK;
}


DECLARE_API (req)
/*++

Routine Description:

    Dumps the requests(Device Queue, Pending, Untagged, Tagged,
    Retrying, Blocked) on the adapter FDO and Lun(s)  

Arguments:

    args - string containing the address of the Adapter FDO or extension,
    or LUN(PDO) or extension.

Return Value:

    none

--*/

{
    ULONG64 Address = 0;
    ULONG64 FDOAddress;
    ULONG64 PDOAddress;
    ULONG64 Type;
    ULONG64 DeviceExtension;
    ULONG64 LunExtension=0;
    ULONG64 realLuns[8];
    ULONG64 realLun;
    ULONG i;
    ULONG64 DeviceObject=0;
    ULONG64 NextLogicalUnit=0;
    ULONG Result;
    ULONG64 RequestListFlink = 0;
    ULONG64 RequestList = 0;
    ULONG64 OffsetOfRequestList;
    ULONG TickCount = 0;
    ULONG64 SrbDataBlockedRequestsList;
    ULONG64 OffsetOfSrbDataBlockedRequests;
    ULONG64 SrbDataBlockedRequestsFlink;
    UCHAR Block;
    ULONG PathId=0;
    ULONG TargetId=0;
    ULONG Lun=0;
    PCommonExtensionFlags Flags = (PCommonExtensionFlags) &Block;

    GetExpressionEx(args, &Address, &args);
    //
    // Read the Type and DeviceExtension fields from the supplied address.
    //
    InitTypeRead(Address, nt!_DEVICE_OBJECT);
    Type = ReadField(Type);
    
    DeviceExtension = Address;
    
    if (Type == IO_TYPE_DEVICE) {
        DeviceExtension = ReadField(DeviceExtension);
        if (!DeviceExtension) {
            MINIPKD_PRINT_ERROR(0);
            return E_FAIL;
        }
        Address = DeviceExtension;
    }

    InitTypeRead(Address, scsiport!COMMON_EXTENSION);
    Block = (UCHAR)ReadField(IsPdo);
    //
    //Check if the Device extension is PDO's. If Yes, read in the 
    //FDO(Adapter) extension 
    //
    if (Flags->IsPdo) {
        LunExtension = DeviceExtension;
        InitTypeRead(Address, scsiport!_LOGICAL_UNIT_EXTENSION);
        DeviceExtension = ReadField(AdapterExtension);
     }

    InitTypeRead(DeviceExtension, scsiport!_ADAPTER_EXTENSION);
    FDOAddress = ReadField(DeviceObject);
    
    realLuns[0] = ReadField(LogicalUnitList[0].List);
    realLuns[1] = ReadField(LogicalUnitList[1].List);
    realLuns[2] = ReadField(LogicalUnitList[2].List);
    realLuns[3] = ReadField(LogicalUnitList[3].List);
    realLuns[4] = ReadField(LogicalUnitList[4].List);
    realLuns[5] = ReadField(LogicalUnitList[5].List);
    realLuns[6] = ReadField(LogicalUnitList[6].List);
    realLuns[7] = ReadField(LogicalUnitList[7].List);

    TickCount = (ULONG) ReadField(TickCount);
    SrbDataBlockedRequestsFlink = ReadField(SrbDataBlockedRequests.Flink);

    OffsetOfSrbDataBlockedRequests = 
        MpGetOffsetOfField("scsiport!_ADAPTER_EXTENSION", 
                           
                           "SrbDataBlockedRequests");
    dprintf("FDO requests: \n");
    MpDumpRequests(FDOAddress, TickCount, 0 + 2);
    
    SrbDataBlockedRequestsList = DeviceExtension + OffsetOfSrbDataBlockedRequests;
    dprintf("SrbDataBlockedRequestsList: \n");
    if (SrbDataBlockedRequestsFlink == SrbDataBlockedRequestsList) {
              xdprintfEx(2, ("Request List @"));
              dprintf("%08p is empty\n", SrbDataBlockedRequestsList);
      } else {
               xdprintfEx(1, ("Request list @"));
               dprintf("%08p:\n", SrbDataBlockedRequestsList);
               MpDumpActiveRequests(SrbDataBlockedRequestsList,
                                    TickCount,
                                    0 + 2);
         }
            

    for (i = 0; (i < NUMBER_LOGICAL_UNIT_BINS); i++) {

        realLun = (LunExtension) ? LunExtension : realLuns[i];
        
        while ((realLun != 0) && (!CheckControlC())) {
            
            Result = (ULONG) InitTypeRead(realLun, scsiport!_LOGICAL_UNIT_EXTENSION);
            if (Result != 0) {
                dprintf("could not init read type (%x)\n", Result);
                return E_FAIL;
            }

            PathId = (ULONG)ReadField(PathId);
            TargetId = (ULONG)ReadField(TargetId);
            Lun = (ULONG)ReadField(Lun);
            dprintf("Lun %08p @ (%3d,%3d,%3d)\n",realLun,PathId,TargetId,Lun);
            PDOAddress = ReadField(CommonExtension.DeviceObject);
            dprintf("PDO requests: \n");
            MpDumpRequests(PDOAddress, TickCount, 0 + 2);

            MpDumpExtReq(realLun, TickCount);

            Result = (ULONG) InitTypeRead(realLun, scsiport!_LOGICAL_UNIT_EXTENSION);
            if (Result != 0) {
                dprintf("could not init read type (%x)\n", Result);
                return E_FAIL;
            }

            OffsetOfRequestList = MpGetOffsetOfField("scsiport!_LOGICAL_UNIT_EXTENSION", "RequestList");
            RequestList = realLun + OffsetOfRequestList;
            RequestListFlink = ReadField(RequestList.Flink);
            realLun = ReadField(NextLogicalUnit);
            if (RequestListFlink == RequestList) {
                    xdprintfEx(0, ("Tagged Request List @"));
                    dprintf("%08p is empty\n", RequestList);
            } else {
                    xdprintfEx(0, ("Tagged Request list @"));
                    dprintf("%08p:\n", RequestList);
                    MpDumpActiveRequests(RequestList,
                                         TickCount,
                                         0 + 2);
            }
            if(LunExtension) {
               return S_OK;
           }
          }
    } 
    return S_OK;
}



VOID
MpDumpExtension(
    IN ULONG64 Address,
    IN ULONG64 DeviceExtension,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG tmp;
    
    ULONG       IsPdo = 0;
    ULONG       IsInitialized = 0;
    ULONG       WmiInitialized = 0;
    ULONG       WmiMiniPortSupport = 0;
    ULONG       IsRemoved = 0;
    ULONG64     DeviceObject = 0;
    ULONG64     LowerDeviceObject = 0;
    ULONG       SrbFlags = 0;
    ULONG       CurrentDeviceState = 0;
    ULONG       CurrentSystemState = 0;
    ULONG       DesiredDeviceState = 0;
    ULONG64     IdleTimer = 0;
    ULONG       CurrentPnpState = 0;    
    ULONG       PreviousPnpState = 0;
    ULONG64     MajorFunction = 0;
    ULONG       PagingPathCount = 0;
    ULONG       HibernatePathCount = 0;
    ULONG       DumpPathCount = 0;
    ULONG64     WmiScsiPortRegInfoBuf = 0;
    ULONG       WmiScsiPortRegInfoBufSize = 0;

    FIELD_INFO deviceFields[] = {
       {"IsPdo",                     NULL, 0, COPY, 0, (PVOID) &IsPdo                     },
       {"IsInitialized",             NULL, 0, COPY, 0, (PVOID) &IsInitialized             },
       {"WmiInitialized",            NULL, 0, COPY, 0, (PVOID) &WmiInitialized            },
       {"WmiMiniPortSupport",        NULL, 0, COPY, 0, (PVOID) &WmiMiniPortSupport        },
       {"IsRemoved",                 NULL, 0, COPY, 0, (PVOID) &IsRemoved                 },
       {"DeviceObject",              NULL, 0, COPY, 0, (PVOID) &DeviceObject              },
       {"LowerDeviceObject",         NULL, 0, COPY, 0, (PVOID) &LowerDeviceObject         },
       {"SrbFlags",                  NULL, 0, COPY, 0, (PVOID) &SrbFlags                  },
       {"CurrentDeviceState",        NULL, 0, COPY, 0, (PVOID) &CurrentDeviceState        },
       {"CurrentSystemState",        NULL, 0, COPY, 0, (PVOID) &CurrentSystemState        },
       {"DesiredDeviceState",        NULL, 0, COPY, 0, (PVOID) &DesiredDeviceState        },
       {"IdleTimer",                 NULL, 0, COPY, 0, (PVOID) &IdleTimer                 },
       {"CurrentPnpState",           NULL, 0, COPY, 0, (PVOID) &CurrentPnpState           },
       {"PreviousPnpState",          NULL, 0, COPY, 0, (PVOID) &PreviousPnpState          },
       {"MajorFunction",             NULL, 0, COPY, 0, (PVOID) &MajorFunction             },
       {"PagingPathCount",           NULL, 0, COPY, 0, (PVOID) &PagingPathCount           },
       {"HibernatePathCount",        NULL, 0, COPY, 0, (PVOID) &HibernatePathCount        },
       {"DumpPathCount",             NULL, 0, COPY, 0, (PVOID) &DumpPathCount             },
       {"WmiScsiPortRegInfoBuf",     NULL, 0, COPY, 0, (PVOID) &WmiScsiPortRegInfoBuf     },
       {"WmiScsiPortRegInfoBufSize", NULL, 0, COPY, 0, (PVOID) &WmiScsiPortRegInfoBufSize },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!COMMON_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object\n", Address);
        return;
    }

    dprintf("Miniport %s device extension at address %08p\n",
            (IsPdo ? "physical" : "functional"),
            Address);

    xdprintfEx(Depth, ("Common Extension:\n"));

    Depth += 1;

    tmp = Depth;

    if(IsInitialized) {
        xdprintfEx(tmp, ("Initialized " ));
        tmp = 0;
    }

    if(IsRemoved) {
        xdprintfEx(tmp, ("Removed " ));
        tmp = 0;
    }

    switch(IsRemoved) {
        case REMOVE_PENDING: {
            xdprintfEx(tmp, ("RemovePending"));
            tmp = 0;
            break;
        }

        case REMOVE_COMPLETE: {
            xdprintfEx(tmp, ("RemoveComplete"));
            tmp = 0;
            break;
        }
    }

    if(WmiMiniPortSupport) {
        if(WmiInitialized) {
            xdprintfEx(tmp, ("WmiInit"));
        } else {
            xdprintfEx(tmp, ("Wmi"));
        }
        tmp = 0;
    }

    if(tmp == 0) {
        dprintf("\n");
    }

    tmp = 0;

    xdprintfEx(Depth, ("DO "));
    dprintf("%08p  LowerObject %08p  SRB Flags %#08lx\n",
            DeviceObject,
            LowerDeviceObject,
            SrbFlags
            );

    xdprintfEx(Depth, ("Current Power "));
    dprintf("(D%d,S%d)  Desired Power D%d Idle %#08lx\n",
            CurrentDeviceState - 1,
            CurrentSystemState - 1,
            DesiredDeviceState - 1,
            IdleTimer);

    xdprintfEx(Depth, ("Current Pnp state "));
    dprintf("%x    Previous state 0x%x\n",
            CurrentPnpState,
            PreviousPnpState);

    xdprintfEx(Depth, ("DispatchTable "));
    dprintf("%08p   UsePathCounts (P%d, H%d, C%d)\n",
            MajorFunction,
            PagingPathCount,
            HibernatePathCount,
            DumpPathCount);

    if(WmiMiniPortSupport) {
        xdprintfEx(Depth, ("WmiInfo "));
        dprintf("%08p   WmiInfoSize %#08lx\n",
                WmiScsiPortRegInfoBuf,
                WmiScsiPortRegInfoBufSize);
    }

    if(IsPdo) {
        xdprintfEx(Depth - 1, ("Logical Unit Extension:\n"));
        MpDumpPdo(Address,
                  NULL,
                  Detail,
                  Depth);
    } else {
        xdprintfEx(Depth - 1, ("Adapter Extension:\n"));
        MpDumpFdoExtension(Address, DeviceExtension, Detail, Depth);
    }

    return;
}

VOID
MpDumpHwExports(
    ULONG64 Address
    )
{
    ULONG result;

    ULONG64 HwFindAdapter = 0;
    ULONG64 HwInitialize = 0;
    ULONG64 HwStartIo = 0;
    ULONG64 HwInterrupt = 0;
    ULONG64 HwResetBus = 0;
    ULONG64 HwDmaStarted = 0;
    ULONG64 HwRequestInterrupt = 0;
    ULONG64 HwTimerRequest = 0;
    ULONG64 HwAdapterControl = 0;

    FIELD_INFO deviceFields[] = {
        {"HwFindAdapter",      NULL, 0, COPY, 0, (PVOID) &HwFindAdapter },
        {"HwInitialize",       NULL, 0, COPY, 0, (PVOID) &HwInitialize  },
        {"HwStartIo",          NULL, 0, COPY, 0, (PVOID) &HwStartIo     },
        {"HwInterrupt",        NULL, 0, COPY, 0, (PVOID) &HwInterrupt   },
        {"HwResetBus",         NULL, 0, COPY, 0, (PVOID) &HwResetBus    },
        {"HwDmaStarted",       NULL, 0, COPY, 0, (PVOID) &HwDmaStarted  },
        {"HwRequestInterrupt", NULL, 0, COPY, 0, (PVOID) &HwRequestInterrupt },
        {"HwTimerRequest",     NULL, 0, COPY, 0, (PVOID) &HwTimerRequest     },
        {"HwAdapterControl",   NULL, 0, COPY, 0, (PVOID) &HwAdapterControl   },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_ADAPTER_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object\n", Address);
        return;
    }

    dprintf("HwFindAdapter     : %08p\n", HwFindAdapter);
    dprintf("HwInitialize      : %08p\n", HwInitialize);
    dprintf("HwStartIo         : %08p\n", HwStartIo);
    dprintf("HwInterrupt       : %08p\n", HwInterrupt);
    dprintf("HwResetBus        : %08p\n", HwResetBus);
    dprintf("HwDmaStarted      : %08p\n", HwDmaStarted);
    dprintf("HwRequestInterrupt: %08p\n", HwRequestInterrupt);
    dprintf("HwTimerRequest    : %08p\n", HwTimerRequest);
    dprintf("HwAdapterControl  : %08p\n", HwAdapterControl);

    return;
}


VOID
MpDumpFdoExtension(
    ULONG64 Address,
    ULONG64 DeviceExtension,
    ULONG Detail,
    ULONG Depth
    )

{
    PADAPTER_EXTENSION realAdapter = (PADAPTER_EXTENSION) Address;
    ULONG tmp = Depth;
    WCHAR name[256] = {0};
    ULONG Result;

    ULONG64 DeviceName = 0;
    ULONG64 InterfaceName = 0;
    ULONG   InterfaceNameLen = 0;
    ULONG64 HwDeviceExtension = 0;
    ULONG64 SrbExtensionBuffer = 0; 
    ULONG64 NonCachedExtension = 0;
    ULONG   PortNumber = 0;
    ULONG   AdapterNumber = 0;
    ULONG   ActiveRequestCount = 0;                    
    ULONG   IsMiniportDetected = 0;
    ULONG   IsInVirtualSlot = 0;
    ULONG   IsPnp = 0;
    ULONG   HasInterrupt = 0;
    ULONG   DisablePower = 0;
    ULONG   DisableStop = 0;
    ULONG   VirtualSlotNumber = 0;
    ULONG   RealBusNumber = 0;
    ULONG   RealSlotNumber = 0;
    ULONG   NumberOfBuses = 0;
    ULONG   MaximumTargetIds = 0;
    ULONG   MaxLuCount = 0;
    ULONG   DisableCount = 0;
    ULONG64 SynchronizeExecution = 0;
    ULONG64 MapRegisterBase = 0;
    ULONG64 DmaAdapterObject = 0;
    ULONG64 PortConfig = 0;
    ULONG64 AllocatedResources = 0;
    ULONG64 TranslatedResources = 0;
    ULONG   InterruptLevel = 0;
    ULONG   IoAddress = 0;
    ULONG   MapBuffers = 0;
    ULONG   RemapBuffers = 0;
    ULONG   MasterWithAdapter = 0;
    ULONG   TaggedQueuing= 0;
    ULONG   AutoRequestSense = 0;
    ULONG   MultipleRequestPerLu = 0;
    ULONG   ReceiveEvent = 0;
    ULONG   CachesData = 0;
    ULONG   Dma64BitAddresses = 0;
    ULONG   Dma32BitAddresses = 0;
    ULONG   DeviceState = 0;
    ULONG   TickCount = 0;
    ULONG64 AdapterExtension = 0;
                                       
    FIELD_INFO deviceFields[] = {
        {"DeviceName",                      NULL, 0, COPY, 0, (PVOID) &DeviceName                   },
        {"InterfaceName",                   NULL, 0, RECUR | F_ADDR, 0, NULL                        },
        {"InterfaceName.Buffer",            NULL, 0, COPY | F_ADDR, 0, (PVOID) &InterfaceName       },
        {"InterfaceName.Length",            NULL, 0, COPY | F_ADDR, 0, (PVOID) &InterfaceNameLen    },
        {"HwDeviceExtension",               NULL, 0, COPY, 0, (PVOID) &HwDeviceExtension            },
        {"SrbExtensionBuffer",              NULL, 0, COPY, 0, (PVOID) &SrbExtensionBuffer           },
        {"NonCachedExtension",              NULL, 0, COPY, 0, (PVOID) &NonCachedExtension           },
        {"PortNumber",                      NULL, 0, COPY, 0, (PVOID) &PortNumber                   },
        {"AdapterNumber",                   NULL, 0, COPY, 0, (PVOID) &AdapterNumber                },
        {"ActiveRequestCount",              NULL, 0, COPY, 0, (PVOID) &ActiveRequestCount           },
        {"SynchronizeExecution",            NULL, 0, COPY, 0, (PVOID) &SynchronizeExecution         },
        {"DeviceState",                     NULL, 0, COPY, 0, (PVOID) &DeviceState                  },
        {"TickCount",                       NULL, 0, COPY, 0, (PVOID) &TickCount                    },
        {"IsMiniportDetected",              NULL, 0, COPY, 0, (PVOID) &IsMiniportDetected           },
        {"IsInVirtualSlot",                 NULL, 0, COPY, 0, (PVOID) &IsInVirtualSlot              },
        {"IsPnp",                           NULL, 0, COPY, 0, (PVOID) &IsPnp                        },
        {"HasInterrupt",                    NULL, 0, COPY, 0, (PVOID) &HasInterrupt                 },
        {"DisablePower",                    NULL, 0, COPY, 0, (PVOID) &DisablePower                 },
        {"DisableStop",                     NULL, 0, COPY, 0, (PVOID) &DisableStop                  },
        {"RealBusNumber",                   NULL, 0, COPY, 0, (PVOID) &RealBusNumber                },
        {"RealSlotNumber",                  NULL, 0, COPY, 0, (PVOID) &RealSlotNumber               },
        {"VirtualSlotNumber.u.AsULONG",     NULL, 0, COPY, 0, (PVOID) &VirtualSlotNumber            },
        {"NumberOfBuses",                   NULL, 0, COPY, 0, (PVOID) &NumberOfBuses                },
        {"MaximumTargetIds",                NULL, 0, COPY, 0, (PVOID) &MaximumTargetIds             },
        {"MaxLuCount",                      NULL, 0, COPY, 0, (PVOID) &MaxLuCount                   },
        {"DisableCount",                    NULL, 0, COPY, 0, (PVOID) &DisableCount                 },
        {"MapRegisterBase",                 NULL, 0, COPY, 0, (PVOID) &MapRegisterBase              },
        {"DmaAdapterObject",                NULL, 0, COPY, 0, (PVOID) &DmaAdapterObject             },
        {"PortConfig",                      NULL, 0, COPY, 0, (PVOID) &PortConfig                   },
        {"AllocatedResources",              NULL, 0, COPY, 0, (PVOID) &AllocatedResources           },
        {"TranslatedResources",             NULL, 0, COPY, 0, (PVOID) &TranslatedResources          },
        {"InterruptLevel",                  NULL, 0, COPY, 0, (PVOID) &InterruptLevel               },
        {"IoAddress",                       NULL, 0, COPY, 0, (PVOID) &IoAddress                    },
        {"MapBuffers",                      NULL, 0, COPY, 0, (PVOID) &MapBuffers                   },
        {"RemapBuffers",                    NULL, 0, COPY, 0, (PVOID) &RemapBuffers                 },
        {"MasterWithAdapter",               NULL, 0, COPY, 0, (PVOID) &MasterWithAdapter            },
        {"TaggedQueuing",                   NULL, 0, COPY, 0, (PVOID) &TaggedQueuing                },
        {"AutoRequestSense",                NULL, 0, COPY, 0, (PVOID) &AutoRequestSense             },
        {"MultipleRequestPerLu",            NULL, 0, COPY, 0, (PVOID) &MultipleRequestPerLu         },
        {"ReceiveEvent",                    NULL, 0, COPY, 0, (PVOID) &ReceiveEvent                 },
        {"CachesData",                      NULL, 0, COPY, 0, (PVOID) &CachesData                   },
        {"Dma64BitAddresses",               NULL, 0, COPY, 0, (PVOID) &Dma64BitAddresses            },
        {"Dma32BitAddresses",               NULL, 0, COPY, 0, (PVOID) &Dma32BitAddresses            },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!ADAPTER_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object\n", Address);
        return;
    }

    RtlZeroMemory((PWCHAR)name, sizeof(name));
    if(!ReadMemory(DeviceName,
                   (PVOID) name,
                   sizeof(name)-sizeof(WCHAR),
                   &Result)) {
        dprintf("Error reading DeviceName at address %p\n", DeviceName);
        return;
    }
    xdprintfEx(Depth, ("Device: %S\n", name));

    InterfaceNameLen = min(InterfaceNameLen, sizeof(name)/sizeof(WCHAR)-1);
    RtlZeroMemory((PWCHAR)name, sizeof(name));
    if (!ReadMemory(InterfaceName,
                    (PVOID) name,
                    sizeof(WCHAR) * (ULONG)InterfaceNameLen,
                    &Result)) {
        dprintf("Error reading interface name at address %p\n", InterfaceName);
        return;
    }

    xdprintfEx(Depth, ("Interface: %S\n", name));

    DumpPointerField("Hw Device Extension", HwDeviceExtension, Depth);
    DumpPointerField("SRB Extension", SrbExtensionBuffer, Depth);
    DumpPointerField("Non-cached Extension", NonCachedExtension, Depth);
    DumpUlongField("Port", PortNumber, Depth);
    DumpUlongField("Adapter", AdapterNumber, Depth);
    DumpUlongField("Active Requests", ActiveRequestCount+1, Depth);
    DumpPointerField("Sync Routine", SynchronizeExecution, Depth);
    DumpUlongField("PNP State", DeviceState, Depth);
    DumpUlongField("Tick Count", TickCount, Depth);

    xdprintfEx(Depth, ("Adapter Info:\n"));
    Depth++;
    if (IsMiniportDetected)
        xdprintfEx(Depth, ("Miniport detected\n"));
    if (IsInVirtualSlot)
        xdprintfEx(Depth, ("In virtual slot\n"));
    if (IsPnp)
        xdprintfEx(Depth, ("PNP adapter\n"));
    if (HasInterrupt)
        xdprintfEx(Depth, ("Has interrupt connected\n"));
    if (DisablePower)
        xdprintfEx(Depth, ("Can be powered off\n"));
    if (DisableStop)
        xdprintfEx(Depth, ("Can be stopped\n"));
    Depth--;

    xdprintfEx(Depth, ("Real Bus/Slot: 0x%08X/0x%08X\n", RealBusNumber, RealSlotNumber));
    DumpUlongField("Virtual PCI Slot", VirtualSlotNumber, Depth);
    DumpUcharField("Buses", NumberOfBuses, Depth);
    DumpUcharField("Max Target IDs", MaximumTargetIds, Depth);
    DumpUcharField("Max LUs", MaxLuCount, Depth);
    DumpUlongField("Disables", DisableCount, Depth);
    DumpPointerField("Map Register Base", MapRegisterBase, Depth);
    DumpPointerField("DMA Adapter", DmaAdapterObject, Depth);
    DumpPointerField("Port Config Info", PortConfig, Depth);
    DumpPointerField("Allocated Resources", AllocatedResources, Depth);
    DumpPointerField("Translated Resources", TranslatedResources, Depth);
    DumpUlongField("Interrupt Lvl", InterruptLevel, Depth);
    DumpPointerField("IO Address", IoAddress, Depth);
    DumpBooleanField("Must map buffers", MapBuffers, Depth);
    DumpBooleanField("Must remap buffers", RemapBuffers, Depth);
    DumpBooleanField("Bus Master", MasterWithAdapter, Depth);
    DumpBooleanField("Supports Tagged Queuing", TaggedQueuing, Depth);
    DumpBooleanField("Supports auto request sense", AutoRequestSense, Depth);
    DumpBooleanField("Supports multiple requests per LU", MultipleRequestPerLu, Depth);
    DumpBooleanField("Supports receive event", ReceiveEvent, Depth);
    DumpBooleanField("Caches data", CachesData, Depth);
    DumpBooleanField("Handles 64b DMA", Dma64BitAddresses, Depth);
    DumpBooleanField("Handles 32b DMA", Dma32BitAddresses, Depth);
    
    xdprintfEx(Depth, ("Logical Unit Info:\n"));
    MpDumpChildren(DeviceExtension, Depth);
    return;
}


VOID
MpDumpChildren(
    IN ULONG64 AdapterExtensionAddr,
    IN ULONG Depth
    )

{
    ULONG i;
    ULONG64 realLun;
    ULONG64 realLuns[8];
    ULONG64 lun;
    ULONG CurrentPnpState=0, PreviousPnpState=0, CurrentDeviceState=0;
    ULONG DesiredDeviceState=0, CurrentSystemState=0;
    ULONG64 DeviceObject=0, NextLogicalUnit=0;
    ULONG result;
    ULONG PathId=0, TargetId=0, Lun=0, ucd;
    ULONG IsClaimed=0, IsMissing=0, IsEnumerated=0, IsVisible=0, IsMismatched=0;
    //Added Vars to show Paging, Hibernnate and Dump Path counts
    ULONG PagingPathCount = 0;
    ULONG HibernatePathCount = 0;
    ULONG DumpPathCount = 0;

    InitTypeRead(AdapterExtensionAddr, scsiport!_ADAPTER_EXTENSION);
    realLuns[0] = ReadField(LogicalUnitList[0].List);
    realLuns[1] = ReadField(LogicalUnitList[1].List);
    realLuns[2] = ReadField(LogicalUnitList[2].List);
    realLuns[3] = ReadField(LogicalUnitList[3].List);
    realLuns[4] = ReadField(LogicalUnitList[4].List);
    realLuns[5] = ReadField(LogicalUnitList[5].List);
    realLuns[6] = ReadField(LogicalUnitList[6].List);
    realLuns[7] = ReadField(LogicalUnitList[7].List);

    Depth++;

    for (i = 0; i < min(NUMBER_LOGICAL_UNIT_BINS, 8); i++) {

        realLun = realLuns[i];
        
        while ((realLun != 0) && (!CheckControlC())) {
            FIELD_INFO deviceFields[] = {
               {"PathId",          NULL, 0, COPY, 0, (PVOID) &PathId},
               {"TargetId",        NULL, 0, COPY, 0, (PVOID) &TargetId},
               {"IsClaimed",       NULL, 0, COPY, 0, (PVOID) &IsClaimed},
               {"IsMissing",       NULL, 0, COPY, 0, (PVOID) &IsMissing},
               {"IsEnumerated",    NULL, 0, COPY, 0, (PVOID) &IsEnumerated},
               {"IsVisible",       NULL, 0, COPY, 0, (PVOID) &IsVisible},
               {"IsMismatched",    NULL, 0, COPY, 0, (PVOID) &IsMismatched},
               {"DeviceObject",    NULL, 0, COPY, 0, (PVOID) &DeviceObject},
               {"NextLogicalUnit", NULL, 0, COPY, 0, (PVOID) &NextLogicalUnit},
               {"CommonExtension", NULL, 0, RECUR, 0, NULL},
               {"CommonExtension.CurrentPnpState",    NULL, 0, COPY | RECUR, 0, (PVOID) &CurrentPnpState},
               {"CommonExtension.PreviousPnpState" ,  NULL, 0, COPY | RECUR, 0, (PVOID) &PreviousPnpState},
               {"CommonExtension.CurrentDeviceState", NULL, 0, COPY | RECUR, 0, (PVOID) &CurrentDeviceState},
               {"CommonExtension.DesiredDeviceState", NULL, 0, COPY | RECUR, 0, (PVOID) &DesiredDeviceState},
               {"CommonExtension.CurrentSystemState", NULL, 0, COPY | RECUR, 0, (PVOID) &CurrentSystemState},
               {"CommonExtension.PagingPathCount", NULL, 0, COPY | RECUR, 0, (PVOID) &PagingPathCount},
               {"CommonExtension.HibernatePathCount", NULL, 0, COPY | RECUR, 0, (PVOID) &HibernatePathCount},
               {"CommonExtension.DumpPathCount", NULL, 0, COPY | RECUR, 0, (PVOID) &DumpPathCount},

            };
            SYM_DUMP_PARAM DevSym = {
               sizeof (SYM_DUMP_PARAM), 
               "scsiport!_LOGICAL_UNIT_EXTENSION", 
               DBG_DUMP_NO_PRINT, 
               realLun,
               NULL, NULL, NULL, 
               sizeof (deviceFields) / sizeof (FIELD_INFO), 
               &deviceFields[0]
            };
            
            xdprintfEx(Depth, ("LUN "));
            dprintf("%08p ", realLun);

            if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
                dprintf("%08lx: Could not read device object\n", realLun);
                return;
            }

            result = (ULONG) InitTypeRead(realLun, scsiport!_LOGICAL_UNIT_EXTENSION);
            if (result != 0) {
                dprintf("could not init read type (%x)\n", result);
                return;
            }
            lun = ReadField(Lun);
            Lun = (UCHAR) lun;
            
            dprintf("@ (%3d,%3d,%3d) %c%c%c%c%c%c%c%c pnp(%02x/%02x) pow(%d%c,%d) DevObj %08p\n",
                    PathId,
                    TargetId,
                    Lun,
                    (IsClaimed ? 'c' : ' '),
                    (IsMissing ? 'm' : ' '),
                    (IsEnumerated ? 'e' : ' '),
                    (IsVisible ? 'v' : ' '),
                    (IsMismatched ? 'r' : ' '),
                    (PagingPathCount ? 'p' : ' '),
                    (HibernatePathCount ? 'h' : ' '),
                    (DumpPathCount ? 'd' : ' '),
                    CurrentPnpState,
                    PreviousPnpState,
                    CurrentDeviceState - 1,
                    ((DesiredDeviceState == PowerDeviceUnspecified) ? ' ' : '*'),
                    CurrentSystemState - 1,
                    DeviceObject);

            realLun = ReadField(NextLogicalUnit);
        }
    }

    return;
}


VOID
MpDumpInterruptData(
    IN PINTERRUPT_DATA Data,
    IN PINTERRUPT_DATA RealData,
    IN ULONG Detail,
    IN ULONG Depth
    )

{
    xdprintfEx(Depth, ("Interrupt Data @0x%p:\n", RealData));

    Depth++;

    DumpFlags(Depth, "Flags", Data->InterruptFlags, AdapterFlags);

    xdprintfEx(Depth, ("Ready LUN 0x%p   Wmi Events 0x%p\n",
                       Data->ReadyLogicalUnit,
                       Data->WmiMiniPortRequests));

    {
        ULONG count = 0;
        PSRB_DATA request = Data->CompletedRequests;

        xdprintfEx(Depth, ("Completed Request List (@0x%p): ",
                           &(RealData->CompletedRequests)));

        Depth += 1;

        while((request != NULL) && (!CheckControlC())) {
            SRB_DATA data;
            ULONG result;

            if(Detail != 0) {
                if(count == 0) {
                    dprintf("\n");
                }
                xdprintfEx(Depth, ("SrbData 0x%p   ", request));
            }

            count++;

            if(!ReadMemory((ULONG_PTR)request,
                           (PVOID) &data,
                           sizeof(SRB_DATA),
                           &result)) {
                dprintf("Error reading structure\n");
                break;
            }

            if(Detail != 0) {
                dprintf("Srb 0x%p   Irp 0x%p\n",
                        data.CurrentSrb,
                        data.CurrentIrp);
            }                

            request = data.CompletedRequests;
        }

        Depth -= 1;

        if((Detail == 0) || (count == 0)) {
            dprintf("%d entries\n", count);
        } else {
            xdprintfEx(Depth + 1, ("%d entries\n", count));
        }
    }

    return;
}


VOID
MpDumpPdo(
    IN ULONG64 Address,
    IN OPTIONAL PADAPTER_EXTENSION Adapter,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG result;
    ULONG offset;
    ULONG Fields;

    ULONG   PortNumber = 0;
    ULONG   PathId = 0;
    ULONG   TargetId = 0;
    ULONG   Lun = 0;
    ULONG   IsClaimed = 0;
    ULONG   IsMissing = 0;
    ULONG   IsEnumerated = 0;
    ULONG   IsVisible = 0;
    ULONG   IsMismatched = 0;
    ULONG   luflags = 0;
    ULONG   RetryCount = 0;
    ULONG   CurrentKey = 0;
    ULONG   QueueLockCount = 0;
    ULONG   QueuePauseCount = 0;
    ULONG   LockRequest = 0;
    ULONG   RequestTimeoutCounter = 0;
    ULONG   QueueCount = 0;
    ULONG   MaxQueueDepth = 0;
    ULONG   TickCount;
    ULONG64 TargetDeviceMapKey = 0;
    ULONG64 LunDeviceMapKey = 0;
    ULONG64 ActiveFailedRequest = 0;
    ULONG64 BlockedFailedRequest = 0;
    ULONG64 RequestSenseIrp = 0;
    ULONG64 RequestListFlink = 0;
    ULONG64 RequestList = 0;
    ULONG64 CommonExtensionDeviceObject = 0;
    ULONG64 RequestSenseSrb = 0;
    ULONG64 RequestSenseMdl = 0;
    ULONG64 HwLogicalUnitExtension = 0;
    ULONG64 AdapterExtension = 0;
    ULONG64 NextLogicalUnit = 0;
    ULONG64 ReadyLogicalUnit = 0;
    ULONG64 PendingRequest = 0;
    ULONG64 BusyRequest = 0;
    ULONG64 CurrentUntaggedRequest = 0;
    ULONG64 AbortSrb = 0;
    ULONG64 CompletedAbort = 0;

#undef RECUR
#undef F_ADDR
#undef COPY
#define RECUR  DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_FULL_NAME

    FIELD_INFO deviceFields[] = {
        {"PortNumber",                      "", 0, COPY, 0, (PVOID) &PortNumber                   },
        {"PathId",                          "", 0, COPY, 0, (PVOID) &PathId                       },
        {"TargetId",                        "", 0, COPY, 0, (PVOID) &TargetId                     },
        {"Lun",                             "", 0, COPY, 0, (PVOID) &Lun                          },
        {"HwLogicalUnitExtension",          "", 0, COPY, 0, (PVOID) &HwLogicalUnitExtension       },
        {"AdapterExtension",                "", 0, COPY, 0, (PVOID) &AdapterExtension     },
        {"AdapterExtension->TickCount",     "", 0, COPY, 0, (PVOID) &TickCount                    },
        {"IsClaimed",                       "", 0, COPY, 0, (PVOID) &IsClaimed                    },
        {"IsMissing",                       "", 0, COPY, 0, (PVOID) &IsMissing                    },
        {"IsEnumerated",                    "", 0, COPY, 0, (PVOID) &IsEnumerated                 },
        {"IsVisible",                       "", 0, COPY, 0, (PVOID) &IsVisible                    },
        {"IsMismatched",                    "", 0, COPY, 0, (PVOID) &IsMismatched                 },
        {"LuFlags",                         "", 0, COPY, 0, (PVOID) &luflags                      },
        {"RetryCount",                      "", 0, COPY, 0, (PVOID) &RetryCount                   },
        {"CurrentKey",                      "", 0, COPY, 0, (PVOID) &CurrentKey                   },
        {"QueueLockCount",                  "", 0, COPY, 0, (PVOID) &QueueLockCount               },
        {"QueuePauseCount",                 "", 0, COPY, 0, (PVOID) &QueuePauseCount              },
        {"LockRequest",                     "", 0, COPY, 0, (PVOID) &LockRequest                  },
        {"RequestTimeoutCounter",           "", 0, COPY, 0, (PVOID) &RequestTimeoutCounter        },
        {"RetryCount",                      "", 0, COPY, 0, (PVOID) &RetryCount                   },
        {"CurrentKey",                      "", 0, COPY, 0, (PVOID) &CurrentKey                   },
        {"QueueLockCount",                  "", 0, COPY, 0, (PVOID) &QueueLockCount               },
        {"QueuePauseCount",                 "", 0, COPY, 0, (PVOID) &QueuePauseCount              },
        {"LockRequest",                     "", 0, COPY, 0, (PVOID) &LockRequest                  },
        {"RequestTimeoutCounter",           "", 0, COPY, 0, (PVOID) &RequestTimeoutCounter        },
        {"NextLogicalUnit",                 "", 0, COPY, 0, (PVOID) &NextLogicalUnit              },
        {"ReadyLogicalUnit",                "", 0, COPY, 0, (PVOID) &ReadyLogicalUnit             },
        {"PendingRequest",                  "", 0, COPY, 0, (PVOID) &PendingRequest               },
        {"BusyRequest",                     "", 0, COPY, 0, (PVOID) &BusyRequest                  },
        {"CurrentUntaggedRequest",          "", 0, COPY, 0, (PVOID) &CurrentUntaggedRequest       },
        {"AbortSrb",                        "", 0, COPY, 0, (PVOID) &AbortSrb                     },
        {"CompletedAbort",                  "", 0, COPY, 0, (PVOID) &CompletedAbort               },
        {"QueueCount",                      "", 0, COPY, 0, (PVOID) &QueueCount                   },
        {"MaxQueueDepth",                   "", 0, COPY, 0, (PVOID) &MaxQueueDepth                },
        {"TargetDeviceMapKey",              "", 0, COPY, 0, (PVOID) &TargetDeviceMapKey           },
        {"LunDeviceMapKey",                 "", 0, COPY, 0, (PVOID) &LunDeviceMapKey              },
        {"ActiveFailedRequest",             "", 0, COPY, 0, (PVOID) &ActiveFailedRequest          },
        {"BlockedFailedRequest",            "", 0, COPY, 0, (PVOID) &BlockedFailedRequest         },
        {"RequestSenseIrp",                 "", 0, COPY, 0, (PVOID) &RequestSenseIrp              },
        {"CommonExtension.DeviceObject",    "", 0, COPY, 0, (PVOID) &CommonExtensionDeviceObject  },
        {"RequestList.Flink",               "", 0, COPY, 0, (PVOID) &RequestListFlink             },
        {"RequestList",                     "", 0, ADDROF, 0, NULL },
        {"RequestSenseSrb",                 "", 0, ADDROF, 0, NULL },
        {"RequestSenseMdl",                 "", 0, ADDROF, 0, NULL },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_LOGICAL_UNIT_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object\n", Address);
        return;
    }
    
    Fields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    RequestList = deviceFields[Fields-3].address;
    RequestSenseSrb = deviceFields[Fields-2].address;
    RequestSenseMdl = deviceFields[Fields-1].address;

    InitTypeRead(AdapterExtension, scsiport!_ADAPTER_EXTENSION);
    TickCount = (ULONG) ReadField(TickCount);

    xdprintfEx(Depth, ("Address (Port, PathId, TargetId, Lun): (%d, %d, %d, %d)\n",
                       PortNumber, PathId, TargetId, Lun));

    DumpPointerField("HW Logical Unit Ext", HwLogicalUnitExtension, Depth);
    DumpPointerField("Adapter Ext", AdapterExtension, Depth);

    xdprintfEx(Depth, ("State:"));
    if (IsClaimed)    xdprintf(0, " Claimed");
    if (IsMissing)    xdprintf(0, " Missing");
    if (IsEnumerated) xdprintf(0, " Enumerated");
    if (IsVisible)    xdprintf(0, " Visible");
    if (IsMismatched) xdprintf(0, " Mismatched");
    dprintf("\n");

    DumpFlags(Depth, "LuFlags", luflags, LuFlags);

    DumpUcharField("Retries      ", RetryCount, Depth);
    DumpUlongField("Key          ", CurrentKey, Depth);
    DumpUlongField("Locks        ", QueueLockCount, Depth);
    DumpUlongField("Pauses       ", QueuePauseCount, Depth);
    DumpUlongField("Current Lock ", LockRequest, Depth);
    DumpUlongField("Timeou       ", RequestTimeoutCounter, Depth);
    xdprintfEx(Depth, ("Next LUN: %p   Ready LUN: %p\n", 
                       NextLogicalUnit, ReadyLogicalUnit));

    xdprintfEx(Depth, ("Requests:\n"));
    Depth++;
    DumpPointerField("Pending  ", PendingRequest, Depth);
    DumpPointerField("Busy     ", BusyRequest, Depth);
    DumpPointerField("Untagged ", CurrentUntaggedRequest, Depth);
    Depth--;

    xdprintfEx(Depth, ("Abort SRB Info:\n"));
    Depth++;
    DumpPointerField("Current  ", AbortSrb, Depth);
    DumpPointerField("Completed", CompletedAbort, Depth);
    Depth--;

    xdprintfEx(Depth, ("Queue Depth: %03d (Max: %03d)\n", QueueCount, MaxQueueDepth));

    xdprintfEx(Depth, ("Device Map Keys:\n"));
    Depth++;
    DumpPointerField("Target ", TargetDeviceMapKey, Depth);
    DumpPointerField("Lun    ", LunDeviceMapKey, Depth);
    Depth--;

    if(((PVOID)ActiveFailedRequest != NULL) ||
       ((PVOID)BlockedFailedRequest != NULL)) {
        xdprintfEx(Depth, ("Failed Requests:\n"));
        Depth++;

        if((PVOID)ActiveFailedRequest != NULL) {
            DumpPointerField("Active", ActiveFailedRequest, Depth);
        }

        if((PVOID)BlockedFailedRequest != NULL) {
            DumpPointerField("Blocked", BlockedFailedRequest, Depth);
        }
        Depth--;
    }

    xdprintfEx(Depth, ("Request Sense:\n"));
    Depth++;
    DumpPointerField("IRP", RequestSenseIrp, Depth);
    DumpPointerField("SRB", RequestSenseSrb, Depth);
    DumpPointerField("MDL", RequestSenseMdl, Depth);
    Depth--;

    if (RequestListFlink == RequestList) {
        xdprintfEx(Depth, ("Request List @"));
        dprintf("%08p is empty\n", RequestList);
    } else {
        xdprintfEx(Depth, ("Request list @"));
        dprintf("%08p:\n", RequestList);
        MpDumpActiveRequests(RequestList,
                             TickCount,
                             Depth + 2);
    }

    return;
}

ULONG64
MpGetOffsetOfField(
    IN PCCHAR Type,
    IN PCCHAR Field
    )
{
    FIELD_INFO offsetField[] = {
        {Field, NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       Type, 
       DBG_DUMP_NO_PRINT, 
       0,
       NULL, NULL, NULL, 
       1,
       &offsetField[0]
    };

    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        return (ULONG)-1;
    }

    return offsetField[0].address;
}

VOID
MpDumpActiveRequests(
    IN ULONG64 ListHead,
    IN ULONG TickCount,
    IN ULONG Depth
    )
{
    ULONG64 lastEntry;
    ULONG64 entry;
    ULONG64 realEntry;
    ULONG64 OffsetOfRequestList;
    ULONG64 CurrentSrb = 0;
    ULONG64 CurrentIrp = 0;
    ULONG64 RequestList = 0;
    ULONG   SrbTickCount = 0;

    FIELD_INFO deviceFields[] = {
        {"CurrentSrb",        NULL, 0, COPY, 0, (PVOID) &CurrentSrb          },
        {"CurrentIrp",        NULL, 0, COPY, 0, (PVOID) &CurrentIrp          },
        {"TickCount",         NULL, 0, COPY, 0, (PVOID) &SrbTickCount        },
        {"RequestList",       NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_SRB_DATA", 
       DBG_DUMP_NO_PRINT, 
       0,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    OffsetOfRequestList = MpGetOffsetOfField(
                              "scsiport!_SRB_DATA", 
                              "RequestList");
    
    entry = ListHead;
    realEntry = entry;
    
    InitTypeRead(ListHead, nt!_LIST_ENTRY);
    lastEntry = ReadField(Blink);

    xdprintf(Depth, "Tick count is %d\n", TickCount);
    do {
        ULONG64 realSrbData;

        ULONG result;

        InitTypeRead(realEntry, nt!_LIST_ENTRY);
        entry = ReadField(Flink);

        //
        // entry points to the list entry element of the srb data.  Calculate
        // the address of the start of the srb data block.
        //

        realSrbData = entry - OffsetOfRequestList;

        xdprintfEx(Depth, ("SrbData "));
        dprintf("%08p   ", realSrbData);

        //
        // Read the SRB_DATA information we need.
        //

        DevSym.addr = realSrbData;
        if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
            dprintf("%08p: Could not read device object\n", realSrbData);
            return;
        }
        RequestList = deviceFields[3].address;
        
        //
        // Update realEntry.
        //

        realEntry = RequestList;

        dprintf("Srb %08p   Irp %08p   %s\n",
                CurrentSrb,
                CurrentIrp,
                MpSecondsToString(TickCount - SrbTickCount));

    } while((entry != lastEntry) && (!CheckControlC()));

    return;
}


PUCHAR 
MpSecondsToString(
    ULONG Count
    )  
{
    static UCHAR string[64] = "";
    UCHAR tmp[16];
    ULONG seconds = 0;
    ULONG minutes = 0;
    ULONG hours = 0;
    ULONG days = 0;
    
    string[0] = '\0';

    if (Count == 0) {
        sprintf(string, "<1s");
        return string;
    }

    seconds = Count % 60;
    Count /= 60;
    
    if (Count != 0) {
        minutes = Count % 60;
        Count /= 60;
    }
        
    if (Count != 0) {
        hours = Count % 24;
        Count /= 24;
    }

    if (Count != 0) {
        days = Count;
    }

    if (days != 0) {
        sprintf(tmp, "%dd", days);
        strcat(string, tmp);
    }

    if (hours != 0) {
        sprintf(tmp, "%dh", hours);
        strcat(string, tmp);
    }

    if (minutes != 0) {
        sprintf(tmp, "%dm", minutes);
        strcat(string, tmp);
    }

    if (seconds != 0) {
        sprintf(tmp, "%ds", seconds);
        strcat(string, tmp);
    }

    return string;
}

VOID
MpDumpRequests(
    IN ULONG64 DeviceObject,
    IN ULONG TickCount,
    IN ULONG Depth
    )
{
    ULONG result;
    ULONG64 listHeadFlink, listHeadBlink;
    ULONG64 realEntry;
    ULONG64 DeviceQueue;
    ULONG offset,Result;
    ULONG64 CurrentIrp;
    ULONG64 currentStack;
    ULONG64 currentSrb; 
    ULONG64 currentSrbData;
    int i=0;
    ULONG index = 0;

    //
    // Read the queue out of the device object.
    //

    InitTypeRead(DeviceObject, nt!_DEVICE_OBJECT);
    CurrentIrp = ReadField(CurrentIrp);

    //
    //Pseudo Loop, as I don't want to use Goto to break out of an error 
    //condition
    //
    for(i=0;i<1;i++)
    {
        if(CurrentIrp){

            result = GetFieldData(
                         CurrentIrp, 
                         "nt!_IRP", 
                         "Tail.Overlay.CurrentStackLocation", 
                         sizeof(ULONG64), 
                         &currentStack
                         );
            if (result) {
                dprintf("GetFieldValue @(%s %d) failed (%08X)\n", 
                        __FILE__, __LINE__, result);
                return;
            }

            result = GetFieldData(
                         currentStack,
                         "nt!_IO_STACK_LOCATION", 
                         "Parameters.Scsi.Srb", 
                         sizeof(ULONG64), 
                         &currentSrb
                         );
            if (result) {
                dprintf("GetFieldValue @(%s %d) failed (%08X)\n", 
                        __FILE__, __LINE__, result);
                return;
            }
        
            result = GetFieldData(
                         currentSrb,
                         "scsiport!_SCSI_REQUEST_BLOCK", 
                         "OriginalRequest", 
                         sizeof(ULONG64), 
                         &currentSrbData
                         );
            if (result) {
                dprintf("GetFieldValue @(%s %d) failed (%08X)\n", 
                        __FILE__, __LINE__, result);
                return;
            }

            dprintf("SrbData %p   Srb %p   CurrentIrp %p\n",
                    currentSrbData, currentSrb, CurrentIrp); 
            
        } else {
            dprintf("SrbData %8c   Srb %8c   CurrentIrp %8c\n",' ',' ',' ');
        } 
    }

    InitTypeRead(DeviceObject, nt!_DEVICE_OBJECT);
    
    result = GetFieldData(
                 DeviceObject, 
                 "nt!_DEVICE_OBJECT", 
                 "DeviceQueue.DeviceListHead.Flink", 
                 sizeof(ULONG64), 
                 &listHeadFlink
                 );
    if (result) {
        dprintf("GetFieldValue @(%s %d) failed (%08X)\n", 
                __FILE__, __LINE__, result);
        return;
    }

    result = GetFieldData(
                 DeviceObject, 
                 "nt!_DEVICE_OBJECT", 
                 "DeviceQueue.DeviceListHead.Blink", 
                 sizeof(ULONG64), 
                 &listHeadBlink
                 );
    if (result) {
        dprintf("GetFieldValue @(%s %d) failed (%08X)\n", 
                __FILE__, __LINE__, result);
        return;
    }

    if (listHeadFlink == listHeadBlink) {
        xdprintf(Depth, "Device Queue is empty\n");
        return;
    }

    result = GetFieldOffset("nt!_DEVICE_OBJECT", "DeviceQueue", &offset);
    if (result) {
        dprintf("GetFieldData @(%s %d) failed (%08X)\n", 
                __FILE__, __LINE__, result);
        return;
    }
    
    DeviceQueue = DeviceObject + offset;

    result = GetFieldOffset("nt!_KDEVICE_QUEUE", "DeviceListHead", &offset);

    realEntry = DeviceQueue + offset;

    index = 0;
    do {

        ULONG64 entryFlink;
        ULONG64 realIrp;
        ULONG64 realStack;
        ULONG64 realSrb;
        ULONG64 realSrbData;
        ULONG64 currentSrb, currentIrp;
        ULONG srbTickCount;

        //
        // we've got a pointer to the first list_entry in the list.  Read the 
        // whole thing in so we can see where the next entry will be.
        //

        result = GetFieldData(
                     realEntry,
                     "nt!_LIST_ENTRY",
                     "Flink",
                     sizeof(ULONG64),
                     &entryFlink
                     );
        if (result) {
            dprintf("GetFieldData @(%s %d) failed (%08X)\n", 
                    __FILE__, __LINE__, result);
            return;
        }
        realEntry = entryFlink;

        result = GetFieldOffset(
                     "nt!_IRP", 
                     "Tail.Overlay.DeviceQueueEntry.DeviceListEntry", 
                     &offset);
        if (result) {
            dprintf("GetFieldData @(%s %d) failed (%08X)\n", 
                    __FILE__, __LINE__, result);
            return;
        }

        realIrp = realEntry - offset;

        result = GetFieldData(
                     realIrp,
                     "nt!_IRP",
                     "Tail.Overlay.CurrentStackLocation",
                     sizeof(ULONG64),
                     &realStack
                     );
        if (result) {
            dprintf("GetFieldData @(%s %d) failed (%08X)\n", 
                    __FILE__, __LINE__, result);
            return;
        }

        result = GetFieldData(
                     realStack,
                     "nt!_IO_STACK_LOCATION",
                     "Parameters.Scsi.Srb",
                     sizeof(ULONG64),
                     &realSrb
                     );
        if (result) {
            dprintf("GetFieldData @(%s %d) failed (%08X)\n", 
                    __FILE__, __LINE__, result);
            return;
        }

        result = GetFieldData(
                     realSrb,
                     "scsiport!_SCSI_REQUEST_BLOCK",
                     "OriginalRequest",
                     sizeof(ULONG64),
                     &realSrbData
                     );
        if (result) {
            dprintf("GetFieldData @(%s %d) failed (%08X)\n", 
                    __FILE__, __LINE__, result);
            return;
        }

        xdprintf(Depth, "[%03d] SrbData 0x%p   ", index++, realSrbData);

        InitTypeRead(realSrbData, scsiport!_SRB_DATA);
        currentSrb = ReadField(CurrentSrb);
        currentIrp = ReadField(CurrentIrp);
        srbTickCount = (ULONG)ReadField(TickCount);

        dprintf("Srb 0x%p   Irp 0x%p   %s\n",
                currentSrb,
                currentIrp,
                MpSecondsToString(TickCount - srbTickCount));

    } while((realEntry != listHeadBlink) && (!CheckControlC()));

    return;
}

VOID
MpDumpAccessRange(
    IN ULONG64 address,
    IN ULONG Depth
    )
{
    ULONG64 RangeStart;
    ULONG RangeLength;
    BOOLEAN RangeInMemory;

    InitTypeRead(address, scsiport!_ACCESS_RANGE);
    RangeStart = ReadField(RangeStart.QuadPart);
    RangeLength = (ULONG) ReadField(RangeLength);
    RangeInMemory = (BOOLEAN) ReadField(RangeInMemory);

    xdprintfEx(Depth, ("@ %08p  %08p   %08x   %s\n",
                       address,
                       RangeStart,
                       RangeLength,
                       RangeInMemory ? "YES" : "NO"));

    return;
}

VOID
MpDumpSrb(
    IN ULONG64 Srb,
    IN ULONG Depth
    )
{
    ULONG   result = 0;

    ULONG   Length = 0;
    UCHAR   Function = 0;
    UCHAR   SrbStatus = 0;
    UCHAR   ScsiStatus = 0;
    UCHAR   PathId = 0;
    UCHAR   TargetId = 0;
    UCHAR   Lun = 0;
    UCHAR   QueueTag = 0;
    UCHAR   QueueAction = 0;
    UCHAR   CdbLength = 0;
    UCHAR   SenseInfoBufferLength = 0;
    ULONG   Flags = 0;
    ULONG   DataTransferLength = 0;
    ULONG   TimeOutValue = 0;
    ULONG64 DataBuffer = 0;
    ULONG64 SenseInfoBuffer = 0;
    ULONG64 NextSrb = 0;
    ULONG64 OriginalRequest = 0;
    ULONG64 SrbExtension = 0;
    ULONG   InternalStatus = 0;
    ULONG64 AddrOfCdb = 0;
    UCHAR   Cdb[16];
    ULONG   i;
    
    FIELD_INFO deviceFields[] = {
        {"Length",                 NULL, 0, COPY, 0, (PVOID) &Length                 },
        {"Function",               NULL, 0, COPY, 0, (PVOID) &Function               },
        {"SrbStatus",              NULL, 0, COPY, 0, (PVOID) &SrbStatus              },
        {"ScsiStatus",             NULL, 0, COPY, 0, (PVOID) &ScsiStatus             },
        {"PathId",                 NULL, 0, COPY, 0, (PVOID) &PathId                 },
        {"TargetId",               NULL, 0, COPY, 0, (PVOID) &TargetId               },
        {"Lun",                    NULL, 0, COPY, 0, (PVOID) &Lun                    },
        {"QueueTag",               NULL, 0, COPY, 0, (PVOID) &QueueTag               },
        {"QueueAction",            NULL, 0, COPY, 0, (PVOID) &QueueAction            },
        {"CdbLength",              NULL, 0, COPY, 0, (PVOID) &CdbLength              },
        {"SenseInfoBufferLength",  NULL, 0, COPY, 0, (PVOID) &SenseInfoBufferLength  },
        {"SrbFlags",               NULL, 0, COPY, 0, (PVOID) &Flags                  },
        {"DataTransferLength",     NULL, 0, COPY, 0, (PVOID) &DataTransferLength     },
        {"TimeOutValue",           NULL, 0, COPY, 0, (PVOID) &TimeOutValue           },
        {"DataBuffer",             NULL, 0, COPY, 0, (PVOID) &DataBuffer             },
        {"SenseInfoBuffer",        NULL, 0, COPY, 0, (PVOID) &SenseInfoBuffer        },
        {"NextSrb",                NULL, 0, COPY, 0, (PVOID) &NextSrb                },
        {"OriginalRequest",        NULL, 0, COPY, 0, (PVOID) &OriginalRequest        },
        {"SrbExtension",           NULL, 0, COPY, 0, (PVOID) &SrbExtension           },
        {"InternalStatus",         NULL, 0, COPY, 0, (PVOID) &InternalStatus         },
        {"Cdb",                    NULL, 0, ADDROF, 0, NULL   },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_SCSI_REQUEST_BLOCK", 
       DBG_DUMP_NO_PRINT, 
       Srb,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("Could not read SRB @ %08p\n", Srb);
        return;
    }

    AddrOfCdb = deviceFields[(sizeof (deviceFields) / sizeof (FIELD_INFO)) - 1].address;
    if (!ReadMemory((ULONG64)AddrOfCdb, Cdb, sizeof(Cdb), &result)) {
        dprintf("Error reading access range\n");
        return;
    }

    xdprintf(Depth, "SCSI_REQUEST_BLOCK:\n");
    DumpUshortField("Length", Length, Depth);

    if (Function < MINIKD_MAX_SCSI_FUNCTION) {
        xdprintfEx(Depth, ("%s: 0x%02X (%s)\n", "Function", Function, MiniScsiFunction[Function]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%02X (???)\n", "Function", Function));
    }

    xdprintfEx(Depth, ("%s: 0x%02X (", "Status", SrbStatus));
    if (SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        dprintf("SRB_STATUS_AUTOSENSE_VALID | ");
    } 
    if (SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
        dprintf("SRB_STATUS_QUEUE_FROZEN | ");
    }
    if (SRB_STATUS(SrbStatus) < MINIKD_MAX_SRB_STATUS) {
        dprintf("%s)", MiniScsiSrbStatus[SRB_STATUS(SrbStatus)]);
    } else {
        dprintf("???)");
    }
    dprintf("\n");

    DumpUcharField("ScsiStatus ", ScsiStatus, Depth);
    DumpUcharField("PathId     ", PathId, Depth);
    DumpUcharField("TargetId   ", TargetId, Depth);
    DumpUcharField("Lun        ", Lun, Depth);
    DumpUcharField("QueueTag   ", QueueTag, Depth);
    DumpUcharField("QueueAction", QueueAction, Depth);
    DumpUcharField("CdbLength  ", CdbLength, Depth);
    DumpUcharField("SenseInfoBufferLength", SenseInfoBufferLength, Depth);

    DumpFlags(Depth, "SrbFlags", Flags, SrbFlagsMap);

    DumpUlongField("DataTransferLength", DataTransferLength, Depth);
    DumpUlongField("TimeOutValue      ", TimeOutValue, Depth);
    DumpPointerField("DataBuffer      ", DataBuffer, Depth);
    DumpPointerField("SenseInfoBuffer ", SenseInfoBuffer, Depth);
    DumpPointerField("NextSrb         ", NextSrb, Depth);
    DumpPointerField("OriginalRequest ", OriginalRequest, Depth);
    DumpPointerField("SrbExtension    ", SrbExtension, Depth);
    DumpUlongField("InternalStatus  ", InternalStatus, Depth);

    xdprintfEx(Depth, ("%s: ", "Cdb"));
    for (i=0; i<CdbLength; i++) {
        dprintf("%x ", Cdb[i]);
    }
    dprintf("\n");

    return;
}

VOID
MpDumpPortConfigurationInformation(
    IN ULONG64 PortConfigInfo,
    IN ULONG Depth
    )
{
    ULONG i;
    ULONG Fields;
    UCHAR BusId[8];
    ULONG status;
    ULONG result;

    ULONG           Length                              = 0;
    ULONG           SystemIoBusNumber                   = 0;
    ULONG           AdapterInterfaceType                = 0;
    ULONG           BusInterruptLevel                   = 0;
    ULONG           BusInterruptVector                  = 0;
    ULONG           InterruptMode                       = 0;
    ULONG           MaximumTransferLength               = 0;
    ULONG           NumberOfPhysicalBreaks              = 0;
    ULONG           DmaChannel                          = 0;
    ULONG           DmaPort                             = 0;
    ULONG           DmaWidth                            = 0;
    ULONG           DmaSpeed                            = 0;
    ULONG           AlignmentMask                       = 0;
    ULONG           NumberOfAccessRanges                = 0;
    ULONG64         Reserved                            = 0;
    ULONG           NumberOfBuses                       = 0;
    ULONG           ScatterGather                       = 0;
    ULONG           Master                              = 0;
    ULONG           CachesData                          = 0;
    ULONG           AdapterScansDown                    = 0;
    ULONG           AtdiskPrimaryClaimed                = 0;
    ULONG           AtdiskSecondaryClaimed              = 0;
    ULONG           Dma32BitAddresses                   = 0;
    ULONG           DemandMode                          = 0;
    ULONG           MapBuffers                          = 0;
    ULONG           NeedPhysicalAddresses               = 0; 
    ULONG           TaggedQueuing                       = 0; 
    ULONG           AutoRequestSense                    = 0;
    ULONG           MultipleRequestPerLu                = 0;
    ULONG           ReceiveEvent                        = 0;
    ULONG           RealModeInitialized                 = 0;
    ULONG           BufferAccessScsiPortControlled      = 0;
    ULONG           MaximumNumberOfTargets              = 0;
    ULONG           SlotNumber                          = 0;
    ULONG           BusInterruptLevel2                  = 0;
    ULONG           BusInterruptVector2                 = 0;
    ULONG           InterruptMode2                      = 0;
    ULONG           DmaChannel2                         = 0;
    ULONG           DmaPort2                            = 0;
    ULONG           DmaWidth2                           = 0;
    ULONG           DmaSpeed2                           = 0;
    ULONG           DeviceExtensionSize                 = 0;
    ULONG           SpecificLuExtensionSize             = 0;
    ULONG           SrbExtensionSize                    = 0;
    ULONG           Dma64BitAddresses                   = 0;
    ULONG           ResetTargetSupported                = 0;
    ULONG           MaximumNumberOfLogicalUnits         = 0;
    ULONG           WmiDataProvider                     = 0;
    ULONG64         InitiatorBusId                      = 0;
    ULONG64         AccessRanges                        = 0;
    
    FIELD_INFO deviceFields[] = {
        {"Length",                           NULL, 0, COPY, 0, (PVOID) &Length                        },
        {"SystemIoBusNumber",                NULL, 0, COPY, 0, (PVOID) &SystemIoBusNumber             },
        {"AdapterInterfaceType",             NULL, 0, COPY, 0, (PVOID) &AdapterInterfaceType          },
        {"BusInterruptLevel",                NULL, 0, COPY, 0, (PVOID) &BusInterruptLevel             },
        {"BusInterruptVector",               NULL, 0, COPY, 0, (PVOID) &BusInterruptVector            },
        {"InterruptMode",                    NULL, 0, COPY, 0, (PVOID) &InterruptMode                 },
        {"MaximumTransferLength",            NULL, 0, COPY, 0, (PVOID) &MaximumTransferLength         },
        {"NumberOfPhysicalBreaks",           NULL, 0, COPY, 0, (PVOID) &NumberOfPhysicalBreaks        },
        {"DmaChannel",                       NULL, 0, COPY, 0, (PVOID) &DmaChannel                    },
        {"DmaPort",                          NULL, 0, COPY, 0, (PVOID) &DmaPort                       },
        {"DmaWidth",                         NULL, 0, COPY, 0, (PVOID) &DmaWidth                      },
        {"DmaSpeed",                         NULL, 0, COPY, 0, (PVOID) &DmaSpeed                      },
        {"AlignmentMask",                    NULL, 0, COPY, 0, (PVOID) &AlignmentMask                 },
        {"NumberOfAccessRanges",             NULL, 0, COPY, 0, (PVOID) &NumberOfAccessRanges          },
        {"Reserved",                         NULL, 0, COPY, 0, (PVOID) &Reserved                      },
        {"NumberOfBuses",                    NULL, 0, COPY, 0, (PVOID) &NumberOfBuses                 },
        {"ScatterGather",                    NULL, 0, COPY, 0, (PVOID) &ScatterGather                 },
        {"Master",                           NULL, 0, COPY, 0, (PVOID) &Master                        },
        {"CachesData",                       NULL, 0, COPY, 0, (PVOID) &CachesData                    },
        {"AdapterScansDown",                 NULL, 0, COPY, 0, (PVOID) &AdapterScansDown              },
        {"AtdiskPrimaryClaimed",             NULL, 0, COPY, 0, (PVOID) &AtdiskPrimaryClaimed          },
        {"AtdiskSecondaryClaimed",           NULL, 0, COPY, 0, (PVOID) &AtdiskSecondaryClaimed        },
        {"Dma32BitAddresses",                NULL, 0, COPY, 0, (PVOID) &Dma32BitAddresses             },
        {"DemandMode",                       NULL, 0, COPY, 0, (PVOID) &DemandMode                    },
        {"MapBuffers",                       NULL, 0, COPY, 0, (PVOID) &MapBuffers                    },
        {"NeedPhysicalAddresses",            NULL, 0, COPY, 0, (PVOID) &NeedPhysicalAddresses         },
        {"TaggedQueuing",                    NULL, 0, COPY, 0, (PVOID) &TaggedQueuing                 },
        {"AutoRequestSense",                 NULL, 0, COPY, 0, (PVOID) &AutoRequestSense              },
        {"MultipleRequestPerLu",             NULL, 0, COPY, 0, (PVOID) &MultipleRequestPerLu          },
        {"ReceiveEvent",                     NULL, 0, COPY, 0, (PVOID) &ReceiveEvent                  },
        {"RealModeInitialized",              NULL, 0, COPY, 0, (PVOID) &RealModeInitialized           },
        {"BufferAccessScsiPortControlled",   NULL, 0, COPY, 0, (PVOID) &BufferAccessScsiPortControlled},
        {"MaximumNumberOfTargets",           NULL, 0, COPY, 0, (PVOID) &MaximumNumberOfTargets        },
        {"SlotNumber",                       NULL, 0, COPY, 0, (PVOID) &SlotNumber                    },
        {"BusInterruptLevel2",               NULL, 0, COPY, 0, (PVOID) &BusInterruptLevel2            },
        {"BusInterruptVector2",              NULL, 0, COPY, 0, (PVOID) &BusInterruptVector2           },
        {"InterruptMode2",                   NULL, 0, COPY, 0, (PVOID) &InterruptMode2                },
        {"DmaChannel2",                      NULL, 0, COPY, 0, (PVOID) &DmaChannel2                   },
        {"DmaPort2",                         NULL, 0, COPY, 0, (PVOID) &DmaPort2                      },
        {"DmaWidth2",                        NULL, 0, COPY, 0, (PVOID) &DmaWidth2                     },
        {"DmaSpeed2",                        NULL, 0, COPY, 0, (PVOID) &DmaSpeed2                     },
        {"DeviceExtensionSize",              NULL, 0, COPY, 0, (PVOID) &DeviceExtensionSize           },
        {"SpecificLuExtensionSize",          NULL, 0, COPY, 0, (PVOID) &SpecificLuExtensionSize       },
        {"SrbExtensionSize",                 NULL, 0, COPY, 0, (PVOID) &SrbExtensionSize              },
        {"Dma64BitAddresses",                NULL, 0, COPY, 0, (PVOID) &Dma64BitAddresses             },
        {"ResetTargetSupported",             NULL, 0, COPY, 0, (PVOID) &ResetTargetSupported          },
        {"MaximumNumberOfLogicalUnits",      NULL, 0, COPY, 0, (PVOID) &MaximumNumberOfLogicalUnits   },
        {"WmiDataProvider",                  NULL, 0, COPY, 0, (PVOID) &WmiDataProvider               },
        {"AccessRanges",                     NULL, 0, COPY, 0, (PVOID) &AccessRanges                  },
        {"InitiatorBusId[0]",                NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL          },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_PORT_CONFIGURATION_INFORMATION", 
       DBG_DUMP_NO_PRINT, 
       PortConfigInfo,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("Could not read _PORT_CONFIGURATION_INFORMATION @ %08p\n", PortConfigInfo);
        return;
    }

    Fields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    InitiatorBusId = deviceFields[Fields-1].address;

    xdprintfEx(Depth, ("PORT_CONFIGURATION_INFORMATION:\n"));
    DumpUlongField("Length", Length, Depth);
    DumpUlongField("SysIoBus", SystemIoBusNumber, Depth);

    if (AdapterInterfaceType < MaximumInterfaceType) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n",  "AdapterInterfaceType", AdapterInterfaceType, MiniInterfaceTypes[AdapterInterfaceType]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "AdapterInterfaceType", AdapterInterfaceType));
    }

    DumpUlongField("BusIntLvl", BusInterruptLevel, Depth);
    DumpUlongField("BusIntVector", BusInterruptVector, Depth);

    if (InterruptMode <= Latched) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "InterruptMode", InterruptMode, MiniInterruptMode[InterruptMode]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "InterruptMode", InterruptMode));
    }
    
    DumpUlongField("MaximumTransferLength", MaximumTransferLength, Depth);
    DumpUlongField("NumberOfPhysicalBreaks", NumberOfPhysicalBreaks, Depth);
    DumpUlongField("DmaChannel", DmaChannel, Depth);
    DumpUlongField("DmaPort", DmaPort, Depth);

    if (DmaWidth < MaximumDmaWidth) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "DmaWidth", DmaWidth, MiniDmaWidths[DmaWidth]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "DmaWidth", DmaWidth));
    }

    if (DmaSpeed < MaximumDmaSpeed) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "DmaSpeed", DmaSpeed, MiniDmaWidths[DmaSpeed]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "DmaSpeed", DmaSpeed));
    }
    
    DumpUlongField("AlignmentMask", AlignmentMask, Depth);
    DumpPointerField("Reserved", (ULONG_PTR)Reserved, Depth);
    DumpUlongField("NumberOfBuses", NumberOfBuses, Depth);

    status = ReadMemory(InitiatorBusId, (PVOID) BusId, sizeof(BusId), &result);
    if (!status) {
        dprintf("Error reading initiator bus id @ %08p\n", InitiatorBusId);
        return;
    }
    
    xdprintfEx(Depth, ("%s: ", "InitiatorBusId"));
    for (i = 0; i < 8; i++) {
        xdprintfEx(Depth, ("%02x ", BusId[i]));
    }
    xdprintfEx(Depth, ("\n"));

    DumpBooleanField("ScatterGather          ", ScatterGather, Depth);
    DumpBooleanField("Master                 ", Master, Depth);
    DumpBooleanField("AdapterScansDown       ", AdapterScansDown, Depth);
    DumpBooleanField("AtdiskPrimaryClaimed   ", AtdiskPrimaryClaimed, Depth);
    DumpBooleanField("AtdiskSecondaryClaimed ", AtdiskSecondaryClaimed, Depth);
    DumpBooleanField("Dma32BitAddresses      ", Dma32BitAddresses, Depth);
    DumpBooleanField("DemandMode             ", DemandMode, Depth);
    DumpBooleanField("MapBuffers             ", MapBuffers, Depth);
    DumpBooleanField("NeedPhysicalAddresses  ", NeedPhysicalAddresses, Depth);
    DumpBooleanField("TaggedQueuing          ", TaggedQueuing, Depth);
    DumpBooleanField("AutoRequestSense       ", AutoRequestSense, Depth);
    DumpBooleanField("MultipleRequestPerLu   ", MultipleRequestPerLu, Depth);
    DumpBooleanField("ReceiveEvent           ", ReceiveEvent, Depth);
    DumpBooleanField("RealModeInitialized    ", RealModeInitialized, Depth);
    DumpBooleanField("BufScsiPortControlled  ", BufferAccessScsiPortControlled, Depth);

    DumpUlongField("MaximumNumberOfTargets", MaximumNumberOfTargets, Depth);
    DumpUlongField("SlotNumber", SlotNumber, Depth);

    DumpUlongField("BusInterruptLevel2", BusInterruptLevel2, Depth);
    DumpUlongField("BusInterruptVector2", BusInterruptVector2, Depth);

    if (InterruptMode2 <= Latched) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "InterruptMode2", InterruptMode2, MiniInterruptMode[InterruptMode2]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "InterruptMode2", InterruptMode2));
    }

    DumpUlongField("DmaChannel2", DmaChannel2, Depth);
    DumpUlongField("DmaPort2", DmaPort2, Depth);

    if (DmaWidth2 < MaximumDmaWidth) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "DmaWidth2", DmaWidth2, MiniDmaWidths[DmaWidth2]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "DmaWidth2", DmaWidth2));
    }

    DumpUlongField("DeviceExtensionSize     ", DeviceExtensionSize, Depth);
    DumpUlongField("SpecificLuExtensionSize ", SpecificLuExtensionSize, Depth);
    DumpUlongField("SrbExtensionSize        ", SrbExtensionSize, Depth);
    DumpUlongField("Dma64BitAddresses       ", Dma64BitAddresses, Depth);
    DumpUlongField("ResetTargetSupported    ", ResetTargetSupported, Depth);
    DumpUlongField("MaxLogicalUnits         ", MaximumNumberOfLogicalUnits, Depth);
    DumpUlongField("WmiDataProvider         ", WmiDataProvider, Depth);
    
    DumpUlongField("NumberOfAccessRanges", NumberOfAccessRanges, Depth);
    xdprintfEx(Depth, ("Access Ranges...\n"));

    Depth++;
    for (i = 0; i < NumberOfAccessRanges; i++) {
        MpDumpAccessRange(AccessRanges, Depth);
        AccessRanges += sizeof(ACCESS_RANGE);
    }

    return;
}

VOID
MpDumpExtReq(
    IN ULONG64 Address,IN ULONG TickCount
    )
{
    ULONG result;
    ULONG offset;

    ULONG64 PendingRequest = 0;
    ULONG64 BusyRequest = 0;
    ULONG64 CurrentUntaggedRequest = 0;

    FIELD_INFO deviceFields[] = {
        {"PendingRequest",                  "", 0, COPY, 0, (PVOID) &PendingRequest               },
        {"BusyRequest",                     "", 0, COPY, 0, (PVOID) &BusyRequest                  },
        {"CurrentUntaggedRequest",          "", 0, COPY, 0, (PVOID) &CurrentUntaggedRequest       },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_LOGICAL_UNIT_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object\n", Address);
        return;
    }

    dprintf("Pending Requests:\n");
    MpDumpSrb_Data(PendingRequest,TickCount);
    dprintf("Busy Requests:\n");
    MpDumpSrb_Data(BusyRequest,TickCount);
    dprintf("Current Untagged Requests:\n");
    MpDumpSrb_Data(CurrentUntaggedRequest,TickCount);
    
    return;
}



VOID 
MpDumpSrb_Data(
    IN ULONG64 Request,
    IN ULONG TickCount
    )
{
    ULONG64 CurrentIrp = 0;
    ULONG64 CurrentSrb = 0;
    ULONG   SrbTickCount = 0;

    FIELD_INFO deviceFields[] = {
        {"CurrentSrb", NULL, 0, COPY, 0, (PVOID) &CurrentSrb},
        {"CurrentIrp", NULL, 0, COPY, 0, (PVOID) &CurrentIrp},
        {"TickCount",  NULL, 0, COPY, 0, (PVOID) &SrbTickCount},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_SRB_DATA", 
       DBG_DUMP_NO_PRINT, 
       Request,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    if (!Request) {
        xdprintfEx(2,("SrbData %8c   Srb %8c   Irp %8c   %c\n",
                ' ',
                ' ',
                ' ',
                ' '));
        return;
    }

   if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
       dprintf("%08p: Could not read device object\n", Request);
       return;
   }

   xdprintfEx(2,("SrbData %08p   Srb %08p   Irp %08p   %s\n",
                 Request,
                 CurrentSrb,
                 CurrentIrp,
                 MpSecondsToString(TickCount - SrbTickCount)));

   return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\portsym\makefile.inc ===
$(O)\scsikd.c : scsi.c
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\redbook\kdext.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = {
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER,
    0
    };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

BOOLEAN                VersionWarningAlreadyPrinted = FALSE;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
    if (VersionWarningAlreadyPrinted) {
        return;
    }
    VersionWarningAlreadyPrinted = TRUE;

#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** RedBook Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** RedBook Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\redbook\help.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    help.c

Abstract:

    WinDbg Extension Api for interpretting redbook debugging structures

Author:

    Henry Gabryjelski (henrygab) 21-Sep-1998

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

typedef struct {
        char *extname;
        char *extdesc;
} exthelp;

exthelp extensions[] =  {
    {"------------", "----------------------------------------------"},
    {"help"        , "displays this help -- all commands take devobj"},
    {"ext"         , "dumps the redbook device  extension"           },
    {"silence"     , "toggles sending only silent buffers to ks"     },
    {"toc"         , "dumps a CDROM_TOC  *** takes TOC pointer *** " },
    {"wmiperfclear", "clears the wmi performance counters"           },
    {"------------", "----------------------------------------------"},
    {NULL,      NULL}
};

DECLARE_API(help)
{
        int i = 0;

        dprintf("\nRedbook Debugger Extension\n");
        while(extensions[i].extname != NULL)    {
                dprintf("\t%-12s - \t%s\n", extensions[i].extname, extensions[i].extdesc);
                i++;
        }
        dprintf("\n");
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\minisym\scsi.c ===
#include "ntddk.h"
#include "port.h"

#ifdef TEST_FLAG
#undef TEST_FLAG
#endif

#ifdef ASSERT_FDO
#undef ASSERT_FDO
#endif

#ifdef ASSERT_PDO
#undef ASSERT_PDO
#endif

#ifdef IS_CLEANUP_REQUEST
#undef IS_CLEANUP_REQUEST
#endif

#include <classpnp.h> 
#include "classp.h" 
#include "cdrom.h"

//Port-Driver Data Structures

ADAPTER_EXTENSION              AdapterExtension;
LOGICAL_UNIT_EXTENSION         LogicalUnitExtension;
SCSI_REQUEST_BLOCK             Srb;
COMMON_EXTENSION               CommonExtension;
REMOVE_TRACKING_BLOCK          RemoveTrackingBlock;
INTERRUPT_DATA                 InterruptData;
SRB_DATA                       SrbData;
PORT_CONFIGURATION_INFORMATION PortConfigInfo; 

//Class-Driver Data Structures

MEDIA_CHANGE_DETECTION_INFO    MediaChange;
FUNCTIONAL_DEVICE_EXTENSION    FunctionalDeviceExtension;
PHYSICAL_DEVICE_EXTENSION      PhysicalDeviceExtension; 
COMMON_DEVICE_EXTENSION	       CommonDeviceExtension;
CLASS_PRIVATE_FDO_DATA         ClassPrivateFdoData;
TRANSFER_PACKET                TransferPacket;
MEDIA_CHANGE_DETECTION_INFO    ChangeDetectionInfo;
DISK_GEOMETRY                  DiskGeometry;
SCSI_REQUEST_BLOCK             Srb;
CDB                            Cdb;
CLASS_ERROR_LOG_DATA           ClassErrorLogData;
STORAGE_DEVICE_DESCRIPTOR      StorageDeviceDescriptor;
SENSE_DATA                     SenseData;

int __cdecl main() { 
    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\portsym\scsi.c ===
#include "ntddk.h"
#include "port.h"

#ifdef TEST_FLAG
#undef TEST_FLAG
#endif

#ifdef ASSERT_FDO
#undef ASSERT_FDO
#endif

#ifdef ASSERT_PDO
#undef ASSERT_PDO
#endif

#ifdef IS_CLEANUP_REQUEST
#undef IS_CLEANUP_REQUEST
#endif

#include <classpnp.h> 
#include "classp.h" 
#include "cdrom.h"

//Port-Driver Data Structures

ADAPTER_EXTENSION              AdapterExtension;
LOGICAL_UNIT_EXTENSION         LogicalUnitExtension;
SCSI_REQUEST_BLOCK             Srb;
COMMON_EXTENSION               CommonExtension;
REMOVE_TRACKING_BLOCK          RemoveTrackingBlock;
INTERRUPT_DATA                 InterruptData;
SRB_DATA                       SrbData;
PORT_CONFIGURATION_INFORMATION PortConfigInfo; 

//Class-Driver Data Structures

MEDIA_CHANGE_DETECTION_INFO    MediaChange;
FUNCTIONAL_DEVICE_EXTENSION    FunctionalDeviceExtension;
PHYSICAL_DEVICE_EXTENSION      PhysicalDeviceExtension; 
COMMON_DEVICE_EXTENSION	       CommonDeviceExtension;
CLASS_PRIVATE_FDO_DATA         ClassPrivateFdoData;
TRANSFER_PACKET                TransferPacket;
MEDIA_CHANGE_DETECTION_INFO    ChangeDetectionInfo;
DISK_GEOMETRY                  DiskGeometry;
SCSI_REQUEST_BLOCK             Srb;
CDB                            Cdb;
CLASS_ERROR_LOG_DATA           ClassErrorLogData;
STORAGE_DEVICE_DESCRIPTOR      StorageDeviceDescriptor;
SENSE_DATA                     SenseData;

int __cdecl main() { 
    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\redbook\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#ifndef REDKDEXT
#define REDKDEXT

//
// allow this to compile at /W4
//

#pragma warning(disable:4115) // named type definition in parenthesis
#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int
#pragma warning(disable:4057) // char * == char[]

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <zwapi.h>


#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <imagehlp.h>

#include <memory.h>

// Stolen from ntrtl.h to override RECOMASSERT
#ifdef ASSERT
    #undef ASSERT
#endif
#ifdef ASSERTMSG
    #undef ASSERTMSG
#endif

#if DBG
    #define ASSERT( exp ) \
        if (!(exp)) \
            RtlAssert( #exp, __FILE__, __LINE__, NULL )

    #define ASSERTMSG( msg, exp ) \
        if (!(exp)) \
            RtlAssert( #exp, __FILE__, __LINE__, msg )
#else
    #define ASSERT( exp )
    #define ASSERTMSG( msg, exp )
#endif // DBG

#include <wdbgexts.h>
extern WINDBG_EXTENSION_APIS ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

// grab the redbook related headers too
#include <ntddredb.h>
#include <redbook.h>
#include "wmistr.h"

#endif //REDKDEXT
//#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\kdext.cpp ===
//depot/Lab01_N/drivers/storage/kdext/minipkd/kdext.cpp#1 - add change 1876 (text)
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>

WINDBG_EXTENSION_APIS  ExtensionApis;

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

extern "C" HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    IDebugControl *DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                          (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
//    g_ExcepCallbacks.Uninitialize();
//    g_FnProfCallbacks.Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\redbook\redbook.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    redbook.c

Abstract:

    Debugger Extension Api for interpretting scsiport structures

Author:

    Henry Gabryjelski 23-Oct-1998

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#define INDENT 2

//#define PRINT_LINE()  dprintf("Line %4d File %s\n", __LINE__, __FILE__)

#define DUMP_STRUCT(v,d,x,y) \
    if ((v) <= Detail) { xdprintf( (d), "%-20s - %#010x\n",     (x), (y) ); }
#define DUMP_STRUCT_P(v,d,x,y) \
    if ((v) <= Detail) { xdprintf( (d), "%-20s - %#p\n",       (x), (y) ); }
#define DUMP_STRUCT64(v,d,x,y) \
    if ((v) <= Detail) { xdprintf( (d), "%-20s - %#016I64x\n", (x), (y) ); }

#define PRINT_FLAGS(Flags,b) \
    if (Flags & b)    { dprintf( #b ", " ); }

typedef struct _FLAG_NAME {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

FLAG_NAME CdFlags[] = {
    FLAG_NAME(CD_STOPPED),         // 0000 0001
    FLAG_NAME(CD_PAUSED),          // 0000 0002
    FLAG_NAME(CD_PLAYING),         // 0000 0004

    FLAG_NAME(CD_STOPPING),        // 0000 0010
    FLAG_NAME(CD_PAUSING),         // 0000 0020

    {0,0}
};

PUCHAR const REDBOOK_CC_STRINGS[5] = {
    "   Read   ",
    "  Stream  ",
    " Read Com ",
    "Stream Com",
    "*Unknown* "
    };



VOID
DumpToc(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpContext(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpFlags(
    LONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );
VOID
DumpList(
    PVOID AddressOfListHead
    );
VOID
DumpRedBookBufferData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookCdromInfo(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookExtension(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookStreamData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookThreadData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookWmiData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookWmiPerf(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
GetAddressAndDetailLevelFromArgs(
    PCSTR      Args,
    PULONG_PTR Address,
    PULONG     Detail
    );
VOID
ParseArguments(
    PCSTR      Args,
    PULONG_PTR Address,
    PULONG     Detail,
    PVOID      Block
    );
VOID
xdprintf(
    LONG  Depth,
    PCCHAR S,
    ...
    );
////////////////////////////////////////////////////////////////////////////////


DECLARE_API(ext)
/*++

Routine Description:
    Dumps the device extension for a given device object, or dumps the
    given device extension

--*/

{
    ULONG_PTR address;
    ULONG detail = 0;
    UCHAR block[sizeof(REDBOOK_DEVICE_EXTENSION)];

    ParseArguments(args, &address, &detail, block);

    if (address == 0) {
        return;
    }

    DumpRedBookExtension(block, address, detail, 0);
    return;
}


DECLARE_API(toc)
/*++

Routine Description:
    Dumps the device extension for a given device object, or dumps the
    given device extension

--*/

{
    ULONG_PTR address;
    ULONG detail = 0;
    UCHAR block[sizeof(CDROM_TOC)];
    ULONG result;

    GetAddressAndDetailLevelFromArgs(args, &address, &detail);

    if (address == 0) {
        return;
    }

    if(!ReadMemory(address, block, sizeof(CDROM_TOC), &result)) {
        xdprintf(0, "Error reading CDROM_TOC at address %p\n", address);
        return;
    }

    DumpToc(block, address, detail, 0);
    return;
}

DECLARE_API(context)
/*++

Routine Description:
    Dumps the device extension for a given device object, or dumps the
    given device extension

--*/

{
    ULONG_PTR address;
    ULONG detail = 0;
    UCHAR block[sizeof(REDBOOK_COMPLETION_CONTEXT)];
    ULONG result;

    GetAddressAndDetailLevelFromArgs(args, &address, &detail);

    if (address == 0) {
        return;
    }

    if(!ReadMemory(address, block, sizeof(REDBOOK_COMPLETION_CONTEXT), &result)) {
        xdprintf(0, "Error reading CDROM_TOC at address %p\n", address);
        return;
    }

    DumpContext(block, address, detail, 0);
    return;
}



DECLARE_API(silence)
{
    ULONG_PTR silenceAddress;
    ULONG silence;
    ULONG result;

    UCHAR * silenceString = "redbook!RedBookForceSilence";

    silenceAddress = (ULONG_PTR) GetExpression(silenceString);

    if (!silenceAddress) {

        dprintf(
            "Unable to get address of %s\n"
            "It could be that redbook is not loaded,"
            "was build FRE, or the symbols are wrong\n",
            silenceString
            );
        return;

    }

    if (!ReadMemory(silenceAddress, &silence, sizeof(ULONG), &result)) {

        dprintf("Unable to read current value for silence (%p)!\n",
                silenceAddress);
        return;

    }

    //
    // allow them to provide an argument?
    //

    if (args[0]) {

        silence = (ULONG) GetExpression(args);
        dprintf("Setting ForceSilence %s\n", (silence?"on":"off"));

    } else {

        dprintf("Toggling ForceSilence from %s to %s\n",
                (silence?"on":"off"),
                (silence?"off":"on"));
        silence = (silence?0:1);

    }

    if(!WriteMemory(silenceAddress, &silence, sizeof(ULONG), &result)) {

        dprintf("Unable to set ForceSilence %s\n", (silence?"on":"off"));
        return;
    }

    return;

}


DECLARE_API(wmiperfclear)
{
    ULONG_PTR address;
    ULONG detail = 0;
    ULONG result;
    UCHAR block[sizeof(REDBOOK_DEVICE_EXTENSION)];
    PREDBOOK_DEVICE_EXTENSION deviceExtension;

    ParseArguments(args, &address, &detail, block);

    if (address == 0) {
        return;
    }

    deviceExtension = (PREDBOOK_DEVICE_EXTENSION)block;
    deviceExtension->WmiPerf.TimeReadDelay     = 0;
    deviceExtension->WmiPerf.TimeReading       = 0;
    deviceExtension->WmiPerf.TimeStreamDelay   = 0;
    deviceExtension->WmiPerf.TimeStreaming     = 0;
    deviceExtension->WmiPerf.DataProcessed     = 0;
    deviceExtension->WmiPerf.StreamPausedCount = 0;

    if(!WriteMemory(address, (PVOID)block, sizeof(REDBOOK_DEVICE_EXTENSION), &result)) {
        xdprintf(0, "Error writing redbook wmi data to address %p\n", address);
        return;
    }
    return;

}

////////////////////////////////////////////////////////////////////////////////


PUCHAR ErrorText[REDBOOK_ERR_MAXIMUM] = {
    "Errors Reading Raw Audio",
    "Errors Streaming Raw Audio",
    "Errors opening SysAudio Mixer",
    "Errors creating virtual source",
    "Errors opening preferred waveout device",
    "Errors getting number of pins on waveout device",
    "Errors connecting to playback pins on waveout device",
    "Errors initializing WMI",
    "Errors creating thread",
    "Warning due to insufficient data (stream paused)",
    "This is an unsupported drive"
};

VOID
DumpRedBookErrors(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_DEVICE_EXTENSION DeviceExtension = X;
    ULONG_PTR errorCountAddress;
    ULONG tmp;
    ULONG errors[REDBOOK_ERR_MAXIMUM] = {0};

    Depth += INDENT;

    errorCountAddress =
        (ULONG_PTR)((PUCHAR)Address +
                    FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION, ErrorLog.RCount[0]));

    xdprintf(Depth, "%x Errors Reported.  Error Counts at %p\n",
             DeviceExtension->ErrorLog.Count, errorCountAddress);

    if (!ReadMemory(errorCountAddress, errors, sizeof(errors), &tmp)){
        xdprintf(Depth, "Unable to read error information\n");
        return;
    }

    Depth += INDENT;

    for (tmp = 0; tmp < REDBOOK_ERR_MAXIMUM; tmp++) {
        if (errors[tmp] != 0) {
            xdprintf(Depth, "%2x - %s\n", errors[tmp], ErrorText[tmp]);
        }
    }

    Depth -= INDENT;

}
////////////////////////////////////////////////////////////////////////////////


VOID
DumpRedBookExtension(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_DEVICE_EXTENSION DeviceExtension = X;

    Depth += INDENT;

    dprintf("\n");

    xdprintf(Depth, "Device Extension at %p\n", Address);
    xdprintf(Depth, "TargetDevObj %p  TargetPdo %p  SelfDevObj %p\n",
             DeviceExtension->TargetDeviceObject,
             DeviceExtension->TargetPdo,
             DeviceExtension->SelfDeviceObject);
    xdprintf(Depth, "PNP: CurrentState %x  PreviousState %x\n",
             DeviceExtension->Pnp.CurrentState,
             DeviceExtension->Pnp.PreviousState);
    xdprintf(Depth, "     RemovePending %x  IoRemoveLock %p\n",
             DeviceExtension->Pnp.RemovePending,
             Address+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION, RemoveLock));
    xdprintf(Depth, "WmiLibInfo: %p  (%x bytes)  Paging Path Count: %x\n",
             Address+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION, WmiLibInfo),
             sizeof(WMILIB_CONTEXT),
             DeviceExtension->PagingPathCount);

    dprintf("\n");

    DumpRedBookErrors(X, Address, Detail, Depth);


    DumpRedBookCdromInfo((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,CDRom),
                         Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,CDRom),
                         Detail,
                         Depth
                         );
    DumpRedBookStreamData((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Stream),
                          Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Stream),
                          Detail,
                          Depth
                          );
    DumpRedBookThreadData((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Thread),
                          Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Thread),
                          Detail,
                          Depth
                          );
    DumpRedBookWmiData((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,WmiData),
                       Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,WmiData),
                       Detail,
                       Depth
                       );
    DumpRedBookWmiPerf((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,WmiPerf),
                       Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,WmiPerf),
                       Detail,
                       Depth
                       );
    DumpRedBookBufferData((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Buffer),
                          Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Buffer),
                          Detail,
                          Depth
                          );
#if DBG
    if (Detail) {

        ULONG Index;
        ULONG i;
        PUCHAR savedIo;

        Index = DeviceExtension->SavedIoCurrentIndex + (SAVED_IO_MAX - 1);
        Index %= SAVED_IO_MAX;

        savedIo = (PUCHAR)Address;
        savedIo += FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,SavedIo[0].IrpWithoutStack);

        xdprintf(Depth, "Irp History: \n");

        for (i=0; i < SAVED_IO_MAX; i++) {

            ULONG realIndex;

            realIndex = Index + i;
            realIndex %= SAVED_IO_MAX;

            xdprintf(Depth, "Irp %p:  !irp %p\n",
                     DeviceExtension->SavedIo[realIndex].OriginalIrp,
                     savedIo + (sizeof(SAVED_IO) * realIndex)
                     );

        }

    }
#endif
    dprintf("\n");
    return;
}


VOID
DumpRedBookCdromInfo(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_CDROM_INFO Cdrom = X;

    xdprintf(Depth, "CDROM INFO at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "CachedToc %p  MediaChangeCount %x\n",
             Cdrom->Toc,
             Cdrom->CheckVerify);
    DumpFlags(Depth, "CdState", Cdrom->StateNow, CdFlags);
    xdprintf(Depth, "Sector information:\n");
    xdprintf(Depth, "NextToRead %x  NextToStream %x  FinishedStreaming %x\n",
             Cdrom->NextToRead,
             Cdrom->NextToStream,
             Cdrom->FinishedStreaming);
    xdprintf(Depth, "EndPlay %x  ReadErrors %x  StreamErrors %x\n",
             Cdrom->EndPlay,
             Cdrom->ReadErrors,
             Cdrom->StreamErrors);
    xdprintf(Depth, "Volume for ports 0-3:  %x %x %x %x\n",
             Cdrom->Volume.PortVolume[0],
             Cdrom->Volume.PortVolume[1],
             Cdrom->Volume.PortVolume[2],
             Cdrom->Volume.PortVolume[3]);

    Depth -= INDENT;

    return;
}


VOID
DumpRedBookWmiData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_WMI_STD_DATA WmiData = X;

    xdprintf(Depth, "WMIDATA at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "Number of buffers: %x\n",
             WmiData->NumberOfBuffers
             );

    xdprintf(Depth, "Sectors: Per Read %x  Mask %x  Maximum\n",
             WmiData->SectorsPerRead,
             WmiData->SectorsPerReadMask,
             WmiData->MaximumSectorsPerRead
             );
    xdprintf(Depth, "Enabled %x  CDDASupported %x  CDDAAccurate %x\n",
             WmiData->PlayEnabled,
             WmiData->CDDASupported,
             WmiData->CDDAAccurate
             );

    Depth -= INDENT;

    return;
}


VOID
DumpRedBookWmiPerf(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_WMI_PERF_DATA WmiPerf = X;

    xdprintf(Depth, "WMIPERF at %p\n", Address);

    //
    // problems printing the info below.
    // it actually crashes the debugger.
    //


    Depth += INDENT;

    xdprintf(Depth, "ReadDelay %I64x      Reading %I64x\n",
             WmiPerf->TimeReadDelay,
             WmiPerf->TimeReading
             );
    xdprintf(Depth, "StreamDelay %I64x    Streaming %I64x\n",
             WmiPerf->TimeStreamDelay,
             WmiPerf->TimeStreaming
             );
    xdprintf(Depth, "DataProcessed %I64x  StreamPausedCount %x\n",
             WmiPerf->DataProcessed,
             WmiPerf->StreamPausedCount
             );
    return;

#if 0
    if (WmiPerf->DataRead != 0) {
        xdprintf( Depth, "\n" );
        xdprintf( Depth, "     stat                seconds\n" );
        xdprintf( Depth, "-------------  -----------------------------\n" );

#define TIME_FORMAT_STRINGa "%12s:  %7I64d.%-02I64d\n"
#define TIME_FORMAT_STRING  "%12s:  %7I64d.%-07I64d\n"
#define UNITS_PER_SECOND ((LONG64)10000000)

        xdprintf( Depth, TIME_FORMAT_STRINGa,
                  "audio data",
                  WmiPerf->DataRead / (RAW_SECTOR_SIZE * 75),
                  (WmiPerf->DataRead / RAW_SECTOR_SIZE) % 75
                  );

        //
        // what is the approximate transfer speed of the drive?
        // in kb/s, but actually calculated as b/(s / 1024^2)
        //

        tempStat = WmiPerf->DataRead / 0x00000400;           // kb
        xdprintf( Depth, " Kbytes read: %I64d\n", tempStat );
        xdprintf( Depth, "     seconds: %I64d . %I64d\n",
                  WmiPerf->TimeReading / UNITS_PER_SECOND,
                  WmiPerf->TimeReading % UNITS_PER_SECOND
                  );
        //
        // need to keep the numbers large, so:
        //

        tempStat  = WmiPerf->TimeReading;
        tempStat /= (UNITS_PER_SECOND / 0x00000400);

        xdprintf( Depth, "   approx drive speed: %I64d kb/s\n",
                  WmiPerf->DataRead / tempStat );

        tempStat  = WmiPerf->TimeReading +
            WmiPerf->TimeReadDelay +
            WmiPerf->TimeStreamDelay;
        tempStat /= (UNITS_PER_SECOND / 0x00000400);

        xdprintf( Depth, "effective drive speed: %I64d kb/s\n",
                  WmiPerf->DataRead / tempStat );

/*
        tempStat /= WmiPerf->TimeReading / UNITS_PER_SECOND; // per second
        xdprintf( Depth, "Approximate drive speed: %I64d kb/s\n", tempStat );

        xdprintf( Depth, TIME_FORMAT_STRING
                  "reading",
                  WmiPerf->TimeReading / UNITS_PER_SECOND,
                  WmiPerf->TimeReading % UNITS_PER_SECOND
                  );
        xdprintf( Depth, TIME_FORMAT_STRING
                  "streaming",
                  WmiPerf->TimeStreaming / UNITS_PER_SECOND,
                  WmiPerf->TimeStreaming % UNITS_PER_SECOND
                  );
        xdprintf( Depth, TIME_FORMAT_STRING
                  "read delay",
                  WmiPerf->TimeReadDelay / UNITS_PER_SECOND,
                  WmiPerf->TimeReadDelay % UNITS_PER_SECOND
                  );
        xdprintf( Depth, TIME_FORMAT_STRING
                  "stream delay",
                  WmiPerf->TimeStreaming / UNITS_PER_SECOND,
                  WmiPerf->TimeStreaming % UNITS_PER_SECOND
                  );
        //
        // now do some simple analysis, use seconds as unit
        //

*/
    }
    Depth -= INDENT;
    return;

#endif // 0

}


VOID
DumpRedBookBufferData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_BUFFER_DATA Buffer = X;
    ULONG numBuf;
    ULONG sectorsPerRead;
    ULONG i;
    PULONG readOk_X;
    PULONG streamOk_X;
    ULONG result;

    xdprintf(Depth, "BUFFERS at %p\n", Address);

    numBuf = CONTAINING_RECORD(X, REDBOOK_DEVICE_EXTENSION, Buffer)->WmiData.NumberOfBuffers;
    sectorsPerRead = CONTAINING_RECORD(X, REDBOOK_DEVICE_EXTENSION, Buffer)->WmiData.SectorsPerRead;

    Depth += INDENT;

    if (Buffer->ReadOk_X == NULL ||
        Buffer->StreamOk_X == NULL ||
        Buffer->Contexts == NULL) {

        xdprintf(Depth, "One of the pointers is NULL\n");
        return;

    }


    readOk_X   = (PULONG)LocalAlloc(LPTR, sizeof(ULONG)*numBuf);
    streamOk_X = (PULONG)LocalAlloc(LPTR, sizeof(ULONG)*numBuf);
    if (readOk_X == NULL ||
        streamOk_X == NULL) {
        if (readOk_X) {
            LocalFree(readOk_X);
        }
        if (streamOk_X) {
            LocalFree(streamOk_X);
        }
        xdprintf(Depth, "Can't Alloc Memory\n");
        return;
    }

    if(!ReadMemory((ULONG_PTR)(Buffer->ReadOk_X),
                   readOk_X,
                   sizeof(ULONG)*numBuf,
                   &result)) {
        xdprintf(0, "Error reading ReadOk_X\n");
        LocalFree(readOk_X);
        LocalFree(streamOk_X);
        return;
    }
    if(!ReadMemory((ULONG_PTR)(Buffer->StreamOk_X),
                   streamOk_X,
                   sizeof(ULONG)*numBuf,
                   &result)) {
        xdprintf(0, "Error reading StreamOk_X\n");
        LocalFree(readOk_X);
        LocalFree(streamOk_X);
        return;
    }

    //
    // now just parse and print
    //

    xdprintf(Depth, "SkipBuffer %p  to  %p  (%x bytes)\n",
             Buffer->SkipBuffer,
             Buffer->SkipBuffer + (RAW_SECTOR_SIZE * sectorsPerRead * numBuf),
             RAW_SECTOR_SIZE * sectorsPerRead
             );

    xdprintf(Depth, "IrpStack %x  Stream is %s\n",
             Buffer->MaxIrpStack,
             (Buffer->Paused ?
              (Buffer->FirstPause ? "in its first pause" : "paused")
              : "not paused")
             );
    xdprintf(Depth, "Silent Buffer %p  Silent Mdl %p\n",
             Buffer->SilentBuffer,
             Buffer->SilentMdl
             );

    dprintf("\n");
    xdprintf(Depth, "PRINTING %x BUFFERS (does it match?)\n", numBuf);

    xdprintf(Depth, " %8s | %10s | %8s | %8s | %8s | %8s\n",
             " Index  ",
             " Reason ",
             " Buffer ",
             "  Mdl   ",
             "  Irp   ",
             " R/S OK "
             );
    xdprintf(Depth, "----------+------------+----------+----------+----------+"
             "----------\n");

    for (i=0;i<numBuf;i++) {
        REDBOOK_COMPLETION_CONTEXT context;

        if(!ReadMemory((ULONG_PTR)(Buffer->Contexts+i),
                       &context,
                       sizeof(REDBOOK_COMPLETION_CONTEXT),
                       &result)) {
            xdprintf(0, "Error reading CompletionContext at address %p\n",
                     Buffer->Contexts + i);
        } else {

            xdprintf(Depth, "");
            dprintf(" %8x |",
                    context.Index);

            if        (context.Reason > 4) {
                dprintf(" %s |", REDBOOK_CC_STRINGS[4]);
            } else {
                dprintf(" %s |", REDBOOK_CC_STRINGS[context.Reason]);
            }

            dprintf(" %8p |",
                    context.Buffer);
            dprintf(" %8p |",
                    context.Mdl);
            dprintf(" %8p |",
                    context.Irp);
            dprintf(" %4s\n",
                    (readOk_X[i] ? "R" : (streamOk_X[i] ? "S" : "-")));
        }
    }
    dprintf("\n");
    LocalFree(readOk_X);
    LocalFree(streamOk_X);


    Depth -= INDENT;
    return;
}


VOID
DumpRedBookStreamData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_STREAM_DATA Stream = X;

    xdprintf(Depth, "STREAM DATA at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "  Pin: FileObject %p  DeviceObject %p\n",
             Stream->PinFileObject,
             Stream->PinDeviceObject);
    xdprintf(Depth, "Mixer: FileObject %p  PinId %x    VolumeNodeId %x\n",
             Stream->MixerFileObject,
             Stream->MixerPinId,
             Stream->VolumeNodeId);
    xdprintf(Depth, "Connect@ %p  Format@ %p  (%x and %x bytes)\n",
             Address+FIELD_OFFSET(REDBOOK_STREAM_DATA,Connect),
             Address+FIELD_OFFSET(REDBOOK_STREAM_DATA,Format),
             sizeof(KSPIN_CONNECT),
             sizeof(KSDATAFORMAT_WAVEFORMATEX));

    Depth -= INDENT;

    return;
}


VOID
DumpRedBookThreadData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_THREAD_DATA Thread = X;
    PUCHAR X2 = (PUCHAR)Address;

    xdprintf(Depth, "THREAD DATA at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "Handle %x  Pointer %p  ",
             Thread->SelfHandle,
             Thread->SelfPointer
             );

    if (Thread->IoctlCurrent) {
        dprintf("Current Ioctl: %p\n", Thread->IoctlCurrent);
    } else {
        dprintf("Current Ioctl: None\n");
    }

    Thread = X;  // BUGBUG - remove this, and Thread gets set to zero above?

    xdprintf(Depth, "PendingRead %x  Pending Stream %x\n",
             Thread->PendingRead,
             Thread->PendingStream
             );

    xdprintf(Depth, "IoctlList:");
    DumpList(X2 + FIELD_OFFSET(REDBOOK_THREAD_DATA, IoctlList));
    dprintf("\n");

    xdprintf(Depth, "WmiList:");
    DumpList(X2 + FIELD_OFFSET(REDBOOK_THREAD_DATA, WmiList));
    dprintf("\n");

    xdprintf(Depth, "DigitalList:");
    DumpList(X2 + FIELD_OFFSET(REDBOOK_THREAD_DATA, DigitalList));
    dprintf("\n");

    Depth -= INDENT;
}


VOID
xdprintf(
    LONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    LONG i;
    CCHAR DebugBuffer[256] = {0};

    // Tree output as follows:
    //
    // +- Item
    // |
    //
    //

    for (i=0;i<Depth;i++) {
        dprintf(" ");
    }

    va_start(ap, S);

    _vsnprintf(DebugBuffer, sizeof(DebugBuffer)-1, S, ap);

    dprintf (DebugBuffer);

    va_end(ap);
}


VOID
DumpFlags(
    LONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;
    UCHAR prolog[64] = {0};

    _snprintf(prolog, sizeof(prolog)-1, "%s (0x%08x): ", Name, Flags);

    xdprintf(Depth, "%s", prolog);

    if(Flags == 0) {
        dprintf("NONE\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %lx\n", prolog, (Flags & (~mask)));
    }

    return;
}



VOID
DumpList(
    PVOID AddressOfListHead
    )
{
    LIST_ENTRY listHead;
    LIST_ENTRY current;
    LIST_ENTRY slow;
    ULONG result;
    BOOLEAN advanceSlowList;

    if (!ReadMemory((ULONG_PTR)AddressOfListHead,
                    &listHead,
                    sizeof(LIST_ENTRY),
                    &result)) {
        dprintf("Unable to read head of list at %p", AddressOfListHead);
        return;
    }

    slow = listHead;
    current = listHead;
    advanceSlowList = FALSE;

    if (current.Flink == AddressOfListHead) {
        dprintf("Empty");
        return;
    }

    //
    // list is empty when FLink points is AddressOfListHead
    // list is looping when Current.BLink == Slow.Blink
    //


    while (!CheckControlC()) {

        if (current.Flink == AddressOfListHead) {
            return;
        }

        //
        // print it
        //

        dprintf(" %p", current.Flink);

        //
        // advance the list pointers
        //

        if (!ReadMemory((ULONG_PTR)current.Flink,
                        &current,
                        sizeof(LIST_ENTRY),
                        &result)) {
            dprintf(" !! Unable to read memory at %p", AddressOfListHead);
            return;
        }
        if (advanceSlowList) {
            // won't fail since current already read this in successfully
            ReadMemory((ULONG_PTR)slow.Flink,
                       &slow,
                       sizeof(LIST_ENTRY),
                       &result);
        }
        advanceSlowList = !advanceSlowList;

        //
        // check for loops
        //

        if (current.Blink == slow.Blink) {
            dprintf(" !! List %p has a loop!", AddressOfListHead);
            return;
        }

    }
    //
    // should always exit from above loop
    //
}

VOID
GetAddressAndDetailLevelFromArgs(
    PCSTR      Args,
    PULONG_PTR Address,
    PULONG     Detail
    )
{
    UCHAR addressBuffer[256] = {0};
    UCHAR detailBuffer[256] = {0};

    /*
     *  Prevent overrun on the output by limitting the length of the input that we process.
     */
    _snscanf(Args, sizeof(addressBuffer)-1, "%s %s", addressBuffer, detailBuffer);

    *Address = 0;
    *Detail  = 0;

    if (addressBuffer[0] != '\0') {

        //
        // they provided an address
        //

        *Address = (ULONG_PTR) GetExpression(addressBuffer);

        //
        // if that still doesn't parse, print an error
        //

        if (*Address==0) {

            dprintf("An error occured trying to evaluate the address\n");
            *Address = 0;
            *Detail = 0;
            return;

        }

        //
        // if they provided a detail level get it.
        //

        if (detailBuffer[0] == '\0') {

            *Detail = 0;

        } else {

            *Detail = (ULONG) GetExpression(detailBuffer);

        }
    }

}


VOID
ParseArguments(
    PCSTR      Args,
    PULONG_PTR Address,
    PULONG     Detail,
    PVOID      Block        // must be sizeof(REDBOOK_DEVICE_EXTENSION) long
    )
{
    ULONG result;
    DEVICE_OBJECT deviceObject = {0};

    GetAddressAndDetailLevelFromArgs(Args, Address, Detail);

    //
    // grab this thing as a device object.  If it's type field matches what
    // we expect then adjust address to point to the actual device extension
    //

    if(!ReadMemory(*Address, &deviceObject, sizeof(DEVICE_OBJECT), &result)) {
        xdprintf(0, "Error reading data at address %p\n", *Address);
        *Address = 0;
        return;
    }

    if(deviceObject.Type == IO_TYPE_DEVICE) {
        *Address = (ULONG_PTR)deviceObject.DeviceExtension;

        //
        // now get the device extension
        //
        if(!ReadMemory(*Address, Block, sizeof(REDBOOK_DEVICE_EXTENSION), &result)) {
            xdprintf(0, "Error reading device extension at address %p\n", *Address);
            *Address = 0;
            return;
        }
    }
    else {
        *Address = 0;
    }
    
    return;
}

VOID
DumpToc(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PCDROM_TOC Toc = X;
    PTRACK_DATA trackData;
    ULONG numberOfTracks;
    ULONG i;

    numberOfTracks = Toc->LastTrack - Toc->FirstTrack;

    xdprintf(Depth, "TOC at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "Key for Control Field:\n");
    xdprintf(Depth, "    P   - Preemphasis\n");
    xdprintf(Depth, "    C   - Copy Protect\n");
    xdprintf(Depth, "    D,A - Data or Audio Track\n");
    xdprintf(Depth, "    #   - Number of Audio Channels\n\n");


    xdprintf(Depth, "FirstTrack %x  LastTrack %x  NumberOfTracks %x  Size: %x\n",
             Toc->FirstTrack,
             Toc->LastTrack,
             numberOfTracks,
             (Toc->Length[0] << 8) | (Toc->Length[1])
             );

    xdprintf(Depth, "Index   Track   Control   MSF        Address\n");
    xdprintf(Depth, "---------------------------------------------\n");

    for (i=0,trackData = Toc->TrackData;
         (!CheckControlC()) && i<numberOfTracks+2; // lead-in, lead-out track
         i++,trackData++) {

        ULONG lba;
        UCHAR m,s,f;

        if (trackData->Reserved || trackData->Reserved1) {
            xdprintf(Depth, "TrackData[%x] has reserved fields filled in. "
                     "Most likely not a TOC\n", i);
            return;
        }

        lba =
            (trackData->Address[0] << 24) |
            (trackData->Address[1] << 16) |
            (trackData->Address[2] <<  8) |
            (trackData->Address[3] <<  0);
        LBA_TO_MSF(lba, m, s, f);

        m = s = f = 0;

        xdprintf(Depth, " %2x      %2x     %s %s %s %s   %02x:%02x:%02x   0x%06x\n",
                 i,
                 trackData->TrackNumber,
                 TEST_FLAG(trackData->Control, AUDIO_WITH_PREEMPHASIS) ? "P" : "-",
                 TEST_FLAG(trackData->Control, DIGITAL_COPY_PERMITTED) ? "C" : "-",
                 TEST_FLAG(trackData->Control, AUDIO_DATA_TRACK)       ? "D" : "A",
                 TEST_FLAG(trackData->Control, TWO_FOUR_CHANNEL_AUDIO) ? "4" : "2",
                 m, s, f, lba
                 );
    }



    Depth -= INDENT;

    return;
}


VOID
DumpContext(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_COMPLETION_CONTEXT Context = X;
    ULONG i;

    xdprintf(Depth, "Context %x for devext %p at %p\n",
             Context->Index, Context->DeviceExtension, Address);

    Depth += INDENT;

    if (Context->ListEntry.Flink != Context->ListEntry.Blink) {

        if (Context->Reason <= 4) {
            xdprintf(Depth, "Context is queued for %s\n",
                     REDBOOK_CC_STRINGS[ Context->Reason ]);
        } else {
            xdprintf(Depth, "Context is queued for %s\n",
                     REDBOOK_CC_STRINGS[ 4 ]);
        }

    }

    xdprintf(Depth, "\\");

    for (i=0;i<2000;i++) {
        UCHAR array[5] = "|/-\\";

        dprintf("\b%c", array[ i%4 ]);
    }

    dprintf("\b \n");

    xdprintf(Depth, "Irp %p  Buffer %p  Mdl %p\n",
             Context->Irp, Context->Buffer, Context->Mdl);

    xdprintf(Depth,
             "KSSTREAM Header at %p\n",
             Address + FIELD_OFFSET(REDBOOK_COMPLETION_CONTEXT, Header)
             );
    xdprintf(Depth,
             "Size              = %x\n",
             Context->Header.Size
             );
    xdprintf(Depth,
             "TypeSpecificFlags = %x\n",
             Context->Header.TypeSpecificFlags
             );
    xdprintf(Depth,
             "Duration          = %I64x\n",
             Context->Header.Duration
             );
    xdprintf(Depth,
             "FrameExtent       = %x\n",
             Context->Header.FrameExtent
             );
    xdprintf(Depth,
             "DataUsed          = %x\n",
             Context->Header.DataUsed
             );
    xdprintf(Depth,
             "Data              = %p\n",
             Context->Header.Data
             );
    xdprintf(Depth,
             "OptionsFlags      = %x\n",
             Context->Header.OptionsFlags
             );
    xdprintf(Depth,
             "PresentationTime.Time        = %I64x\n",
             Context->Header.PresentationTime.Time
             );
    xdprintf(Depth,
             "PresentationTime.Numerator   = %x\n",
             Context->Header.PresentationTime.Numerator
             );
    xdprintf(Depth,
             "PresentationTime.Denominator = %x\n",
             Context->Header.PresentationTime.Denominator
             );


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\sbp2kdx\sbp2kdx.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sbp2kdx.c

Abstract

    Kernel debugger extension dll for sbp2port.sys (1394 sbp2 protocol driver)

Author:

    Dan Knudson (dankn) 25 Jun 1999

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntverp.h>
#include <windows.h>
#include <ntosp.h>
#include <wdbgexts.h>
#include <sbp2port.h>

//
// Utility routine prototypes
//

void
DisplayAddressContext(
    char               *Name,
    PADDRESS_CONTEXT    Context,
    char               *Indent
    );

void
DisplayAsyncContextFlags(
    ULONG   Flags
    );

void
DisplayDeviceFlags(
    ULONG   Flags
    );

void
DisplayDeviceInformation(
    PDEVICE_INFORMATION     Info,
    ULONG                   Index
    );

void
DisplayLeaf(
    char           *Name,
    PTEXTUAL_LEAF   Leaf,
    char           *Indent
    );

void
DisplayStatusFifoBlock(
    char               *Name,
    PSTATUS_FIFO_BLOCK  Block
    );


//
//  Global variables
//

char                    Indent0[] = "", Indent1[] = "  ", Indent2[] = "    ";
EXT_API_VERSION         ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;
BOOLEAN                 Verbose, OrbFields;

char *Help[] =
{
    "\n",

    "    *** SBP2PORT.SYS Debugger Extensions ***\n\n",

    "Command                  Displays...\n",
    "---------------------------------------------------------------\n",
    "arc    <addr>            async request context\n",
    "fdoext <fdo> [-v]        fdo device extension (-v = verbose)\n",
    "help                     this\n",
    "pdoext <pdo> [-v] [-o]   pdo device extension (-o = Orb fields)\n\n",

    "NOTE: ' !devnode 0 1 ohci1394 ' shows the pdo device stack\n",
    "NOTE: pdoext.BusFdo shows the fdo address\n",

    "\n",
    NULL
};


BOOL
WINAPI
DLLMain(
    HINSTANCE   hInstance,
    ULONG       ulReason,
    LPVOID      pvReserved
    )
{
    return (TRUE);

}


void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )
{
    ExtensionApis = *pExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}


void
CheckVersion(
    void
    )
{
    // no-op?
}


LPEXT_API_VERSION
ExtensionApiVersion(
    void
    )
{
    return (&ApiVersion);
}


DECLARE_API(arc)
{
    ULONG                   bytesRead;
    ULONG_PTR               p;
    ASYNC_REQUEST_CONTEXT   context, *pcontext;


    dprintf ("\n");

    if (args[0] == 0)
    {
        dprintf ("usage: arc <address> \n\n");
        return;
    }

    sscanf (args, "%lx", &p);

    if (!ReadMemory (p, &context, sizeof (context), &bytesRead))
    {
        dprintf ("Unable to read context\n\n");
        return;
    }

    if (bytesRead < sizeof (context))
    {
        dprintf(
            "Only read %d bytes of context, expected %d\n\n",
            bytesRead,
            sizeof (context)
            );

        return;
    }

    OrbFields = TRUE; // so address context below will get displayed

    // BUGUG  validation? like :  if (context.Tag != SBP2_ASYNC_CONTEXT_TAG)

    pcontext = (PASYNC_REQUEST_CONTEXT) p;

    dprintf ("&OrbList              = x%p\n", &pcontext->OrbList);
    dprintf ("  Flink               = x%p\n", context.OrbList.Flink);
    dprintf ("  Blink               = x%p\n", context.OrbList.Blink);
    dprintf ("&LookasideList        = x%p\n", &pcontext->LookasideList);
    dprintf ("  Next                = x%p\n", context.LookasideList.Next);
    dprintf ("Tag                   = x%x\n", context.Tag);
    dprintf ("DeviceObject          = x%p\n", context.DeviceObject);
    dprintf ("Srb                   = x%p\n", context.Srb);

    DisplayAsyncContextFlags (context.Flags);

    dprintf ("CmdOrb                = x%p\n", context.CmdOrb);
    dprintf ("CmdOrbAddress         = x%x%08x\n", context.CmdOrbAddress.u.HighQuad, context.CmdOrbAddress.u.LowQuad);
    dprintf ("PartialMdl            = x%p\n", context.PartialMdl);
    dprintf ("RequestMdl            = x%p\n", context.RequestMdl);
    dprintf ("PageTableContext\n");
    dprintf ("  MaxPages            = x%x\n", context.PageTableContext.MaxPages);
    dprintf ("  NumberOfPages       = x%x\n", context.PageTableContext.NumberOfPages);
    dprintf ("  PageTable           = x%p\n", context.PageTableContext.PageTable);

    DisplayAddressContext ("  AddressContext\n", &context.PageTableContext.AddressContext, Indent2);

    dprintf ("DataMappingHandle     = x%p\n", context.DataMappingHandle);
    dprintf ("Packet                = x%p\n", context.Packet);

    dprintf ("\n");
}


DECLARE_API(fdoext)
{
    ULONG                   bytesRead, i;
    ULONG_PTR               p;
    DEVICE_OBJECT           obj;
    FDO_DEVICE_EXTENSION    ext;


    dprintf ("\n");


    //
    // Get the fdo pointer & any args from the cmd line
    //

    if (args[0] == 0)
    {
        dprintf ("usage: fdoext <fdo address> [-v]\n\n");
        return;
    }

    sscanf (args, "%lx", &p);

    Verbose = (BOOLEAN) strstr (args, "-v");


    //
    // Read the DEVICE_OBJECT to retrieve the device extension pointer
    //

    if (!ReadMemory (p, &obj, sizeof (obj), &bytesRead))
    {
        dprintf ("Unable to read pdo\n\n");
        return;
    }

    if (bytesRead < sizeof (obj))
    {
        dprintf(
            "Only read %d bytes of pdo, expected %d\n\n",
            bytesRead,
            sizeof (obj)
            );

        return;
    }

    p = (ULONG_PTR) obj.DeviceExtension;


    //
    // Read the device extension
    //

    if (!ReadMemory (p, &ext, sizeof (ext), &bytesRead))
    {
        dprintf ("Unable to read pdo extension\n\n");
        return;
    }

    if (bytesRead < sizeof (ext))
    {
        dprintf(
            "Only read %d bytes of fdo extension, expected %d\n\n",
            bytesRead,
            sizeof (ext)
            );

        return;
    }

    if (ext.Type != SBP2_FDO)
    {
        dprintf ("Not a fdo extension (ext.Type=x%x)\n\n", ext.Type);
        return;
    }


    //
    // Display the extension fields
    //

    dprintf ("DeviceObject          = x%p\n", ext.DeviceObject);
    dprintf ("LowerDeviceObject     = x%p\n", ext.LowerDeviceObject);

    DisplayDeviceFlags (ext.DeviceFlags);

    dprintf ("ConfigRom\n");
    dprintf ("  CR_Info             = x%x\n", ext.ConfigRom.CR_Info);
    dprintf ("  CR_Signiture        = x%x\n", ext.ConfigRom.CR_Signiture);
    dprintf ("  CR_BusInfoBlockCaps = x%x\n", ext.ConfigRom.CR_BusInfoBlockCaps);
    dprintf ("  CR_Node_UniqueID[0] = x%x\n", ext.ConfigRom.CR_Node_UniqueID[0]);
    dprintf ("  CR_Node_UniqueID[1] = x%x\n", ext.ConfigRom.CR_Node_UniqueID[1]);
    dprintf ("  CR_Root_Info        = x%x\n", ext.ConfigRom.CR_Root_Info);

    for (i = 0; i < SBP2_MAX_LUNS_PER_NODE; i++)
    {
        DisplayDeviceInformation (ext.DeviceList + i, i);
    }

    dprintf ("DeviceListSize        = x%x\n", ext.DeviceListSize);

    DisplayLeaf ("VendorLeaf", ext.VendorLeaf, Indent1);

    dprintf ("MaxClassTransferSize  = x%x\n", ext.MaxClassTransferSize);
    dprintf ("Sbp2ObjectDirectory   = x%p\n", ext.Sbp2ObjectDirectory);


    dprintf ("\n");
}


DECLARE_API(help)
{
    ULONG   i;


    for (i = 0; Help[i]; i++)
    {
        dprintf (Help[i]);
    }

    return;
}


DECLARE_API(pdoext)
{
    ULONG               bytesRead;
    ULONG_PTR           p;
    DEVICE_OBJECT       obj;
    DEVICE_EXTENSION    ext;


    dprintf ("\n");


    //
    // Get the fdo pointer & any args from the cmd line
    //

    if (args[0] == 0)
    {
        dprintf ("usage: pdoext <pdo address> [-v]\n\n");
        return;
    }

    sscanf (args, "%lx", &p);

    Verbose = (BOOLEAN) strstr (args, "-v");

    OrbFields = (BOOLEAN) strstr (args, "-o");


    //
    // Read the DEVICE_OBJECT to retrieve the device extension pointer
    //

    if (!ReadMemory (p, &obj, sizeof (obj), &bytesRead))
    {
        dprintf ("Unable to read pdo\n\n");
        return;
    }

    if (bytesRead < sizeof (obj))
    {
        dprintf(
            "Only read %d bytes of pdo, expected %d\n\n",
            bytesRead,
            sizeof (obj)
            );

        return;
    }

    p = (ULONG_PTR) obj.DeviceExtension;


    //
    // Read the device extension
    //

    if (!ReadMemory (p, &ext, sizeof (ext), &bytesRead))
    {
        dprintf ("Unable to read pdo extension\n\n");
        return;
    }

    if (bytesRead < sizeof (ext))
    {
        dprintf(
            "Only read %d bytes of pdo extension, expected %d\n\n",
            bytesRead,
            sizeof (ext)
            );

        return;
    }

    if (ext.Type != SBP2_PDO)
    {
        dprintf ("Not a pdo extension (ext.Type=x%x)\n\n", ext.Type);
        return;
    }


    //
    // Display the extension fields
    //

    dprintf ("DeviceObject          = x%p\n", ext.DeviceObject);
    dprintf ("LowerDeviceObject     = x%p\n", ext.LowerDeviceObject);

    DisplayDeviceFlags (ext.DeviceFlags);

    dprintf ("BusFdo                = x%p\n", ext.BusFdo);

    DisplayDeviceInformation (ext.DeviceInfo, 0xffffffff);

    dprintf ("MaxOrbListDepth       = %d\n", ext.MaxOrbListDepth);

    dprintf ("&PendingOrbList       = x%p\n", &((PDEVICE_EXTENSION) p)->PendingOrbList);

    if (Verbose)
    {
    dprintf ("  Flink               = x%p\n", ext.PendingOrbList.Flink);
    dprintf ("  Blink               = x%p\n", ext.PendingOrbList.Blink);
    }

    dprintf ("OrbListDepth          = %d\n", ext.OrbListDepth);
    dprintf ("CurrentKey            = x%x\n", ext.CurrentKey);
    dprintf ("LastFetchedContext    = x%p\n", ext.LastFetchedContext);
    dprintf ("NextContextToFree     = x%p\n", ext.NextContextToFree);
    dprintf ("DevicePowerState      = %d\n", (ULONG) ext.DevicePowerState);
    dprintf ("SystemPowerState      = %d\n", (ULONG) ext.SystemPowerState);
    dprintf ("PowerDeferredIrp      = x%p\n", ext.PowerDeferredIrp);
    dprintf ("DeferredPowerRequest  = x%p\n", ext.DeferredPowerRequest);
    dprintf ("PagingPathCount       = %d\n", (ULONG) ext.PagingPathCount);
    dprintf ("HibernateCount        = %d\n", (ULONG) ext.HibernateCount);
    dprintf ("CrashDumpCount        = %d\n", (ULONG) ext.CrashDumpCount);
    dprintf ("HandleCount           = %d\n", (ULONG) ext.HandleCount);
    dprintf ("IdleCounter           = x%p\n", &((PDEVICE_EXTENSION) p)->IdleCounter);

    // DueTime

    dprintf ("Reserved              = x%x (%d)\n", ext.Reserved, ext.Reserved);
    dprintf ("LastTransactionStatus = x%x\n", ext.LastTransactionStatus);
    dprintf ("ReservedMdl           = x%p\n", ext.ReservedMdl);
    dprintf ("&InquiryData          = x%p\n", &((PDEVICE_EXTENSION) p)->InquiryData);
    dprintf ("InitiatorAddressId    = x%d\n", ext.InitiatorAddressId);
    dprintf ("CurrentGeneration     = x%d\n", ext.CurrentGeneration);
    dprintf ("MaxControllerPhySpeed = x%d\n", ext.MaxControllerPhySpeed);
    dprintf ("OrbReadPayloadMask    = x%d\n", (ULONG) ext.OrbReadPayloadMask);
    dprintf ("OrbWritePayloadMask   = x%d\n", (ULONG) ext.OrbWritePayloadMask);

    if (Verbose)
    {
    dprintf ("HostControllerInformation\n");
    dprintf ("  HostCapabilities    = x%d\n", ext.HostControllerInformation.HostCapabilities);
    dprintf ("  MaxAsyncReadReq     = x%d\n", ext.HostControllerInformation.MaxAsyncReadRequest);
    dprintf ("  MaxAsyncWriteReq    = x%d\n", ext.HostControllerInformation.MaxAsyncWriteRequest);

    dprintf ("HostRoutineAPI\n");
    dprintf ("  PhysAddrMappingRtn  = x%p\n", ext.HostRoutineAPI.PhysAddrMappingRoutine);
    dprintf ("  Context             = x%p\n", ext.HostRoutineAPI.Context);
    }

    if (OrbFields)
    {
    dprintf ("TaskOrb\n");
    dprintf ("  OrbAddress          = x%x%08x\n", ext.TaskOrb.OrbAddress.u.HighQuad, ext.TaskOrb.OrbAddress.u.LowQuad);
    dprintf ("  Reserved            = x%x%08x\n", ext.TaskOrb.Reserved.u.HighQuad, ext.TaskOrb.Reserved.u.LowQuad);
    dprintf ("  OrbInfo             = x%x\n", ext.TaskOrb.OrbInfo);
    dprintf ("  Reserved1           = x%x\n", ext.TaskOrb.Reserved1);
    dprintf ("  StatusBlockAddress  = x%x%08x\n", ext.TaskOrb.StatusBlockAddress.u.HighQuad, ext.TaskOrb.StatusBlockAddress.u.LowQuad);

    dprintf ("ManagementOrb\n");
    dprintf ("  Reserved[0]         = x%x%08x\n", ext.ManagementOrb.Reserved[0].u.HighQuad, ext.ManagementOrb.Reserved[0].u.LowQuad);
    dprintf ("  Reserved[1]         = x%x%08x\n", ext.ManagementOrb.Reserved[1].u.HighQuad, ext.ManagementOrb.Reserved[1].u.LowQuad);
    dprintf ("  OrbInfo             = x%x\n", ext.ManagementOrb.OrbInfo);
    dprintf ("  Reserved1           = x%x\n", ext.ManagementOrb.Reserved1);
    dprintf ("  StatusBlockAddress  = x%x%08x\n", ext.ManagementOrb.StatusBlockAddress.u.HighQuad, ext.ManagementOrb.StatusBlockAddress.u.LowQuad);
    }

    DisplayAddressContext ("TaskOrbContext\n", &ext.TaskOrbContext, Indent1);
    DisplayAddressContext ("ManagementOrbContext\n", &ext.ManagementOrbContext, Indent1);
    DisplayStatusFifoBlock ("ManagementOrbStatusBlock\n", &ext.ManagementOrbStatusBlock);
    DisplayAddressContext ("ManagementOrbStatusContext\n", &ext.ManagementOrbStatusContext, Indent1);
    DisplayStatusFifoBlock ("TaskOrbStatusBlock\n", &ext.TaskOrbStatusBlock);
    DisplayAddressContext ("TaskOrbStatusContext\n", &ext.TaskOrbStatusContext, Indent1);
    DisplayAddressContext ("GlobalStatusContext\n", &ext.GlobalStatusContext, Indent1);

    if (Verbose)
    {
    dprintf ("LoginResponse\n");
    dprintf ("  LengthAndLoginId    = x%x\n", ext.LoginResponse.LengthAndLoginId);
    dprintf ("  Csr_Off_High        = x%x\n", ext.LoginResponse.Csr_Off_High);
    dprintf ("  Csr_Off_Low         = x%x\n", ext.LoginResponse.Csr_Off_Low);
    dprintf ("  Reserved            = x%x\n", ext.LoginResponse.Reserved);
    }

    DisplayAddressContext ("LoginRespContext\n", &ext.LoginRespContext, Indent1);

    if (Verbose)
    {
    dprintf ("&QueryLoginResponse   = x%p\n", &((PDEVICE_EXTENSION) p)->QueryLoginResponse);
    dprintf ("  LengthAndNumLogins  = x%x\n", ext.QueryLoginResponse.LengthAndNumLogins);
    dprintf ("  Elements[0]\n");
    dprintf ("    NodeAndLoginId    = x%x\n", ext.QueryLoginResponse.Elements[0].NodeAndLoginId);
    dprintf ("    EUI64             = x%x%08x\n", ext.QueryLoginResponse.Elements[0].EUI64.u.HighQuad, ext.QueryLoginResponse.Elements[0].EUI64.u.LowQuad);
    }

    // there's 3 more elements in the Elements[] array above we could display

    DisplayAddressContext ("QueryLoginRespContext\n", &ext.QueryLoginRespContext, Indent1);

    dprintf ("&StatusFifoListHead   = x%p\n", &((PDEVICE_EXTENSION) p)->StatusFifoListHead);

//    KSPIN_LOCK StatusFifoLock;

    dprintf ("StatusFifoBase        = x%p\n", ext.StatusFifoBase);

    dprintf ("&FreeContextListHead  = x%p\n", &((PDEVICE_EXTENSION) p)->FreeContextListHead);
    dprintf ("&BusReqContxtListHead = x%p\n", &((PDEVICE_EXTENSION) p)->BusRequestContextListHead);
    dprintf ("&BusReqIrpIrbListHead = x%p\n", &((PDEVICE_EXTENSION) p)->BusRequestIrpIrbListHead);

//    KSPIN_LOCK  BusRequestLock;

//    KSPIN_LOCK FreeContextLock;

    dprintf ("AsyncContextBase      = x%p\n", ext.AsyncContextBase);

    DisplayAddressContext ("OrbPoolContext\n", &ext.OrbPoolContext, Indent1);

//    KSPIN_LOCK  ExtensionDataSpinLock;
//    KDPC DeviceManagementTimeoutDpc;
//    KTIMER DeviceManagementTimer;

    dprintf ("\n");
}


//
// Utility funcs
//

void
DisplayAddressContext(
    char               *Name,
    PADDRESS_CONTEXT    pContext,
    char               *Indent
    )
{
    char   *postIndent = (Indent == Indent1 ? Indent1 : Indent0);


    if (!OrbFields)
    {
        return;
    }

    dprintf (Name);

    dprintf ("%sDeviceObject%s      = x%p\n", Indent, postIndent, pContext->DeviceObject);
    dprintf ("%sAddress%s           = x%x%08x\n", Indent, postIndent, pContext->Address.u.HighQuad, pContext->Address.u.LowQuad);
    dprintf ("%sReservedAddr%s      = x%x%08x\n", Indent, postIndent, pContext->ReservedAddr.u.HighQuad, pContext->ReservedAddr.u.LowQuad);
    dprintf ("%sAddressHandle%s     = x%p\n", Indent, postIndent, pContext->AddressHandle);
    dprintf ("%sRequestMdl%s        = x%p\n", Indent, postIndent, pContext->RequestMdl);
    dprintf ("%sTransactionType%s   = x%x\n", Indent, postIndent, pContext->TransactionType);
    dprintf ("%sReserved%s          = x%p\n", Indent, postIndent, pContext->Reserved);
}


void
DisplayAsyncContextFlags(
    ULONG   Flags
    )
{
    ULONG   i;
    char   *flagNames[] =
    {
        "TIMER_STARTED",
        "COMPLETED",
        "PAGE_ALLOC",
        "DATA_ALLOC",
        NULL
    };


    dprintf ("DeviceFlags           = x%x, ", Flags);

    for (i = 0; Flags  &&  flagNames[i]; i++)
    {
        if (Flags & (1 << i))
        {
            dprintf (flagNames[i]);

            Flags &= ~(1 << i);
        }
    }

    if (Flags)
    {
        dprintf ("<inval flag(s)=x%x>", Flags);
    }

    dprintf ("\n");
}


void
DisplayDeviceFlags(
    ULONG   Flags
    )
{
    ULONG   i;
    char   *flagNames[] =
    {
        "STOPPED ",
        "RESET_IN_PROGRESS ",
        "REMOVED ",
        "LOGIN_IN_PROGRESS ",
        "RECONNECT ",
        "CLAIMED ",
        "INITIALIZING ",
        "QUEUE_LOCKED ",
        "SPC_CMD_SET ",
        "INITIALIZED ",
        "REMOVE_PENDING ",
        "DEVICE_FAILED ",
        NULL
    };


    dprintf ("DeviceFlags           = x%x, ", Flags);

    for (i = 0; Flags  &&  flagNames[i]; i++)
    {
        if (Flags & (1 << i))
        {
            dprintf (flagNames[i]);

            Flags &= ~(1 << i);
        }
    }

    if (Flags)
    {
        dprintf ("<inval flag(s)=x%x>", Flags);
    }

    dprintf ("\n");
}


void
DisplayDeviceInformation(
    PDEVICE_INFORMATION     Info,
    ULONG                   Index
    )
{
    ULONG               bytesRead;
    DEVICE_INFORMATION  info;


    if (Index == 0xffffffff)
    {
        //
        // Called from pdoext(), Info is simple a debugee pointer, need
        // to read in the data
        //

            dprintf ("DeviceInfo            = x%p\n", Info);

        if (!Verbose)
        {
            return;
        }

        if (!ReadMemory ((ULONG_PTR) Info, &info, sizeof (info), &bytesRead))
        {
            dprintf ("  <Unable to read device information>\n");
            return;
        }

        if (bytesRead < sizeof (info))
        {
            dprintf(
                "  <Only read %d bytes of device information, expected %d>\n",
                bytesRead,
                sizeof (info)
                );

            return;
        }

        Info = &info;
    }
    else
    {
        //
        // Called from fdoext(), Info data is valid
        //

        if (!Verbose  ||  !Info->DeviceObject)
        {
            return;
        }

        dprintf ("DeviceInfo[%d]\n", Index);
    }

    dprintf ("  DeviceObject        = x%p\n", Info->DeviceObject);
    dprintf ("  Lun                 = x%x\n", Info->Lun);
    dprintf ("  CmdSetId            = x%x\n", Info->CmdSetId);
    dprintf ("  UnitCharactristics  = x%x\n", Info->UnitCharacteristics);
    dprintf ("  MgmtAgentBaseReg    = x%x%08x\n", Info->ManagementAgentBaseReg.u.HighQuad, Info->ManagementAgentBaseReg.u.LowQuad);
    dprintf ("  CsrRegisterBase     = x%x%08x\n", Info->CsrRegisterBase.u.HighQuad, Info->CsrRegisterBase.u.LowQuad);
    dprintf ("  ConfigRom           = x%p\n", Info->ConfigRom);

    // display crom

    DisplayLeaf ("  ModelLeaf", Info->ModelLeaf, Indent2);
    DisplayLeaf ("  VendorLeaf", Info->VendorLeaf, Indent2);

    dprintf ("  GenericName         = %s\n", Info->GenericName);
    dprintf ("  MaxClassXferSize    = x%x\n", Info->MaxClassTransferSize);
}


void
DisplayLeaf(
    char           *Name,
    PTEXTUAL_LEAF   Leaf,
    char           *Indent
    )
{
    char           *postIndent = (Indent == Indent1 ? Indent1 : Indent0);
    BYTE            buf[sizeof (TEXTUAL_LEAF) + SBP2_MAX_TEXT_LEAF_LENGTH];
    ULONG           bytesRead, length;
    ULONG_PTR       p = (ULONG_PTR) Leaf;
    PTEXTUAL_LEAF   leaf = (PTEXTUAL_LEAF) buf;


    dprintf ("%-22.22s= x%p\n", Name, p);

    if (Leaf  &&  Verbose)
    {
        //
        // First read in, byte swap, & display the fixed size of the leaf
        //

        if (!ReadMemory (p, buf, sizeof (*leaf), &bytesRead))
        {
            dprintf ("  <Unable to read leaf>\n");
            return;
        }

        if (bytesRead < sizeof (*leaf))
        {
            dprintf(
                "  <Only read %d bytes of leaf, expected %d>\n",
                bytesRead,
                sizeof (buf)
                );

            return;
        }

        {
            ULONG   *p = (ULONG *) &leaf->TL_CRC;

            *p = bswap (*p);
        }

        leaf->TL_Spec_Id = bswap (leaf->TL_Spec_Id);
        leaf->TL_Language_Id = bswap (leaf->TL_Language_Id);

        dprintf ("%sTL_CRC%s            = x%x\n", Indent, postIndent, (ULONG) leaf->TL_CRC);
        dprintf ("%sTL_Length%s         = x%x\n", Indent, postIndent, (ULONG) leaf->TL_Length);
        dprintf ("%sTL_Spec_Id%s        = x%x\n", Indent, postIndent, leaf->TL_Spec_Id);
        dprintf ("%sTL_Language_Id%s    = x%x\n", Indent, postIndent, leaf->TL_Language_Id);


        //
        // Now read in the whole leaf (but not more than will fit in
        // our stack buffer).  Display only the first 50 chars
        //

        length = (ULONG) (leaf->TL_Length * sizeof (QUADLET)) +
            sizeof (*leaf) - sizeof (leaf->TL_Data);

        length = (length > sizeof (buf) ? sizeof (buf) : length);

        if (!ReadMemory (p, buf, length, &bytesRead))
        {
            dprintf ("  <Unable to read variable-length portion of leaf>\n");
            return;
        }

        if (bytesRead < sizeof (*leaf))
        {
            dprintf(
                "  <Only read %d bytes of leaf, expected %d>\n",
                bytesRead,
                sizeof (buf)
                );

            return;
        }

        leaf->TL_Spec_Id = bswap (leaf->TL_Spec_Id);

        if (leaf->TL_Spec_Id  &  0x80000000) // unicode
        {
            dprintf ("%sTL_Data%s           = %ws\n", Indent, postIndent, &leaf->TL_Data);
        }
        else // ascii
        {
            dprintf ("%sTL_Data%s           = %s\n", Indent, postIndent, &leaf->TL_Data);
        }

    }
}


void
DisplayStatusFifoBlock(
    char               *Name,
    PSTATUS_FIFO_BLOCK  Block
    )
{
    if (!OrbFields)
    {
        return;
    }

    dprintf (Name);

    dprintf ("  AddressAndStatus    = x%x%08x\n", Block->AddressAndStatus.u.HighQuad, Block->AddressAndStatus.u.LowQuad);
    dprintf ("  Contents[0]         = x%x%08x\n", Block->Contents[0].u.HighQuad, Block->Contents[0].u.LowQuad);
    dprintf ("  Contents[1]         = x%x%08x\n", Block->Contents[1].u.HighQuad, Block->Contents[1].u.LowQuad);
    dprintf ("  Contents[2]         = x%x%08x\n", Block->Contents[2].u.HighQuad, Block->Contents[2].u.LowQuad);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\classkd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    classkd.c

Abstract:

    Debugger Extension Api for interpretting scsiport structures

Author:

    Peter Wieland (peterwie) 16-Oct-1995
    johnstra
    ervinp

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"


#include "classpnp.h" // #defines ALLOCATE_SRB_FROM_POOL as needed

#include "classp.h"   // Classpnp's private definitions
#include "cdrom.h"

#include "classkd.h"  // routines that are useful for all class drivers


DECLARE_API(classext)

/*++

Routine Description:

    Dumps the device extension for a given device object, or dumps the
    given device extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 devObjAddr = 0;
    ULONG64 detail = 0;
    
    ReloadSymbols("classpnp.sys");
    
    if (GetExpressionEx(args, &devObjAddr, &args))
    {
        GetExpressionEx(args, &detail, &args);
    }

    /*
     *  Read the device object and extension into the debugger's address space.
     */
    if (devObjAddr == 0){
        /*
         *  If this is the server version of classpnp with the global AllFdosList, display all class FDOs.
         */
        ClassTryShowAllFDOs((ULONG)detail);

        xdprintf(0, "\n usage: !classext <class fdo> <level [0-2]>\n\n");
    }
    else {
        CSHORT objType = GetUSHORTField(devObjAddr, "nt!_DEVICE_OBJECT", "Type");
            
        if (objType == IO_TYPE_DEVICE){
            ULONG64 devExtAddr;

            devExtAddr = GetULONGField(devObjAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
            if (devExtAddr != BAD_VALUE){
                ULONG64 commonExtAddr = devExtAddr;
                ULONG64 tmpDevObjAddr;
                BOOLEAN isFdo;

                /*
                 *  To sanity-check our device context, check that the 'DeviceObject' field matches our device object.
                 */
                tmpDevObjAddr = GetULONGField(devExtAddr, "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", "DeviceObject");
                isFdo = GetUCHARField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "IsFdo");
                if ((tmpDevObjAddr == devObjAddr) && isFdo && (isFdo != BAD_VALUE)){
                    ULONG64 fdoDataAddr;

                    fdoDataAddr = GetULONGField(devExtAddr, "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", "PrivateFdoData");
                    if (fdoDataAddr != BAD_VALUE){
                        
                        ClassDumpFdoExtensionInternal(fdoDataAddr, (ULONG)detail, 0);
                        
                        ClassDumpFdoExtensionExternal(devExtAddr, (ULONG)detail, 0);
                    }
                }
                else {
                    dprintf("%08p is not a storage class FDO (for PDO information, use !classext on the parent FDO) \n", devObjAddr);
                    dprintf(g_genericErrorHelpStr);
                }
            }
        }
        else {
            dprintf("Error: 0x%08p is not a device object\n", devObjAddr);
            dprintf(g_genericErrorHelpStr);
        }
    }
        
    return S_OK;
}


BOOLEAN ClassTryShowAllFDOs(ULONG Detail)
{
    ULONG64 allFdosListAddr;
    BOOLEAN found = FALSE;
    
    allFdosListAddr = GetExpression("classpnp!AllFdosList");
    if (allFdosListAddr){
        ULONG64 listEntryAddr = GetULONGField(allFdosListAddr, "nt!_LIST_ENTRY", "Flink");
        dprintf("\n");
        if (listEntryAddr == BAD_VALUE){
        }    
        else if (listEntryAddr == allFdosListAddr){
            dprintf("    No class FDOs found\n");
        }
        else {
            found = TRUE;
            
            do {
                ULONG64 fdoDataAddr = GetContainingRecord(listEntryAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "AllFdosListEntry");
                if (fdoDataAddr == BAD_VALUE){          
                    break;
                }
                else {
                    /*
                     *  We got the private FDO data struct.
                     *  Get the actual FDO from one of the TRANSFER_PACKETS.
                     */
                    ULONG numPackets = (ULONG)GetULONGField(fdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "NumTotalTransferPackets");
                    if ((numPackets != BAD_VALUE) && (numPackets > 0)){
                        ULONG64 xferPktListHeadAddr = GetFieldAddr(fdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "AllTransferPacketsList");
                        if (xferPktListHeadAddr == BAD_VALUE){
                            break;
                        }
                        else {
                            ULONG64 pktListEntryAddr = GetULONGField(xferPktListHeadAddr, "nt!_LIST_ENTRY", "Flink");
                            if (pktListEntryAddr == BAD_VALUE){
                                break;
                            }
                            else {
                                ULONG64 pktAddr = GetContainingRecord(pktListEntryAddr, "classpnp!_TRANSFER_PACKET", "AllPktsListEntry");
                                if (pktAddr == BAD_VALUE){
                                    break;
                                }
                                else {
                                    ULONG64 fdoAddr = GetULONGField(pktAddr, "classpnp!_TRANSFER_PACKET", "Fdo");
                                    if (fdoAddr == BAD_VALUE){
                                        break;
                                    }
                                    else {
                                        /*
                                         *  Got the FDO.  Figure out if its a paging device.
                                         */
                                        BOOLEAN isPagingDevice = FALSE;
                                        ULONG64 devExtAddr = GetULONGField(fdoAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");

                                        if (devExtAddr != BAD_VALUE)
                                        {
                                            ULONG64 commonExtAddr = devExtAddr;
                                            ULONG pagingPathCount = (ULONG)GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "PagingPathCount");

                                            if ((pagingPathCount != BAD_VALUE) && (pagingPathCount > 0))
                                            {
                                                isPagingDevice = TRUE;
                                            }
                                        }

                                        dprintf("  ' !scsikd.classext %08p '   (%c) ", fdoAddr, ((isPagingDevice) ? 'p' : ' '));
                                        ClassDumpIds(fdoAddr, 1);
                                    }    
                                }
                            }    
                        }
                    }
                    else {
                        break;
                    }
                }   
                
                listEntryAddr = GetULONGField(listEntryAddr, "nt!_LIST_ENTRY", "Flink");
            }
            while ((listEntryAddr != allFdosListAddr) && (listEntryAddr != BAD_VALUE));
            
        }
    }

    return found;
}


VOID 
ClassDumpFdoExtensionExternal(
    IN ULONG64 FdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG64 commonExtAddr = FdoExtAddr;
    ULONG64 mediaChangeInfoAddr;
    ULONG64 childPdoExtAddr;
    ULONG isRemoved;
    UCHAR isInitialized;
    ULONG removeLock;
    UCHAR currentState, previousState;
    ULONG64 lowerDevObjAddr;
    ULONG64 classDriverDataAddr;
    
    classDriverDataAddr = GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "DriverData");

    xdprintf(Depth, "\n");
    xdprintf(Depth, ""), dprintf("Classpnp _EXTERNAL_ data (ext=%08p, class DriverData=%08p):\n\n", FdoExtAddr, classDriverDataAddr);

    /*
     *  Print the media change information (which only exists for removable media like cdrom)
     */
    mediaChangeInfoAddr = GetULONGField(FdoExtAddr, "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", "MediaChangeDetectionInfo");
    if (mediaChangeInfoAddr != BAD_VALUE){
        
        if (mediaChangeInfoAddr){
            ULONG64 mediaChangeIrpAddr = GetULONGField(mediaChangeInfoAddr, "classpnp!_MEDIA_CHANGE_DETECTION_INFO", "MediaChangeIrp");
            UCHAR gesnSupported = GetUCHARField(mediaChangeInfoAddr, "classpnp!_MEDIA_CHANGE_DETECTION_INFO", "Gesn.Supported");
                            
            xdprintf(Depth+1, ""), dprintf("MEDIA_CHANGE_DETECTION_INFO @ %08p:\n", mediaChangeInfoAddr);
            if (gesnSupported){
                xdprintf(Depth+2, "GESN is supported\n");
            }
            else {
                xdprintf(Depth+2, "GESN is NOT supported\n");
            }
            xdprintf(Depth+2, ""), dprintf("MediaChangeIrp = %08p\n", mediaChangeIrpAddr);
            xdprintf(Depth+2, ""), dprintf("(for more info, use 'dt classpnp!_MEDIA_CHANGE_DETECTION_INFO %08p')\n", mediaChangeInfoAddr);
            dprintf("\n");
        }
        else {
            xdprintf(Depth+1, "MediaChangeDetectionInfo is NULL\n");
        }
    }

    /*
     *  Print the media type and geometry information
     */
    {
        ULONG64 geometryInfoAddr = GetFieldAddr(FdoExtAddr, "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", "DiskGeometry");

        if (geometryInfoAddr != BAD_VALUE){
            ULONG64 numCylinders = GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "Cylinders");
            ULONG mediaType = (ULONG)GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "MediaType");
            ULONG64 tracksPerCylinder = GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "TracksPerCylinder");
            ULONG64 sectorsPerTrack = GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "SectorsPerTrack");
            ULONG64 bytesPerSector = GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "BytesPerSector");

            if ((numCylinders != BAD_VALUE) && (mediaType != BAD_VALUE) && (tracksPerCylinder != BAD_VALUE) && (sectorsPerTrack != BAD_VALUE) && (bytesPerSector != BAD_VALUE)){
                ULONG64 totalVolume = numCylinders*tracksPerCylinder*sectorsPerTrack*bytesPerSector;
                xdprintf(Depth+1, ""), dprintf("Media type: %s(%xh)\n", DbgGetMediaTypeStr(mediaType), mediaType);
                xdprintf(Depth+1, ""), dprintf("Geometry: %d(%xh)cyl x %d(%xh)tracks x %d(%xh)sectors x %d(%xh)bytes\n",
                                                              (ULONG)numCylinders, (ULONG)numCylinders, 
                                                              (ULONG)tracksPerCylinder, (ULONG)tracksPerCylinder, 
                                                              (ULONG)sectorsPerTrack, (ULONG)sectorsPerTrack, 
                                                              (ULONG)bytesPerSector, (ULONG)bytesPerSector);
                xdprintf(Depth+1+4, ""), dprintf("= %x'%xh", (ULONG)(totalVolume>>32), (ULONG)totalVolume);
                if (totalVolume > (((ULONG64)1) << 30)){
                    dprintf(" = ~%d GB\n", (ULONG)(totalVolume >> 30));
                }
                else {
                    dprintf(" = ~%d MB\n", (ULONG)(totalVolume >> 20));
                }
            }
        }
    }

    /*
     *  Print 'IsInitialized' state.
     */
    isInitialized = GetUCHARField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "IsInitialized");
    xdprintf(Depth+1, "IsInitialized = %d\n", isInitialized);
    
    /*
     *  Print the 'IsRemoved' state.
     */
    isRemoved = (ULONG)GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "IsRemoved");
    removeLock = (ULONG)GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "RemoveLock");
    xdprintf(Depth+1, "Remove lock count = %d\n", removeLock);
    switch (isRemoved){
        #undef MAKE_CASE
        #define MAKE_CASE(remCase) case remCase: xdprintf(Depth+1, "IsRemoved = " #remCase "(%d)\n", isRemoved); break; 
        MAKE_CASE(NO_REMOVE)
        MAKE_CASE(REMOVE_PENDING)
        MAKE_CASE(REMOVE_COMPLETE)
    }

    /*
     *  Print the PnP state.
     */
    currentState = GetUCHARField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "CurrentState");
    previousState = GetUCHARField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "PreviousState");
    xdprintf(Depth+1, "PnP state:  CurrentState:"); 
    switch (currentState){
        #undef MAKE_CASE
        #define MAKE_CASE(pnpCase) case pnpCase: xdprintf(0, #pnpCase "(%xh)", pnpCase); break;
        MAKE_CASE(IRP_MN_START_DEVICE)
        MAKE_CASE(IRP_MN_STOP_DEVICE)
        MAKE_CASE(IRP_MN_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_STOP_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_STOP_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_REMOVE_DEVICE)
        default: xdprintf(0, "???(%xh)", currentState); break;
    }
    xdprintf(0, "  PreviousState:");
    switch (previousState){
        #undef MAKE_CASE
        #define MAKE_CASE(pnpCase) case pnpCase: xdprintf(0, #pnpCase "(%xh)", pnpCase); break;
        MAKE_CASE(IRP_MN_START_DEVICE)
        MAKE_CASE(IRP_MN_STOP_DEVICE)
        MAKE_CASE(IRP_MN_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_STOP_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_STOP_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_REMOVE_DEVICE)
        case 0x0FF: xdprintf(0, "(None)"); break;
        default: xdprintf(0, "???(%xh)", previousState); break;
    }
    xdprintf(0, "\n");

    /*
     *  Print target device
     */
    lowerDevObjAddr = GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "LowerDeviceObject");
    xdprintf(Depth+1, ""), dprintf("Target device=%08p\n", lowerDevObjAddr);

    /*
     *  Dump child PDO list
     */
    xdprintf(Depth+1, "Child PDOs:\n");
    childPdoExtAddr = GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "ChildList");
    while (childPdoExtAddr && (childPdoExtAddr != BAD_VALUE)){
        ULONG64 pdoAddr = GetULONGField(childPdoExtAddr, "classpnp!_PHYSICAL_DEVICE_EXTENSION", "DeviceObject");
        UCHAR isEnumerated = GetUCHARField(childPdoExtAddr, "classpnp!_PHYSICAL_DEVICE_EXTENSION", "IsEnumerated");
        UCHAR isMissing = GetUCHARField(childPdoExtAddr, "classpnp!_PHYSICAL_DEVICE_EXTENSION", "IsMissing");
        
        xdprintf(Depth+2, ""), dprintf("PDO=%08p IsEnumerated=%d IsMissing=%d\n", pdoAddr, isEnumerated, isMissing);
                
        childPdoExtAddr = GetULONGField(childPdoExtAddr, "classpnp!_PHYSICAL_DEVICE_EXTENSION", "CommonExtension.ChildList");    
    }
    dprintf("\n");
        
    dprintf("\n");
    xdprintf(Depth+2, ""), dprintf("(for more info use 'dt classpnp!_FUNCTIONAL_DEVICE_EXTENSION %08p')\n", FdoExtAddr);
    xdprintf(0, "\n");
    
}


VOID
ClassDumpFdoExtensionInternal(
    IN ULONG64 FdoDataAddr,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG64 keTickCountAddr;
    ULONG keTickCount;
    ULONG len;
    
    dprintf("\n");
    xdprintf(Depth, ""), dprintf("Classpnp _INTERNAL_ data (%08p):\n", FdoDataAddr);
    
    /*
     *  Dump TRANSFER_PACKET lists
     */
    ClassDumpTransferPacketLists(FdoDataAddr, Detail, Depth+1);

    /*
     *  Dump private error logs
     */
    ClassDumpPrivateErrorLogs(FdoDataAddr, Detail, Depth+1);          

    /*
     *  Show time at trap (for comparison with error log timestamps)
     */
    keTickCountAddr = GetExpression("nt!KeTickCount");
    if (ReadMemory(keTickCountAddr, &keTickCount, sizeof(ULONG), &len)){
        dprintf("\n");
        xdprintf(Depth+1, ""), dprintf("KeTickCount at trap time: %d.%d (%04xh)\n", (ULONG)(keTickCount/1000), (ULONG)(keTickCount%1000), keTickCount);
    }

    /*
     *  For full details on debug target, show the packet log
     */
    if (Detail >= 2) {
        ClassDumpPrivatePacketLogs(FdoDataAddr, Detail, Depth+1);
    }
    
    dprintf("\n");
    xdprintf(Depth+2, ""), dprintf("(for more info use 'dt classpnp!_CLASS_PRIVATE_FDO_DATA %08p')\n", FdoDataAddr);
        
}



VOID ClassDumpTransferPacketLists(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth)
{
    ULONG64 allxferPktsListAddr;

    /*
     *  Print transfer packet lists
     */
    allxferPktsListAddr = GetFieldAddr(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "AllTransferPacketsList");
    if (allxferPktsListAddr != BAD_VALUE){
        ULONG64 listEntryAddr;
        ULONG numTotalXferPkts = (ULONG)GetULONGField(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "NumTotalTransferPackets");
        ULONG numFreeXferPkts = (ULONG)GetULONGField(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "NumFreeTransferPackets");
        ULONG numPackets;
        char *extraSpaces = IsPtr64() ? "        " : "";
        
        /*
         *  Walk AllTransferPacketsList and print only the outstanding packets with full SRB info.
         */
        xdprintf(Depth, "\n");
        xdprintf(Depth, "Outstanding transfer packets:  (out of %d total)\n", numTotalXferPkts);
        xdprintf(Depth, "\n");
        xdprintf(Depth+1, " packet %s   irp %s     srb %s    sense %s   status \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
        xdprintf(Depth+1, "--------%s --------%s --------%s --------%s -------- \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
        numPackets = 0; 
        listEntryAddr = GetULONGField(allxferPktsListAddr, "nt!_LIST_ENTRY", "Flink");
        while ((listEntryAddr != allxferPktsListAddr) && (listEntryAddr != BAD_VALUE)){
            ULONG64 pktAddr;

            pktAddr = GetContainingRecord(listEntryAddr, "classpnp!_TRANSFER_PACKET", "AllPktsListEntry");
            if (pktAddr == BAD_VALUE){
                break;
            }
            else {
                ClassDumpTransferPacket(pktAddr, TRUE, FALSE, TRUE, Depth+1);

                numPackets++;
                listEntryAddr = GetULONGField(listEntryAddr, "nt!_LIST_ENTRY", "Flink");                
            }
        }
        if (numPackets != numTotalXferPkts){
            xdprintf(Depth, "*** Warning: NumTotalTransferPackets(%d) doesn't match length of queue(%d) ***\n", numTotalXferPkts, numPackets);
        }


        if (Detail > 0){
            ULONG64 slistEntryAddr;
            
            /*
             *  Print all transfer packets
             */
            xdprintf(Depth, "\n");
            xdprintf(Depth, "All transfer packets:  (%d total, %d free)\n", numTotalXferPkts, numFreeXferPkts);
            xdprintf(Depth, "\n");
            xdprintf(Depth+1, " packet %s   irp %s     srb %s    sense %s   status \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
            xdprintf(Depth+1, "--------%s --------%s --------%s --------%s -------- \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
            numPackets = 0; 
            listEntryAddr = GetULONGField(allxferPktsListAddr, "nt!_LIST_ENTRY", "Flink");
            while ((listEntryAddr != allxferPktsListAddr) && (listEntryAddr != BAD_VALUE)){
                ULONG64 pktAddr;

                pktAddr = GetContainingRecord(listEntryAddr, "classpnp!_TRANSFER_PACKET", "AllPktsListEntry");
                if (pktAddr == BAD_VALUE){
                    break;
                }
                else {
                    ClassDumpTransferPacket(pktAddr, TRUE, TRUE, FALSE, Depth+1);

                    listEntryAddr = GetULONGField(listEntryAddr, "nt!_LIST_ENTRY", "Flink");                
                }
            }

            /*
             *  Print free packets sList
             */
            xdprintf(Depth, "\n");
            xdprintf(Depth, "Free transfer packets in fast SLIST: (%d free)\n", numFreeXferPkts);
            if (IsPtr64()){
                xdprintf(Depth, "(Cannot display fast SLIST on 64-bit system)\n");
            }
            else {
                xdprintf(Depth+1, " packet %s   irp %s     srb %s    sense %s   status \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
                xdprintf(Depth+1, "--------%s --------%s --------%s --------%s -------- \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
                numPackets = 0;         
                slistEntryAddr = GetULONGField(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "FreeTransferPacketsList.Next.Next");
                while (slistEntryAddr && (slistEntryAddr != BAD_VALUE)){
                    ULONG64 pktAddr;

                    pktAddr = GetContainingRecord(slistEntryAddr, "classpnp!_TRANSFER_PACKET", "SlistEntry");
                    if (pktAddr == BAD_VALUE){
                        break;
                    }
                    else {
                        ClassDumpTransferPacket(pktAddr, TRUE, TRUE, FALSE, Depth+1);
                        
                        numPackets++;
                        slistEntryAddr = GetULONGField(pktAddr, "classpnp!_TRANSFER_PACKET", "SlistEntry.Next");
                    }
                }
                if (numPackets != numFreeXferPkts){
                    xdprintf(Depth, "*** Warning: NumFreeTransferPackets(%d) doesn't match length of queue(%d) ***\n", numFreeXferPkts, numPackets);
                }
            }
                
        }
                
    }

}


/*
 *  ClassDumpTransferPacket
 *
 *      Dump TRANSFER_PACKET contents under the following heading:
 *
 *      "  packet    irp      srb     sense    status "
 *      " -------- -------- -------- -------- -------- "
 *
 */
VOID ClassDumpTransferPacket(
    ULONG64 PktAddr, 
    BOOLEAN DumpPendingPkts, 
    BOOLEAN DumpFreePkts, 
    BOOLEAN DumpFullInfo, 
    ULONG Depth)
{

    ULONG64 irpAddr = GetULONGField(PktAddr, "classpnp!_TRANSFER_PACKET", "Irp");
    ULONG64 srbAddr = GetFieldAddr(PktAddr, "classpnp!_TRANSFER_PACKET", "Srb");
    ULONG64 senseAddr = GetFieldAddr(PktAddr, "classpnp!_TRANSFER_PACKET", "SrbErrorSenseData");

    if ((irpAddr == BAD_VALUE) || (srbAddr == BAD_VALUE) || (senseAddr == BAD_VALUE)){
        dprintf("\n ClassDumpTransferPacket: error retrieving contents of packet %08p.\n", PktAddr);
    }
    else {
        UCHAR currentStackLoc = GetUCHARField(irpAddr, "nt!_IRP", "CurrentLocation");
        UCHAR stackCount = GetUCHARField(irpAddr, "nt!_IRP", "StackCount");
        BOOLEAN isPending;
        
        isPending = (currentStackLoc != stackCount+1);
            
        if ((isPending && DumpPendingPkts) || (!isPending && DumpFreePkts)){
            
            /*
             *  Print the transfer packet description line
             */
            xdprintf(Depth, "");
            dprintf("%08p", PktAddr);
            dprintf(" %08p", irpAddr);
            dprintf(" %08p", srbAddr);
            dprintf(" %08p", senseAddr);
            if (isPending){
                xdprintf(0, " pending*");
            }
            else {
                xdprintf(0, " (free)");
            }
            xdprintf(0, "\n");

            if (DumpFullInfo){
                ULONG64 bufLen = GetULONGField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "DataTransferLength");
                ULONG64 cdbAddr = GetFieldAddr(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "Cdb");
                ULONG64 origIrpAddr = GetULONGField(PktAddr, "classpnp!_TRANSFER_PACKET", "OriginalIrp");
                ULONG64 mdlAddr = GetULONGField(origIrpAddr, "nt!_IRP", "MdlAddress");
                UCHAR scsiOp = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB6GENERIC.OperationCode");
                UCHAR srbStat = GetUCHARField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "SrbStatus");
                ULONG64 bufAddr;

                /*
                 *  The the buffer address from the MDL if possible; 
                 *  else from the SRB (which may not be valid).
                 */
                bufAddr = GetULONGField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "DataBuffer");
                if (mdlAddr && (mdlAddr != BAD_VALUE)){
                    ULONG mdlFlags = (ULONG)GetULONGField(mdlAddr, "nt!_MDL", "MdlFlags");
                    if ((mdlFlags != BAD_VALUE) && (mdlFlags & MDL_PAGES_LOCKED)){
                        bufAddr = GetULONGField(mdlAddr, "nt!_MDL", "MappedSystemVa");
                    }
                }
                else {
                    /*
                     *  There's no MDL, so bufAddr should be the actual kernel-space pointer.  
                     *  Sanity-check it.
                     */
                    if (!IsPtr64() && !(bufAddr & 0x80000000)){ 
                        bufAddr = BAD_VALUE;
                    }
                }
                
                /*
                 *  Print the SRB description line
                 */
                xdprintf(Depth+1, "(");
                dprintf("%s ", DbgGetScsiOpStr(scsiOp));
                dprintf("status=%s ", DbgGetSrbStatusStr(srbStat));

                if (mdlAddr && (mdlAddr != BAD_VALUE)){
                    if (bufAddr == BAD_VALUE){
                        dprintf("mdl=%08p ", mdlAddr);
                    }
                    else {
                        dprintf("mdl+%08p ", bufAddr);
                    }
                }
                else if (bufAddr == BAD_VALUE){
                        dprintf("buf=??? ");
                }
                else {
                    dprintf("buf=%08p ", bufAddr);
                }
                                
                dprintf("len=%08lx", bufLen);
                dprintf(")\n");

                /*
                 *  Print a line with original irp if appropriate
                 */
                if (cdbAddr != BAD_VALUE){ 
                    scsiOp = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB6GENERIC.OperationCode");
                    
                    if ((scsiOp == SCSIOP_READ) || (scsiOp == SCSIOP_WRITE)){
                        xdprintf(Depth+1, ""), dprintf("(OriginalIrp=%08p)\n", origIrpAddr);
                    }
                }
            }
        }
        
    }


}

    

VOID ClassDumpPrivateErrorLogs(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth)
{
    ULONG64 errLogsAddr;
    
    errLogsAddr = GetFieldAddr(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "ErrorLogs");
    if (errLogsAddr != BAD_VALUE){
        ULONG errLogSize = GetTypeSize("classpnp!_CLASS_ERROR_LOG_DATA");
        if (errLogSize != BAD_VALUE){
            ULONG nextErrLogIndex, firstErrLogIndex, lastErrLogIndex;
            
            /*
             *  Find what should be the index of the last error log (if there were any error logs)
             *  See if it is valid by checking for a non-zero timestamp.
             */
            nextErrLogIndex = (ULONG)GetULONGField(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "ErrorLogNextIndex");
            if (nextErrLogIndex != BAD_VALUE){
                ULONG64 tickCount;
                
                lastErrLogIndex = (nextErrLogIndex+NUM_ERROR_LOG_ENTRIES-1) % NUM_ERROR_LOG_ENTRIES;

                tickCount = GetULONGField(errLogsAddr+lastErrLogIndex*errLogSize, "classpnp!_CLASS_ERROR_LOG_DATA", "TickCount");                   
                if (tickCount == BAD_VALUE){
                }
                else if (tickCount == 0){
                    /*
                     *  The "latest" error log is not initialized, so there are no error logs
                     */
                    dprintf("\n"), xdprintf(Depth, "No Error Logs:\n");  
                }
                else {                    
                    /*
                     *  Search forward through the circular list for the first valid error log.
                     */
                    for (firstErrLogIndex = (lastErrLogIndex+1)%NUM_ERROR_LOG_ENTRIES;
                        firstErrLogIndex != lastErrLogIndex;
                        firstErrLogIndex = (firstErrLogIndex+1)%NUM_ERROR_LOG_ENTRIES){

                        ULONG64 thisErrLogAddr = errLogsAddr+firstErrLogIndex*errLogSize;
                        
                        tickCount = GetULONGField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "TickCount");                   
                        if (tickCount == BAD_VALUE){
                            /*
                             *  something's screwed up; abort
                             */
                            break;
                        }
                        else if (tickCount != 0){
                            /*
                             *  found the earliest of the recorded error logs, break
                             */
                            break;
                        }
                    }

                    if (tickCount != BAD_VALUE){
                        /*
                         *  Now that we've found the valid range of error logs, print them out.
                         */
                        ULONG numErrLogs = (lastErrLogIndex >= firstErrLogIndex) ? 
                                             lastErrLogIndex-firstErrLogIndex+1 :
                                             lastErrLogIndex+NUM_ERROR_LOG_ENTRIES-firstErrLogIndex+1;
                        
                        dprintf("\n\n"), xdprintf(Depth, "ERROR LOGS (%d):\n", numErrLogs);  
                        xdprintf(Depth, "---------------------------------------------------\n"); 
                        
                        do {
                            ULONG64 thisErrLogAddr = errLogsAddr+firstErrLogIndex*errLogSize;
                            ULONG64 senseDataAddr = GetFieldAddr(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "SenseData");
                            ULONG64 srbAddr = GetFieldAddr(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "Srb");
                            ULONG64 cdbAddr;

                            tickCount = GetFieldAddr(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "TickCount");

                            // GetFieldOffset of an embedded struct gets the wrong address for some reason,
                            // so do this manually.
                            #if 0
                                cdbAddr = GetFieldAddr(thisErrLogAddr, "classpnp!_SCSI_REQUEST_BLOCK", "Cdb");
                            #else
                                cdbAddr = (srbAddr == BAD_VALUE) ? BAD_VALUE :
                                          IsPtr64() ? srbAddr + 0x48 :
                                          srbAddr + 0x30;  
                            #endif
                                    

                            if ((thisErrLogAddr != BAD_VALUE) && (srbAddr != BAD_VALUE) && (senseDataAddr != BAD_VALUE) && (cdbAddr != BAD_VALUE)){                              
                                UCHAR scsiOp = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB6GENERIC.OperationCode");
                                UCHAR srbStat = GetUCHARField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "SrbStatus");
                                UCHAR scsiStat = GetUCHARField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "ScsiStatus");
                                UCHAR isPaging = GetUCHARField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "ErrorPaging");
                                UCHAR isRetried = GetUCHARField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "ErrorRetried");
                                UCHAR isUnhandled = GetUCHARField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "ErrorUnhandled");
                                
                                tickCount = GetULONGField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "TickCount");                                               

                                if ((scsiOp != BAD_VALUE) && (tickCount != BAD_VALUE)){

                                    xdprintf(Depth+1, "");
                                    dprintf("<tick %d.%d>:  ", (ULONG)(tickCount/1000), (ULONG)(tickCount%1000));
                                    dprintf("%s(%xh)\n",
                                            DbgGetScsiOpStr(scsiOp),
                                            (ULONG)scsiOp);
                                        
                                    xdprintf(Depth+2, "");
                                    dprintf("srbStat=%s(%xh) scsiStat=%xh \n",
                                            DbgGetSrbStatusStr(srbStat),
                                            (ULONG)srbStat,
                                            (ULONG)scsiStat
                                            );
                                    
                                    xdprintf(Depth+2, "");
                                    dprintf("SenseData = %s/%s/%s \n",
                                            DbgGetSenseCodeStr(srbStat, senseDataAddr),
                                            DbgGetAdditionalSenseCodeStr(srbStat, senseDataAddr),
                                            DbgGetAdditionalSenseCodeQualifierStr(srbStat, senseDataAddr));
                                    
                                    xdprintf(Depth+2, "");
                                    if (isPaging) dprintf("Paging; "); else dprintf("(not paging); ");
                                    if (isRetried) dprintf("Retried; "); else dprintf("(not retried); ");
                                    if (isUnhandled) dprintf("Unhandled; ");
                                    if ((scsiOp == SCSIOP_READ) || (scsiOp == SCSIOP_WRITE)){
                                        UCHAR lbaBytes[4], numBlocksBytes[4] = {0};
                                        ULONG lba, numBlocks;
                                        lbaBytes[3] = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB10.LogicalBlockByte0");
                                        lbaBytes[2] = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB10.LogicalBlockByte1");
                                        lbaBytes[1] = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB10.LogicalBlockByte2");
                                        lbaBytes[0] = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB10.LogicalBlockByte3");
                                        lba = *(PULONG)(PUCHAR)lbaBytes;
                                        numBlocksBytes[0] = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB10.TransferBlocksLsb");
                                        numBlocksBytes[1] = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB10.TransferBlocksMsb");
                                        numBlocks = *(PULONG)(PUCHAR)numBlocksBytes;
                                        dprintf("LBA=%xh; blocks=%xh;", lba, numBlocks);
                                    }
                                    dprintf("\n");
                                        
                                    xdprintf(Depth+2, "");
                                    dprintf("(for more info, use 'dt classpnp!_CLASS_ERROR_LOG_DATA %08p'\n\n", thisErrLogAddr);
                                    
                                    firstErrLogIndex = (firstErrLogIndex+1)%NUM_ERROR_LOG_ENTRIES;
                                }
                                else {
                                    break;
                                }
                            }
                            else {
                                break;
                            }
                        } while (firstErrLogIndex != (lastErrLogIndex+1)%NUM_ERROR_LOG_ENTRIES);
                        
                        xdprintf(Depth, "---------------------------------------------------\n");                         
                    }
                }
            }        
        }
    }


}


VOID ClassDumpPrivatePacketLogs(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth)
{
    ULONG fieldMissing;
    ULONG offset;

    /*
     *  The packet log only exists for debug targets, and only for Whistler server ~beta 3 builds and up.
     *  Don't complain if its missing.
     */
    fieldMissing = GetFieldOffset("classpnp!_CLASS_PRIVATE_FDO_DATA", "DbgPacketLogs", &offset);
    if (!fieldMissing){
        ULONG64 pktLogsAddr;
    
        pktLogsAddr = GetFieldAddr(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "DbgPacketLogs");
        if (pktLogsAddr != BAD_VALUE){
            ULONG pktSize = GetTypeSize("classpnp!_TRANSFER_PACKET");
            if (pktSize != BAD_VALUE){              
                ULONG nextPktIndex, firstPktIndex, lastPktIndex;
            
                /*
                 *  Find what should be the index of the last pkt (if there were any pkt logs)
                 *  See if it is valid by checking for a non-zero Fdo.
                 */
                nextPktIndex = (ULONG)GetULONGField(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "DbgPacketLogNextIndex");
                if (nextPktIndex != BAD_VALUE){
                    ULONG64 fdoAddr;
                
                    lastPktIndex = (nextPktIndex+DBG_NUM_PACKET_LOG_ENTRIES-1) % DBG_NUM_PACKET_LOG_ENTRIES;

                    fdoAddr = GetULONGField(pktLogsAddr+lastPktIndex*pktSize, "classpnp!_TRANSFER_PACKET", "Fdo");                   
                    if (fdoAddr == BAD_VALUE){
                    }
                    else if (fdoAddr == 0){
                        /*
                         *  The "latest" pkt log is not initialized, so there are no pkt logs
                         */
                        dprintf("\n"), xdprintf(Depth, "No Packet Logs:\n");  
                    }
                    else {                         
                        /*
                         *  Search forward through the circular list for the first valid pkt log.
                         */
                        for (firstPktIndex = (lastPktIndex+1)%DBG_NUM_PACKET_LOG_ENTRIES;
                            firstPktIndex != lastPktIndex;
                            firstPktIndex = (firstPktIndex+1)%DBG_NUM_PACKET_LOG_ENTRIES){

                            ULONG64 thisPktAddr = pktLogsAddr+firstPktIndex*pktSize;
                            
                            fdoAddr = GetULONGField(thisPktAddr, "classpnp!_TRANSFER_PACKET", "Fdo");                   
                            if (fdoAddr == BAD_VALUE){
                                /*
                                 *  something's screwed up; abort
                                 */
                                break;
                            }
                            else if (fdoAddr != 0){
                                /*
                                 *  found the earliest of the recorded pkt logs, break
                                 */
                                break;
                            }
                        }

                        if (fdoAddr != BAD_VALUE){
                            /*
                             *  Now that we've found the valid range of pkt logs, print them out.
                             */
                            ULONG numPktLogs = (lastPktIndex >= firstPktIndex) ? 
                                                 lastPktIndex-firstPktIndex+1 :
                                                 lastPktIndex+DBG_NUM_PACKET_LOG_ENTRIES-firstPktIndex+1;
                        
                            dprintf("\n\n"), xdprintf(Depth, "PACKET LOGS (%d):\n", numPktLogs);  
                            xdprintf(Depth, "---------------------------------------------------\n"); 
                        
                            do {
                                ULONG64 thisPktAddr = pktLogsAddr+firstPktIndex*pktSize;
                                ULONG64 srbAddr = GetFieldAddr(thisPktAddr, "classpnp!_TRANSFER_PACKET", "Srb");
                                ULONG64 cdbAddr;

                                // GetFieldOffset of an embedded struct gets the wrong address for some reason,
                                // so do this manually.
                                #if 0
                                    cdbAddr = GetFieldAddr(thisPktAddr, "classpnp!_SCSI_REQUEST_BLOCK", "Cdb");
                                #else
                                    cdbAddr = (srbAddr == BAD_VALUE) ? BAD_VALUE :
                                              IsPtr64() ? srbAddr + 0x48 :
                                              srbAddr + 0x30;  
                                #endif
                                        

                                if ((thisPktAddr != BAD_VALUE) && (srbAddr != BAD_VALUE) && (cdbAddr != BAD_VALUE)){                              
                                    UCHAR scsiOp = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB6GENERIC.OperationCode");
                                    ULONG srbFlags = (ULONG)GetULONGField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "SrbFlags");
                                    ULONG pktId = (ULONG)GetULONGField(thisPktAddr, "classpnp!_TRANSFER_PACKET", "DbgPktId");
                                    ULONG64 timeSent = GetULONGField(thisPktAddr, "classpnp!_TRANSFER_PACKET", "DbgTimeSent");
                                    ULONG64 timeReturned = GetULONGField(thisPktAddr, "classpnp!_TRANSFER_PACKET", "DbgTimeReturned");
                                    
                                    if ((scsiOp != BAD_VALUE) && (srbFlags != BAD_VALUE) && (timeSent != BAD_VALUE) && (timeReturned != BAD_VALUE) && (pktId != BAD_VALUE)){
                                        UCHAR directionIndicator = (timeReturned == 0) ? '>' : '<';
                                        
                                        xdprintf(Depth, "");
                                        dprintf("%c #%04x @%d.%d %s ",
                                                directionIndicator,
                                                pktId,
                                                (ULONG)(timeReturned ? timeReturned/1000 : timeSent/1000),
                                                (ULONG)(timeReturned ? timeReturned%1000 : timeSent%1000),
                                                DbgGetScsiOpStr(scsiOp));
                                        
                                        dprintf("(");
                                        if (srbFlags & SRB_CLASS_FLAGS_PAGING) dprintf("Paging;");
                                        if ((scsiOp == SCSIOP_READ) || (scsiOp == SCSIOP_WRITE)){
                                            ULONG numRetries = (ULONG)GetULONGField(thisPktAddr, "classpnp!_TRANSFER_PACKET", "NumRetries");
                                            if ((numRetries != BAD_VALUE) && (numRetries < MAXIMUM_RETRIES)){
                                                dprintf("I/O Retry %d/%d;", MAXIMUM_RETRIES-numRetries, MAXIMUM_RETRIES);
                                            }
                                        }      
                                        dprintf(")\n");

                                        xdprintf(Depth, "");
                                        dprintf("%27s ' dt classpnp!_TRANSFER_PACKET %08p '\n", "", thisPktAddr);
                                                                                
                                        firstPktIndex = (firstPktIndex+1)%DBG_NUM_PACKET_LOG_ENTRIES;
                                    }
                                    else {
                                        break;
                                    }
                                }
                                else {
                                    break;
                                }
                            } while (firstPktIndex != (lastPktIndex+1)%DBG_NUM_PACKET_LOG_ENTRIES);
                        
                            xdprintf(Depth, "---------------------------------------------------\n");                         
                        }
                    }
                }        
            }
        }
    }

}


VOID
ClassDumpIds(
    ULONG64 devObjAddr,
    ULONG   detail
    )
/*++

Routine Description:

    Dumps the vendor, model, firmware and serial number for a given
    device object.  Accepts either a FDO or PDO that belongs to a
    CLASSPNP driver (disk, cdrom, tape)
    

Arguments:

    args - string containing the address of the device object

Return Value:

    none

--*/
{
    /*
     *  Read the device object and extension into the debugger's address space.
     */
    if (devObjAddr == 0){
        /*
         *  If this is the server version of classpnp with the global AllFdosList, display all class FDOs.
         */
        ClassTryShowAllFDOs(detail);

        xdprintf(0, "\n usage: !classid <class fdo/pdo> [0|1]\n\n");
    }
    else {
        CSHORT objType = GetUSHORTField(devObjAddr, "nt!_DEVICE_OBJECT", "Type");
            
        if (objType == IO_TYPE_DEVICE){
            ULONG64 devExtAddr;

            devExtAddr = GetULONGField(devObjAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
            if (devExtAddr != BAD_VALUE){
                ULONG64 partitionZeroExtension = BAD_VALUE;
                ULONG64 deviceDescriptor = BAD_VALUE;
                ULONG64 tmpDevObjAddr = BAD_VALUE;
                BOOLEAN isFdo;

                /*
                 *  To sanity-check our device context, check that the 'DeviceObject' field matches our device object.
                 */
                tmpDevObjAddr = GetULONGField(devExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "DeviceObject");
                isFdo = GetUCHARField(devExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "IsFdo");
                
                if ((tmpDevObjAddr == devObjAddr) && (isFdo != BAD_VALUE)) {
                    partitionZeroExtension = GetULONGField(devExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "PartitionZeroExtension");
                }
                    
                if (partitionZeroExtension != BAD_VALUE) {
                    deviceDescriptor = GetULONGField(devExtAddr, "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", "DeviceDescriptor");
                }

                if (deviceDescriptor != BAD_VALUE) {

                    // get and dump the real info
                    ULONG64 vendorIdOffset = BAD_VALUE;
                    ULONG64 productIdOffset = BAD_VALUE;
                    ULONG64 productRevisionOffset = BAD_VALUE;
                    ULONG64 serialNumberOffset = BAD_VALUE;
                    UCHAR  vendorId[256] = {0};
                    UCHAR  productId[256] = {0};
                    UCHAR  productRevision[256] = {0};
                    UCHAR  serialNumber[256] = {0};

                    vendorIdOffset        = GetULONGField(deviceDescriptor, "classpnp!_STORAGE_DEVICE_DESCRIPTOR", "VendorIdOffset");
                    productIdOffset       = GetULONGField(deviceDescriptor, "classpnp!_STORAGE_DEVICE_DESCRIPTOR", "ProductIdOffset");
                    productRevisionOffset = GetULONGField(deviceDescriptor, "classpnp!_STORAGE_DEVICE_DESCRIPTOR", "ProductRevisionOffset");
                    serialNumberOffset    = GetULONGField(deviceDescriptor, "classpnp!_STORAGE_DEVICE_DESCRIPTOR", "SerialNumberOffset");
                    
                    if ((vendorIdOffset != 0) && (vendorIdOffset != BAD_VALUE)) {
                        ULONG t = (sizeof(vendorId) / sizeof (UCHAR)) - 1; // always keep a NULL
                        GetAnsiString(deviceDescriptor + vendorIdOffset, vendorId, &t);
                    }
                    if ((productIdOffset != 0) && (productIdOffset != BAD_VALUE)) {
                        ULONG t = (sizeof(productId) / sizeof (UCHAR)) - 1; // always keep a NULL
                        GetAnsiString(deviceDescriptor + productIdOffset, productId, &t);
                    }
                    if ((productRevisionOffset != 0) && (productRevisionOffset != BAD_VALUE)) {
                        ULONG t = (sizeof(productRevision) / sizeof (UCHAR)) - 1; // always keep a NULL
                        GetAnsiString(deviceDescriptor + productRevisionOffset, productRevision, &t);
                    }
                    if ((serialNumberOffset != 0) && (serialNumberOffset != BAD_VALUE)) {
                        ULONG t = (sizeof(serialNumber) / sizeof (UCHAR)) - 1; // always keep a NULL
                        GetAnsiString(deviceDescriptor + serialNumberOffset, serialNumber, &t);
                    }

                    if (detail == 1)
                    {
                        // print it all on one line
                        dprintf("| %s | %s | %s | %s |\n", vendorId, productId, productRevision, serialNumber);
                    }
                    else
                    {
                        // print it with labels and such
                        dprintf("   Device Object: %p\n"
                                "          Is Fdo: %s\n"
                                "       Vendor Id: \"%s\"\n"
                                "      Product Id: \"%s\"\n"
                                "Product Revision: \"%s\"\n"
                                "   Serial Number: \"%s\"\n",
                                devExtAddr,
                                (isFdo ? "Yes" : "No"),
                                vendorId,
                                productId,
                                productRevision,
                                serialNumber);
                    }

                }
                else {
                    dprintf("%08p - could not retrieve requested information\n", devObjAddr);
                    dprintf(g_genericErrorHelpStr);
                }
            }
        }
        else {
            dprintf("Error: 0x%08p is not a device object\n", devObjAddr);
            dprintf(g_genericErrorHelpStr);
        }
    }
        
    return;
}

DECLARE_API(classid)
/*++

Routine Description:

    Dumps the vendor, model, firmware and serial number for a given
    device object.  Accepts either a FDO or PDO that belongs to a
    CLASSPNP driver (disk, cdrom, tape)
    

Arguments:

    args - string containing the address of the device object

Return Value:

    none

--*/

{
    ULONG64 devObjAddr = 0;
    ULONG64 detail = 0;
    
    ReloadSymbols("classpnp.sys");
    
    if (GetExpressionEx(args, &devObjAddr, &args))
    {
        GetExpressionEx(args, &detail, &args);
    }

    ClassDumpIds( devObjAddr, (ULONG)detail );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\help.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    help.c

Abstract:

    WinDbg Extension Api for interpretting AIC78XX debugging structures

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

typedef struct {
        char *extname;
        char *extdesc;
} exthelp;

exthelp extensions[] =  {
        {"help",            "displays this message"},
        {"srbdata",         "dumps the specified SRB_DATA tracking block"},
        {"",                ""},
        {"The following take either the device object or device extension", ""},
        {"scsiext",         "dumps the specified scsiport extension"},
        {"classext",        "dumps the specified classpnp extension"},
        {"",                ""},
        {"Commands for partition tables", ""},
        {"layout",          "dumps the drive layout at the the specified address"},
        {"layoutex",        "dumps the extended drive layout at the specified address"},
        {"part",            "dumps the partition at the specified address"},
        {"partex",          "dumps the extended partition at the specified address"},
        {NULL,          NULL}};

DECLARE_API( help )
{
        int i = 0;

        dprintf("\nSCSIPORT Debugger Extension\n");
        while(extensions[i].extname != NULL)    {
                dprintf("\t%10s - \t%s\n",
                        extensions[i].extname,
                        extensions[i].extdesc);
                i++;
        }
        dprintf("\n");
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\partition.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    partition.c

Abstract:

    Debugger extension for dumping partition structures:

        DRIVE_LAYOUT_INFORMATION

        DRIVE_LAYOUT_INFORMATION_EX

        PARTITION_INFORMATION

        PARTITION_INFORMATION_EX

Author:

    Matthew D Hendel (math) 19-Jan-2000

Revision History:

--*/

#include "pch.h"
#include <ntdddisk.h>



VOID
DumpPartition(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth,
    IN ULONG PartitionCount
    )

/*++

Routine Description:

    Dump a PARTITION_INFORMATION structure.

Arguments:

    Address - The address of the partition information structure to dump.

    Detail - The detail level. Currently unused.

    Depth - The depth to indent to.

    PartitionCount - The number of partitions. This is used to determine
            whether a particular partition ordinal is valid or not.

Return Value:

    None.

--*/

{
    BOOL Succ;
    ULONG Size;
    ULONG64 StartingOffset;
    ULONG64 PartitionLength;
    ULONG PartitionNumber;
    UCHAR PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;

    InitTypeRead(Address, nt!PARTITION_INFORMATION);
    StartingOffset = ReadField(StartingOffset.QuadPart);
    PartitionLength = ReadField(PartitionLength.QuadPart);
    PartitionType = (UCHAR) ReadField(PartitionType);
    BootIndicator = (BOOLEAN) ReadField(BootIndicator);
    RecognizedPartition = (BOOLEAN) ReadField(RecognizedPartition);
    RewritePartition = (BOOLEAN) ReadField(RewritePartition);
    PartitionNumber = (ULONG) ReadField(PartitionNumber);

    //
    // Sanity check the data.
    //

    if ( (BootIndicator != TRUE && BootIndicator != FALSE) ||
         (RecognizedPartition != TRUE && RecognizedPartition != FALSE) ||
         (RewritePartition != TRUE && RewritePartition != FALSE) ) {

        xdprintfEx (Depth, ("Invalid partition information at %p\n", Address));
    }

    if (PartitionNumber > PartitionCount) {
        PartitionNumber = (ULONG)-1;
    }

    xdprintfEx (Depth, ("[%-2d] %-16I64x %-16I64x %2.2x   %c  %c  %c\n",
                PartitionNumber,
                StartingOffset,
                PartitionLength,
                PartitionType,
                BootIndicator ? 'x' : ' ',
                RecognizedPartition ? 'x' : ' ',
                RewritePartition ? 'x' : ' '
                ));
}

VOID
DumpDriveLayout(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    BOOL Succ;
    ULONG Size;
    ULONG i;
    ULONG64 PartAddress;
    ULONG result;
    ULONG offset;
    ULONG PartitionCount;
    ULONG Signature;
    ULONG OffsetOfFirstPartitionInfo;
    ULONG SizeOfPartitionInfo;

    InitTypeRead(Address, nt!_DRIVE_LAYOUT_INFORMATION);
    PartitionCount = (ULONG) ReadField(PartitionCount);
    Signature = (ULONG) ReadField(Signature);

    xdprintfEx (Depth, ("\nDRIVE_LAYOUT %p\n", Address));

    //
    // Warn if the partition count is not a factor of 4. This is probably a
    // bad partition information structure, but we'll continue on anyway.
    //

    if (PartitionCount % 4 != 0) {
        xdprintfEx (Depth, ("WARNING: Partition count should be a factor of 4.\n"));
    }

    xdprintfEx (Depth, ("PartitionCount: %d\n", PartitionCount));
    xdprintfEx (Depth, ("Signature: %8.8x\n\n", Signature));
    xdprintfEx (Depth+1, (" ORD Offset           Length           Type BI RP RW\n"));
    xdprintfEx (Depth+1, ("------------------------------------------------------------\n"));

    result = GetFieldOffset("nt!_DRIVE_LAYOUT_INFORMATION",
                            "PartitionEntry[0]",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    OffsetOfFirstPartitionInfo = offset;

    result = GetFieldOffset("nt!_DRIVE_LAYOUT_INFORMATION",
                            "PartitionEntry[1]",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    SizeOfPartitionInfo = offset - OffsetOfFirstPartitionInfo;

    PartAddress = Address + OffsetOfFirstPartitionInfo;
    for (i = 0; i < PartitionCount; i++) {

        if (CheckControlC()) {
            return;
        }

        DumpPartition(PartAddress, Detail, Depth+1, PartitionCount);
        PartAddress += SizeOfPartitionInfo;
    }
}


VOID
DumpPartitionEx(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth,
    IN ULONG PartitionCount
    )

/*++

Routine Description:

    Dump a PARTITION_INFORMATION_EX structure.

Arguments:

    Address - The address of the partition information structure to dump.

    Detail - The detail level. Currently unused.

    Depth - The depth to indent to.

    PartitionCount - The number of partitions. This is used to determine
            whether a particular partition ordinal is valid or not.

Return Value:

    None.

--*/
{
    BOOL Succ;
    ULONG Size;
    ULONG result;
    ULONG offset;
    ULONG PartitionStyle;
    ULONG PartitionNumber;
    ULONG64 StartingOffset;
    ULONG64 PartitionLength;
    BOOLEAN RewritePartition;
    UCHAR MbrPartitionType;
    BOOLEAN MbrBootIndicator;
    BOOLEAN MbrRecognizedPartition;
    ULONG64 GptAttributes;
    GUID GptPartitionType;
    GUID GptPartitionId;
    ULONG64 AddrOfGuid;
    WCHAR GptName[36+1] = {0};

    InitTypeRead (Address, nt!_PARTITION_INFORMATION_EX);
    PartitionStyle = (ULONG) ReadField(PartitionStyle);

    if (PartitionStyle != PARTITION_STYLE_MBR &&
        PartitionStyle != PARTITION_STYLE_GPT) {

        SCSIKD_PRINT_ERROR(0);
        return;
    }

    PartitionNumber = (ULONG) ReadField(PartitionNumber);
    StartingOffset = ReadField(StartingOffset.QuadPart);
    PartitionLength = ReadField(PartitionLength.QuadPart);
    RewritePartition = (BOOLEAN) ReadField(RewritePartition);

    //
    // We use -1 to denote an invalid partition ordinal.
    //

    if (PartitionNumber >= PartitionCount) {
        PartitionNumber = (ULONG)-1;
    }

    InitTypeRead (Address, nt!_PARTITION_INFORMATION_EX);

    if (PartitionStyle == PARTITION_STYLE_MBR) {

        MbrPartitionType = (UCHAR) ReadField(Mbr.PartitionType);
        MbrBootIndicator = (BOOLEAN) ReadField(Mbr.BootIndicator);
        MbrRecognizedPartition = (BOOLEAN) ReadField(Mbr.RecognizedPartition);

        xdprintfEx (Depth, ("[%-2d] %-16I64x %-16I64x %2.2x   %c  %c  %c\n",
                    PartitionNumber,
                    StartingOffset,
                    PartitionLength,
                    MbrPartitionType,
                    MbrBootIndicator ? 'x' : ' ',
                    MbrRecognizedPartition ? 'x' : ' ',
                    RewritePartition ? 'x' : ' '
                    ));
    } else {

        GptAttributes = ReadField(Gpt.Attributes);

        result = GetFieldOffset("nt!_PARTITION_INFORMATION_EX",
                                "Gpt.PartitionType",
                                &offset);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return;
        }

        AddrOfGuid = Address + offset;

        Succ = ReadMemory (
                    AddrOfGuid,
                    &GptPartitionType,
                    sizeof (GUID),
                    &Size
                    );

        if (!Succ || Size != sizeof (GUID)) {
            SCSIKD_PRINT_ERROR(0);
            return;
        }

        //
        // PartitionId immediately follows the PartitionType.  So all we have to do
        // is add sizeof(GUID) to the address and read PartitionId.
        //

        AddrOfGuid += sizeof(GUID);

        Succ = ReadMemory (
                    AddrOfGuid,
                    &GptPartitionId,
                    sizeof (GUID),
                    &Size
                    );

        if (!Succ || Size != sizeof (GUID)) {
            SCSIKD_PRINT_ERROR(0);
            return;
        }

        //
        // Read in the Gpt.Name.
        //

        result = GetFieldOffset("nt!_PARTITION_INFORMATION_EX",
                                "Gpt.Name",
                                &offset);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return;
        }

        Succ = ReadMemory (
                    Address + offset,
                    GptName,
                    sizeof(GptName)-sizeof(WCHAR),
                    &Size
                    );

        if (!Succ || Size != sizeof (GUID)) {
            SCSIKD_PRINT_ERROR(0);
            return;
        }

        xdprintfEx (Depth, ("[%-2d] %S\n",
                    PartitionNumber, GptName));
        xdprintfEx (Depth, ("OFF %-16I64x LEN %-16I64x ATTR %-16I64x R/W %c\n",
                    StartingOffset,
                    PartitionLength,
                    GptAttributes,
                    RewritePartition ? 'T' : 'F'));
        xdprintfEx (Depth, ("TYPE %s\n",
                    GuidToString (&GptPartitionType)));
        xdprintfEx (Depth, ("ID %s\n",
                    GuidToString (&GptPartitionId)));
        xdprintfEx (Depth, ("\n"));
    }
}

VOID
DumpDriveLayoutEx(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG result;
    BOOL Succ;
    ULONG Size;
    ULONG i;
    ULONG offset;
    ULONG64 AddrOfDiskId;
    ULONG PartitionStyle;
    ULONG PartitionCount;
    ULONG MbrSignature;
    GUID    GptDiskId;
    ULONG64 GptStartingUsableOffset;
    ULONG64 GptUsableLength;
    ULONG   GptMaxPartitionCount;

    InitTypeRead(Address, nt!_DRIVE_LAYOUT_INFORMATION_EX);
    PartitionStyle = (ULONG)ReadField(PartitionStyle);
    PartitionCount = (ULONG)ReadField(PartitionCount);
    MbrSignature = (ULONG)ReadField(Mbr.Signature);
    GptStartingUsableOffset = ReadField(Gpt.StartingUsableOffset.QuadPart);
    GptUsableLength = ReadField(Gpt.UsableLength.QuadPart);
    GptMaxPartitionCount = (ULONG)ReadField(Gpt.MaxPartitionCount);

    result = GetFieldOffset("nt!_DRIVE_LAYOUT_INFORMATION_EX",
                            "Gpt.DiskId",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    AddrOfDiskId = Address + offset;
    Succ = ReadMemory(
                AddrOfDiskId,
                &GptDiskId,
                sizeof(GUID),
                &Size);
    if (!Succ || Size != sizeof(GUID)) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    xdprintfEx (Depth, ("\nDRIVE_LAYOUT_EX %p\n", Address));

    if (PartitionStyle != PARTITION_STYLE_MBR &&
        PartitionStyle != PARTITION_STYLE_GPT) {

        xdprintfEx (Depth, ("ERROR: invalid partition style %d\n", PartitionStyle));
        return;
    }

    if (PartitionStyle == PARTITION_STYLE_MBR &&
        PartitionCount % 4 != 0) {

        xdprintfEx (Depth, ("WARNING: Partition count is not a factor of 4, (%d)\n",
                    PartitionCount));
    }

    if (PartitionStyle == PARTITION_STYLE_MBR) {

        xdprintfEx (Depth, ("Signature: %8.8x\n", MbrSignature));
        xdprintfEx (Depth, ("PartitionCount %d\n\n", PartitionCount));

        xdprintfEx (Depth+1, (" ORD Offset           Length           Type BI RP RW\n"));
        xdprintfEx (Depth+1, ("------------------------------------------------------------\n"));

    } else {

        xdprintfEx (Depth, ("DiskId: %s\n", GuidToString (&GptDiskId)));
        xdprintfEx (Depth, ("StartingUsableOffset: %I64x\n", GptStartingUsableOffset));
        xdprintfEx (Depth, ("UsableLength:  %I64x\n", GptUsableLength));
        xdprintfEx (Depth, ("MaxPartitionCount: %d\n", GptMaxPartitionCount));
        xdprintfEx (Depth, ("PartitionCount %d\n\n", PartitionCount));
    }


    result = GetFieldOffset("nt!_DRIVE_LAYOUT_INFORMATION_EX", "PartitionEntry[0]", &offset);

    if (result)
    {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    Address += offset;

    for (i = 0; i < PartitionCount; i++)
    {
        if (CheckControlC())
        {
            return;
        }

        DumpPartitionEx(Address, Detail, Depth + 1, PartitionCount);

        Address += sizeof(PARTITION_INFORMATION_EX);
    }
}



DECLARE_API (layout)

/*++

Routine Description:

    Dump a DRIVE_LAYOUT structure with all it's partitions.

Arguments:

    args - A string containing the address of the DRIVE_LAYOUT structure to
           be dumped.

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG64 detail = 0;

    if (GetExpressionEx(args, &Address, &args))
    {
        GetExpressionEx(args, &detail, &args);
    }

    DumpDriveLayout (Address, (ULONG)detail, 0);

    return S_OK;
}

DECLARE_API (layoutex)


/*++

Routine Description:

    Dump a DRIVE_LAYOUT_EX structure and it's partitions.

Usage:

    layoutex <address>

Arguments:

    args - A string containing the address of the DRIVE_LAYOUT_EX structure
           to be dumped.

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG64 detail = 0;

    if (GetExpressionEx(args, &Address, &args))
    {
        GetExpressionEx(args, &detail, &args);
    }

    DumpDriveLayoutEx (Address, (ULONG)detail, 0);

    return S_OK;
}


DECLARE_API (part)

/*++

Routine Description:

    Dump a PARTITION_INFORMATION structure.

Usage:

    part <address>

Arguments:

    args - A string containing the address of the PARTITION_INFORMATION
           structure to be dumped.

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG64 detail = 0;

    if (GetExpressionEx(args, &Address, &args))
    {
        GetExpressionEx(args, &detail, &args);
    }

    DumpPartition (Address, (ULONG)detail, 0, 0);

    return S_OK;
}

DECLARE_API (partex)


/*++

Routine Description:

    Dump a PARTITION_INFORMATION_EX structure.

Usage:

    partex <address>

Arguments:

    args - A string containing the address of the PARTITION_INFORMATION_EX
           structure to be dumped.

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG64 detail = 0;

    if (GetExpressionEx(args, &Address, &args))
    {
        GetExpressionEx(args, &detail, &args);
    }

    DumpPartitionEx (Address, (ULONG)detail, 0, 0);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\classkd.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    classkd.h

Abstract:

    Debugger Extension header file

Author:

Environment:

Revision History:

--*/


#define BAD_VALUE  (ULONG64)-1


VOID
ClassDumpFdoExtensionExternal(
    IN IN ULONG64 FdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ClassDumpFdoExtensionInternal(
    IN ULONG64 FdoDataAddr,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ClassDumpIds(
    ULONG64 devObjAddr,
    ULONG   detail
    );


char *DbgGetIoctlStr(ULONG ioctl);
char *DbgGetScsiOpStr(UCHAR ScsiOp);
char *DbgGetSrbStatusStr(UCHAR SrbStat);
char *DbgGetSenseCodeStr(UCHAR SrbStat, ULONG64 SenseDataAddr);
char *DbgGetAdditionalSenseCodeStr(UCHAR SrbStat, ULONG64 SenseDataAddr);
char *DbgGetAdditionalSenseCodeQualifierStr(UCHAR SrbStat, ULONG64 SenseDataAddr);
char *DbgGetMediaTypeStr(ULONG MediaType);
ULONG64 GetULONGField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
USHORT GetUSHORTField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
UCHAR GetUCHARField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
ULONG64 GetFieldAddr(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
ULONG64 GetContainingRecord(ULONG64 FieldAddr, LPCSTR StructType, LPCSTR FieldName);

VOID ClassDumpTransferPacket(
    ULONG64 PktAddr, 
    BOOLEAN DumpPendingPkts, 
    BOOLEAN DumpFreePkts, 
    BOOLEAN DumpFullInfo, 
    ULONG Depth);

VOID ClassDumpTransferPacketLists(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth);
VOID ClassDumpPrivateErrorLogs(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth);
VOID ClassDumpPrivatePacketLogs(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth);
BOOLEAN ClassTryShowAllFDOs(ULONG Detail);


extern char *g_genericErrorHelpStr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\scsikd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    scsikd.c

Abstract:

    Debugger Extension Api for interpretting scsiport structures

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

    John Strange (johnstra) 17-Apr-2000 : make 64b friendly

--*/

#include "pch.h"

#include "port.h"

FLAG_NAME LuFlags[] = {
    FLAG_NAME(LU_QUEUE_FROZEN),             // 0001
    FLAG_NAME(LU_LOGICAL_UNIT_IS_ACTIVE),   // 0002
    FLAG_NAME(LU_NEED_REQUEST_SENSE),       // 0004
    FLAG_NAME(LU_LOGICAL_UNIT_IS_BUSY),     // 0008
    FLAG_NAME(LU_QUEUE_IS_FULL),            // 0010
    FLAG_NAME(LU_PENDING_LU_REQUEST),       // 0020
    FLAG_NAME(LU_QUEUE_LOCKED),             // 0040
    FLAG_NAME(LU_QUEUE_PAUSED),             // 0080
    {0,0}
};

FLAG_NAME AdapterFlags[] = {
    FLAG_NAME(PD_DEVICE_IS_BUSY),            // 0X00001
    FLAG_NAME(PD_NOTIFICATION_REQUIRED),     // 0X00004
    FLAG_NAME(PD_READY_FOR_NEXT_REQUEST),    // 0X00008
    FLAG_NAME(PD_FLUSH_ADAPTER_BUFFERS),     // 0X00010
    FLAG_NAME(PD_MAP_TRANSFER),              // 0X00020
    FLAG_NAME(PD_LOG_ERROR),                 // 0X00040
    FLAG_NAME(PD_RESET_HOLD),                // 0X00080
    FLAG_NAME(PD_HELD_REQUEST),              // 0X00100
    FLAG_NAME(PD_RESET_REPORTED),            // 0X00200
    FLAG_NAME(PD_PENDING_DEVICE_REQUEST),    // 0X00800
    FLAG_NAME(PD_DISCONNECT_RUNNING),        // 0X01000
    FLAG_NAME(PD_DISABLE_CALL_REQUEST),      // 0X02000
    FLAG_NAME(PD_DISABLE_INTERRUPTS),        // 0X04000
    FLAG_NAME(PD_ENABLE_CALL_REQUEST),       // 0X08000
    FLAG_NAME(PD_TIMER_CALL_REQUEST),        // 0X10000
    FLAG_NAME(PD_WMI_REQUEST),               // 0X20000
    {0,0}
};

VOID
ScsiDumpPdo(
    IN ULONG64 LunAddress,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ScsiDumpFdo(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    );

VOID
ScsiDumpSrbData(
    ULONG64 SrbData,
    ULONG Depth
    );
VOID
ScsiDumpAdapterPerfCounters(
    ULONG64 Adapter,
    ULONG Depth
    );

VOID
ScsiDumpScatterGatherList(
    ULONG64 List,
    ULONG Entries,
    ULONG Depth
    );

VOID
ScsiDumpActiveRequests(
    IN ULONG64 ListHead,
    IN ULONG TickCount,
    IN ULONG Depth
    );

VOID
ScsiDumpScsiportExtension(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ScsiDumpInterruptData(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ScsiDumpChildren(
    IN ULONG64 Adapter,
    IN ULONG Depth
    );

PUCHAR 
SecondsToString(
    ULONG Count
    );

VOID
ScsiDumpLocks(
    ULONG64 CommonExtension,
    ULONG Depth
    );

VOID
ScsiDumpQueuedRequests(
    IN ULONG64 DeviceObject,
    IN ULONG TickCount,
    IN ULONG Depth
    );

DECLARE_API(scsiext)

/*++

Routine Description:

    Dumps the device extension for a given device object, or dumps the
    given device extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 address = 0;
    ULONG result;
    ULONG64 detail = 0;
    CSHORT Type;

    if (GetExpressionEx(args, &address, &args))
    {
        GetExpressionEx(args, &detail, &args);
    }

    //
    // The supplied address may be either the address of a device object or the
    // address of a device extension.  To distinguish which, we treat the 
    // address as a device object and read what would be its type field.  If
    // the 
    //

    result = GetFieldData(address,
                          "scsiport!_DEVICE_OBJECT",
                          "Type",
                          sizeof(CSHORT),
                          &Type
                          );
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return E_FAIL;
    }
    
    //
    // See if the supplied address holds a device object.  If it does, read the
    // address of the device extension.  Otherwise, we assume the supplied
    // addres holds a device extension and we use it directly.
    //

    if (Type == IO_TYPE_DEVICE) {

        result = GetFieldData(address,
                              "scsiport!_DEVICE_OBJECT",
                              "DeviceExtension",
                              sizeof(ULONG64),
                              &address
                              );
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return E_FAIL;
        }
    }

    //
    // Call worker routine to dump the information.
    //

    ScsiDumpScsiportExtension(address, (ULONG)detail, 0);

    return S_OK;
}


VOID
ScsiDumpScsiportExtension(
    IN ULONG64 CommonExtension,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG tmp;
    ULONG result;

    ULONG64 DeviceObject = 0;
    ULONG IsPdo = 0;
    ULONG IsInitialized = 0;
    ULONG WmiInitialized = 0;
    ULONG WmiMiniPortSupport = 0;
    ULONG CurrentPnpState = 0;    
    ULONG PreviousPnpState = 0;
    ULONG IsRemoved = 0;
    ULONG64 LowerDeviceObject = 0;
    ULONG SrbFlags = 0;
    ULONG64 MajorFunction = 0;
    SYSTEM_POWER_STATE CurrentSystemState = 0;
    DEVICE_POWER_STATE CurrentDeviceState = 0;
    DEVICE_POWER_STATE DesiredDeviceState = 0;
    ULONG64 IdleTimer = 0;
    ULONG64 WmiScsiPortRegInfoBuf = 0;
    ULONG WmiScsiPortRegInfoBufSize = 0;   
    ULONG PagingPathCount = 0;
    ULONG HibernatePathCount = 0;
    ULONG DumpPathCount = 0;
    
    FIELD_INFO deviceFields[] = {
       {"DeviceObject", NULL, 0, COPY, 0, (PVOID) &DeviceObject},
       {"IsPdo", NULL, 0, COPY, 0, (PVOID) &IsPdo},
       {"IsInitialized", NULL, 0, COPY, 0, (PVOID) &IsInitialized},
       {"WmiInitialized", NULL, 0, COPY, 0, (PVOID) &WmiInitialized},
       {"WmiMiniPortSupport", NULL, 0, COPY, 0, (PVOID) &WmiMiniPortSupport},
       {"CurrentPnpState", NULL, 0, COPY, 0, (PVOID) &CurrentPnpState},
       {"PreviousPnpState", NULL, 0, COPY, 0, (PVOID) &PreviousPnpState},
       {"IsRemoved", NULL, 0, COPY, 0, (PVOID) &IsRemoved},
       {"LowerDeviceObject", NULL, 0, COPY, 0, (PVOID) &LowerDeviceObject},
       {"SrbFlags", NULL, 0, COPY, 0, (PVOID) &SrbFlags},
       {"MajorFunction", NULL, 0, COPY, 0, (PVOID) &MajorFunction},
       {"CurrentSystemState", NULL, 0, COPY, 0, (PVOID) &CurrentSystemState},
       {"CurrentDeviceState", NULL, 0, COPY, 0, (PVOID) &CurrentDeviceState},
       {"DesiredDeviceState", NULL, 0, COPY, 0, (PVOID) &DesiredDeviceState},
       {"IdleTimer", NULL, 0, COPY, 0, (PVOID) &IdleTimer},
       {"WmiScsiPortRegInfoBuf", NULL, 0, COPY, 0, (PVOID) &WmiScsiPortRegInfoBuf},
       {"WmiScsiPortRegInfoBufSize", NULL, 0, COPY, 0, (PVOID) &WmiScsiPortRegInfoBufSize},
       {"PagingPathCount", NULL, 0, COPY, 0, (PVOID) &PagingPathCount},
       {"HibernatePathCount", NULL, 0, COPY, 0, (PVOID) &HibernatePathCount},
       {"DumpPathCount", NULL, 0, COPY, 0, (PVOID) &DumpPathCount},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_COMMON_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       CommonExtension,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        dprintf("%08p: Could not read device object\n", CommonExtension);
        return;
    }
    
    xdprintfEx(Depth, ("Scsiport %s device extension at address %p\n",
               IsPdo ? "physical" : "functional", CommonExtension));

    xdprintfEx(Depth, ("Common Extension:\n"));

    Depth += 1;

    tmp = Depth;

    if(IsInitialized) {
        xdprintfEx(tmp, ("Initialized "));
        tmp = 0;
    }

    if(IsRemoved) {
        xdprintfEx(tmp, ("Removed " ));
        tmp = 0;
    }

    switch(IsRemoved) {
        case REMOVE_PENDING: {
            xdprintfEx(tmp, ("RemovePending"));
            tmp = 0;
            break;
        }

        case REMOVE_COMPLETE: {
            xdprintfEx(tmp, ("RemoveComplete"));
            tmp = 0;
            break;
        }
    }

    if(WmiMiniPortSupport) {
        if(WmiInitialized) {
            xdprintfEx(tmp, ("WmiInit"));
        } else {
            xdprintfEx(tmp, ("Wmi"));
        }
        tmp = 0;
    }

    if(tmp == 0) {
        dprintf("\n");
    }

    tmp = 0;

    xdprintfEx(Depth, ("DO 0x%08p  LowerObject 0x%08p  SRB Flags %#08lx\n",
               DeviceObject,
               LowerDeviceObject,
               SrbFlags));

    xdprintfEx(Depth, ("Current Power (D%d,S%d)  Desired Power D%d Idle %#08lx\n",
               CurrentDeviceState - 1,
               CurrentSystemState - 1,
               DesiredDeviceState - 1,
               IdleTimer));

    xdprintfEx(Depth, ("Current PnP state 0x%x    Previous state 0x%x\n",
               CurrentPnpState,
               PreviousPnpState));

    xdprintfEx(Depth, ("DispatchTable %08p   UsePathCounts (P%d, H%d, C%d)\n",
               MajorFunction,
               PagingPathCount,
               HibernatePathCount,
               DumpPathCount));

    if(WmiMiniPortSupport) {
        xdprintfEx(Depth, ("DispatchTable 0x%08p   WmiInfoSize %#08lx\n",
                   WmiScsiPortRegInfoBuf,
                   WmiScsiPortRegInfoBufSize));
    }

    if(IsPdo) {
        xdprintfEx(Depth - 1, ("Logical Unit Extension:\n"));
        ScsiDumpPdo(CommonExtension, Detail, Depth);
    } else {
        xdprintfEx(Depth - 1, ("Adapter Extension:\n"));
        ScsiDumpFdo(CommonExtension, Detail, Depth);
    }

    if(Detail > 1) {
        ScsiDumpLocks(CommonExtension, Depth - 1);
    }

    return;
}

VOID
ScsiDumpFdo(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    )
{
    ULONG tmp = Depth;
    ULONG result;
    ULONG NumOfFields;

    ULONG   PortNumber = 0;
    UCHAR   IsPnp = 0;
    UCHAR   IsMiniportDetected = 0;
    UCHAR   IsInVirtualSlot = 0;
    UCHAR   HasInterrupt = 0;
    UCHAR   DisablePower = 0;
    UCHAR   DisableStop = 0;
    ULONG64 LowerPdo = 0;
    ULONG64 HwDeviceExtension = 0;
    LONG    ActiveRequestCount = 0;
    ULONG   NumberOfBuses = 0;
    ULONG   MaximumTargetIds = 0;
    ULONG   MaxLuCount = 0;
    ULONG   Flags = 0;
    ULONG64 NonCachedExtension = 0;
    ULONG   IoAddress = 0;
    ULONG   InterruptLevel = 0;
    ULONG   RealBusNumber = 0;
    ULONG   RealSlotNumber = 0;
    LONG    PortTimeoutCounter = 0;
    ULONG   DpcFlags = 0;
    ULONG   SequenceNumber = 0;
    ULONG64 SrbExtensionListHeader = 0;
    ULONG   NumberOfRequests = 0;
    ULONG64 QueueTagBitMap = 0;
    ULONG   QueueTagHint = 0;
    ULONG   HwLogicalUnitExtensionSize = 0;
    ULONG   SrbExtensionSize = 0;
    ULONG   LargeScatterGatherListSize = 0;
    ULONG64 EmergencySrbData = 0;
    ULONG   CommonBufferSize = 0;
    ULONG64 PhysicalCommonBuffer = 0;
    ULONG64 SrbExtensionBuffer = 0;
    ULONG64 InterruptObject = 0;
    ULONG64 InterruptObject2 = 0;
    ULONG64 DmaAdapterObject = 0;
    ULONG64 AllocatedResources = 0;
    ULONG64 TranslatedResources = 0;
    ULONG64 PortConfig = 0;
    ULONG64 PortDeviceMapKey = 0;
    ULONG64 BusDeviceMapKeys = 0;
    UCHAR   RemoveTrackingLookasideListInitialized = 0;
    ULONG64 AddrOfMaxQueueTag = 0;
    ULONG64 SrbDataBlockedRequests = 0;
    ULONG64 SrbDataLookasideList = 0;
    ULONG64 MediumScatterGatherLookasideList = 0;
    ULONG64 RemoveTrackingLookasideList = 0;
    ULONG64 InterruptData = 0;
    UCHAR   MaxQueueTag = 0;
    
    FIELD_INFO deviceFields[] = {
       {"PortNumber", NULL, 0, COPY, 0, (PVOID) &PortNumber},
       {"IsPnp", NULL, 0, COPY, 0, (PVOID) &IsPnp},
       {"IsMiniportDetected", NULL, 0, COPY, 0, (PVOID) &IsMiniportDetected},
       {"IsInVirtualSlot", NULL, 0, COPY, 0, (PVOID) &IsInVirtualSlot},
       {"HasInterrupt", NULL, 0, COPY, 0, (PVOID) &HasInterrupt},
       {"DisablePower", NULL, 0, COPY, 0, (PVOID) &DisablePower},
       {"DisableStop", NULL, 0, COPY, 0, (PVOID) &DisableStop},
       {"LowerPdo", NULL, 0, COPY, 0, (PVOID) &LowerPdo},
       {"HwDeviceExtension", NULL, 0, COPY, 0, (PVOID) &HwDeviceExtension},
       {"ActiveRequestCount", NULL, 0, COPY, 0, (PVOID) &ActiveRequestCount},
       {"NumberOfBuses", NULL, 0, COPY, 0, (PVOID) &NumberOfBuses},
       {"MaximumTargetIds", NULL, 0, COPY, 0, (PVOID) &MaximumTargetIds},
       {"MaxLuCount", NULL, 0, COPY, 0, (PVOID) &MaxLuCount},
       {"Flags", NULL, 0, COPY, 0, (PVOID) &Flags},
       {"NonCachedExtension", NULL, 0, COPY, 0, (PVOID) &NonCachedExtension},
       {"IoAddress", NULL, 0, COPY, 0, (PVOID) &IoAddress},
       {"InterruptLevel", NULL, 0, COPY, 0, (PVOID) &InterruptLevel},
       {"RealBusNumber", NULL, 0, COPY, 0, (PVOID) &RealBusNumber},
       {"RealSlotNumber", NULL, 0, COPY, 0, (PVOID) &RealSlotNumber},
       {"PortTimeoutCounter", NULL, 0, COPY, 0, (PVOID) &PortTimeoutCounter},
       {"DpcFlags", NULL, 0, COPY, 0, (PVOID) &DpcFlags},
       {"SequenceNumber", NULL, 0, COPY, 0, (PVOID) &SequenceNumber},
       {"SrbExtensionListHeader", NULL, 0, COPY, 0, (PVOID) &SrbExtensionListHeader},
       {"NumberOfRequests", NULL, 0, COPY, 0, (PVOID) &NumberOfRequests},
       {"QueueTagBitMap", NULL, 0, COPY, 0, (PVOID) &QueueTagBitMap},
       {"QueueTagHint", NULL, 0, COPY, 0, (PVOID) &QueueTagHint},
       {"HwLogicalUnitExtensionSize", NULL, 0, COPY, 0, (PVOID) &HwLogicalUnitExtensionSize},
       {"SrbExtensionSize", NULL, 0, COPY, 0, (PVOID) &SrbExtensionSize},
       {"LargeScatterGatherListSize", NULL, 0, COPY, 0, (PVOID) &LargeScatterGatherListSize},
       {"EmergencySrbData", NULL, 0, COPY, 0, (PVOID) &EmergencySrbData},
       {"CommonBufferSize", NULL, 0, COPY, 0, (PVOID) &CommonBufferSize},
       {"PhysicalCommonBuffer.QuadPart", NULL, 0, COPY, 0, (PVOID) &PhysicalCommonBuffer},
       {"SrbExtensionBuffer", NULL, 0, COPY, 0, (PVOID) &SrbExtensionBuffer},
       {"InterruptObject", NULL, 0, COPY, 0, (PVOID) &InterruptObject},
       {"InterruptObject2", NULL, 0, COPY, 0, (PVOID) &InterruptObject2},
       {"DmaAdapterObject", NULL, 0, COPY, 0, (PVOID) &DmaAdapterObject},
       {"AllocatedResources", NULL, 0, COPY, 0, (PVOID) &AllocatedResources},
       {"TranslatedResources", NULL, 0, COPY, 0, (PVOID) &TranslatedResources},
       {"PortConfig", NULL, 0, COPY, 0, (PVOID) &PortConfig},
       {"PortDeviceMapKey", NULL, 0, COPY, 0, (PVOID) &PortDeviceMapKey},
       {"BusDeviceMapKeys", NULL, 0, COPY, 0, (PVOID) &BusDeviceMapKeys},
       {"CommonExtension.RemoveTrackingLookasideListInitialized", NULL, 0, COPY, 0, (PVOID) &RemoveTrackingLookasideListInitialized},
       {"MaxQueueTag", NULL, 0, ADDROF, 0, NULL},
       {"SrbDataBlockedRequests", NULL, 0, ADDROF, 0, NULL},
       {"SrbDataLookasideList", NULL, 0, ADDROF, 0, NULL},
       {"MediumScatterGatherLookasideList", NULL, 0, ADDROF, 0, NULL},
       {"CommonExtension.RemoveTrackingLookasideList", NULL, 0, ADDROF, 0, NULL},
       {"InterruptData", NULL, 0, ADDROF, 0, NULL},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_ADAPTER_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    result = GetFieldData(Address,
                          "scsiport!_ADAPTER_EXTENSION",
                          "MaxQueueTag",
                          sizeof(UCHAR),
                          &MaxQueueTag
                          );
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    NumOfFields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    InterruptData = deviceFields[NumOfFields-1].address;
    RemoveTrackingLookasideList = deviceFields[NumOfFields-2].address;
    MediumScatterGatherLookasideList = deviceFields[NumOfFields-3].address;
    SrbDataLookasideList = deviceFields[NumOfFields-4].address;
    SrbDataBlockedRequests = deviceFields[NumOfFields-5].address;
    AddrOfMaxQueueTag = deviceFields[NumOfFields-6].address;

    xdprintfEx(Depth, ("Port %d   ", PortNumber));

    if(IsPnp) {
        xdprintfEx(tmp, ("IsPnp "));
        tmp = 0;
    }

    if(IsMiniportDetected) {
        xdprintfEx(tmp, ("MpDetected "));
        tmp = 0;
    }

    if(IsInVirtualSlot) {
        xdprintfEx(tmp, ("VirtualSlot "));
        tmp = 0;
    }

    if(HasInterrupt) {
        xdprintfEx(tmp, ("HasInterrupt"));
        tmp = 0;
    }

    if(DisablePower) {
        xdprintfEx(tmp, ("NoPower"));
        tmp = 0;
    }

    if(DisableStop) {
        xdprintfEx(tmp, ("NoStop"));
        tmp = 0;
    }

    dprintf("\n");

    xdprintfEx(Depth, ("LowerPdo 0x%08p   HwDevExt 0x%08p   Active Requests 0x%08lx\n",
               LowerPdo,
               HwDeviceExtension,
               ActiveRequestCount));

    xdprintfEx(Depth, ("MaxBus 0x%02x   MaxTarget 0x%02x   MaxLun 0x%02x\n",
               NumberOfBuses,
               MaximumTargetIds,
               MaxLuCount));

    DumpFlags(Depth, "Port Flags", Flags, AdapterFlags);

    xdprintfEx(Depth, ("NonCacheExt 0x%08p  IoBase 0x%08x   Int 0x%02x\n",
               NonCachedExtension,
               IoAddress,
               InterruptLevel));

    xdprintfEx(Depth, ("RealBus# 0x%0x  RealSlot# 0x%0x\n",
               RealBusNumber,
               RealSlotNumber));

    xdprintfEx(Depth, ("Timeout 0x%08x   DpcFlags 0x%08x   Sequence 0x%08x\n",
               PortTimeoutCounter,
               DpcFlags,
               SequenceNumber));

    xdprintfEx(Depth, ("Srb Ext Header 0x%08p   No. Requests 0x%08lx\n",
               SrbExtensionListHeader, NumberOfRequests));

    xdprintfEx(Depth, ("QueueTag BitMap 0x%08p   Hint 0x%08lx\n",
               QueueTagBitMap, QueueTagHint));

    xdprintfEx(Depth, ("MaxQueueTag 0x%2x (@0x%08p)\n",
               MaxQueueTag, AddrOfMaxQueueTag));

    xdprintfEx(Depth, ("LuExt Size 0x%08lx   SrbExt Size 0x%08lx\n",
               HwLogicalUnitExtensionSize,
               SrbExtensionSize));

    xdprintfEx(Depth + 1, ("SG List Size - Small %d   Large %d\n",
               SP_SMALL_PHYSICAL_BREAK_VALUE,
               LargeScatterGatherListSize));

    Depth++;

    xdprintfEx(Depth, ("Emergency  - SrbData 0x%08p  Blocked List @0x%08p\n",
               EmergencySrbData,
               SrbDataBlockedRequests));

    xdprintfEx(Depth, ("CommonBuff - Size: 0x%08lx    PA: 0x%016I64x  VA: 0x%08p\n",
               CommonBufferSize,
               PhysicalCommonBuffer,
               SrbExtensionBuffer));

    xdprintfEx(Depth, ("Ke Objects - Int1: 0x%08p    Int2: 0x%08p        Dma: 0x%08p\n",
               InterruptObject,
               InterruptObject2,
               DmaAdapterObject));

    xdprintfEx(Depth, ("Lookaside  - SrbData @ 0x%08p SgList @0x%08p  Remove: @0x%08p\n",
               SrbDataLookasideList,
               MediumScatterGatherLookasideList,
               (RemoveTrackingLookasideListInitialized ?
                  RemoveTrackingLookasideList : 0)));

    xdprintfEx(Depth, ("Resources  - Raw: 0x%08p     Translated: 0x%08p\n",
               AllocatedResources,
               TranslatedResources));

    xdprintfEx(Depth, ("Port Config %08p\n", PortConfig));

    xdprintfEx(Depth, ("DeviceMap Handles: Port %p    Busses %p\n",
               PortDeviceMapKey, BusDeviceMapKeys));

    Depth--;
    ScsiDumpInterruptData(InterruptData,
                          Detail,
                          Depth);

    ScsiDumpAdapterPerfCounters(Address, Depth);

    ScsiDumpChildren(Address, Depth);
    return;
}


VOID
ScsiDumpChildren(
    IN ULONG64 AdapterExtensionAddr,
    IN ULONG Depth
    )

{
    ULONG i;
    ULONG64 realLun;
    ULONG64 realLuns[8];
    ULONG64 lun;
    UCHAR   CurrentPnpState=0, PreviousPnpState=0;
    ULONG   CurrentDeviceState=0;
    ULONG   DesiredDeviceState=0, CurrentSystemState=0;
    ULONG64 DeviceObject=0, NextLogicalUnit=0;
    ULONG   result;
    UCHAR   PathId=0, TargetId=0, Lun=0;
    UCHAR   IsClaimed=0, IsMissing=0, IsEnumerated=0, IsVisible=0, IsMismatched=0;
    ULONG64 b6, b7, b8;

    InitTypeRead(AdapterExtensionAddr, scsiport!_ADAPTER_EXTENSION);
    realLuns[0] = ReadField(LogicalUnitList[0].List);
    realLuns[1] = ReadField(LogicalUnitList[1].List);
    realLuns[2] = ReadField(LogicalUnitList[2].List);
    realLuns[3] = ReadField(LogicalUnitList[3].List);
    realLuns[4] = ReadField(LogicalUnitList[4].List);
    realLuns[5] = ReadField(LogicalUnitList[5].List);
    realLuns[6] = ReadField(LogicalUnitList[6].List);
    realLuns[7] = ReadField(LogicalUnitList[7].List);

    Depth++;

    for (i = 0; i < NUMBER_LOGICAL_UNIT_BINS; i++) {

        realLun = realLuns[i];
        
        while ((realLun != 0) && (!CheckControlC())) {

            FIELD_INFO deviceFields[] = {
               {"PathId",          NULL, 0, COPY, 0, (PVOID) &PathId},
               {"TargetId",        NULL, 0, COPY, 0, (PVOID) &TargetId},
               {"IsClaimed",       NULL, 0, COPY, 0, (PVOID) &IsClaimed},
               {"IsMissing",       NULL, 0, COPY, 0, (PVOID) &IsMissing},
               {"IsEnumerated",    NULL, 0, COPY, 0, (PVOID) &IsEnumerated},
               {"IsVisible",       NULL, 0, COPY, 0, (PVOID) &IsVisible},
               {"IsMismatched",    NULL, 0, COPY, 0, (PVOID) &IsMismatched},
               {"DeviceObject",    NULL, 0, COPY, 0, (PVOID) &DeviceObject},
               {"NextLogicalUnit", NULL, 0, COPY, 0, (PVOID) &NextLogicalUnit},
               {"CommonExtension.CurrentPnpState",    NULL, 0, COPY, 0, (PVOID) &CurrentPnpState},
               {"CommonExtension.PreviousPnpState" ,  NULL, 0, COPY, 0, (PVOID) &PreviousPnpState},
               {"CommonExtension.CurrentDeviceState", NULL, 0, COPY, 0, (PVOID) &CurrentDeviceState},
               {"CommonExtension.DesiredDeviceState", NULL, 0, COPY, 0, (PVOID) &DesiredDeviceState},
               {"CommonExtension.CurrentSystemState", NULL, 0, COPY, 0, (PVOID) &CurrentSystemState},
            };
            SYM_DUMP_PARAM DevSym = {
               sizeof (SYM_DUMP_PARAM), 
               "scsiport!_LOGICAL_UNIT_EXTENSION", 
               DBG_DUMP_NO_PRINT, 
               realLun,
               NULL, NULL, NULL, 
               sizeof (deviceFields) / sizeof (FIELD_INFO), 
               &deviceFields[0]
            };
            
            xdprintfEx(Depth, ("LUN "));
            dprintf("%08p ", realLun);

            if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
                dprintf("%08lx: Could not read device object\n", realLun);
                return;
            }

            result = (ULONG) InitTypeRead(realLun, scsiport!_LOGICAL_UNIT_EXTENSION);
            if (result != 0) {
                dprintf("could not init read type (%x)\n", result);
                return;
            }
            lun = ReadField(Lun);
            Lun = (UCHAR) lun;
#if 0
            PathId = ReadField(PathId);
            TargetId = ReadField(TargetId);
            IsClaimed = ReadField(IsClaimed);
            IsMissing = ReadField(IsMissing);
            IsEnumerated = ReadField(IsEnumerated);
            IsVisible = ReadField(IsVisible);
            IsMismatched = ReadField(IsMismatched);
#endif
            dprintf("@ (%3d,%3d,%3d) %c%c%c%c%c pnp(%02x/%02x) pow(%d%c,%d) DevObj %08p\n",
                    PathId,
                    TargetId,
                    Lun,
                    (IsClaimed ? 'c' : ' '),
                    (IsMissing ? 'm' : ' '),
                    (IsEnumerated ? 'e' : ' '),
                    (IsVisible ? 'v' : ' '),
                    (IsMismatched ? 'r' : ' '),
                    CurrentPnpState,
                    PreviousPnpState,
                    CurrentDeviceState - 1,
                    ((DesiredDeviceState == PowerDeviceUnspecified) ? ' ' : '*'),
                    CurrentSystemState - 1,
                    DeviceObject);

            realLun = ReadField(NextLogicalUnit);
        }
    }

    return;
}



VOID
ScsiDumpInterruptData(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    )

{
    ULONG result;
    ULONG NumOfFields;

    //
    // Architecture independent fields declarations.
    //
    //

    ULONG   InterruptFlags = 0;
    ULONG64 CompletedRequests;
    ULONG64 AddrOfCompletedRequests;
    ULONG64 ReadyLogicalUnit = 0;
    ULONG64 WmiMiniPortRequests = 0;
    
    FIELD_INFO deviceFields[] = {
       {"InterruptFlags",      NULL, 0, COPY,   0, (PVOID) &InterruptFlags},
       {"ReadyLogicalUnit",    NULL, 0, COPY,   0, (PVOID) &ReadyLogicalUnit},
       {"WmiMiniPortRequests", NULL, 0, COPY,   0, (PVOID) &WmiMiniPortRequests},
       {"CompletedRequests",   NULL, 0, ADDROF, 0, NULL},
    };
    
    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_INTERRUPT_DATA", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    //
    // Read in the top-level field data.  Quit on failure.
    //

    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        dprintf("error reading INTERRUPT_DATA @ %08p\n", Address);
        return;
    }

    //
    // Get address-of information.
    //

    NumOfFields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    AddrOfCompletedRequests = deviceFields[NumOfFields-1].address;

    //
    // Do a separate get of the CompleteRequests field.  This is necessary
    // because the typedump Ioctl doesn't like retreiving both the addr-of
    // and the data-of a field.
    //

    result = GetFieldData(Address,
                          "scsiport!_INTERRUPT_DATA",
                          "CompletedRequests",
                          sizeof(ULONG64),
                          &CompletedRequests
                          );
    if (result) {
        dprintf("error (%08x): @ %s %d\n", result, __FILE__, __LINE__);
        return;
    }
    
    xdprintfEx(Depth, ("Interrupt Data @0x%08p:\n", Address));

    Depth++;

    DumpFlags(Depth, "Flags", InterruptFlags, AdapterFlags);

    xdprintfEx(Depth, ("Ready LUN 0x%08p   Wmi Events 0x%08p\n",
               ReadyLogicalUnit,
               WmiMiniPortRequests));

    {
        ULONG count = 0;
        ULONG64 request = CompletedRequests;

        xdprintfEx(Depth, ("Completed Request List (@0x%08p): ",
                   AddrOfCompletedRequests));

        Depth += 1;

        while((request != 0) && (!CheckControlC())) {
            ULONG64 NextCompletedRequests;

            if(Detail != 0) {
                if(count == 0) {
                    dprintf("\n");
                }
                xdprintfEx(Depth, ("SrbData 0x%08p   ", request));
            }

            count++;

            result = GetFieldData(request,
                                  "scsiport!_SRB_DATA",
                                  "CompletedRequests",
                                  sizeof(ULONG64),
                                  &NextCompletedRequests
                                  );
            if (result) {
                dprintf("error (%08x): @ %s %d\n", result, __FILE__, __LINE__);
                return;
            }

            if(Detail != 0) {
                ULONG64 CurrentSrb, CurrentIrp;
                result = GetFieldData(request,
                                      "scsiport!_SRB_DATA",
                                      "CurrentSrb",
                                      sizeof(ULONG64),
                                      &CurrentSrb
                                      );
                if (result) {
                    dprintf("error (%08x): @ %s %d\n", result, __FILE__, __LINE__);
                    return;
                }
                result = GetFieldData(request,
                                      "scsiport!_SRB_DATA",
                                      "CurrentIrp",
                                      sizeof(ULONG64),
                                      &CurrentIrp
                                      );
                if (result) {
                    dprintf("error (%08x): @ %s %d\n", result, __FILE__, __LINE__);
                    return;
                }
                dprintf("Srb 0x%08p   Irp 0x%08p\n",
                        CurrentSrb,
                        CurrentIrp);
            }

            request = NextCompletedRequests;
        }

        Depth -= 1;

        if((Detail == 0) || (count == 0)) {
            dprintf("%d entries\n", count);
        } else {
            xdprintfEx(Depth + 1, ("%d entries\n", count));
        }
    }

    return;
}


VOID
ScsiDumpPdo(
    IN ULONG64 LunAddress,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG result;
    ULONG Fields;

    UCHAR   PathId;
    UCHAR   TargetId;
    UCHAR   Lun;
    ULONG   PortNumber;
    UCHAR   IsClaimed;
    UCHAR   IsMissing;
    UCHAR   IsEnumerated;
    UCHAR   IsVisible;
    UCHAR   IsMismatched;
    ULONG   LunLuFlags;
    UCHAR   RetryCount;
    ULONG   CurrentKey;
    ULONG   QueueLockCount;
    ULONG   QueuePauseCount;
    ULONG64 HwLogicalUnitExtension;
    ULONG64 AdapterExtension;
    LONG    RequestTimeoutCounter;
    ULONG64 NextLogicalUnit;
    ULONG64 ReadyLogicalUnit;
    ULONG64 PendingRequest;
    ULONG64 BusyRequest;
    ULONG64 CurrentUntaggedRequest;
    ULONG64 CompletedAbort;
    ULONG64 AbortSrb;
    ULONG   QueueCount;
    ULONG   MaxQueueDepth;
    ULONG64 TargetDeviceMapKey;
    ULONG64 LunDeviceMapKey;
    ULONG64 ActiveFailedRequest;
    ULONG64 BlockedFailedRequest;
    ULONG64 RequestSenseIrp;
    ULONG64 BypassSrbDataList_Next;
    ULONG64 RequestList_Flink;
    ULONG64 CommonExtension_DeviceObject;
    ULONG64 AddrOf_InquiryData;
    ULONG64 AddrOf_RequestSenseSrb;
    ULONG64 AddrOf_RequestSenseMdl;
    ULONG64 AddrOf_BypassSrbDataBlocks;
    ULONG64 AddrOf_RequestList;
    ULONG logEntries;

    ULONG Adapter_TickCount;

    FIELD_INFO deviceFields[] = {
       {"PathId", NULL, 0, COPY, 0, (PVOID) &PathId},
       {"TargetId", NULL, 0, COPY, 0, (PVOID) &TargetId},
       {"Lun", NULL, 0, COPY, 0, (PVOID) &Lun},
       {"PortNumber", NULL, 0, COPY, 0, (PVOID) &PortNumber},
       {"IsClaimed", NULL, 0, COPY, 0, (PVOID) &IsClaimed},
       {"IsMissing", NULL, 0, COPY, 0, (PVOID) &IsMissing},
       {"IsEnumerated", NULL, 0, COPY, 0, (PVOID) &IsEnumerated},
       {"IsVisible", NULL, 0, COPY, 0, (PVOID) &IsVisible},
       {"IsMismatched", NULL, 0, COPY, 0, (PVOID) &IsMismatched},
       {"LuFlags", NULL, 0, COPY, 0, (PVOID) &LunLuFlags},
       {"RetryCount", NULL, 0, COPY, 0, (PVOID) &RetryCount},
       {"CurrentKey", NULL, 0, COPY, 0, (PVOID) &CurrentKey},
       {"QueueCount", NULL, 0, COPY, 0, (PVOID) &QueueCount},
       {"QueueLockCount", NULL, 0, COPY, 0, (PVOID) &QueueLockCount},
       {"QueuePauseCount", NULL, 0, COPY, 0, (PVOID) &QueuePauseCount},       
       {"HwLogicalUnitExtension", NULL, 0, COPY, 0, (PVOID) &HwLogicalUnitExtension},
       {"AdapterExtension", NULL, 0, COPY, 0, (PVOID) &AdapterExtension},
       {"RequestTimeoutCounter", NULL, 0, COPY, 0, (PVOID) &RequestTimeoutCounter},
       {"NextLogicalUnit", NULL, 0, COPY, 0, (PVOID) &NextLogicalUnit},
       {"ReadyLogicalUnit", NULL, 0, COPY, 0, (PVOID) &ReadyLogicalUnit},
       {"PendingRequest", NULL, 0, COPY, 0, (PVOID) &PendingRequest},       
       {"BusyRequest", NULL, 0, COPY, 0, (PVOID) &BusyRequest},
       {"CurrentUntaggedRequest", NULL, 0, COPY, 0, (PVOID) &CurrentUntaggedRequest},
       {"CompletedAbort", NULL, 0, COPY, 0, (PVOID) &CompletedAbort},    
       {"AbortSrb", NULL, 0, COPY, 0, (PVOID) &AbortSrb},
       {"MaxQueueDepth", NULL, 0, COPY, 0, (PVOID) &MaxQueueDepth},
       {"TargetDeviceMapKey", NULL, 0, COPY, 0, (PVOID) &TargetDeviceMapKey},
       {"LunDeviceMapKey", NULL, 0, COPY, 0, (PVOID) &LunDeviceMapKey},
       {"ActiveFailedRequest", NULL, 0, COPY, 0, (PVOID) &ActiveFailedRequest},
       {"BlockedFailedRequest", NULL, 0, COPY, 0, (PVOID) &BlockedFailedRequest},
       {"RequestSenseIrp", NULL, 0, COPY, 0, (PVOID) &RequestSenseIrp},
       {"BypassSrbDataList.Next", NULL, 0, COPY, 0, (PVOID) &BypassSrbDataList_Next},
       {"InquiryData", NULL, 0, ADDROF, 0, NULL},
       {"RequestSenseSrb", NULL, 0, ADDROF, 0, NULL},
       {"RequestSenseMdl", NULL, 0, ADDROF, 0, NULL},
       {"BypassSrbDataBlocks", NULL, 0, ADDROF, 0, NULL},
       {"RequestList", NULL, 0, ADDROF, 0, NULL},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_LOGICAL_UNIT_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       LunAddress,
       NULL, NULL, NULL,
       sizeof (deviceFields) / sizeof (FIELD_INFO),
       &deviceFields[0]
    };

    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        dprintf("%08p: Could not read _LOGICAL_UNIT_EXTENSION\n", LunAddress);
        return;
    }

    Fields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    AddrOf_RequestList = deviceFields[Fields-1].address;
    AddrOf_BypassSrbDataBlocks = deviceFields[Fields-2].address;
    AddrOf_RequestSenseMdl = deviceFields[Fields-3].address;
    AddrOf_RequestSenseSrb = deviceFields[Fields-4].address;
    AddrOf_InquiryData = deviceFields[Fields-5].address;

    result = GetFieldData(AddrOf_RequestList,
                          "scsiport!LIST_ENTRY",
                          "Flink",
                          sizeof(ULONG64),
                          &RequestList_Flink);
    if (result) {
        dprintf("Error reading request list from adapter extension @%p\n", AdapterExtension);
        return;
    }

    result = GetFieldData(AdapterExtension,
                          "scsiport!_ADAPTER_EXTENSION",
                          "TickCount",
                          sizeof(ULONG),
                          &Adapter_TickCount);
    if (result) {
        dprintf("Error reading TickCount from adapter extension @%p\n", AdapterExtension);
        return;
    }

    InitTypeRead(LunAddress, scsiport!_LOGICAL_UNIT_EXTENSION);
    QueueCount = (ULONG)ReadField(QueueCount);

    xdprintfEx(Depth, ("Address (%d, %d, %d, %d) %s %s %s %s %s\n",
               PortNumber, PathId, TargetId, Lun,
               (IsClaimed ? "Claimed" : ""),
               (IsMissing ? "Missing" : ""),
               (IsEnumerated ? "Enumerated" : ""),
               (IsVisible ? "Visible" : ""),
               (IsMismatched ? "Mismatched" : "")));

    //
    // Print out the various LU flags
    //

    DumpFlags(Depth, "LuFlags", LunLuFlags, LuFlags);

    xdprintfEx(Depth, ("Retry 0x%02x          Key 0x%08lx\n",
               RetryCount, CurrentKey));

    xdprintfEx(Depth, ("Lock 0x%08lx  Pause 0x%08lx   CurrentLock: 0x%p\n",
               QueueLockCount, QueuePauseCount, NULL));

    xdprintfEx(Depth, ("HwLuExt 0x%08p  Adapter 0x%08p  Timeout 0x%08x\n",
               HwLogicalUnitExtension, AdapterExtension,
               RequestTimeoutCounter));

    xdprintfEx(Depth, ("NextLun 0x%p  ReadyLun 0x%p\n",
               NextLogicalUnit, ReadyLogicalUnit));

    xdprintfEx(Depth, ("Pending 0x%p  Busy 0x%p     Untagged 0x%p\n",
               PendingRequest,
               BusyRequest,
               CurrentUntaggedRequest));

    if((CompletedAbort != 0) || (AbortSrb != 0)) {
        xdprintfEx(Depth, ("Abort 0x%p    Completed Abort 0x%p\n",
                   AbortSrb, CompletedAbort));
    }

    xdprintfEx(Depth, ("Q Depth %03d (%03d)   InquiryData 0x%p\n",
               QueueCount, MaxQueueDepth, AddrOf_InquiryData));

    xdprintfEx(Depth, ("DeviceMap Keys: Target %#08lx   Lun %#08lx\n",
               TargetDeviceMapKey, LunDeviceMapKey));

    xdprintfEx(Depth, ("Bypass SRB_DATA blocks %d @ %08p   List %08p\n", 
               NUMBER_BYPASS_SRB_DATA_BLOCKS, 
               AddrOf_BypassSrbDataBlocks,
               BypassSrbDataList_Next));

    if((ActiveFailedRequest != 0) ||
       (BlockedFailedRequest != 0)) {
        xdprintfEx(Depth, ("Failed Requests - "));

        if(ActiveFailedRequest != 0) {
            dprintf("Active %#08I ", ActiveFailedRequest);
        }

        if(BlockedFailedRequest != 0) {
            dprintf("Blocked %#08I ", BlockedFailedRequest);
        }
        dprintf("\n");
    }

    xdprintfEx(Depth, ("RS Irp %p  Srb @ %p   MDL @ %p\n", 
               RequestSenseIrp,
               AddrOf_RequestSenseSrb,
               AddrOf_RequestSenseMdl));

    if((RequestList_Flink) == AddrOf_RequestList) {
        xdprintfEx(Depth, ("Request List @0x%p is empty\n",
                   AddrOf_RequestList));
    } else {
        xdprintfEx(Depth, ("Request list @0x%p:\n", AddrOf_RequestList));
        ScsiDumpActiveRequests(AddrOf_RequestList,
                               Adapter_TickCount,
                               Depth + 2);
    }

    if (Detail != 0) {

        //
        // The caller wants additional detail.  Dump the queued requests.
        // Extract the address of the device object from the common extension
        // and pass it to the routine that dumps queued requests.
        //

        ULONG64 DeviceObject;
        result = GetFieldData(LunAddress,
                              "scsiport!_COMMON_EXTENSION",
                              "DeviceObject",
                              sizeof(ULONG64),
                              &DeviceObject);
        if (result) {
            dprintf("Error reading DeviceObject @%p\n", LunAddress);
            return;
        }
        
        xdprintfEx(Depth, ("Queued requests:\n"));
        ScsiDumpQueuedRequests(
            DeviceObject,       
            Adapter_TickCount,
            Depth + 2
            );
    }

    //
    // Dump the per-lun IO log.
    //

    InitTypeRead(LunAddress, scsiport!_LOGICAL_UNIT_EXTENSION); 
    logEntries = (ULONG) ReadField(IoLogEntries);

    if (logEntries > 0) {
        ULONG index;
        ULONG offset;
        ULONG64 logAddress;
        SP_LUN_IO_LOG ioLog[10] = {0};
        ULONG bytesRead;
        PSP_LUN_IO_LOG entry;
        ULONG i;

        dprintf("Log:\n");

        if (logEntries >= 10) {
            //
            // The current index is the oldest entry in the log.
            //
            index = (ULONG) ReadField(IoLogIndex);
            if (index >= 10) {
                index = 0;
            }
        } else {
            //
            // we haven't wrapped so zero is the oldest entry in the log.
            //
            index = 0;
        }
        
        //
        // Get the offset of the log array relative to the beginning of the
        // logical unit extension.
        //
        result = GetFieldOffset("scsiport!_LOGICAL_UNIT_EXTENSION",
                                "IoLog",
                                &offset);
        if (result != 0) {
            goto NoLogEntry;
        }

        //
        // Calculate the address of the log.
        // 
        logAddress = LunAddress + offset;

        //
        // Read all of the log entries.
        //
        result = ReadMemory(logAddress, 
                            (PVOID) ioLog, 
                            sizeof(SP_LUN_IO_LOG) * 10, 
                            &bytesRead);

        xdprintfEx(Depth, ("\n"));
        xdprintfEx(Depth, ("                  Srb    Scsi         \n"));
        xdprintfEx(Depth, ("TickCount   Cmd   Status Status Sector     Tag\n"));
        xdprintfEx(Depth, ("---------   ---   ------ ------ --------   ---\n"));
        
        //
        // Dump the log, beginning with the oldest entry.
        //
        for (i=0; i<logEntries; i++) {
            entry = &ioLog[index];

            xdprintfEx(Depth, ("%08x    %02x    %02x     %02x     %08x   %02x",
                       entry->TickCount,
                       entry->Cdb[0],
                       entry->SrbStatus,
                       entry->ScsiStatus,
                       entry->QueueSortKey,
                       entry->Tag
                       ));

            if (entry->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
                PSENSE_DATA senseData  = (PSENSE_DATA) entry->SenseData;
                dprintf("  (%x, %x, %x)\n",
                        senseData->ErrorCode,
                        senseData->AdditionalSenseCode,
                        senseData->AdditionalSenseCodeQualifier);
            } else {
                dprintf("\n");
            }

            index++;
            if (index == 10) {
                index = 0;
            }
        }
    }

NoLogEntry:
    
    return;
}

VOID
ScsiDumpActiveRequests(
    IN ULONG64 ListHead,
    IN ULONG TickCount,
    IN ULONG Depth
    )
{
    ULONG result;

    ULONG64 lastEntry = 0;
    ULONG64 entry = 0;
    ULONG64 realEntry = 0;
    ULONG64 CurrentSrb = 0;
    ULONG64 CurrentIrp = 0;
    ULONG64 RequestList = 0;
    ULONG OffsetOfRequestList = 0;
    ULONG SrbTickCount = 0;
    ULONG Key = 0;

    FIELD_INFO deviceFields[] = {
        {"CurrentSrb", NULL, 0, COPY, 0, (PVOID) &CurrentSrb},
        {"CurrentIrp", NULL, 0, COPY, 0, (PVOID) &CurrentIrp},
        {"TickCount", NULL, 0, COPY, 0, (PVOID) &SrbTickCount},
        {"RequestList", NULL, 0, ADDROF, 0, NULL},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_SRB_DATA", 
       DBG_DUMP_NO_PRINT, 
       0,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    result = GetFieldOffset("scsiport!_SRB_DATA", 
                            "RequestList",
                            &OffsetOfRequestList);
    if (result) {
        dprintf("failed to get offset of request list (%08X)\n", result);
        return;
    }
    
    entry = ListHead;
    realEntry = entry;
    
    InitTypeRead(ListHead, nt!_LIST_ENTRY);
    lastEntry = ReadField(Blink);

    xdprintfEx(Depth, ("Tick count is %d\n", TickCount));

    do {

        ULONG64 realSrbData;

        GetFieldData(realEntry,
                     "scsiport!_LIST_ENTRY",
                     "Flink",
                     sizeof(ULONG64),
                     &entry);

        //
        // entry points to the list entry element of the srb data.  Calculate
        // the address of the start of the srb data block.
        //

        realSrbData = entry - OffsetOfRequestList;

        xdprintfEx(Depth, ("SrbData %08p   ", realSrbData));

        //
        // Read the SRB_DATA information we need.
        //

        DevSym.addr = realSrbData;
        if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
            dprintf("%08p: Could not read device object\n", realSrbData);
            return;
        }
        RequestList = deviceFields[3].address;
        

        InitTypeRead(CurrentSrb, scsiport!_SCSI_REQUEST_BLOCK);
        Key = (ULONG)ReadField(QueueSortKey);

        //
        // Update realEntry.
        //

        realEntry = RequestList;

        dprintf("Srb %08p   Irp %08p   Key %x  %s\n",
                CurrentSrb,
                CurrentIrp,
                Key,
                SecondsToString(TickCount - SrbTickCount));

    } while((entry != lastEntry) && (!CheckControlC()));

    return;
}

VOID
ScsiDumpLocks(
    ULONG64 CommonExtension,
    ULONG Depth
    )

/*++

Routine Description:

    dumps the remove locks for a given device object

Arguments:

    CommonExtension - a pointer to the local copy of the device object
                      common extension

Return Value:

    None

--*/

{
    ULONG result;

    LONG RemoveLock;
    ULONG64 RemoveTrackingSpinlock;
    ULONG64 RemoveTrackingList;

    InitTypeRead(CommonExtension, scsiport!_COMMON_EXTENSION);
    RemoveLock = (ULONG) ReadField(RemoveLock);
    RemoveTrackingSpinlock = ReadField(RemoveTrackingSpinlock);
    RemoveTrackingList = ReadField(RemoveTrackingList);

    xdprintfEx(Depth, ("RemoveLock count is %d", RemoveLock));

    if((PVOID)RemoveTrackingSpinlock != (PVOID)-1) {

        ULONG64 lockEntryAddress = RemoveTrackingList;

        dprintf(":\n");
        Depth++;

        if(RemoveTrackingSpinlock != 0) {
            xdprintfEx(Depth, ("RemoveTrackingList is in intermediate state"
                       "@ %p\n", RemoveTrackingList));
            return;
        }

        while((lockEntryAddress != 0L) && !CheckControlC()) {

            UCHAR buffer[512];
            ULONG64 File;
            ULONG64 Tag;
            ULONG64 NextBlock;
            ULONG Line;
            
            InitTypeRead(lockEntryAddress, scsiport!REMOVE_TRACKING_BLOCK);
            File = ReadField(File);
            Tag = ReadField(Tag);
            Line = (ULONG) ReadField(Line);
            NextBlock = ReadField(NextBlock);

            result = sizeof(buffer);

            if(!GetAnsiString(File,
                              buffer,
                              &result)) {

                xdprintfEx(Depth, ("Tag 0x%p File 0x%p Line %d\n",
                           Tag,
                           File,
                           Line));
            } else {

                PUCHAR name;

                name = &buffer[result];

                while((result > 0) &&
                      (*(name - 1) != '\\') &&
                      (*(name - 1)  != '/') &&
                      (!CheckControlC())) {
                    name--;
                    result--;
                }

                xdprintfEx(Depth, ("Tag 0x%p   File %s   Line %d\n",
                           Tag,
                           name,
                           Line));
            }

            lockEntryAddress = NextBlock;
        }
    } else {
        dprintf(" (not tracked on free build)\n");
    }
    return;
}

VOID
ScsiDumpSrbData(
    ULONG64 SrbData,
    ULONG Depth
    )
{
    ULONG result;

    CSHORT Type = 0;
    ULONG64 LogicalUnit = 0;
    ULONG64 CurrentSrb = 0;
    ULONG64 CurrentIrp = 0;
    ULONG64 RequestSenseSave = 0;
    ULONG QueueTag = 0;
    ULONG64 CompletedRequests = 0;
    ULONG ErrorLogRetryCount = 0;
    ULONG SequenceNumber = 0;
    ULONG Flags = 0;
    ULONG64 RequestListFlink = 0;
    ULONG64 RequestListBlink = 0;
    ULONG64 DataOffset = 0;
    ULONG64 OriginalDataBuffer = 0;
    ULONG64 MapRegisterBase = 0;
    ULONG NumberOfMapRegisters = 0;
    ULONG64 ScatterGatherList = 0;

    FIELD_INFO deviceFields[] = {
       {"Type", NULL, 0, COPY, 0, (PVOID) &Type},
       {"LogicalUnit", NULL, 0, COPY, 0, (PVOID) &LogicalUnit},
       {"CurrentSrb", NULL, 0, COPY, 0, (PVOID) &CurrentSrb},
       {"CurrentIrp", NULL, 0, COPY, 0, (PVOID) &CurrentIrp},
       {"RequestSenseSave", NULL, 0, COPY, 0, (PVOID) &RequestSenseSave},
       {"QueueTag", NULL, 0, COPY, 0, (PVOID) &QueueTag},
       {"CompletedRequests", NULL, 0, COPY, 0, (PVOID) &CompletedRequests},
       {"ErrorLogRetryCount", NULL, 0, COPY, 0, (PVOID) &ErrorLogRetryCount},
       {"SequenceNumber", NULL, 0, COPY, 0, (PVOID) &SequenceNumber},
       {"Flags", NULL, 0, COPY, 0, (PVOID) &Flags},
       {"RequestList.Flink", NULL, 0, COPY, 0, (PVOID) &RequestListFlink},
       {"RequestList.Blink", NULL, 0, COPY, 0, (PVOID) &RequestListBlink},
       {"DataOffset", NULL, 0, COPY, 0, (PVOID) &DataOffset},
       {"OriginalDataBuffer", NULL, 0, COPY, 0, (PVOID) &OriginalDataBuffer},
       {"MapRegisterBase", NULL, 0, COPY, 0, (PVOID) &MapRegisterBase},
       {"NumberOfMapRegisters", NULL, 0, COPY, 0, (PVOID) &NumberOfMapRegisters},
       {"ScatterGatherList", NULL, 0, COPY, 0, (PVOID) &ScatterGatherList},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_SRB_DATA", 
       DBG_DUMP_NO_PRINT, 
       SrbData,
       NULL, NULL, NULL,
       sizeof (deviceFields) / sizeof (FIELD_INFO),
       &deviceFields[0]
    };

    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    if(Type != SRB_DATA_TYPE) {
        dprintf("Type (%#x) does not match SRB_DATA_TYPE (%#x)\n",
                Type, SRB_DATA_TYPE);
    }

    xdprintfEx(Depth, ("Lun  0x%p   Srb 0x%p   Irp 0x%p\n",
             LogicalUnit, CurrentSrb, CurrentIrp));

    xdprintfEx(Depth, ("Sense 0x%p  Tag  0x%08lx  Next Completed 0x%p\n",
             RequestSenseSave,
             QueueTag, CompletedRequests));

    xdprintfEx(Depth, ("Retry 0x%02x        Seq 0x%08lx   Flags 0x%08lx\n",
             ErrorLogRetryCount, SequenceNumber,
             Flags));

    xdprintfEx(Depth, ("Request List:     Next 0x%p  Previous 0x%p\n",
             RequestListFlink, RequestListBlink));

    xdprintfEx(Depth, ("Data Offset 0x%p    Original Data Buffer 0x%p\n", DataOffset, OriginalDataBuffer));

    xdprintfEx(Depth, ("Map Registers 0x%p (0x%02x)    SG List 0x%p\n",
             MapRegisterBase,
             NumberOfMapRegisters,
             ScatterGatherList));

    if(ScatterGatherList != 0) {
        
        ScsiDumpScatterGatherList(ScatterGatherList, 
                                  NumberOfMapRegisters, 
                                  Depth + 1);
    }

    return;

}


VOID
ScsiDumpScatterGatherList(
    ULONG64 List,
    ULONG Entries,
    ULONG Depth
    )
{
    ULONG result;
    ULONG i;
    ULONG start = TRUE;
    ULONG64 PhysicalAddress;
    ULONG Length;

    for(i = 0; i < Entries; i++) {

        InitTypeRead(List, nt!_SCATTER_GATHER_ELEMENT);
        PhysicalAddress = ReadField(Address);
        Length = (ULONG) ReadField(Length);

        if(start) {
            xdprintfEx(Depth, ("0x%016I64x (0x%08lx), ",
                     PhysicalAddress,
                     Length));
        } else {
            dprintf("0x%016I64x (0x%08lx),\n",
                    PhysicalAddress,
                    Length);
        }

        start = !start;
        List += (IsPtr64() != 0) ? 0x18 : 0xc;
    }

    if(!start) {
        dprintf("\n");
    }
}

DECLARE_API(srbdata)
{
    ULONG64 address;

    GetExpressionEx(args, &address, &args);

    dprintf("SrbData structure at %#p\n", address);

    ScsiDumpSrbData(address, 1);

    return S_OK;
}

VOID
ScsiDumpAdapterPerfCounters(
    ULONG64 Adapter,
    ULONG Depth
    )
{
#if TEST_LISTS
    ULONG result;

    ULONG SmallAllocationCount;
    ULONG LargeAllocationCount;
    ULONG64 ScatterGatherAllocationCount;
    ULONG64 SmallAllocationSize;
    ULONG64 MediumAllocationSize;
    ULONG64 LargeAllocationSize;
    ULONG64 SrbDataAllocationCount;
    ULONG64 SrbDataResurrectionCount;
    ULONG64 SrbDataEmergencyFreeCount;

    FIELD_INFO deviceFields[] = {
       {"SmallAllocationCount", NULL, 0, COPY, 0, (PVOID) &SmallAllocationCount},
       {"LargeAllocationCount", NULL, 0, COPY, 0, (PVOID) &LargeAllocationCount},
       {"ScatterGatherAllocationCount", NULL, 0, COPY, 0, (PVOID) &ScatterGatherAllocationCount},
       {"SmallAllocationSize", NULL, 0, COPY, 0, (PVOID) &SmallAllocationSize},
       {"MediumAllocationSize", NULL, 0, COPY, 0, (PVOID) &MediumAllocationSize},
       {"LargeAllocationSize", NULL, 0, COPY, 0, (PVOID) &LargeAllocationSize},
       {"SrbDataAllocationCount", NULL, 0, COPY, 0, (PVOID) &SrbDataAllocationCount},
       {"SrbDataResurrectionCount", NULL, 0, COPY, 0, (PVOID) &SrbDataResurrectionCount},
       {"SrbDataEmergencyFreeCount", NULL, 0, COPY, 0, (PVOID) &SrbDataEmergencyFreeCount},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_ADAPTER_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Adapter,
       NULL, NULL, NULL,
       sizeof (deviceFields) / sizeof (FIELD_INFO),
       &deviceFields[0]
    };

    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    ULONG mediumAllocationCount = (ULONG)
        (ScatterGatherAllocationCount -
         (SmallAllocationCount +
          LargeAllocationCount));

    double average;

    xdprintfEx(Depth, ("Performance Counters:\n"));

    Depth++;

    xdprintfEx(Depth, ("SGList Allocs - "));
    dprintf("Small: %d, ", SmallAllocationCount);
    dprintf("Med: %d, ",
            (ScatterGatherAllocationCount -
             SmallAllocationCount -
             LargeAllocationCount));
    dprintf("Large: %d, ", LargeAllocationCount);
    dprintf("Total: %I64d\n",
            ScatterGatherAllocationCount);

    xdprintfEx(Depth, ("Average SG Entries - "));

    if(SmallAllocationCount != 0) {
        average = ((double) (SmallAllocationSize)) / SmallAllocationCount;
        dprintf("Small: %.2f   ", average);
    }

    if(mediumAllocationCount != 0) {
        average = ((double) (MediumAllocationSize)) / mediumAllocationCount;
        dprintf("Medium: %.2f   ", average);
    }

    if(Adapter->LargeAllocationCount != 0) {
        average = ((double) (Adapter->LargeAllocationSize)) / LargeAllocationCount;
        dprintf("Large: %.2f", average);
    }

    dprintf("\n");

    xdprintfEx(Depth, ("SrbData - Allocs: %I64d, ",
               SrbDataAllocationCount));

    dprintf("Resurrected: %I64d, ",
            SrbDataResurrectionCount);

    dprintf("Timer Serviced: %I64d,\n",
            SrbDataServicedFromTickHandlerCount);

    xdprintfEx(Depth, ("          Queued: %I64d, ",
               SrbDataQueueInsertionCount));

    dprintf("Emergency Freed: %I64d\n",
            SrbDataEmergencyFreeCount);

#endif
    return;
}

PUCHAR
SecondsToString(
    ULONG Count
    )  
{
    static UCHAR string[64] = "";
    UCHAR tmp[16];

    ULONG seconds = 0;
    ULONG minutes = 0;
    ULONG hours = 0;
    ULONG days = 0;

    string[0] = '\0';

    if(Count == 0) {
        sprintf(string, "<1s");
        return string;
    }

    seconds = Count % 60;
    Count /= 60;

    if(Count != 0) {
        minutes = Count % 60;
        Count /= 60;
    }
        
    if(Count != 0) {
        hours = Count % 24;
        Count /= 24;
    }

    if(Count != 0) {
        days = Count;
    }

    if(days != 0) {
        sprintf(tmp, "%dd", days);
        strcat(string, tmp);
    }

    if(hours != 0) {
        sprintf(tmp, "%dh", hours);
        strcat(string, tmp);
    }

    if(minutes != 0) {
        sprintf(tmp, "%dm", minutes);
        strcat(string, tmp);
    }

    if(seconds != 0) {
        sprintf(tmp, "%ds", seconds);
        strcat(string, tmp);
    }

    return string;
}

VOID
ScsiDumpQueuedRequests(
    IN ULONG64 DeviceObject,
    IN ULONG TickCount,
    IN ULONG Depth
    )
{
    ULONG result;
    ULONG64 ListHeadFlink;
    ULONG64 ListHeadBlink;
    ULONG64 DeviceListHead;
    ULONG64 realEntry;

    //
    // Get the address of the head of the device list in the device queue.
    //

    result = GetFieldData(
                 DeviceObject,
                 "scsiport!_DEVICE_OBJECT",
                 "DeviceQueue.DeviceListHead",
                 sizeof(ULONG64),
                 &DeviceListHead);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    //
    // Get the forward and backward link fields from the list head.  If
    // the queue is empty, we're done.
    //

    InitTypeRead(DeviceListHead, scsiport!_LIST_ENTRY);
    ListHeadFlink = ReadField(CurrentSrb);
    ListHeadBlink = ReadField(CurrentIrp);
                 
    if (ListHeadFlink == ListHeadBlink) {
        xdprintfEx(Depth, ("Device Queue is empty\n"));
        return;
    }

    //
    // Initialize a pointer the head of the list.
    //

    realEntry = DeviceListHead;

    do {

        ULONG64 realIrp;
        ULONG64 realStack;
        ULONG64 realSrb;
        ULONG64 realSrbData;
        ULONG64 CurrentSrb;
        ULONG64 CurrentIrp;
        ULONG OffsetOfDeviceListEntry;
        ULONG SrbDataTickCount;

        //
        // Get the address of the next entry in the queue.
        //

        result = GetFieldData(realEntry,
                              "scsiport!_LIST_ENTRY",
                              "Flink",
                              sizeof(ULONG64),
                              &realEntry);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }
        
        //
        // We to calculate the address of the IRP using the address of the 
        // list entry.  Can't use static CONTAINING_RECORD; we need a runtime 
        // equivalent.  So we use type info to get the offset of the list 
        // entry and calculate the address of the beginning of the IRP.  This
        // makes the extension work for 32b and 64b debuggees.
        //

        result = GetFieldOffset(
                     "scsiport!_IRP",
                     "Tail.Overlay.DeviceQueueEntry.DeviceListEntry",
                     &OffsetOfDeviceListEntry);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }

        realIrp = realEntry - OffsetOfDeviceListEntry;

        //
        // Now we need to read in the address of the current IO stack 
        // location.
        //

        result = GetFieldData(
                     realIrp,
                     "scsiport!_IRP",
                     "Tail.Overlay.CurrentStackLocation",
                     sizeof(ULONG64),
                     &realStack);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }

        //
        // Load the SRB field of the stack location.
        //

        result = GetFieldData(
                     realStack,
                     "scsiport!_IO_STACK_LOCATION",
                     "Parameters.Scsi.Srb",
                     sizeof(ULONG64),
                     &realSrb);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }

        //
        // Pick out the pointer to the srb data and read that in.
        //

        result = GetFieldData(
                     realSrb,
                     "scsiport!_SCSI_REQUEST_BLOCK",
                     "OriginalRequest",
                     sizeof(ULONG64),
                     &realSrbData);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }

        xdprintfEx(Depth, ("SrbData 0x%p   ", realSrbData));

        //
        // Read the SRB_DATA information we need.
        //

        InitTypeRead(realSrb, scsiport!_SRB_DATA);
        CurrentSrb = ReadField(CurrentSrb);
        CurrentIrp = ReadField(CurrentIrp);
        SrbDataTickCount = (ULONG)ReadField(TickCount);

        dprintf("Srb 0x%p   Irp 0x%p   %s\n",
                CurrentSrb,
                CurrentIrp,
                SecondsToString(TickCount - SrbDataTickCount));

    } while((realEntry != ListHeadBlink) && (!CheckControlC()));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <scsi.h>
#include <srb.h>


#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;

// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

#define EXIT_API     ExtRelease

extern WINDBG_EXTENSION_APIS ExtensionApis;

#define SCSIKD_PRINT_ERROR(r)\
    dprintf("scsikd error (%x): %s @ line %d\n", (r), __FILE__, __LINE__);


#define RECUR  DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY   DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS
#define ADDROF DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

//#define KDBG_EXT

#include "wmistr.h"

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

__inline 
VOID
xdindent(
    ULONG Depth
    )
{
    ULONG i;
    for (i=0; i<Depth; i++)
        dprintf("  ");
}

#define xdprintfEx(d, expr)\
    xdindent((d));\
    dprintf expr

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

BOOLEAN
GetAnsiString(
    IN ULONG64 Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    );

PCHAR
GuidToString(
    GUID* GUID
    );

ULONG64
GetDeviceExtension(
    ULONG64 address
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\scsikd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       scsikd.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsiportsym\makefile.inc ===
$(O)\scsiport.c : scsiport.c
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsiportsym\scsiport.c ===
#include "ntddk.h"
#include "port.h"

//Port-Driver Data Structures

ADAPTER_EXTENSION              AdapterExtension;
LOGICAL_UNIT_EXTENSION         LogicalUnitExtension;
SCSI_REQUEST_BLOCK             Srb;
COMMON_EXTENSION               CommonExtension;
REMOVE_TRACKING_BLOCK          RemoveTrackingBlock;
INTERRUPT_DATA                 InterruptData;
SRB_DATA                       SrbData;
PORT_CONFIGURATION_INFORMATION PortConfigInfo; 

int __cdecl main() { 
    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\util.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    util.c

Abstract:

    Utility library used for the various debugger extensions in this library.

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#include "classkd.h"  // routines that are useful for all class drivers

PUCHAR devicePowerStateNames[] = {
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum",
    "Invalid"
};


char *g_genericErrorHelpStr =   "\n" \
                                "**************************************************************** \n" \
                                "  Make sure you have _private_ symbols for classpnp.sys loaded.\n" \
                                "  The FDO parameter should be the upper AttachedDevice of the disk/cdrom/etc PDO\n" \
                                "  as returned by '!devnode 0 1 {disk|cdrom|4mmdat|etc}'.\n" \
                                "**************************************************************** \n\n" \
                                ;


PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    )

{
    ULONG stateIndex = (ULONG)State;
    
    if(stateIndex > PowerDeviceMaximum) {
        return "Invalid";
    } else {
        return devicePowerStateNames[stateIndex];
    }
}


/*
 *  xdprintf
 *
 *      Prints formatted text with leading spaces.
 *
 *      WARNING:  DOES NOT HANDLE ULONG64 PROPERLY.
 */
VOID
xdprintf(
    ULONG  Depth,
    PCCHAR Format,
    ...
    )
{
    va_list args;
    ULONG i;
    CCHAR DebugBuffer[256];

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(args, Format);
    _vsnprintf(DebugBuffer, 255, Format, args);
    dprintf (DebugBuffer);
    va_end(args);
}

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64] = {0};

    _snprintf(prolog, sizeof(prolog)-1, "%s (0x%08x): ", Name, Flags);

    xdprintf(Depth, "%s", prolog);

    if(Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}


BOOLEAN
GetAnsiString(
    IN ULONG64 Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    )
{
    ULONG i = 0;

    //
    // Grab the string in 128 character chunks until we find a NULL or the read fails.
    //

    while((i < *Length) && (!CheckControlC())) {

        ULONG transferSize;
        ULONG result;

        if(*Length - i < 128) {
            transferSize = *Length - i;
        } else {
            transferSize = 128;
        }

        if(!ReadMemory(Address + i,
                       Buffer + i,
                       transferSize,
                       &result)) {
            //
            // read failed and we didn't find the NUL the last time.  Don't
            // expect to find it this time.
            //

            *Length = i;
            return FALSE;

        } else {

            ULONG j;

            //
            // Scan from where we left off looking for that NUL character.
            //

            for(j = 0; j < transferSize; j++) {

                if(Buffer[i + j] == '\0') {
                    *Length = i + j;
                    return TRUE;
                }
            }
        }

        i += transferSize;
    }

    /*
     *  We copied all the bytes allowed and did not hit the NUL character.
     *  Insert a NUL character so returned string is terminated.
     */
    if (i > 0){   
        Buffer[i-1] = '\0';  
    }       
    *Length = i;
    
    return FALSE;
}

PCHAR
GuidToString(
    GUID* Guid
    )
{
    static CHAR Buffer [64];
    
    sprintf (Buffer,
             "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
             Guid->Data1,
             Guid->Data2,
             Guid->Data3,
             Guid->Data4[0],
             Guid->Data4[1],
             Guid->Data4[2],
             Guid->Data4[3],
             Guid->Data4[4],
             Guid->Data4[5],
             Guid->Data4[6],
             Guid->Data4[7]
             );

    return Buffer;
}


ULONG64
GetDeviceExtension(
    ULONG64 address
    )

/*++

Routine Description:

    The function accepts the address of either a device object or a device
    extension.  If the supplied address is that of a device object, the
    device extension is retrieved and returned.  If the address is that of
    a device extension, the address is returned unmodified.

Arguments:

    Address - address of a device extension or a device object

Return Value:

    The address of the device extension or 0 if an error occurs.

--*/

{
    ULONG result;
    CSHORT Type;
    ULONG64 Address = address;

    //
    // The supplied address may be either the address of a device object or the
    // address of a device extension.  To distinguish which, we treat the 
    // address as a device object and read what would be its type field.  If
    // the 
    //

    result = GetFieldData(Address,
                          "scsiport!_DEVICE_OBJECT",
                          "Type",
                          sizeof(CSHORT),
                          &Type
                          );
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return 0;
    }
    
    //
    // See if the supplied address holds a device object.  If it does, read the
    // address of the device extension.  Otherwise, we assume the supplied
    // addres holds a device extension and we use it directly.
    //

    if (Type == IO_TYPE_DEVICE) {

        result = GetFieldData(Address,
                              "scsiport!_DEVICE_OBJECT",
                              "DeviceExtension",
                              sizeof(ULONG64),
                              &Address
                              );
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return 0;
        }
    }

    return Address;
}



/*
 *  GetULONGField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
ULONG64 GetULONGField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(ULONG64), &result);
    if (dbgStat != 0){
        dprintf("\n GetULONGField: GetFieldData failed with %xh retrieving field '%s' of struct '%s', returning bogus field value %08xh.\n", dbgStat, FieldName, StructType, BAD_VALUE);
        dprintf(g_genericErrorHelpStr);        
        result = BAD_VALUE;
    }

    return result;
}


/*
 *  GetUSHORTField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
USHORT GetUSHORTField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    USHORT result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(USHORT), &result);
    if (dbgStat != 0){
        dprintf("\n GetUSHORTField: GetFieldData failed with %xh retrieving field '%s' of struct '%s', returning bogus field value %08xh.\n", dbgStat, FieldName, StructType, BAD_VALUE);
        dprintf(g_genericErrorHelpStr);
        result = (USHORT)BAD_VALUE;
    }

    return result;
}


/*
 *  GetUCHARField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
UCHAR GetUCHARField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    UCHAR result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(UCHAR), &result);
    if (dbgStat != 0){
        dprintf("\n GetUCHARField: GetFieldData failed with %xh retrieving field '%s' of struct '%s', returning bogus field value %08xh.\n", dbgStat, FieldName, StructType, BAD_VALUE);
        dprintf(g_genericErrorHelpStr);
        result = (UCHAR)BAD_VALUE;
    }

    return result;
}

ULONG64 GetFieldAddr(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG offset;
    ULONG dbgStat;

    dbgStat = GetFieldOffset(StructType, FieldName, &offset);
    if (dbgStat == 0){
        result = StructAddr+offset;
    }
    else {
        dprintf("\n GetFieldAddr: GetFieldOffset failed with %xh retrieving offset of struct '%s' field '%s'.\n", dbgStat, StructType, FieldName);
        dprintf(g_genericErrorHelpStr);
        result = BAD_VALUE;
    }
    
    return result;
}


ULONG64 GetContainingRecord(ULONG64 FieldAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG offset;
    ULONG dbgStat;
    
    dbgStat = GetFieldOffset(StructType, FieldName, &offset);
    if (dbgStat == 0){
        result = FieldAddr-offset;
    }
    else {
        dprintf("\n GetContainingRecord: GetFieldOffset failed with %xh retrieving offset of struct '%s' field '%s', returning bogus address %08xh.\n", dbgStat, StructType, FieldName, BAD_VALUE);
        dprintf(g_genericErrorHelpStr);        
        result = BAD_VALUE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\scsikd\string.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    classkd.c

Abstract:

    Debugger Extension Api for interpretting scsiport structures

Author:

    ervinp

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#include "classpnp.h" // #defines ALLOCATE_SRB_FROM_POOL as needed
#include "classp.h"   // Classpnp's private definitions
#include "cdrom.h"

#include "classkd.h"  // routines that are useful for all class drivers

char *HexNumberStrings[] = {
    "00", "01", "02", "03", "04", "05", "06", "07",
    "08", "09", "0A", "0B", "0C", "0D", "0E", "0F",
    "10", "11", "12", "13", "14", "15", "16", "17",
    "18", "19", "1A", "1B", "1C", "1D", "1E", "1F",
    "20", "21", "22", "23", "24", "25", "26", "27",
    "28", "29", "2A", "2B", "2C", "2D", "2E", "2F",
    "30", "31", "32", "33", "34", "35", "36", "37",
    "38", "39", "3A", "3B", "3C", "3D", "3E", "3F",
    "40", "41", "42", "43", "44", "45", "46", "47",
    "48", "49", "4A", "4B", "4C", "4D", "4E", "4F",
    "50", "51", "52", "53", "54", "55", "56", "57",
    "58", "59", "5A", "5B", "5C", "5D", "5E", "5F",
    "60", "61", "62", "63", "64", "65", "66", "67",
    "68", "69", "6A", "6B", "6C", "6D", "6E", "6F",
    "70", "71", "72", "73", "74", "75", "76", "77",
    "78", "79", "7A", "7B", "7C", "7D", "7E", "7F",
    "80", "81", "82", "83", "84", "85", "86", "87",
    "88", "89", "8A", "8B", "8C", "8D", "8E", "8F",
    "90", "91", "92", "93", "94", "95", "96", "97",
    "98", "99", "9A", "9B", "9C", "9D", "9E", "9F",
    "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7",
    "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF",
    "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7",
    "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF",
    "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7",
    "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF",
    "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7",
    "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF",
    "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7",
    "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF",
    "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7",
    "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"
};



char *DbgGetIoctlStr(ULONG ioctl)
{
    char *ioctlStr = "?";
    
    switch (ioctl){
        
        #undef MAKE_CASE             
        #define MAKE_CASE(ioctlCode) case ioctlCode: ioctlStr = #ioctlCode; break;

        MAKE_CASE(IOCTL_STORAGE_CHECK_VERIFY)
        MAKE_CASE(IOCTL_STORAGE_CHECK_VERIFY2)
        MAKE_CASE(IOCTL_STORAGE_MEDIA_REMOVAL)
        MAKE_CASE(IOCTL_STORAGE_EJECT_MEDIA)
        MAKE_CASE(IOCTL_STORAGE_LOAD_MEDIA)
        MAKE_CASE(IOCTL_STORAGE_LOAD_MEDIA2)
        MAKE_CASE(IOCTL_STORAGE_RESERVE)
        MAKE_CASE(IOCTL_STORAGE_RELEASE)
        MAKE_CASE(IOCTL_STORAGE_FIND_NEW_DEVICES)
        MAKE_CASE(IOCTL_STORAGE_EJECTION_CONTROL)
        MAKE_CASE(IOCTL_STORAGE_MCN_CONTROL)
        MAKE_CASE(IOCTL_STORAGE_GET_MEDIA_TYPES)
        MAKE_CASE(IOCTL_STORAGE_GET_MEDIA_TYPES_EX)
        MAKE_CASE(IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER)
        MAKE_CASE(IOCTL_STORAGE_GET_HOTPLUG_INFO)
        MAKE_CASE(IOCTL_STORAGE_RESET_BUS)
        MAKE_CASE(IOCTL_STORAGE_RESET_DEVICE)
        MAKE_CASE(IOCTL_STORAGE_GET_DEVICE_NUMBER)
        MAKE_CASE(IOCTL_STORAGE_PREDICT_FAILURE)
        MAKE_CASE(IOCTL_STORAGE_QUERY_PROPERTY)
        MAKE_CASE(OBSOLETE_IOCTL_STORAGE_RESET_BUS)
        MAKE_CASE(OBSOLETE_IOCTL_STORAGE_RESET_DEVICE)
    }
  
    return ioctlStr;
}


char *DbgGetScsiOpStr(UCHAR ScsiOp)
{
    char *scsiOpStr = HexNumberStrings[ScsiOp];
    
    switch (ScsiOp){

        #undef MAKE_CASE             
        #define MAKE_CASE(scsiOpCode) case scsiOpCode: scsiOpStr = #scsiOpCode; break;
        
        MAKE_CASE(SCSIOP_TEST_UNIT_READY)
        MAKE_CASE(SCSIOP_REWIND)    // aka SCSIOP_REZERO_UNIT
        MAKE_CASE(SCSIOP_REQUEST_BLOCK_ADDR)
        MAKE_CASE(SCSIOP_REQUEST_SENSE)
        MAKE_CASE(SCSIOP_FORMAT_UNIT)
        MAKE_CASE(SCSIOP_READ_BLOCK_LIMITS)
        MAKE_CASE(SCSIOP_INIT_ELEMENT_STATUS)   // aka SCSIOP_REASSIGN_BLOCKS
        MAKE_CASE(SCSIOP_RECEIVE)       // aka SCSIOP_READ6
        MAKE_CASE(SCSIOP_SEND)  // aka SCSIOP_WRITE6, SCSIOP_PRINT
        MAKE_CASE(SCSIOP_SLEW_PRINT)    // aka SCSIOP_SEEK6, SCSIOP_TRACK_SELECT
        MAKE_CASE(SCSIOP_SEEK_BLOCK)
        MAKE_CASE(SCSIOP_PARTITION)
        MAKE_CASE(SCSIOP_READ_REVERSE)
        MAKE_CASE(SCSIOP_FLUSH_BUFFER)      // aka SCSIOP_WRITE_FILEMARKS
        MAKE_CASE(SCSIOP_SPACE)
        MAKE_CASE(SCSIOP_INQUIRY)
        MAKE_CASE(SCSIOP_VERIFY6)
        MAKE_CASE(SCSIOP_RECOVER_BUF_DATA)
        MAKE_CASE(SCSIOP_MODE_SELECT)
        MAKE_CASE(SCSIOP_RESERVE_UNIT)
        MAKE_CASE(SCSIOP_RELEASE_UNIT)
        MAKE_CASE(SCSIOP_COPY)
        MAKE_CASE(SCSIOP_ERASE)
        MAKE_CASE(SCSIOP_MODE_SENSE)
        MAKE_CASE(SCSIOP_START_STOP_UNIT)   // aka SCSIOP_STOP_PRINT, SCSIOP_LOAD_UNLOAD
        MAKE_CASE(SCSIOP_RECEIVE_DIAGNOSTIC)
        MAKE_CASE(SCSIOP_SEND_DIAGNOSTIC)
        MAKE_CASE(SCSIOP_MEDIUM_REMOVAL)
        MAKE_CASE(SCSIOP_READ_FORMATTED_CAPACITY)
        MAKE_CASE(SCSIOP_READ_CAPACITY)
        MAKE_CASE(SCSIOP_READ)
        MAKE_CASE(SCSIOP_WRITE)
        MAKE_CASE(SCSIOP_SEEK)  // aka SCSIOP_LOCATE, SCSIOP_POSITION_TO_ELEMENT
        MAKE_CASE(SCSIOP_WRITE_VERIFY)
        MAKE_CASE(SCSIOP_VERIFY)
        MAKE_CASE(SCSIOP_SEARCH_DATA_HIGH)
        MAKE_CASE(SCSIOP_SEARCH_DATA_EQUAL)
        MAKE_CASE(SCSIOP_SEARCH_DATA_LOW)
        MAKE_CASE(SCSIOP_SET_LIMITS)
        MAKE_CASE(SCSIOP_READ_POSITION)
        MAKE_CASE(SCSIOP_SYNCHRONIZE_CACHE)
        MAKE_CASE(SCSIOP_COMPARE)
        MAKE_CASE(SCSIOP_COPY_COMPARE)
        MAKE_CASE(SCSIOP_WRITE_DATA_BUFF)
        MAKE_CASE(SCSIOP_READ_DATA_BUFF)
        MAKE_CASE(SCSIOP_CHANGE_DEFINITION)
        MAKE_CASE(SCSIOP_READ_SUB_CHANNEL)
        MAKE_CASE(SCSIOP_READ_TOC)
        MAKE_CASE(SCSIOP_READ_HEADER)
        MAKE_CASE(SCSIOP_PLAY_AUDIO)
        MAKE_CASE(SCSIOP_GET_CONFIGURATION)
        MAKE_CASE(SCSIOP_PLAY_AUDIO_MSF)
        MAKE_CASE(SCSIOP_PLAY_TRACK_INDEX)
        MAKE_CASE(SCSIOP_PLAY_TRACK_RELATIVE)
        MAKE_CASE(SCSIOP_GET_EVENT_STATUS)
        MAKE_CASE(SCSIOP_PAUSE_RESUME)
        MAKE_CASE(SCSIOP_LOG_SELECT)
        MAKE_CASE(SCSIOP_LOG_SENSE)
        MAKE_CASE(SCSIOP_STOP_PLAY_SCAN)
        MAKE_CASE(SCSIOP_READ_DISK_INFORMATION)
        MAKE_CASE(SCSIOP_READ_TRACK_INFORMATION)
        MAKE_CASE(SCSIOP_RESERVE_TRACK_RZONE)
        MAKE_CASE(SCSIOP_SEND_OPC_INFORMATION)
        MAKE_CASE(SCSIOP_MODE_SELECT10)
        MAKE_CASE(SCSIOP_MODE_SENSE10)
        MAKE_CASE(SCSIOP_CLOSE_TRACK_SESSION)
        MAKE_CASE(SCSIOP_READ_BUFFER_CAPACITY)
        MAKE_CASE(SCSIOP_SEND_CUE_SHEET)
        MAKE_CASE(SCSIOP_PERSISTENT_RESERVE_IN)
        MAKE_CASE(SCSIOP_PERSISTENT_RESERVE_OUT)
        MAKE_CASE(SCSIOP_REPORT_LUNS)
        MAKE_CASE(SCSIOP_BLANK)
        MAKE_CASE(SCSIOP_SEND_KEY)
        MAKE_CASE(SCSIOP_REPORT_KEY)
        MAKE_CASE(SCSIOP_MOVE_MEDIUM)
        MAKE_CASE(SCSIOP_LOAD_UNLOAD_SLOT)  // aka SCSIOP_EXCHANGE_MEDIUM
        MAKE_CASE(SCSIOP_SET_READ_AHEAD)
        MAKE_CASE(SCSIOP_READ_DVD_STRUCTURE)
        MAKE_CASE(SCSIOP_REQUEST_VOL_ELEMENT)
        MAKE_CASE(SCSIOP_SEND_VOLUME_TAG)
        MAKE_CASE(SCSIOP_READ_ELEMENT_STATUS)
        MAKE_CASE(SCSIOP_READ_CD_MSF)
        MAKE_CASE(SCSIOP_SCAN_CD)
        MAKE_CASE(SCSIOP_SET_CD_SPEED)
        MAKE_CASE(SCSIOP_PLAY_CD)
        MAKE_CASE(SCSIOP_MECHANISM_STATUS)
        MAKE_CASE(SCSIOP_READ_CD)
        MAKE_CASE(SCSIOP_SEND_DVD_STRUCTURE)
        MAKE_CASE(SCSIOP_INIT_ELEMENT_RANGE)
    }

    return scsiOpStr;
}


char *DbgGetSrbStatusStr(UCHAR SrbStat)
{
    char *srbStatStr = HexNumberStrings[SrbStat];
    
    switch (SrbStat){

        #undef MAKE_CASE
        #define MAKE_CASE(srbStat) \
                    case srbStat: \
                        srbStatStr = #srbStat; \
                        break; \
                    case srbStat|SRB_STATUS_QUEUE_FROZEN: \
                        srbStatStr = #srbStat "|SRB_STATUS_QUEUE_FROZEN"; \
                        break; \
                    case srbStat|SRB_STATUS_AUTOSENSE_VALID: \
                        srbStatStr = #srbStat "|SRB_STATUS_AUTOSENSE_VALID"; \
                        break; \
                    case srbStat|SRB_STATUS_QUEUE_FROZEN|SRB_STATUS_AUTOSENSE_VALID: \
                        srbStatStr = #srbStat "|SRB_STATUS_QUEUE_FROZEN|SRB_STATUS_AUTOSENSE_VALID"; \
                        break; 

        MAKE_CASE(SRB_STATUS_PENDING)
        MAKE_CASE(SRB_STATUS_SUCCESS)
        MAKE_CASE(SRB_STATUS_ABORTED)
        MAKE_CASE(SRB_STATUS_ABORT_FAILED)
        MAKE_CASE(SRB_STATUS_ERROR)
        MAKE_CASE(SRB_STATUS_BUSY)
        MAKE_CASE(SRB_STATUS_INVALID_REQUEST)
        MAKE_CASE(SRB_STATUS_INVALID_PATH_ID)
        MAKE_CASE(SRB_STATUS_NO_DEVICE)
        MAKE_CASE(SRB_STATUS_TIMEOUT)
        MAKE_CASE(SRB_STATUS_SELECTION_TIMEOUT)
        MAKE_CASE(SRB_STATUS_COMMAND_TIMEOUT)
        MAKE_CASE(0x0C)
        MAKE_CASE(SRB_STATUS_MESSAGE_REJECTED)
        MAKE_CASE(SRB_STATUS_BUS_RESET)
        MAKE_CASE(SRB_STATUS_PARITY_ERROR)
        MAKE_CASE(SRB_STATUS_REQUEST_SENSE_FAILED)
        MAKE_CASE(SRB_STATUS_NO_HBA)
        MAKE_CASE(SRB_STATUS_DATA_OVERRUN)
        MAKE_CASE(SRB_STATUS_UNEXPECTED_BUS_FREE)
        MAKE_CASE(SRB_STATUS_PHASE_SEQUENCE_FAILURE)
        MAKE_CASE(SRB_STATUS_BAD_SRB_BLOCK_LENGTH)
        MAKE_CASE(SRB_STATUS_REQUEST_FLUSHED)
        MAKE_CASE(SRB_STATUS_INVALID_LUN)
        MAKE_CASE(SRB_STATUS_INVALID_TARGET_ID)
        MAKE_CASE(SRB_STATUS_BAD_FUNCTION)
        MAKE_CASE(SRB_STATUS_ERROR_RECOVERY)
        MAKE_CASE(SRB_STATUS_NOT_POWERED)
        MAKE_CASE(0x25)
        MAKE_CASE(0x26)
        MAKE_CASE(0x27)
        MAKE_CASE(0x28)
        MAKE_CASE(0x29)
        MAKE_CASE(0x2A)
        MAKE_CASE(0x2B)
        MAKE_CASE(0x2C)
        MAKE_CASE(0x2D)
        MAKE_CASE(0x2E)
        MAKE_CASE(0x2F)
        MAKE_CASE(SRB_STATUS_INTERNAL_ERROR)
        MAKE_CASE(0x31)
        MAKE_CASE(0x32)
        MAKE_CASE(0x33)
        MAKE_CASE(0x34)
        MAKE_CASE(0x35)
        MAKE_CASE(0x36)
        MAKE_CASE(0x37)
        MAKE_CASE(0x38)
        MAKE_CASE(0x39)
        MAKE_CASE(0x3A)
        MAKE_CASE(0x3B)
        MAKE_CASE(0x3C)
        MAKE_CASE(0x3D)
        MAKE_CASE(0x3E)
        MAKE_CASE(0x3F)
    }

    return srbStatStr;
}



char *DbgGetSenseCodeStr(UCHAR SrbStat, ULONG64 SenseDataAddr)
{
    char *senseCodeStr = "??";

    if (SrbStat & SRB_STATUS_AUTOSENSE_VALID){
        UCHAR senseCode;

        senseCode = GetUCHARField(SenseDataAddr, "classpnp!_SENSE_DATA", "SenseKey");
        if (senseCode != BAD_VALUE){
            
            senseCode &= 0x0f;

            senseCodeStr = HexNumberStrings[senseCode];
                         
            switch (senseCode){

                #undef MAKE_CASE             
                #define MAKE_CASE(snsCod) case snsCod: senseCodeStr = #snsCod; break;
            
                MAKE_CASE(SCSI_SENSE_NO_SENSE)
                MAKE_CASE(SCSI_SENSE_RECOVERED_ERROR)
                MAKE_CASE(SCSI_SENSE_NOT_READY)
                MAKE_CASE(SCSI_SENSE_MEDIUM_ERROR)
                MAKE_CASE(SCSI_SENSE_HARDWARE_ERROR)
                MAKE_CASE(SCSI_SENSE_ILLEGAL_REQUEST)
                MAKE_CASE(SCSI_SENSE_UNIT_ATTENTION)
                MAKE_CASE(SCSI_SENSE_DATA_PROTECT)
                MAKE_CASE(SCSI_SENSE_BLANK_CHECK)
                MAKE_CASE(SCSI_SENSE_UNIQUE)
                MAKE_CASE(SCSI_SENSE_COPY_ABORTED)
                MAKE_CASE(SCSI_SENSE_ABORTED_COMMAND)
                MAKE_CASE(SCSI_SENSE_EQUAL)
                MAKE_CASE(SCSI_SENSE_VOL_OVERFLOW)
                MAKE_CASE(SCSI_SENSE_MISCOMPARE)
                MAKE_CASE(SCSI_SENSE_RESERVED)               
            }
        }                
    }

    return senseCodeStr;
}


char *DbgGetAdditionalSenseCodeStr(UCHAR SrbStat, ULONG64 SenseDataAddr)
{
    char *adSenseCodeStr = "?";

    if (SrbStat & SRB_STATUS_AUTOSENSE_VALID){
        UCHAR adSenseCode;

        adSenseCode = GetUCHARField(SenseDataAddr, "classpnp!_SENSE_DATA", "AdditionalSenseCode");

        adSenseCodeStr = HexNumberStrings[adSenseCode];

        if (adSenseCode != BAD_VALUE){
            
            switch (adSenseCode){

                #undef MAKE_CASE             
                #define MAKE_CASE(adSnsCod) case adSnsCod: adSenseCodeStr = #adSnsCod; break;
                MAKE_CASE(SCSI_ADSENSE_NO_SENSE)
                MAKE_CASE(SCSI_ADSENSE_NO_SEEK_COMPLETE)
                MAKE_CASE(SCSI_ADSENSE_LUN_NOT_READY)
                MAKE_CASE(SCSI_ADSENSE_WRITE_ERROR)
                MAKE_CASE(SCSI_ADSENSE_TRACK_ERROR)
                MAKE_CASE(SCSI_ADSENSE_SEEK_ERROR)
                MAKE_CASE(SCSI_ADSENSE_REC_DATA_NOECC)
                MAKE_CASE(SCSI_ADSENSE_REC_DATA_ECC)
                MAKE_CASE(SCSI_ADSENSE_ILLEGAL_COMMAND)
                MAKE_CASE(SCSI_ADSENSE_ILLEGAL_BLOCK)
                MAKE_CASE(SCSI_ADSENSE_INVALID_CDB)
                MAKE_CASE(SCSI_ADSENSE_INVALID_LUN)
                MAKE_CASE(SCSI_ADSENSE_WRITE_PROTECT)   // aka SCSI_ADWRITE_PROTECT
                MAKE_CASE(SCSI_ADSENSE_MEDIUM_CHANGED)
                MAKE_CASE(SCSI_ADSENSE_BUS_RESET)
                MAKE_CASE(SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION)
                MAKE_CASE(SCSI_ADSENSE_INVALID_MEDIA)
                MAKE_CASE(SCSI_ADSENSE_NO_MEDIA_IN_DEVICE)
                MAKE_CASE(SCSI_ADSENSE_POSITION_ERROR)
                MAKE_CASE(SCSI_ADSENSE_OPERATOR_REQUEST)
                MAKE_CASE(SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED)
                MAKE_CASE(SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK)
                MAKE_CASE(SCSI_ADSENSE_COPY_PROTECTION_FAILURE)
                MAKE_CASE(SCSI_ADSENSE_POWER_CALIBRATION_ERROR)
                MAKE_CASE(SCSI_ADSENSE_VENDOR_UNIQUE)
                MAKE_CASE(SCSI_ADSENSE_MUSIC_AREA)
                MAKE_CASE(SCSI_ADSENSE_DATA_AREA)
                MAKE_CASE(SCSI_ADSENSE_VOLUME_OVERFLOW)
            }
        }
    }

    return adSenseCodeStr;
}


char *DbgGetAdditionalSenseCodeQualifierStr(UCHAR SrbStat, ULONG64 SenseDataAddr)
{
    char *adSenseCodeQualStr = "?";
    
    if (SrbStat & SRB_STATUS_AUTOSENSE_VALID){
        UCHAR adSenseCode, adSenseCodeQual;

        adSenseCode = GetUCHARField(SenseDataAddr, "classpnp!_SENSE_DATA", "AdditionalSenseCode");
        adSenseCodeQual = GetUCHARField(SenseDataAddr, "classpnp!_SENSE_DATA", "AdditionalSenseCodeQualifier");

        adSenseCodeQualStr = HexNumberStrings[adSenseCodeQual];
        
        if ((adSenseCode != BAD_VALUE) && (adSenseCodeQual != BAD_VALUE)){
    
            switch (adSenseCode){

                #undef MAKE_CASE             
                #define MAKE_CASE(adSnsCodQual) case adSnsCodQual: adSenseCodeQualStr = #adSnsCodQual; break;

                case SCSI_ADSENSE_LUN_NOT_READY:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_CAUSE_NOT_REPORTABLE)
                        MAKE_CASE(SCSI_SENSEQ_BECOMING_READY)
                        MAKE_CASE(SCSI_SENSEQ_INIT_COMMAND_REQUIRED)
                        MAKE_CASE(SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED)
                        MAKE_CASE(SCSI_SENSEQ_FORMAT_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_REBUILD_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_RECALCULATION_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_OPERATION_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS)                        
                    }
                    break;
                case SCSI_ADSENSE_NO_SENSE:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_FILEMARK_DETECTED)
                        MAKE_CASE(SCSI_SENSEQ_END_OF_MEDIA_DETECTED)
                        MAKE_CASE(SCSI_SENSEQ_SETMARK_DETECTED)
                        MAKE_CASE(SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED)
                    }
                    break;
                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR)
                    }
                    break;
                case SCSI_ADSENSE_POSITION_ERROR:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_DESTINATION_FULL)
                        MAKE_CASE(SCSI_SENSEQ_SOURCE_EMPTY)
                    }
                    break;
                case SCSI_ADSENSE_INVALID_MEDIA:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED)
                        MAKE_CASE(SCSI_SENSEQ_UNKNOWN_FORMAT)
                        MAKE_CASE(SCSI_SENSEQ_INCOMPATIBLE_FORMAT)
                        MAKE_CASE(SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED)
                    }
                    break;
                case SCSI_ADSENSE_OPERATOR_REQUEST:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_STATE_CHANGE_INPUT)
                        MAKE_CASE(SCSI_SENSEQ_MEDIUM_REMOVAL)
                        MAKE_CASE(SCSI_SENSEQ_WRITE_PROTECT_ENABLE)
                        MAKE_CASE(SCSI_SENSEQ_WRITE_PROTECT_DISABLE)
                    }
                    break;
                case SCSI_ADSENSE_COPY_PROTECTION_FAILURE:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_AUTHENTICATION_FAILURE)
                        MAKE_CASE(SCSI_SENSEQ_KEY_NOT_PRESENT)
                        MAKE_CASE(SCSI_SENSEQ_KEY_NOT_ESTABLISHED)
                        MAKE_CASE(SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION)
                        MAKE_CASE(SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT)
                        MAKE_CASE(SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR)
                    }
                    break;
            }
        }
    }

    return adSenseCodeQualStr;
}


/*
 *  DbgGetMediaTypeStr
 *
 *      Convert MEDIA_TYPE (defined in ntdddisk.h) to a string.
 */
char *DbgGetMediaTypeStr(ULONG MediaType)
{
    char *mediaTypeStr = "?";

    if (MediaType < 0xff)
    {
        mediaTypeStr = HexNumberStrings[MediaType];
    }
    
    switch (MediaType){

        #undef MAKE_CASE             
        #define MAKE_CASE(mtype) case mtype: mediaTypeStr = #mtype; break;

        MAKE_CASE(Unknown)
        MAKE_CASE(F5_1Pt2_512)
        MAKE_CASE(F3_1Pt44_512)
        MAKE_CASE(F3_2Pt88_512)
        MAKE_CASE(F3_20Pt8_512)
        MAKE_CASE(F3_720_512)
        MAKE_CASE(F5_360_512)
        MAKE_CASE(F5_320_512)
        MAKE_CASE(F5_320_1024)
        MAKE_CASE(F5_180_512)
        MAKE_CASE(F5_160_512)
        MAKE_CASE(RemovableMedia)
        MAKE_CASE(FixedMedia)
        MAKE_CASE(F3_120M_512)
        MAKE_CASE(F3_640_512)
        MAKE_CASE(F5_640_512)
        MAKE_CASE(F5_720_512)
        MAKE_CASE(F3_1Pt2_512)
        MAKE_CASE(F3_1Pt23_1024)
        MAKE_CASE(F5_1Pt23_1024)
        MAKE_CASE(F3_128Mb_512)
        MAKE_CASE(F3_230Mb_512)
        MAKE_CASE(F8_256_128)
        MAKE_CASE(F3_200Mb_512)
        MAKE_CASE(F3_240M_512)
        MAKE_CASE(F3_32M_512)
    }

    return mediaTypeStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\stor\kdext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"


//
// globals
//

WINDBG_EXTENSION_APIS  ExtensionApis;


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}



extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(
    PULONG Version,
    PULONG Flags
    )
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
//    g_ExcepCallbacks.Uninitialize();
//    g_FnProfCallbacks.Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\class\mcd.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    mcd.c

Abstract:

Environment:

    Kernel mode

Revision History :

--*/
#include "mchgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerUnload)
#pragma alloc_text(PAGE, CreateChangerDeviceObject)
#pragma alloc_text(PAGE, ChangerClassCreateClose)
#pragma alloc_text(PAGE, ChangerClassDeviceControl)
#pragma alloc_text(PAGE, ChangerAddDevice)
#pragma alloc_text(PAGE, ChangerStartDevice)
#pragma alloc_text(PAGE, ChangerInitDevice)
#pragma alloc_text(PAGE, ChangerRemoveDevice)
#pragma alloc_text(PAGE, ChangerStopDevice)
#pragma alloc_text(PAGE, ChangerReadWriteVerification)
#endif


NTSTATUS
ChangerClassCreateClose (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp
  )

/*++

Routine Description:

    This routine handles CREATE/CLOSE requests.
    As these are exclusive devices, don't allow multiple opens.

Arguments:

    DeviceObject
    Irp

Return Value:

    NT Status

--*/

{
     PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
     PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
     PMCD_CLASS_DATA    mcdClassData;
     PMCD_INIT_DATA     mcdInitData;
     ULONG              miniclassExtSize;
     NTSTATUS           status = STATUS_SUCCESS;

     PAGED_CODE();

     mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);

     mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                              ChangerClassInitialize);

     if (mcdInitData == NULL) {

         Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
         ClassReleaseRemoveLock(DeviceObject, Irp);
         ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);

         return STATUS_NO_SUCH_DEVICE;
     }

     miniclassExtSize = mcdInitData->ChangerAdditionalExtensionSize();

     //
     // The class library's private data is after the miniclass's.
     //

     (ULONG_PTR)mcdClassData += miniclassExtSize;

     if (irpStack->MajorFunction == IRP_MJ_CLOSE) {
         DebugPrint((3,
                    "ChangerClassCreateClose - IRP_MJ_CLOSE\n"));

         //
         // Indicate that the device is available for others.
         //

         mcdClassData->DeviceOpen = 0;
         status = STATUS_SUCCESS;

     } else if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         DebugPrint((3,
                    "ChangerClassCreateClose - IRP_MJ_CREATE\n"));

         //
         // If already opened, return busy.
         //

         if (mcdClassData->DeviceOpen) {

             DebugPrint((1,
                        "ChangerClassCreateClose - returning DEVICE_BUSY. DeviceOpen - %x\n",
                        mcdClassData->DeviceOpen));

             status = STATUS_DEVICE_BUSY;
         } else {

             //
             // Indicate that the device is busy.
             //

             InterlockedIncrement(&mcdClassData->DeviceOpen);
             status = STATUS_SUCCESS;
         }


     }

     Irp->IoStatus.Status = status;
     ClassReleaseRemoveLock(DeviceObject, Irp);
     ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);

     return status;

} // end ChangerCreate()


NTSTATUS
ChangerClassDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension = DeviceObject->DeviceExtension;
    PMCD_INIT_DATA    mcdInitData;
    NTSTATUS               status;
    ULONG ioControlCode;

    PAGED_CODE();


    mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);

        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Disable media change detection before processing current IOCTL
    //
    ClassDisableMediaChangeDetection(fdoExtension);

    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    switch (ioControlCode) {

        case IOCTL_CHANGER_GET_PARAMETERS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_PARAMETERS\n"));

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(GET_CHANGER_PARAMETERS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else
            {
                PGET_CHANGER_PARAMETERS changerParameters = Irp->AssociatedIrp.SystemBuffer;
                RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

                status = mcdInitData->ChangerGetParameters(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_GET_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_STATUS\n"));

            status = mcdInitData->ChangerGetStatus(DeviceObject, Irp);

            break;

        case IOCTL_CHANGER_GET_PRODUCT_DATA:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_PRODUCT_DATA\n"));

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(CHANGER_PRODUCT_DATA)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            }
            else
            {
                PCHANGER_PRODUCT_DATA changerProductData = Irp->AssociatedIrp.SystemBuffer;
                RtlZeroMemory(changerProductData, sizeof(CHANGER_PRODUCT_DATA));

                status = mcdInitData->ChangerGetProductData(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_SET_ACCESS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_SET_ACCESS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SET_ACCESS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = mcdInitData->ChangerSetAccess(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_GET_ELEMENT_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_ELEMENT_STATUS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_READ_ELEMENT_STATUS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
                ULONG length = readElementStatus->ElementList.NumberOfElements * sizeof(CHANGER_ELEMENT_STATUS);
                ULONG lengthEx = readElementStatus->ElementList.NumberOfElements * sizeof(CHANGER_ELEMENT_STATUS_EX);
                ULONG outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

                //
                // Further validate parameters.
                //
                status = STATUS_SUCCESS;
                if ((outputBuffLen < lengthEx) && (outputBuffLen < length)) {

                    status = STATUS_BUFFER_TOO_SMALL;

                } else if ((length == 0) || (lengthEx == 0)) {

                    status = STATUS_INVALID_PARAMETER;
                }

                if (NT_SUCCESS(status)) {

                    status = mcdInitData->ChangerGetElementStatus(DeviceObject, Irp);
                }

            }

            break;

        case IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = mcdInitData->ChangerInitializeElementStatus(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_SET_POSITION:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_SET_POSITION\n"));


            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SET_POSITION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = mcdInitData->ChangerSetPosition(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_EXCHANGE_MEDIUM:

            DebugPrint((3, "Mcd.ChangerDeviceControl: IOCTL_CHANGER_EXCHANGE_MEDIUM\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_EXCHANGE_MEDIUM)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {
                status = mcdInitData->ChangerExchangeMedium(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_MOVE_MEDIUM:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_MOVE_MEDIUM\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_MOVE_MEDIUM)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = mcdInitData->ChangerMoveMedium(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_REINITIALIZE_TRANSPORT:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_REINITIALIZE_TRANSPORT\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_ELEMENT)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = mcdInitData->ChangerReinitializeUnit(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_QUERY_VOLUME_TAGS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_QUERY_VOLUME_TAGS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SEND_VOLUME_TAG_INFORMATION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof(READ_ELEMENT_ADDRESS_INFO)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = mcdInitData->ChangerQueryVolumeTags(DeviceObject, Irp);
            }

            break;

        default:
            DebugPrint((1,
                       "Mcd.ChangerDeviceControl: Unhandled IOCTL\n"));


            //
            // Pass the request to the common device control routine.
            //

            status = ClassDeviceControl(DeviceObject, Irp);

            //
            // Re-enable media change detection
            //
            ClassEnableMediaChangeDetection(fdoExtension);

            return status;
    }

    Irp->IoStatus.Status = status;

    //
    // Re-enable media change detection
    //
    ClassEnableMediaChangeDetection(fdoExtension);

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        DebugPrint((1,
                   "Mcd.ChangerDeviceControl: IOCTL %x, status %x\n",
                    irpStack->Parameters.DeviceIoControl.IoControlCode,
                    status));

        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
    }

    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);
    return status;
}


VOID
ChangerClassError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    Final Nt status indicating the results of the operation.

Notes:


--*/

{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension = DeviceObject->DeviceExtension;
    PMCD_INIT_DATA mcdInitData;

    mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return;
    }

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        switch (senseBuffer->SenseKey & 0xf) {

          case SCSI_SENSE_MEDIUM_ERROR: {
              *Retry = FALSE;

              if (((senseBuffer->AdditionalSenseCode) ==  SCSI_ADSENSE_INVALID_MEDIA) &&
                  ((senseBuffer->AdditionalSenseCodeQualifier) == SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED)) {

                  //
                  // This indicates a cleaner cartridge is present in the changer
                  //
                  *Status = STATUS_CLEANER_CARTRIDGE_INSTALLED;
              }
              break;
          }

          case SCSI_SENSE_ILLEGAL_REQUEST: {
              switch (senseBuffer->AdditionalSenseCode) {
                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR ) {

                        DebugPrint((1,
                                    "MediumChanger: An operation was attempted on an invalid element\n"));

                        //
                        // Attemped operation to an invalid element.
                        //

                        *Retry = FALSE;
                        *Status = STATUS_ILLEGAL_ELEMENT_ADDRESS;
                    }
                    break;

                case SCSI_ADSENSE_POSITION_ERROR:

                    if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {

                        DebugPrint((1,
                                "MediumChanger: The specified source element has no media\n"));

                        //
                        // The indicated source address has no media.
                        //

                        *Retry = FALSE;
                        *Status = STATUS_SOURCE_ELEMENT_EMPTY;

                    } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {

                        DebugPrint((1,
                                    "MediumChanger: The specified destination element already has media.\n"));
                        //
                        // The indicated destination already contains media.
                        //

                        *Retry = FALSE;
                        *Status = STATUS_DESTINATION_ELEMENT_FULL;
                    }
                    break;



                default:
                    break;
              } // switch (senseBuffer->AdditionalSenseCode)

              break;
          }

          case SCSI_SENSE_UNIT_ATTENTION: {

              if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_MEDIUM_CHANGED) ||
                  (senseBuffer->AdditionalSenseCode == 0x3f && senseBuffer->AdditionalSenseCodeQualifier == 0x81)) {

                  //
                  // Changers like the Compaq StorageWorks LIB-81 return
                  // 0x06/3f/81 when media is injected/ejected into the
                  // changer instead of 0x06/28/00
                  //

                  //
                  // Need to notify applications of possible media change in
                  // the library. First, set the current media state to
                  // NotPresent and then set the state to present. We need to
                  // do this because, changer devices do not report MediaNotPresent
                  // state. They only convey MediumChanged condition. In order for
                  // classpnp to notify applications of media change, we need to
                  // simulate media notpresent to present state transition
                  //
                  ClassSetMediaChangeState(fdoExtension, MediaNotPresent, FALSE);
                  ClassSetMediaChangeState(fdoExtension, MediaPresent, FALSE);
              }

              break;
          }

          default:
              break;

        } // end switch (senseBuffer->SenseKey & 0xf)
    } // if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)

    //
    // Call Changer MiniDriver error routine only if we
    // are running at or below APC_LEVEL
    //
    if (KeGetCurrentIrql() > APC_LEVEL) {
        return;
    }

    if (mcdInitData->ChangerError) {
        //
        // Allow device-specific module to update this.
        //
        mcdInitData->ChangerError(DeviceObject, Srb, Status, Retry);
    }

    return;
}



NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - MC class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    PULONG devicesFound = NULL;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the address of the count of the number of tape devices already initialized.
    //

    devicesFound = &IoGetConfigurationInformation()->MediumChangerCount;

    status = CreateChangerDeviceObject(DriverObject,
                                       PhysicalDeviceObject);


    if(NT_SUCCESS(status)) {

        (*devicesFound)++;
    }

    return status;
}



NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine is called after InitDevice, and creates the symbolic link,
    and sets up information in the registry.
    The routine could be called multiple times, in the event of a StopDevice.


Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PINQUIRYDATA            inquiryData = NULL;
    ULONG                   pageLength;
    ULONG                   inquiryLength;
    SCSI_REQUEST_BLOCK      srb;
    PCDB                    cdb;
    NTSTATUS                status;
    PMCD_CLASS_DATA         mcdClassData = (PMCD_CLASS_DATA)fdoExtension->CommonExtension.DriverData;
    PMCD_INIT_DATA          mcdInitData;
    ULONG                   miniClassExtSize;

    PAGED_CODE();

    mcdInitData = IoGetDriverObjectExtension(Fdo->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return STATUS_NO_SUCH_DEVICE;
    }

    miniClassExtSize = mcdInitData->ChangerAdditionalExtensionSize();

    //
    // Build and send request to get inquiry data.
    //

    inquiryData = ExAllocatePool(NonPagedPoolCacheAligned, MAXIMUM_CHANGER_INQUIRY_DATA);
    if (!inquiryData) {
        //
        // The buffer cannot be allocated.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 2;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = MAXIMUM_CHANGER_INQUIRY_DATA;

    status = ClassSendSrbSynchronous(Fdo,
                                     &srb,
                                     inquiryData,
                                     MAXIMUM_CHANGER_INQUIRY_DATA,
                                     FALSE);


    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        srb.SrbStatus = SRB_STATUS_SUCCESS;
    }

    if (srb.SrbStatus == SRB_STATUS_SUCCESS) {
        inquiryLength = inquiryData->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (inquiryLength > srb.DataTransferLength) {
            inquiryLength = srb.DataTransferLength;
        }
    } else {

        //
        // The class function will only write inquiryLength of inquiryData
        // to the reg. key.
        //

        inquiryLength = 0;
    }

    //
    // Add changer device info to registry
    //

    ClassUpdateInformationInRegistry(Fdo,
                                     "Changer",
                                     fdoExtension->DeviceNumber,
                                     inquiryData,
                                     inquiryLength);

    ExFreePool(inquiryData);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    return STATUS_SUCCESS;
}




#define CHANGER_SRB_LIST_SIZE 2



NTSTATUS
ChangerInitDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will complete the changer initialization.  This includes
    allocating sense info buffers and srb s-lists. Additionally, the miniclass
    driver's init entry points are called.

    This routine will not clean up allocate resources if it fails - that
    is left for device stop/removal

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PVOID                   senseData = NULL;
    NTSTATUS                status;
    PVOID                   minitapeExtension;
    PMCD_INIT_DATA          mcdInitData;
    STORAGE_PROPERTY_ID     propertyId;
    UNICODE_STRING          interfaceName;
    PMCD_CLASS_DATA         mcdClassData;

    PAGED_CODE();

    mcdInitData = IoGetDriverObjectExtension(Fdo->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePool(NonPagedPoolCacheAligned,
                               SENSE_BUFFER_SIZE);

    if (senseData == NULL) {

        //
        // The buffer cannot be allocated.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ChangerInitDeviceExit;
    }

    //
    // Build the lookaside list for srb's for the device. Should only
    // need a couple.
    //

    ClassInitializeSrbLookasideList(&(fdoExtension->CommonExtension), CHANGER_SRB_LIST_SIZE);

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    fdoExtension->TimeOutValue = 600;

    //
    // Call port driver to get adapter capabilities.
    //

    propertyId = StorageAdapterProperty;

    status = ClassGetDescriptor(fdoExtension->CommonExtension.LowerDeviceObject,
                                &propertyId,
                                &(fdoExtension->AdapterDescriptor));

    if(!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "ChangerInitDevice: Unable to get adapter descriptor. Status %x\n",
                    status));
        goto ChangerInitDeviceExit;
    }

    //
    // Invoke the device-specific initialization function.
    //

    status = mcdInitData->ChangerInitialize(Fdo);
    if(!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "ChangerInitDevice: Minidriver Init failed. Status %x\n",
                    status));
        goto ChangerInitDeviceExit;
    }

    //
    // Register for media change notification
    //
    ClassInitializeMediaChangeDetection(fdoExtension, "Changer");

    //
    // Register interfaces for this device.
    //

    RtlInitUnicodeString(&interfaceName, NULL);

    status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                                       (LPGUID) &MediumChangerClassGuid,
                                       NULL,
                                       &interfaceName);

    if(NT_SUCCESS(status)) {

        mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);

        //
        // The class library's private data is after the miniclass's.
        //

        (ULONG_PTR)mcdClassData += mcdInitData->ChangerAdditionalExtensionSize();

        ((MCD_CLASS_DATA UNALIGNED *)mcdClassData)->MediumChangerInterfaceString = interfaceName;

        status = IoSetDeviceInterfaceState(
                    &interfaceName,
                    TRUE);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1,
                        "ChangerInitDevice: Unable to register Changer%x interface name - %x.\n",
                        fdoExtension->DeviceNumber,
                        status));
            status = STATUS_SUCCESS;
        }
    }

    return status;

    //
    // Fall through and return whatever status the miniclass driver returned.
    //

ChangerInitDeviceExit:

    if (senseData) {
        ExFreePool(senseData);
        fdoExtension->SenseData = NULL;
    }

    return status;

} // End ChangerStartDevice



NTSTATUS
ChangerRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    tape driver.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    none - this routine may not fail

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PMCD_CLASS_DATA              mcdClassData = (PMCD_CLASS_DATA)fdoExtension->CommonExtension.DriverData;
    PMCD_INIT_DATA               mcdInitData;
    ULONG                        miniClassExtSize;
    WCHAR                        dosNameBuffer[64];
    UNICODE_STRING               dosUnicodeString;
    NTSTATUS                     status;

    PAGED_CODE();

    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }


    mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return STATUS_NO_SUCH_DEVICE;
    }

    miniClassExtSize = mcdInitData->ChangerAdditionalExtensionSize();

    //
    // Free all allocated memory.
    //

    if (Type == IRP_MN_REMOVE_DEVICE){
        if (fdoExtension->DeviceDescriptor) {
            ExFreePool(fdoExtension->DeviceDescriptor);
            fdoExtension->DeviceDescriptor = NULL;
        }
        if (fdoExtension->AdapterDescriptor) {
            ExFreePool(fdoExtension->AdapterDescriptor);
            fdoExtension->AdapterDescriptor = NULL;
        }
        if (fdoExtension->SenseData) {
            ExFreePool(fdoExtension->SenseData);
            fdoExtension->SenseData = NULL;
        }
        ClassDeleteSrbLookasideList(&fdoExtension->CommonExtension);
    }

    (ULONG_PTR)mcdClassData += miniClassExtSize;

    if((((MCD_CLASS_DATA UNALIGNED *)mcdClassData)->MediumChangerInterfaceString).Buffer != NULL) {
        IoSetDeviceInterfaceState(&(mcdClassData->MediumChangerInterfaceString),
                                  FALSE);

        RtlFreeUnicodeString(&(mcdClassData->MediumChangerInterfaceString));

        //
        // Clear it.
        //

        RtlInitUnicodeString(&(mcdClassData->MediumChangerInterfaceString), NULL);
    }

    //
    // Delete the symbolic link "changerN".
    //

    if(mcdClassData->DosNameCreated) {

        swprintf(dosNameBuffer,
                L"\\DosDevices\\Changer%d",
                fdoExtension->DeviceNumber);
        RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);
        IoDeleteSymbolicLink(&dosUnicodeString);
        mcdClassData->DosNameCreated = FALSE;
    }

    //
    // Remove registry bits.
    //

    if(Type == IRP_MN_REMOVE_DEVICE) {
        IoGetConfigurationInformation()->MediumChangerCount--;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is a stub that returns invalid device request.

Arguments:

    DeviceObject - Supplies the device object.

    Irp - Supplies the I/O request packet.

Return Value:

    STATUS_INVALID_DEVICE_REQUEST


--*/

{
    return  STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
DriverEntry(
  IN PDRIVER_OBJECT DriverObject,
  IN PUNICODE_STRING RegistryPath
  )

/*++

Routine Description:

    This is the entry point for this EXPORT DRIVER.  It does nothing.

--*/

{
    return STATUS_SUCCESS;
}


NTSTATUS
ChangerClassInitialize(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath,
    IN  PMCD_INIT_DATA  MCDInitData
    )

/*++

Routine Description:

    This routine is called by a changer mini-class driver during its
    DriverEntry routine to initialize the driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

    MCDInitData     - Changer Minidriver Init Data

Return Value:

    Status value returned by ClassInitialize
--*/

{
    PMCD_INIT_DATA driverExtension;
    CLASS_INIT_DATA InitializationData;
    NTSTATUS status;

    //
    // Get the driver extension
    //
    status = IoAllocateDriverObjectExtension(
                      DriverObject,
                      ChangerClassInitialize,
                      sizeof(MCD_INIT_DATA),
                      &driverExtension);
    if (!NT_SUCCESS(status)) {
        if(status == STATUS_OBJECT_NAME_COLLISION) {

            //
            // An extension already exists for this key.  Get a pointer to it
            //

            driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                         ChangerClassInitialize);
            if (driverExtension == NULL) {
                DebugPrint((1,
                            "ChangerClassInitialize : driverExtension NULL\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {

            //
            // As this failed, the changer init data won't be able to be stored.
            //

            DebugPrint((1,
                        "ChangerClassInitialize: Error %x allocating driver extension\n",
                        status));

            return status;
        }
    }

    RtlCopyMemory(driverExtension, MCDInitData, sizeof(MCD_INIT_DATA));

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);

    InitializationData.FdoData.DeviceExtensionSize =
        sizeof(FUNCTIONAL_DEVICE_EXTENSION) +
        MCDInitData->ChangerAdditionalExtensionSize() +
        sizeof(MCD_CLASS_DATA);

    InitializationData.FdoData.DeviceType = FILE_DEVICE_CHANGER;
    InitializationData.FdoData.DeviceCharacteristics = 0;

    //
    // Set entry points
    //

    InitializationData.FdoData.ClassStartDevice = ChangerStartDevice;
    InitializationData.FdoData.ClassInitDevice = ChangerInitDevice;
    InitializationData.FdoData.ClassStopDevice = ChangerStopDevice;
    InitializationData.FdoData.ClassRemoveDevice = ChangerRemoveDevice;
    InitializationData.ClassAddDevice = ChangerAddDevice;

    InitializationData.FdoData.ClassReadWriteVerification = NULL;
    InitializationData.FdoData.ClassDeviceControl = ChangerClassDeviceControl;
    InitializationData.FdoData.ClassError = ChangerClassError;
    InitializationData.FdoData.ClassShutdownFlush = NULL;

    InitializationData.FdoData.ClassCreateClose = ChangerClassCreateClose;

    //
    // Stub routine to make the class driver happy.
    //

    InitializationData.FdoData.ClassReadWriteVerification = ChangerReadWriteVerification;

    InitializationData.ClassUnload = ChangerUnload;


    //
    // Routines for WMI support
    //
    InitializationData.FdoData.ClassWmiInfo.GuidCount = 3;
    InitializationData.FdoData.ClassWmiInfo.GuidRegInfo = ChangerWmiFdoGuidList;
    InitializationData.FdoData.ClassWmiInfo.ClassQueryWmiRegInfo = ChangerFdoQueryWmiRegInfo;
    InitializationData.FdoData.ClassWmiInfo.ClassQueryWmiDataBlock = ChangerFdoQueryWmiDataBlock;
    InitializationData.FdoData.ClassWmiInfo.ClassSetWmiDataBlock = ChangerFdoSetWmiDataBlock;
    InitializationData.FdoData.ClassWmiInfo.ClassSetWmiDataItem = ChangerFdoSetWmiDataItem;
    InitializationData.FdoData.ClassWmiInfo.ClassExecuteWmiMethod = ChangerFdoExecuteWmiMethod;
    InitializationData.FdoData.ClassWmiInfo.ClassWmiFunctionControl = ChangerWmiFunctionControl;

    //
    // Call the class init routine
    //

    return ClassInitialize( DriverObject, RegistryPath, &InitializationData);

}


VOID
ChangerUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    return;
}

NTSTATUS
CreateChangerDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates an object for the device and then searches
    the device for partitions and creates an object for each partition.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PhysicalDeviceObject - DeviceObject of the attached to device.

Return Value:

    NTSTATUS

--*/

{

    PDEVICE_OBJECT lowerDevice;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;
    CCHAR          deviceNameBuffer[64];
    NTSTATUS       status;
    PDEVICE_OBJECT deviceObject;
    ULONG          requiredStackSize;
    PVOID          senseData;
    WCHAR          dosNameBuffer[64];
    WCHAR          wideNameBuffer[64];
    UNICODE_STRING dosUnicodeString;
    UNICODE_STRING deviceUnicodeString;
    PMCD_CLASS_DATA mcdClassData;
    PMCD_INIT_DATA mcdInitData;
    ULONG          mcdCount;

    PAGED_CODE();

    DebugPrint((3,"CreateChangerDeviceObject: Enter routine\n"));

    //
    // Get the saved MCD Init Data
    //
    mcdInitData = IoGetDriverObjectExtension(DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT(mcdInitData);

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);
    //
    // Claim the device. Note that any errors after this
    // will goto the generic handler, where the device will
    // be released.
    //

    status = ClassClaimDevice(lowerDevice, FALSE);

    if(!NT_SUCCESS(status)) {

        //
        // Someone already had this device.
        //

        ObDereferenceObject(lowerDevice);
        return status;
    }

    //
    // Create device object for this device.
    //
    mcdCount = 0;
    do {
       sprintf(deviceNameBuffer,
               "\\Device\\Changer%d",
               mcdCount);

       status = ClassCreateDeviceObject(DriverObject,
                                        deviceNameBuffer,
                                        PhysicalDeviceObject,
                                        TRUE,
                                        &deviceObject);
       mcdCount++;
    } while (status == STATUS_OBJECT_NAME_COLLISION);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"CreateChangerDeviceObjects: Can not create device %s\n",
                    deviceNameBuffer));

        goto CreateChangerDeviceObjectExit;
    }

    //
    // Indicate that IRPs should include MDLs.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system tape number
    //

    fdoExtension->DeviceNumber = mcdCount - 1;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Save the device descriptors
    //

    fdoExtension->AdapterDescriptor = NULL;

    fdoExtension->DeviceDescriptor = NULL;

    //
    // Clear the SrbFlags and disable synchronous transfers
    //

    fdoExtension->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Attach to the PDO
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        //
        // The attach failed. Cleanup and return.
        //

        status = STATUS_UNSUCCESSFUL;
        goto CreateChangerDeviceObjectExit;
    }


    //
    // Create the dos port driver name.
    //

    swprintf(dosNameBuffer,
             L"\\DosDevices\\Changer%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);

    //
    // Recreate the deviceName
    //

    swprintf(wideNameBuffer,
             L"\\Device\\Changer%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&deviceUnicodeString,
                         wideNameBuffer);


    mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);
    (ULONG_PTR)mcdClassData += mcdInitData->ChangerAdditionalExtensionSize();
    if (NT_SUCCESS(IoAssignArcName(&dosUnicodeString, &deviceUnicodeString))) {
          mcdClassData->DosNameCreated = TRUE;
    } else {
          mcdClassData->DosNameCreated = FALSE;
    }

    //
    // The device is initialized properly - mark it as such.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    ObDereferenceObject(lowerDevice);

    return(STATUS_SUCCESS);

CreateChangerDeviceObjectExit:

    //
    // Release the device since an error occured.
    //

    // ClassClaimDevice(PortDeviceObject,
    //                      LunInfo,
    //                      TRUE,
    //                      NULL);

    ObDereferenceObject(lowerDevice);

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    return status;


} // end CreateChangerDeviceObject()


NTSTATUS
ChangerClassSendSrbSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN WriteToDevice
    )
{
    return ClassSendSrbSynchronous(DeviceObject, Srb,
                                   Buffer, BufferSize,
                                   WriteToDevice);
}


PVOID
ChangerClassAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )

{
    return ExAllocatePoolWithTag(PoolType, NumberOfBytes, 'CMcS');
}


VOID
ChangerClassFreePool(
    IN PVOID PoolToFree
    )
{
    ExFreePool(PoolToFree);
}

#if DBG
#define MCHGR_DEBUG_PRINT_BUFF_LEN 127
ULONG MCDebug = 0;
UCHAR DebugBuffer[MCHGR_DEBUG_PRINT_BUFF_LEN + 1];
#endif


#if DBG

VOID
ChangerClassDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all medium changer drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= MCDebug) {

        _vsnprintf(DebugBuffer, MCHGR_DEBUG_PRINT_BUFF_LEN,
                  DebugMessage, ap);
        DebugBuffer[MCHGR_DEBUG_PRINT_BUFF_LEN] = '\0';

        DbgPrintEx(DPFLTR_MCHGR_ID, DPFLTR_INFO_LEVEL, DebugBuffer);
    }

    va_end(ap);

} // end MCDebugPrint()

#else

//
// DebugPrint stub
//

VOID
ChangerClassDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\stor\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <storport.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define MINIPKD_PRINT_ERROR(r)\
    dprintf("minipkd error (%x): %s @ line %d\n", (r), __FILE__, __LINE__);

#define RECUR  DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY   DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS
#define ADDROF DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

extern WINDBG_EXTENSION_APIS64 ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "wmistr.h"

#ifdef __cplusplus
extern "C" {
#endif

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

__inline 
VOID
xdindent(
    ULONG Depth
    )
{
    ULONG i;
    for (i=0; i<Depth; i++)
        dprintf("  ");
}

#define xdprintfEx(d, expr)\
    xdindent((d));\
    dprintf expr

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

extern FLAG_NAME SrbFlags[];

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
GetAddressAndDetailLevel(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    );

VOID
GetAddress(
    IN  PCSTR      Args,
    OUT PULONG64   Address
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

BOOLEAN
GetAnsiString(
    IN ULONG_PTR Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    );

PCHAR
GuidToString(
    GUID* GUID
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\kdext\stor\stordbgext.c ===
#include "pch.h"
#include "precomp.h"

typedef ULONG64 POINTER;

//
// Port processing irp means the port driver is currently executing
// instructions to complete the irp. The irp is NOT waiting for
// resources on any queue.
//

#define RaidPortProcessingIrp           (0xA8)

//
// Pending resources is when the irp is in an IO queue awaiting
// resources.
//

#define RaidPendingResourcesIrp         (0xA9)

//
// The irp takes on state Miniport Processing while the miniport has
// control over the irp. That is, between the time we call HwStartIo
// and when the miniport calls ScsiPortNotification with a completion
// status for the irp.
//

#define RaidMiniportProcessingIrp       (0xAA)

//
// The irp takes on the Pending Completion state when it is moved to
// the completed list.
//

#define RaidPendingCompletionIrp        (0xAB)

//
// We set the irp state to Completed just before we call IoCompleteRequest
// for the irp.
//

#define RaidCompletedIrp                (0xAC)


//#define XRB_SIGNATURE	(0x1F2E3D4CUL)
#define ARRAY_COUNT(Array) (sizeof(Array)/sizeof(Array[0]))


ULONG Verbose = 0;

PCHAR DeviceStateTable [] = {
        "Not Present",	// not present
	    "Working",	// working
	    "Stopped",	// stopped
	    "P-Stop",	// pending stop
	    "P-Remove",	// pending remove
	    "Surprise",	// surprise remove
        "Removed",  // removed
        "Invalid"   // invalid state
};


PCHAR SystemPowerTable [] = {
        "Unspecified",
        "Working",
        "Sleeping1",
        "Sleeping2",
        "Sleeping3",
        "Hibernate",
        "Shutdown",
        "Maximum",
        "Invalid"
};


PCHAR DevicePowerTable [] = {
        "Unspecified",
        "D0",
        "D1",
        "D2",
        "D3",
        "Maximum",
        "Invalid"
};


char *SCSI6byteOpCode[] = {      /* 0x00 - 0x1E */
    "SCSI/TEST UNT RDY",
    "SCSI/REZERO UNIT ",
    "SCSI/REQ BLK ADDR",
    "SCSI/REQ SENSE   ",
    "SCSI/FORMAT UNIT ",
    "SCSI/RD BLK LMTS ",
    "SCSI/NO OPCODE   ",
    "SCSI/REASSGN BLKS",
    "SCSI/READ (06)   ",
    "SCSI/INVALID     ",
    "SCSI/WRITE (06)  ",
    "SCSI/SEEK (06)   ",
    "SCSI/SEEK BLOCK  ",
    "SCSI/PARTITION   ",
    "SCSI/NO OPCODE   ",
    "SCSI/READ REVERSE",
    "SCSI/WRTE FILEMKS",
    "SCSI/SPACE       ",
    "SCSI/INQUIRY     ",
    "SCSI/VERIFY (06) ",
    "SCSI/RECVR BUFFRD",
    "SCSI/MODE SEL(06)",
    "SCSI/RESERVE UNIT",
    "SCSI/RELEASE UNIT",
    "SCSI/COPY        ",
    "SCSI/ERASE       ",
    "SCSI/MOD SNSE(06)",
    "SCSI/STRT/STP UNT",
    "SCSI/RECV DIAGNOS",
    "SCSI/SEND DIAGNOS",
    "SCSI/MEDIUM REMVL"
 };


char *SCSI10byteOpCode[] = {    /* 0x23 - 0x5F */
    "SCSI/RD FRMTD CAP", 
    "SCSI/NOP         ",
    "SCSI/READ CAP    ",
    "SCSI/NOP         ",
    "SCSI/NOP         ",
    "SCSI/READ (10)   ",
    "SCSI/NO OPCODE   ",
    "SCSI/WRITE (10)  ",
    "SCSI/SEEK (10)   ",          
    "SCSI/NOP         ",
    "SCSI/NOP         ",
    "SCSI/WRT&VRF (10)",
    "SCSI/VERIFY (10) ",
    "SCSI/SC DT H (10)",
    "SCSI/SC DT E (10)",
    "SCSI/SC DT L (10)",
    "SCSI/ST LMTS (10)",
    "SCSI/PRE-FETCH   ",
    "SCSI/SYNC   CACHE",
    "SCSI/LCK/UN CACHE",
    "SCSI/RD DF D (10)",
    "SCSI/NO OPCODE   ",
    "SCSI/COMPARE     ",
    "SCSI/CPY & VERIFY",
    "SCSI/WRT DAT BUFF",
    "SCSI/RD DAT BUFF ",
    "SCSI/NO OPCODE   ",
    "SCSI/READ LONG   ",
    "SCSI/WRITE LONG  ",
    "SCSI/CHGE DEF    ",
    "SCSI/RD SUB-CHNL ",
    "SCSI/READ TOC    ",
    "SCSI/READ HEADER ",
    "SCSI/PLY AUD (10)",
    "SCSI/GET CONFIG  ",
    "SCSI/PLY AUD MSF ",
    "SCSI/PLY TRK INDX",
    "SCSI/PLY TRK REL ",
    "SCSI/GET EVT STAT",
    "SCSI/PAUSE/RESUME",
    "SCSI/LOG SELECT  ",
    "SCSI/LOG SENSE   ",
    "SCSI/STP/PLY SCAN",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/RD DSK INFO ",
    "SCSI/RD TRK INFO ",
    "SCSI/RSRV TRCK RZ",
    "SCSI/SND OPC INFO",
    "SCSI/MOD SEL (10)",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/MOD SNS (10)",
    "SCSI/CLS TRCK SES",
    "SCSI/RD BUFF CAP ",
    "SCSI/SND CUE SHT ",
    "SCSI/PRS RSRV IN ",
    "SCSI/PRS RSRV OUT"
};


char *SCSI12byteOpCode[] = {    /* 0xA0 - 0xBF, 0xE7 */
    "SCSI/REPORT LUNS ",
    "SCSI/BLANK       ",
    "SCSI/NO OPCODE   ",
    "SCSI/SEND KEY    ",
    "SCSI/REPORT KEY  ",
    "SCSI/MOVE MEDIUM ",
    "SCSI/LD/UNLD SLOT",
    "SCSI/SET RD AHEAD",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/RD DVD STRUC",
    "SCSI/NO OPCODE   ", 
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/REQ VOL ELMT",
    "SCSI/SEND VOL TAG",
    "SCSI/NO OPCODE   ",
    "SCSI/RD ELMT STAT",
    "SCSI/READ CD MSF ",
    "SCSI/SCAN CD     ",
    "SCSI/SET CD SPEED",
    "SCSI/PLAY CD     ",
    "SCSI/MECHNSM STAT",
    "SCSI/READ CD     ",
    "SCSI/SND DVD STRC",
    "SCSI/INIT ELM RNG",       /* 0xE7 */
};


PCHAR SrbFunctions [] = {
	"EXECUTE SCSI     ",		// 0x00
	"CLAIM DEVICE     ",		// 0x01
	"IO CONTROL       ",		// 0x02
	"RECEIVE EVENT    ",		// 0x03
	"RELEASE QUEUE    ",		// 0x04
	"ATTACH DEVICE    ",		// 0x05
	"RELEASE DEVICE   ",		// 0x06
	"SHUTDOWN         ",			// 0x07
	"FLUSH            ",		// 0x08
	"NOP              ",		// 0x09
	"NOP              ",		// 0x0A
	"NOP              ",		// 0x0B
	"NOP              ",		// 0x0C
	"NOP              ",		// 0x0D
	"NOP              ",		// 0x0E
	"NOP              ",		// 0x0F
	"ABORT COMMAND    ",		// 0x10
	"RELEASE RECOVERY ",		// 0x11
	"RESET BUS        ",		// 0x12
	"RESET DEVICE     ",		// 0x13
	"TERMINATE IO     ",		// 0x14
	"FLUSH QUEUE      ",		// 0x15
	"REMOVE DEVICE    ",		// 0x16
	"WMI              ",		// 0x17
	"LOCK QUEUE       ",		// 0x18
	"UNLOCK QUEUE     ",		// 0x19
	"NOP              ",        // 0x1A
	"NOP              ",        // 0x1B
	"NOP              ",        // 0x1C
	"NOP              ",        // 0x1D
	"NOP              ",        // 0x1E
	"NOP              ",        // 0x1F
	"RESET LUN        "			// 0x20
};

VOID
FixString (
    PSZ Id
    )

{
    ULONG Pos;

    Pos = strlen(Id);
    if (Pos > 0) {
        Pos--;
    }

    while ( (Pos > 0) && (Id[Pos] == ' ') ) {
        Id[Pos]='\0';
        Pos--;
    }
}


UCHAR
GetIoState(
	IN POINTER Xrb
	)
{
	POINTER Irp;
	ULONG Offset;
	UCHAR State;
	POINTER ExEntry;
	
	GetFieldValue (Xrb,
				   "storport!EXTENDED_REQUEST_BLOCK",
				   "Irp",
				   Irp);

	GetFieldOffset ("storport!IRP",
					"Tail.Overlay.DeviceQueueEntry",
					&Offset);

	ExEntry = Irp + Offset;

	GetFieldValue (ExEntry,
				   "storport!EX_DEVICE_QUEUE_ENTRY",
				   "State",
				   State);

	return State;
}

BOOLEAN
GetScsiCommand(
	IN POINTER Srb,
	OUT PUCHAR Command
	)
{
	ULONG Offset;
	
	*Command = 0xFF;
	
	GetFieldOffset("storport!SCSI_REQUEST_BLOCK", "Cdb", &Offset);

	ReadMemory(Srb + Offset, Command, sizeof (Command), NULL);      

	return TRUE;
}

BOOLEAN
VerifyXrb(
	IN POINTER Xrb
	)
{
	ULONG Signature;
	
	GetFieldValue (Xrb,
				   "storport!EXTENDED_REQUEST_BLOCK",
				   "Signature",
				   Signature);
	return (Signature == XRB_SIGNATURE);
}

VOID
GetUnitProductInfo (
    IN ULONG64 UnitExtension,
    PSZ VendorId,
    PSZ ProductId
    )

{
    ULONG64 UnitInfoPtr;
    ULONG64 UnitInfo;
    ULONG offset;
    
    
    ZeroMemory(VendorId, 9);
    ZeroMemory(ProductId, 17);
    if (!GetFieldOffset("storport!RAID_UNIT_EXTENSION", "Identity", &offset)) {
        UnitInfoPtr = UnitExtension + offset;
        if (!GetFieldOffset("storport!STOR_SCSI_IDENTITY", "InquiryData", &offset)) {
            UnitInfoPtr = UnitInfoPtr + offset;
            ReadPointer(UnitInfoPtr, &UnitInfo);
            if (GetFieldData(UnitInfo, "storport!INQUIRYDATA", "VendorId", 8, VendorId)) {
                //dprintf("ERROR: Unable to retrieve VendorId field\n");
            }
            if (GetFieldData(UnitInfo, "storport!INQUIRYDATA", "ProductId", 16, ProductId)) {
                //dprintf("ERROR: Unable to retrieve ProductId field\n");
            }
            FixString(VendorId);
            FixString(ProductId);
        }
        else {
            dprintf("ERROR: Unable to retrieve InquiryData offset\n");
        }
    }
    else {
        dprintf("ERROR: Unable to retrieve Identity offset\n");
    }
}


VOID
PrintAddressList (
    IN ULONG64 Address
    )

{ 
    if (IsPtr64()) {
        dprintf("%16.16x  ", Address);
    }
    else {
        dprintf("%8.8x  ", Address);
    }
}


VOID
GetScsiCommandString(
    IN UCHAR Command,
	IN PCHAR Buffer
    )

{
    UCHAR Index;

    if ((Command >= 0x00) && (Command <= 0x1E)) {
        Index = Command;
        sprintf(Buffer, "%s", SCSI6byteOpCode[Index]); 
        return;
    }

	if ((Command >= 0x23) && (Command <= 0x5F)) {
        Index = Command - 0x23;
        sprintf(Buffer, "%s", SCSI10byteOpCode[Index]);
        return;
    }

	if ((Command >= 0xA0) && (Command <= 0xBF)) {
        Index = Command - 0xA0;
        sprintf(Buffer, "%s", SCSI12byteOpCode[Index]); 
        return;
    }

	if (Command == 0xE7) {
        sprintf(Buffer, "%s", SCSI12byteOpCode[32]); 
        return;
    }

	sprintf(Buffer, "NO OPCODE        ");
}


VOID
PrintAddress (
    IN PSZ Name,
    IN ULONG64 Address
    )

{
    if (IsPtr64()) {
        dprintf("%s %16.16x   ", Name, Address);
    }
    else {
        dprintf("%s %8.8x   ", Name, Address);
    }
}


ULONG64
ContainingRecord (
        IN ULONG64  Object,
        IN PSZ Type,
        IN PSZ Field
        )

{
    ULONG offset;

    
    if (GetFieldOffset(Type, Field, &offset)) {
        return 0;
    }
    else {
        return (Object - offset);
    }
}


BOOLEAN
CheckRaidObject (
    IN ULONG64 Object,
    IN RAID_OBJECT_TYPE Type
    )

{
    RAID_OBJECT_TYPE RetType;

    if (GetFieldValue(Object, "storport!RAID_COMMON_EXTENSION", "ObjectType", RetType )) {
        return FALSE;
    }
    else if (Type != RetType) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
IsDeviceObject (
    IN ULONG64 address
    )

{
    CSHORT Type;

    if (GetFieldValue(address, "storport!DEVICE_OBJECT", "Type", Type)) {
        return FALSE;
    }
    else {
        return (Type == IO_TYPE_DEVICE);
    }
}


ULONG64
GetExtension (
    IN ULONG64 address,
    IN RAID_OBJECT_TYPE Object
    )

{
    ULONG64 Extension;
    ULONG64 DeviceObject;
    ULONG64 temp;
    ULONG offset;
    
    if (CheckRaidObject(address, Object)) {
        Extension = address;
        if (Object == RaidAdapterObject) {
            InitTypeRead(Extension, storport!RAID_ADAPTER_EXTENSION);
        }
        else if (Object == RaidUnitObject) {
            InitTypeRead(Extension, storport!RAID_UNIT_EXTENSION);
        }

        DeviceObject = ReadField(DeviceObject);
        
        if (IsDeviceObject(DeviceObject)) {
            if (GetFieldOffset("storport!DEVICE_OBJECT", "DeviceExtension", &offset)) {
                dprintf("ERROR: Unable to retrieve Device Extension offset\n");
                temp = 0;
            }
            else {
                ReadPointer(DeviceObject + offset, &temp);
            }
            
            if (temp == Extension) {
                return Extension;
            }
        }
    }

    DeviceObject = address;            
    if (IsDeviceObject(DeviceObject)) {
        if (GetFieldOffset("storport!DEVICE_OBJECT", "DeviceExtension", &offset)) {
            dprintf("ERROR: Unable to retrieve Device Extension offset\n");
            Extension = 0;
        }
        else {
            ReadPointer(DeviceObject + offset, &Extension);
        }

        if (CheckRaidObject(Extension, Object)) {
            if (Object == RaidAdapterObject) {
                InitTypeRead(Extension, storport!RAID_ADAPTER_EXTENSION);
            }
            else if (Object == RaidUnitObject) {
                InitTypeRead(Extension, storport!RAID_UNIT_EXTENSION);
            }
            DeviceObject = ReadField(DeviceObject);
            
            if (DeviceObject == address) {
                return Extension;
            }
        }
    }
    else {
        dprintf("ERROR: Invalid Device Object\n");
    }

    return 0;
}


PCHAR
DeviceStateToString (
    IN ULONG State
    )

{
    if (State > 6) {
        return DeviceStateTable[7];
    }

    return DeviceStateTable[State];
}


PCHAR
SystemPower (
    IN ULONG State
    )

{
    if (State > 7) {
        return SystemPowerTable[8];
    }

    return SystemPowerTable[State];
}


PCHAR
DevicePower (
    IN ULONG State
    )

{
    if (State > 5) {
        return DevicePowerTable[6];
    }

    return DevicePowerTable[State];
}

PCHAR
GetSrbFunction(
	IN UCHAR SrbFunctionCode
	)
{
	if (SrbFunctionCode >= ARRAY_COUNT (SrbFunctions)) {
		return "Invalid SRB Function";
	}

	return SrbFunctions [SrbFunctionCode];
}

ULONG
GetRemLockCount (
    IN ULONG64 Object,
    IN PSZ Type,
    IN PSZ Field
    )

{
    ULONG64 address;
    ULONG offset;
    ULONG IOCount;
    
    IOCount = -1;

    if (!GetFieldOffset(Type, Field, &offset)) {
        address = Object + offset;
        if (!GetFieldOffset("storport!IO_REMOVE_LOCK", "Common", &offset)) {
            address = address + offset;
            GetFieldValue(address,"storport!IO_REMOVE_LOCK_COMMON_BLOCK", "IoCount", IOCount);
        }
    }
    return IOCount;
}


VOID
dindentf(
    IN ULONG Depth
    )

{
    ULONG i;
    
    for (i = 1; i <= Depth; i++) {
        dprintf("   ");
    }
}


VOID
DumpQueuedRequests(
    IN POINTER DeviceQueue
    )
{
    ULONG64 ListHead;
    ULONG64 NextRequest;
    ULONG64 Irp;
    ULONG64 StackLocation;
    ULONG64 Srb;
    ULONG offset;
    ULONG CommandLength;
    ULONG TimeOut;
    UCHAR ScsiCommand;
    UCHAR SrbFunction;
	CHAR ScsiCommandString[100];
    
    if (GetFieldOffset("storport!EXTENDED_DEVICE_QUEUE", "DeviceListHead", &offset)) {
        dprintf("ERROR: Unable to retrieve PendingQueue offset\n");
        return;
    }

	ListHead = DeviceQueue + offset;

    for (GetFieldValue(ListHead, "storport!LIST_ENTRY", "Flink", NextRequest); NextRequest != 0 && NextRequest != ListHead; GetFieldValue(NextRequest, "storport!LIST_ENTRY", "Flink", NextRequest)) {
        Irp = ContainingRecord(NextRequest, "storport!IRP", "Tail.Overlay.DeviceQueueEntry.DeviceListEntry");
        PrintAddressList(Irp);
        
        if (GetFieldOffset("storport!IRP", "Tail.Overlay.CurrentStackLocation", &offset)) {
            dprintf("ERROR: Unable to retrieve Current Stack Location offset\n");
            return;
        }
        StackLocation = Irp + offset;
        ReadPtr(StackLocation, &StackLocation);

        if (GetFieldOffset("storport!IO_STACK_LOCATION",
						  "Parameters.Scsi.Srb", &offset)) {

			dprintf("ERROR: Unable to retrieve Srb offset\n");
            return;
        }
		
        Srb = StackLocation + offset;
        ReadPtr (Srb, &Srb);
        PrintAddressList(Srb);

        dprintf("  n/a     ");

		GetFieldValue (Srb,
					   "storport!SCSI_REQUEST_BLOCK",
					   "Function",
					   SrbFunction);
			
					   
        if (SrbFunction == SRB_FUNCTION_EXECUTE_SCSI) {
			GetScsiCommand (Srb, &ScsiCommand),
			GetScsiCommandString (ScsiCommand, ScsiCommandString);
		} else {
			sprintf (ScsiCommandString,
					 "%s    ",
					 GetSrbFunction (SrbFunction));
		}

		dprintf ("%s ", ScsiCommandString);
		
        InitTypeRead(Irp, storport!IRP);
        PrintAddressList(ReadField(MdlAddress));
        dprintf("  n/a     ");


        GetFieldValue(Srb,
					  "storport!SCSI_REQUEST_BLOCK",
					  "TimeOutValue",
					  TimeOut);
					  
        dprintf("%d\n", TimeOut);
    }
}


#if 0

VOID
ReadFlink(
	IN ULONG64 ListEntry,
	OUT PULONG64 NextListEntry
	)
{
	GetFieldValue (ListEntry, "nt!LIST_ENTRY", "Flink", *NextListEntry);
}

VOID
IteratePendingRequests(
    IN ULONG64 DeviceQueue,
	IN ULONG Flags,
	IN PFN Callback
    )
{
    ULONG64 ListHead;
    ULONG64 NextRequest;
    ULONG64 Irp;
    ULONG64 StackLocation;
    ULONG64 Srb;
    ULONG offset;
    ULONG CommandLength;
    ULONG TimeOut;
    UCHAR Command;
    UCHAR SrbFunction;
    

	if (GetFieldOffset("storport!EXTENDED_DEVICE_QUEUE", "DeviceListHead", &offset)) {
        dprintf("ERROR: Unable to retrieve PendingQueue offset\n");
        return;
    }

    ListHead = DeviceQueue + offset;

	for (ReadFlink (ListHead, NextRequest);
		 NextRequest != 0 && NextRequest != ListHead;
		 ReadFlink (NextRequest, NextRequest)) {
		 
        Irp = ContainingRecord (
						NextRequest,
						"storport!IRP",
						"Tail.Overlay.DeviceQueueEntry.DeviceListEntry");
		Callback (Irp);
	}
}


#endif


ULONG
DumpRequests (
    IN POINTER UnitExtension,
	IN UCHAR RequestedState
    )
/*++

Routine Description:

	Print out list of outstanding or pending requests depending on value
	of RequestedState parameter.

Arguments:

	UnitExtension - Debuggee-Pointer to unit extension.

	RequestedState - Supplies the requested state to dump, must be either:

		RaidMiniportProcessingIrp for Outstanding requests.

		RaidPendingCompletionIrp for Completing requests.

Return Value:

	Number of requests dumped.

--*/
{
    POINTER address;
    POINTER NextRequest;
    POINTER Xrb;
    POINTER Srb;
    ULONG offset;
    ULONG TimeOut;
    UCHAR SrbFunction;
    UCHAR ScsiCommand;
	CHAR ScsiCommandString[100];
	UCHAR IoState;
	ULONG Count;

	Count = 0;

    if (GetFieldOffset("storport!RAID_UNIT_EXTENSION", "PendingQueue", &offset)) {
        dprintf("ERROR: Unable to retrieve PendingQueue offset\n");
        return 0;
    }
    
    address = UnitExtension + offset;

    if (GetFieldOffset("storport!STOR_EVENT_QUEUE", "List", &offset)) {
        dprintf("ERROR: Unable to retrieve PendingQueue offset\n");
        return 0;
    }

    address += offset;

    for (GetFieldValue(address, "storport!LIST_ENTRY", "Flink", NextRequest);
		 NextRequest != 0 && NextRequest != address;
		 GetFieldValue(NextRequest, "storport!LIST_ENTRY", "Flink", NextRequest)) {
		
		Xrb = ContainingRecord (NextRequest,
							    "storport!EXTENDED_REQUEST_BLOCK",
								"PendingLink.NextLink");

		if (Verbose) {
			dprintf ("VERBOSE: Xrb %p\n", Xrb);
		}
        
        InitTypeRead(Xrb, storport!EXTENDED_REQUEST_BLOCK);

		if (!VerifyXrb (Xrb)) {
			dprintf ("ERROR: Request %p does not have an XRB signature!\n",
					  Xrb);
			continue;
		}

		IoState = GetIoState (Xrb);

		if (Verbose) {
			dprintf ("VERBOSE: Irp state is %x\n", (ULONG)IoState);
		}
		
		if (IoState != RequestedState) {
			continue;
		}

		Count++;

		GetFieldValue (Xrb,
					   "storport!EXTENDED_REQUEST_BLOCK",
					   "Srb",
					   Srb);
		
		PrintAddressList(ReadField(Irp));
        PrintAddressList(Srb);
        PrintAddressList(Xrb);

		GetFieldValue (Srb,
					   "storport!SCSI_REQUEST_BLOCK",
					   "Function",
					   SrbFunction);
					   
		if (SrbFunction == SRB_FUNCTION_EXECUTE_SCSI) {
			GetScsiCommand (Srb, &ScsiCommand);
			GetScsiCommandString (ScsiCommand, ScsiCommandString);
		} else {
			sprintf (ScsiCommandString,
					 "%s    ",
					 GetSrbFunction (SrbFunction));
		}

		dprintf ("%s ", ScsiCommandString);

        InitTypeRead(Xrb, storport!EXTENDED_REQUEST_BLOCK);

		PrintAddressList (ReadField(Mdl));
		PrintAddressList (ReadField(SgList));

		GetFieldValue(Srb,
					  "Storport!SCSI_REQUEST_BLOCK",
					  "TimeOutValue",
					  TimeOut);
					  
        dprintf("%d\n", TimeOut);

    }

	return Count;
}

ULONG
DumpOutstandingRequests(
	IN POINTER UnitExtension
	)
{
	return DumpRequests (UnitExtension, RaidMiniportProcessingIrp);
}


ULONG
DumpCompletedRequests(
	IN POINTER UnitExtension
	)
{
	return DumpRequests (UnitExtension, RaidPendingCompletionIrp);
}

VOID
PrintRequestListHeader(
	IN PCHAR Title
	)
{
	dprintf ("\n\n[%s]\n\n", Title);
    dprintf("IRP       SRB       XRB       Command           MDL       "
			"SGList    Timeout\n");
    dprintf("----------------------------------------------------------"
	        "-----------------\n");
}

VOID
DumpUnit (
    IN ULONG64 address,
    IN ULONG Level,
    IN ULONG Depth
    )

{
    ULONG64 UnitExtension;
    ULONG64 VirtualBase;
    ULONG64 QueueTagList;
    ULONG64 IoQueue;
    ULONG64 DeviceQueue;
    ULONG64 IoGateway;
    ULONG64 EventQ;
    ULONG offset;
    ULONG RemLock_IOCount;
    UCHAR VendorId[9] = {0};
    UCHAR ProductId[17] = {0};
    PSZ SlowLock;

    UnitExtension = GetExtension(address, RaidUnitObject);

    if (UnitExtension == 0) {
        dprintf("ERROR: Unable to retrieve Unit Extension address\n");
        return;
    }

    InitTypeRead(UnitExtension, storport!RAID_UNIT_EXTENSION);

    if (Level == 0) {
        GetUnitProductInfo(UnitExtension, VendorId, ProductId);
            
        dindentf(Depth);
        if (!GetFieldOffset("storport!RAID_UNIT_EXTENSION", "Address", &offset)) {
            InitTypeRead(UnitExtension + offset, storport!STOR_SCSI_ADDRESS);
        }
        else {
            dprintf("ERROR: Unable to retrieve STOR_SCSI_ADDRESS structure offset\n");
        }
        dprintf("%-10.10s %-10.10s  %2d %2d %2d  ",
				VendorId,
				ProductId,
				(ULONG)ReadField(PathId),
				(ULONG)ReadField(TargetId),
				(ULONG)ReadField(Lun));
        InitTypeRead(UnitExtension, storport!RAID_UNIT_EXTENSION);
        PrintAddressList(ReadField(DeviceObject));
        PrintAddressList(UnitExtension);
           
        if (GetFieldOffset("storport!RAID_UNIT_EXTENSION", "IoQueue", &offset)) {
            dprintf("ERROR: Unable to retrieve IoQueue offset\n");
            return;
        }
        IoQueue = UnitExtension + offset;
        if (GetFieldOffset("storport!IO_QUEUE", "DeviceQueue", &offset)) {
            dprintf("ERROR: Unable to retreive DeviceQueue offset\n");
            return;
        }
        DeviceQueue = IoQueue + offset;

        InitTypeRead(DeviceQueue, storport!EXTENDED_DEVICE_QUEUE);

        dprintf("%3d %3d %2d  ",
				(ULONG)ReadField(DeviceRequests),
				(ULONG)ReadField(OutstandingRequests),
				(ULONG)ReadField(ByPassRequests));
        
        InitTypeRead(UnitExtension, storport!RAID_UNIT_EXTENSION);
        dprintf("%s\n", DeviceStateToString((ULONG)ReadField(DeviceState))); 

	} else {

		ULONG OutstandingCount;
		ULONG Count;
		
		dprintf("UNIT\n");
        Depth++;
        dindentf(Depth);
        PrintAddress("DO", ReadField(DeviceObject));
        PrintAddress("Ext", UnitExtension);
        PrintAddress("Adapter", ReadField(Adapter));
        dprintf("%s\n", DeviceStateToString((ULONG)ReadField(DeviceState)));
        GetUnitProductInfo(UnitExtension, VendorId, ProductId);
            
        dindentf(Depth);

		if (!GetFieldOffset("storport!RAID_UNIT_EXTENSION", "Address", &offset)) {
            InitTypeRead(UnitExtension + offset, storport!STOR_SCSI_ADDRESS);
        } else {
            dprintf("ERROR: Unable to retrieve STOR_SCSI_ADDRESS structure offset\n");
        }
		
        dprintf("Vendor: %s   Product: %s   SCSI ID: (%d, %d, %d)   \n", VendorId, ProductId, (ULONG)ReadField(PathId), (ULONG)ReadField(TargetId), (ULONG)ReadField(Lun));
        InitTypeRead(UnitExtension, storport!RAID_UNIT_EXTENSION);
        dindentf(Depth);
        dprintf("%s %s %s %s \n", (ReadField(Flags.DeviceClaimed) ? "Claimed" : ""), (ReadField(Flags.QueueFrozen) ? "Frozen" : ""), (ReadField(Flags.QueueLocked) ? "Locked" : ""), (ReadField(Flags.Enumerated) ? "Enumerated" : ""));

        InitTypeRead(UnitExtension, storport!RAID_UNIT_EXTENSION);
        SlowLock = ReadField(SlowLock) ? "Held" : "Free";
        RemLock_IOCount = GetRemLockCount(UnitExtension, "storport!RAID_UNIT_EXTENSION", "RemoveLock");
        dindentf(Depth);
        dprintf("SlowLock %s   RemLock %d   PageCount %d\n", SlowLock, RemLock_IOCount, (ULONG)ReadField(PagingPathCount));

        VirtualBase = ReadField(SrbExtensionRegion.VirtualBase);
        dindentf(Depth);
        PrintAddress("SrbExtensionRegion (Virtual Base)", VirtualBase);
        dprintf("(%d bytes)\n", (ULONG)ReadField(SrbExtensionRegion.Length));

        if (GetFieldOffset("storport!RAID_UNIT_EXTENSION", "TagList", &offset)) {
            dprintf("ERROR: Unable to retrieve TagList offset\n");
            return;
        }
        QueueTagList = UnitExtension + offset;

        dindentf(Depth);
        PrintAddress("QueueTagList:", QueueTagList);
        dprintf("(%d of %d used)\n", (ULONG)ReadField(TagList.OutstandingTags), (ULONG)ReadField(TagList.Count));

        if (GetFieldOffset("storport!RAID_UNIT_EXTENSION", "IoQueue", &offset)) {
            dprintf("ERROR: Unable to retrieve IoQueue offset\n");
        }
		IoQueue = UnitExtension + offset;

		if (GetFieldOffset("storport!IO_QUEUE", "DeviceQueue", &offset)) {
            dprintf("ERROR: Unable to retreive DeviceQueue offset\n");
        }
        DeviceQueue = IoQueue + offset;

		if (GetFieldOffset ("storport!RAID_UNIT_EXTENSION", "PendingQueue", &offset)) {
			dprintf ("ERROR: Unable to retrieve PendingQueue offset\n");
		}
		EventQ = UnitExtension + offset;
		
        InitTypeRead (EventQ, storport!STOR_EVENT_QUEUE);
        dindentf(Depth);
		dprintf("Outstanding: Head %p  Tail %p  Timeout %d\n",
				ReadField (List.Flink),
				ReadField (List.Blink),
				ReadField (Timeout));
        
        InitTypeRead(DeviceQueue, storport!EXTENDED_DEVICE_QUEUE);
        dindentf(Depth);
        PrintAddress("DeviceQueue", DeviceQueue);
        dprintf("Depth: %d   ", (ULONG)ReadField(Depth));
        dprintf("Status: %s \n",
				(ReadField(Frozen) ? "Frozen" : "Not Frozen"));
        
        IoGateway = ReadField(Gateway);
        InitTypeRead(IoGateway, storport!STOR_IO_GATEWAY);
        dindentf(Depth);
        dprintf("IO Gateway: Busy Count %d   Pause Count %d\n",
				 (ULONG)ReadField(BusyCount),
				 (ULONG)ReadField(PauseCount));
        InitTypeRead(DeviceQueue, storport!EXTENDED_DEVICE_QUEUE);
        dindentf(Depth);

		OutstandingCount = (ULONG)ReadField (OutstandingRequests);
        dprintf("Requests: Outstanding %d   Device %d   ByPass %d\n",
				OutstandingCount,
				(ULONG)ReadField(DeviceRequests),
				(ULONG)ReadField(ByPassRequests));

		PrintRequestListHeader ("Queued Requests");
        DumpQueuedRequests (DeviceQueue);

		PrintRequestListHeader ("Outstanding Requests");
        Count = DumpOutstandingRequests (UnitExtension);

		PrintRequestListHeader ("Completed Requests");
        Count += DumpCompletedRequests (UnitExtension);

		if (Count < OutstandingCount) {
			dprintf ("\n\nNOTE: %d request(s) not found on the completed or outstanding list. The\n"
					 "  requests are probably being transferred from one list to another. On an\n"
				     "  MP machine this could be happening on a separate processor.\n",
					 OutstandingCount - Count);
		} else if (Count > OutstandingCount) {
			dprintf ("ERROR: %d counted requests > %d outstanding requests\n\n",
					 Count, OutstandingCount);
		}

		dprintf ("\n");
    }
}


VOID
ListAdapterUnits(
    IN ULONG64 AdapterExtension,
    IN ULONG Level,
    IN ULONG Depth
    )

{
    ULONG64 Units;
    ULONG64 NextUnit;
    ULONG64 UnitExtension;
    ULONG offset;

    if (!GetFieldOffset("storport!RAID_ADAPTER_EXTENSION", "UnitList.List", &offset)) {
        Units = AdapterExtension + offset;
    }
    else {
        dprintf("ERROR: Unable to retrieve Unit List offset\n");
        return;
    }

    for (GetFieldValue(Units, "storport!LIST_ENTRY", "Flink", NextUnit); NextUnit != 0 && NextUnit != Units; GetFieldValue(NextUnit, "storport!LIST_ENTRY", "Flink", NextUnit)) {
        UnitExtension = ContainingRecord(NextUnit, "storport!RAID_UNIT_EXTENSION", "NextUnit");

        if (!CheckRaidObject(UnitExtension, RaidUnitObject)) {
                dprintf("ERROR: Invalid RAID unit object\n");
                return;
        }

        DumpUnit(UnitExtension, 0, Depth); 
    }
}


VOID
DumpAdapter (
    IN ULONG64 address,
    IN ULONG Level,
    IN ULONG Depth
    )

{
    ULONG64 AdapterExtension;
    ULONG64 DriverNameBuffer;
    ULONG64 DriverNameLength;
    ULONG64 DriverObject;
    ULONG64 MiniportObject;
    ULONG64 HwInitData;
    ULONG64 HwDeviceExt;
    CHAR NameBuffer[512] = {0};
    PSZ SlowLock;
    ULONG RemLock;
    ULONG offset;
    ULONG debugtemp;
    ULONG debugoffset;
    
    AdapterExtension = GetExtension(address, RaidAdapterObject);
    if (AdapterExtension == 0) {
        dprintf("ERROR: Unable to retrieve Adapter Extension address\n");
        return;
    }

    InitTypeRead (AdapterExtension, storport!RAID_ADAPTER_EXTENSION);

    if (Level == 0) {
        if (GetFieldValue(ReadField(Driver), "storport!RAID_DRIVER_EXTENSION", "DriverObject", DriverObject)) {
            dprintf("ERROR: Unable to retrieve Driver Extension address\n");
            return;
        }   

        GetFieldValue(DriverObject, "storport!DRIVER_OBJECT", "DriverName.Buffer", DriverNameBuffer);
        GetFieldValue(DriverObject, "storport!DRIVER_OBJECT", "DriverName.Length", DriverNameLength);
        DriverNameLength = min(DriverNameLength, sizeof(NameBuffer)/sizeof(WCHAR)-1);
        ReadMemory(DriverNameBuffer, (PVOID)NameBuffer, (ULONG)DriverNameLength*sizeof(WCHAR), NULL);
        
        dprintf("%-20.20S   ", NameBuffer);
        PrintAddressList(ReadField(DeviceObject));
        PrintAddressList(AdapterExtension);
        dprintf(" %s\n", DeviceStateToString((ULONG)ReadField(DeviceState)));
    } else {
        dprintf("ADAPTER\n");
        Depth++;
        dindentf(Depth);
        PrintAddress("DO", ReadField(DeviceObject));
        PrintAddress("Ext", AdapterExtension);
        PrintAddress("Driver", ReadField(Driver));
        dprintf("%s\n", DeviceStateToString((ULONG)ReadField(DeviceState)));
        
        dindentf(Depth);
        PrintAddress("LDO", ReadField(LowerDeviceObject));
        PrintAddress("PDO", ReadField(PhysicalDeviceObject)); 
        dprintf("\n");
        
        SlowLock = ReadField(SlowLock) ? "Held" : "Free";
        RemLock = GetRemLockCount(AdapterExtension, "storport!RAID_ADAPTER_EXTENSION", "RemoveLock");

        dindentf(Depth);
        dprintf("SlowLock %s   RemLock %d   \n", SlowLock, RemLock);
        
        dindentf(Depth);
        dprintf("Power: %s %s   %s\n",
				SystemPower((ULONG)ReadField(Power.SystemState)), 
                DevicePower((ULONG)ReadField(Power.DeviceState)), 
                (ReadField(IoModel) == StorSynchronizeFullDuplex ? "Full Duplex" : "Half Duplex")); 
        
        dindentf(Depth);
        dprintf("Bus %d   Slot %d   ", (ULONG)ReadField(BusNumber), (ULONG)ReadField(SlotNumber));
        PrintAddress("DMA", ReadField(Dma.DmaAdapter));
        PrintAddress("Interrupt", ReadField(Interrupt));
        dprintf("\n");

        dindentf(Depth);
        PrintAddress("ResourceList: Allocated", ReadField(ResourceList.AllocatedResources));
        PrintAddress("Translated", ReadField(ResourceList.TranslatedResources));
        
        dprintf("\n");
        dindentf(Depth);
        dprintf("Gateway: Outstanding %d   Lower %d   High %d\n", 
                (ULONG)ReadField(Gateway.Outstanding), 
                (ULONG)ReadField(Gateway.LowWaterMark), 
                (ULONG)ReadField(Gateway.HighWaterMark));
        
        GetFieldOffset("storport!RAID_ADAPTER_EXTENSION", "Miniport", &offset);
        MiniportObject = AdapterExtension + offset;
        InitTypeRead(MiniportObject, storport!RAID_MINIPORT);

        HwInitData = ReadField(HwInitializationData);
        GetFieldOffset("storport!RAID_MINIPORT", "PortConfiguration", &offset);
        
        dindentf(Depth);
        PrintAddress("PortConfigInfo", (MiniportObject + offset));
        dprintf("\n");
        
        dindentf(Depth);
        PrintAddress("HwInit", HwInitData);
        HwDeviceExt = ReadField(PrivateDeviceExt);
        if (!GetFieldOffset("storport!RAID_HW_DEVICE_EXT", "HwDeviceExtension", &offset)) {
            HwDeviceExt = HwDeviceExt + offset;
        }
        else {
            HwDeviceExt = 0;
        }
        PrintAddress("HwDeviceExt", HwDeviceExt);

        InitTypeRead(HwInitData, storport!HW_INITIALIZATION_DATA);
        
        dprintf("(%d bytes)\n", (ULONG)ReadField(DeviceExtensionSize));

        dindentf(Depth);
        dprintf("SrbExt %d bytes   LUExt %d bytes\n", 
                (ULONG)ReadField(SrbExtensionSize), 
                (ULONG)ReadField(SpecificLuExtensionSize));

        dindentf(Depth);
        dprintf("Logical Units: \n");
        dprintf("\n");
        dindentf(Depth);
        dprintf("Product                 SCSI ID  Object    Extension Pnd Out Ct  State\n");
        dindentf(Depth);
        dprintf("----------------------------------------------------------------------------\n");


        
        ListAdapterUnits(AdapterExtension, Level, Depth);

    }
}


VOID
ListGeneral (
    IN ULONG Level,
    IN ULONG Depth,
    IN CHAR Type
    )

{
    ULONG64 address;
    ULONG64 Drivers;
    ULONG64 Adapters;
    ULONG64 PortData;
    ULONG64 NextDriver;
    ULONG64 NextAdapter;
    ULONG64 DriverExtension;
    ULONG64 AdapterExtension;
    ULONG   offset;

    address = GetExpression("storport!RaidpPortData");
    if ((address != 0)) {
        ReadPointer(address, &PortData);
        if (!GetFieldOffset("storport!RAID_PORT_DATA", "DriverList.List", &offset)) {
            Drivers = PortData + offset;
        }
        else {
            dprintf("ERROR: Unable to retrieve Driver List offset\n");
            return;
        }
    }
    else {
        dprintf("ERROR: Unable to lookup RAID_PORT_DATA structure\n");
        return;
    }

    
    for (GetFieldValue(Drivers, "storport!LIST_ENTRY", "Flink", NextDriver); NextDriver != 0 && NextDriver != Drivers; GetFieldValue(NextDriver, "storport!LIST_ENTRY", "Flink", NextDriver)) {
        DriverExtension = ContainingRecord(NextDriver, "storport!RAID_DRIVER_EXTENSION", "DriverLink");

        if (!CheckRaidObject(DriverExtension, RaidDriverObject)) {
            dprintf("ERROR: Not a valid RAID Driver Object\n");
            return;
        }

        if (!GetFieldOffset("storport!RAID_DRIVER_EXTENSION", "AdapterList.List", &offset)) {
            Adapters = DriverExtension + offset;
        }
        else {
            dprintf("ERROR: Unable to retrieve Adapter List offset\n");
            return; 
        }

        if (Type == 'A') {
            dprintf("Driver                 Object    Extension  State\n");
            dprintf("----------------------------------------------------\n");
        }
        else if (Type == 'U') {
            dprintf("Product                 SCSI ID  Object    Extension Pnd Out Ct  State\n");
            dprintf("----------------------------------------------------------------------------\n");
        }

        GetFieldValue(Adapters, 
                      "storport!LIST_ENTRY", 
                      "Flink", 
                      NextAdapter);
        
        //ASSERT(NextAdapter != 0);
                
        while (NextAdapter != 0 && NextAdapter != Adapters) {

            AdapterExtension = ContainingRecord(
                                   NextAdapter,
                                   "storport!RAID_ADAPTER_EXTENSION",
                                   "NextAdapter");
            if (!CheckRaidObject(AdapterExtension, RaidAdapterObject))             {
                dprintf("ERROR: Not a valid RAID Adapter Object\n");
                return;
            }
            
            if (Type == 'A') {
                DumpAdapter(AdapterExtension, Level, Depth);
            }
            else if (Type == 'U') {
                ListAdapterUnits(AdapterExtension, Level, Depth);
            }
            else {
                dprintf("ERROR: Wrong Type\n");
                return;
            }
            
            GetFieldValue(NextAdapter, 
                          "storport!LIST_ENTRY", 
                          "Flink", 
                          NextAdapter);
        }
    }
}


__inline BOOL
GetHelpExpressionEx(
    PCSTR Expression,
    PCSTR* Command
    )
{
    if (Expression[0] != '\0' ) {
        *Command = Expression;
        return TRUE;
    }

    return FALSE;
}


DECLARE_API (help)

{
    PCSTR command;
    
    if(GetHelpExpressionEx(args, &command)) {
        if ((strcmp(command, "adapter") == 0) || (strcmp(command, "Adapter") == 0)) {
            dprintf("\nNAME: \n");
            dprintf("\t!storkd.adapter\n");
            dprintf("\nUSAGE: \n");
            dprintf("\t!adapter [ADAPTER-OBJECT]\n");
            dprintf("\nARGUMENTS: \n");
            dprintf("\tADAPTER-OBJECT - pointer to a device object or an adapter extension\n");
            dprintf("\tfor a given unit.  If no ADAPTER-OBJECT is specified, all STOR adapters\n");
            dprintf("\tused in the system are listed.\n");

            return S_OK;
        }
        else if ((strcmp(command, "unit") == 0) || (strcmp(command, "UNIT") == 0) || (strcmp(command, "Unit") == 0)) {
            dprintf("\nNAME: \n");
            dprintf("\t!storkd.unit\n");
            dprintf("\nUSAGE: \n");
            dprintf("\t!lun [UNIT-OBJECT]\n");
            dprintf("\nARGUMENTS: \n");
            dprintf("\tUNIT-OBJECT - pointer to a device object or an unit extension for a\n");
            dprintf("\tgiven logical unit.  If no UNIT-OBJECT is specified, all STOR logical\n");
            dprintf("\tunits used in the system is listed.\n");

            return S_OK;
        }
        else if ((strcmp(command, "help") == 0) || (strcmp(command, "HELP") == 0) || (strcmp(command, "Help") == 0)) {
            dprintf("\nNAME: \n");
            dprintf("\t!storkd.help\n");
            dprintf("\nUSAGE: \n");
            dprintf("\t!help [COMMAND]\n");
            dprintf("\nARGUMENTS: \n");
            dprintf("\tCOMMAND - command name.\n");

            return S_OK;
        }
        else {
            dprintf ("\nERROR: INVALID COMMAND\n");

            return S_OK;
        }
    }
    else {
        dprintf("\n!adapter               - list all adapters with summary information\n");
        dprintf("!adapter <address>     - provide detailed information about the adapter\n");
        dprintf("                         identified by its device object or device extension\n");
        dprintf("                         address\n");
        dprintf("!unit                  - list all logical units with summary information\n");
        dprintf("!unit <address>        - provide detailed information about the logical unit\n");
        dprintf("                         identified by its device object or device extension\n");
        dprintf("                         address\n");
        dprintf("!help                  - list commands with description\n");
        dprintf("\n");
    
        return S_OK;
    }
}


DECLARE_API (adapter)

{
    ULONG64 address;

    if (GetExpressionEx(args, &address, &args)) {
        DumpAdapter(address, 1, 0);
    }
    else {
        ListGeneral(0, 0, 'A');
    }
    return S_OK;
}


DECLARE_API (unit)

{
    ULONG64 address;

    if (GetExpressionEx(args, &address, &args)) {
        DumpUnit(address, 1, 0);
    }
    else {
        ListGeneral(0, 0, 'U');

    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\class\mcdw2k.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    mcd.h

Abstract:

    These are the structures and defines that are used in the
    changer class drivers. The changer class driver is separated
    into two modules. Mcd.c contains code common to all medium
    changer drivers including the driver's major entry points.

Author:

    chuckp (Chuck Park)

Environment:

    Kernel mode

Revision History :

--*/


#include "scsi.h"
#include "ntddchgr.h"
#include <classpnp.h>

#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
#define DebugPrint(x) MCDebugPrint x
#else
#define DebugPrint(x)
#endif


VOID
MCDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define MAXIMUM_CHANGER_INQUIRY_DATA 252

typedef struct _MODE_ELEMENT_ADDRESS_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransportElementAddress[2];
    UCHAR NumberTransportElements[2];
    UCHAR FirstStorageElementAddress[2];
    UCHAR NumberStorageElements[2];
    UCHAR FirstIEPortElementAddress[2];
    UCHAR NumberIEPortElements[2];
    UCHAR FirstDataXFerElementAddress[2];
    UCHAR NumberDataXFerElements[2];
    UCHAR Reserved2[2];

} MODE_ELEMENT_ADDRESS_PAGE, *PMODE_ELEMENT_ADDRESS_PAGE;

typedef struct _MODE_TRANSPORT_GEOMETRY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR Flip : 1;
    UCHAR Reserved2: 7;
    UCHAR TransportElementNumber;

} MODE_TRANSPORT_GEOMETRY_PAGE, *PMODE_TRANSPORT_GEOMETRY_PAGE;

//
// Capabilities page decribes the various functions that the device
// supports. Used in GetParameters.
//

typedef struct _MODE_DEVICE_CAPABILITIES_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransport : 1;
    UCHAR StorageLocation : 1;
    UCHAR IEPort : 1;
    UCHAR DataXFer : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;
    UCHAR MTtoMT : 1;
    UCHAR MTtoST : 1;
    UCHAR MTtoIE : 1;
    UCHAR MTtoDT : 1;
    UCHAR Reserved4 : 4;
    UCHAR STtoMT : 1;
    UCHAR STtoST : 1;
    UCHAR STtoIE : 1;
    UCHAR STtoDT : 1;
    UCHAR Reserved5 : 4;
    UCHAR IEtoMT : 1;
    UCHAR IEtoST : 1;
    UCHAR IEtoIE : 1;
    UCHAR IEtoDT : 1;
    UCHAR Reserved6 : 4;
    UCHAR DTtoMT : 1;
    UCHAR DTtoST : 1;
    UCHAR DTtoIE : 1;
    UCHAR DTtoDT : 1;
    UCHAR Reserved7 : 4;
    UCHAR Reserved8[4];
    UCHAR XMTtoMT : 1;
    UCHAR XMTtoST : 1;
    UCHAR XMTtoIE : 1;
    UCHAR XMTtoDT : 1;
    UCHAR Reserved9 : 4;
    UCHAR XSTtoMT : 1;
    UCHAR XSTtoST : 1;
    UCHAR XSTtoIE : 1;
    UCHAR XSTtoDT : 1;
    UCHAR Reserved10 : 4;
    UCHAR XIEtoMT : 1;
    UCHAR XIEtoST : 1;
    UCHAR XIEtoIE : 1;
    UCHAR XIEtoDT : 1;
    UCHAR Reserved11 : 4;
    UCHAR XDTtoMT : 1;
    UCHAR XDTtoST : 1;
    UCHAR XDTtoIE : 1;
    UCHAR XDTtoDT : 1;
    UCHAR Reserved12 : 4;

} MODE_DEVICE_CAPABILITIES_PAGE, *PMODE_DEVICE_CAPABILITIES_PAGE;

#define MODE_PAGE_DISPLAY 0x22

//
// Structures describing return data from READ_ELEMENT_STATUS
//

typedef struct _ELEMENT_STATUS_HEADER {
    UCHAR FirstElementAddress[2];
    UCHAR NumberOfElements[2];
    UCHAR Reserved1;
    UCHAR ReportByteCount[3];
} ELEMENT_STATUS_HEADER, *PELEMENT_STATUS_HEADER;

typedef struct _ELEMENT_STATUS_PAGE {
    UCHAR ElementType;
    UCHAR Reserved1 : 6;
    UCHAR AVolTag : 1;
    UCHAR PVolTag : 1;
    UCHAR ElementDescriptorLength[2];
    UCHAR Reserved2;
    UCHAR DescriptorByteCount[3];
} ELEMENT_STATUS_PAGE, *PELEMENT_STATUS_PAGE;


typedef struct _ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
} ELEMENT_DESCRIPTOR, *PELEMENT_DESCRIPTOR;


//
// The following routines are the exported entry points for
// all changer class drivers.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
ChangerClassCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerClassDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOID
ChangerClassAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
ChangerClassFreePool(
    IN PVOID PoolToFree
    );

NTSTATUS
ChangerClassSendSrbSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN WriteToDevice
    );


//
// The following routines are provided by the changer
// device-specific module. Each routine name is
// prefixed with 'Changer.'


ULONG
ChangerAdditionalExtensionSize(
    VOID
    );

BOOLEAN
ChangerVerifyInquiry(
    PINQUIRYDATA InquiryData
    );

NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\class\mcdw2k.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    mcd.c

Abstract:

Environment:

    Kernel mode

Revision History :

--*/

#include "stdarg.h"
#include "ntddk.h"
#include "mcd.h"

#include "initguid.h"
#include "ntddstor.h"

typedef struct _MCD_CLASS_DATA {
    LONG          DeviceOpen;
    UNICODE_STRING MediumChangerInterfaceString;
    BOOLEAN       DosNameCreated;
} MCD_CLASS_DATA, *PMCD_CLASS_DATA;


NTSTATUS
ChangerClassCreateClose (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp
  );

NTSTATUS
ChangerClassDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ChangerClassError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ChangerStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
ChangerInitDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ChangerRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
ChangerUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

NTSTATUS
CreateChangerDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
ClasspSendSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerUnload)
#pragma alloc_text(PAGE, CreateChangerDeviceObject)
#pragma alloc_text(PAGE, ChangerClassCreateClose)
#pragma alloc_text(PAGE, ChangerClassDeviceControl)
#pragma alloc_text(PAGE, ChangerAddDevice)
#pragma alloc_text(PAGE, ChangerStartDevice)
#pragma alloc_text(PAGE, ChangerInitDevice)
#pragma alloc_text(PAGE, ChangerRemoveDevice)
#pragma alloc_text(PAGE, ChangerStopDevice)
#pragma alloc_text(PAGE, ChangerReadWriteVerification)
#endif


NTSTATUS
ChangerClassCreateClose (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp
  )

/*++

Routine Description:

    This routine handles CREATE/CLOSE requests.
    As these are exclusive devices, don't allow multiple opens.

Arguments:

    DeviceObject
    Irp

Return Value:

    NT Status

--*/

{
     PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
     PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
     PMCD_CLASS_DATA    mcdClassData;
     ULONG              miniclassExtSize;
     NTSTATUS           status = STATUS_SUCCESS;

     PAGED_CODE();

     mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);
     miniclassExtSize = ChangerAdditionalExtensionSize();

     //
     // The class library's private data is after the miniclass's.
     //

     (ULONG_PTR)mcdClassData += miniclassExtSize;

     if (irpStack->MajorFunction == IRP_MJ_CLOSE) {
         DebugPrint((3,
                    "ChangerClassCreateClose - IRP_MJ_CLOSE\n"));

         //
         // Indicate that the device is available for others.
         //

         mcdClassData->DeviceOpen = 0;
         status = STATUS_SUCCESS;

     } else if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         DebugPrint((3,
                    "ChangerClassCreateClose - IRP_MJ_CREATE\n"));

         //
         // If already opened, return busy.
         //

         if (mcdClassData->DeviceOpen) {

             DebugPrint((1,
                        "ChangerClassCreateClose - returning DEVICE_BUSY. DeviceOpen - %x\n",
                        mcdClassData->DeviceOpen));

             status = STATUS_DEVICE_BUSY;
         } else {

             //
             // Indicate that the device is busy.
             //

             InterlockedIncrement(&mcdClassData->DeviceOpen);
             status = STATUS_SUCCESS;
         }


     }

     Irp->IoStatus.Status = status;
     ClassReleaseRemoveLock(DeviceObject, Irp);
     ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);

     return status;

} // end ChangerCreate()


NTSTATUS
ChangerClassDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS               status;

    PAGED_CODE();

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CHANGER_GET_PARAMETERS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_PARAMETERS\n"));

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(GET_CHANGER_PARAMETERS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = ChangerGetParameters(DeviceObject, Irp);

            }

            break;

        case IOCTL_CHANGER_GET_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_STATUS\n"));

            status = ChangerGetStatus(DeviceObject, Irp);

            break;

        case IOCTL_CHANGER_GET_PRODUCT_DATA:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_PRODUCT_DATA\n"));

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(CHANGER_PRODUCT_DATA)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = ChangerGetProductData(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_SET_ACCESS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_SET_ACCESS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SET_ACCESS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = ChangerSetAccess(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_GET_ELEMENT_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_ELEMENT_STATUS\n"));


            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_READ_ELEMENT_STATUS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
                ULONG length = readElementStatus->ElementList.NumberOfElements * sizeof(CHANGER_ELEMENT_STATUS);

                //
                // Further validate parameters.
                //

                if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length) {

                    status = STATUS_BUFFER_TOO_SMALL;

                } else if (length == 0) {

                    status = STATUS_INVALID_PARAMETER;

                } else {

                    status = ChangerGetElementStatus(DeviceObject, Irp);
                }

            }

            break;

        case IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = ChangerInitializeElementStatus(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_SET_POSITION:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_SET_POSITION\n"));


            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SET_POSITION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = ChangerSetPosition(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_EXCHANGE_MEDIUM:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_EXCHANGE_MEDIUM\n"));

            status = ChangerExchangeMedium(DeviceObject, Irp);

            break;

        case IOCTL_CHANGER_MOVE_MEDIUM:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_MOVE_MEDIUM\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_MOVE_MEDIUM)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = ChangerMoveMedium(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_REINITIALIZE_TRANSPORT:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_REINITIALIZE_TRANSPORT\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_ELEMENT)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = ChangerReinitializeUnit(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_QUERY_VOLUME_TAGS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_QUERY_VOLUME_TAGS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SEND_VOLUME_TAG_INFORMATION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof(READ_ELEMENT_ADDRESS_INFO)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {
                status = ChangerQueryVolumeTags(DeviceObject, Irp);
            }

            break;

        default:
            DebugPrint((1,
                       "Mcd.ChangerDeviceControl: Unhandled IOCTL\n"));


            //
            // Pass the request to the common device control routine.
            //

            return ClassDeviceControl(DeviceObject, Irp);
            break;
    }

    Irp->IoStatus.Status = status;

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        DebugPrint((1,
                   "Mcd.ChangerDeviceControl: IOCTL %x, status %x\n",
                    irpStack->Parameters.DeviceIoControl.IoControlCode,
                    status));

        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
    }

    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);
    return status;
}


VOID
ChangerClassError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    Final Nt status indicating the results of the operation.

Notes:


--*/

{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIRP irp = Srb->OriginalRequest;

    PAGED_CODE();

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {


        case SCSI_SENSE_ILLEGAL_REQUEST:
        switch (senseBuffer->AdditionalSenseCode) {
            case SCSI_ADSENSE_ILLEGAL_BLOCK:
                if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR ) {

                    DebugPrint((1,
                                "MediumChanger: An operation was attempted on an invalid element\n"));

                    //
                    // Attemped operation to an invalid element.
                    //

                    *Retry = FALSE;
                    *Status = STATUS_ILLEGAL_ELEMENT_ADDRESS;
                }
                break;

            case SCSI_ADSENSE_POSITION_ERROR:

                if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {

                    DebugPrint((1,
                                "MediumChanger: The specified source element has no media\n"));

                    //
                    // The indicated source address has no media.
                    //

                    *Retry = FALSE;
                    *Status = STATUS_SOURCE_ELEMENT_EMPTY;

                } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {

                    DebugPrint((1,
                                "MediumChanger: The specified destination element already has media.\n"));
                    //
                    // The indicated destination already contains media.
                    //

                    *Retry = FALSE;
                    *Status = STATUS_DESTINATION_ELEMENT_FULL;
                }
                break;

            default:
                break;
        }

        default:
            break;

        } // end switch
    }

    //
    // Allow device-specific module to update this.
    //

    ChangerError(DeviceObject, Srb, Status, Retry);
    return;
}



NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - MC class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    PULONG devicesFound = NULL;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the address of the count of the number of tape devices already initialized.
    //

    devicesFound = &IoGetConfigurationInformation()->MediumChangerCount;

    status = CreateChangerDeviceObject(DriverObject,
                                       PhysicalDeviceObject);


    if(NT_SUCCESS(status)) {

        (*devicesFound)++;
    }

    return status;
}



NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine is called after InitDevice, and creates the symbolic link,
    and sets up information in the registry.
    The routine could be called multiple times, in the event of a StopDevice.


Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PINQUIRYDATA            inquiryData = NULL;
    ULONG                   pageLength;
    ULONG                   inquiryLength;
    SCSI_REQUEST_BLOCK      srb;
    PCDB                    cdb;
    NTSTATUS                status;
    PMCD_CLASS_DATA              mcdClassData = (PMCD_CLASS_DATA)fdoExtension->CommonExtension.DriverData;
    ULONG                        miniClassExtSize = ChangerAdditionalExtensionSize();

    PAGED_CODE();

    //
    // Build and send request to get inquiry data.
    //

    inquiryData = ExAllocatePool(NonPagedPoolCacheAligned, MAXIMUM_CHANGER_INQUIRY_DATA);
    if (!inquiryData) {
        //
        // The buffer cannot be allocated.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 2;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = MAXIMUM_CHANGER_INQUIRY_DATA;

    status = ClassSendSrbSynchronous(Fdo,
                                     &srb,
                                     inquiryData,
                                     MAXIMUM_CHANGER_INQUIRY_DATA,
                                     FALSE);


    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        srb.SrbStatus = SRB_STATUS_SUCCESS;
    }

    if (srb.SrbStatus == SRB_STATUS_SUCCESS) {
        inquiryLength = inquiryData->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (inquiryLength > srb.DataTransferLength) {
            inquiryLength = srb.DataTransferLength;
        }
    } else {

        //
        // The class function will only write inquiryLength of inquiryData
        // to the reg. key.
        //

        inquiryLength = 0;
    }

    //
    // Add changer device info to registry
    //

    ClassUpdateInformationInRegistry(Fdo,
                                     "Changer",
                                     fdoExtension->DeviceNumber,
                                     inquiryData,
                                     inquiryLength);

    ExFreePool(inquiryData);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    return STATUS_SUCCESS;
}




#define CHANGER_SRB_LIST_SIZE 2



NTSTATUS
ChangerInitDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will complete the changer initialization.  This includes
    allocating sense info buffers and srb s-lists. Additionally, the miniclass
    driver's init entry points are called.

    This routine will not clean up allocate resources if it fails - that
    is left for device stop/removal

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PVOID                   senseData = NULL;
    NTSTATUS                status;
    PVOID                   minitapeExtension;
    STORAGE_PROPERTY_ID     propertyId;
    UNICODE_STRING          interfaceName;
    PMCD_CLASS_DATA         mcdClassData;

    PAGED_CODE();

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePool(NonPagedPoolCacheAligned,
                               SENSE_BUFFER_SIZE);

    if (senseData == NULL) {

        //
        // The buffer cannot be allocated.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ChangerInitDeviceExit;
    }

    //
    // Build the lookaside list for srb's for the device. Should only
    // need a couple.
    //

    ClassInitializeSrbLookasideList(&(fdoExtension->CommonExtension), CHANGER_SRB_LIST_SIZE);

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    fdoExtension->TimeOutValue = 600;

    //
    // Call port driver to get adapter capabilities.
    //

    propertyId = StorageAdapterProperty;

    status = ClassGetDescriptor(fdoExtension->CommonExtension.LowerDeviceObject,
                                &propertyId,
                                &(fdoExtension->AdapterDescriptor));

    if(!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "ChangerStartDevice: Unable to get adapter descriptor. Status %x\n",
                    status));
        goto ChangerInitDeviceExit;
    }

    //
    // Invoke the device-specific initialization function.
    //

    status = ChangerInitialize(Fdo);

    //
    // Register interfaces for this device.
    //

    RtlInitUnicodeString(&interfaceName, NULL);

    status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                                       (LPGUID) &MediumChangerClassGuid,
                                       NULL,
                                       &interfaceName);

    if(NT_SUCCESS(status)) {
        ULONG miniclassExtSize;

        mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);
        miniclassExtSize = ChangerAdditionalExtensionSize();

        //
        // The class library's private data is after the miniclass's.
        //

        (ULONG_PTR)mcdClassData += miniclassExtSize;

        mcdClassData->MediumChangerInterfaceString = interfaceName;

        status = IoSetDeviceInterfaceState(
                    &interfaceName,
                    TRUE);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1,
                        "ChangerInitDevice: Unable to register Changer%x interface name - %x.\n",
                        fdoExtension->DeviceNumber,
                        status));
            status = STATUS_SUCCESS;
        }
    }

    return status;

    //
    // Fall through and return whatever status the miniclass driver returned.
    //

ChangerInitDeviceExit:

    if (senseData) {
        ExFreePool(senseData);
    }

    return status;

} // End ChangerStartDevice



NTSTATUS
ChangerRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    tape driver.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    none - this routine may not fail

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PMCD_CLASS_DATA              mcdClassData = (PMCD_CLASS_DATA)fdoExtension->CommonExtension.DriverData;
    ULONG                        miniClassExtSize = ChangerAdditionalExtensionSize();
    WCHAR                        dosNameBuffer[64];
    UNICODE_STRING               dosUnicodeString;
    NTSTATUS                     status;

    PAGED_CODE();

    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }

    //
    // Free all allocated memory.
    //

    if (fdoExtension->DeviceDescriptor) {
        ExFreePool(fdoExtension->DeviceDescriptor);
        fdoExtension->DeviceDescriptor = NULL;
    }
    if (fdoExtension->AdapterDescriptor) {
        ExFreePool(fdoExtension->AdapterDescriptor);
        fdoExtension->AdapterDescriptor = NULL;
    }
    if (fdoExtension->SenseData) {
        ExFreePool(fdoExtension->SenseData);
        fdoExtension->SenseData = NULL;
    }

    //
    // Remove the lookaside list.
    //

    ClassDeleteSrbLookasideList(&fdoExtension->CommonExtension);

    (ULONG_PTR)mcdClassData += miniClassExtSize;

    if(mcdClassData->MediumChangerInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(&(mcdClassData->MediumChangerInterfaceString),
                                  FALSE);

        RtlFreeUnicodeString(&(mcdClassData->MediumChangerInterfaceString));

        //
        // Clear it.
        //

        RtlInitUnicodeString(&(mcdClassData->MediumChangerInterfaceString), NULL);
    }

    //
    // Delete the symbolic link "changerN".
    //

    if(mcdClassData->DosNameCreated) {

        swprintf(dosNameBuffer,
                L"\\DosDevices\\Changer%d",
                fdoExtension->DeviceNumber);
        RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);
        IoDeleteSymbolicLink(&dosUnicodeString);
        mcdClassData->DosNameCreated = FALSE;
    }

    //
    // Remove registry bits.
    //

    if(Type == IRP_MN_REMOVE_DEVICE) {
        IoGetConfigurationInformation()->MediumChangerCount--;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is a stub that returns invalid device request.

Arguments:

    DeviceObject - Supplies the device object.

    Irp - Supplies the I/O request packet.

Return Value:

    STATUS_INVALID_DEVICE_REQUEST


--*/

{
    return  STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

--*/

{



    CLASS_INIT_DATA InitializationData;

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);

    InitializationData.FdoData.DeviceExtensionSize = sizeof(FUNCTIONAL_DEVICE_EXTENSION) + ChangerAdditionalExtensionSize() + sizeof(MCD_CLASS_DATA);
    InitializationData.FdoData.DeviceType = FILE_DEVICE_CHANGER;
    InitializationData.FdoData.DeviceCharacteristics = 0;

    //
    // Set entry points
    //

    InitializationData.FdoData.ClassStartDevice = ChangerStartDevice;
    InitializationData.FdoData.ClassInitDevice = ChangerInitDevice;
    InitializationData.FdoData.ClassStopDevice = ChangerStopDevice;
    InitializationData.FdoData.ClassRemoveDevice = ChangerRemoveDevice;
    InitializationData.ClassAddDevice = ChangerAddDevice;

    InitializationData.FdoData.ClassReadWriteVerification = NULL;
    InitializationData.FdoData.ClassDeviceControl = ChangerClassDeviceControl;
    InitializationData.FdoData.ClassError = ChangerClassError;
    InitializationData.FdoData.ClassShutdownFlush = NULL;

    InitializationData.FdoData.ClassCreateClose = ChangerClassCreateClose;

    //
    // Stub routine to make the class driver happy.
    //

    InitializationData.FdoData.ClassReadWriteVerification = ChangerReadWriteVerification;

    InitializationData.ClassUnload = ChangerUnload;


    //
    // Call the class init routine
    //

    return ClassInitialize( DriverObject, RegistryPath, &InitializationData);

}

VOID
ChangerUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    return;
}

NTSTATUS
CreateChangerDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates an object for the device and then searches
    the device for partitions and creates an object for each partition.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PhysicalDeviceObject - DeviceObject of the attached to device.

Return Value:

    NTSTATUS

--*/

{

    PDEVICE_OBJECT lowerDevice;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;
    CCHAR          deviceNameBuffer[64];
    NTSTATUS       status;
    PDEVICE_OBJECT deviceObject;
    ULONG          requiredStackSize;
    PVOID          senseData;
    WCHAR          dosNameBuffer[64];
    WCHAR          wideNameBuffer[64]; 
    UNICODE_STRING dosUnicodeString;
    UNICODE_STRING deviceUnicodeString;
    PMCD_CLASS_DATA mcdClassData;
    ULONG          mcdCount;

    PAGED_CODE();

    DebugPrint((3,"CreateChangerDeviceObject: Enter routine\n"));

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);
    //
    // Claim the device. Note that any errors after this
    // will goto the generic handler, where the device will
    // be released.
    //

    status = ClassClaimDevice(lowerDevice, FALSE);

    if(!NT_SUCCESS(status)) {

        //
        // Someone already had this device.
        //

        ObDereferenceObject(lowerDevice);
        return status;
    }

    //
    // Create device object for this device.
    //
    mcdCount = 0;
    do {
       sprintf(deviceNameBuffer,
               "\\Device\\Changer%d",
               mcdCount);
   
       status = ClassCreateDeviceObject(DriverObject,
                                        deviceNameBuffer,
                                        PhysicalDeviceObject,
                                        TRUE,
                                        &deviceObject);
       mcdCount++;
    } while (status == STATUS_OBJECT_NAME_COLLISION);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"CreateChangerDeviceObjects: Can not create device %s\n",
                    deviceNameBuffer));

        goto CreateChangerDeviceObjectExit;
    }

    //
    // Indicate that IRPs should include MDLs.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system tape number
    //

    fdoExtension->DeviceNumber = mcdCount - 1;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Save the device descriptors
    //

    fdoExtension->AdapterDescriptor = NULL;

    fdoExtension->DeviceDescriptor = NULL;

    //
    // Clear the SrbFlags and disable synchronous transfers
    //

    fdoExtension->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Attach to the PDO
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        //
        // The attach failed. Cleanup and return.
        //

        status = STATUS_UNSUCCESSFUL;
        goto CreateChangerDeviceObjectExit;
    }


    //
    // Create the dos port driver name.
    //

    swprintf(dosNameBuffer,
             L"\\DosDevices\\Changer%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);

    //
    // Recreate the deviceName
    //

    swprintf(wideNameBuffer,
             L"\\Device\\Changer%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&deviceUnicodeString,
                         wideNameBuffer);


    mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);
    (ULONG_PTR)mcdClassData += ChangerAdditionalExtensionSize();
    if (NT_SUCCESS(IoAssignArcName(&dosUnicodeString, &deviceUnicodeString))) {
          mcdClassData->DosNameCreated = TRUE;
    } else {
          mcdClassData->DosNameCreated = FALSE;
    }

    //
    // The device is initialized properly - mark it as such.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    ObDereferenceObject(lowerDevice);

    return(STATUS_SUCCESS);

CreateChangerDeviceObjectExit:

    //
    // Release the device since an error occured.
    //

    // ClassClaimDevice(PortDeviceObject,
    //                      LunInfo,
    //                      TRUE,
    //                      NULL);

    ObDereferenceObject(lowerDevice);

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    return status;


} // end CreateChangerDeviceObject()


NTSTATUS
ChangerClassSendSrbSynchronous(
    IN PDEVICE_OBJECT Fdo,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID BufferAddress,
    IN ULONG BufferLength,
    IN BOOLEAN WriteToDevice
    )
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    IO_STATUS_BLOCK ioStatus;
    ULONG controlType;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT event;
    PUCHAR senseInfoBuffer;
    ULONG retryCount = MAXIMUM_RETRIES;
    NTSTATUS status;
    BOOLEAN retry;

    //
    // NOTE: While this code may look as though it could be pagable,
    //       making it pagable creates the possibility of a page
    //       boundary between IoCallDriver() and ClassReleaseQueue(),
    //       which could leave the queue frozen as we try to page in
    //       this code, which is required to unfreeze the queue.
    //       The result would be a nice case of deadlock.
    //

    ASSERT(fdoExtension->CommonExtension.IsFdo);

    //
    // Write length to SRB.
    //

    Srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set SCSI bus address.
    //

    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // NOTICE:  The SCSI-II specification indicates that this field should be
    // zero; however, some target controllers ignore the logical unit number
    // in the INDENTIFY message and only look at the logical unit number field
    // in the CDB.
    //

    // Srb->Cdb[1] |= deviceExtension->Lun << 5;

    //
    // Enable auto request sense.
    //

    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Sense buffer is in aligned nonpaged pool.
    //

    senseInfoBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                     SENSE_BUFFER_SIZE,
                                     '7CcS');

    if (senseInfoBuffer == NULL) {

        DebugPrint((1, "ClassSendSrbSynchronous: Can't allocate request sense "
                       "buffer\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Srb->SenseInfoBuffer = senseInfoBuffer;
    Srb->DataBuffer = BufferAddress;

    if(BufferAddress != NULL) {
        if(WriteToDevice) {
            Srb->SrbFlags = SRB_FLAGS_DATA_OUT;
        } else {
            Srb->SrbFlags = SRB_FLAGS_DATA_IN;
        }
    } else {
        Srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER;
    }

    //
    // Start retries here.
    //

retry:

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build device I/O control request with METHOD_NEITHER data transfer.
    // We'll queue a completion routine to cleanup the MDL's and such ourself.
    //

    irp = IoAllocateIrp(
            (CCHAR) (fdoExtension->CommonExtension.LowerDeviceObject->StackSize + 1),
            FALSE);

    if(irp == NULL) {
        ExFreePool(senseInfoBuffer);
        DebugPrint((1, "ClassSendSrbSynchronous: Can't allocate Irp\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Get next stack location.
    //

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set up SRB for execute scsi request. Save SRB address in next stack
    // for the port driver.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->Parameters.Scsi.Srb = Srb;

    IoSetCompletionRoutine(irp,
                           ClasspSendSynchronousCompletion,
                           Srb,
                           TRUE,
                           TRUE,
                           TRUE);

    irp->UserIosb = &ioStatus;
    irp->UserEvent = &event;

    if(BufferAddress) {
        //
        // Build an MDL for the data buffer and stick it into the irp.  The
        // completion routine will unlock the pages and free the MDL.
        //

        irp->MdlAddress = IoAllocateMdl( BufferAddress,
                                         BufferLength,
                                         FALSE,
                                         FALSE,
                                         irp );
        if (irp->MdlAddress == NULL) {
            ExFreePool(senseInfoBuffer);
            Srb->SenseInfoBuffer = NULL;
            IoFreeIrp( irp );
            DebugPrint((1, "ClassSendSrbSynchronous: Can't allocate MDL\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        try {
            MmProbeAndLockPages( irp->MdlAddress,
                                 KernelMode,
                                 (WriteToDevice ? IoReadAccess :
                                                  IoWriteAccess));

        } except(EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();

            ExFreePool(senseInfoBuffer);
            Srb->SenseInfoBuffer = NULL;
            IoFreeMdl(irp->MdlAddress);
            IoFreeIrp(irp);

            DebugPrint((1, "ClassSendSrbSynchronous: Exception %lx "
                           "locking buffer\n", status));
            return status;
        }
    }

    //
    // Disable synchronous transfer for these requests.
    //

    SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

    //
    // Set the transfer length.
    //

    Srb->DataTransferLength = BufferLength;

    //
    // Zero out status.
    //

    Srb->ScsiStatus = Srb->SrbStatus = 0;
    Srb->NextSrb = 0;

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = irp;

    //
    // Call the port driver with the request and wait for it to complete.
    //

    status = IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    //
    // Check that request completed without error.
    //

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        ULONG retryInterval;

        //
        // Release the queue if it is frozen.
        //

        if (Srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(Fdo);
        }

        //
        // Update status and determine if request should be retried.
        //

        retry = ClassInterpretSenseInfo(Fdo,
                                        Srb,
                                        IRP_MJ_SCSI,
                                        0,
                                        MAXIMUM_RETRIES  - retryCount,
                                        &status,
                                        &retryInterval);

        if (retry) {

            if ((status == STATUS_DEVICE_NOT_READY &&
                 ((PSENSE_DATA) senseInfoBuffer)->AdditionalSenseCode ==
                                SCSI_ADSENSE_LUN_NOT_READY) ||
                (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_SELECTION_TIMEOUT)) {

                LARGE_INTEGER delay;

                //
                // Delay for at least 2 seconds.
                //

                if(retryInterval < 2) {
                    retryInterval = 2;
                }

                delay.QuadPart = (LONGLONG)( - 10 * 1000 * (LONGLONG)1000 * retryInterval);

                //
                // Stall for a while to let the controller spinup.
                //

                KeDelayExecutionThread(KernelMode, FALSE, &delay);

            }

            //
            // If retries are not exhausted then retry this operation.
            //

            if (retryCount--) {
                goto retry;
            }
        }

    } else {

        status = STATUS_SUCCESS;
    }

    Srb->SenseInfoBuffer = NULL;
    ExFreePool(senseInfoBuffer);
    return status;

}


NTSTATUS
ClasspSendSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This completion routine will set the user event in the irp after
    freeing the irp and the associated MDL (if any).

Arguments:

    DeviceObject - the device object which requested the completion routine

    Irp - the irp being completed

    Context - unused

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    DebugPrint((3, "ClasspSendSynchronousCompletion: %p %p %p\n",
                   DeviceObject, Irp, Context));
    //
    // First set the status and information fields in the io status block
    // provided by the caller.
    //

    *(Irp->UserIosb) = Irp->IoStatus;

    //
    // Unlock the pages for the data buffer.
    //

    if(Irp->MdlAddress) {
        MmUnlockPages(Irp->MdlAddress);
        IoFreeMdl(Irp->MdlAddress);
    }

    //
    // Signal the caller's event.
    //

    KeSetEvent(Irp->UserEvent, IO_NO_INCREMENT, FALSE);

    //
    // Free the MDL and the IRP.
    //

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


PVOID
ChangerClassAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )

{
    return ExAllocatePoolWithTag(PoolType, NumberOfBytes, 'CMcS');
}


VOID
ChangerClassFreePool(
    IN PVOID PoolToFree
    )
{
    ExFreePool(PoolToFree);
}

#if DBG
ULONG MCDebug = 0;
UCHAR DebugBuffer[128];
#endif


#if DBG

VOID
MCDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all medium changer drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= MCDebug) {

        vsprintf(DebugBuffer, DebugMessage, ap);

        DbgPrint(DebugBuffer);
    }

    va_end(ap);

} // end MCDebugPrint()

#else

//
// DebugPrint stub
//

VOID
MCDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\class\mchgr.h ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    mchgr.h

Abstract:

    SCSI Medium Changer class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/
#ifndef _MCHGR_H_
#define _MCHGR_H_

#include "stdarg.h"
#include "ntddk.h"
#include "mcd.h"

#include "initguid.h"
#include "ntddstor.h"

#include <wmidata.h>
#include <wmistr.h>
#include <stdarg.h>

//
// WMI guid list for changer.
//
extern GUIDREGINFO ChangerWmiFdoGuidList[];

//
// Changer class device extension
//
typedef struct _MCD_CLASS_DATA {
    LONG          DeviceOpen;

#if defined(_WIN64)
    //
    // Force PVOID alignment
    //
    ULONG_PTR Reserved;
#endif

    UNICODE_STRING MediumChangerInterfaceString;

    BOOLEAN       DosNameCreated;

} MCD_CLASS_DATA, *PMCD_CLASS_DATA;


NTSTATUS
ChangerClassCreateClose (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp
  );

NTSTATUS
ChangerClassDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ChangerClassError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ChangerStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
ChangerInitDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ChangerRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
ChangerUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

NTSTATUS
CreateChangerDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
ChangerReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// WMI routines
//
NTSTATUS
ChangerFdoQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    );

NTSTATUS
ChangerFdoQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
ChangerFdoSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
ChangerFdoSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
ChangerFdoExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
ChangerWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    );

#endif // _MCHGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\class\mcdwmi.c ===
/*++ 
Copyright (C) Microsoft Corporation, 1999

Module Name:

    mcdwmi.c

Abstract:

    This is the changer class driver - WMI support routines.

Environment:

    kernel mode only

Revision History:

--*/
#include "mchgr.h"

//
// Internal routines
//
NTSTATUS
ChangerWMIGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PGET_CHANGER_PARAMETERS changerParameters
    );

//
// List of WMI GUIDs 
//
GUIDREGINFO ChangerWmiFdoGuidList[] =
{
   {
      WMI_CHANGER_PARAMETERS_GUID,
      1,
      0
   },

   {
      WMI_CHANGER_PROBLEM_WARNING_GUID,
      1,
      WMIREG_FLAG_EVENT_ONLY_GUID
   },

   {
      WMI_CHANGER_PROBLEM_DEVICE_ERROR_GUID,
      1,
      WMIREG_FLAG_EXPENSIVE
   },
};

GUID ChangerDriveProblemEventGuid = WMI_CHANGER_PROBLEM_WARNING_GUID;

//
// GUID index. It should match the list defined above
//
#define ChangerParametersGuid           0
#define ChangerProblemWarningGuid       1
#define ChangerProblemDevErrorGuid      2

//
// ISSUE: 02/29/2000 - nramas : Should make wmi routines pagable
//
/*
#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, 

#endif
*/

NTSTATUS
ChangerFdoQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.


Return Value:

    status

--*/
{
   //
   // Use devnode for FDOs
   //
   *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
   return STATUS_SUCCESS;
}

NTSTATUS
ChangerFdoQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
   PMCD_INIT_DATA mcdInitData;
   ULONG sizeNeeded = 0;
   
   switch (GuidIndex) {
      case ChangerParametersGuid: {
         GET_CHANGER_PARAMETERS changerParameters;
         PWMI_CHANGER_PARAMETERS outBuffer;

         sizeNeeded = sizeof(WMI_CHANGER_PARAMETERS);
         if (BufferAvail < sizeNeeded) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }
         
         status = ChangerWMIGetParameters(DeviceObject,
                                          &changerParameters);
         if (NT_SUCCESS(status)) {
            outBuffer = (PWMI_CHANGER_PARAMETERS)Buffer;
            outBuffer->NumberOfSlots = changerParameters.NumberStorageElements;
            outBuffer->NumberOfDrives = changerParameters.NumberDataTransferElements;
            outBuffer->NumberOfIEPorts = changerParameters.NumberIEElements;
            outBuffer->NumberOfTransports = changerParameters.NumberTransportElements;
            outBuffer->NumberOfDoors = changerParameters.NumberOfDoors;
            outBuffer->MagazineSize = changerParameters.MagazineSize;
            outBuffer->NumberOfCleanerSlots = changerParameters.NumberCleanerSlots;
         }

         break;
      }

      case ChangerProblemDevErrorGuid: {
         PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError;

         mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                                  ChangerClassInitialize);

         if (mcdInitData == NULL) {
             status = STATUS_NO_SUCH_DEVICE;
             break;
         }

         if (!(mcdInitData->ChangerPerformDiagnostics)) {
             status = STATUS_NOT_IMPLEMENTED;
             break;
         }

         sizeNeeded = sizeof(WMI_CHANGER_PROBLEM_DEVICE_ERROR);
         if (BufferAvail < sizeNeeded) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         changerDeviceError = (PWMI_CHANGER_PROBLEM_DEVICE_ERROR)Buffer;
         RtlZeroMemory(changerDeviceError, 
                       sizeof(WMI_CHANGER_PROBLEM_DEVICE_ERROR));
         status = mcdInitData->ChangerPerformDiagnostics(DeviceObject,
                                                         changerDeviceError);
         break;
      }

      default: {
         sizeNeeded = 0;
         status = STATUS_WMI_GUID_NOT_FOUND;
         break;
      }
   } // switch (GuidIndex)

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    sizeNeeded,
                                    IO_NO_INCREMENT);

   return status;
}


NTSTATUS
ChangerWMIGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PGET_CHANGER_PARAMETERS changerParameters
    )
/*+++

Routine Description: 
   Sends the IOCTL to get the changer parameters
   
Arguments :

   DeviceObject The changer device objcet
   ChangerParameters buffer in which the changer parameters is returned.
   
Return value:

   NT Status.
--*/
{
   KEVENT event;
   PDEVICE_OBJECT topOfStack;
   PIRP irp = NULL;
   IO_STATUS_BLOCK ioStatus;
   NTSTATUS status;

   KeInitializeEvent(&event, SynchronizationEvent, FALSE);

   topOfStack = IoGetAttachedDeviceReference(DeviceObject);

   //
   // Send down irp to get the changer parameters
   //
   irp = IoBuildDeviceIoControlRequest(
                   IOCTL_CHANGER_GET_PARAMETERS,
                   topOfStack,
                   NULL,
                   0,
                   changerParameters,
                   sizeof(GET_CHANGER_PARAMETERS),
                   FALSE,
                   &event,
                   &ioStatus);
   if (irp != NULL) { 
       status = IoCallDriver(topOfStack, irp);
       if (status == STATUS_PENDING) {
           KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
           status = ioStatus.Status;
       }
   } else {
       status = STATUS_INSUFFICIENT_RESOURCES;
   }

   ObDereferenceObject(topOfStack);
   return status;
}

NTSTATUS
ChangerWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

    This function can be used to enable\disable datablock collection. 

Arguments:

    DeviceObject is the device whose data block is being queried

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
   NTSTATUS status;

   if (Function == DataBlockCollection) {
      DebugPrint((3,
                  "ChangerWmiFunctionControl : Irp %p - %s DataBlockCollection",
                  " for Device %p.\n",
                  Irp, Enable ? "Enable " : "Disable ", DeviceObject));
      status = STATUS_SUCCESS;
   } else {
       //
       // ISSUE: 03/01/2000 - nramas
       // Need to handle EventGeneration. But now we don't do polling
       // of the changers to detect failure. So, for now disallow
       // EventGeneration
       //
      DebugPrint((1,
                  "ChangerWmiFunctionControl : Unknown function %d for ",
                  "Device %p, Irp %p\n",
                  Function, DeviceObject, Irp));

      status = STATUS_INVALID_DEVICE_REQUEST;
   }

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    0,
                                    IO_NO_INCREMENT);
   return status;
}

NTSTATUS
ChangerFdoExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the returned data block


Return Value:

    status

--*/
{   
   NTSTATUS status = STATUS_SUCCESS;


   DebugPrint((3,
               "ChangerFdoExecuteMethod : Device %p, Irp %p, ",
               "GuidIndex %d\n",
               DeviceObject, Irp, GuidIndex));

   if (GuidIndex > ChangerProblemDevErrorGuid) {
      status = STATUS_WMI_GUID_NOT_FOUND;
   }

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    0,
                                    IO_NO_INCREMENT);

   return status;
}

NTSTATUS
ChangerFdoSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*+

Routine Description :

   This routine is called to set the contents of a datablock.
   When the driver is finished setting the buffer, it must call
   ClassWmiCompleteRequest to complete the irp. The driver can
   return STATUS_PENDING if the irp cannot be completed immediately.

Arguments :

   Device object of the device being referred.

   Irp is the WMI Irp

   GuidIndex is the index of the guid for which the data is being set

   BufferSize is the size of the data block

   Buffer is the pointer to the data block

Return valus :

   NTSTATUS returned by ClassWmiCompleteRequest
   STATUS_WMI_READ_ONLY if the datablock cannot be modified.
   STATUS_WMI_GUID_NOT_FOUND if an invalid guid index is passed
-*/
{
   NTSTATUS status = STATUS_WMI_READ_ONLY;

   DebugPrint((3,
               "ChangerWmiSetBlock : Device %p, Irp %p, ",
               "GuidIndex %d\n",
               DeviceObject, Irp, GuidIndex));

   if (GuidIndex > ChangerProblemDevErrorGuid) {
      status = STATUS_WMI_GUID_NOT_FOUND;
   }

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    0,
                                    IO_NO_INCREMENT);

   DebugPrint((3, "ChangerSetWmiDataBlock : Device %p, Irp %p, returns %x\n",
               DeviceObject, Irp, status));
   return status;
}

NTSTATUS
ChangerFdoSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

   NTSTATUS returned by ClassWmiCompleteRequest
   STATUS_WMI_READ_ONLY if the datablock cannot be modified.
   STATUS_WMI_GUID_NOT_FOUND if an invalid guid index is passed

-*/
{
    NTSTATUS status = STATUS_WMI_READ_ONLY;

    DebugPrint((3,
                "TapeSetWmiDataItem, Device %p, Irp %p, GuiIndex %d",
                "  BufferSize %#x Buffer %p\n",
                DeviceObject, Irp,
                GuidIndex, DataItemId,
                BufferSize, Buffer));

    if (GuidIndex > ChangerProblemDevErrorGuid) {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    DebugPrint((3, "TapeSetWmiDataItem Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\adicsc\adicsc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    adicsc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _ADIC_MC_
#define _ADIC_MC_

typedef struct _ADICS_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;                      // true for drives only
    UCHAR Reserved6 : 1;                // true for drives only
    UCHAR LunValid : 1;                 // true for drives only
    UCHAR IdValid : 1;                  // true for drives only
    UCHAR Reserved7 : 1;                // true for drives only
    UCHAR NotThisBus : 1;               // true for drives only
    UCHAR BusAddress;                   // true for drives only
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} ADICS_ELEMENT_DESCRIPTOR, *PADICS_ELEMENT_DESCRIPTOR;

typedef struct _ADICS_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];

    union {

        struct {
            UCHAR VolumeTagInformation[36];
            UCHAR CodeSet : 4;
            UCHAR Reserved10 : 4;
            UCHAR IdType : 4;
            UCHAR Reserved11: 4;
            UCHAR Reserved12;
            UCHAR IdLength;
            UCHAR Identifier[64];
        } VolumeTagDeviceID;

        struct {
            UCHAR CodeSet : 4;
            UCHAR Reserved10 : 4;
            UCHAR IdType : 4;
            UCHAR Reserved11: 4;
            UCHAR Reserved12;
            UCHAR IdLength;
            UCHAR Identifier[64];
        } DeviceID;

    };

} ADICS_ELEMENT_DESCRIPTOR_PLUS, *PADICS_ELEMENT_DESCRIPTOR_PLUS;


#define ADIC_NO_ELEMENT 0xFFFF

#define ADIC_SCALAR     1
#define ADIC_FASTSTOR   2
#define ADIC_SCALAR_448 3
#define UHDL            4

//
// Diagnostic related defines
//
// Device Status codes
//
#define ADICSC_DEVICE_PROBLEM_NONE     0x00
#define ADICSC_HW_ERROR                0x01

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device status after Send Diagnostic
    //
    ULONG DeviceStatus;

    //
    // Flag to indicate whether or not the driver
    // should attempt to retrieve Device Identifier
    // info (serialnumber, etc). Not all devices
    // support this
    //
    BOOLEAN ObtainDeviceIdentifier;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;

//
// Internal routines to adicsc
//
NTSTATUS
AdicBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PADICS_ELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\adicvls\adicvls.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    adicvls.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _ADICVLS_MC_
#define _ADICVLS_MC_

typedef struct _ADICVLS_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} ADICVLS_ELEMENT_DESCRIPTOR, *PADICVLS_ELEMENT_DESCRIPTOR;

#define ADIC_NO_ELEMENT 0xFFFF


typedef struct _ADIC_SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
    UCHAR VendorStatus[3];
    UCHAR MagazinePosition;
} ADIC_SENSE_DATA, *PADIC_SENSE_DATA;

//
// Bit defs for Vendor status
//

#define SENSOR_BEAM_BLOCKED 0x4

#define ADIC_SENSE_LENGTH 22

//
// Diagnostic related defines
//
// ASC
//
#define ADICVLS_ASC_CHM_ERROR          0x15
#define ADICVLS_ASC_DIAGNOSTIC_ERROR   0x40

//
// ASCQ
//
#define ADICVLS_ASCQ_DOOR_OPEN                0x88
#define ADICVLS_ASCQ_GRIPPER_ERROR            0x91
#define ADICVLS_ASCQ_GRIPPER_MOVE_ERROR       0x92
#define ADICVLS_ASCQ_CHM_MOVE_SHORT_AXIS      0xA0
#define ADICVLS_ASCQ_CHM_SHORT_HOME_POSITION  0xA1
#define ADICVLS_ASCQ_CHM_DEST_SHORT_AXIS      0xA5
#define ADICVLS_ASCQ_CHM_MOVE_LONG_AXIS       0xB0
#define ADICVLS_ASCQ_CHM_LONG_HOME_POSITION   0xB1
#define ADICVLS_ASCQ_CHM_DEST_LONG_AXIS       0xB5
#define ADICVLS_ASCQ_DRUM_MOVE_ERROR          0xC0
#define ADICVLS_ASCQ_DRUM_HOME_ERROR          0xC1
#define ADICVLS_ASCQ_CHM_DEST_LONG            0xE5
#define ADICVLS_ASCQ_CHM_SHORT_AXIS_MOVE      0xF1

//
// DeviceStatus
//
#define ADICVLS_DEVICE_PROBLEM_NONE      0x00
#define ADICVLS_HW_ERROR                 0x01
#define ADICVLS_CHM_ERROR                0x02
#define ADICVLS_CHM_MOVE_ERROR           0x03
#define ADICVLS_GRIPPER_ERROR            0x04
#define ADICVLS_DOOR_OPEN                0x05


#define ADIC_1200       1               // 1-drive model
#define ADIC_VLS    2           // 2-drive model (except for DLT)

#define ADIC_4mm            1
#define ADIC_8mm_EXB    2
#define ADIC_8mm_SONY   3
#define ADIC_DLT            4

#define SCSIOP_ADIC_ALIGN_ELEMENTS 0xE5

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Device Status after diagnostic send completes
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    PVOID Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
AdicvlsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

PADIC_SENSE_DATA
InternalSendRequestSense(
    IN PDEVICE_OBJECT DeviceObject
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\atl\atlmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    atlmc.h

Abstract:

Authors:

    davet (Dave Therrien)

Revision History:

--*/
#ifndef _ATL_MC_
#define _ATL_MC_

#define ATL_DEVICE_CAP_EXTENSION                4

typedef union _ATL_ED {

    struct _ATL_FED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
        UCHAR DriveSerialNumber[20];
        UCHAR Reserved9[12];
    } ATL_FED, *PATL_FED;

    struct _ATL_PED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[6];
    } ATL_PED, *PATL_PED;

} ATL_ED, *PATL_ED;

#define ATL_PARTIAL_SIZE sizeof(struct _ATL_PED)
#define ATL_FULL_SIZE sizeof(struct _ATL_FED)

#define ATL_DISPLAY_LINES        4
#define ATL_DISPLAY_LINE_LENGTH  20

// Vendor Unique Mode Page 0

typedef struct _PAGE0_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR Reserved2 : 4;
    UCHAR NBL : 1;
    UCHAR Reserved3 : 2;
    UCHAR AInit : 1;
    UCHAR MaxParityRetries;
    UCHAR DisplayLine[ATL_DISPLAY_LINES][ATL_DISPLAY_LINE_LENGTH];
} PAGE0_MODE_PAGE, *PPAGE0_MODE_PAGE;


// Vendor Unique Mode Page 20 

typedef struct _PAGE20_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR Reserved2 : 1;
    UCHAR AC : 1;
    UCHAR Reserved3 : 6;
    UCHAR EXB : 1;
    UCHAR Reserved4 : 7;
} PAGE20_MODE_PAGE, *PPAGE20_MODE_PAGE;


#define ATL_NO_ELEMENT 0xFFFF

//
// Diagnostic test related defines
//
// ASC
#define ATL_ASC_HW_ERROR            0x80
#define ATL_ASC_GRIPPER_ERROR       0x81
#define ATL_ASC_VERTICAL_ERROR      0x84
#define ATL_ASC_HORIZONTAL_ERROR    0x85
#define ATL_ASC_LOAD_PORT           0x8C
#define ATL_ASC_DLT_DRIVE           0xF3

//
// ASCQ
//
#define ATL_ASCQ_GRIPPER_BLOCKED        0x50
#define ATL_ASCQ_PICK_ERROR             0x51 
#define ATL_ASCQ_POSITION_ERROR         0x03
#define ATL_ASCQ_HOME_NOT_FOUND         0x08
#define ATL_ASCQ_LOAD_PORT_DOOR_OPEN    0x06
#define ATL_ASCQ_DLT_DRIVE_TIMEOUT      0x02

//
// DeviceStatus codes
//
#define ATL_DEVICE_PROBLEM_NONE         0x00
#define ATL_HW_ERROR                    0x01
#define ATL_CHM_ERROR                   0x02
#define ATL_DOOR_OPEN                   0x03


#define ATL_520        1
#define ATL_7100       2
#define ATL_P1000      3

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device Status after diagnostic test is performed
    //
    ULONG DeviceStatus; 

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PATL_ED ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _ATL_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\atl\atlmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    atlmc.c

Abstract:

    This module contains device-specific routines for the following
    ATL medium changers: 
            - ATL 520 and 7100 Series Libraries

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "atlmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}




NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                                sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Now get the full inquiry information for the device.

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.TimeOutValue = 10;
    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;
    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength +
                             FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        if (RtlCompareMemory(dataBuffer->ProductId,"ACL4/52",7) == 7) {
            changerData->DriveID = ATL_520;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TL810",5) == 5) {
            changerData->DriveID = ATL_520;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TL812",5) == 5) {
            changerData->DriveID = ATL_520;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TL894",5) == 5) {
            changerData->DriveID = ATL_520;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"ATL7100",7) == 7) {
            changerData->DriveID = ATL_7100;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"P1000",5) == 5) {
            changerData->DriveID = ATL_P1000;
        }
    }

    ChangerClassFreePool(dataBuffer);

    // in case the unit is not set to AutoInventory, do one here !
/*
    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb.Cdb;

    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.TimeOutValue = fdoExtension->TimeOutValue;
    srb.DataTransferLength = 0;

    cdb->INIT_ELEMENT_STATUS.OperationCode = 
                                        SCSIOP_INIT_ELEMENT_STATUS;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);
*/
    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    ULONG deviceStatus;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:
           if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x3:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                    default:
                        break;
                }
           }
           if (senseBuffer->AdditionalSenseCode == 0x80) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x0:
                    case 0x7:
                    case 0x9:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                    default:
                        break;
                }
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           UCHAR atlASC = senseBuffer->AdditionalSenseCode;
           UCHAR atlASCQ = senseBuffer->AdditionalSenseCodeQualifier;

           deviceStatus = ATL_HW_ERROR;
           
           switch (atlASC) {
            case ATL_ASC_HW_ERROR: {
               deviceStatus = ATL_HW_ERROR;
               break;
            }

            case ATL_ASC_GRIPPER_ERROR: {
               if ((atlASCQ == ATL_ASCQ_GRIPPER_BLOCKED) ||
                   (atlASCQ == ATL_ASCQ_PICK_ERROR)) {
                  deviceStatus = ATL_CHM_ERROR;
               } else {
                  deviceStatus = ATL_HW_ERROR;
               }
               break;
            }

            case ATL_ASC_VERTICAL_ERROR: 
            case ATL_ASC_HORIZONTAL_ERROR: {
               switch (atlASCQ) {
                  case ATL_ASCQ_POSITION_ERROR:
                  case ATL_ASCQ_HOME_NOT_FOUND: {
                     deviceStatus = ATL_CHM_ERROR;
                     break;
                  }

                  default: {
                     deviceStatus = ATL_HW_ERROR;
                     break;
                  }
               } // switch (atlASCQ)
               break;
            }

            case ATL_ASC_LOAD_PORT: {
               if ((atlASCQ == ATL_ASCQ_LOAD_PORT_DOOR_OPEN) ||
                   (atlASCQ == ATL_ASCQ_HOME_NOT_FOUND)) {
                  *Retry = FALSE;
                  *Status = STATUS_DEVICE_DOOR_OPEN;
                  deviceStatus = ATL_DOOR_OPEN;
               }
               break;
            }

            case ATL_ASC_DLT_DRIVE: {
               if (atlASCQ == ATL_ASCQ_DLT_DRIVE_TIMEOUT) {
                  *Retry = FALSE;
                  *Status = STATUS_DEVICE_NOT_CONNECTED;
                  deviceStatus = ATL_HW_ERROR;
               }
            }

            default: {
               deviceStatus = ATL_HW_ERROR;
               break;
            }
           } // switch (atlASC)

           changerData->DeviceStatus = deviceStatus;
           break;
        } // case SCSI_SENSE_HARDWARE_ERROR

        default:
            break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1D - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //
    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = 
                 elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= 
                 (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = 
                 elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= 
                 (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = 
                 elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= 
                 (elementAddressPage->NumberIEPortElements[0] << 8);
    
    changerParameters->NumberDataTransferElements = 
                 elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= 
                 (elementAddressPage->NumberDataXFerElements[0] << 8);

    changerParameters->NumberOfDoors = 1;

    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 0;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    changerParameters->MagazineSize = 0; 
    // clean timeout changed from 600 to 300 seconds to 
    // reduce overall clean time from 16 minutes to 11 minutes. 
    changerParameters->DriveCleanTimeout = 300;

    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1E - transport geometry mode sense.

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                             sizeof(MODE_PARAMETER_HEADER) +
                             sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // initialize Features1  
    //
    changerParameters->Features1 = 0;

    if (changerData->DriveID != ATL_P1000) {
        changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_OPEN |
                                       CHANGER_IEPORT_USER_CONTROL_CLOSE ;
    }

        // initialize Features0 and then set flip bit...
    changerParameters->Features0 = 
             transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;
 

    // Features based on manual, nothing programatic.
    changerParameters->Features0 |= 
               CHANGER_BAR_CODE_SCANNER_INSTALLED    |
               CHANGER_INIT_ELEM_STAT_WITH_RANGE     |
               CHANGER_STATUS_NON_VOLATILE           | 
               CHANGER_LOCK_UNLOCK                   | 
               CHANGER_POSITION_TO_ELEMENT           |
               CHANGER_REPORT_IEPORT_STATE           |
               CHANGER_PREDISMOUNT_EJECT_REQUIRED    | 
               CHANGER_CLEANER_ACCESS_NOT_VALID      |
               CHANGER_DRIVE_CLEANING_REQUIRED;

    //
    // Keypad, door, and IEPort cannot be locked for P1000
    //
    if (changerData->DriveID == ATL_P1000) {
        changerParameters->LockUnlockCapabilities = 0;
        changerParameters->Features0 &= ~CHANGER_LOCK_UNLOCK;
    } else {
        // door and keypad cannot be locked, only the IEPORT
        changerParameters->LockUnlockCapabilities = 
                    LOCK_UNLOCK_IEPORT;
    }

    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1F - Device Capabilities Page

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // ATL uses an addition 4 bytes past the scsi-defined structure.
    //

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE) + 
              ATL_DEVICE_CAP_EXTENSION;


    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    // Fill in values in Features that are contained in this page.

    changerParameters->Features0 |= 
     capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    // Determine all the move from and exchange from 
    // capabilities of this device.

    changerParameters->MoveFromTransport = 
     capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = 
     capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = 
     capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    // changerParameters->MoveFromIePort |= 
    //  capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = 
     capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    // changerParameters->MoveFromDrive |= 0;
    //  capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 
     capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = 
     capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = 
     capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = 
     capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;


        // legal Position capabilities... 
        changerParameters->PositionCapabilities = 0;
        //              CHANGER_TO_SLOT | 
        //              CHANGER_TO_IEPORT | 
        //              CHANGER_TO_DRIVE;
                

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    // Copy cached inquiry data fields into the system buffer.
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, 
                  VENDOR_ID_LENGTH);

    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, 
                  PRODUCT_ID_LENGTH);

    RtlMoveMemory(productData->Revision, 
                  changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door or IEPort. 

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;

    if (changerData->DriveID == ATL_P1000) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ((setAccess->Element.ElementType == ChangerKeypad) || 
                (setAccess->Element.ElementType == ChangerDoor)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (setAccess->Element.ElementType == ChangerIEPort) {

        // Do Prevent/Allow Medium  Removal... 
        srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
        if (!srb) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

        srb->DataBuffer = NULL;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;

        if (controlOperation == LOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 1;
        } else if (controlOperation == UNLOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 0;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
       return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command 
    for either all elements or the
    specified element type. The buffer returned is used to build 
    the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    NTSTATUS status;
    PVOID    statusBuffer;

    // Get the element type.
    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {
        statusPages = 4;
    } else {
        statusPages = 1;
    } 

    if ((readElementStatus->VolumeTagInfo) ||
        (elementType == ChangerDrive)) {
        length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
            (ATL_FULL_SIZE * 
                readElementStatus->ElementList.NumberOfElements);
    } else {
        length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
            (ATL_PARTIAL_SIZE * 
                readElementStatus->ElementList.NumberOfElements);
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] =         
        (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] =         
        (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] =
                                      (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] =
                                      (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] =
                                      (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {
        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PATL_ED elementDescriptor;
        ULONG numberElements = 
             readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        // Determine total number elements returned.
        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        // The buffer is composed of a header, status page, 
        // and element descriptors.
        // Point each element to it's respective place in the buffer.

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = 
           statusPage->ElementDescriptorLength[1];
        descriptorLength |= 
           (statusPage->ElementDescriptorLength[0] << 8);

        // Determine the number of elements of this type reported.
        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        // Fill in user buffer.
        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {
            for (i = 0; i < typeCount; i++, remainingElements--) {

                // Get the address for this element.

                elementStatus->Element.ElementAddress =
                 elementDescriptor->ATL_FED.ElementAddress[1];

                elementStatus->Element.ElementAddress |=
                  (elementDescriptor->ATL_FED.ElementAddress[0] << 8);

                // Account for address mapping.
                elementStatus->Element.ElementAddress -= 
                   addressMapping->FirstElement[elementType];

                // Set the element type.
                elementStatus->Element.ElementType = elementType;

                if (elementDescriptor->ATL_FED.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    // Source address is valid. 
                    // Determine the device specific address.
                    tmpAddress = elementDescriptor->ATL_FED.SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->ATL_FED.SourceStorageElementAddress[0] << 8);

                    // Now convert to 0-based values.
                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress =
                         tmpAddress - addressMapping->FirstElement[j];

                }

                // Build Flags field.

                elementStatus->Flags = 
                 elementDescriptor->ATL_FED.Full;
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.Exception << 2);
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.Accessible << 3);

                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.LunValid << 12);
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.IdValid << 13);
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.NotThisBus << 15);

                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.Invert << 22);
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.SValid << 23);


                elementStatus->ExceptionCode = 
                 MapExceptionCodes(elementDescriptor);

                if (elementDescriptor->ATL_FED.IdValid) {
                    elementStatus->TargetId = 
                     elementDescriptor->ATL_FED.BusAddress;
                }
                if (elementDescriptor->ATL_FED.LunValid) {
                    elementStatus->Lun = elementDescriptor->ATL_FED.Lun;
                }

                //if (tagInfo) {
                //   RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                //        elementDescriptor->ATL_FED.PrimaryVolumeTag, 
                //        MAX_VOLUME_ID_SIZE);
                //    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                //}


                if (tagInfo) {
                    if (statusPage->PVolTag) {

                        ULONG tagIndex;

                        //
                        // ATL returns 32 " " + 4 NULL characters if missing label
                        //

                        for (tagIndex = 0; tagIndex < 36; tagIndex++) {
                            if (elementDescriptor->ATL_FED.PrimaryVolumeTag[tagIndex] != ' ') { 
                                break;
                            }
                        }
                        if (tagIndex == 32) {

                            elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                            elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;

                        } else {
                            RtlMoveMemory(elementStatus->PrimaryVolumeID,elementDescriptor->ATL_FED.PrimaryVolumeTag,
                                          MAX_VOLUME_ID_SIZE);

                            elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                        }

                    } 
                }

                if ((statusPage->AVolTag) &&
                    (elementType == ChangerDrive)) {
                    //
                    // ATL P Series libraries return drive 
                    // serialnumber for ReadElementStatus 
                    // for drives, and set AVolTag bit
                    //
                    if (outputBuffLen >=
                        (numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {

                        PCHANGER_ELEMENT_STATUS_EX   elementStatusEx;

                        elementStatusEx = (PCHANGER_ELEMENT_STATUS_EX)elementStatus;

                        //
                        // NOTE here that ATL devices provide
                        // only drive serialnumbers. They do not
                        // provide vendorid, and product id here
                        //
                        RtlMoveMemory(elementStatusEx->SerialNumber,
                                      elementDescriptor->ATL_FED.DriveSerialNumber,
                                      20);
                        elementStatusEx->Flags |= ELEMENT_STATUS_PRODUCT_DATA;

                    }
                }

                // Get next descriptor.
                (ULONG_PTR)elementDescriptor += descriptorLength;

                // Advance to the next entry in the user 
                // buffer and element descriptor array.

                if (outputBuffLen >=
                    (numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
                    DebugPrint((3,
                                "Incrementing by sizeof(CHANGER_ELEMENT_STATUS_EX\n"));
                    (PUCHAR)elementStatus += sizeof(CHANGER_ELEMENT_STATUS_EX);
                } else {
                    elementStatus += 1;
                }
            }

            if (remainingElements > 0) {
                // Get next status page.
                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;
                elementType = statusPage->ElementType;

                // Point to decriptors.
                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = 
                   statusPage->ElementDescriptorLength[1];
                descriptorLength |= 
                   (statusPage->ElementDescriptorLength[0] << 8);

                // Determine the number of this element type reported.
                typeCount = statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);
                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        if (outputBuffLen >=
            (numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
            Irp->IoStatus.Information = numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX);
        } else {
            Irp->IoStatus.Information = numberElements * sizeof(CHANGER_ELEMENT_STATUS);
        }

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either 
    initialize all elements or the specified range of elements 
    using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

        cdb->INIT_ELEMENT_STATUS.OperationCode = 
                                            SCSIOP_INIT_ELEMENT_STATUS;

        cdb->INIT_ELEMENT_STATUS.NoBarCode = 
                            initElementStatus->BarCodeScan ? 0 : 1;
    } else {
        PCHANGER_ELEMENT_LIST elementList = 
                    &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = 
                    &elementList->Element;

        srb->CdbLength = CDB10GENERIC_LENGTH;
        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = 
                                     SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        //
        // Addresses of elements need to be mapped from 
        // 0-based to device-specific.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
            (UCHAR)((element->ElementAddress + 
            addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
            (UCHAR)((element->ElementAddress + 
            addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] =
            (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = 
            (UCHAR)(elementList->NumberOfElements & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = 
                               initElementStatus->BarCodeScan ? 0 : 1;

    }

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 
                          sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the 
    robotic mechanism to the specified
    element address. Normally used to optimize moves or 
    exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    return STATUS_INVALID_DEVICE_REQUEST;

/*
    if ((setPosition->Destination.ElementType == ChangerKeypad) ||
        (setPosition->Destination.ElementType == ChangerDoor)) {
        return STATUS_INVALID_PARAMETER;
    }


         

    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    // Convert to device addresses.

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += 
     addressMapping->FirstElement[setPosition->Destination.ElementType];

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    // Build srb and cdb.

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    // Build device-specific addressing.

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] =
                    (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = 
                    (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = 
                    (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = 
                    (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;

*/
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;
   // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 
      (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 
      (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = 
      (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = 
      (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 
      (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 
      (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;

    // Do Rezero Unit ... 
    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_REZERO_UNIT;

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }
    return status;
}




NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = ATL_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = 
         (elementAddressPage->MediumTransportElementAddress[0] << 8) |
         elementAddressPage->MediumTransportElementAddress[1];

        addressMapping->FirstElement[ChangerDrive] = 
         (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
         elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = 
         (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
         elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = 
         (elementAddressPage->FirstStorageElementAddress[0] << 8) |
         elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = 
         elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= 
         (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = 
         elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= 
         (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = 
         elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= 
         (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = 
         elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= 
         (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;
    }


    // Determine the lowest element address for use with AllElements.
    //
    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < 
                         addressMapping->FirstElement[AllElements]) {
            addressMapping->FirstElement[AllElements] = 
                                     addressMapping->FirstElement[i];
        }
    }

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PATL_ED ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor 
    and creates the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->ATL_FED.AdditionalSenseCode;
    UCHAR asq = ElementDescriptor->ATL_FED.AddSenseCodeQualifier;
    ULONG exceptionCode;

    switch (asc) {

        case 0x80:
            switch (asq) {
                case 0x22:
                    exceptionCode = ERROR_LABEL_UNREADABLE;
                    break;

                default:
                    exceptionCode = ERROR_UNHANDLED_ERROR;

            }
                break; // 0x85

        case 0x8D:
            switch (asq) {
                case 0x22:

                case 0xF3:
                    exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
                    break;
            }

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;
}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == ATL_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.
Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to
   // ATL_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = ATL_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "ATLMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set PF & SelfTest bits
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0xA;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != ATL_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case ATL_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         case ATL_CHM_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
            break;
         }

         case ATL_DOOR_OPEN: {
            changerDeviceError->ChangerProblemType = DeviceProblemDoorOpen;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch (changerData->DeviceStatus) 
   }
   
   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\adicsc\adicsc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    adicsc.c

Abstract:

    This module contains device-specific routines for the ADIC Scalar medium changers:
    ADIC Scalar 218,224,448, 458.
    Also for the Compaq UHDL

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "adicsc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, AdicBuildAddressMapping)
#endif


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the ADIC Scalar changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath,
                                  &mcdInitData);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = AdicBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));

        //
        // Indicate that the device needs to re-init.
        //

        changerData->AddressMapping.Initialized = FALSE;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        DebugPrint((1,
                    "Adicsc.ChangerInitialize: Error allocating dataBuffer. %x\n", status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"Scalar DLT 448", 14) == 14) {
            changerData->DriveID = ADIC_SCALAR_448;
        }

        if ((RtlCompareMemory(dataBuffer->ProductId,"Scalar 100", 10) == 10) ||
            (RtlCompareMemory(dataBuffer->ProductId,"PV-136T", 7) == 7)) {
            changerData->DriveID = ADIC_SCALAR;
        }

        if ((RtlCompareMemory(dataBuffer->ProductId,"FastStor DLT", 12) == 12) ||
            (RtlCompareMemory(dataBuffer->ProductId,"PV-120T DLT", 11) == 11)) {
            changerData->DriveID = ADIC_FASTSTOR;
        }

        if (RtlCompareMemory(dataBuffer->ProductId, "UHDL", 4) == 4)
        {
            changerData->DriveID = UHDL;
        }
    }

    ChangerClassFreePool(dataBuffer);

    //
    // We'll try to get device identifier info. If it fails
    // this flag will be set to FALSE so that subsequently
    // we won't try to get device identifier info
    //
    changerData->ObtainDeviceIdentifier = TRUE;

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:

            if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier)
                {
                    //
                    // The Compaq StorageWorks UHDL returns 0x02/04/03 when a
                    // magazine is ejected out and a TUR is sent down.
                    //
                    case 0x03:
                        if (changerData->DriveID == UHDL)
                        {
                            *Retry = FALSE;
                            *Status = STATUS_DEVICE_DOOR_OPEN;
                        }
                        break;

                    case 0x82:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;

        case SCSI_SENSE_UNIT_ATTENTION:
            //
            // The Compaq StorageWorks UHDL returns 0x06/3B/12 when a magazine
            // is ejected out.
            //
            if (senseBuffer->AdditionalSenseCode == 0x3B &&
                senseBuffer->AdditionalSenseCodeQualifier == 0x12 &&
                changerData->DriveID == UHDL)
            {
                *Retry = FALSE;
                *Status = STATUS_DEVICE_DOOR_OPEN;
            }
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            break;

        case SCSI_SENSE_HARDWARE_ERROR:

            //
            // The ADIC returns 4/40/01 for some illegal commands.
            //

            if (senseBuffer->AdditionalSenseCode == 0x40) {
                if (senseBuffer->AdditionalSenseCodeQualifier == 0x01) {
                    *Retry = FALSE;
                    *Status = STATUS_INVALID_DEVICE_REQUEST;
                }
            } else {
                changerData->DeviceStatus = ADICSC_HW_ERROR;
            }
            break;

        default:
            break;
        }
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    ADIC Scalar changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 1;

    changerParameters->FirstSlotNumber = 0;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    if (changerData->DriveID == UHDL)
    {
        changerParameters->MagazineSize = 8;
    }
    else
    {
        changerParameters->MagazineSize = 0;
    }

    changerParameters->DriveCleanTimeout = 300;

    if (!addressMapping->Initialized) {
        ULONG i;

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;

        //
        // Determine the lowest element address for use with AllElements.
        //

        for (i = 0; i < ChangerDrive; i++) {
            if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {
                addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
            }
        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //
    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Set IEPort flags if the changer has at least one IEPort
    //
    if (changerParameters->NumberIEElements != 0) {
       changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_OPEN |
                                      CHANGER_IEPORT_USER_CONTROL_CLOSE;
    }

    if (changerData->DriveID == UHDL)
    {
        changerParameters->Features0 |= CHANGER_BAR_CODE_SCANNER_INSTALLED;
    }
    else
    {
        //
        // The ADICs indicates whether a bar-code scanner is
        // attached by setting bit-0 in this byte.
        //
        changerParameters->Features0 |= ((changerData->InquiryData.VendorSpecific[19] & 0x1)) ?
                                             CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;
    }

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 |= CHANGER_INIT_ELEM_STAT_WITH_RANGE     |
                                    CHANGER_POSITION_TO_ELEMENT           |
                                    CHANGER_PREDISMOUNT_EJECT_REQUIRED    |
                                    CHANGER_DRIVE_CLEANING_REQUIRED       |
                                    CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS    |
                                    CHANGER_CLEANER_ACCESS_NOT_VALID;

    if (changerParameters->NumberIEElements == 0) {

        //
        // No real IE Elements - nothing can be programatically locked.
        //

        changerParameters->PositionCapabilities = (CHANGER_TO_SLOT | CHANGER_TO_DRIVE);

    } else {
        changerParameters->PositionCapabilities = (CHANGER_TO_SLOT | CHANGER_TO_DRIVE | CHANGER_TO_IEPORT);
    }

    changerParameters->LockUnlockCapabilities = 0;
    if ((changerData->DriveID) == ADIC_SCALAR) {
        changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_IEPORT;
        changerParameters->Features0 |= CHANGER_LOCK_UNLOCK;
    }

    if (changerData->DriveID == UHDL)
    {
        changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_DOOR;
        changerParameters->Features0 |= (CHANGER_LOCK_UNLOCK | CHANGER_CARTRIDGE_MAGAZINE);
        changerParameters->Features0 &= ~(CHANGER_INIT_ELEM_STAT_WITH_RANGE | CHANGER_PREDISMOUNT_EJECT_REQUIRED);
    }

    changerParameters->NumberCleanerSlots = 0;
    changerParameters->FirstSlotNumber = 1;

    if (changerParameters->Features0 & CHANGER_BAR_CODE_SCANNER_INSTALLED) {

        if ((changerParameters->NumberStorageElements == 17) ||
            (changerParameters->NumberStorageElements == 6)) {

            //
            // This is the 218 or FastStor
            // Barcode scanner steals the lowest slot.
            //

            changerParameters->FirstSlotNumber = 2;

        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build device capabilities mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Fix up the 218's storage capabilities.
    //

    if (changerParameters->NumberIEElements == 0) {
        changerParameters->Features0 &= ~CHANGER_STORAGE_IEPORT;
    }

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    //
    // The FastStor's door really isn't a door in
    // the same sense as other changers, neither is its ieport
    //
    if(changerData->DriveID == ADIC_FASTSTOR) {
          changerParameters->NumberIEElements = 0;
          changerParameters->Features0 &= ~(CHANGER_STORAGE_IEPORT |
                                            CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS);
          changerParameters->Features1 &= ~(CHANGER_IEPORT_USER_CONTROL_OPEN |
                                      CHANGER_IEPORT_USER_CONTROL_CLOSE);
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the door or IEPort. Value can be one of the
    following:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =
        DeviceObject->DeviceExtension;

    PCHANGER_DATA       changerData =
        (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);

    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;

    //
    // IEPort solenoid burns out if left activated constantly, on 448 unit.
    // So IEPort locking is only done around MoveMedium calls that involve
    // the IEPORT on these units.
    //
    // For other Scalar units, we'll keep the IEPort locked except when
    // the user is to inject or eject media via the IEPort.
    //
    if ((changerData->DriveID) == ADIC_SCALAR_448) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Only IEPort lock\unlock function is supported for ADICs and Door
    // lock/unlock is supported for Compaq UHDL
    //

    if (setAccess->Element.ElementType != ChangerIEPort &&
        !(setAccess->Element.ElementType == ChangerDoor && changerData->DriveID == UHDL)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ((controlOperation != LOCK_ELEMENT) &&
        (controlOperation != UNLOCK_ELEMENT)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (ElementOutOfRange(addressMapping,
                          (USHORT)setAccess->Element.ElementAddress,
                          setAccess->Element.ElementType)) {

        DebugPrint((1, "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;

    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;

    srb->TimeOutValue = 10;

    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    if (controlOperation == LOCK_ELEMENT) {
        cdb->MEDIA_REMOVAL.Prevent = 1;
    } else {
        cdb->MEDIA_REMOVAL.Prevent = 0;
    }

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
    if (!NT_SUCCESS(status)) {
       DebugPrint((1, "ChangerSetAccess failed. Status - %x",
                   status));
    }

    ChangerClassFreePool(srb);

    return status;
}


NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    NTSTATUS status;
    PVOID    statusBuffer;
    PCHANGER_ELEMENT_STATUS_EX elementStatusEx;
    ULONG    totalElements = readElementStatus->ElementList.NumberOfElements;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // length will be based on whether vol. tags are returned and element type(s).
    //

    if (elementType != AllElements)
    {
        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType))
        {
            DebugPrint((1, "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }
    }

    //
    // Allocate first only for the header
    //
    length = sizeof(ELEMENT_STATUS_HEADER);
    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb)
    {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

RetrySRB:
    RtlZeroMemory(statusBuffer, length);
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // ISSUE - 2001/04/11 - nramas : Should change Reserved1 field in CDB
    // to meaningful name.
    //
    if ((elementType == ChangerDrive) && (changerData->ObtainDeviceIdentifier == TRUE) && (changerData->DriveID != UHDL))
    {
        //
        // Set this bit to retrieve device identifier information
        //
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x01;

        //
        // Since serial number info follows volume tag field,
        // we need to set VolTag bit also in the CDB
        //
        cdb->READ_ELEMENT_STATUS.VolTag = 0x01;
    }
    else
    {
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x00;
    }

    //
    // Send SCSI command (CDB) to device
    //
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (NT_SUCCESS(status) || STATUS_DATA_OVERRUN == status)
    {
        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;;

        if (STATUS_DATA_OVERRUN == status)
        {
            if ((srb->DataTransferLength) <= length)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                DebugPrint((1, "Adicsc:ReadElementStatus - Dataoverrun.\n"));
                ChangerClassFreePool(srb);
                ChangerClassFreePool(statusBuffer);

                return status;
            }
        }

        //
        // Get the actual needed length
        //
        length =  (statusHeader->ReportByteCount[2]);
        length |= (statusHeader->ReportByteCount[1] << 8);
        length |= (statusHeader->ReportByteCount[0] << 16);

        //
        // Account for the size of the status header
        //
        length += sizeof(ELEMENT_STATUS_HEADER);

        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
    }
    else if (status == STATUS_INVALID_DEVICE_REQUEST)
    {
        //
        // Probably the device doesn't support DVCID bit
        // which retrieves Device Identifier info such as
        // serial number for drives. Try RES once more with
        // DVCID bit turned off.
        //
        if (changerData->ObtainDeviceIdentifier == TRUE)
        {
            changerData->ObtainDeviceIdentifier = FALSE;
            goto RetrySRB;
        }
    }
    else
    {
        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

RetryRequest:

    RtlZeroMemory(statusBuffer, length);

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // ISSUE - 2001/04/11 - nramas : Should change Reserved1 field in CDB
    // to meaningful name.
    //
    if ((elementType == ChangerDrive) && (changerData->ObtainDeviceIdentifier == TRUE) && (changerData->DriveID != UHDL))
    {
        //
        // Set this bit to retrieve device identifier information
        //
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x01;

        //
        // Since serial number info follows volume tag field,
        // we need to set VolTag bit also in the CDB
        //
        cdb->READ_ELEMENT_STATUS.VolTag = 0x01;
    } else {
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x00;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PADICS_ELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;


        //
        // Check if the error was STATUS_DATA_OVERRUN
        //
        if (status == STATUS_DATA_OVERRUN) {
           //
           // Check if there was a DATA_OVERRUN, or was it just
           // DATA_UNDERRUN reported as DATA_OVERRRUN.
           //
           if (srb->DataTransferLength < length) {
              DebugPrint((1,
                          "DATA_UNDERRUN reported as DATA_OVERRUN."));
              DebugPrint((1,
                          "Expected: %d, Transferred: %d.\n",
                          length, srb->DataTransferLength));
              status = STATUS_SUCCESS;
           } else {
              //
              // It was really DATA_OVERRUN error. Report accordingly.
              //
              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                    elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |=
                    (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;


                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);


                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                if (elementDescriptor->IdValid) {
                    elementStatus->TargetId = elementDescriptor->BusAddress;
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Ensure that media is actually present. If so, get the tag info.
                //

                if (elementDescriptor->Full) {
                    if (tagInfo) {
                        if (statusPage->PVolTag) {
                            ULONG tagIndex;

                            //
                            // Verify validity of volume tag information.
                            //

                            for (tagIndex = 0; tagIndex < 14; tagIndex++) {
                                if (((PADICS_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor)->VolumeTagDeviceID.VolumeTagInformation[tagIndex] != 0) {
                                    break;
                                }
                            }
                            if (tagIndex == 14) {

                                elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                                elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;

                            } else {
                                RtlMoveMemory(elementStatus->PrimaryVolumeID,
                                              ((PADICS_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor)->VolumeTagDeviceID.VolumeTagInformation,
                                              MAX_VOLUME_ID_SIZE);

                                elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                            }

                        } else {
                            DebugPrint((1,
                                       "ChangerGetElementStatus: tagInfo requested but PVoltag not set\n"));
                        }
                    }
                }

                if (elementType == ChangerDrive) {
                    if (outputBuffLen >=
                        (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {

                        PADICS_ELEMENT_DESCRIPTOR_PLUS elementDescPlus =
                            (PADICS_ELEMENT_DESCRIPTOR_PLUS) elementDescriptor;
                        PUCHAR idField = NULL;
                        ULONG idLength = 0;

                        elementStatusEx = (PCHANGER_ELEMENT_STATUS_EX)elementStatus;

                        if (statusPage->PVolTag) {
                            idField =  elementDescPlus->VolumeTagDeviceID.Identifier;
                            idLength = elementDescPlus->VolumeTagDeviceID.IdLength;
                        } else {
                            idField = elementDescPlus->DeviceID.Identifier;
                            idLength = elementDescPlus->DeviceID.IdLength;
                        }

                        if (idLength != 0) {

                            if (idLength > SERIAL_NUMBER_LENGTH) {
                                idLength = SERIAL_NUMBER_LENGTH;
                            }

                            RtlMoveMemory(elementStatusEx->SerialNumber,
                                          idField,
                                          idLength);

                            DebugPrint((3, "Serial number : %s\n",
                                        elementStatusEx->SerialNumber));

                            elementStatusEx->Flags |= ELEMENT_STATUS_PRODUCT_DATA;
                        }
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer and element descriptor array.
                //
                if (outputBuffLen >=
                    (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
                    DebugPrint((3,
                                "Incrementing by sizeof(CHANGER_ELEMENT_STATUS_EX\n"));
                    (PUCHAR)elementStatus += sizeof(CHANGER_ELEMENT_STATUS_EX);
                } else {
                    elementStatus += 1;
                }

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }

                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        if (outputBuffLen >= (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
            Irp->IoStatus.Information = numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX);
        } else {
            Irp->IoStatus.Information = numberElements * sizeof(CHANGER_ELEMENT_STATUS);
        }
    } else if (status == STATUS_INVALID_DEVICE_REQUEST) {
        //
        // Probably the device doesn't support DVCID bit
        // which retrieves Device Identifier info such as
        // serial number for drives. Try RES once more with
        // DVCID bit turned off.
        //
        if (changerData->ObtainDeviceIdentifier == TRUE) {
            changerData->ObtainDeviceIdentifier = FALSE;
            goto RetryRequest;
        }
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;
        cdb->INIT_ELEMENT_STATUS.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        PCHANGER_ELEMENT_LIST elementList;
        PCHANGER_ELEMENT element;

        if (changerData->DriveID == UHDL)
        {
            ChangerClassFreePool(srb);
            return STATUS_INVALID_PARAMETER;
        }

        elementList = &initElementStatus->ElementList;
        element = &elementList->Element;

        //
        // Use the ADIC vendor-unique initialize with range command
        //

        srb->CdbLength = CDB10GENERIC_LENGTH;
        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        //
        // Addresses of elements need to be mapped from 0-based to device-specific.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        //
        // Indicate whether to use bar code scanning.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // The Scalars don't support 2-sided media.
    //

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the Scalars units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status, moveStatus;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // ADICs don't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;


    if ((changerData->DriveID) == ADIC_SCALAR_448) {

        // Pre-MoveMedium Locking ? =========================================
        // if source or destination involved IEPORT, lock the IEPORT first
        if ((moveMedium->Source.ElementType == ChangerIEPort) ||
            (moveMedium->Destination.ElementType == ChangerIEPort)) {

            srb->CdbLength = CDB6GENERIC_LENGTH;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            srb->DataBuffer = NULL;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;

            // lock the IEPORT !
            cdb->MEDIA_REMOVAL.Prevent = 1;
            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                 srb,
                                                 srb->DataBuffer,
                                                 srb->DataTransferLength,
                                                 FALSE);
            if (!NT_SUCCESS(status)) {
               DebugPrint((1,
                           "Pre-MoveMedium Locking failed : ",
                           status));
            }
        }
    }


    // MoveMedium  =========================================

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;
    srb->DataTransferLength = 0;
    moveStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(moveStatus)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    if ((changerData->DriveID) == ADIC_SCALAR_448) {

        // Post-MoveMedium UnLocking ? =========================================
        // if source or destination involved IEPORT, unlock the IEPORT
        if ((moveMedium->Source.ElementType == ChangerIEPort) ||
            (moveMedium->Destination.ElementType == ChangerIEPort)) {

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            srb->CdbLength = CDB6GENERIC_LENGTH;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            srb->DataBuffer = NULL;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;

            // unlock the IEPORT !
            cdb->MEDIA_REMOVAL.Prevent = 0;
            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                 srb,
                                                 srb->DataBuffer,
                                                 srb->DataTransferLength,
                                                 FALSE);
            if (!NT_SUCCESS(status)) {
               DebugPrint((1,
                           "Post-MoveMedium UnLocking failed : ",
                           status));
            }
        }
    }

    ChangerClassFreePool(srb);
    return moveStatus;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
AdicBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = ADIC_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);


    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;

        //
        // Determine the lowest element address for use with AllElements.
        //

        for (i = 0; i < ChangerDrive; i++) {
            if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {

                DebugPrint((1,
                           "BuildAddressMapping: New lowest address %x\n",
                           addressMapping->FirstElement[i]));
                addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
            }
        }
    }



    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PADICS_ELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asq = ElementDescriptor->AddSenseCodeQualifier;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    ULONG exceptionCode = 0;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x83:
            if (asq == 0x03) {
                exceptionCode = ERROR_LABEL_QUESTIONABLE;
            }
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "adicsmc: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               asq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == ADIC_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to
   // ADICSC_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = ADICSC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "ADICSC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set only SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != ADICSC_DEVICE_PROBLEM_NONE) {
       changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\adicvls\adicvls.c ===
/*++

Copyright (C) 1996-97  Microsoft Corporation

Module Name:

    adicvls.c

Abstract:

    This module contains device-specific routines for ADIC's VLS
    and 1200x series of Changers. These changers support the
    following drives:
      - HP and Sony 4mm DDS
      - Exabyte 8mm
      - Sony SDX 8mm
      - Quantum DLT

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "adicvls.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, AdicvlsBuildAddressMapping)
#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, InternalSendRequestSense)
#pragma alloc_text(PAGE, MapExceptionCodes)
#endif



ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the various VLS/1200 changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = AdicvlsBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }

        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"DAT AutoChanger",15) == 15) {
        changerData->DriveType = ADIC_1200;
        changerData->DriveID   = ADIC_4mm;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"VLS 4mm",7) == 7) {
        changerData->DriveType = ADIC_VLS;
        changerData->DriveID   = ADIC_4mm;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"VLS 8mm",7) == 7) {
        changerData->DriveType = ADIC_VLS;
        changerData->DriveID   = ADIC_8mm_EXB;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"VLS SDX",7) == 7) {
        changerData->DriveType = ADIC_VLS;
        changerData->DriveID   = ADIC_8mm_SONY;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"VLS DLT",7) == 7) {
        changerData->DriveType = ADIC_VLS;
        changerData->DriveID   = ADIC_DLT;
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    ULONG deviceStatus;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        switch (senseBuffer->SenseKey) {
            case SCSI_SENSE_NOT_READY:
                break;

            case SCSI_SENSE_UNIT_ATTENTION:
                break;

            case SCSI_SENSE_HARDWARE_ERROR: {
                UCHAR adicvlsASC;
                UCHAR adicvlsASCQ;

                adicvlsASC = senseBuffer->AdditionalSenseCode;
                adicvlsASCQ = senseBuffer->AdditionalSenseCodeQualifier;

                deviceStatus = ADICVLS_HW_ERROR;
                switch (adicvlsASC) {
                  case ADICVLS_ASC_CHM_ERROR: {
                      deviceStatus = ADICVLS_CHM_ERROR;
                      break;
                  }

                  case ADICVLS_ASC_DIAGNOSTIC_ERROR: {
                      switch (adicvlsASCQ) {
                        case ADICVLS_ASCQ_DOOR_OPEN: {
                            deviceStatus = ADICVLS_DOOR_OPEN;
                            break;
                        }

                        case ADICVLS_ASCQ_GRIPPER_ERROR:
                        case ADICVLS_ASCQ_GRIPPER_MOVE_ERROR: {
                            deviceStatus = ADICVLS_GRIPPER_ERROR;
                           break;
                        }

                        case ADICVLS_ASCQ_CHM_MOVE_SHORT_AXIS:
                        case ADICVLS_ASCQ_CHM_SHORT_HOME_POSITION:
                        case ADICVLS_ASCQ_CHM_DEST_SHORT_AXIS:
                        case ADICVLS_ASCQ_CHM_MOVE_LONG_AXIS:
                        case ADICVLS_ASCQ_CHM_LONG_HOME_POSITION:
                        case ADICVLS_ASCQ_CHM_DEST_LONG_AXIS:
                        case ADICVLS_ASCQ_DRUM_MOVE_ERROR:
                        case ADICVLS_ASCQ_DRUM_HOME_ERROR:
                        case ADICVLS_ASCQ_CHM_DEST_LONG:
                        case ADICVLS_ASCQ_CHM_SHORT_AXIS_MOVE: {
                            deviceStatus = ADICVLS_CHM_MOVE_ERROR;
                            break;
                        }

                        default: {
                            deviceStatus = ADICVLS_HW_ERROR;
                            break;
                        }
                      } // switch (adicvlsASCQ)

                      break;
                  }

                  default: {
                      deviceStatus = ADICVLS_HW_ERROR;
                      break;
                  }
                } // switch (adicvlsASC)

                changerData->DeviceStatus = deviceStatus;
                break;
            }
        }

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. Srb status %x\n",
                   Srb->SrbStatus));
    }

    return;

}


NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    ADIC VLS/1200 changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK          srb;
    PGET_CHANGER_PARAMETERS      changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE   elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE  transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    //
    // These units say they have an IEPORT, but they don't.
    //

    changerParameters->NumberIEElements = 0;

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                         elementAddressPage->MediumTransportElementAddress[1];

        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                     elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                      elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                    elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = (elementAddressPage->NumberTransportElements[0] << 8) |
                                                             elementAddressPage->NumberTransportElements[1];

        addressMapping->NumberOfElements[ChangerDrive] = (elementAddressPage->NumberDataXFerElements[0] << 8) |
                                                         elementAddressPage->NumberDataXFerElements[1];

        addressMapping->NumberOfElements[ChangerIEPort] = 0;

        addressMapping->NumberOfElements[ChangerSlot] = (elementAddressPage->NumberStorageElements[0] << 8) |
                                                        elementAddressPage->NumberStorageElements[1];

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = elementAddressPage->MediumTransportElementAddress[1];

        if (elementAddressPage->FirstDataXFerElementAddress[1] < addressMapping->LowAddress) {
            addressMapping->LowAddress = elementAddressPage->FirstDataXFerElementAddress[1];
        }
    }

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;
    changerParameters->DriveCleanTimeout = 200;
    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    if (changerData->DriveID == ADIC_DLT) {
       changerParameters->DriveCleanTimeout = 300;
    }

    //
    // Set MagazineSize to number of slots, as
    // all of the slots are in one magazine.
    //

    changerParameters->MagazineSize = (elementAddressPage->NumberStorageElements[0] << 8) |
                                      elementAddressPage->NumberStorageElements[1];

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_LOCK_UNLOCK                     |
                                   CHANGER_CARTRIDGE_MAGAZINE              |
                                   CHANGER_POSITION_TO_ELEMENT             |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE     |
                                   CHANGER_DRIVE_CLEANING_REQUIRED         |
                                   CHANGER_PREDISMOUNT_EJECT_REQUIRED      |
                                   CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS      |
                                   CHANGER_CLEANER_ACCESS_NOT_VALID;

    changerParameters->Features1 = CHANGER_PREDISMOUNT_ALIGN_TO_SLOT       |
                                   CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE;

    changerParameters->PositionCapabilities = (CHANGER_TO_SLOT | CHANGER_TO_DRIVE);

    if (changerData->DriveType == ADIC_1200) {

        changerParameters->Features0 &= ~CHANGER_CLEANER_ACCESS_NOT_VALID;
        changerParameters->Features1 &= ~CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE;
        changerParameters->Features1 |= CHANGER_CLEANER_OPS_NOT_SUPPORTED;
        changerParameters->PositionCapabilities &= ~CHANGER_TO_DRIVE;
    }

    //
    // build device capabilities mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;

    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    // The device reports that MT->IE is possible. As the Ieport is more conceptual than
    // a real element on these, claim no support.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    //
    // See above note concerning IePorts and these devices.
    //

    changerParameters->MoveFromIePort = 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 0;
    changerParameters->ExchangeFromSlot = 0;
    changerParameters->ExchangeFromIePort = 0;
    changerParameters->ExchangeFromDrive = 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;

}



NTSTATUS
ChangerGetStatus(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door, Keypad and IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping =
    &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (setAccess->Element.ElementType != ChangerDoor) {
        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (controlOperation == LOCK_ELEMENT) {

        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
        if (!NT_SUCCESS(status)) {
            DebugPrint((1,
                       "Adicvls.SetAccess: Prevent failed - %x\n",
                       status));
            ChangerClassFreePool(srb);
            return status;
        }

        //
        // By sending a move medium from IEPort to transport,
        // the unit will 'load' the magazine.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

        cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
        cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

        cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] >> 8);
        cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] & 0xFF);

        cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
        cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

        cdb->MOVE_MEDIUM.Flip = 0;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    } else if (controlOperation == UNLOCK_ELEMENT) {

        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 0;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

        if (!NT_SUCCESS(status)) {
            DebugPrint((1,
                       "Adicvls.SetAccess: Prevent failed - %x\n",
                       status));
            ChangerClassFreePool(srb);
            return status;
        }

        //
        // By sending a move medium from IEPort to transport,
        // the unit will 'load' the magazine.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

        cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
        cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

        cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
        cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

        cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] >> 8);
        cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] & 0xFF);

        cdb->MOVE_MEDIUM.Flip = 0;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    }

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    ChangerClassFreePool(srb);
    return status;

}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {
        ULONG i;

        statusPages = 4;

        //
        // Verify that the NumberOfElements for the AllElements request is valid.
        //


        for (i = 0; i <= ChangerDrive; i++) {
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // As the 'ieport' element is stripped off later (and never reported as being present)
        // need to add enough buffer to handle getting this info from the device.
        //

        totalElements += 1;

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                        "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }
        statusPages = 1;
    }

    length = sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    if (readElementStatus->VolumeTagInfo) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    length += (sizeof(ADICVLS_ELEMENT_DESCRIPTOR) * totalElements);
    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = 0;

    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] = (UCHAR)((element->ElementAddress +
                                                         addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] = (UCHAR)((element->ElementAddress +
                                                          addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, a status page,
        // and one or more element descriptors.
        // Point each element to its respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {
            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // These units will return element status for the 'ieport'. As it's
                // claimed that none exist, bypass this info.
                //

                if (elementType != ChangerIEPort) {
                    //
                    // Get the address for this element.
                    //

                    elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                    //
                    // Set the element type.
                    //

                    elementStatus->Element.ElementType = elementType;
                    elementStatus->Flags = 0;


                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    }

                    //
                    // Build Flags field.
                    //

                    if (elementType != ChangerTransport) {

                        //
                        // The VLS and 1200 devices use a different meaning of transport
                        // full than that which is expected. As moves from transport aren't
                        // possible anyway, claim it's always empty.
                        //

                        elementStatus->Flags = elementDescriptor->Full;
                    }

                    elementStatus->Flags |= (elementDescriptor->Exception << 2);

                    //
                    // The Access bit also has a different meaning on the VLS devices, so report
                    // the FULL state instead of the real Access state.
                    //

                    if (changerData->DriveType != ADIC_1200) {
                         elementStatus->Flags |= (elementDescriptor->Full << 3);
                    } else {
                        elementStatus->Flags |= (elementDescriptor->Accessible << 3);
                    }

                    elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->SValid << 23);


                    if (elementDescriptor->Exception) {
                        elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                        if (elementStatus->ExceptionCode == 0) {

                            //
                            // Turn off the exception bit.
                            //

                            elementStatus->Flags &= ~ELEMENT_STATUS_EXCEPT;
                        }
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                        //
                        // The vls doesn't set LunValid, but it is.
                        //

                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    //
                    // If the element type is a drive, send a request sense to the changer.
                    // This might update the full status, if the media was a cleaner cartridge,
                    // or bad media.
                    //

                    if (elementStatus->Element.ElementType == ChangerDrive) {
                        PADIC_SENSE_DATA requestSenseBuffer;

                        if (changerData->DriveType != ADIC_1200) {
                            requestSenseBuffer = InternalSendRequestSense(DeviceObject);

                            if (requestSenseBuffer) {

                                //
                                // Indicates that the media has been ejected by the drive - either bad media
                                // or a cleaner cartridge.
                                //

                                if (requestSenseBuffer->VendorStatus[0] & SENSOR_BEAM_BLOCKED) {

                                    //
                                    // Indicate that media is actually NOT in the drive.
                                    //

                                    if (elementStatus->Flags & ELEMENT_STATUS_FULL) {

                                        DebugPrint((1,
                                                   "Adicvls: Updating elementStatus to NOT full\n"));

                                        elementStatus->Flags &= ~ELEMENT_STATUS_FULL;
                                    }
                                }

                                ChangerClassFreePool(requestSenseBuffer);
                            }
                        }
                    }

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // By sending a move medium from IEPort to transport,
    // the unit will 'load' the magazine.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

    cdb->MOVE_MEDIUM.Flip = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    //
    // If the load fails, throw away the error, and continue.
    //

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                   "InitializeElementStatus: Load magazine failed - %x\n",
                   status));
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;
    PADIC_SENSE_DATA requestSenseBuffer;


    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress + addressMapping->FirstElement[ChangerTransport]);
    maxTransport = (USHORT)(addressMapping->FirstElement[ChangerTransport] +
                            addressMapping->NumberOfElements[ChangerTransport]);

    destination = (USHORT)(setPosition->Destination.ElementAddress +
                           addressMapping->FirstElement[setPosition->Destination.ElementType]);
    maxDest = (USHORT)(addressMapping->FirstElement[setPosition->Destination.ElementType] +
                       addressMapping->NumberOfElements[setPosition->Destination.ElementType]);

    if ((transport > maxTransport) || (destination > maxDest)) {

        //
        // One of the elements specified in the user buffer was out of range.
        //

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send unsolicited request sense to get the current magazine position.
    // If the requested pos. is where the unit is currently, just return success.
    // Could be an optimization, but mainly is used as the vls units will auto-move
    // some media on the position command - hence, the move medium issued afterwards
    // will fail.
    //

    if (setPosition->Destination.ElementType == ChangerSlot) {
        if (changerData->DriveType != ADIC_1200) {
            requestSenseBuffer = InternalSendRequestSense(DeviceObject);

            if (requestSenseBuffer) {
                ULONG currentPosition = requestSenseBuffer->MagazinePosition;

                //
                // Free the buffer allocated by the requestsense call.
                //

                ChangerClassFreePool(requestSenseBuffer);

                if (currentPosition == setPosition->Destination.ElementAddress) {

                    Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
                    return STATUS_SUCCESS;
                }
            }
        }
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DebugPrint((1,
               "SetPosition: Positioning type %x address %x\n",
               setPosition->Destination.ElementType,
               setPosition->Destination.ElementAddress));


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = 0;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;
    LONG                lockValue = 0;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //


    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // ADICs don't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
AdicvlsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK          srb;
    PCDB                         cdb;
    NTSTATUS                     status;
    ULONG                        bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE   elementAddressPage;
    PVOID                        modeBuffer;
    ULONG                        i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = ADIC_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                         elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                     elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                      elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                    elementAddressPage->FirstStorageElementAddress[1];
        //
        // Determine lowest address of all elements.
        //

        //
        // Determine the lowest element address for use with AllElements.
        //

        for (i = 0; i < ChangerDrive; i++) {
            if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {

                DebugPrint((1,
                           "BuildAddressMapping: New lowest address %x\n",
                           addressMapping->FirstElement[i]));
                addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = 0;
        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    ULONG exceptionCode = 0;
    UCHAR asq = ElementDescriptor->AddSenseCodeQualifier;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;


    DebugPrint((1,
               "MapExceptionCodes: ASC %x, ASCQ %x, ExceptionCode %x\n",
               asc,
               asq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == ADIC_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


PADIC_SENSE_DATA
InternalSendRequestSense(
    IN PDEVICE_OBJECT DeviceObject
    )

{
    PADIC_SENSE_DATA    requestSenseBuffer;
    PSCSI_REQUEST_BLOCK srb;
    ULONG       length = ADIC_SENSE_LENGTH;
    NTSTATUS    status;
    PCDB        cdb;

    requestSenseBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!requestSenseBuffer) {
        return NULL;
    }

    RtlZeroMemory(requestSenseBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(requestSenseBuffer);
        return NULL;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = 6;
    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.AllocationLength = (UCHAR)length;
    cdb->CDB6INQUIRY.Control = 0;

    srb->DataBuffer = requestSenseBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 10;

    //
    // Send unsolicited request sense.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (status == STATUS_DATA_OVERRUN) {
        if (srb->DataTransferLength >= ADIC_SENSE_LENGTH) {
            status = STATUS_SUCCESS;
        }
    }

    DebugPrint((1,
               "Adicvls: additional sense length %x\n",
               requestSenseBuffer->AdditionalSenseLength));

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                   "Adicvls: request sense failed - %x\n",
                   status));

        ChangerClassFreePool(requestSenseBuffer);
        requestSenseBuffer = NULL;
    }

    ChangerClassFreePool(srb);

    return requestSenseBuffer;

}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to
   // ADICVLS_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = ADICVLS_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "ADICVLS\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set only SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != ADICVLS_DEVICE_PROBLEM_NONE) {
       switch (changerData->DeviceStatus) {
         case ADICVLS_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         case ADICVLS_CHM_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
            break;
         }

         case ADICVLS_DOOR_OPEN: {
            changerDeviceError->ChangerProblemType = DeviceProblemDoorOpen;
            break;
         }

         case ADICVLS_CHM_MOVE_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMMoveError;
            break;
         }

         case ADICVLS_GRIPPER_ERROR: {
             changerDeviceError->ChangerProblemType = DeviceProblemGripperError;
             break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }      
      } // switch (changerData->DeviceStatus)
   }
   
   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\breece\breecemc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    breecemc.h

Abstract:

Authors:

    davet (Dave Therrien)

Revision History:

--*/
#ifndef _BREECE_MC_
#define _BREECE_MC_

//
// Breece Hill uses an addition 4 bytes on their device capabilities page...
//

#define BREECE_DEVICE_CAP_EXTENSION 4

typedef union _BHT_ED {

    struct _BHT_FED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
    } BHT_FED, *PBHT_FED;

    struct _BHT_PED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } BHT_PED, *PBHT_PED;

} BHT_ED, *PBHT_ED;

#define BHT_PARTIAL_SIZE sizeof(struct _BHT_PED)
#define BHT_FULL_SIZE sizeof(struct _BHT_FED)

#define BHT_DISPLAY_LINES        2
#define BHT_DISPLAY_LINE_LENGTH 16

typedef struct _LCD_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR WriteLine : 4;
    UCHAR Reserved2 : 2;
    UCHAR LCDSecurity : 1;
    UCHAR SecurityValid : 1;
    UCHAR Reserved4;
    UCHAR DisplayLine[BHT_DISPLAY_LINES][BHT_DISPLAY_LINE_LENGTH];
    UCHAR Reserved5[28];        // not used
} LCD_MODE_PAGE, *PLCD_MODE_PAGE;

#define BHT_NO_ELEMENT 0xFFFF

//
// Diagnostic sense codes
//
// ASC
// 
#define BREECE_ASC_HW_NOT_RESPONDING        0x08
#define BREECE_ASC_PICK_PUT_ERROR           0x15
#define BREECE_ASC_DRIVE_ERROR              0x3B
#define BREECE_ASC_DIAGNOSTIC_ERROR         0x40
#define BREECE_ASC_INTERNAL_HW_ERROR        0x44
#define BREECE_ASC_BARCODE_READ_ERROR       0x80
#define BREECE_ASC_INTERNAl_SW_ERROR        0x84

//
// ASCQ
//
#define BREECE_ASCQ_UNABLE_TO_OPEN_PICKER_JAW       0x90
#define BREECE_ASCQ_UNABLE_TO_CLOSE_PICKER_JAW      0x91
#define BREECE_ASCQ_THETA_AXIS_STUCK                0xA1
#define BREECE_ASCQ_Y_AXIS_STUCK                    0xB1
#define BREECE_ASCQ_Z_AXIS_STUCK                    0xC1

//
// DeviceStatus codes set in the extension
//
#define BREECE_DEVICE_PROBLEM_NONE      0x00 
#define BREECE_HW_ERROR                 0x01
#define BREECE_CHM_ERROR                0x02
#define BREECE_DRIVE_ERROR              0x03
#define BREECE_CHM_MOVE_ERROR           0x04


#define Q7            1
#define Q47           2


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device status returned by Diagnostic command
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PBHT_ED ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _BREECE_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\breece\breecemc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    breecemc.c

Abstract:

    This module contains device-specific routines for the following
    Breece Hill medium changers: 
            - Q7
            - Q47

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "breecemc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}

ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the exabyte changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}




NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"Quad 7",6) == 6) {
            changerData->DriveID = Q7;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"Quad 47",7) == 7) {
            changerData->DriveID = Q47;
        } 
    }

    ChangerClassFreePool(dataBuffer);


    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    ULONG deviceStatus;
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;


    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:

           if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x81:
                    case 0x82:
                    case 0x83:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            if (senseBuffer->AdditionalSenseCode == 0x80) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x03:
                    case 0x04:

                        *Retry = FALSE;
                        *Status = STATUS_MAGAZINE_NOT_PRESENT;
                         break;
                    case 0x05:
                    case 0x06:
                        *Retry = TRUE;
                        *Status = STATUS_DEVICE_NOT_CONNECTED;
                        break;
                default:
                    break;
                }
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           deviceStatus = BREECE_HW_ERROR;

           switch (senseBuffer->AdditionalSenseCode) {
            case BREECE_ASC_HW_NOT_RESPONDING: {
               deviceStatus = BREECE_HW_ERROR;
               break;
            }

            case BREECE_ASC_PICK_PUT_ERROR: {
               deviceStatus = BREECE_CHM_ERROR;
              break;
            }

            case BREECE_ASC_DRIVE_ERROR: {
               deviceStatus = BREECE_DRIVE_ERROR;
               break;
            }

            case BREECE_ASC_DIAGNOSTIC_ERROR: {
               switch (senseBuffer->AdditionalSenseCodeQualifier) {
                  case BREECE_ASCQ_UNABLE_TO_OPEN_PICKER_JAW:
                  case BREECE_ASCQ_UNABLE_TO_CLOSE_PICKER_JAW: {
                     deviceStatus = BREECE_CHM_ERROR;
                     break;
                  }

                  case BREECE_ASCQ_THETA_AXIS_STUCK:
                  case BREECE_ASCQ_Y_AXIS_STUCK:
                  case BREECE_ASCQ_Z_AXIS_STUCK: {
                     deviceStatus = BREECE_CHM_MOVE_ERROR;
                  }

                  default: {
                     deviceStatus = BREECE_HW_ERROR;
                     break;
                  }
               } // switch (senseBuffer->AdditionalSenseCodeQualifier)

               break;
            }

            case BREECE_ASC_INTERNAL_HW_ERROR: 
            case BREECE_ASC_BARCODE_READ_ERROR: 
            case BREECE_ASC_INTERNAl_SW_ERROR: {
               deviceStatus = BREECE_HW_ERROR;
               break;
            }

            default: {
               deviceStatus = BREECE_HW_ERROR;
               break;
            }
           } // switch (senseBuffer->AdditionalSenseCode)

           changerData->DeviceStatus = deviceStatus;
           break;
        }

        default:
            break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    exabyte changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1D - Element address assignment page.

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    // Fill in values.

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = 
                 elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= 
                 (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = 
                 elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= 
                 (elementAddressPage->NumberStorageElements[0] << 8);

    // Breece Hill reports an IEPORT for both the Q7 and 47 
    // to represent an access to a 7 cartridge magazine. These
    // are really slots, not IEPORTs. 
    // The Q47 has an option called SCI/E which is a real IEPORT,
    // BUT IT IS NOT SUPPORTED BY NTMS PER AGREEMENT BY BREECE HILL
    // AND HIGHGROUND (3/31/98 - Ray Heineman, Brian Conrey of BH). 
    // BH DID NOT WANT TO FIX A BUG WITH THE 
    // INABILITY TO SCAN A MEDIUM THAT WAS INJECTED OR THE 
    // INNEFICIENCY OF DOING A SINGLE SLOT IES (which did them
    // all, not a single slot).  
    
    //if ((changerData->DriveID == Q47) && 
    //    ((changerData->InquiryData.VendorSpecific[19] & 0x2) == 0x2)) {
    //   changerParameters->NumberIEElements = 1;
    //} else { 
        changerParameters->NumberIEElements = 0;
    //} 

    changerParameters->NumberDataTransferElements = 
                 elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= 
                 (elementAddressPage->NumberDataXFerElements[0] << 8);

    changerParameters->NumberOfDoors = 1;

    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 0;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    changerParameters->MagazineSize = 7;

    changerParameters->DriveCleanTimeout = 600;

    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1E - transport geometry mode sense.

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                             sizeof(MODE_PARAMETER_HEADER) +
                             sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);


    // initialize Features1  
        changerParameters->Features1 = 0;

    // initialize Features 0 and then set flip bit... 
    changerParameters->Features0 = 
             transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    // Breece Hill Q7 and Q47 units do not set the Inquiry BC bit
    // but they always hav a barcode reader installed. 

    changerParameters->Features0 |=
                             CHANGER_BAR_CODE_SCANNER_INSTALLED; 


    // Features based on manual, nothing programatic.
    changerParameters->Features0 |= 
               CHANGER_STATUS_NON_VOLATILE           | 
               CHANGER_LOCK_UNLOCK                   |                                   
               CHANGER_CARTRIDGE_MAGAZINE            |
               CHANGER_DRIVE_CLEANING_REQUIRED       |
               CHANGER_PREDISMOUNT_EJECT_REQUIRED;

    // FIRMWARE BUG!
    // the spec says IES w/RANGE is supported, but
    // IES to one slot does them all and IES to IEPORT
    // doesn't do anything !
    //          CHANGER_INIT_ELEM_STAT_WITH_RANGE     |


    // Only the Door can be locked and unlocked
    // Door on Q7/Q47 is top access mechanism, not the big front door !
    // Big front door cannot be locked
    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_DOOR;


    // legal Position capabilities... 
    changerParameters->PositionCapabilities = 0;


    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1F - Device Capabilities Page

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // BreeceHill uses an addition 4 bytes past the 
    // scsi-defined structure.

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE) + 
              BREECE_DEVICE_CAP_EXTENSION;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    // Fill in values in Features that are contained in this page.

    changerParameters->Features0 |= 
     capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    // Determine all the move from and exchange from 
    // capabilities of this device.

    changerParameters->MoveFromTransport = 
     capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = 
     capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = 0;

    changerParameters->MoveFromDrive = 
     capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 
     capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = 
     capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = 0;

    changerParameters->ExchangeFromDrive = 
     capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    //
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, 
                  VENDOR_ID_LENGTH);

    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId,
                  PRODUCT_ID_LENGTH);

    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel,
                  REVISION_LENGTH);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door or IEPort. 

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;

    if ((setAccess->Element.ElementType == ChangerKeypad) || 
        (setAccess->Element.ElementType == ChangerIEPort)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ((controlOperation == EXTEND_IEPORT) ||
        (controlOperation == RETRACT_IEPORT)) { 
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;


    if ((controlOperation == LOCK_ELEMENT) || 
        (controlOperation == UNLOCK_ELEMENT)) {

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

        srb->DataBuffer = NULL;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        if (controlOperation == LOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 1;
        } else if (controlOperation == UNLOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 0;
        }
    }

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command 
    for either all elements or the
    specified element type. The buffer returned is used to build 
    the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    numberElements;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;
    BOOLEAN  tagInfo;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    // Get the element type.
    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;
    numberElements = readElementStatus->ElementList.NumberOfElements;
    tagInfo = readElementStatus->VolumeTagInfo;

    if (elementType == AllElements) {
        statusPages = 4;
        if ((changerData->DriveID == Q47) && 
            ((changerData->InquiryData.VendorSpecific[19] & 0x2) == 0x2)) {
    
            numberElements++;   // if ALL requested, and the app thinks there
                                // are no IEPORTs, we must set aside a buffer
                                // for the IEPORT element and hide that 
                                // information when it gets passed back to 
                                // the application
        }
    } else {
        statusPages = 1;
    } 

    length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE));

    if (tagInfo) {
        length += (BHT_FULL_SIZE * numberElements);
    } else {
        length += (BHT_PARTIAL_SIZE * numberElements);
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = tagInfo;

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] =         
        (UCHAR)(numberElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] =      
        (UCHAR)(numberElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] =
                                      (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] =
                                      (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] =
                                      (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PBHT_ED elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);
          
              return status;
           }
        }

        if (elementType == AllElements) {
            if ((changerData->DriveID == Q47) && 
                ((changerData->InquiryData.VendorSpecific[19] & 0x2) == 0x2)) {
    
                numberElements--;       
                                // Since this was incremented before to 
                                // create a RdElemStatus call that includes
                                // the IEPORT, it must be take out at this point
            }
        }


        // Determine total number elements returned.
        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        // The buffer is composed of a header, status page, 
        // and element descriptors.
        // Point each element to it's respective place in the buffer.

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);
            
        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = 
           statusPage->ElementDescriptorLength[1];
        descriptorLength |= 
           (statusPage->ElementDescriptorLength[0] << 8);

        // Determine the number of elements of this type reported.
        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //
        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {
            // hide the IEPORT from the application
            for (i = 0; i < typeCount; i++, remainingElements--) {

               // don't return IEPORT info to host
               if (elementType != ChangerIEPort) {

                    // Get the address for this element.
                    elementStatus->Element.ElementAddress =
                     elementDescriptor->BHT_FED.ElementAddress[1];
                    elementStatus->Element.ElementAddress |=
                     (elementDescriptor->BHT_FED.ElementAddress[0] << 8);

                    // Account for address mapping.
                    elementStatus->Element.ElementAddress -= 
                    addressMapping->FirstElement[elementType];

                    // Set the element type.
                    elementStatus->Element.ElementType = elementType;

                    if (elementDescriptor->BHT_FED.SValid) {

                        ULONG  j;
                        USHORT tmpAddress;

                        // Source address is valid. 
                        // Determine the device specific address.
                        tmpAddress = elementDescriptor->BHT_FED.SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->BHT_FED.SourceStorageElementAddress[0] << 8);

                        // Now convert to 0-based values.
                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                       elementStatus->SrcElementAddress.ElementAddress =
                             tmpAddress - addressMapping->FirstElement[j];

                    }

                    // Build Flags field.

                    elementStatus->Flags = 
                     elementDescriptor->BHT_FED.Full;
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.Exception << 2);
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.Accessible << 3);

                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.LunValid << 12);
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.IdValid << 13);
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.NotThisBus << 15);

                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.Invert << 22);
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.SValid << 23);


                    elementStatus->ExceptionCode = 
                     MapExceptionCodes(elementDescriptor);

                    if (elementDescriptor->BHT_FED.IdValid) {
                        elementStatus->TargetId = 
                         elementDescriptor->BHT_FED.BusAddress;
                    }
                    if (elementDescriptor->BHT_FED.LunValid) {
                        elementStatus->Lun = elementDescriptor->BHT_FED.Lun;
                    }

                    if (tagInfo) {
                       RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                            elementDescriptor->BHT_FED.PrimaryVolumeTag, 
                            MAX_VOLUME_ID_SIZE);
                       elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }

                    // Advance to the next entry in the user 
                    // buffer and element descriptor array.
                    elementStatus += 1;
               }
                 
               // even for IEPORT, walk across its data
               // Get next descriptor of this same element type.
               (ULONG_PTR)elementDescriptor += descriptorLength;

            } // end of loop for this element type

            if (remainingElements > 0) {
                // Get next status page.
                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;
                elementType = statusPage->ElementType;

                // Point to decriptors.
                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = 
                       statusPage->ElementDescriptorLength[1];
                descriptorLength |= 
                       (statusPage->ElementDescriptorLength[0] << 8);

                // Determine the number of this element type reported.
                typeCount = statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = 
                sizeof(CHANGER_ELEMENT_STATUS) * numberElements;
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either 
    initialize all elements or the specified range of elements 
    using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    if (initElementStatus->ElementList.Element.ElementType != AllElements) {
        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->INIT_ELEMENT_STATUS.OperationCode = 
                                      SCSIOP_INIT_ELEMENT_STATUS;
    cdb->INIT_ELEMENT_STATUS.NoBarCode = 
            initElementStatus->BarCodeScan ? 0 : 1;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 
                     sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}




NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the 
    robotic mechanism to the specified
    element address. Normally used to optimize moves or 
    exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if ((setPosition->Destination.ElementType == ChangerKeypad) ||
         (setPosition->Destination.ElementType == ChangerDoor)) {
        return STATUS_INVALID_PARAMETER;
    }


    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    // Convert to device addresses.

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += 
     addressMapping->FirstElement[setPosition->Destination.ElementType];

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    // Build srb and cdb.

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    // Build device-specific addressing.

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] =
                    (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = 
                    (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = 
                    (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = 
                    (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the exabyte units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

   // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 
      (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 
      (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = 
      (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = 
      (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 
      (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 
      (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    // there is no command on these libraries to home or reinit the 
    // changer mechanism

    return STATUS_INVALID_DEVICE_REQUEST;
}




NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;


}



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = BHT_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = 
         (elementAddressPage->MediumTransportElementAddress[0] << 8) |
         elementAddressPage->MediumTransportElementAddress[1];

        addressMapping->FirstElement[ChangerDrive] = 
         (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
         elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = 
         (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
         elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = 
         (elementAddressPage->FirstStorageElementAddress[0] << 8) |
         elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = 
         elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= 
         (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = 
         elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= 
         (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = 0;

        addressMapping->NumberOfElements[ChangerSlot] = 
         elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= 
         (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;
    }


    // Determine the lowest element address for use with AllElements.
    //
    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < 
                         addressMapping->FirstElement[AllElements]) {
            addressMapping->FirstElement[AllElements] = 
                                     addressMapping->FirstElement[i];
        }
    }

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PBHT_ED ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor 
    and creates the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->BHT_FED.AdditionalSenseCode;
    UCHAR asq = ElementDescriptor->BHT_FED.AddSenseCodeQualifier;
    ULONG exceptionCode;

    switch (asc) {

        case 0x83:
            switch (asq) {
                case 0x0:
                    exceptionCode = ERROR_LABEL_QUESTIONABLE;
                    break;

                case 0x1:
                    exceptionCode = ERROR_LABEL_UNREADABLE;
                    break;

                case 0x2:
                    exceptionCode = ERROR_SLOT_NOT_PRESENT;
                    break;

                case 0x3:
                    exceptionCode = ERROR_LABEL_QUESTIONABLE;
                    break;


                case 0x4:
                    exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
                    break;

                default:
                    exceptionCode = ERROR_UNHANDLED_ERROR;

            }
                        break; // 0x83

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;
}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == BHT_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}
                                                                                                                                                             

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to 
   // BREECE_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate 
   // devicestatus.
   //
   changerData->DeviceStatus = BREECE_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "BREECEMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != BREECE_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case BREECE_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         case BREECE_CHM_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
            break;
         }

         case BREECE_DRIVE_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemDriveError;
            break;
         }

         case BREECE_CHM_MOVE_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMMoveError;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch (changerData->DeviceStatus)
   }

   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\ddsmc\ddsmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ddsmc.c

Abstract:

    This module contains device-specific routines for DDS-2 DDS-3 medium changers:
    HP C1553A, HP C1557A, Sony TSL-7000

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "ddsmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, DdsBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}



ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the hp changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //


    status = DdsBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(changerData->InquiryData.VendorId,"HP      ",8) == 8) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"C1553A",6) == 6) {
                changerData->DriveID = HP_DDS2;

            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"C1557A",6) == 6) {
                changerData->DriveID = HP_DDS3;

            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"C5713A",6) == 6) {
                changerData->DriveID = HP_DDS4;
            } 
        } else if (RtlCompareMemory(changerData->InquiryData.VendorId,"DEC     ",8) == 8) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"TLZ9",4) == 4) {
                changerData->DriveID = DEC_TLZ;
            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"TLZ1",4) == 4) {
                changerData->DriveID = DEC_TLZ;
            }

        } else if (RtlCompareMemory(changerData->InquiryData.VendorId,"SONY",4) == 4) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-7000",8) == 8) {
                changerData->DriveID = SONY_TSL;
            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-9000",8) == 8) {
                changerData->DriveID = SONY_TSL;
            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-10000",9) == 9) {
                changerData->DriveID = SONY_TSL;
            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-11000",9) == 9) {
                changerData->DriveID = SONY_TSL11000;
            }
        } else if (RtlCompareMemory(changerData->InquiryData.VendorId,"ADIC    ",8) == 8) {

            //
            // ADIC 800E is OEMd from Sony
            //

            if (RtlCompareMemory(changerData->InquiryData.ProductId,"800E",4) == 4) {
                changerData->DriveID = SONY_TSL;
            }
        } else if (RtlCompareMemory(changerData->InquiryData.VendorId,"COMPAQ", 6) == 6) {  
           if ((RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-9000",8) == 8) ||
               (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-10000", 9))) {
                changerData->DriveID = COMPAQ_TSL;
           }
        }
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/
{



    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA   senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_MEDIUM_ERROR: {
            if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_INVALID_MEDIA) {
                if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED) {

                    //
                    // Indicates a cleaner cartridge.
                    //
                    *Status = STATUS_CLEANER_CARTRIDGE_INSTALLED;
                }

            }
            break;
        }

        case SCSI_SENSE_NOT_READY: {
            if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_NO_MEDIA_IN_DEVICE) &&
                (senseBuffer->AdditionalSenseCodeQualifier == 0x00)) {

                //
                // Indicates there's no magazine in the changer
                //
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
            }

            break;
        }

        default:
            break;
        }
    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. SrbStatus %x\n",
                   Srb->SrbStatus));
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    hp changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    if ((changerData->DriveID == SONY_TSL) ||
         (changerData->DriveID == DEC_TLZ) ||
         (changerData->DriveID == COMPAQ_TSL) ||
         (changerData->DriveID == SONY_TSL11000)) {

        //
        // Indicate that a dedicated slot exists.
        //

        changerParameters->NumberCleanerSlots = 1;
        changerParameters->FirstCleanerSlotAddress = 7;
        changerParameters->MagazineSize = 8;
    } else {
        changerParameters->NumberCleanerSlots = 0;
        changerParameters->FirstCleanerSlotAddress = 0;
        changerParameters->MagazineSize = 6;
    }

    if (!addressMapping->Initialized) {

        ULONG i;

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = DDS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    addressMapping->NumberOfElements[ChangerTransport] = changerParameters->NumberTransportElements;
    addressMapping->NumberOfElements[ChangerDrive] = changerParameters->NumberDataTransferElements;
    addressMapping->NumberOfElements[ChangerIEPort] = changerParameters->NumberIEElements;
    addressMapping->NumberOfElements[ChangerSlot] = changerParameters->NumberStorageElements;
    addressMapping->NumberOfElements[ChangerDoor] = changerParameters->NumberOfDoors;
    addressMapping->NumberOfElements[ChangerKeypad] = 0;


    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->DriveCleanTimeout = 600;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_LOCK_UNLOCK                   |
                                   CHANGER_CARTRIDGE_MAGAZINE            |
                                   CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS    |
                                   CHANGER_DRIVE_CLEANING_REQUIRED;

    changerParameters->Features1 = CHANGER_CLEANER_AUTODISMOUNT;

    if ((changerData->DriveID == SONY_TSL) ||
        (changerData->DriveID == DEC_TLZ) ||
        (changerData->DriveID == COMPAQ_TSL) ||
        (changerData->DriveID == SONY_TSL11000)) {

        changerParameters->Features0 |= CHANGER_CLEANER_SLOT;
    }

    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_DOOR;

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;


    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the loader mechanism.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (setAccess->Element.ElementType != ChangerDoor) {

        //
        // No IEPORTs on these devices.
        //

        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (controlOperation == LOCK_ELEMENT) {

        //
        // Issue prevent media removal command to lock the magazine.
        //

        cdb->MEDIA_REMOVAL.Prevent = 1;

    } else if (controlOperation == UNLOCK_ELEMENT) {

        //
        // Issue allow media removal.
        //

        cdb->MEDIA_REMOVAL.Prevent = 0;

    } else {

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {
        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    }


    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}


NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PIO_STACK_LOCATION           irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    ELEMENT_TYPE        originalElementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    realElements;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // Save this value for later. The HP's have no transport element and special casing
    // is done while filling in the user buffer.
    //

    originalElementType = elementType;

    DebugPrint((2,
               "GetElementStatus: ElementType: %x\n",
                elementType));

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;
        realElements = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            realElements += addressMapping->NumberOfElements[i];
        }
    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        statusPages = 1;
        realElements = readElementStatus->ElementList.NumberOfElements;
    }

    DebugPrint((2,
               "StatusPages %x, readElements %x\n",
               statusPages,
               realElements));

    if (readElementStatus->VolumeTagInfo) {

        //
        // These units have no Volume tag capability.
        //

        return STATUS_INVALID_PARAMETER;
    } else {

        if ((changerData->DriveID == SONY_TSL) ||
             (changerData->DriveID == DEC_TLZ) ||
             (changerData->DriveID == COMPAQ_TSL) ||
             (changerData->DriveID == SONY_TSL11000)) {

            //
            // length will be based on number of element type(s).
            //

            length = sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages) +
                     (sizeof(SONY_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);

        } else {

            //
            // length will be based on number of element type(s).
            //

            length = sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages) +
                     (sizeof(HP_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);

        }
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // The HP's may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(realElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(realElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if ((NT_SUCCESS(status)) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        //
        // Check if data overrun is actually an underrun
        // reported as overrun.
        //
        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        RtlZeroMemory(elementStatus, irpStack->Parameters.DeviceIoControl.OutputBufferLength);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->Full;

        // Since none of these devices support exception reporting
                // don't se the exception bit
                //elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // The HP units don't have the capability of reporting exceptions
                // in this manner.
                //

                elementStatus->ExceptionCode = 0;

                if (elementDescriptor->IdValid) {
                    if (changerData->DriveID == SONY_TSL) {
                        UCHAR shiftValue;
                        UCHAR sonyAddress;

                        //
                        // Sony uses a bitmask for representing the target id
                        //

                        sonyAddress = elementDescriptor->BusAddress;
                        for (shiftValue = 1; shiftValue < 8; shiftValue++) {
                            if ((sonyAddress >> shiftValue) == 0) {
                                break;
                            }
                        }
                        elementStatus->TargetId = shiftValue - 1;
                    } else {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }

                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);


        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

        //
        // Send SCSI command (CDB) to device
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

        if (NT_SUCCESS(status)) {
            Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
        }

    } else {

        status = STATUS_INVALID_DEVICE_REQUEST;

    }


    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. None of the support devices currently have this functionality.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the hp units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (!((changerData->DriveID == HP_DDS2) || 
          (changerData->DriveID == HP_DDS3) ||
          (changerData->DriveID == HP_DDS4))) {

        //
        // The HP's don't really have a transport, so don't bother.
        //

        if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

            DebugPrint((1,
                       "ChangerMoveMedium: Transport element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }
    }


    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    //
    // DDS changers don't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
DdsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID                  modeBuffer;
    ULONG                  i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = DDS_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->LowAddress = DDS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == DDS_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\ddsmc\ddsmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    ddsmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _DDS_MC_
#define _DDS_MC_

typedef struct _HP_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved[4];
} HP_ELEMENT_DESCRIPTOR, *PHP_ELEMENT_DESCRIPTOR;

typedef struct _SONY_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
} SONY_ELEMENT_DESCRIPTOR, *PSONY_ELEMENT_DESCRIPTOR;

#define DDS_NO_ELEMENT 0xFFFF

//
// Drive ID's
//

#define HP_DDS2          0x00000001
#define HP_DDS3          0x00000002
#define SONY_TSL         0x00000003
#define DEC_TLZ          0x00000004
#define HP_DDS4          0x00000005
#define COMPAQ_TSL       0x00000006
#define SONY_TSL11000    0x00000007

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the Lowest element address of the unit.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

    UCHAR Reserved[3];

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Indicates which device is currently supported.
    // See above.
    //

    ULONG DriveID;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;

//
// Device diagnostic related definitions
//
#define TSL_NO_ERROR                            0x00
#define MAGAZINE_LOADUNLOAD_ERROR               0xD0
#define ELEVATOR_JAMMED                         0xD1
#define LOADER_JAMMED                           0xD2
#define LU_COMMUNICATION_FAILURE                0xD3
#define LU_COMMUNICATION_TIMEOUT                0xD4
#define MOTOR_MONITOR_TIMEOUT                   0xD5
#define AUTOLOADER_DIAGNOSTIC_FAILURE           0xD6

typedef struct _SONY_TSL_RECV_DIAG {
   UCHAR ErrorSet : 4;
   UCHAR Reserved1 : 2;
   UCHAR TimeReSync : 1;
   UCHAR ResetError : 1;
   UCHAR ErrorCode;
   UCHAR ResultA;
   UCHAR ResultB;
   UCHAR TestNumber;
} SONY_TSL_RECV_DIAG, *PSONY_TSL_RECV_DIAG;

typedef struct _HP_RECV_DIAG {
   UCHAR TestNumber;
   UCHAR ErrorCode;
   UCHAR SuspectPart;
   UCHAR LoopCount;
   UCHAR TestSpecInfo[60];
}HP_RECV_DIAG, *PHP_RECV_DIAG;


NTSTATUS
DdsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

//
// Internal functions for wmi
//
VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer,
    IN ULONG changerId
    );

#endif // _DDS_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\elmsmc\elmsmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    elmsmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _ELMS_MC_
#define _ELMS_MC_


#define ELMS_CD                         0x01

#define ELMS_SERIAL_NUMBER_LENGTH       23

typedef struct _ELMS_STORAGE_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
} ELMS_STORAGE_ELEMENT_DESCRIPTOR, *PELMS_STORAGE_ELEMENT_DESCRIPTOR;

typedef struct _ELMS_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} ELMS_ELEMENT_DESCRIPTOR, *PELMS_ELEMENT_DESCRIPTOR;

#define ELMS_NO_ELEMENT 0xFFFF


typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[ELMS_SERIAL_NUMBER_LENGTH];
    UCHAR Reserved1[6];
} SERIALNUMBER, *PSERIALNUMBER;


//
// Diagnostic sense codes
//
// ASC
//
#define ELMS_ASC_CHM_MOVE_ERROR                 0x02
#define ELMS_ASC_CARRIAGE_OR_BARCODE_FAILURE    0x06
#define ELMS_ASC_MECHANICAL_ERROR               0x15
#define ELMS_ASC_DIAGNOSTIC_FAILURE             0x40

//
// ASCQ
//
#define ELMS_ASCQ_CARRIAGE_FAILURE              0x00
#define ELMS_ASCQ_BARCODE_READER_FAILURE        0x80
#define ELMS_ASCQ_DOOR_OPEN                     0x81
#define ELMS_ASCQ_ELEVATOR_BLOCKED              0x82
#define ELMS_ASCQ_DRIVE_TRAY_OPEN               0x83
#define ELMS_ASCQ_ELEVATOR_FAILURE              0x84

//
// DeviceStatus
//
#define ELMS_DEVICE_PROBLEM_NONE    0x00
#define ELMS_HW_ERROR               0x01
#define ELMS_CHM_MOVE_ERROR         0x02
#define ELMS_DOOR_OPEN              0x03
#define ELMS_DRIVE_ERROR            0x04
#define ELMS_CHM_ERROR              0x05

//
// unique asc and ascq for the DVL
//

#define SCSI_ADSENSE_DIAGNOSTIC_FAILURE 0x40
#define SCSI_SENSEQ_ELMS_UNIQUE         0x81

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either CD-ROM or CD-R.
    //

    ULONG DriveType;

    //
    // Device status after diagnostic test.
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[ELMS_SERIAL_NUMBER_LENGTH];

    //
    // Pad out to ULONG.
    //

    UCHAR Reserved;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved1;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
ElmsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _ELMS_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\ddsmc\wmi.c ===
/*++ 

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for DDS changers.

Environment:

    kernel mode only

Revision History:

--*/ 
#include "ntddk.h"
#include "mcd.h"
#include "ddsmc.h"


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++ 

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.


Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   changerId = changerData->DriveID;

   //
   // ISSUE: 02/29/2000 - nramas :
   // Need to handle DEC_TLZ changer. For now, 
   // do not handle DEC TLZ changers
   //
   if (changerId == DEC_TLZ) {
      return STATUS_NOT_IMPLEMENTED;
   }

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "DDSMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set only SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
   if ((NT_SUCCESS(status)) ||
       (status != STATUS_IO_DEVICE_ERROR)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if (status == STATUS_IO_DEVICE_ERROR) {
        //
        // Diagnostic test failed. Do ReceiveDiagnostic to receive
        // the results of the diagnostic test
        //  
        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        cdb->CDB6GENERIC.OperationCode = SCSIOP_RECEIVE_DIAGNOSTIC;
        if ((changerId == SONY_TSL) ||
            (changerId == COMPAQ_TSL)) {
           length = sizeof(SONY_TSL_RECV_DIAG);
           cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(SONY_TSL_RECV_DIAG);
        } else if ((changerId == HP_DDS2) ||
                   (changerId == HP_DDS3) ||
                   (changerId == HP_DDS4)) {
           length = sizeof(HP_RECV_DIAG);
           cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(HP_RECV_DIAG);
        } else {
            DebugPrint((1, "DDSMC:Unknown changer id %x\n",
                        changerId));
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            ChangerClassFreePool(srb);
            return STATUS_SUCCESS;
        }

        resultBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                                length);
        if (resultBuffer == NULL) {
            //
            // Not enough memory. Just set the generic 
            // ChangerProblemType (DeviceProblemHardware)
            // and return STATUS_SUCCESS
            //
           changerDeviceError->ChangerProblemType = DeviceProblemHardware;
           DebugPrint((1, "DDSMC:PerformDiagnostics - Not enough memory to ",
                       "receive diagnostic results\n"));

           ChangerClassFreePool(srb);
           return STATUS_SUCCESS;
        }

        srb->DataTransferLength = length;
        srb->DataBuffer = resultBuffer;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->TimeOutValue = 120;
        
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                srb->DataBuffer,
                                                srb->DataTransferLength,
                                                FALSE);
        if (NT_SUCCESS(status)) {
            ProcessDiagnosticResult(changerDeviceError,
                                    resultBuffer, 
                                    changerId);
        }
                               
        ChangerClassFreePool(resultBuffer);
        status = STATUS_SUCCESS;
   } 

   ChangerClassFreePool(srb);
   return status;
}


VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer,
    IN ULONG changerId
    )
/*+++

Routine Description :

   This routine parses the data returned by the device on
   Receive Diagnostic command, and returns appropriate
   value for the problem type.
   
Arguements :

   changerDeviceError - Output buffer with diagnostic info
   
   resultBuffer - Buffer in which the data returned by the device
                  Receive Diagnostic command is stored.
                  
   changerId    - Type of DDS changer (COMPAQ_TSL, SONY_TSL, etc)
   
Return Value :

   DeviceProblemNone - If there is no problem with the device
   Appropriate status code indicating the changer problem type.   
--*/
{
   UCHAR errorCode;
   UCHAR errorSet;
   CHANGER_DEVICE_PROBLEM_TYPE changerErrorType;

   changerErrorType = DeviceProblemNone;
   if (changerId == SONY_TSL) {
      PSONY_TSL_RECV_DIAG diagBuffer;

      diagBuffer = (PSONY_TSL_RECV_DIAG)resultBuffer;
      errorCode = diagBuffer->ErrorCode;
      errorSet = diagBuffer->ErrorSet;

      if (errorSet == 0) {
         switch (errorCode) {
            case TSL_NO_ERROR: {
               changerErrorType = DeviceProblemNone;
               break;
            }
            case MAGAZINE_LOADUNLOAD_ERROR:
            case ELEVATOR_JAMMED:
            case LOADER_JAMMED: {
               changerErrorType = DeviceProblemCHMError;
               break;  
            }

            case LU_COMMUNICATION_FAILURE:
            case LU_COMMUNICATION_TIMEOUT:
            case MOTOR_MONITOR_TIMEOUT:
            case AUTOLOADER_DIAGNOSTIC_FAILURE: {
               changerErrorType = DeviceProblemHardware;
               break;
            }

            default: {
               changerErrorType = DeviceProblemDriveError;
               break;
            }
         }
      } else {
         changerErrorType = DeviceProblemHardware;
      }

   } else if ((changerId == HP_DDS2) ||
              (changerId == HP_DDS3) ||
              (changerId == HP_DDS4)) {
      PHP_RECV_DIAG diagBuffer = (PHP_RECV_DIAG)resultBuffer;

      errorCode = diagBuffer->ErrorCode;

      if (errorCode <= 0x2B) {
         changerErrorType = DeviceProblemDriveError;
      } else if (((errorCode >= 0x42) && 
                 (errorCode <= 0x4F)) ||
                 ((errorCode >= 0x61) &&
                  (errorCode <= 0x7F))) {
         if (errorCode == 0x6F) {
            changerErrorType = DeviceProblemCartridgeInsertError;
         } else if (errorCode == 0x7E) {
            changerErrorType = DeviceProblemNone;
         } else {
            changerErrorType = DeviceProblemHardware;
         }
         //
         // Issue - 02/14/2000 - nramas
         // More error codes for HP DDS drives need to be
         // handled
         //
      } 
   }

   changerDeviceError->ChangerProblemType = changerErrorType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\exabyte\exabyte.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    exabyte.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _EXABYTE_MC_
#define _EXABYTE_MC_

#define EXABYTE_210   1
#define EXABYTE_220   2
#define EXABYTE_440   3
#define EXABYTE_480   4
#define EXABYTE_10    5

#define EXABYTE_SERIAL_NUMBER_LENGTH 10

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device status returned by Send Diagnostic command
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[EXABYTE_SERIAL_NUMBER_LENGTH];

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;


#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;

//
// defines for Exabyte Additional Sense codes
// and Additional Sense code qualifiers
//
#define EXB_ADSENSE_DIAGNOSTIC_FAILURE              0x40
#define EXB_ADSENSE_TARGET_FAILURE                  0x44
#define EXB_ADSENSE_CARTRIDGE_ERROR                 0x81
#define EXB_ADSENSE_CHM_MOVE_ERROR                  0x82
#define EXB_ADSENSE_CHM_ZERO_ERROR                  0x83
#define EXB_ADSENSE_CARTRIDGE_INSERT_ERROR          0x84
#define EXB_ADSENSE_CHM_POSITION_ERROR              0x85
#define EXB_ADSENSE_HARDWARE_ERROR                  0x86
#define EXB_ADSENSE_CALIBRATION_ERROR               0x88
#define EXB_ADSENSE_SENSOR_ERROR                    0x89
#define EXB_ADSENSE_UNRECOVERABLE_ERROR             0x8A
#define EXB_ADSENSE_EJECT_ERROR                     0x8B

#define EXB_ADSENSEQUAL_FIRMWARE                    0x00
#define EXB_ADSENSEQUAL_CARTRIDGE_DROPPED           0x80
#define EXB_ADSENSEQUAL_MECH_PICK_ERROR             0x81
#define EXB_ADSENSEQUAL_PLACE_ERROR                 0x83
#define EXB_ADSENSEQUAL_STALLED                     0x84
#define EXB_ADSENSEQUAL_GRIPPER_OPEN_ERROR          0x85
#define EXB_ADSENSEQUAL_PICK_FAILURE                0x86

#define EXB_ADSENSEQUAL_CHM_ERROR                   0x80
#define EXB_ADSENSEQUAL_DOOR_ERROR                  0x88
#define EXB_ADSENSEQUAL_GRIPPER_ERROR               0x91
#define EXB_ADSENSEQUAL_GRIPPER_MOTION_ERROR        0x92
#define EXB_ADSENSEQUAL_SHORT_AXIS_MOVE             0xA0
#define EXB_ADSENSEQUAL_SHORT_HOMING_ERROR          0xA1
#define EXB_ADSENSEQUAL_SERVO_SHORT                 0xA3
#define EXB_ADSENSEQUAL_DESTINATION_SHORT           0xA5
#define EXB_ADSENSEQUAL_LONG_AXIS_MOVE              0xB0
#define EXB_ADSENSEQUAL_LONG_HOMING_ERROR           0xB1
#define EXB_ADSENSEQUAL_SERVO_LONG                  0xB3
#define EXB_ADSENSEQUAL_DESTINATION_LONG            0xB5
#define EXB_ADSENSEQUAL_DRUM_MOTION                 0xC0
#define EXB_ADSENSEQUAL_DRUM_HOME                   0xC1
#define EXB_ADSENSEQUAL_CONTROLLER_CARD             0xE0
#define EXB_ADSENSEQUAL_DESTINATION_SHORT2          0xE5
#define EXB_ADSENSEQUAL_DESTINATION_LONG2           0xF1

//
// Device Status codes on doing Send Diagnostic command
//
#define EXB_DEVICE_PROBLEM_NONE                     0x00
#define EXB_HARDWARE_ERROR                          0x01
#define EXB_CARTRIDGE_HANDLING_ERROR                0x02
#define EXB_DOOR_ERROR                              0x03
#define EXB_CALIBRATION_ERROR                       0x04
#define EXB_TARGET_FAILURE                          0x05
#define EXB_CHM_MOVE_ERROR                          0x06
#define EXB_CHM_ZERO_ERROR                          0x07
#define EXB_CARTRIDGE_INSERT_ERROR                  0x08
#define EXB_CHM_POSITION_ERROR                      0x09
#define EXB_SENSOR_ERROR                            0x0A
#define EXB_UNRECOVERABLE_ERROR                     0x0B
#define EXB_EJECT_ERROR                             0x0C
#define EXB_GRIPPER_ERROR                           0x0D

//
// Exabyte uses an addition 4 bytes on their device capabilities page...
//

#define EXABYTE_DEVICE_CAP_EXTENSION 4

typedef union _EXA_ELEMENT_DESCRIPTOR {

    struct _EXA_FULL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
    } EXA_FULL_ELEMENT_DESCRIPTOR, *PEXA_FULL_ELEMENT_DESCRIPTOR;

    struct _EXA_PARTIAL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } EXA_PARTIAL_ELEMENT_DESCRIPTOR, *PEXA_PARTIAL_ELEMENT_DESCRIPTOR;

} EXA_ELEMENT_DESCRIPTOR, *PEXA_ELEMENT_DESCRIPTOR;

#define EXA_PARTIAL_SIZE sizeof(struct _EXA_PARTIAL_ELEMENT_DESCRIPTOR)
#define EXA_FULL_SIZE sizeof(struct _EXA_FULL_ELEMENT_DESCRIPTOR)

#define EXA_DISPLAY_LINES        4
#define EXA_DISPLAY_LINE_LENGTH 20

typedef struct _LCD_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR WriteLine : 4;
    UCHAR Reserved2 : 2;
    UCHAR LCDSecurity : 1;
    UCHAR SecurityValid : 1;
    UCHAR Reserved4;
    UCHAR DisplayLine[4][EXA_DISPLAY_LINE_LENGTH];
} LCD_MODE_PAGE, *PLCD_MODE_PAGE;

#define EXA_NO_ELEMENT 0xFFFF



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PEXA_ELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType,
    IN BOOLEAN IntrisicElement
    );

#endif // _EXABYTE_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\exabyte\wmi.c ===
/*++

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for exabyte changers.

Environment:

    kernel mode only

Revision History:

--*/


#include "ntddk.h"
#include <wmidata.h>
#include <wmistr.h>
#include "mcd.h"
#include "exabyte.h"

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer 
   are set appropriately.
   
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType; 

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "Exabyte\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;
   
   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;
   cdb->CDB6GENERIC.CommandUniqueBits = 0xA;

   //
   // Set DeviceStatus in the device extension to 
   // EXB_DEVICE_PROBLEM_NONE
   //
   changerData->DeviceStatus = EXB_DEVICE_PROBLEM_NONE;

   //
   // Send the request down
   //
   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else {
      //
      // First check if it a hardware error
      //
      if ((changerData->DeviceStatus) != EXB_DEVICE_PROBLEM_NONE) {
         DebugPrint((1, 
                     "Exabyte\\ChangerPerformDiagnostics ",
                     "Found hardware problem. DeviceStatus %x\n",
                     changerData->DeviceStatus));
         switch (changerData->DeviceStatus) {
            case EXB_HARDWARE_ERROR: {
               changerProblemType = DeviceProblemHardware;
               break;
            }

            case EXB_CARTRIDGE_HANDLING_ERROR: {
               changerProblemType = DeviceProblemCHMError;
               break;
            }

            case EXB_DOOR_ERROR: {
               changerProblemType = DeviceProblemDoorOpen;
               break;
            }

            case EXB_CALIBRATION_ERROR: {
               changerProblemType = DeviceProblemCalibrationError;
               break;
            }

            case EXB_TARGET_FAILURE: {
               changerProblemType = DeviceProblemTargetFailure;
               break;
            }

            case EXB_CHM_MOVE_ERROR: {
               changerProblemType = DeviceProblemCHMMoveError;
               break;
            }

            case EXB_CHM_ZERO_ERROR: {
               changerProblemType = DeviceProblemCHMZeroError;
               break;
            }

            case EXB_CARTRIDGE_INSERT_ERROR: {
               changerProblemType = DeviceProblemCartridgeInsertError;
               break;
            }

            case EXB_CHM_POSITION_ERROR: {
               changerProblemType = DeviceProblemPositionError;
               break;
            }

            case EXB_SENSOR_ERROR: {
               changerProblemType = DeviceProblemSensorError;
               break;
            }

            case EXB_UNRECOVERABLE_ERROR: {
               changerProblemType = DeviceProblemHardware;
               break;
            }

            case EXB_EJECT_ERROR: {
               changerProblemType = DeviceProblemCartridgeEjectError;
               break;
            }

            case EXB_GRIPPER_ERROR: {
               changerProblemType = DeviceProblemGripperError;
               break;
            }

            default : {
               changerProblemType = DeviceProblemHardware;
               break;
            }
         } // switch (changerData->DeviceStatus)
      } else {
         changerDeviceError->ChangerProblemType = DeviceProblemNone;
         DebugPrint((1, "Exabyte\\ChangerPerformDiagnostics : Status %x\n",
                     status));
      }
   } 

   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\exabyte\exabyte.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    exabyte.c

Abstract:

    This module contains device-specific routines for exabyte medium changers:
    EXABYTE 210/220, EXABYTE 480.

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "exabyte.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the exabyte changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}

typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[10];
} SERIALNUMBER, *PSERIALNUMBER;


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        DebugPrint((1,
                    "Examc.ChangerInitialize: Error allocating dataBuffer. %x\n", status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"EXB-440",7) == 7) {
            changerData->DriveID = EXABYTE_440;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"EXB-480",7) == 7) {
            changerData->DriveID = EXABYTE_480;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"EXB-210",7) == 7) {
            changerData->DriveID = EXABYTE_210;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"EXB-220",7) == 7) {
            changerData->DriveID = EXABYTE_220;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"EXB-10e",7) == 7) {
            changerData->DriveID = EXABYTE_10;
        }
    }

    if ((changerData->DriveID != EXABYTE_10)) {
        serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 14);
        if (!serialBuffer) {

            ChangerClassFreePool(dataBuffer);

            DebugPrint((1,
                        "Examc.ChangerInitialize: Error allocating serial number buffer. %x\n",
                        status));

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(serialBuffer, 14);

        //
        // Get serial number page.
        //

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Set timeout value.
        //

        srb.TimeOutValue = 10;

        srb.CdbLength = 6;

        cdb = (PCDB)srb.Cdb;

        //
        // Set CDB operation code.
        //

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        //
        // Set EVPD
        //

        cdb->CDB6INQUIRY.Reserved1 = 1;

        //
        // Unit serial number page.
        //

        cdb->CDB6INQUIRY.PageCode = 0x80;

        //
        // Set allocation length to inquiry data buffer size.
        //

        cdb->CDB6INQUIRY.AllocationLength = 14;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             serialBuffer,
                                             14,
                                             FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            ULONG i;

            RtlMoveMemory(changerData->SerialNumber, serialBuffer->SerialNumber, EXABYTE_SERIAL_NUMBER_LENGTH);

            DebugPrint((1,"DeviceType - %x\n", serialBuffer->DeviceType));
            DebugPrint((1,"PageCode - %x\n", serialBuffer->PageCode));
            DebugPrint((1,"Length - %x\n", serialBuffer->PageLength));

            DebugPrint((1,"Serial number "));

            for (i = 0; i < 10; i++) {
                DebugPrint((1,"%x", serialBuffer->SerialNumber[i]));
            }

            DebugPrint((1,"\n"));

        }

        ChangerClassFreePool(serialBuffer);
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIRP irp = Srb->OriginalRequest;
    PCHANGER_DATA changerData;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
     
    fdoExtension = DeviceObject->DeviceExtension;
    changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:

            if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x83:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;

                    case 0x85:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            if (senseBuffer->AdditionalSenseCode == 0x80) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x03:
                    case 0x04:

                        *Retry = FALSE;
                        *Status = STATUS_MAGAZINE_NOT_PRESENT;
                         break;
                    case 0x05:
                    case 0x06:
                        *Retry = TRUE;
                        *Status = STATUS_DEVICE_NOT_CONNECTED;
                        break;
                default:
                    break;
                }
            } else if ((senseBuffer->AdditionalSenseCode == 0x91) && (senseBuffer->AdditionalSenseCodeQualifier == 0x00)) {
                *Status = STATUS_TRANSPORT_FULL;

            }
            break;

        case SCSI_SENSE_UNIT_ATTENTION: {
            if ((senseBuffer->AdditionalSenseCode == 0x28) &&
                (senseBuffer->AdditionalSenseCodeQualifier == 0x0)) {

                //
                // Indicate that the door was opened and reclosed.
                //

                *Status = STATUS_MEDIA_CHANGED;
                *Retry = FALSE;
            }

            break;
        }

        case SCSI_SENSE_HARDWARE_ERROR: {
           UCHAR addSenseCode;
           UCHAR addSenseCodeQual;
           UCHAR statusCode;

           //
           // ISSUE - 2000/02/10 - nramas 
           // Should define more appropriate NTStatus codes
           // for these types of device  errors. For now
           // we handle it internally.
           //
           *Status = STATUS_IO_DEVICE_ERROR;
           statusCode = EXB_HARDWARE_ERROR;

           addSenseCode = senseBuffer->AdditionalSenseCode;
           addSenseCodeQual = senseBuffer->AdditionalSenseCodeQualifier;

           switch (addSenseCode) {
            case SCSI_ADSENSE_SEEK_ERROR: {
               switch (addSenseCodeQual) {
                  case EXB_ADSENSEQUAL_CARTRIDGE_DROPPED:
                  case EXB_ADSENSEQUAL_MECH_PICK_ERROR: 
                  case EXB_ADSENSEQUAL_PLACE_ERROR:
                  case EXB_ADSENSEQUAL_STALLED: 
                  case EXB_ADSENSEQUAL_GRIPPER_OPEN_ERROR:
                  case EXB_ADSENSEQUAL_PICK_FAILURE:{
                     statusCode = EXB_CARTRIDGE_HANDLING_ERROR;
                     break;
                  }   
               } // switch (addSenseCodeQual)

               break;
            }

            case EXB_ADSENSE_DIAGNOSTIC_FAILURE: {

               switch (addSenseCodeQual) {
                  case EXB_ADSENSEQUAL_CHM_ERROR: {
                     statusCode = EXB_CARTRIDGE_HANDLING_ERROR;
                     break;
                  }

                  case EXB_ADSENSEQUAL_DOOR_ERROR: {   
                     statusCode = EXB_DOOR_ERROR;
                     break;
                  }

                  case EXB_ADSENSEQUAL_GRIPPER_ERROR: 
                  case EXB_ADSENSEQUAL_GRIPPER_MOTION_ERROR:{
                     statusCode = EXB_GRIPPER_ERROR;
                     break;
                  }

                  case EXB_ADSENSEQUAL_SHORT_AXIS_MOVE:
                  case EXB_ADSENSEQUAL_SHORT_HOMING_ERROR: 
                  case EXB_ADSENSEQUAL_SERVO_SHORT:
                  case EXB_ADSENSEQUAL_DESTINATION_SHORT:
                  case EXB_ADSENSEQUAL_LONG_AXIS_MOVE:
                  case EXB_ADSENSEQUAL_SERVO_LONG:
                  case EXB_ADSENSEQUAL_DESTINATION_LONG:
                  case EXB_ADSENSEQUAL_LONG_HOMING_ERROR:
                  case EXB_ADSENSEQUAL_DRUM_MOTION:
                  case EXB_ADSENSEQUAL_DRUM_HOME:
                  case EXB_ADSENSEQUAL_CONTROLLER_CARD:
                  case EXB_ADSENSEQUAL_DESTINATION_SHORT2:
                  case EXB_ADSENSEQUAL_DESTINATION_LONG2:{
                     statusCode = EXB_CALIBRATION_ERROR;
                     break;
                  }

               } // switch (addSenseCodeQual)
               
               break;
            }

            case EXB_ADSENSE_TARGET_FAILURE: {
               statusCode = EXB_TARGET_FAILURE;
               break;
            }

            case EXB_ADSENSE_CARTRIDGE_ERROR: {
               statusCode = EXB_CARTRIDGE_HANDLING_ERROR;
               break;
            }

            case EXB_ADSENSE_CHM_MOVE_ERROR: {
               statusCode = EXB_CHM_MOVE_ERROR;
               break;
            }

            case EXB_ADSENSE_CHM_ZERO_ERROR: {
               statusCode = EXB_CHM_ZERO_ERROR;
               break;
            }

            case EXB_ADSENSE_CARTRIDGE_INSERT_ERROR: {
               if (addSenseCodeQual == EXB_ADSENSEQUAL_FIRMWARE) {
                  statusCode = EXB_HARDWARE_ERROR;
               } else {
                  statusCode = EXB_CARTRIDGE_INSERT_ERROR;
               }
               break;
            }

           case EXB_ADSENSE_CHM_POSITION_ERROR: {
              statusCode = EXB_CHM_POSITION_ERROR;
              break;
           }

           case EXB_ADSENSE_HARDWARE_ERROR: {
              statusCode = EXB_HARDWARE_ERROR;;
              break;
           }

           case EXB_ADSENSE_CALIBRATION_ERROR: {
              statusCode = EXB_CALIBRATION_ERROR;
              break;
           }

           case EXB_ADSENSE_SENSOR_ERROR: {
              statusCode = EXB_SENSOR_ERROR;
              break;
           }

           case EXB_ADSENSE_UNRECOVERABLE_ERROR: {
              statusCode = EXB_UNRECOVERABLE_ERROR;
              break;
           }

           case EXB_ADSENSE_EJECT_ERROR: {
              statusCode = EXB_EJECT_ERROR;
              break;
           }

           } // switch (addSenseCode)

           //
           // Update DeviceStatus in the device extension
           // with appropriate status code.
           //
           changerData->DeviceStatus = statusCode;
        } // case SCSI_SENSE_HARDWARE_ERROR

        default:
            break;
        }
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    exabyte changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 1;

    changerParameters->FirstSlotNumber = 0;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    changerParameters->MagazineSize = 10;
    changerParameters->DriveCleanTimeout = 600;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Exabyte indicates whether a bar-code scanner is
    // attached by setting bit-0 in this byte.
    //

    changerParameters->Features0 |= ((changerData->InquiryData.VendorSpecific[19] & 0x1)) ?
                                         CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;

    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_DOOR    |
                                                 LOCK_UNLOCK_KEYPAD);
    changerParameters->PositionCapabilities =  (CHANGER_TO_SLOT      |
                                                CHANGER_TO_DRIVE);


    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 |= CHANGER_STATUS_NON_VOLATILE           |
                                    CHANGER_INIT_ELEM_STAT_WITH_RANGE     |
                                    CHANGER_CLEANER_SLOT                  |
                                    CHANGER_LOCK_UNLOCK                   |
                                    CHANGER_CARTRIDGE_MAGAZINE            |
                                    CHANGER_POSITION_TO_ELEMENT           |
                                    CHANGER_DEVICE_REINITIALIZE_CAPABLE   |
                                    CHANGER_PREDISMOUNT_EJECT_REQUIRED    |
                                    CHANGER_DRIVE_CLEANING_REQUIRED       |
                                    CHANGER_VOLUME_IDENTIFICATION         |
                                    CHANGER_VOLUME_SEARCH                 |
                                    CHANGER_SERIAL_NUMBER_VALID           |
                                    CHANGER_KEYPAD_ENABLE_DISABLE;

    if ((changerData->DriveID == EXABYTE_440) ||(changerData->DriveID == EXABYTE_480)) {
        changerParameters->Features0 |= CHANGER_CLOSE_IEPORT |
                                        CHANGER_OPEN_IEPORT;

        changerParameters->PositionCapabilities |= CHANGER_TO_IEPORT;
        changerParameters->LockUnlockCapabilities |= LOCK_UNLOCK_IEPORT;

    } else if (changerData->DriveID == EXABYTE_10) {
        changerParameters->Features0 &= ~(CHANGER_SERIAL_NUMBER_VALID       |
                                          CHANGER_STATUS_NON_VOLATILE       |
                                          CHANGER_INIT_ELEM_STAT_WITH_RANGE |
                                          CHANGER_CLEANER_SLOT              |
                                          CHANGER_VOLUME_IDENTIFICATION     |
                                          CHANGER_VOLUME_SEARCH             |
                                          CHANGER_LOCK_UNLOCK               |
                                          CHANGER_KEYPAD_ENABLE_DISABLE);

        changerParameters->LockUnlockCapabilities = 0;
        changerParameters->NumberCleanerSlots = 0;
    }

    if (!(changerParameters->Features0 & CHANGER_BAR_CODE_SCANNER_INSTALLED)) {

        //
        // No scanner, no search/ident possible.
        //

        changerParameters->Features0 &= ~(CHANGER_VOLUME_IDENTIFICATION | CHANGER_VOLUME_SEARCH);
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Exabyte uses an addition 4 bytes past the scsi-defined structure.
    //

    length =  sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE) + EXABYTE_DEVICE_CAP_EXTENSION;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;


    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, EXABYTE_SERIAL_NUMBER_LENGTH);

    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the door or IEPort. Value can be one of the
    following:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType, FALSE)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    switch (setAccess->Element.ElementType) {
        case ChangerDoor:

            if (controlOperation == LOCK_ELEMENT) {

                //
                // Issue prevent media removal command to lock the door.
                //

                cdb->MEDIA_REMOVAL.Prevent = 1;

            } else if (controlOperation == UNLOCK_ELEMENT) {

                //
                // Issue allow media removal.
                //

                cdb->MEDIA_REMOVAL.Prevent = 0;

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            if ((changerData->DriveID == EXABYTE_440) || (changerData->DriveID == EXABYTE_480)) {

                //
                // Set the P/A bits to indicate that this operation is for the front door.
                //

                cdb->MEDIA_REMOVAL.Control = 0xC0;
            }

            break;

        case ChangerIEPort:

            if ((changerData->DriveID == EXABYTE_210) ||
                (changerData->DriveID == EXABYTE_220) ||
                (changerData->DriveID == EXABYTE_10)) {

                //
                // No IEPorts on these devices.
                //

                status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Set vendor-unique flag indicating that this operation is for the
                // ieport only.
                //

                cdb->MEDIA_REMOVAL.Control = 0x80;

                if (controlOperation == LOCK_ELEMENT) {

                    //
                    // Issue prevent media removal command to lock the ie port.
                    //

                    cdb->MEDIA_REMOVAL.Prevent = 1;

                } else if (controlOperation == UNLOCK_ELEMENT) {

                    //
                    // Issue allow media removal.
                    //

                    cdb->MEDIA_REMOVAL.Prevent = 0;

                } else if (controlOperation == EXTEND_IEPORT) {

                    srb->CdbLength = CDB12GENERIC_LENGTH;
                    srb->TimeOutValue = fdoExtension->TimeOutValue;

                    //
                    // Exabyte overloads the move medium command by a bit-mask in the control byte.
                    //

                    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

                    //
                    // Build addressing values based on address map.
                    //

                    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 0;
                    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 0;

                    cdb->MOVE_MEDIUM.SourceElementAddress[0] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) >> 8);

                    cdb->MOVE_MEDIUM.SourceElementAddress[1] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) & 0xFF);

                    cdb->MOVE_MEDIUM.DestinationElementAddress[0] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) >> 8);

                    cdb->MOVE_MEDIUM.DestinationElementAddress[1] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) & 0xFF);

                    cdb->MOVE_MEDIUM.Flip = 0;

                    //
                    // Indicate that the IEPORT should be extended.
                    //

                    cdb->MOVE_MEDIUM.Control = 0x40;

                    srb->DataTransferLength = 0;

                } else if (controlOperation == RETRACT_IEPORT) {
                    srb->CdbLength = CDB12GENERIC_LENGTH;
                    srb->TimeOutValue = fdoExtension->TimeOutValue;

                    //
                    // Exabyte overloads the move medium command by a bit-mask in the control byte.
                    //

                    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

                    //
                    // Build addressing values based on address map.
                    //

                    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 0;
                    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 0;

                    cdb->MOVE_MEDIUM.SourceElementAddress[0] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) >> 8);

                    cdb->MOVE_MEDIUM.SourceElementAddress[1] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) & 0xFF);

                    cdb->MOVE_MEDIUM.DestinationElementAddress[0] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) >> 8);

                    cdb->MOVE_MEDIUM.DestinationElementAddress[1] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) & 0xFF);

                    cdb->MOVE_MEDIUM.Flip = 0;

                    //
                    // Indicate that the IEPORT should be retracted.
                    //

                    cdb->MOVE_MEDIUM.Control = 0x80;

                    srb->DataTransferLength = 0;

                } else {
                    status = STATUS_INVALID_PARAMETER;
                }
            }

            break;

        case ChangerKeypad: {
            PVOID                modeBuffer;
            PLCD_MODE_PAGE       lcdModePage;

            //
            // Build the exabyte-unique lcd mode page.
            //

            modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER) + sizeof(LCD_MODE_PAGE));
            if (!modeBuffer) {
                ChangerClassFreePool(srb);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(LCD_MODE_PAGE));
            lcdModePage = (PLCD_MODE_PAGE)modeBuffer;
            (PCHAR)lcdModePage += sizeof(MODE_PARAMETER_HEADER);

            lcdModePage->PageCode = 0x22;
            lcdModePage->PageLength = 0x52;
            lcdModePage->SecurityValid = 1;

            //
            // Determine if the panel should be enabled or disabled.
            //

            if (controlOperation == LOCK_ELEMENT) {

                DebugPrint((2,
                           "ChangerSetAccess: Locking keypad\n"));

                lcdModePage->LCDSecurity = 1;

            } else if (controlOperation == UNLOCK_ELEMENT) {

                DebugPrint((2,
                           "ChangerSetAccess: UnLocking keypad\n"));
                lcdModePage->LCDSecurity = 0;

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            //
            // The display line fields will be left as zero and the WriteLine field left off, so that
            // the default text on the display is not changed.
            //

            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->TimeOutValue = 20;
            srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(LCD_MODE_PAGE);
            srb->DataBuffer = modeBuffer;

            cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
            cdb->MODE_SELECT.PFBit = 1;
            cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb->DataTransferLength;

            writeToDevice = TRUE;
        }
        break;

        default:

            status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             writeToDevice);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}


NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // length will be based on whether vol. tags are returned and element type(s).
    //

    if (elementType == AllElements) {


        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }
    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType, TRUE)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        statusPages = 1;
    }

    if (readElementStatus->VolumeTagInfo) {

        //
        // Each descriptor will have an embedded volume tag buffer.
        //

        length = sizeof(ELEMENT_STATUS_HEADER) + (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
                 (EXA_FULL_SIZE * totalElements);
    } else {

        length = sizeof(ELEMENT_STATUS_HEADER) + (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
                 (EXA_PARTIAL_SIZE * totalElements);

    }


    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
       ChangerClassFreePool(statusBuffer);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if ((NT_SUCCESS(status)) || (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PEXA_ELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = totalElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);
  
              return status;
           }
        }
        

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PVOID)statusPage = (PVOID)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);
                                         
        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                    ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                elementStatus->Element.ElementAddress |=
                    (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;


                if (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                    tmpAddress |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Full;
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                    if (changerData->DriveID == EXABYTE_10) {

                        //
                        // If the door was opened and closed, or a reset occurred,
                        // ERROR_LABEL_QUESTIONABLE is returned. This needs to be remapped.
                        //

                        elementStatus->ExceptionCode = ERROR_INIT_STATUS_NEEDED;

                    }
                }

                if (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                    elementStatus->TargetId = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                }
                if (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                    elementStatus->Lun = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Lun;
                }

                if (tagInfo) {
                    RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                                  ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag, MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer and element descriptor array.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }

                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;
        cdb->INIT_ELEMENT_STATUS.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        if (changerData->DriveID == EXABYTE_10) {
            cdb->INIT_ELEMENT_STATUS.NoBarCode = 0;
        }

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        PCHANGER_ELEMENT_LIST elementList = &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = &elementList->Element;

        if (changerData->DriveID == EXABYTE_10) {

            //
            // Only supports normal SCSI Init element status command.
            //

            ChangerClassFreePool(srb);
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Use the exabyte vendor-unique initialize with range command
        //

        srb->CdbLength = CDB10GENERIC_LENGTH;
        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        //
        // Addresses of elements need to be mapped from 0-based to device-specific.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        //
        // Indicate whether to use bar code scanning.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport, TRUE)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType, TRUE)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Exabyte doesn't support 2-sided media.
    //

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the exabyte units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport, TRUE)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType, TRUE)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType, TRUE)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Exabyte doesn't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_ELEMENT transportToHome = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport is within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(transportToHome->ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport, TRUE)) {

        DebugPrint((1,
                   "ChangerReinitialize: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Setting destination equal to the transport, positions the arm out of the way
    // on the Exabyte units.
    //

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(transport & 0xFF);
    cdb->POSITION_TO_ELEMENT.Flip = 0;

    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PCHANGER_SEND_VOLUME_TAG_INFORMATION volTagInfo = Irp->AssociatedIrp.SystemBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_ELEMENT    element = &volTagInfo->StartingElement;
    PSCSI_REQUEST_BLOCK srb;
    PVOID    tagBuffer;
    PCDB     cdb;
    NTSTATUS status;

    //
    // Do some validation.
    //

    if (volTagInfo->ActionCode != SEARCH_PRI_NO_SEQ) {
        DebugPrint((1,
                   "QueryVolumeTags: Invalid Action Code %x\n",
                   volTagInfo->ActionCode));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    tagBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, MAX_VOLUME_TEMPLATE_SIZE);

    if (!srb || !tagBuffer) {

        if (srb) {
            ChangerClassFreePool(srb);
        }
        if (tagBuffer) {
            ChangerClassFreePool(tagBuffer);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(tagBuffer, MAX_VOLUME_TEMPLATE_SIZE);

    //
    // Load buffer with template.
    //

    RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = MAX_VOLUME_TEMPLATE_SIZE;

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->SEND_VOLUME_TAG.OperationCode = SCSIOP_SEND_VOLUME_TAG;
    cdb->SEND_VOLUME_TAG.ElementType = (UCHAR)element->ElementType;

    cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->SEND_VOLUME_TAG.ActionCode = (UCHAR)volTagInfo->ActionCode;


    cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
    cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;


    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         tagBuffer,
                                         MAX_VOLUME_TEMPLATE_SIZE,
                                         TRUE);

    ChangerClassFreePool(tagBuffer);

    if (NT_SUCCESS(status)) {

        PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
        PVOID statusBuffer;
        ULONG returnElements = irpStack->Parameters.DeviceIoControl.OutputBufferLength / sizeof(READ_ELEMENT_ADDRESS_INFO);
        ULONG requestLength;

        //
        // Size of buffer returned is based on the size of the user buffer. If it's incorrectly
        // sized, the IoStatus.Information will be updated to indicate how large it should really be.
        //

        requestLength = sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE) +
                              (EXA_FULL_SIZE * returnElements);

        statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, requestLength);
        if (!statusBuffer) {
            ChangerClassFreePool(srb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(statusBuffer, requestLength);

        //
        // Build read volume element command.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = requestLength;

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.OperationCode = SCSIOP_REQUEST_VOL_ELEMENT;
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.ElementType = (UCHAR)element->ElementType;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[0] = (UCHAR)(returnElements >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[1] = (UCHAR)(returnElements & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.VolTag = 1;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[0] = (UCHAR)(requestLength >> 16);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[1] = (UCHAR)(requestLength >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[2] = (UCHAR)(requestLength & 0xFF);


        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             statusBuffer,
                                             requestLength,
                                             TRUE);


        if ((status == STATUS_SUCCESS) || (status == STATUS_DATA_OVERRUN)) {

            PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
            PELEMENT_STATUS_PAGE   statusPage;
            PCHANGER_ELEMENT_STATUS elementStatus;
            PEXA_ELEMENT_DESCRIPTOR elementDescriptor;
            ULONG i;
            ULONG descriptorLength;
            ULONG numberElements;
            ULONG dataTransferLength = srb->DataTransferLength;

            //
            // Zero the portion of user buffer that is always there.
            //

            RtlZeroMemory(readElementAddressInfo,
                          sizeof(READ_ELEMENT_ADDRESS_INFO));

            //
            // Make it success.
            //

            status = STATUS_SUCCESS;

            //
            // Determine if ANY matches were found.
            //

            numberElements = (statusHeader->NumberOfElements[0] << 8);
            numberElements |= (statusHeader->NumberOfElements[1] & 0xFF);

            DebugPrint((1,
                       "QueryVolumeTags: Matches found - %x\n",
                       numberElements));

            //
            // Update IoStatus.Information to indicate the correct buffer size.
            // Account for the fact that READ_ELEMENT_ADDRESS_INFO is declared
            // with a one-element array of CHANGER_ELEMENT_STATUS.
            //

            Irp->IoStatus.Information = sizeof(READ_ELEMENT_ADDRESS_INFO) +
                                        ((numberElements - 1) *
                                         sizeof(CHANGER_ELEMENT_STATUS));

            //
            // Fill in user buffer.
            //

            readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            RtlZeroMemory(readElementAddressInfo, irpStack->Parameters.DeviceIoControl.OutputBufferLength);

            readElementAddressInfo->NumberOfElements = numberElements;

            if (numberElements) {

                //
                // The buffer is composed of a header, status page, and element descriptors.
                // Point each element to it's respective place in the buffer.
                //

                (PCHAR)statusPage = (PCHAR)statusHeader;
                (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                elementStatus = &readElementAddressInfo->ElementStatus[0];

                //
                // Set values for each element descriptor.
                //

                for (i = 0; i < numberElements; i++ ) {

                    elementStatus->Element.ElementAddress = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -=
                        addressMapping->FirstElement[statusPage->ElementType];

                    elementStatus->Element.ElementType = statusPage->ElementType;

                    if (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.SValid) {

                        ULONG j;
                        USHORT tmpAddress;

                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    }

                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Full;
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                    if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {
                        elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                        if (changerData->DriveID == EXABYTE_10) {

                            //
                            // If the door was opened and closed, or a reset occurred,
                            // ERROR_LABEL_QUESTIONABLE is returned. This needs to be remapped.
                            //

                            elementStatus->ExceptionCode = ERROR_INIT_STATUS_NEEDED;

                        }
                    }

                    if (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                        elementStatus->TargetId = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                    }
                    if (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                        elementStatus->Lun = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Lun;
                    }

                    RtlMoveMemory(elementStatus->PrimaryVolumeID, elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag, MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                    (PCHAR)elementDescriptor += descriptorLength;
                }
            }
        } else {
            DebugPrint((1,
                       "QueryVolumeTags: RequestElementAddress failed. %x\n",
                       status));
        }

        ChangerClassFreePool(statusBuffer);

    } else {
        DebugPrint((1,
                   "QueryVolumeTags: Send Volume Tag failed. %x\n",
                   status));
    }
    if (srb) {
        ChangerClassFreePool(srb);
    }
    return status;
}


NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = EXA_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);


    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;
    }


    //
    // Determine the lowest element address for use with AllElements.
    //

    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {

            DebugPrint((1,
                       "BuildAddressMapping: New lowest address %x\n",
                       addressMapping->FirstElement[i]));
            addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PEXA_ELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asq = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)ElementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.AddSenseCodeQualifier;
    ULONG exceptionCode;

    //
    // On the exabytes, the additional sense code is always 0x83.
    //

    switch (asq) {
        case 0x0:
            exceptionCode = ERROR_LABEL_QUESTIONABLE;
            break;

        case 0x1:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        case 0x2:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        case 0x3:
            exceptionCode = ERROR_LABEL_QUESTIONABLE;
            break;


        case 0x4:
            exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
            break;

        case 0x8:
        case 0x9:
        case 0xA:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType,
    IN BOOLEAN IntrisicElement
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The exabyte's address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == EXA_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    if (IntrisicElement) {
        if (ElementType >= ChangerDoor) {
            DebugPrint((1,
                       "ElementOutOfRange: Specified type not intrinsic. Type %x\n",
                       ElementType));
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\elmsmc\elmsmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    elmsmc.c

Abstract:

    This module contains device-specific routines for ELMS Cd library devices

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "elmsmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ElmsBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the DVL changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //


    status = ElmsBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->VendorId,"Elms", 4) == 4) {
        if (RtlCompareMemory(dataBuffer->ProductId,"DVL",3) == 3) {
            changerData->DriveType = ELMS_CD;
        }
    } else if (RtlCompareMemory(dataBuffer->VendorId,"CYGNET",6) == 6) {

        if (RtlCompareMemory(dataBuffer->ProductId,"ID100",5) == 5) {
            changerData->DriveType = ELMS_CD;
        }
    }


    //
    // Get the Vital Product Data page.
    //

    serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 33);
    if (!serialBuffer) {
        DebugPrint((1, "BuildAddressMapping failed. %x\n", status));

        ChangerClassFreePool(dataBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(serialBuffer, sizeof(SERIALNUMBER));

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set EVPD
    //

    cdb->CDB6INQUIRY.Reserved1 = 1;

    //
    // Unit serial number page.
    //

    cdb->CDB6INQUIRY.PageCode = 0x80;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIALNUMBER);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     serialBuffer,
                                     sizeof(SERIALNUMBER),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        ULONG i;

        RtlMoveMemory(changerData->SerialNumber, serialBuffer->SerialNumber,
                      ELMS_SERIAL_NUMBER_LENGTH);

        DebugPrint((1,"DeviceType - %x\n", serialBuffer->DeviceType));
        DebugPrint((1,"PageCode - %x\n", serialBuffer->PageCode));
        DebugPrint((1,"Length - %x\n", serialBuffer->PageLength));

        DebugPrint((1,"Serial number "));

        for (i = 0; i < ELMS_SERIAL_NUMBER_LENGTH; i++) {
            DebugPrint((1,"%x", serialBuffer->SerialNumber[i]));
        }

        DebugPrint((1,"\n"));

    }


    ChangerClassFreePool(serialBuffer);
    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    ULONG deviceStatus;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       switch (senseBuffer->SenseKey) {
           case SCSI_SENSE_NOT_READY:
               if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY) &&
                   (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED)) {
   
                   //
                   // Indicate that the door is open.
                   //
   
                   *Status = STATUS_DEVICE_DOOR_OPEN;
               }
               break;
   
       case SCSI_SENSE_HARDWARE_ERROR:
               deviceStatus = ELMS_HW_ERROR;

               switch (senseBuffer->AdditionalSenseCode) {
                  case ELMS_ASC_CHM_MOVE_ERROR: {
                     deviceStatus = ELMS_CHM_MOVE_ERROR;
                     break;
                  }

                  case ELMS_ASC_CARRIAGE_OR_BARCODE_FAILURE:  {
                     if ((senseBuffer->AdditionalSenseCodeQualifier) == 
                         ELMS_ASCQ_CARRIAGE_FAILURE) {
                        deviceStatus = ELMS_CHM_ERROR;
                     } else if ((senseBuffer->AdditionalSenseCodeQualifier) == 
                                ELMS_ASCQ_BARCODE_READER_FAILURE) {
                                deviceStatus = ELMS_HW_ERROR;
                     }
                  }

                  case ELMS_ASC_MECHANICAL_ERROR: {
                     deviceStatus = ELMS_HW_ERROR;
                     break;
                  }

                  case ELMS_ASC_DIAGNOSTIC_FAILURE: {
                     switch (senseBuffer->AdditionalSenseCodeQualifier) {
                        case ELMS_ASCQ_DOOR_OPEN: {
                           *Status = STATUS_DEVICE_DOOR_OPEN;
                           deviceStatus = ELMS_DOOR_OPEN;
                           break;
                        }

                        case ELMS_ASCQ_ELEVATOR_BLOCKED: {
                           deviceStatus = ELMS_CHM_MOVE_ERROR;
                           break;
                        }

                        case ELMS_ASCQ_DRIVE_TRAY_OPEN: {
                           deviceStatus = ELMS_DRIVE_ERROR;
                           break;
                        }

                        case ELMS_ASCQ_ELEVATOR_FAILURE: {
                           deviceStatus = ELMS_CHM_ERROR;
                           break;
                        }
                        
                        default:    {
                           deviceStatus = ELMS_HW_ERROR;
                           break;
                        }
                     } // switch (senseBuffer->AdditionalSenseCodeQualifier)

                     break;
                  }

                  default: {
                     deviceStatus = ELMS_HW_ERROR;
                     break;
                  }
               } // switch (senseBuffer->AdditionalSenseCode)   

               changerData->DeviceStatus = deviceStatus;
               DebugPrint((1, "HardwareError - SenseKey %x, ASC %x, ASCQ %x\n",
                           senseBuffer->SenseKey,
                           senseBuffer->AdditionalSenseCode,
                           senseBuffer->AdditionalSenseCodeQualifier));
               break;
   
           case SCSI_SENSE_UNIT_ATTENTION:
   
               if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_POSITION_ERROR) {
                   if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {
   
                       DebugPrint((1,
                                   "Elmsmc: The specified source element has no media\n"));
   
                       //
                       // The indicated source address has no media.
                       //
   
                       *Status = STATUS_SOURCE_ELEMENT_EMPTY;
   
                   } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {
   
                       DebugPrint((1,
                                   "Elmsmc: The specified destination element already has media.\n"));
                       //
                       // The indicated destination already contains media.
                       //
   
                       *Status = STATUS_DESTINATION_ELEMENT_FULL;
                   } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_ELMS_UNIQUE) {
   
                       DebugPrint((1,
                                   "Elmsmc: The specified element is contained in a magazine no longer present.\n"));
   
                       *Status = STATUS_MAGAZINE_NOT_PRESENT;
                   }
   
               } else if (senseBuffer->AdditionalSenseCode == 0x5A) {
                   if (senseBuffer->AdditionalSenseCodeQualifier == 0x80) {
                       *Status = STATUS_DEVICE_DOOR_OPEN;
   
                   }
               }
   
           break;
   
       }
    }
    
    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    DVL changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    //
    // The actual value should be that of above, but the magazines are considered IEPORTs.
    // For above layers to function properly, make this zero.
    //

    changerParameters->NumberIEElements = 0;

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        //
        // See note concerning IEPorts, above.
        //

        addressMapping->FirstElement[ChangerIEPort] = 0;

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = ELMS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->MagazineSize = 20;
    changerParameters->DriveCleanTimeout = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_POSITION_TO_ELEMENT         |
                                   CHANGER_PREDISMOUNT_EJECT_REQUIRED  |
                                   CHANGER_PREMOUNT_EJECT_REQUIRED     |
                                   CHANGER_CARTRIDGE_MAGAZINE          |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE |
                                   CHANGER_SERIAL_NUMBER_VALID;

    changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE | CHANGER_TO_SLOT);

    //
    // build device caps mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;



    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, ELMS_SERIAL_NUMBER_LENGTH);

    //
    // Indicate drive type.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort/ Front panel.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{


    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // Another verification of parameters.
    //

    if (readElementStatus->ElementList.NumberOfElements < 1) {
        return STATUS_INVALID_PARAMETER;
    }

    if (readElementStatus->VolumeTagInfo) {

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements) {

        ULONG i;
        ULONG totalElements = 0;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;

            //
            // Add these up instead of using the number passed in the user's buffer, as the driver
            // fakes that there are no IEPorts.
            //

            totalElements += addressMapping->NumberOfElements[i];
        }

        //
        // Account for length of the descriptors expected for the slots.
        //

        length = (sizeof(ELMS_STORAGE_ELEMENT_DESCRIPTOR))*
                        addressMapping->NumberOfElements[ChangerSlot];

        //
        // Add in length of descriptors for the other element types.
        //

        length += (sizeof(ELMS_ELEMENT_DESCRIPTOR)) *
                      (totalElements - addressMapping->NumberOfElements[ChangerSlot]);

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {

        if (elementType == ChangerSlot) {
            length = (sizeof(ELMS_STORAGE_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);
        } else {
            length = (sizeof(ELMS_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);
        }

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // The DVL's may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (typeCount > ((LONG)descriptorLength * remainingElements)) {

            //
            // Handle a problem with earlier FW revs.
            //

            DebugPrint((1,
                        "ChangerGetElementStatus: DescriptorByteCount is hosed. Claimed: %x",
                        typeCount));

            typeCount = descriptorLength * remainingElements;

            DebugPrint((1," Actual: %x\n", typeCount));
        }

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // The device claims it has IEPorts, but the driver claims otherwise.
                // Throw away any of these.
                //

                if (elementType != ChangerIEPort) {

                    //
                    // Get the address for this element.
                    //

                    elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                    //
                    // Set the element type.
                    //

                    elementStatus->Element.ElementType = elementType;
                    elementStatus->Flags = 0;

                    //
                    // Zero these first.
                    //

                    elementStatus->SrcElementAddress.ElementAddress = 0;
                    elementStatus->SrcElementAddress.ElementType = 0;

                    if (elementType == ChangerDrive) {

                        //
                        // Source address
                        //

                        if (elementDescriptor->SValid) {

                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                        }

                        if (elementDescriptor->IdValid) {
                            elementStatus->TargetId = elementDescriptor->BusAddress;
                        }
                        if (elementDescriptor->LunValid) {
                            elementStatus->Lun = elementDescriptor->Lun;
                        }
                    }

                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags |= elementDescriptor->Full;
                    elementStatus->Flags |= (elementDescriptor->Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                    if (elementType == ChangerDrive) {

                        elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                        elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                        elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                        elementStatus->Flags |= (elementDescriptor->Invert << 22);
                        elementStatus->Flags |= (elementDescriptor->SValid << 23);

                    }

                    //
                    // Map the exceptions.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                    //
                    // Work around for FW.
                    //

                    if ((elementDescriptor->AddSenseCodeQualifier == 0x0E) && (elementDescriptor->AdditionalSenseCode == 0x3B)) {

                        DebugPrint((1,
                                   "Elmsmc: elementStatus reports no media as exception\n"));

                        //
                        // This indicates no media in tray. Turn off the exception and ensure the Full flag is 0.
                        //

                        elementStatus->Flags &= ~ELEMENT_STATUS_EXCEPT;
                        elementStatus->Flags &= ~ELEMENT_STATUS_FULL;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                if (elementType != ChangerIEPort) {

                    //
                    // Don't advance user buffer for IEPorts
                    //

                    elementStatus += 1;
                }
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Verify transport and dest. are within range.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    if ((setPosition->Destination.ElementType > ChangerDrive) ||
        (setPosition->Destination.ElementType == ChangerIEPort) ||
        (setPosition->Destination.ElementType == ChangerTransport)) {

        //
        // Though positioning to IEPorts is valid from the mechanism point of view
        // we claim there are none on these devices, so don't allow this.
        //

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the elms units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ElmsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = ELMS_NO_ELEMENT;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = ELMS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;
    ULONG exceptionCode = 0;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x3B:
            if (ascq == 0x0E) {

                //
                // This should only be 'til the FW is fixed, though may keep it around
                // for legacy cases.
                //

                DebugPrint((1,
                           "Elmsmc: FW reports no media as exception\n"));
                exceptionCode = 0;

            } else if (ascq == 0x82) {
                exceptionCode = ERROR_SLOT_NOT_PRESENT;

            } else if (ascq == 0x84) {
                exceptionCode = ERROR_TRAY_MALFUNCTION;

            }
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "Elmsmc: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == ELMS_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to ELMS_DEVICE_PROBLEM_NONE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set an appropriate devicestatus.
   //
   changerData->DeviceStatus = ELMS_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "ELMSMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set the SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != ELMS_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
               case ELMS_HW_ERROR: {
                  changerDeviceError->ChangerProblemType = DeviceProblemHardware;
                  break;
               }

               case ELMS_CHM_MOVE_ERROR: {
                  changerDeviceError->ChangerProblemType = DeviceProblemCHMMoveError;
                  break;
               }

               case ELMS_DOOR_OPEN: {
                  changerDeviceError->ChangerProblemType = DeviceProblemDoorOpen;
                  break;
               }

               case ELMS_DRIVE_ERROR: {
                  changerDeviceError->ChangerProblemType = DeviceProblemDriveError;
                  break;
               }

               case ELMS_CHM_ERROR: {
                  changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
                  break;
               }

               default: {
                  changerDeviceError->ChangerProblemType = DeviceProblemHardware;
                  break;
               }
      } // switch (changerData->DeviceStatus) 
   }

   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\hpmc\hpmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    hpmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _HP_MC_
#define _HP_MC_

typedef struct _HPMO_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
} HPMO_ELEMENT_DESCRIPTOR, *PHPMO_ELEMENT_DESCRIPTOR;

typedef struct _HPMO_DATA_XFER_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} HPMO_DATA_XFER_ELEMENT_DESCRIPTOR, *PHPMO_DATA_XFER_ELEMENT_DESCRIPTOR;

typedef struct _HPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR VolumeTagInformation[36];
    UCHAR CodeSet : 4;
    UCHAR Reserved10 : 4;
    UCHAR IDType : 4;
    UCHAR Reserved11 : 4;
    UCHAR Reserved12;
    UCHAR IDLength;
    UCHAR VendorID[VENDOR_ID_LENGTH];
    UCHAR ProductID[PRODUCT_ID_LENGTH];
    UCHAR SerialNumber[SERIAL_NUMBER_LENGTH];
} HPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS, *PHPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS;


typedef struct _HPMO_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Reserved6[3];
    UCHAR Reserved7 : 7;
    UCHAR SValid : 1;
    UCHAR SourceElementAddress[2];
    UCHAR VolumeTagInformation[36];
} HPMO_ELEMENT_DESCRIPTOR_PLUS, *PHPMO_ELEMENT_DESCRIPTOR_PLUS;

typedef struct _PLASMON_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} PLASMON_ELEMENT_DESCRIPTOR, *PPLASMON_ELEMENT_DESCRIPTOR;

#define SCSIOP_ROTATE_MAILSLOT 0x0C

#define HP_MAILSLOT_OPEN       0x01
#define HP_MAILSLOT_CLOSE      0x00

#define HP_NO_ELEMENT          0xFFFF

//
// Diagnostic related defines
//
#define HPMC_DEVICE_PROBLEM_NONE     0x00
#define HPMC_HW_ERROR                0x01

typedef struct _HPMC_RECV_DIAG {
    UCHAR Reserved;
    UCHAR HWErrorCode;
    UCHAR FRU_1;
    UCHAR FRU_2;
    UCHAR FRU_3;
    UCHAR TestNumber;
    UCHAR Parameters[8];
} HPMC_RECV_DIAG, *PHPMC_RECV_DIAG;


#define HP_MO  1
#define HP_DLT 2

#define HP1194   1
#define HP1100   2
#define HP1160   3
#define HP1718   4
#define HP5151   5
#define HP5153   6
#define HP418    7
#define PLASMON  8
#define PINNACLE 9
#define HP7000   10


// Device features
#define DEVICE_DOOR (L"DeviceHasDoor")
#define DEVICE_IEPORT_USER_CLOSE (L"IEPortUserClose")

// Device names
#define HPMC_MEDIUM_CHANGER (L"HPMC")


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Device Status after send diagnostic is completed
    //
    ULONG DeviceStatus;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As the HP units lock the IEPort on these operations
    // MoveMedium/SetAccess might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // Indicate whether to worry about the IEPort getting locked
    // down when a Prevent is sent.
    //

    ULONG DeviceLocksPort;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
HpmoBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

VOID ScanForSpecial(
    IN PDEVICE_OBJECT DeviceObject,
    IN PGET_CHANGER_PARAMETERS ChangerParameters
    );

VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer,
    IN ULONG changerId
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\jvcmc\jvcmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    jvcmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _JVC_MC_
#define _JVC_MC_

typedef struct _JVC_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR ExEnable : 1;
    UCHAR InEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 7;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
    UCHAR Tray : 1;
    UCHAR IEPortOpen : 1;
    UCHAR Reserved11 : 6;
    UCHAR Reserved12;
} JVC_ELEMENT_DESCRIPTOR, *PJVC_ELEMENT_DESCRIPTOR;

typedef struct _JVC_INIT_ELEMENT_RANGE {
    UCHAR OperationCode;
    UCHAR Form : 2;
    UCHAR Reserved1 : 3;
    UCHAR LogicalUnitNumber : 3;
    UCHAR FirstElementAddress[2];
    UCHAR LastElementAddress[2];
    UCHAR Reserved2[4];
} JVC_INIT_ELEMENT_RANGE, *PJVC_INIT_ELEMENT_RANGE;

#define JVC_INIT_ELEMENT  0xE7
#define INIT_ALL_ELEMENTS 0x00
#define INIT_SPECIFIED_RANGE 0x02

#define JVC_NO_ELEMENT 0xFFFF


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As the Sony units lock the IEPort on these operations
    // MoveMedium/SetAccess might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // Flag to indicate if the changer returned 
    // sense code SCSI_SENSE_HARDWARE_ERROR
    //
    BOOLEAN HardwareError;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
JVCBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\m4mc\m4mc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    m4mc.c

Abstract:

    This module contains device-specific routines for M4 Data medium changers:
    Magfile.

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "m4mc.h"


#define MAGFILE   1
#define M1500     2

#define M4DATA_SERIAL_NUMBER_LENGTH 10

typedef struct _CHANGER_ADDRESS_MAPPING
{

  //
  // Indicates the first element for each element type.
  // Used to map device-specific values into the 0-based
  // values that layers above expect.
  //

  USHORT FirstElement[ChangerMaxElement];

  //
  // Indicates the number of each element type.
  //

  USHORT NumberOfElements[ChangerMaxElement];

  //
  // Indicates that the address mapping has been
  // completed successfully.
  //

  BOOLEAN Initialized;

}
CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA
{

  //
  // Size, in bytes, of the structure.
  //

  ULONG Size;

  //
  // Unique identifier for the supported models. See above.
  //

  ULONG DriveID;

  //
  // See Address mapping structure above.
  //

  CHANGER_ADDRESS_MAPPING AddressMapping;

  //
  // Cached unique serial number.
  //

  UCHAR SerialNumber[M4DATA_SERIAL_NUMBER_LENGTH];

  //
  // Cached inquiry data.
  //

  INQUIRYDATA InquiryData;

}
CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS M4BuildAddressMapping (IN PDEVICE_OBJECT DeviceObject);

ULONG MapExceptionCodes (IN PM4_ELEMENT_DESCRIPTOR ElementDescriptor);

BOOLEAN
ElementOutOfRange (IN PCHANGER_ADDRESS_MAPPING AddressMap,
           IN USHORT ElementOrdinal,
           IN ELEMENT_TYPE ElementType, IN BOOLEAN IntrinsicElement);


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = NULL;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath,
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize (VOID)
/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the magfile changers.

Arguments:


Return Value:

    Size, in bytes.

--*/
{

  return sizeof (CHANGER_DATA);
}

typedef struct _SERIALNUMBER
{
  UCHAR DeviceType;
  UCHAR PageCode;
  UCHAR Reserved;
  UCHAR PageLength;
  UCHAR SerialNumber[10];
}
SERIALNUMBER, *PSERIALNUMBER;


NTSTATUS
ChangerInitialize (IN PDEVICE_OBJECT DeviceObject)
{
  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  NTSTATUS status;
  PINQUIRYDATA dataBuffer;
  PSERIALNUMBER serialBuffer;
  PCDB cdb;
  ULONG length;
  SCSI_REQUEST_BLOCK srb;

  changerData->Size = sizeof (CHANGER_DATA);

  //
  // Build address mapping.
  //

  status = M4BuildAddressMapping (DeviceObject);
  if (!NT_SUCCESS (status))
    {
      DebugPrint ((1, "BuildAddressMapping failed. %x\n", status));
      return status;
    }

  //
  // Get inquiry data.
  //

  dataBuffer =
    ChangerClassAllocatePool (NonPagedPoolCacheAligned, sizeof (INQUIRYDATA));
  if (!dataBuffer)
    {
      DebugPrint ((1,
           "M4mc.ChangerInitialize: Error allocating dataBuffer. %x\n",
           status));
      return STATUS_INSUFFICIENT_RESOURCES;
    }

  //
  // Now get the full inquiry information for the device.
  //

  RtlZeroMemory (&srb, SCSI_REQUEST_BLOCK_SIZE);

  //
  // Set timeout value.
  //

  srb.TimeOutValue = 10;

  srb.CdbLength = 6;

  cdb = (PCDB) srb.Cdb;

  //
  // Set CDB operation code.
  //

  cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

  //
  // Set allocation length to inquiry data buffer size.
  //

  cdb->CDB6INQUIRY.AllocationLength = sizeof (INQUIRYDATA);

  status = ChangerClassSendSrbSynchronous (DeviceObject,
                    &srb,
                    dataBuffer, sizeof (INQUIRYDATA), FALSE);

  if (SRB_STATUS (srb.SrbStatus) == SRB_STATUS_SUCCESS ||
      SRB_STATUS (srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN)
    {

      //
      // Updated the length actually transfered.
      //

      length =
    dataBuffer->AdditionalLength + FIELD_OFFSET (INQUIRYDATA, Reserved);

      if (length > srb.DataTransferLength)
    {
      length = srb.DataTransferLength;
    }


      RtlMoveMemory (&changerData->InquiryData, dataBuffer, length);

      //
      // Determine drive id.
      //

      if (RtlCompareMemory (dataBuffer->ProductId, "MagFile", 7) == 7)
    {
      changerData->DriveID = MAGFILE;
    }
      else if (RtlCompareMemory (dataBuffer->ProductId, "1500", 4) == 4)
    {
      changerData->DriveID = M1500;
    }
    }

  serialBuffer = ChangerClassAllocatePool (NonPagedPoolCacheAligned, sizeof(SERIALNUMBER));
  if (!serialBuffer)
    {

      ChangerClassFreePool (dataBuffer);

      DebugPrint ((1,
           "M4mc.ChangerInitialize: Error allocating serial number buffer. %x\n",
           status));

      return STATUS_INSUFFICIENT_RESOURCES;
    }

  RtlZeroMemory (serialBuffer, sizeof(SERIALNUMBER));

  //
  // Get serial number page.
  //

  RtlZeroMemory (&srb, SCSI_REQUEST_BLOCK_SIZE);

  //
  // Set timeout value.
  //

  srb.TimeOutValue = 10;

  srb.CdbLength = 6;

  cdb = (PCDB) srb.Cdb;

  //
  // Set CDB operation code.
  //

  cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

  //
  // Set EVPD
  //

  cdb->CDB6INQUIRY.Reserved1 = 1;

  //
  // Unit serial number page.
  //

  cdb->CDB6INQUIRY.PageCode = 0x80;

  //
  // Set allocation length to inquiry data buffer size.
  //

  cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIALNUMBER);

  status = ChangerClassSendSrbSynchronous (DeviceObject,
                    &srb, serialBuffer, sizeof(SERIALNUMBER), FALSE);

  if (SRB_STATUS (srb.SrbStatus) == SRB_STATUS_SUCCESS ||
      SRB_STATUS (srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN)
    {

      ULONG i;

      RtlMoveMemory (changerData->SerialNumber,
             serialBuffer->SerialNumber, M4DATA_SERIAL_NUMBER_LENGTH);

      DebugPrint ((1, "DeviceType - %x\n", serialBuffer->DeviceType));
      DebugPrint ((1, "PageCode - %x\n", serialBuffer->PageCode));
      DebugPrint ((1, "Length - %x\n", serialBuffer->PageLength));

      DebugPrint ((1, "Serial number "));

      for (i = 0; i < 10; i++)
      {
      DebugPrint ((1, "%x", serialBuffer->SerialNumber[i]));
      }

      DebugPrint ((1, "\n"));

    }

  ChangerClassFreePool (serialBuffer);


  ChangerClassFreePool (dataBuffer);

  return STATUS_SUCCESS;
}


VOID
ChangerError (PDEVICE_OBJECT DeviceObject,
          PSCSI_REQUEST_BLOCK Srb, NTSTATUS * Status, BOOLEAN * Retry)
/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

  PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
  PIRP irp = Srb->OriginalRequest;

  if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)
    {

      switch (senseBuffer->SenseKey & 0xf)
    {

    case SCSI_SENSE_NOT_READY:

      if (senseBuffer->AdditionalSenseCode == 0x04)
        {
          switch (senseBuffer->AdditionalSenseCodeQualifier)
        {
        case 0x83:

          *Retry = FALSE;
          *Status = STATUS_DEVICE_DOOR_OPEN;
          break;

        case 0x85:
          *Retry = FALSE;
          *Status = STATUS_DEVICE_DOOR_OPEN;
          break;
        }
        }

      break;

    case SCSI_SENSE_ILLEGAL_REQUEST:
      if (senseBuffer->AdditionalSenseCode == 0x80)
        {
          switch (senseBuffer->AdditionalSenseCodeQualifier)
        {
        case 0x03:
        case 0x04:

          *Retry = FALSE;
          *Status = STATUS_MAGAZINE_NOT_PRESENT;
          break;
        case 0x05:
        case 0x06:
          *Retry = TRUE;
          *Status = STATUS_DEVICE_NOT_CONNECTED;
          break;
        default:
          break;
        }
        }
      else if ((senseBuffer->AdditionalSenseCode == 0x91)
           && (senseBuffer->AdditionalSenseCodeQualifier == 0x00))
        {
          *Status = STATUS_TRANSPORT_FULL;

        }
      break;

    case SCSI_SENSE_UNIT_ATTENTION:
      if ((senseBuffer->AdditionalSenseCode == 0x28) &&
          (senseBuffer->AdditionalSenseCodeQualifier == 0x0))
        {

          //
          // Indicate that the door was opened and reclosed.
          //

          *Status = STATUS_MEDIA_CHANGED;
          *Retry = FALSE;
        }

      break;

    default:
      break;
    }
    }


  return;
}

NTSTATUS
ChangerGetParameters (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    magfile changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
  PSCSI_REQUEST_BLOCK srb;
  PGET_CHANGER_PARAMETERS changerParameters;
  PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
  PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
  PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
  NTSTATUS status;
  ULONG length;
  PVOID modeBuffer;
  PCDB cdb;

  srb = ChangerClassAllocatePool (NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

  if (srb == NULL)
    {

      return STATUS_INSUFFICIENT_RESOURCES;
    }

  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);
  cdb = (PCDB) srb->Cdb;

  //
  // Build a mode sense - Element address assignment page.
  //

  modeBuffer =
    ChangerClassAllocatePool (NonPagedPoolCacheAligned,
                  sizeof (MODE_PARAMETER_HEADER) +
                  sizeof (MODE_ELEMENT_ADDRESS_PAGE));
  if (!modeBuffer)
    {
      ChangerClassFreePool (srb);
      return STATUS_INSUFFICIENT_RESOURCES;
    }


  RtlZeroMemory (modeBuffer,
         sizeof (MODE_PARAMETER_HEADER) +
         sizeof (MODE_ELEMENT_ADDRESS_PAGE));
  srb->CdbLength = CDB6GENERIC_LENGTH;
  srb->TimeOutValue = 20;
  srb->DataTransferLength =
    sizeof (MODE_PARAMETER_HEADER) + sizeof (MODE_ELEMENT_ADDRESS_PAGE);
  srb->DataBuffer = modeBuffer;

  cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
  cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
  cdb->MODE_SENSE.Dbd = 1;
  cdb->MODE_SENSE.AllocationLength = (UCHAR) srb->DataTransferLength;

  //
  // Send the request.
  //

  status = ChangerClassSendSrbSynchronous (DeviceObject,
                    srb,
                    srb->DataBuffer,
                    srb->DataTransferLength, FALSE);

  if (!NT_SUCCESS (status))
    {
      ChangerClassFreePool (srb);
      ChangerClassFreePool (modeBuffer);
      return status;
    }

  //
  // Fill in values.
  //

  changerParameters = Irp->AssociatedIrp.SystemBuffer;
  RtlZeroMemory (changerParameters, sizeof (GET_CHANGER_PARAMETERS));

  elementAddressPage = modeBuffer;
  (PCHAR) elementAddressPage += sizeof (MODE_PARAMETER_HEADER);

  changerParameters->Size = sizeof (GET_CHANGER_PARAMETERS);
  changerParameters->NumberTransportElements =
    elementAddressPage->NumberTransportElements[1];
  changerParameters->NumberTransportElements |=
    (elementAddressPage->NumberTransportElements[0] << 8);

  changerParameters->NumberStorageElements =
    elementAddressPage->NumberStorageElements[1];
  changerParameters->NumberStorageElements |=
    (elementAddressPage->NumberStorageElements[0] << 8);

  changerParameters->NumberIEElements =
    elementAddressPage->NumberIEPortElements[1];
  changerParameters->NumberIEElements |=
    (elementAddressPage->NumberIEPortElements[0] << 8);

  //
  // If there are no IEPorts, then that slot is 
  // counted as data slot. But, since the last
  // slot is inaccessbile, we do not count them
  // Do the required adjustment here
  //
  if (changerParameters->NumberIEElements == 0) {
      USHORT tmpValue;
 
      tmpValue = changerParameters->NumberStorageElements;

      changerParameters->NumberStorageElements = tmpValue - (tmpValue % 20);

  }

  changerParameters->NumberDataTransferElements =
    elementAddressPage->NumberDataXFerElements[1];
  changerParameters->NumberDataTransferElements |=
    (elementAddressPage->NumberDataXFerElements[0] << 8);

  changerParameters->NumberOfDoors = 1;
  changerParameters->NumberCleanerSlots = 1;

  changerParameters->FirstSlotNumber = 0;
  changerParameters->FirstDriveNumber = 0;
  changerParameters->FirstTransportNumber = 0;
  changerParameters->FirstIEPortNumber = 0;
  changerParameters->FirstCleanerSlotAddress = 0;

  changerParameters->MagazineSize = 10;
  changerParameters->DriveCleanTimeout = 300;

  //
  // Free buffer.
  //

  ChangerClassFreePool (modeBuffer);

  //
  // build transport geometry mode sense.
  //

  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);
  cdb = (PCDB) srb->Cdb;

  modeBuffer =
    ChangerClassAllocatePool (NonPagedPoolCacheAligned,
                  sizeof (MODE_PARAMETER_HEADER) +
                  sizeof (MODE_PAGE_TRANSPORT_GEOMETRY));
  if (!modeBuffer)
    {
      ChangerClassFreePool (srb);
      return STATUS_INSUFFICIENT_RESOURCES;
    }


  RtlZeroMemory (modeBuffer,
         sizeof (MODE_PARAMETER_HEADER) +
         sizeof (MODE_TRANSPORT_GEOMETRY_PAGE));
  srb->CdbLength = CDB6GENERIC_LENGTH;
  srb->TimeOutValue = 20;
  srb->DataTransferLength =
    sizeof (MODE_PARAMETER_HEADER) + sizeof (MODE_TRANSPORT_GEOMETRY_PAGE);
  srb->DataBuffer = modeBuffer;

  cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
  cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
  cdb->MODE_SENSE.Dbd = 1;
  cdb->MODE_SENSE.AllocationLength = (UCHAR) srb->DataTransferLength;

  //
  // Send the request.
  //

  status = ChangerClassSendSrbSynchronous (DeviceObject,
                    srb,
                    srb->DataBuffer,
                    srb->DataTransferLength, FALSE);

  if (!NT_SUCCESS (status))
    {
      ChangerClassFreePool (srb);
      ChangerClassFreePool (modeBuffer);
      return status;
    }

  changerParameters = Irp->AssociatedIrp.SystemBuffer;
  transportGeometryPage = modeBuffer;
  (PCHAR) transportGeometryPage += sizeof (MODE_PARAMETER_HEADER);

  //
  // Determine if mc has 2-sided media.
  //

  changerParameters->Features0 =
    transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

  //
  // M4 indicates whether a bar-code scanner is
  // attached by setting bit-0 in this byte.
  //

  changerParameters->Features0 |=
    ((changerData->InquiryData.
      VendorSpecific[19] & 0x1)) ? CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;

  changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_DOOR | LOCK_UNLOCK_IEPORT);
  changerParameters->PositionCapabilities = 0;


  //
  // Features based on manual, nothing programatic.
  //

  changerParameters->Features0 |= CHANGER_STATUS_NON_VOLATILE |
    CHANGER_INIT_ELEM_STAT_WITH_RANGE |
    CHANGER_CLEANER_SLOT |
    CHANGER_LOCK_UNLOCK |
    CHANGER_CARTRIDGE_MAGAZINE |
    CHANGER_PREDISMOUNT_EJECT_REQUIRED |
    CHANGER_DRIVE_CLEANING_REQUIRED |
    CHANGER_SERIAL_NUMBER_VALID;

  //
  // Free buffer.
  //

  ChangerClassFreePool (modeBuffer);

  //
  // build transport geometry mode sense.
  //


  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);
  cdb = (PCDB) srb->Cdb;

  length =
    sizeof (MODE_PARAMETER_HEADER) + sizeof (MODE_DEVICE_CAPABILITIES_PAGE);

  modeBuffer = ChangerClassAllocatePool (NonPagedPoolCacheAligned, length);

  if (!modeBuffer)
    {
      ChangerClassFreePool (srb);
      return STATUS_INSUFFICIENT_RESOURCES;
    }

  RtlZeroMemory (modeBuffer, length);
  srb->CdbLength = CDB6GENERIC_LENGTH;
  srb->TimeOutValue = 20;
  srb->DataTransferLength = length;
  srb->DataBuffer = modeBuffer;

  cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
  cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
  cdb->MODE_SENSE.Dbd = 1;
  cdb->MODE_SENSE.AllocationLength = (UCHAR) srb->DataTransferLength;

  //
  // Send the request.
  //

  status = ChangerClassSendSrbSynchronous (DeviceObject,
                    srb,
                    srb->DataBuffer,
                    srb->DataTransferLength, FALSE);

  if (!NT_SUCCESS (status))
    {
      ChangerClassFreePool (srb);
      ChangerClassFreePool (modeBuffer);
      return status;
    }

  //
  // Get the systembuffer and by-pass the mode header for the mode sense data.
  //

  changerParameters = Irp->AssociatedIrp.SystemBuffer;
  capabilitiesPage = modeBuffer;
  (PCHAR) capabilitiesPage += sizeof (MODE_PARAMETER_HEADER);

  //
  // Fill in values in Features that are contained in this page.
  //

  changerParameters->Features0 |=
    capabilitiesPage->MediumTransport ? CHANGER_STORAGE_TRANSPORT : 0;
  changerParameters->Features0 |=
    capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
  changerParameters->Features0 |=
    capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
  changerParameters->Features0 |=
    capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

  //
  // Determine all the move from and exchange from capabilities of this device.
  //

  changerParameters->MoveFromTransport =
    capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
  changerParameters->MoveFromTransport |=
    capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
  changerParameters->MoveFromTransport |=
    capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
  changerParameters->MoveFromTransport |=
    capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

  changerParameters->MoveFromSlot =
    capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
  changerParameters->MoveFromSlot |=
    capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
  changerParameters->MoveFromSlot |=
    capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
  changerParameters->MoveFromSlot |=
    capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

  changerParameters->MoveFromIePort =
    capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
  changerParameters->MoveFromIePort |=
    capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
  changerParameters->MoveFromIePort |=
    capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
  changerParameters->MoveFromIePort |=
    capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

  changerParameters->MoveFromDrive =
    capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
  changerParameters->MoveFromDrive |=
    capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
  changerParameters->MoveFromDrive |=
    capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
  changerParameters->MoveFromDrive |=
    capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

  changerParameters->ExchangeFromTransport =
    capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
  changerParameters->ExchangeFromTransport |=
    capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
  changerParameters->ExchangeFromTransport |=
    capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
  changerParameters->ExchangeFromTransport |=
    capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

  changerParameters->ExchangeFromSlot =
    capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
  changerParameters->ExchangeFromSlot |=
    capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
  changerParameters->ExchangeFromSlot |=
    capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
  changerParameters->ExchangeFromSlot |=
    capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

  changerParameters->ExchangeFromIePort =
    capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
  changerParameters->ExchangeFromIePort |=
    capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
  changerParameters->ExchangeFromIePort |=
    capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
  changerParameters->ExchangeFromIePort |=
    capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

  changerParameters->ExchangeFromDrive =
    capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
  changerParameters->ExchangeFromDrive |=
    capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
  changerParameters->ExchangeFromDrive |=
    capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
  changerParameters->ExchangeFromDrive |=
    capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;


  ChangerClassFreePool (srb);
  ChangerClassFreePool (modeBuffer);

  Irp->IoStatus.Information = sizeof (GET_CHANGER_PARAMETERS);

  return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PSCSI_REQUEST_BLOCK srb;
  PCDB cdb;
  NTSTATUS status;

  srb = ChangerClassAllocatePool (NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

  if (!srb)
    {

      return STATUS_INSUFFICIENT_RESOURCES;
    }

  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);
  cdb = (PCDB) srb->Cdb;

  //
  // Build TUR.
  //

  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);
  cdb = (PCDB) srb->Cdb;

  srb->CdbLength = CDB6GENERIC_LENGTH;
  cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
  srb->TimeOutValue = 20;

  //
  // Send SCSI command (CDB) to device
  //

  status = ChangerClassSendSrbSynchronous (DeviceObject, srb, NULL, 0, FALSE);

  ChangerClassFreePool (srb);
  return status;
}


NTSTATUS
ChangerGetProductData (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

  RtlZeroMemory (productData, sizeof (CHANGER_PRODUCT_DATA));

  //
  // Copy cached inquiry data fields into the system buffer.
  //
  RtlMoveMemory (productData->VendorId, changerData->InquiryData.VendorId,
                 VENDOR_ID_LENGTH);
  RtlMoveMemory (productData->ProductId, changerData->InquiryData.ProductId,
                 PRODUCT_ID_LENGTH);
  RtlMoveMemory (productData->Revision, changerData->InquiryData.ProductRevisionLevel,
                 REVISION_LENGTH);
  RtlMoveMemory (productData->SerialNumber, changerData->SerialNumber,
                 M4DATA_SERIAL_NUMBER_LENGTH);

  //
  // Indicate that this is a tape changer and that media isn't two-sided.
  //

  productData->DeviceType = MEDIUM_CHANGER;

  Irp->IoStatus.Information = sizeof (CHANGER_PRODUCT_DATA);
  return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine sets the state of the door or IEPort. Value can be one of the
    following:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
  PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
  ULONG controlOperation = setAccess->Control;
  NTSTATUS status = STATUS_SUCCESS;
  PSCSI_REQUEST_BLOCK srb;
  PCDB cdb;
  BOOLEAN writeToDevice = FALSE;


  if (ElementOutOfRange
      (addressMapping, (USHORT) setAccess->Element.ElementAddress,
       setAccess->Element.ElementType, FALSE))
    {
      DebugPrint ((1, "ChangerSetAccess: Element out of range.\n"));

      return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

  srb = ChangerClassAllocatePool (NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

  if (!srb)
    {

      return STATUS_INSUFFICIENT_RESOURCES;
    }

  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);
  cdb = (PCDB) srb->Cdb;

  srb->CdbLength = CDB6GENERIC_LENGTH;
  cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

  srb->DataBuffer = NULL;
  srb->DataTransferLength = 0;
  srb->TimeOutValue = 10;

  switch (setAccess->Element.ElementType)
    {
      case ChangerIEPort:
      case ChangerDoor:

      if (controlOperation == LOCK_ELEMENT)
    {

      //
      // Issue prevent media removal command to lock the door.
      //

      cdb->MEDIA_REMOVAL.Prevent = 1;

    }
      else if (controlOperation == UNLOCK_ELEMENT)
    {

      //
      // Issue allow media removal.
      //

      cdb->MEDIA_REMOVAL.Prevent = 0;

    }
      else
    {
      status = STATUS_INVALID_PARAMETER;
    }


      break;


    default:

      status = STATUS_INVALID_PARAMETER;
    }

  if (NT_SUCCESS (status))
    {

      //
      // Issue the srb.
      //

      status = ChangerClassSendSrbSynchronous (DeviceObject,
                    srb,
                    srb->DataBuffer,
                    srb->DataTransferLength,
                    writeToDevice);
    }

  if (srb->DataBuffer)
    {
      ChangerClassFreePool (srb->DataBuffer);
    }

  ChangerClassFreePool (srb);
  if (NT_SUCCESS (status))
    {
      Irp->IoStatus.Information = sizeof (CHANGER_SET_ACCESS);
    }

  return status;
}


NTSTATUS
ChangerGetElementStatus (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
  PCHANGER_READ_ELEMENT_STATUS readElementStatus =
    Irp->AssociatedIrp.SystemBuffer;
  PCHANGER_ELEMENT_STATUS elementStatus;
  PCHANGER_ELEMENT element;
  ELEMENT_TYPE elementType;
  PSCSI_REQUEST_BLOCK srb;
  PCDB cdb;
  ULONG length;
  ULONG statusPages;
  ULONG totalElements = 0;
  NTSTATUS status;
  PVOID statusBuffer;
  PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
  ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

  //
  // Determine the element type.
  //

  elementType = readElementStatus->ElementList.Element.ElementType;
  element = &readElementStatus->ElementList.Element;

  //
  // length will be based on whether vol. tags are returned and element type(s).
  //

  if (elementType == AllElements)
    {


      ULONG i;

      statusPages = 0;

      //
      // Run through and determine number of statuspages, based on
      // whether this device claims it supports an element type.
      // As everything past ChangerDrive is artificial, stop there.
      //

      for (i = 0; i <= ChangerDrive; i++)
    {
      statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
      totalElements += addressMapping->NumberOfElements[i];
    }

      if (totalElements != readElementStatus->ElementList.NumberOfElements)
    {
      DebugPrint ((1,
               "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
               totalElements,
               readElementStatus->ElementList.NumberOfElements));

      return STATUS_INVALID_PARAMETER;
    }
    }
  else
    {

      if (ElementOutOfRange
      (addressMapping, (USHORT) element->ElementAddress, elementType,
       TRUE))
    {
      DebugPrint ((1,
               "ChangerGetElementStatus: Element out of range.\n"));

      return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

      totalElements = readElementStatus->ElementList.NumberOfElements;
      statusPages = 1;
    }

  if (readElementStatus->VolumeTagInfo)
    {

      //
      // Each descriptor will have an embedded volume tag buffer.
      //

      length =
    sizeof (ELEMENT_STATUS_HEADER) +
    (statusPages * sizeof (ELEMENT_STATUS_PAGE)) +
    (M4_FULL_SIZE * totalElements);
    }
  else
    {

      length =
    sizeof (ELEMENT_STATUS_HEADER) +
    (statusPages * sizeof (ELEMENT_STATUS_PAGE)) +
    (M4_PARTIAL_SIZE * totalElements);

    }


  statusBuffer = ChangerClassAllocatePool (NonPagedPoolCacheAligned, length);

  if (!statusBuffer)
    {
      return STATUS_INSUFFICIENT_RESOURCES;
    }

  RtlZeroMemory (statusBuffer, length);

  //
  // Build srb and cdb.
  //

  srb = ChangerClassAllocatePool (NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

  if (!srb)
    {
      ChangerClassFreePool (statusBuffer);
      return STATUS_INSUFFICIENT_RESOURCES;
    }

  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);
  cdb = (PCDB) srb->Cdb;

  srb->CdbLength = CDB12GENERIC_LENGTH;
  srb->DataBuffer = statusBuffer;
  srb->DataTransferLength = length;
  srb->TimeOutValue = 200;

  cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

  cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR) elementType;
  cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

  //
  // Fill in element addressing info based on the mapping values.
  //

  cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
    (UCHAR) ((element->ElementAddress +
          addressMapping->FirstElement[element->ElementType]) >> 8);

  cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
    (UCHAR) ((element->ElementAddress +
          addressMapping->FirstElement[element->ElementType]) & 0xFF);

  cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR) (totalElements >> 8);
  cdb->READ_ELEMENT_STATUS.NumberOfElements[1] =
    (UCHAR) (totalElements & 0xFF);

  cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR) (length >> 16);
  cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR) (length >> 8);
  cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR) (length & 0xFF);

  //
  // Send SCSI command (CDB) to device
  //

  status = ChangerClassSendSrbSynchronous (DeviceObject,
                    srb,
                    srb->DataBuffer,
                    srb->DataTransferLength, FALSE);

  if ((NT_SUCCESS (status)) || (status == STATUS_DATA_OVERRUN))
    {

      PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
      PELEMENT_STATUS_PAGE statusPage;
      PM4_ELEMENT_DESCRIPTOR elementDescriptor;
      ULONG numberElements = totalElements;
      ULONG remainingElements;
      ULONG typeCount;
      BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
      ULONG i;
      ULONG descriptorLength;

      if (status == STATUS_DATA_OVERRUN)
    {
      if (srb->DataTransferLength < length)
        {
          DebugPrint ((1, "Data Underrun reported as overrun.\n"));
          status = STATUS_SUCCESS;
        }
      else
        {
          DebugPrint ((1, "Data Overrun in ChangerGetElementStatus.\n"));

          ChangerClassFreePool (srb);
          ChangerClassFreePool (statusBuffer);

          return status;
        }
    }


      //
      // Determine total number elements returned.
      //

      remainingElements = statusHeader->NumberOfElements[1];
      remainingElements |= (statusHeader->NumberOfElements[0] << 8);

      //
      // The buffer is composed of a header, status page, and element descriptors.
      // Point each element to it's respective place in the buffer.
      //

      (PVOID) statusPage = (PVOID) statusHeader;
      (PCHAR) statusPage += sizeof (ELEMENT_STATUS_HEADER);

      elementType = statusPage->ElementType;

      (PCHAR) elementDescriptor = (PCHAR) statusPage;
      (PCHAR) elementDescriptor += sizeof (ELEMENT_STATUS_PAGE);

      descriptorLength = statusPage->ElementDescriptorLength[1];
      descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

      //
      // Determine the number of elements of this type reported.
      //

      typeCount = statusPage->DescriptorByteCount[2];
      typeCount |= (statusPage->DescriptorByteCount[1] << 8);
      typeCount |= (statusPage->DescriptorByteCount[0] << 16);

      typeCount /= descriptorLength;

      //
      // Fill in user buffer.
      //

      elementStatus = Irp->AssociatedIrp.SystemBuffer;
      RtlZeroMemory(elementStatus, outputBuffLen);

      do
    {

      for (i = 0; i < typeCount; i++, remainingElements--)
        {

          //
          // Get the address for this element.
          //

          elementStatus->Element.ElementAddress =
        elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.
        ElementAddress[1];
          elementStatus->Element.ElementAddress |=
        (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.
         ElementAddress[0] << 8);

          //
          // Account for address mapping.
          //

          elementStatus->Element.ElementAddress -=
        addressMapping->FirstElement[elementType];

          //
          // Set the element type.
          //

          elementStatus->Element.ElementType = elementType;


          if (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.SValid)
        {

          ULONG j;
          USHORT tmpAddress;


          //
          // Source address is valid. Determine the device specific address.
          //

          tmpAddress =
            elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.
            SourceStorageElementAddress[1];
          tmpAddress |=
            (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.
             SourceStorageElementAddress[0] << 8);

          //
          // Now convert to 0-based values.
          //

          for (j = 1; j <= ChangerDrive; j++)
            {
              if (addressMapping->FirstElement[j] <= tmpAddress)
            {
              if (tmpAddress <
                  (addressMapping->NumberOfElements[j] +
                   addressMapping->FirstElement[j]))
                {
                  elementStatus->SrcElementAddress.ElementType =
                j;
                  break;
                }
            }
            }

          elementStatus->SrcElementAddress.ElementAddress =
            tmpAddress - addressMapping->FirstElement[j];

        }

          //
          // Build Flags field.
          //

          elementStatus->Flags =
        elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.Full;
          elementStatus->Flags |=
        (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.
         Exception << 2);
          elementStatus->Flags |=
        (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.
         Accessible << 3);

          elementStatus->Flags |=
        (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.
         LunValid << 12);
          elementStatus->Flags |=
        (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
          elementStatus->Flags |=
        (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.
         NotThisBus << 15);

          elementStatus->Flags |=
        (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
          elementStatus->Flags |=
        (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


          if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT)
        {
          elementStatus->ExceptionCode =
            MapExceptionCodes (elementDescriptor);
        }

          if (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.IdValid)
        {
          elementStatus->TargetId =
            elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.BusAddress;
        }
          if (elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.LunValid)
        {
          elementStatus->Lun =
            elementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.Lun;
        }

          if (tagInfo)
        {
          RtlMoveMemory (elementStatus->PrimaryVolumeID,
                 elementDescriptor->
                 M4_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag,
                 MAX_VOLUME_ID_SIZE);
          elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
        }

          //
          // Get next descriptor.
          //

          (PCHAR) elementDescriptor += descriptorLength;

          //
          // Advance to the next entry in the user buffer and element descriptor array.
          //

          elementStatus += 1;

        }

      if (remainingElements)
        {

          //
          // Get next status page.
          //

          (PCHAR) statusPage = (PCHAR) elementDescriptor;

          elementType = statusPage->ElementType;

          //
          // Point to decriptors.
          //

          (PCHAR) elementDescriptor = (PCHAR) statusPage;
          (PCHAR) elementDescriptor += sizeof (ELEMENT_STATUS_PAGE);

          descriptorLength = statusPage->ElementDescriptorLength[1];
          descriptorLength |=
        (statusPage->ElementDescriptorLength[0] << 8);

          //
          // Determine the number of this element type reported.
          //

          typeCount = statusPage->DescriptorByteCount[2];
          typeCount |= (statusPage->DescriptorByteCount[1] << 8);
          typeCount |= (statusPage->DescriptorByteCount[0] << 16);

          typeCount /= descriptorLength;
        }

    }
      while (remainingElements);

      Irp->IoStatus.Information =
    sizeof (CHANGER_ELEMENT_STATUS) * numberElements;

    }

  ChangerClassFreePool (srb);
  ChangerClassFreePool (statusBuffer);

  return status;
}


NTSTATUS
ChangerInitializeElementStatus (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
  PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus =
    Irp->AssociatedIrp.SystemBuffer;
  PSCSI_REQUEST_BLOCK srb;
  PCDB cdb;
  NTSTATUS status;

  //
  // Build srb and cdb.
  //

  srb = ChangerClassAllocatePool (NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

  if (!srb)
    {

      return STATUS_INSUFFICIENT_RESOURCES;
    }

  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);
  cdb = (PCDB) srb->Cdb;

  if (initElementStatus->ElementList.Element.ElementType == AllElements)
    {

      //
      // Build the normal SCSI-2 command for all elements.
      //

      srb->CdbLength = CDB6GENERIC_LENGTH;
      cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;
      cdb->INIT_ELEMENT_STATUS.NoBarCode =
    initElementStatus->BarCodeScan ? 0 : 1;

      srb->TimeOutValue = fdoExtension->TimeOutValue;
      srb->DataTransferLength = 0;

    }
  else
    {

      PCHANGER_ELEMENT_LIST elementList = &initElementStatus->ElementList;
      PCHANGER_ELEMENT element = &elementList->Element;

      //
      // Use the magfile vendor-unique initialize with range command
      //

      srb->CdbLength = CDB10GENERIC_LENGTH;
      cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = SCSIOP_INIT_ELEMENT_RANGE;
      cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

      //
      // Addresses of elements need to be mapped from 0-based to device-specific.
      //

      cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
    (UCHAR) ((element->ElementAddress +
          addressMapping->FirstElement[element->ElementType]) >> 8);
      cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
    (UCHAR) ((element->ElementAddress +
          addressMapping->FirstElement[element->ElementType]) & 0xFF);

      cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] =
    (UCHAR) (elementList->NumberOfElements >> 8);
      cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] =
    (UCHAR) (elementList->NumberOfElements & 0xFF);

      //
      // Indicate whether to use bar code scanning.
      //

      cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode =
    initElementStatus->BarCodeScan ? 0 : 1;

      srb->TimeOutValue = fdoExtension->TimeOutValue;
      srb->DataTransferLength = 0;

    }

  //
  // Send SCSI command (CDB) to device
  //

  status = ChangerClassSendSrbSynchronous (DeviceObject, srb, NULL, 0, FALSE);

  if (NT_SUCCESS (status))
    {
      Irp->IoStatus.Information = sizeof (CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

  ChangerClassFreePool (srb);
  return status;
}


NTSTATUS
ChangerSetPosition (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
  PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
  USHORT transport;
  USHORT destination;
  PSCSI_REQUEST_BLOCK srb;
  PCDB cdb;
  NTSTATUS status;

  return STATUS_INVALID_DEVICE_REQUEST;

}


NTSTATUS
ChangerExchangeMedium (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    None of the magfile units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/
{
  return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
  PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
  USHORT transport;
  USHORT source;
  USHORT destination;
  PSCSI_REQUEST_BLOCK srb;
  PCDB cdb;
  NTSTATUS status;

  //
  // Verify transport, source, and dest. are within range.
  // Convert from 0-based to device-specific addressing.
  //

  transport = (USHORT) (moveMedium->Transport.ElementAddress);

  if (ElementOutOfRange (addressMapping, transport, ChangerTransport, TRUE))
    {

      DebugPrint ((1,
           "ChangerMoveMedium: Transport element out of range.\n"));

      return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

  source = (USHORT) (moveMedium->Source.ElementAddress);

  if (ElementOutOfRange
      (addressMapping, source, moveMedium->Source.ElementType, TRUE))
    {

      DebugPrint ((1, "ChangerMoveMedium: Source element out of range.\n"));

      return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

  destination = (USHORT) (moveMedium->Destination.ElementAddress);

  if (ElementOutOfRange
      (addressMapping, destination, moveMedium->Destination.ElementType,
       TRUE))
    {
      DebugPrint ((1,
           "ChangerMoveMedium: Destination element out of range.\n"));

      return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

  //
  // Convert to device addresses.
  //

  transport += addressMapping->FirstElement[ChangerTransport];
  source += addressMapping->FirstElement[moveMedium->Source.ElementType];
  destination +=
    addressMapping->FirstElement[moveMedium->Destination.ElementType];

  //
  // Magfile doesn't support 2-sided media.
  //

  if (moveMedium->Flip)
    {
      return STATUS_INVALID_PARAMETER;
    }

  //
  // Build srb and cdb.
  //

  srb = ChangerClassAllocatePool (NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

  if (!srb)
    {

      return STATUS_INSUFFICIENT_RESOURCES;
    }

  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);
  cdb = (PCDB) srb->Cdb;
  srb->CdbLength = CDB12GENERIC_LENGTH;
  srb->TimeOutValue = fdoExtension->TimeOutValue;

  cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

  //
  // Build addressing values based on address map.
  //

  cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR) (transport >> 8);
  cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR) (transport & 0xFF);

  cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR) (source >> 8);
  cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR) (source & 0xFF);

  cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR) (destination >> 8);
  cdb->MOVE_MEDIUM.DestinationElementAddress[1] =
    (UCHAR) (destination & 0xFF);

  cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

  srb->DataTransferLength = 0;

  //
  // Send SCSI command (CDB) to device
  //

  status = ChangerClassSendSrbSynchronous (DeviceObject, srb, NULL, 0, FALSE);

  if (NT_SUCCESS (status))
    {
      Irp->IoStatus.Information = sizeof (CHANGER_MOVE_MEDIUM);
    }

  ChangerClassFreePool (srb);
  return status;
}


NTSTATUS
ChangerReinitializeUnit (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
  PCHANGER_ELEMENT transportToHome = Irp->AssociatedIrp.SystemBuffer;
  USHORT transport;
  PSCSI_REQUEST_BLOCK srb;
  PCDB cdb;
  NTSTATUS status;

  return STATUS_INVALID_DEVICE_REQUEST;

}


NTSTATUS
ChangerQueryVolumeTags (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

  return STATUS_INVALID_DEVICE_REQUEST;

}


NTSTATUS
M4BuildAddressMapping (IN PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

  PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
  PCHANGER_DATA changerData =
    (PCHANGER_DATA) (fdoExtension->CommonExtension.DriverData);
  PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
  PSCSI_REQUEST_BLOCK srb;
  PCDB cdb;
  NTSTATUS status;
  PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
  PVOID modeBuffer;
  ULONG i;

  srb = ChangerClassAllocatePool (NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
  if (!srb)
    {
      return STATUS_INSUFFICIENT_RESOURCES;
    }

  //
  // Set all FirstElements to NO_ELEMENT.
  //

  for (i = 0; i < ChangerMaxElement; i++)
    {
      addressMapping->FirstElement[i] = M4_NO_ELEMENT;
    }

  RtlZeroMemory (srb, SCSI_REQUEST_BLOCK_SIZE);

  cdb = (PCDB) srb->Cdb;

  //
  // Build a mode sense - Element address assignment page.
  //

  modeBuffer =
    ChangerClassAllocatePool (NonPagedPoolCacheAligned,
                  sizeof (MODE_PARAMETER_HEADER) +
                  sizeof (MODE_ELEMENT_ADDRESS_PAGE));
  if (!modeBuffer)
    {
      ChangerClassFreePool (srb);
      return STATUS_INSUFFICIENT_RESOURCES;
    }


  RtlZeroMemory (modeBuffer,
         sizeof (MODE_PARAMETER_HEADER) +
         sizeof (MODE_ELEMENT_ADDRESS_PAGE));
  srb->CdbLength = CDB6GENERIC_LENGTH;
  srb->TimeOutValue = 20;
  srb->DataTransferLength =
    sizeof (MODE_PARAMETER_HEADER) + sizeof (MODE_ELEMENT_ADDRESS_PAGE);
  srb->DataBuffer = modeBuffer;

  cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
  cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
  cdb->MODE_SENSE.Dbd = 1;
  cdb->MODE_SENSE.AllocationLength = (UCHAR) srb->DataTransferLength;

  //
  // Send the request.
  //

  status = ChangerClassSendSrbSynchronous (DeviceObject,
                    srb,
                    srb->DataBuffer,
                    srb->DataTransferLength, FALSE);


  elementAddressPage = modeBuffer;
  (PCHAR) elementAddressPage += sizeof (MODE_PARAMETER_HEADER);

  if (NT_SUCCESS (status))
    {

      //
      // Build address mapping.
      //

      addressMapping->FirstElement[ChangerTransport] =
    (elementAddressPage->
     MediumTransportElementAddress[0] << 8) | elementAddressPage->
    MediumTransportElementAddress[1];
      addressMapping->FirstElement[ChangerDrive] =
    (elementAddressPage->
     FirstDataXFerElementAddress[0] << 8) | elementAddressPage->
    FirstDataXFerElementAddress[1];
      addressMapping->FirstElement[ChangerIEPort] =
    (elementAddressPage->
     FirstIEPortElementAddress[0] << 8) | elementAddressPage->
    FirstIEPortElementAddress[1];
      addressMapping->FirstElement[ChangerSlot] =
    (elementAddressPage->
     FirstStorageElementAddress[0] << 8) | elementAddressPage->
    FirstStorageElementAddress[1];
      addressMapping->FirstElement[ChangerDoor] = 0;

      addressMapping->FirstElement[ChangerKeypad] = 0;

      addressMapping->NumberOfElements[ChangerTransport] =
    elementAddressPage->NumberTransportElements[1];
      addressMapping->NumberOfElements[ChangerTransport] |=
    (elementAddressPage->NumberTransportElements[0] << 8);

      addressMapping->NumberOfElements[ChangerDrive] =
    elementAddressPage->NumberDataXFerElements[1];
      addressMapping->NumberOfElements[ChangerDrive] |=
    (elementAddressPage->NumberDataXFerElements[0] << 8);

      addressMapping->NumberOfElements[ChangerIEPort] =
    elementAddressPage->NumberIEPortElements[1];
      addressMapping->NumberOfElements[ChangerIEPort] |=
    (elementAddressPage->NumberIEPortElements[0] << 8);

      addressMapping->NumberOfElements[ChangerSlot] =
    elementAddressPage->NumberStorageElements[1];
      addressMapping->NumberOfElements[ChangerSlot] |=
    (elementAddressPage->NumberStorageElements[0] << 8);


      //
      // If there are no IEPorts, then that slot is 
      // counted as data slot. But, since the last
      // slot is inaccessbile, we do not count them
      // Do the required adjustment here
      //
      if (addressMapping->NumberOfElements[ChangerIEPort] == 0) {
          USHORT tmpValue;

          tmpValue = addressMapping->NumberOfElements[ChangerSlot];

          addressMapping->NumberOfElements[ChangerSlot] = 
              tmpValue - (tmpValue % 20);

      }

      addressMapping->NumberOfElements[ChangerDoor] = 1;
      addressMapping->NumberOfElements[ChangerKeypad] = 1;

      addressMapping->Initialized = TRUE;
    }


  //
  // Determine the lowest element address for use with AllElements.
  //

  for (i = 0; i < ChangerDrive; i++)
    {
      if (addressMapping->FirstElement[i] <
      addressMapping->FirstElement[AllElements])
    {

      DebugPrint ((1,
               "BuildAddressMapping: New lowest address %x\n",
               addressMapping->FirstElement[i]));
      addressMapping->FirstElement[AllElements] =
        addressMapping->FirstElement[i];
    }
    }

  //
  // Free buffer.
  //

  ChangerClassFreePool (modeBuffer);
  ChangerClassFreePool (srb);

  return status;
}


ULONG
MapExceptionCodes (IN PM4_ELEMENT_DESCRIPTOR ElementDescriptor)
/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/
{
  UCHAR asq =
    ElementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.AddSenseCodeQualifier;
  ULONG exceptionCode;

  if (ElementDescriptor->M4_FULL_ELEMENT_DESCRIPTOR.AdditionalSenseCode == 0x83)
    {
      switch (asq)
    {
    case 0x0:
      exceptionCode = ERROR_LABEL_QUESTIONABLE;
      break;

    case 0x1:
      exceptionCode = ERROR_LABEL_UNREADABLE;
      break;

    case 0x2:
      exceptionCode = ERROR_SLOT_NOT_PRESENT;
      break;

    case 0x3:
      exceptionCode = ERROR_LABEL_QUESTIONABLE;
      break;


    case 0x4:
      exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
      break;

    case 0x8:
    case 0x9:
    case 0xA:
      exceptionCode = ERROR_LABEL_UNREADABLE;
      break;

    default:
      exceptionCode = ERROR_UNHANDLED_ERROR;
    }
    }
  else
    {
      exceptionCode = ERROR_UNHANDLED_ERROR;
    }

  return exceptionCode;

}


BOOLEAN
ElementOutOfRange (IN PCHANGER_ADDRESS_MAPPING AddressMap,
           IN USHORT ElementOrdinal,
           IN ELEMENT_TYPE ElementType, IN BOOLEAN IntrinsicElement)
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The magfile's address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

  if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType])
    {

      DebugPrint ((1,
           "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
           ElementType,
           ElementOrdinal,
           AddressMap->NumberOfElements[ElementType]));
      return TRUE;
    }
  else if (AddressMap->FirstElement[ElementType] == M4_NO_ELEMENT)
    {

      DebugPrint ((1,
           "ElementOutOfRange: No Type %x present\n", ElementType));

      return TRUE;
    }

  if (IntrinsicElement)
    {
      if (ElementType >= ChangerDoor)
    {
      DebugPrint ((1,
               "ElementOutOfRange: Specified type not intrinsic. Type %x\n",
               ElementType));
      return TRUE;
    }
    }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\jvcmc\jvcmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    jvcmc.c

Abstract:

    This module contains device-specific routines for JVC 1200/1600.

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "jvcmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, JVCBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the Pioneer changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = JVCBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Send an allow to the unit to ensure that the LockCount and state of the unit
    // are in sync.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb.Cdb;
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.DataTransferLength = 0;
    srb.TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    DebugPrint((1,
               "ChangerError: Error on opcode %x\n",
               Srb->Cdb[0]));

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        switch (senseBuffer->SenseKey) {
            case SCSI_SENSE_ABORTED_COMMAND:
                if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_POSITION_ERROR) {
                    if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {

                        *Status = STATUS_DESTINATION_ELEMENT_FULL;

                    } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {

                        *Status = STATUS_SOURCE_ELEMENT_EMPTY;

                    } else {

                        *Status = STATUS_SOURCE_ELEMENT_EMPTY;
                    }

                }

                break;

            case SCSI_SENSE_NOT_READY:
                break;

            case SCSI_SENSE_HARDWARE_ERROR: {
               changerData->HardwareError = TRUE;
               break;
            }

            case SCSI_SENSE_UNIT_ATTENTION:

                if (senseBuffer->AdditionalSenseCode != SCSI_ADSENSE_MEDIUM_CHANGED) {

                    //
                    // Reset/power-on clears any prevents.
                    //

                    InterlockedExchange(&changerData->LockCount, 0);
                }

                break;

            break;

        }

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));

    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. SrbStatus %x\n",
                   Srb->SrbStatus));

    }
    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    DVL changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK          srb;
    PGET_CHANGER_PARAMETERS      changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE   elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE  transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = JVC_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    changerParameters->MagazineSize = 50;
    changerParameters->DriveCleanTimeout = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_LOCK_UNLOCK                 |
                                   CHANGER_STATUS_NON_VOLATILE         |
                                   CHANGER_POSITION_TO_ELEMENT         |
                                   CHANGER_CARTRIDGE_MAGAZINE          |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE;

    changerParameters->Features1 = CHANGER_SLOTS_USE_TRAYS | CHANGER_IEPORT_USER_CONTROL_CLOSE;

    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_IEPORT;
    changerParameters->PositionCapabilities = (CHANGER_TO_SLOT  | CHANGER_TO_IEPORT | CHANGER_TO_DRIVE);

    //
    // build device caps mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate drive type.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort/ Front panel.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The IEPort can be locked/unlocked.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (setAccess->Element.ElementType == ChangerIEPort) {

        if (controlOperation == LOCK_ELEMENT) {

            //
            // Inc the lock count to indicate that a prevent is on the device.
            //

            InterlockedIncrement(&changerData->LockCount);

            //
            // Issue prevent media removal command to lock the door.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            InterlockedExchange(&changerData->LockCount, 0);

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             writeToDevice);
    }

    ChangerClassFreePool(srb);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}


NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;
    ULONG    totalElements = 0;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (addressMapping->Initialized != TRUE) {

        DebugPrint((1,
                   "GetElementStatus: Not initialized, building address mapping\n"));
        status = JVCBuildAddressMapping(DeviceObject);
        if (!NT_SUCCESS(status)) {
            DebugPrint((1, "GetElementStatus: Address mapping failed %x\n",
                        status));
            return status;
        }
    }

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (readElementStatus->VolumeTagInfo) {

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {

            DebugPrint((2,
                       "Jvc: NumberOfElements[%d] -> %d\n",
                       i,
                       addressMapping->NumberOfElements[i]));

            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;

            //
            // Add these up instead of using the number passed in the user's buffer, as the driver
            // fakes that there are no IEPorts.
            //

            totalElements += addressMapping->NumberOfElements[i];

        }

        //
        // Firmware workaround. Even though there aren't 6 drives, ask for info on them.
        //

        totalElements += (6 - addressMapping->NumberOfElements[ChangerDrive]);

        DebugPrint((2,
                   "Jvc: TotalElements - %d\n",
                   totalElements));

        //
        // Determine length of the descriptors expected for the elements.
        //

        length = (sizeof(JVC_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {


        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                        "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        length = (sizeof(JVC_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // Ensure that starting address is valid.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);



    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                if (elementType == ChangerDrive) {
                    if (!elementDescriptor->Accessible) {
                        DebugPrint((1,
                                   "JVC: Drive not accessible\n"));

                        (ULONG_PTR)elementDescriptor += descriptorLength;
                        continue;
                    }
                }

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                }

                if (elementDescriptor->IdValid) {
                    elementStatus->TargetId = elementDescriptor->BusAddress;
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                if (elementType != ChangerIEPort) {
                    elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                }

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);


                //
                // Map the exceptions.
                //

                if (elementDescriptor->Exception) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;
                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue * 10;
        srb->DataTransferLength = 0;

    } else {


        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport and dest. are within range.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    if ((setPosition->Destination.ElementType == AllElements) ||
        (setPosition->Destination.ElementType == ChangerTransport) ||
        (setPosition->Destination.ElementType > ChangerDrive) ) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    if (moveMedium->Source.ElementType == ChangerIEPort) {

        //
        // JVC has a stealth address for closing the IEPort.
        //

        DebugPrint((2,
                   "Incing ieport address %x -> ",
                   source));

        source += 1;

        DebugPrint((2,"%x\n", source));

    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    if (lockValue) {

        NTSTATUS preventStatus;

        //
        // Send the prevent to re-lock down the unit.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        //
        // Ignore any errors at this point. The LM will fixup any problems with
        // prevent/allow
        //

        preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                srb,
                                NULL,
                                0,
                                FALSE);
        DebugPrint((1,
                   "MoveMedium: Prevent sent. Status %x\n",
                   preventStatus));
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
JVCBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = JVC_NO_ELEMENT;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = JVC_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    } else {
        DebugPrint((1,
                   "JVCMC: AddressMapping not initialized\n"));
    }

    //
    // If the mode sense failed, first open of the device will get the information.
    //

    status = STATUS_SUCCESS;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;
    ULONG exceptionCode;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x04:
        case 0x3A:

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "JVCMC: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == JVC_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++ 

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the flag in the device extension to FALSE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set this flag to TRUE in ChangerError routine.
   //
   changerData->HardwareError = FALSE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "JVCMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set selftest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
      changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\libxprmc\libxprmc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    libxprmc.h

Abstract:

Authors:

Revision History:
    April 2000, Added support for Library Mode Page 23h
    August 25, 1999, Valerie Barr, Overland Data
        Added support for Alternate Volume Tag Information
    July 14, 1999, Valerie Barr, Overland Data
        Changed file name

--*/
#ifndef _LIBXPR_MC
#define _LIBXPR_MC_

#define OVR_ALT_VOLUME_ID_SIZE 20

#define LXB_OR_LXG    1
#define LXS           2
#define LIBRARYPRO    3
#define SSL2000       4
#define MSL5000       5

#define VPD_SERIAL_NUMBER_LENGTH 10

#define MODE_PAGE_LIBRARY_MODE 0x23     // Page Code for Library Mode Page

#define LIB_MODE_RANDOM 0x0
#define LIB_UNLOAD_MODE 0x8
#define LIB_RECIRC 0x10
#define LIB_DOOR_AUTO_CLOSE 0x20
#define LIB_DOOR_OPEN_RESPONSE 0x40

#define OVR_NO_ELEMENT 0xFFFF

typedef union _OVR_ELEMENT_DESCRIPTOR {

    struct _OVR_FULL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
        UCHAR AlternateVolumeTag[OVR_ALT_VOLUME_ID_SIZE];
        UCHAR Reserved9[12];
    } OVR_FULL_ELEMENT_DESCRIPTOR, *POVR_FULL_ELEMENT_DESCRIPTOR;

    struct _OVR_PARTIAL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } OVR_PARTIAL_ELEMENT_DESCRIPTOR, *POVR_PARTIAL_ELEMENT_DESCRIPTOR;


    struct _OVR_DRIVE_FULL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
        UCHAR DriveSerialNumber[36];
    } OVR_DRIVE_FULL_ELEMENT_DESCRIPTOR, *POVR_DRIVE_FULL_ELEMENT_DESCRIPTOR;

    struct _OVR_DRIVE_PARTIAL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
        UCHAR DriveSerialNumber[36];
    } OVR_DRIVE_PARTIAL_ELEMENT_DESCRIPTOR, *POVR_DRIVE_PARTIAL_ELEMENT_DESCRIPTOR;


} OVR_ELEMENT_DESCRIPTOR, *POVR_ELEMENT_DESCRIPTOR;

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[VPD_SERIAL_NUMBER_LENGTH];



    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

} CHANGER_DATA, *PCHANGER_DATA;

#define OVR_PARTIAL_SIZE sizeof(struct _OVR_PARTIAL_ELEMENT_DESCRIPTOR)
#define OVR_FULL_SIZE sizeof(struct _OVR_FULL_ELEMENT_DESCRIPTOR)

#define OVR_DRIVE_PARTIAL_SIZE sizeof(struct _OVR_DRIVE_PARTIAL_ELEMENT_DESCRIPTOR)
#define OVR_DRIVE_FULL_SIZE sizeof(struct _OVR_DRIVE_FULL_ELEMENT_DESCRIPTOR)

#define OVR_DISPLAY_LINES        4
#define OVR_DISPLAY_LINE_LENGTH 20

typedef struct _MODE_LIBRARY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR LibraryMode : 3;
    UCHAR UnldMd : 1;
    UCHAR Recirc : 1;
    UCHAR DoorAutoClose : 1;
    UCHAR DoorOpenResponse : 1;
    UCHAR Reserved2 : 1;
    UCHAR Reserved4;
} MODE_LIBRARY_PAGE, *PMODE_LIBRARY_PAGE;

typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[VPD_SERIAL_NUMBER_LENGTH];
} SERIALNUMBER, *PSERIALNUMBER;


NTSTATUS
OvrBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN POVR_ELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\libxprmc\libxprmc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    libxprmc.c

Abstract:

    This module contains device-specific routines for Overland Data
    medium changers:
         LXB, LXG, LXS, LXL, LXM, LIBRARYPRO, TL8xx, SSL2000 Series

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


    April xx, 2000 - Valerie Barr, Overland Data
        Added support for Overland LIBRARYPRO and COMPAQ SSL2000 Series
            Modified Features0 and Features1 values
        Support SCSI cmd Position To Element (implemented as a no-op)
    August 25, 1999 - Valerie Barr, Overland Data
        Fixed a blue-screen problem in which invalid primary volume tag info
          was being written to a non-allocated buffer.
        Added support for slot and drive address differences between
          Overland and Compaq
        Modified the magazine size calculation
        Added support for alternate volume tag info for Overland and Compaq
    August 3, 1999 - Valerie Barr, Overland Data
        Corrected out of order memory deallocation instances
        Corrected not deallocating memory in error conditions
    July 14, 1999 - Valerie Barr, Overland Data
        Changed file names
        Fixed 2 warnings of conversions from int to char

--*/

#include "ntddk.h"
#include "mcd.h"
#include "libxprmc.h"

#ifdef  ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, OvrBuildAddressMapping)

#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = NULL;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath,
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
                              VOID
                              )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by these changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}

NTSTATUS
ChangerInitialize(
                 IN PDEVICE_OBJECT DeviceObject
                 )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = OvrBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        DebugPrint((1,
                    "Examc.ChangerInitialize: Error allocating dataBuffer. %x\n", status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            &srb,
                                            dataBuffer,
                                            sizeof(INQUIRYDATA),
                                            FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"LXB",3) == 3) {
            changerData->DriveID = LXB_OR_LXG;

        } else if (RtlCompareMemory(dataBuffer->ProductId,"LXS",3)==3) {
            changerData->DriveID = LXS;
        } else if (RtlCompareMemory(changerData->InquiryData.ProductId,
                                    "LIBRARYPRO",10) == 10) {
            changerData->DriveID = LIBRARYPRO;
        } else if (RtlCompareMemory(changerData->InquiryData.ProductId,
                                    "SSL2000 Series",14) == 14) {
            changerData->DriveID = SSL2000;
        } else if (RtlCompareMemory(changerData->InquiryData.ProductId,
                                    "MSL5000 Series",14) == 14) {
            changerData->DriveID = MSL5000;
        }
    }

    //
    // Get serial number page

    serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(SERIALNUMBER));
    if (!serialBuffer) {
        ChangerClassFreePool(dataBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(serialBuffer, sizeof(SERIALNUMBER));

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.TimeOutValue = 10;
    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;
    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    // Set EVPD
    cdb->CDB6INQUIRY.Reserved1 = 1;

    // Unit serial number page.
    cdb->CDB6INQUIRY.PageCode = 0x80;

    // Set allocation length to inquiry data buffer size.
    cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIALNUMBER);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            &srb,
                                            serialBuffer,
                                            sizeof(SERIALNUMBER),
                                            FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        RtlMoveMemory(changerData->SerialNumber, serialBuffer->SerialNumber,
                      VPD_SERIAL_NUMBER_LENGTH);

    }

    if (serialBuffer)
        ChangerClassFreePool(serialBuffer);
    ChangerClassFreePool(dataBuffer);
    return STATUS_SUCCESS;
}

VOID
ChangerError(
            PDEVICE_OBJECT DeviceObject,
            PSCSI_REQUEST_BLOCK Srb,
            NTSTATUS *Status,
            BOOLEAN *Retry
            )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIRP irp = Srb->OriginalRequest;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        if (senseBuffer->AdditionalSenseCode == 0x04) {
            switch (senseBuffer->AdditionalSenseCodeQualifier) {
            case 0x83:
                //               case 0x8D:
                //               case 0x8E:
                //               case 0x03:
                *Retry = FALSE;
                *Status = STATUS_DEVICE_DOOR_OPEN;
                break;
            default:
                break;
            }
        }

        if (senseBuffer->AdditionalSenseCode == 0x3B) {
            switch (senseBuffer->AdditionalSenseCodeQualifier) {
            case 0x90:
            case 0x91:
                *Retry = FALSE;
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
                break;
            default:
                break;
            }
        }

        if (senseBuffer->AdditionalSenseCode == 0x80) {
            switch (senseBuffer->AdditionalSenseCodeQualifier) {
            case 0x03:
            case 0x04:
                *Retry = FALSE;
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
                break;
            default:
                break;
            }
        }

        if (senseBuffer->AdditionalSenseCode == 0x83) {
            switch (senseBuffer->AdditionalSenseCodeQualifier) {
            case 0x02:
                *Retry = FALSE;
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
                break;
            case 0x04:
                *Retry = TRUE;
                *Status = STATUS_DEVICE_NOT_CONNECTED;
                break;
            default:
                break;
            }
        }
    }
    return;
}

NTSTATUS
ChangerGetParameters(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
                    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    these changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    PMODE_LIBRARY_PAGE librarymodePage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;
    struct _MODE_SENSE_VALUES {

        UCHAR    UnldMd : 1;        // To store Mode Sense value
        UCHAR    Recirc : 1;        // To store Mode Sense value
    } MODE_SENSE_VALUES;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // Mode Sense - Page 1D - Element Address Assignment

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                          sizeof(MODE_PARAMETER_HEADER) +
                                          sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                  sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(modeBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);

    changerParameters->NumberTransportElements =
    elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |=
    (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements =
    elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |=
    (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements =
    elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |=
    (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements =
    elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |=
    (elementAddressPage->NumberDataXFerElements[0] << 8);

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    // the front panel offset is determined by the vendor mode defaults
    if ((RtlCompareMemory(changerData->InquiryData.VendorId,"DEC",3) == 3)  ||
        (RtlCompareMemory(changerData->InquiryData.VendorId,"COMPAQ",6) == 6)) {
        // Compaq mode
        changerParameters->FirstSlotNumber = 0;
        changerParameters->FirstDriveNumber =  0;
        changerParameters->FirstIEPortNumber = 0;
    } else {
        // Overland mode
        changerParameters->FirstSlotNumber = 1;
        changerParameters->FirstDriveNumber =  1;
        changerParameters->FirstIEPortNumber = 1;
    }

    changerParameters->FirstTransportNumber = 1;
    changerParameters->FirstCleanerSlotAddress = 0;

    // Magazine size
    // Make the magazine size the number of storage elements.  This works
    // for single module systems but is not quite true for multi-module
    // systems which contain multiple magazines of different sizes.  However,
    // there is not a way to communicate this to the next level since there
    // is only one magazine size stored.  So, this value contains the total
    // number of storage elements available in the system.

    changerParameters->MagazineSize = changerParameters->NumberStorageElements;

    changerParameters->DriveCleanTimeout = 600;

    ChangerClassFreePool(modeBuffer);


    // Mode Sense - Page 1E - Transport Geometry Parameters

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                          sizeof(MODE_PARAMETER_HEADER) +
                                          sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                  sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(modeBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);


    // initialize Features1
    changerParameters->Features1 = 0;

    // check for AIT Library and set ieport features
    if (((changerData->DriveID) == LIBRARYPRO)  ||
        ((changerData->DriveID) == SSL2000)) {

        changerParameters->Features1 |= CHANGER_REPORT_IEPORT_STATE |
                                        CHANGER_IEPORT_USER_CONTROL_OPEN |
                                        CHANGER_IEPORT_USER_CONTROL_CLOSE;
    }


    changerParameters->Features0 =
    transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    // Features based on manual, nothing programatic.
    changerParameters->Features0 |=
    CHANGER_STATUS_NON_VOLATILE           |
    CHANGER_LOCK_UNLOCK                   |
    CHANGER_CARTRIDGE_MAGAZINE            |
    CHANGER_POSITION_TO_ELEMENT           |
    CHANGER_DRIVE_CLEANING_REQUIRED       |
    CHANGER_SERIAL_NUMBER_VALID;


    // Only the DOOR can be locked and unlocked
    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_DOOR;

    //
    // NEO Series libraries can also lock\unlock IEPorts
    //
    if ((changerData->DriveID) == MSL5000) {

        changerParameters->LockUnlockCapabilities |= LOCK_UNLOCK_IEPORT;
    }

    // Barcode scanner installed?
    changerParameters->Features0 |=
    ((changerData->InquiryData.VendorSpecific[19] & 0x1)) ?
    CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;

    ChangerClassFreePool(modeBuffer);

    // Mode Sense - Page 1F - Device Capabilities Parameters

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) +
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(modeBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Features0 |=
    capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |=
    capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |=
    capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |=
    capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    changerParameters->MoveFromTransport =
    capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |=
    capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |=
    capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |=
    capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot =
    capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |=
    capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |=
    capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |=
    capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort =
    capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |=
    capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |=
    capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |=
    capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive =
    capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |=
    capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |=
    capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |=
    capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport =
    capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |=
    capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |=
    capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |=
    capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot =
    capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |=
    capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |=
    capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |=
    capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort =
    capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |=
    capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |=
    capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |=
    capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive =
    capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |=
    capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |=
    capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |=
    capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->PositionCapabilities = 0;

    ChangerClassFreePool(modeBuffer);


    // Mode Sense - Page 23 - Library Mode Parameters

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) +
              sizeof(MODE_LIBRARY_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_LIBRARY_MODE;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(modeBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    // Check to see if the Door Open and Door Auto Close are already set.

    librarymodePage = modeBuffer;
    (ULONG_PTR)librarymodePage += sizeof(MODE_PARAMETER_HEADER);

    if (!(librarymodePage->DoorAutoClose && librarymodePage->DoorOpenResponse)) {
        // Both are not set, issue Mode Select to set them

        // Save some parameters from the Mode Sense
        MODE_SENSE_VALUES.UnldMd = librarymodePage->UnldMd;
        MODE_SENSE_VALUES.Recirc = librarymodePage->Recirc;

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        length =  sizeof(MODE_PARAMETER_HEADER) +
                  sizeof(MODE_LIBRARY_PAGE);

        RtlZeroMemory(modeBuffer, length);
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->TimeOutValue = 20;
        srb->DataTransferLength = length;
        srb->DataBuffer = modeBuffer;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.SPBit = SETBITON;      // Save Parameters
        cdb->MODE_SELECT.PFBit = SETBITON;      // Page format is SCSI-2
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)length;

        // Library Mode is 0 == RANDOM;
        librarymodePage->PageCode = MODE_PAGE_LIBRARY_MODE;
        librarymodePage->PageLength = 0x02;
        librarymodePage->UnldMd = MODE_SENSE_VALUES.UnldMd;     // From Mode Sense
        librarymodePage->Recirc = MODE_SENSE_VALUES.Recirc;     // From Mode Sense
        librarymodePage->DoorAutoClose = 0x01;
        librarymodePage->DoorOpenResponse = 0x01;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                srb->DataBuffer,
                                                srb->DataTransferLength,
                                                TRUE);

        if (!NT_SUCCESS(status)) {
            ChangerClassFreePool(modeBuffer);
            ChangerClassFreePool(srb);
            return status;
        }
    }

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);
    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));
    RtlMoveMemory(productData->VendorId,
                  changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId,
                  changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision,
                  changerData->InquiryData.ProductRevisionLevel, 4);
    RtlMoveMemory(productData->SerialNumber,
                  changerData->SerialNumber, VPD_SERIAL_NUMBER_LENGTH);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerSetAccess(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )

/*++

Routine Description:

    This routine sets the state of the door or IEPort. Value can be one of the
    following:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;



    if ((setAccess->Element.ElementType) == ChangerKeypad) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (((setAccess->Element.ElementType) == ChangerIEPort) &&
         (((changerData->DriveID) == LXB_OR_LXG) ||
          ((changerData->DriveID) == LXS))) {

        //
        // All units have a DOOR. Even though the LXG can be configured to have an
        // IEPORT, this is not a configuration option.
        //
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    if (controlOperation == LOCK_ELEMENT) {
        cdb->MEDIA_REMOVAL.Prevent = 1;
    } else if (controlOperation == UNLOCK_ELEMENT) {
        cdb->MEDIA_REMOVAL.Prevent = 0;
    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                srb->DataBuffer,
                                                srb->DataTransferLength,
                                                writeToDevice);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
                       )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType != AllElements)
    {
        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType))
        {
            DebugPrint((1, "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }
    }

    // Compaq and Overland return different sized data structures for
    // the driveElementDescriptor. To determine the length of the real
    // data to be returned, we'll send out a request for just the first
    // 8 bytes of data. From bytes 5-7 of the header, we can add 8 more
    // bytes to it to get the length that this device will return for
    // the requested elements.

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    length = 8;  // header only ! ! !
    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;

    //
    // Voltag must be cleared for Transport Elements.
    // We want to get drive serialnumbers. So set
    // Voltag bit if we are reading status of drive
    //
    if (((readElementStatus->VolumeTagInfo) &&
        (elementType != ChangerTransport)) ||
        (elementType == ChangerDrive)) {
        cdb->READ_ELEMENT_STATUS.VolTag = 1;
    } else {
        cdb->READ_ELEMENT_STATUS.VolTag = 0;
    }

    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (NT_SUCCESS(status)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;

        // Get the length that would be returned if we'd have allocated
        // more space via the CDB.

        length =  (statusHeader->ReportByteCount[2]);
        length |= (statusHeader->ReportByteCount[1] << 8);
        length |= (statusHeader->ReportByteCount[0] << 16);

        // need to add 8 bytes to account for the header
        length = length + 8;

        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
    } else {
        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
        return status;
    }


    // now do the real ReadElementStatus command with the length acquired
    // from the last ReadElementStatus command

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;

    //
    // Voltag must be cleared for Transport Elements.
    // We want to get drive serialnumbers. So set
    // Voltag bit if we are reading status of drive
    //
    if (((readElementStatus->VolumeTagInfo) &&
        (elementType != ChangerTransport)) ||
        (elementType == ChangerDrive)) {
        cdb->READ_ELEMENT_STATUS.VolTag = 1;
    } else {
        cdb->READ_ELEMENT_STATUS.VolTag = 0;
    }

    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (NT_SUCCESS(status)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        POVR_ELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        ULONG remainingElements;
        ULONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        ULONG i;
        ULONG descriptorLength;

        // Determine total number elements returned.

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to its respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        typeCount /= descriptorLength;

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                elementStatus->Element.ElementAddress |=
                (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;


                if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Full;
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                    elementStatus->TargetId = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                }
                if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                    elementStatus->Lun = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Lun;
                }

                if (tagInfo) {  // Upper level requested volume tags
                    // Let's see if the library returned data
                    if (statusPage->PVolTag) {
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag, MAX_VOLUME_ID_SIZE);
                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {
                        RtlMoveMemory(elementStatus->AlternateVolumeID, elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.AlternateVolumeTag, OVR_ALT_VOLUME_ID_SIZE);
                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }
                }

                if (elementType == ChangerDrive) {
                    if (outputBuffLen >=
                        (numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
                        PCHANGER_ELEMENT_STATUS_EX elementStatusEx;

                        elementStatusEx = (PCHANGER_ELEMENT_STATUS_EX)elementStatus;

                        if (statusPage->AVolTag) {
                            PUCHAR serialNumber;
                            ULONG inx;

                            inx = 0;
                            serialNumber =
                                elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.AlternateVolumeTag;
                            while ((inx < OVR_ALT_VOLUME_ID_SIZE) &&
                                   (serialNumber[inx] != ' ') &&
                                   (serialNumber[inx] != '\0')) {
                                elementStatusEx->SerialNumber[inx] = serialNumber[inx];
                                inx++;
                            }

                            if (inx <= OVR_ALT_VOLUME_ID_SIZE) {
                                elementStatusEx->SerialNumber[inx] = '\0';
                            }

                            DebugPrint((3, "Serial number : %s\n",
                                        elementStatusEx->SerialNumber));

                            elementStatusEx->Flags |= ELEMENT_STATUS_PRODUCT_DATA;
                        }
                    }
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer and element descriptor array.
                //
                if (outputBuffLen >= (numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
                    DebugPrint((3, "Incrementing by sizeof(CHANGER_ELEMENT_STATUS_EX\n"));
                    (PUCHAR)elementStatus += sizeof(CHANGER_ELEMENT_STATUS_EX);
                } else {
                    elementStatus += 1;
                }
            }

            if (remainingElements) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                typeCount /= descriptorLength;
            }

        } while (remainingElements);

        if (outputBuffLen >= (numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
            Irp->IoStatus.Information = numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX);
        } else {
            Irp->IoStatus.Information = numberElements * sizeof(CHANGER_ELEMENT_STATUS);
        }
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN PIRP Irp
                              )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //
    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType ==
        AllElements) {

        // Build the normal SCSI-2 command for all elements.

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode =
        SCSIOP_INIT_ELEMENT_STATUS;

        // must set last byte to 0xC0, Do an init of barcodes and elements
        // since there is no option to do a non-barcoded InitElemStatus
        cdb->INIT_ELEMENT_STATUS.Reserved3 = 0x40;
        cdb->INIT_ELEMENT_STATUS.NoBarCode = 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {
        PCHANGER_ELEMENT_LIST elementList =
        &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = &elementList->Element;

        srb->CdbLength = CDB10GENERIC_LENGTH;
        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode =
        SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        // Addresses of elements need to be mapped from 0-based to device-specific.

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        // Indicate whether to use bar code scanning.

        // must set last byte to 0xC0, not 80 on BC Scan
        cdb->INITIALIZE_ELEMENT_RANGE.Reserved4 = 0x40;
        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = 1;
        // cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
                  IN PDEVICE_OBJECT DeviceObject,
                  IN PIRP Irp
                  )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

// The command is supported but it's a no-op...

{
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerExchangeMedium(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     )

/*++

Routine Description:

    None of the units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
                 )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    // bug fix - cannot do transport to other element moves
    if ((moveMedium->Source.ElementType == ChangerTransport) ||
        (moveMedium->Destination.ElementType == ChangerTransport)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                    "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                    "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                    "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
                       )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    // there is no command on this library to home or reinit the
    // changer mechanism

    return STATUS_INVALID_DEVICE_REQUEST;
}




NTSTATUS
ChangerQueryVolumeTags(
                      IN PDEVICE_OBJECT DeviceObject,
                      IN PIRP Irp
                      )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PCHANGER_SEND_VOLUME_TAG_INFORMATION volTagInfo = Irp->AssociatedIrp.SystemBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_ELEMENT    element = &volTagInfo->StartingElement;
    PSCSI_REQUEST_BLOCK srb;
    PVOID    tagBuffer;
    PCDB     cdb;
    NTSTATUS status;

    //
    // Do some validation.
    //

    if (volTagInfo->ActionCode != SEARCH_PRI_NO_SEQ) {
        DebugPrint((1,
                    "QueryVolumeTags: Invalid Action Code %x\n",
                    volTagInfo->ActionCode));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    tagBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, MAX_VOLUME_TEMPLATE_SIZE);

    if (!srb || !tagBuffer) {

        if (tagBuffer) {
            ChangerClassFreePool(tagBuffer);
        }
        if (srb) {
            ChangerClassFreePool(srb);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(tagBuffer, MAX_VOLUME_TEMPLATE_SIZE);

    //
    // Load buffer with template.
    //

    RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = MAX_VOLUME_TEMPLATE_SIZE;

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->SEND_VOLUME_TAG.OperationCode = SCSIOP_SEND_VOLUME_TAG;
    cdb->SEND_VOLUME_TAG.ElementType = (UCHAR)(element->ElementType);

    cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->SEND_VOLUME_TAG.ActionCode = (UCHAR)volTagInfo->ActionCode;


    cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
    cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;


    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            tagBuffer,
                                            MAX_VOLUME_TEMPLATE_SIZE,
                                            TRUE);

    ChangerClassFreePool(tagBuffer);

    if (NT_SUCCESS(status)) {

        PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
        PVOID statusBuffer;
        ULONG returnElements = irpStack->Parameters.DeviceIoControl.OutputBufferLength / sizeof(READ_ELEMENT_ADDRESS_INFO);
        ULONG requestLength;

        //
        // Size of buffer returned is based on the size of the user buffer. If it's incorrectly
        // sized, the IoStatus.Information will be updated to indicate how large it should really be.
        //

        requestLength = sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE) +
                        (OVR_FULL_SIZE * returnElements);

        statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, requestLength);
        if (!statusBuffer) {
            ChangerClassFreePool(srb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(statusBuffer, requestLength);

        //
        // Build read volume element command.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = requestLength;

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.OperationCode = SCSIOP_REQUEST_VOL_ELEMENT;
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.ElementType = (UCHAR)(element->ElementType);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[0] = (UCHAR)(returnElements >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[1] = (UCHAR)(returnElements & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.VolTag = 1;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[0] = (UCHAR)(requestLength >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[1] = (UCHAR)(requestLength & 0xFF);


        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                statusBuffer,
                                                requestLength,
                                                TRUE);


        if ((status == STATUS_SUCCESS) || (status == STATUS_DATA_OVERRUN)) {

            PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
            PELEMENT_STATUS_PAGE   statusPage;
            PCHANGER_ELEMENT_STATUS elementStatus;
            POVR_ELEMENT_DESCRIPTOR elementDescriptor;
            ULONG i;
            ULONG descriptorLength;
            ULONG numberElements;
            ULONG dataTransferLength = srb->DataTransferLength;

            //
            // Make it success.
            //

            status = STATUS_SUCCESS;

            //
            // Determine if ANY matches were found.
            //

            if (dataTransferLength <= sizeof(ELEMENT_STATUS_HEADER)) {
                numberElements = 0;
            } else {

                //
                // Subtract out header and page info.
                //

                dataTransferLength -= sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
                numberElements = dataTransferLength / OVR_FULL_SIZE;

            }

            DebugPrint((1,
                        "QueryVolumeTags: Matches found - %x\n",
                        numberElements));

            //
            // Update IoStatus.Information to indicate the correct buffer size.
            // Account for 'NumberOfElements' field + the array of elementStatus'.
            //

            Irp->IoStatus.Information =
                RTL_SIZEOF_THROUGH_FIELD(READ_ELEMENT_ADDRESS_INFO, NumberOfElements) +
                (numberElements * sizeof(CHANGER_ELEMENT_STATUS));

            //
            // Fill in user buffer.
            //

            readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            RtlZeroMemory(readElementAddressInfo, irpStack->Parameters.DeviceIoControl.OutputBufferLength);

            readElementAddressInfo->NumberOfElements = numberElements;

            if (numberElements) {
                //
                // The buffer is composed of a header, status page, and element descriptors.
                // Point each element to it's respective place in the buffer.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
                (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                elementStatus = &readElementAddressInfo->ElementStatus[0];

                //
                // Set values for each element descriptor.
                //

                for (i = 0; i < numberElements; i++ ) {

                    elementStatus->Element.ElementAddress = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -=
                    addressMapping->FirstElement[statusPage->ElementType];

                    elementStatus->Element.ElementType = statusPage->ElementType;

                    if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SValid) {

                        ULONG j;
                        USHORT tmpAddress;

                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    }

                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Full;
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                    if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                        elementStatus->TargetId = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                    }
                    if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                        elementStatus->Lun = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Lun;
                    }

                    RtlMoveMemory(elementStatus->PrimaryVolumeID, elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag, MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                    (ULONG_PTR)elementDescriptor += descriptorLength;
                }
            }
        } else {
            DebugPrint((1,
                        "QueryVolumeTags: RequestElementAddress failed. %x\n",
                        status));
        }

        ChangerClassFreePool(statusBuffer);

    } else {
        DebugPrint((1,
                    "QueryVolumeTags: Send Volume Tag failed. %x\n",
                    status));
    }
    if (srb) {
        ChangerClassFreePool(srb);
    }
    return status;
}



NTSTATUS
OvrBuildAddressMapping(
                      IN PDEVICE_OBJECT DeviceObject
                      )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = OVR_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                          + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);


    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                         elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                     elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                      elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                    elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;
        addressMapping->Initialized = TRUE;
    }


    //
    // Determine the lowest element address for use with AllElements.
    //

    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {

            DebugPrint((1,
                        "BuildAddressMapping: New lowest address %x\n",
                        addressMapping->FirstElement[i]));
            addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
                 IN POVR_ELEMENT_DESCRIPTOR ElementDescriptor
                 )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.AdditionalSenseCode;
    UCHAR asq = ElementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.AddSenseCodeQualifier;
    ULONG exceptionCode;

    switch (asc) {
    case 0x3B:
        switch (asq) {
        case 0x90:
        case 0x91:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
        }
        break; //0x3B

    case 0x80:
        switch (asq) {
        case 0x01:
        case 0x02:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
        }
        break; //0x80

    case 0x83:
        switch (asq) {
        case 0x1:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        case 0x2:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        case 0x4:
            exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
            break;

        case 0x9:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;

        }
        break; // 0x83

    default:
        exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;
}



BOOLEAN
ElementOutOfRange(
                 IN PCHANGER_ADDRESS_MAPPING AddressMap,
                 IN USHORT ElementOrdinal,
                 IN ELEMENT_TYPE ElementType
                 )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((0,
                    "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                    ElementType,
                    ElementOrdinal,
                    AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == OVR_NO_ELEMENT) {

        DebugPrint((1,
                    "ElementOutOfRange: No Type %x present\n",
                    ElementType));

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\hpmc\hpmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    hpmc.c

Abstract:

    This module contains device-specific routines for HP MO and DLT medium changers:
    HP 40FX, HP ..... TODO

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "hpmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, HpmoBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the HP DLT and MO changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    changerData->DeviceLocksPort = 1;

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"C1160A",6) == 6) {
        changerData->DriveType = HP_MO;
        changerData->DriveID   = HP1160;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C1160F",6) == 6) {
        changerData->DriveType = HP_MO;
        changerData->DriveID = HP1160;

    } else if ((RtlCompareMemory(dataBuffer->ProductId,"C1100F",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1107F",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1118J",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1100J",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1118M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1119M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1170M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1160M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1150M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1111M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1110M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1107M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1105M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1104M",6) == 6)) {

        changerData->DriveType = HP_MO;
        changerData->DriveID = HP1100;
        changerData->DeviceLocksPort = 1;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5153F",6) == 6) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5153;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C1718T",6) == 6) {
        changerData->DriveType = HP_MO;
        changerData->DriveID = HP1718;
        changerData->DeviceLocksPort = 0;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C1194F",6) == 6) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP1194;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5151-4000", 10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5151;
        changerData->DeviceLocksPort = 0;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5151-2000", 10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5151;
        changerData->DeviceLocksPort = 0;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5177-4000",10) == 10) {

        //
        // Fast Wide versions of 1194 with DLT4000 and DLT7000 drives
        //

        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP1194;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5177-7000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP1194;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5173-4000",10) == 10) {

        //
        // Fast Wide versions of 5151 with DLT4000 and DLT7000 drives
        //

        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5151;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5173-7000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5151;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C6280-4000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP418;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C6280-7000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP418;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C6280-8000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP418;
    } else if ((RtlCompareMemory(dataBuffer->ProductId,"C7200",5) == 5) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C7145",5) == 5) ||
               (RtlCompareMemory(dataBuffer->ProductId,"PV-128T",7) == 7)) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP7000;
    }

    //
    // Check for Plasmon and Pinnacle.
    //

    if (RtlCompareMemory(dataBuffer->VendorId,"PINNACLE", 8) == 8) {
        if (RtlCompareMemory(dataBuffer->ProductId,"ALTA", 4) == 4) {

            //
            // Acts like an 1100
            //

            changerData->DriveType = HP_MO;
            changerData->DriveID = PINNACLE;
            changerData->DeviceLocksPort = 1;
        }
    } else if (RtlCompareMemory(dataBuffer->VendorId,"IDE     ", 8) == 8) {

        if (RtlCompareMemory(dataBuffer->ProductId,"MULTI", 5) == 5) {
            changerData->DriveType = HP_MO;
            changerData->DriveID = PLASMON;
            changerData->DeviceLocksPort = 0;
        }
    }

    DebugPrint((1,
               "ChangerInitialize: DriveType %x, DriveID %x\n",
               changerData->DriveType,
               changerData->DriveID));

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = HpmoBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Send an allow to the unit to ensure that the LockCount and state of the unit
    // are in sync.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb.Cdb;
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.DataTransferLength = 0;
    srb.TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     NULL,
                                     0,
                                     FALSE);
    return STATUS_SUCCESS;
}

VOID
ScanForSpecial(
     IN PDEVICE_OBJECT DeviceObject,
     IN PGET_CHANGER_PARAMETERS ChangerParameters
     )

/*
   Routine Description : 
      This routine reads from registry certain hardware features, 
      and overrides the features derived (incorrectly) from the device.
      
   Arguments:
      DeviceObject  Pointer to the functional device object
      changerParameters Pointer to GET_CHANGER_PARAMETERS struct
   
   Return Value:
      None
 */

{
   PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension;
   PCHANGER_DATA   changerData; 
   NTSTATUS status;
   HANDLE deviceHandle, keyHandle;
   ULONG DeviceHasDoor, IEPortUserClose;
   RTL_QUERY_REGISTRY_TABLE queryTable[3];
   PDEVICE_OBJECT physicalDeviceObject;
   OBJECT_ATTRIBUTES ObjAttributes;
   UNICODE_STRING DriverName;
   ULONG DeviceBit;

   DebugPrint((3, "Entered ScanForSpecial in HPMC.SYS.\n"));
   
   ASSERT(DeviceObject != NULL);
   fdoExtension = DeviceObject->DeviceExtension;
   
   ASSERT(fdoExtension != NULL);
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   
   physicalDeviceObject = fdoExtension->LowerPdo;

   //
   // Open a handle to the device node.
   //
   status = IoOpenDeviceRegistryKey(physicalDeviceObject, 
                                    PLUGPLAY_REGKEY_DEVICE, 
                                    KEY_QUERY_VALUE, 
                                    &deviceHandle);
   if (!NT_SUCCESS(status)) {
       DebugPrint((1, 
                   "IoOpenDeviceRegistryKey Failed in ScanForSpecial : %x.\n",
                   status));
       return;
   }

   DebugPrint((3, 
             "IoOpenDeviceRegistryKey success in HPMC.SYS!ScanForSpecial.\n"));
   
   RtlInitUnicodeString(&DriverName, HPMC_MEDIUM_CHANGER);
   
   RtlZeroMemory(queryTable, sizeof(queryTable));

   InitializeObjectAttributes(&ObjAttributes, &DriverName, 
                               (OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE),
                               deviceHandle, NULL);
   status = ZwOpenKey(&keyHandle, KEY_READ, &ObjAttributes);
   if (!NT_SUCCESS(status)) {
      DebugPrint((1, "ZwOpenKey failed in hpmc.sys : %x.\n",
                  status));
      ZwClose(deviceHandle);
      return;
   }
   
   //
   // Read values for device specific features from registry.
   // If the device has door, DeviceHasDoor flag should
   // be set to 1. Otherwise 0. Similarly, if IEPort
   // should be closed by the user, IEPortUserClose flag
   // should be set to 1. Otherwise 0.
   //
   queryTable[0].Flags = (RTL_QUERY_REGISTRY_REQUIRED | 
                             RTL_QUERY_REGISTRY_DIRECT);
   queryTable[0].Name = (PWSTR) DEVICE_DOOR;
   queryTable[0].EntryContext = &DeviceHasDoor;
   queryTable[0].DefaultType = REG_DWORD;
   queryTable[0].DefaultData = NULL;
   queryTable[0].DefaultLength = 0;
   
   queryTable[1].Flags = (RTL_QUERY_REGISTRY_REQUIRED | 
                          RTL_QUERY_REGISTRY_DIRECT);
   queryTable[1].Name = (PWSTR) DEVICE_IEPORT_USER_CLOSE;
   queryTable[1].EntryContext = &IEPortUserClose;
   queryTable[1].DefaultType = REG_DWORD;
   queryTable[1].DefaultData = NULL;
   queryTable[1].DefaultLength = 0;

   status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE, 
                                   (PWSTR)keyHandle, queryTable, 
                                   NULL, NULL);
   if (!NT_SUCCESS(status)) {
      DebugPrint((1, 
                  "QueryRegistry failed for DEVICE_DOOR : %d.\n",
                  status));
      ZwClose(keyHandle);
      ZwClose(deviceHandle);
      return;
   }
      
   //
   // Check the bit corresponding to this device to determine if
   // the device has door and if IEPort should be closed by the user.
   //
   DeviceBit = (1 << ((changerData->DriveID) - 1));

   if ((DeviceHasDoor & DeviceBit) == 0) {
      DebugPrint((3, "Modifying LockUnlockCapabilities flag.\n"));
      ChangerParameters->LockUnlockCapabilities &= ~LOCK_UNLOCK_DOOR;
   }

   if ((IEPortUserClose & DeviceBit) != 0) {
      DebugPrint((3, "Modifying Features1 flag.\n"));
      ChangerParameters->Features1 |= CHANGER_IEPORT_USER_CONTROL_CLOSE;
   }

   // 
   // Close the handle to the registry subkey and devnode
   //
   ZwClose(keyHandle);
   ZwClose(deviceHandle);
   
   return;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

            case SCSI_SENSE_ILLEGAL_REQUEST:

                //if (senseBuffer->AdditionalSenseCode == ?? sense data for 'the unit is locked') {
                //}
                break;

            case SCSI_SENSE_UNIT_ATTENTION:

                changerData->LockCount = 0;
                break;

            case SCSI_SENSE_HARDWARE_ERROR: {
                changerData->DeviceStatus = HPMC_HW_ERROR;
                break;
            }

            default:
                break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    HP changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    if (changerData->DriveID == HP1718) {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    } else {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
        cdb->MODE_SENSE.Dbd = 1;
    }

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    if (changerData->DriveID == HP1718) {
        (PCHAR)elementAddressPage += (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK));
    } else {
        (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);
    }

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = HP_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }
    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    if (changerData->DriveType == HP_DLT) {
        changerParameters->NumberOfDoors = 1;
    } else {
        changerParameters->NumberOfDoors = 0;
    }

    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    if (changerData->DriveID == HP5153 || changerData->DriveID == HP5151) {
        changerParameters->MagazineSize = 5;
    } else if (changerData->DriveID == HP7000) {
        changerParameters->MagazineSize = 6;
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;


    if (changerData->DriveID == HP1718) {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY);
    } else {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY);
        cdb->MODE_SENSE.Dbd = 1;
    }
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    if (changerData->DriveID == HP1718) {
        (PCHAR)transportGeometryPage += (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK));
    } else {
        (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);
    }

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;
    changerParameters->Features1 = 0;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->DriveCleanTimeout = 300;
    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_IEPORT | LOCK_UNLOCK_DOOR);
    changerParameters->PositionCapabilities = (CHANGER_TO_SLOT      |
                                               CHANGER_TO_IEPORT    |
                                               CHANGER_TO_DRIVE);

    if (changerData->DriveID == HP1194) {
        changerParameters->Features0 |= CHANGER_BAR_CODE_SCANNER_INSTALLED      |
                                        CHANGER_CLOSE_IEPORT                    |
                                        CHANGER_OPEN_IEPORT                     |
                                        CHANGER_EXCHANGE_MEDIA                  |
                                        CHANGER_LOCK_UNLOCK                     |
                                        CHANGER_POSITION_TO_ELEMENT             |
                                        CHANGER_REPORT_IEPORT_STATE             |
                                        CHANGER_DEVICE_REINITIALIZE_CAPABLE     |
                                        CHANGER_DRIVE_CLEANING_REQUIRED         |
                                        CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;
    }

    if ((changerData->DriveID == HP5151) || 
        (changerData->DriveID == HP5153) ||
        (changerData->DriveID == HP7000)) {
        changerParameters->Features0 |= CHANGER_BAR_CODE_SCANNER_INSTALLED  |
                                        CHANGER_LOCK_UNLOCK                 |
                                        CHANGER_POSITION_TO_ELEMENT         |
                                        CHANGER_DRIVE_CLEANING_REQUIRED     |
                                        CHANGER_DEVICE_REINITIALIZE_CAPABLE |
                                        CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;

    } else if (changerData->DriveID == HP418) {
        changerParameters->Features0 |= CHANGER_LOCK_UNLOCK                 |
                                        CHANGER_POSITION_TO_ELEMENT         |
                                        CHANGER_DRIVE_CLEANING_REQUIRED     |
                                        CHANGER_DEVICE_REINITIALIZE_CAPABLE |
                                        CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;

       changerParameters->Features1 |= CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR;
    }

    if (changerData->DriveType == HP_MO) {

        //
        // MO units
        //

        changerParameters->Features0 |= CHANGER_CLOSE_IEPORT                  |
                                        CHANGER_OPEN_IEPORT                   |
                                        CHANGER_EXCHANGE_MEDIA                |
                                        CHANGER_LOCK_UNLOCK                   |
                                        CHANGER_POSITION_TO_ELEMENT           |
                                        CHANGER_DEVICE_REINITIALIZE_CAPABLE   |
                                        CHANGER_REPORT_IEPORT_STATE;

        changerParameters->DriveCleanTimeout = 0;

        if (changerData->DriveID == PLASMON) {

            //
            // IEport can't retract and can't tell when media is inserted when open.
            //

            changerParameters->Features0 &= ~CHANGER_CLOSE_IEPORT;
            changerParameters->Features0 &= ~CHANGER_REPORT_IEPORT_STATE;

            //
            // Transport needs to be positioned in front of drive on dismount.
            //

            changerParameters->Features1 |= CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE;
        }

        if (changerData->DriveID == PINNACLE) {

            changerParameters->Features0 &= ~(CHANGER_CLOSE_IEPORT | CHANGER_OPEN_IEPORT);
        }
    } else {

        //
        // DLT
        //

        changerParameters->Features0 |= CHANGER_CLEANER_ACCESS_NOT_VALID;
    }

    if ((changerData->DriveID == HP1100) || (changerData->DriveID == PINNACLE)) {
        changerParameters->Features0 &= ~CHANGER_EXCHANGE_MEDIA;
        changerParameters->LockUnlockCapabilities &= ~LOCK_UNLOCK_DOOR;
    }

    if ((changerData->DriveID == HP5151) || 
        (changerData->DriveID == HP418)) {
        changerParameters->PositionCapabilities &= ~CHANGER_TO_IEPORT;
        changerParameters->LockUnlockCapabilities &= ~LOCK_UNLOCK_IEPORT;

    }
    
    if (changerData->DriveID == HP1160) {
        changerParameters->LockUnlockCapabilities &= ~LOCK_UNLOCK_DOOR;
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (changerData->DriveID == HP1718) {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    } else {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
        cdb->MODE_SENSE.Dbd = 1;
    }
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    if (changerData->DriveID == HP1718) {
        (PCHAR)capabilitiesPage += (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK));
    } else {
        (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);
    }

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    if (changerData->DriveID == HP418) {

        //
        // As slot->slot moves are only available on a subset of slots, claim no support.
        //

        changerParameters->MoveFromSlot &= ~CHANGER_TO_SLOT;
    }
    if (changerData->DriveType == HP_DLT) {

        if ((changerData->DriveID == HP1194) ||
            (changerData->DriveID == HP7000)) {
            changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
            changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
            changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
            changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

        } else {
            changerParameters->MoveFromIePort = 0;
        }

    } else {
        changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
        changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
        changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
        changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;
    }

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;



    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    ScanForSpecial(DeviceObject, changerParameters);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    LONG                lockValue = 0;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (changerData->DeviceLocksPort) {
        if (controlOperation == LOCK_ELEMENT) {

            //
            // Inc the lock count to indicate that a prevent is on the device.
            //

            InterlockedIncrement(&changerData->LockCount);

        } else if (controlOperation == UNLOCK_ELEMENT) {

            //
            // Dec the lock count to indicate that an unlock has been sent.
            //

            changerData->LockCount = 0;
        } else {

            //
            // Either an extend or retract.
            // Need to ensure that the unit isn't locked down.
            //

            lockValue = changerData->LockCount;
            DebugPrint((1,
                       "SetAccess: LockCount is %x\n",
                       changerData->LockCount));


            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;

            srb->CdbLength = CDB6GENERIC_LENGTH;

            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
        }
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (setAccess->Element.ElementType == ChangerDoor) {

        if (controlOperation == LOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the door.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;
        }

    } else if (setAccess->Element.ElementType == ChangerIEPort) {

        if (addressMapping->NumberOfElements[ChangerIEPort] == 0) {
            status = STATUS_INVALID_PARAMETER;
        } else {

            if (controlOperation == LOCK_ELEMENT) {

                cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

                //
                // Issue prevent media removal command to lock the ie port.
                //

                cdb->MEDIA_REMOVAL.Prevent = 1;

            } else if (controlOperation == UNLOCK_ELEMENT) {

                cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

                //
                // Issue allow media removal.
                //

                cdb->MEDIA_REMOVAL.Prevent = 0;

            } else if (controlOperation == EXTEND_IEPORT) {

                if (changerData->DriveID == PINNACLE) {

                    ChangerClassFreePool(srb);
                    return STATUS_INVALID_DEVICE_REQUEST;
                }

                srb->TimeOutValue = fdoExtension->TimeOutValue;

                //
                // Hp uses a vendor unique mailslot command.
                //

                cdb->CDB6GENERIC.OperationCode = SCSIOP_ROTATE_MAILSLOT;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = HP_MAILSLOT_OPEN;

            } else if (controlOperation == RETRACT_IEPORT) {

                if (changerData->DriveID == PINNACLE) {
                    ChangerClassFreePool(srb);
                    return STATUS_INVALID_DEVICE_REQUEST;
                }

                srb->TimeOutValue = fdoExtension->TimeOutValue;

                //
                // Hp uses a vendor unique mailslot command.
                //

                cdb->CDB6GENERIC.OperationCode = SCSIOP_ROTATE_MAILSLOT;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = HP_MAILSLOT_CLOSE;

            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
    } else {

        //
        // No keypad selectivity programatically.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
        if (status == STATUS_INVALID_DEVICE_REQUEST) {

            //
            // If EXTEND\RETRACT IEPort is not supported
            // by this changer, then just ignore the
            // error
            //
            if ((controlOperation == RETRACT_IEPORT) ||
                (controlOperation == EXTEND_IEPORT)) {

                DebugPrint((1, "Extend or Retract not supported\n"));
                status = STATUS_SUCCESS;
            }
        }

    }

    if (lockValue) {
        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB6GENERIC_LENGTH;

        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
        status = STATUS_SUCCESS;
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT_STATUS_EX   elementStatusEx;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    BOOLEAN  IsSCSI3 = FALSE;

    if (((changerData->InquiryData.Versions) & 0x7) >= 3) {
        IsSCSI3 = TRUE;
    }

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (readElementStatus->VolumeTagInfo) {

        if (changerData->DriveType == HP_MO || changerData->DriveID == HP418) {

            //
            // These units have no Volume tag capability. DLT have this capability
            //

            return STATUS_INVALID_PARAMETER;

        }
    }

    if ((changerData->DriveID == HP7000) &&
        (elementType == ChangerIEPort)) {
        LARGE_INTEGER waitTime;

        waitTime.LowPart = (ULONG)(- ( 10 * 1000 * 10000 ));
        waitTime.HighPart = -1;
        KeDelayExecutionThread(KernelMode, FALSE, &waitTime);
    }

    if (elementType != AllElements)
    {
        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType))
        {
            DebugPrint((1, "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate only for the status header, send down the SRB, and then use the
    // correct length from the header.
    //
    length = sizeof(ELEMENT_STATUS_HEADER);
    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer)
    {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements)
    {
        //
        // The HP's may not have the low address as 0.
        //
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);
    }
    else
    {
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // If we are using SCSI-3 set Dvc Id bit (1st bit of the 7th byte in
    // the CDB) to retrieve "Device Identification Descriptor"
    //
    // ISSUE - 2000/02/11 - nramas : Should change Reserved1 field in CDB
    // to meaningful name.
    //
    if ((elementType == ChangerDrive) && (IsSCSI3 == TRUE))
    {
       cdb->READ_ELEMENT_STATUS.Reserved1 = 0x01;

       //
       // In the descriptor returned for Drive, product info
       // follows volumetag info. So, we get both volume tag
       // and product info for drives
       //
       cdb->READ_ELEMENT_STATUS.VolTag = 0x01;
    }

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (NT_SUCCESS(status) || STATUS_DATA_OVERRUN == status)
    {
        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;;
        
        if (STATUS_DATA_OVERRUN == status)
        {
            if ((srb->DataTransferLength) <= length)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                DebugPrint((1, "HPMC:ReadElementStatus - Dataoverrun.\n"));
                ChangerClassFreePool(srb);
                ChangerClassFreePool(statusBuffer);
          
                return status;
            }
        }
        
        //
        // Get the actual needed length
        //
        length =  (statusHeader->ReportByteCount[2]);
        length |= (statusHeader->ReportByteCount[1] << 8);
        length |= (statusHeader->ReportByteCount[0] << 16);

        //
        // Account for the size of the status header
        //
        length += sizeof(ELEMENT_STATUS_HEADER);

        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
    }
    else
    {
        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    totalElements = readElementStatus->ElementList.NumberOfElements;

    DebugPrint((1,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    //
    // now do the real ReadElementStatus command with the length acquired 
    // from the last ReadElementStatus command
    //
    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // The HP's may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // If we are using SCSI-3 set Dvc Id bit (1st bit of the 7th byte in
    // the CDB) to retrieve "Device Identification Descriptor"
    //
    // ISSUE - 2000/02/11 - nramas : Should change Reserved1 field in CDB
    // to meaningful name.
    //
    if ((elementType == ChangerDrive) && (IsSCSI3 == TRUE)) {

       cdb->READ_ELEMENT_STATUS.Reserved1 = 0x01;

       //
       // In the descriptor returned for Drive, product info
       // follows volumetag info. So, we get both volume tag
       // and product info for drives
       //
       cdb->READ_ELEMENT_STATUS.VolTag = 0x01;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if ((NT_SUCCESS(status)) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if ((srb->DataTransferLength) <= length) {
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "HPMC:ReadElementStatus - Dataoverrun.\n"));
              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);
          
              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements < 0 ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements less than zero - %x\n",
                       remainingElements));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        if (typeCount < 0) {
            DebugPrint((1,
                       "ChangerGetElementStatus (1): Count of type %x less than zero - %x\n",
                       elementType,
                       typeCount));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                if ((tagInfo) ||
                    (IsSCSI3 == TRUE)) {

                    //
                    // For drive and slot types, copy the additional fields (vol tag info).
                    //

                    if (elementType == ChangerDrive) {
                        PHPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS driveDescriptor =
                                                                (PHPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                        if (statusPage->PVolTag) {
                            RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                                          driveDescriptor->VolumeTagInformation, 
                                          MAX_VOLUME_ID_SIZE);

                            elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                        }

                        //
                        // Copy Device indentification information if
                        // the device implemenets SCSI-3 or higher
                        //
                        if (IsSCSI3 == TRUE) {
                            if (outputBuffLen >= 
                                (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {

                                elementStatusEx = (PCHANGER_ELEMENT_STATUS_EX)elementStatus; 

                                RtlMoveMemory(elementStatusEx->VendorIdentification,
                                              driveDescriptor->VendorID,
                                              VENDOR_ID_LENGTH);

                                RtlMoveMemory(elementStatusEx->ProductIdentification,
                                              driveDescriptor->ProductID,
                                              PRODUCT_ID_LENGTH);

                                //
                                // Serial number is 10 bytes long
                                //
                                RtlMoveMemory(elementStatusEx->SerialNumber,
                                              driveDescriptor->SerialNumber,
                                              10);

                                DebugPrint((3, 
                                            "Serial number : %s\n",
                                            elementStatusEx->SerialNumber));
                                elementStatusEx->Flags |= ELEMENT_STATUS_PRODUCT_DATA;
                            }
                        }
                        
                        if (elementDescriptor->IdValid) {
                            elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                            elementStatus->TargetId = elementDescriptor->BusAddress;
                        }

                        if (elementDescriptor->LunValid) {
                            elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                            elementStatus->Lun = elementDescriptor->Lun;
                        }

                        //
                        // Source address
                        //

                        if (elementDescriptor->SValid) {

                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                        }

                    } else if (elementType == ChangerSlot) {
                        PHPMO_ELEMENT_DESCRIPTOR_PLUS slotDescriptor =
                                                         (PHPMO_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                        if (statusPage->PVolTag) {
                            RtlMoveMemory(elementStatus->PrimaryVolumeID, slotDescriptor->VolumeTagInformation, MAX_VOLUME_ID_SIZE);
                            elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                        }

                        if (elementDescriptor->SValid) {

                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                        }
                    }

                } else {

                    if (elementType == ChangerDrive) {

                        //
                        // Source address
                        //

                        if (elementDescriptor->SValid) {
                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                        }

                        if (elementDescriptor->IdValid) {
                            elementStatus->TargetId = elementDescriptor->BusAddress;
                        }
                        if (elementDescriptor->LunValid) {
                            elementStatus->Lun = elementDescriptor->Lun;
                        }
                    }
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                if (elementType == ChangerDrive) {
                    elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->SValid << 23);
                }

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // The HP units don't have the capability of reporting exceptions
                    // in this manner except for - DataTransferElements on Optical
                    // DataXfer, Slot on DLT
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                } else if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    ULONG index;

                    //
                    // Ensure that the tag info isn't all spaces. This indicates an error.
                    //

                    for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                        if (elementStatus->PrimaryVolumeID[index] != ' ') {
                            break;
                        }
                    }

                    //
                    // Determine if the volume id was all spaces. Do an extra check to see if media is
                    // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                    //

                    if ((index == MAX_VOLUME_ID_SIZE) && (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                        DebugPrint((1,
                                   "Hpmc.GetElementStatus: Setting exception to LABEL_UNREADABLE\n"));

                        elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                if (outputBuffLen >= 
                    (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
                    DebugPrint((3, 
                                "Incrementing by sizeof(CHANGER_ELEMENT_STATUS_EX\n"));
                    (PUCHAR)elementStatus += sizeof(CHANGER_ELEMENT_STATUS_EX);
                } else {
                    elementStatus += 1;
                }

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }

                if (typeCount < 0) {
                    DebugPrint((1,
                               "ChangerGetElementStatus(2): Count of type %x less than zero - %x\n",
                               elementType,
                               typeCount));
                }
            }

        } while (remainingElements);


        DebugPrint((3, "IoStatus.Information set to %d\n",
                    outputBuffLen));
        if (outputBuffLen >= 
            (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
            Irp->IoStatus.Information = totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX);
        } else {
            Irp->IoStatus.Information = totalElements * sizeof(CHANGER_ELEMENT_STATUS);
        }
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{


    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    switch (changerData->DriveID) {
        case HP5151:
        case HP5153:
        case HP418:
        case HP7000: {
            DebugPrint((1, "ChangerExchangeMedium not supported for device %d\n",
                        (changerData->DriveID)));
            return STATUS_INVALID_DEVICE_REQUEST;
        } 

        default:  {
            break;
        }
    } // switch (changerData->DriveID)

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // for HP 1194, if the source or destination is an IEPORT,
    // do an allow before the move and a prevent after the move.
    // This works around the behaviour of the device whereby a PreventMediumRemoval
    // inhibits a MoveMedium to/from the IEPORT.
    //

    if ((changerData->DeviceLocksPort) &&
       ((exchangeMedium->Destination1.ElementType == ChangerIEPort) ||
        (exchangeMedium->Destination2.ElementType == ChangerIEPort) ||
        (exchangeMedium->Source.ElementType == ChangerIEPort))) {


        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "ExchangeMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "ExchangeMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }

    if ((changerData->DeviceLocksPort) &&
       ((exchangeMedium->Destination1.ElementType == ChangerIEPort) ||
        (exchangeMedium->Destination2.ElementType == ChangerIEPort) ||
        (exchangeMedium->Source.ElementType == ChangerIEPort))) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The calling layer will need to fixup any problems with
            // prevent/allow.
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                                    srb,
                                                    NULL,
                                                    0,
                                                    FALSE);

            DebugPrint((1,
                       "ExchangeMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // for many HP units, if the source or destination is an IEPORT,
    // do an allow before the move and a prevent after the move.
    // This works around the behaviour of the device whereby a PreventMediumRemoval
    // inhibits a MoveMedium to/from the IEPORT.
    //

    if ((changerData->DeviceLocksPort) &&
        ((moveMedium->Destination.ElementType == ChangerIEPort) ||
         (moveMedium->Source.ElementType == ChangerIEPort))) {


        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    if ((changerData->DeviceLocksPort) &&
        ((moveMedium->Destination.ElementType == ChangerIEPort) ||
         (moveMedium->Source.ElementType == ChangerIEPort))) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The LM will fixup any problems with
            // prevent/allow
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                    srb,
                                    NULL,
                                    0,
                                    FALSE);
            DebugPrint((1,
                       "MoveMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ChangerClassFreePool(srb);

    DebugPrint((1,
               "MoveMedium: Returning %x\n",
               status));
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    //
    // Clear locks.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);
    //
    // Set LockCount to zero.
    //

    changerData->LockCount = 0;

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
HpmoBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = HP_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    if (changerData->DriveID == HP1718) {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    } else {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
        cdb->MODE_SENSE.Dbd = 1;
    }

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    if (changerData->DriveID == HP1718) {
        (PCHAR)elementAddressPage += (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK));
    } else {
        (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);
    }

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = HP_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);


        if (changerData->DriveType == HP_MO) {
            addressMapping->NumberOfElements[ChangerDoor] = 0;
        } else {
            addressMapping->NumberOfElements[ChangerDoor] = 1;
        }
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }




    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;

    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "Hpmc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == HP_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   changerId = changerData->DriveID;

   //
   // Initialize the devicestatus in the device extension to
   // HPMC_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = HPMC_DEVICE_PROBLEM_NONE;
   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "HPMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set the selftest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
       changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) == HPMC_HW_ERROR) {
       //
       // Diagnostic test failed. Do ReceiveDiagnostic to receive
       // the results of the diagnostic test
       //
       RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

       cdb = (PCDB)srb->Cdb;
       cdb->CDB6GENERIC.OperationCode = SCSIOP_RECEIVE_DIAGNOSTIC;
       cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(HPMC_RECV_DIAG);
       resultBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                               sizeof(HPMC_RECV_DIAG));
       if (resultBuffer == NULL) {
           //
           // No memory to receive diagnostic result. Set the
           // generic error code (DeviceProblemHardware), but return
           // STATUS_SUCCESS anyway.
           //
           changerDeviceError->ChangerProblemType = DeviceProblemHardware;
           DebugPrint((1, "HPMC:PerformDiagnostics - Not enough memory to ",
                       "receive diagnostic results\n"));

           ChangerClassFreePool(srb);
           return STATUS_SUCCESS;
       }

       srb->DataTransferLength = sizeof(HPMC_RECV_DIAG);
       srb->DataBuffer = resultBuffer;
       srb->CdbLength = CDB6GENERIC_LENGTH;
       srb->TimeOutValue = 120;

       status = ChangerClassSendSrbSynchronous(DeviceObject,
                                        srb,
                                        srb->DataBuffer,
                                        srb->DataTransferLength,
                                        FALSE);
       if (NT_SUCCESS(status)) {
           ProcessDiagnosticResult(changerDeviceError,
                                   resultBuffer,
                                   changerId);
       }

       ChangerClassFreePool(resultBuffer);
       status = STATUS_SUCCESS;
   }

   ChangerClassFreePool(srb);
   return status;
}


VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer,
    IN ULONG changerId
    )
/*+++

Routine Description :

   This routine parses the data returned by the device on
   Receive Diagnostic command, and returns appropriate
   value for the problem type.

Arguements :

   changerDeviceError - Output buffer with diagnostic info

   resultBuffer - Buffer in which the data returned by the device
                  Receive Diagnostic command is stored.

   changerId    - Type of DDS changer (COMPAQ_TSL, SONY_TSL, etc)

Return Value :

   DeviceProblemNone - If there is no problem with the device
   Appropriate status code indicating the changer problem type.
--*/
{
   UCHAR errorCode;
   UCHAR FRU_One;
   UCHAR FRU_Two;
   UCHAR FRU_Three;
   CHANGER_DEVICE_PROBLEM_TYPE changerErrorType;
   PHPMC_RECV_DIAG  diagBuffer;

   changerErrorType = DeviceProblemNone;
   diagBuffer = (PHPMC_RECV_DIAG)resultBuffer;

   errorCode = diagBuffer->HWErrorCode;
   FRU_One = diagBuffer->FRU_1;
   FRU_Two = diagBuffer->FRU_2;
   FRU_Three = diagBuffer->FRU_3;

   //
   // ISSUE: 02/24/2000 - nramas
   // Not sure if the FRUs returned indicate a hardware error
   // or not. For now, do not return HW error for them.
   //
   DebugPrint((1, "HPMC\\RecvDiag : FRU_1 %x, FRU_2 %x, FRU_3 %x\n",
               FRU_One, FRU_Two, FRU_Three));
   if (errorCode) {
       changerErrorType = DeviceProblemHardware;
   }

   changerDeviceError->ChangerProblemType = changerErrorType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\m4mc\m4mc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    m4mc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _M4_MC_
#define _M4_MC_

//
// M4Data uses an addition 4 bytes on their device capabilities page...
//

typedef union _M4_ELEMENT_DESCRIPTOR {

    struct _M4_FULL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
    } M4_FULL_ELEMENT_DESCRIPTOR, *PM4_FULL_ELEMENT_DESCRIPTOR;

    struct _M4_PARTIAL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } M4_PARTIAL_ELEMENT_DESCRIPTOR, *PM4_PARTIAL_ELEMENT_DESCRIPTOR;

} M4_ELEMENT_DESCRIPTOR, *PM4_ELEMENT_DESCRIPTOR;

#define M4_PARTIAL_SIZE sizeof(struct _M4_PARTIAL_ELEMENT_DESCRIPTOR)
#define M4_FULL_SIZE sizeof(struct _M4_FULL_ELEMENT_DESCRIPTOR)

#define M4_NO_ELEMENT 0xFFFF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\nsmmc\nsmmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    nsmmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _NSM_MC_
#define _NSM_MC_

typedef struct _NSM_STORAGE_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR ExEnable : 1;
    UCHAR InEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} NSM_ELEMENT_DESCRIPTOR, *PNSM_ELEMENT_DESCRIPTOR;

#define NSM_NO_ELEMENT 0xFFFF


#define NSM_SERIAL_NUMBER_LENGTH        12

typedef struct _SERIALNUMBER {
    UCHAR DeviceType : 5;
    UCHAR PeripheralQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[NSM_SERIAL_NUMBER_LENGTH];
} SERIALNUMBER, *PSERIALNUMBER;


#define MERCURY_40 0x01


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Indicates the unit being supported.
    //

    ULONG DeviceID;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As the HP units lock the IEPort on these operations
    // MoveMedium/SetAccess might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[NSM_SERIAL_NUMBER_LENGTH];

    //
    // Pad out to ULONG.
    //

    BOOLEAN HardwareError;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
NSMBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\nsmmc\nsmmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    nsmmc.c

Abstract:

    This module contains device-specific routines for NSM Mercury Cd library devices

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "nsmmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, NSMBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the NSM changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //


    status = NSMBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"Mercury-40S",11) == 11) {
        changerData->DeviceID = MERCURY_40;
    }

    //
    // Get the Vital Product Data page.
    //

    serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(SERIALNUMBER));
    if (!serialBuffer) {
        DebugPrint((1, "BuildAddressMapping failed. %x\n", status));

        ChangerClassFreePool(dataBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(serialBuffer, sizeof(SERIALNUMBER));

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set EVPD
    //

    cdb->CDB6INQUIRY.Reserved1 = 1;

    //
    // Unit serial number page.
    //

    cdb->CDB6INQUIRY.PageCode = 0x80;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIALNUMBER);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     serialBuffer,
                                     sizeof(SERIALNUMBER),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        ULONG i;

        RtlMoveMemory(changerData->SerialNumber, serialBuffer->SerialNumber, NSM_SERIAL_NUMBER_LENGTH);

        DebugPrint((1,"DeviceType - %x\n", serialBuffer->DeviceType));
        DebugPrint((1,"PageCode - %x\n", serialBuffer->PageCode));
        DebugPrint((1,"Length - %x\n", serialBuffer->PageLength));

        DebugPrint((1,"Serial number "));

        for (i = 0; i < NSM_SERIAL_NUMBER_LENGTH; i++) {
            DebugPrint((1,"%x", serialBuffer->SerialNumber[i]));
        }

        DebugPrint((1,"\n"));

    }


    ChangerClassFreePool(serialBuffer);
    ChangerClassFreePool(dataBuffer);


    //
    // Send an allow to the unit to ensure that the LockCount and state of the unit
    // are in sync.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb.Cdb;
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.DataTransferLength = 0;
    srb.TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     NULL,
                                     0,
                                     FALSE);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;



    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        switch (senseBuffer->SenseKey) {
            case SCSI_SENSE_NOT_READY:
                if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY) &&
                    (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED)) {

                    //
                    // Indicate that the door is open.
                    //

                    *Status = STATUS_DEVICE_DOOR_OPEN;
                }
                break;

            case SCSI_SENSE_UNIT_ATTENTION: {

                InterlockedExchange(&changerData->LockCount, 0);

                if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_POSITION_ERROR) {
                    if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {

                        DebugPrint((1,
                                    "NSMMC: The specified source element has no media\n"));

                        //
                        // The indicated source address has no media.
                        //

                        *Status = STATUS_SOURCE_ELEMENT_EMPTY;

                    } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {

                        DebugPrint((1,
                                    "NSMMC: The specified destination element already has media.\n"));
                        //
                        // The indicated destination already contains media.
                        //

                        *Status = STATUS_DESTINATION_ELEMENT_FULL;
                    }
                }

                break;
            }

            case SCSI_SENSE_HARDWARE_ERROR: {
               DebugPrint((1, "HardwareError - SenseCode %x, ASC %x, ASCQ %x\n",
                           senseBuffer->SenseKey,
                           senseBuffer->AdditionalSenseCode,
                           senseBuffer->AdditionalSenseCodeQualifier));
               changerData->HardwareError = TRUE;

               break;
            }
        }

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    }
    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    DVL changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = NSM_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->MagazineSize = 50;
    changerParameters->DriveCleanTimeout = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_EXCHANGE_MEDIA              |
                                   CHANGER_LOCK_UNLOCK                 |
                                   CHANGER_CARTRIDGE_MAGAZINE          |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE |
                                   CHANGER_SERIAL_NUMBER_VALID;

    changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_CLOSE | 
                                   CHANGER_MOVE_EXTENDS_IEPORT;

    changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE | CHANGER_TO_SLOT | CHANGER_TO_IEPORT);
    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_IEPORT);

    //
    // build device caps mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;



    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, NSM_SERIAL_NUMBER_LENGTH);

    //
    // Indicate drive type.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort/ Front panel.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    switch (setAccess->Element.ElementType) {
        case ChangerIEPort:

            if (controlOperation == LOCK_ELEMENT) {

                //
                // Issue prevent media removal command to lock the door.
                //

                cdb->MEDIA_REMOVAL.Prevent = 1;

                //
                // Inc the lock count to indicate that a prevent is on the device.
                //

                InterlockedIncrement(&changerData->LockCount);

            } else if (controlOperation == UNLOCK_ELEMENT) {

                //
                // Issue allow media removal.
                //

                cdb->MEDIA_REMOVAL.Prevent = 0;

                InterlockedExchange(&changerData->LockCount, 0);

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;

        default:

            status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             writeToDevice);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (readElementStatus->VolumeTagInfo) {

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements) {

        ULONG i;
        ULONG totalElements = 0;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;

            //
            // Add these up instead of using the number passed in the user's buffer, as the driver
            // fakes that there are no IEPorts.
            //

            totalElements += addressMapping->NumberOfElements[i];
        }

        //
        // Determine length of the descriptors expected for the elements.
        //

        length = (sizeof(NSM_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {

        length = (sizeof(NSM_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // Ensure that starting address is valid.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) || 
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (typeCount > ((LONG)descriptorLength * remainingElements)) {
            DebugPrint((1,
                        "ChangerGetElementStatus: DescriptorByteCount is hosed. Claimed: %x",
                        typeCount));

            typeCount = descriptorLength * remainingElements;

            DebugPrint((1," Actual: %x\n", typeCount));
        }

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                if (elementType == ChangerDrive) {

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                } else {

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);


                //
                // Map the exceptions.
                //

                if (elementDescriptor->Exception) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                    if (elementStatus->ExceptionCode == 0) {

                        //
                        // For some reason an exception was noted that is not relevant.
                        //

                        elementStatus->Flags &=~ELEMENT_STATUS_EXCEPT;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    //
    // The Mercury doesn't support this.
    //

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;
    LONG                lockValue = 0;

    //
    // Verify transport, source, and dest. are within range.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    if (lockValue) {

        NTSTATUS preventStatus;

        //
        // Send the prevent to re-lock down the unit.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        //
        // Ignore any errors at this point. The LM will fixup any problems with
        // prevent/allow
        //

        preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                srb,
                                NULL,
                                0,
                                FALSE);
        DebugPrint((1,
                   "MoveMedium: Prevent sent. Status %x\n",
                   preventStatus));
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
NSMBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = NSM_NO_ELEMENT;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = NSM_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;
    ULONG exceptionCode = 0;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x53:
            if (ascq == 0x02) {

                //
                // Reporting that medium removal is prevented.
                //

                exceptionCode = 0;

            }
            break;
        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "NSMMC: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == NSM_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   
   //
   // Initialize the flag in the device extension to FALSE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set this flag to TRUE in ChangerError routine.
   //
   changerData->HardwareError = FALSE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "NSMMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set selftest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
      changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\plasmc\plasmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    hpmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _PLAS_MC_
#define _PLAS_MC_

typedef struct _PLASMON_DSERIES_UNIT_INFO_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR MaximumMagazines;
    UCHAR MaximumDrives;
    UCHAR NumberColumns;
    UCHAR Reserved1;
    UCHAR FlFWPartNumber[10];
    UCHAR FlFWCheckSum[2];
    UCHAR FlFWRev;
    UCHAR FlFWBuildFlags;
    UCHAR EPFWPartNumber[10];
    UCHAR EPFWRev[4];
    UCHAR EPFWCheckSum[2];
    UCHAR Reserved2[2];
} PLASMON_DSERIES_UNIT_INFO_PAGE, *PPLASMON_DSERIES_UNIT_INFO_PAGE;

typedef struct _PLASMON_FTA_UNIT_INFO_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR FWLevel;
    UCHAR HWLevel;
    UCHAR Reserved1 : 1;
    UCHAR BarCodes  : 1;
    UCHAR RedundantMTA : 1;
    UCHAR NoOfPassThrough : 2;
    UCHAR MaximumMagazines : 2;
    UCHAR Reserved2 : 1;
    UCHAR NumberOfSlots[2];
    UCHAR MaximumNoOfDrives;
    UCHAR NoOfColumns;
    UCHAR SlotsInColumn[10];
    UCHAR Reserved3[4];
    UCHAR FWPartNumber[10];
    UCHAR Reserved4[10];
    UCHAR FWChecksum[2];
    UCHAR Reserved5[2];
    UCHAR ElectronicSignature[6];
    UCHAR Reserved6[2];
} PLASMON_FTA_UNIT_INFO_PAGE, *PPLASMON_FTA_UNIT_INFO_PAGE;

typedef union _PLASMON_ELEMENT_DESCRIPTOR {
    struct {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR ImpExp : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR ExEnable : 1;
        UCHAR InEnable : 1;
        UCHAR Reserved4 : 2;
        UCHAR Reserved5;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved6 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved7 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved8;
        UCHAR Reserved9 : 7;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR BarCode[32];
        UCHAR Reserved11[8];
        UCHAR DriveSerialNumber[10];
    } PLASMON_FTA_DESCRIPTOR;

    struct {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR ImpExp : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR ExEnable : 1;
        UCHAR InEnable : 1;
        UCHAR Reserved4 : 2;
        UCHAR Reserved5;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved6 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved7 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved8;
        UCHAR Reserved9 : 7;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved10[4];
        UCHAR Changed : 1;
        UCHAR Magazine : 1;
        UCHAR Reserved11 : 3;
        UCHAR Volatile : 1;
        UCHAR PD : 1;
        UCHAR Tray : 1;
        UCHAR Reserved12;
    } PLASMON_DSERIES_DESCRIPTOR;

} PLASMON_ELEMENT_DESCRIPTOR, *PPLASMON_ELEMENT_DESCRIPTOR;

typedef struct _LIBRARY_MODE_PARAMS_PAGE2 {
    UCHAR PageCode;
    UCHAR ParameterLength;
    UCHAR Reserved1 : 1;
    UCHAR IgnoreParity : 1;
    UCHAR WaitLoad : 1;
    UCHAR NoDelay : 1;
    UCHAR LvClosed : 1;
    UCHAR LimitRec : 1;
    UCHAR AlwPdExp : 1;
    UCHAR NoRepRec : 1;
    UCHAR UnUsed[7]; // Some interesting bits, but we aren't using them at present.
} LIBRARY_MODE_PARAMS_PAGE2, *PLIBRARY_MODE_PARAMS_PAGE2;


typedef struct _READ_MAGAZINE_STATUS {
    UCHAR OperationCode;
    UCHAR Reserved1 : 5;
    UCHAR LogicalUnitNubmer : 3;
    UCHAR FirstMagazineNumber[2];
    UCHAR NumberOfMagazines[2];
    UCHAR Reserved2;
    UCHAR AllocationLength[3];
    UCHAR Reserved3;
} READ_MAGAZINE_STATUS, *PREAD_MAGAZINE_STATUS;

typedef struct _MAGAZINE_STATUS_HEADER {
    UCHAR FirstMagazineReported[2];
    UCHAR NumberOfMagazines[2];
    UCHAR Reserved1;
    UCHAR ReportByteCount[3];
} MAGAZINE_STATUS_HEADER, *PMAGAZINE_STATUS_HEADER;

typedef struct _MAGAZINE_DESCRIPTOR {
    UCHAR MagazineNumber;
    UCHAR FirstElementAddress[2];
    UCHAR Description;
} MAGAZINE_DESCRIPTOR, *PMAGAZINE_DESCRIPTOR;

//
// Bit defs of the description field in the magazine descriptor
// Some left out as they are presently unused.
//

#define MAGAZINE_FULL    0x01
#define MAGAZINE_CHANGED 0x04

#define MODE_PARAMS_PAGE2  0x20

#define SCSIOP_OPEN_IEPORT_DSERIES     0x0D
#define SCSIOP_OPEN_IEPORT_FTA         0x0C

#define SCSIOP_READ_MAG_STATUS_DSERIES 0xF8
#define SCSIOP_READ_MAG_STATUS_FTA     0xB9

#define PLASMON_MAILSLOT_OPEN  0x01
#define PLASMON_MAILSLOT_CLOSE 0x00

#define PLASMON_DSERIES_IEPORT_LOCK  0x40
#define PLASMON_FTA_IEPORT_LOCK      0x00

#define PLAS_NO_ELEMENT          0xFFFF

//
// Diagnostic error codes
//
// ASC
//
#define PLASMC_ASC_DIAGNOSTIC_FAILURE       0x40
#define PLASMC_ASC_INTERNAL_TARGET_FAILURE  0x44
#define PLASMC_ASC_VENDOR_UNIQUE            0x80

//
// ASCQ
//
#define PLASMC_ASCQ_PICKER_HOME_FAILURE         0x50
#define PLASMC_ASCQ_LIFT_BLOCKED_BY_TRAY        0x64

//
// DeviceStatus codes
//
#define PLASMC_DEVICE_PROBLEM_NONE              0x00
#define PLASMC_HW_ERROR                         0x01
#define PLASMC_TARGET_FAILURE                   0x02
#define PLASMC_CHM_MOVE_ERROR                   0x03


#define PLSMN_CD     1
#define PLSMN_TAPE   2

#define PLASMON_DSERIES  1
#define PLASMON_FTA      2

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Indicates the number of magazine slots available.
    //

    ULONG MagazineSlots;

    //
    // Indicates the number of slots in each magazine.
    //

    ULONG SlotsPerMag;

    //
    // Bitmap of available magazine locations.
    //

    ULONG MagazinePresent;

    //
    // Device status after a diagnostic test
    //
    ULONG DeviceStatus;

    //
    // FLAG set if we are building magazine map
    //
    BOOLEAN BuildMagazineMapInProgress;

    //
    // Flag to indicate if barcode reader is installed
    // or not
    //
    BOOLEAN BarCodeReaderInstalled;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
PlasmonBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

NTSTATUS
BuildMagazineMap(
    IN PDEVICE_OBJECT DeviceObject
    );

#endif // _PLAS_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\plasmc\plasmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    plasmc.c

Abstract:

    This module contains device-specific routines for Plasmon medium changers:

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "plasmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, PlasmonBuildAddressMapping)
#pragma alloc_text(PAGE, BuildMagazineMap)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the plasmon D-Series changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PPLASMON_DSERIES_UNIT_INFO_PAGE dseriesUnitInfo = NULL;
    PPLASMON_FTA_UNIT_INFO_PAGE     ftaUnitInfo = NULL;
    PVOID          unitInfo = NULL;
    PVOID          modeBuffer;
    PLIBRARY_MODE_PARAMS_PAGE2 modePage2;
    PCDB           cdb;
    ULONG          length;
    UCHAR          sizeNeeded;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            &srb,
                                            dataBuffer,
                                            sizeof(INQUIRYDATA),
                                            FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->VendorId,"PLASMON ", 8) == 8) {
        if (RtlCompareMemory(dataBuffer->ProductId,"D-SERIES",8) == 8) {
            changerData->DriveType = PLSMN_CD;
            changerData->DriveID = PLASMON_DSERIES;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"FTA",3) == 3) {
            changerData->DriveType = PLSMN_TAPE;
            changerData->DriveID = PLASMON_FTA;
        }
    }

    changerData->BuildMagazineMapInProgress = FALSE;


    DebugPrint((1,
               "ChangerInitialize: DriveType %x, DriveID %x\n",
               changerData->DriveType,
               changerData->DriveID));

    ChangerClassFreePool(dataBuffer);

    if ((changerData->DriveID) == PLASMON_DSERIES) {

        sizeNeeded = sizeof(PLASMON_DSERIES_UNIT_INFO_PAGE);
    } else if ((changerData->DriveID) == PLASMON_FTA) {

        sizeNeeded = sizeof(PLASMON_FTA_UNIT_INFO_PAGE);
    } else {

        return STATUS_NOT_IMPLEMENTED;
    }

    unitInfo = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                        sizeNeeded);
    if (unitInfo) {

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Set timeout value.
        //

        srb.TimeOutValue = 10;
        srb.CdbLength = 6;

        cdb = (PCDB)srb.Cdb;

        //
        // Set CDB operation code.
        //

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        cdb->CDB6INQUIRY.PageCode = 0xC0;

        //
        // Set EVPD
        //

        cdb->CDB6INQUIRY.Reserved1 = 1;

        //
        // Set allocation length to inquiry data buffer size.
        //

        cdb->CDB6INQUIRY.AllocationLength = sizeNeeded;

        changerData->BarCodeReaderInstalled = FALSE;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                &srb,
                                                unitInfo,
                                                sizeNeeded,
                                                FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            if ((changerData->DriveID) == PLASMON_DSERIES) {
                dseriesUnitInfo = (PPLASMON_DSERIES_UNIT_INFO_PAGE) unitInfo;
                changerData->MagazineSlots = dseriesUnitInfo->MaximumMagazines;
                changerData->SlotsPerMag = 10;
            } else if ((changerData->DriveID) == PLASMON_FTA) {
                ftaUnitInfo = (PPLASMON_FTA_UNIT_INFO_PAGE) unitInfo;
                changerData->MagazineSlots = ftaUnitInfo->MaximumMagazines;
                changerData->SlotsPerMag = 5;

                if (ftaUnitInfo->BarCodes) {
                    changerData->BarCodeReaderInstalled = TRUE;
                }
            }

        } else {
            if ((changerData->DriveID) == PLASMON_FTA) {
                changerData->MagazineSlots = 1;
            } else {
                changerData->MagazineSlots = 12;
            }
        }

        //
        // Determine the current magazine state of the device.
        //

        status = BuildMagazineMap(DeviceObject);


        ChangerClassFreePool(unitInfo);
    }

    //
    // Build address mapping.
    //

    status = PlasmonBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Send a mode sense for the Library Mode parameters page 2.
    //

    //
    // ISSUE : nramas 12/15/2000
    //         LIBRARY_MODE_PARAMS_PAGE2 is slightly different, but
    //         LvClosed bit matches both D-SERIES and FTA. But, this
    //         should be fixed.
    //
    length = sizeof(MODE_PARAMETER_HEADER) + sizeof(LIBRARY_MODE_PARAMS_PAGE2);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (modeBuffer) {

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
        RtlZeroMemory(modeBuffer, length);
        srb.CdbLength = CDB6GENERIC_LENGTH;
        srb.TimeOutValue = 20;
        srb.DataTransferLength = length;
        srb.DataBuffer = modeBuffer;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PARAMS_PAGE2;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)srb.DataTransferLength;

        //
        // Send the request.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                &srb,
                                                modeBuffer,
                                                length,
                                                FALSE);

        if (NT_SUCCESS(status)) {

            PMODE_PARAMETER_HEADER header;

            RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
            modePage2 = (PLIBRARY_MODE_PARAMS_PAGE2)modeBuffer;
            header = (PMODE_PARAMETER_HEADER)modeBuffer;

            //
            // Zero out this field.
            //

            header->ModeDataLength = 0;

            //
            // Bypass the header.
            //

            (ULONG_PTR)modePage2 += sizeof(MODE_PARAMETER_HEADER);

            //
            // Setup the unit to NOT open the ieport port on moves to it.
            //

            modePage2->PageCode &= ~0x80;
            modePage2->LvClosed = 1;

            srb.CdbLength = CDB6GENERIC_LENGTH;
            srb.TimeOutValue = 20;
            srb.DataTransferLength = length;
            srb.DataBuffer = modeBuffer;

            cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
            cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb.DataTransferLength;

            //
            // Send the request.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                    &srb,
                                                    modeBuffer,
                                                    length,
                                                    TRUE);

            DebugPrint((1,
                       "Plasmc: Mode select of page2 - %x\n",
                       status));

        }

        ChangerClassFreePool(modeBuffer);
    }

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    ULONG   deviceStatus;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        DebugPrint((1,
                   "Plasmc: senseCode %x\n",
                   senseBuffer->SenseKey & 0xf));
        DebugPrint((1,
                   "Plasmc: additionalSenseCode %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "Plasmc: additionalSenseCodeQualifier %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));

        switch (senseBuffer->SenseKey & 0xf) {

            case SCSI_SENSE_ILLEGAL_REQUEST:

                if (senseBuffer->AdditionalSenseCode == 0x3B) {
                    if (senseBuffer->AdditionalSenseCodeQualifier == 0x81) {
                        BuildMagazineMap(DeviceObject);
                    }
                }
                break;

            case SCSI_SENSE_UNIT_ATTENTION:

                //
                // Update the map, as the door might have been opened, etc.
                //

                BuildMagazineMap(DeviceObject);
                break;

            case SCSI_SENSE_HARDWARE_ERROR: {
               deviceStatus = PLASMC_HW_ERROR;
               switch (senseBuffer->AdditionalSenseCode) {
                  case PLASMC_ASC_DIAGNOSTIC_FAILURE: {
                     deviceStatus = PLASMC_HW_ERROR;
                     break;
                  }

                  case PLASMC_ASC_INTERNAL_TARGET_FAILURE: {
                     deviceStatus = PLASMC_TARGET_FAILURE;
                     break;
                  }
                  
                  case PLASMC_ASC_VENDOR_UNIQUE: {
                     UCHAR plasmcASCQ = senseBuffer->AdditionalSenseCodeQualifier;

                     if ((plasmcASCQ >= PLASMC_ASCQ_PICKER_HOME_FAILURE) &&
                         (plasmcASCQ <= PLASMC_ASCQ_LIFT_BLOCKED_BY_TRAY)) {
                        deviceStatus = PLASMC_CHM_MOVE_ERROR;
                     } else {
                        deviceStatus = PLASMC_HW_ERROR;
                     }
                     break;
                  }
               }

               changerData->DeviceStatus = deviceStatus;
               break;
            }

            default:
               break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    plasmon changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = PLAS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->MagazineSize = (USHORT)changerData->SlotsPerMag;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;


    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY);
    cdb->MODE_SENSE.Dbd = 1;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Features based on manual, nothing programatic.
    //

    if ((changerData->DriveType) == PLSMN_TAPE) {
        changerParameters->DriveCleanTimeout = 300;
    } else {
        changerParameters->DriveCleanTimeout = 0;
    }
    
    changerParameters->Features0 |= CHANGER_EXCHANGE_MEDIA                |
                                    CHANGER_LOCK_UNLOCK                   |
                                    CHANGER_POSITION_TO_ELEMENT           |
                                    CHANGER_DEVICE_REINITIALIZE_CAPABLE   |
                                    CHANGER_CLOSE_IEPORT                  |
                                    CHANGER_OPEN_IEPORT                   |
                                    CHANGER_CARTRIDGE_MAGAZINE            |
                                    CHANGER_REPORT_IEPORT_STATE;

    if (changerData->DriveID == PLASMON_DSERIES) {
        changerParameters->Features1 = (CHANGER_SLOTS_USE_TRAYS | 
                                        CHANGER_TRUE_EXCHANGE_CAPABLE);
    }

    if (changerData->DriveID == PLASMON_FTA) {
        changerParameters->Features0 |= (CHANGER_PREDISMOUNT_EJECT_REQUIRED |
                                         CHANGER_DRIVE_CLEANING_REQUIRED    |
                                         CHANGER_CLEANER_ACCESS_NOT_VALID);

        changerParameters->Features0 &= ~(CHANGER_CLOSE_IEPORT      |
                                          CHANGER_OPEN_IEPORT       |
                                          CHANGER_CARTRIDGE_MAGAZINE);
    }

    if (changerData->BarCodeReaderInstalled) {
        changerParameters->Features0 |= CHANGER_BAR_CODE_SCANNER_INSTALLED;
    }

    changerParameters->PositionCapabilities = (CHANGER_TO_SLOT | CHANGER_TO_IEPORT | CHANGER_TO_DRIVE);
    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_IEPORT | LOCK_UNLOCK_DOOR);

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    cdb->MODE_SENSE.Dbd = 1;
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    UCHAR IePortCode = 0;
    UCHAR ControlCode = 0;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (setAccess->Element.ElementType == ChangerDoor) {

        if (controlOperation == LOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the door.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;
        } else {

            status = STATUS_INVALID_PARAMETER;
        }

    } else if (setAccess->Element.ElementType == ChangerIEPort) {

        if (changerData->DriveID == PLASMON_DSERIES) {
            IePortCode = SCSIOP_OPEN_IEPORT_DSERIES;
            ControlCode = PLASMON_DSERIES_IEPORT_LOCK;
        } else {
            IePortCode = SCSIOP_OPEN_IEPORT_FTA;
            ControlCode = PLASMON_FTA_IEPORT_LOCK;
        }

        if (addressMapping->NumberOfElements[ChangerIEPort] == 0) {
            status = STATUS_INVALID_PARAMETER;
        } else {

            if (controlOperation == LOCK_ELEMENT) {

                cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

                //
                // Issue prevent media removal command to lock the ie port.
                //

                cdb->MEDIA_REMOVAL.Prevent = 1;
                cdb->MEDIA_REMOVAL.Control = ControlCode;

            } else if (controlOperation == UNLOCK_ELEMENT) {

                cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

                //
                // Issue allow media removal.
                //

                cdb->MEDIA_REMOVAL.Prevent = 0;
                cdb->MEDIA_REMOVAL.Control = ControlCode;

            } else if (controlOperation == EXTEND_IEPORT) {

                //
                // The Plasmon CAN extend and retract the ieport,
                // but the plastic trays for the disc need to come from
                // a slot. So disallow direct access to this feature.
                //

                srb->TimeOutValue = fdoExtension->TimeOutValue;
                cdb->CDB6GENERIC.OperationCode = IePortCode; //SCSIOP_OPEN_IEPORT;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = PLASMON_MAILSLOT_OPEN;

                //status = STATUS_INVALID_PARAMETER;

            } else if (controlOperation == RETRACT_IEPORT) {

                srb->TimeOutValue = fdoExtension->TimeOutValue;
                cdb->CDB6GENERIC.OperationCode = IePortCode; //SCSIOP_OPEN_IEPORT;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = PLASMON_MAILSLOT_CLOSE;

                //status = STATUS_INVALID_PARAMETER;

            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
    } else {

        //
        // No keypad selectivity programatically.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                NULL,
                                                0,
                                                FALSE);

    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (((changerData->DriveID) == PLASMON_DSERIES) &&
         (readElementStatus->VolumeTagInfo)) {

        //
        // These units have no Volume tag capability.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements ||
        elementType == ChangerSlot) {

        //
        // Build bitmap of available slot locations.
        //

        status = BuildMagazineMap(DeviceObject);

    }

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        length = sizeof(PLASMON_ELEMENT_DESCRIPTOR) * totalElements;

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        length = (sizeof(PLASMON_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
    }

    DebugPrint((2,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements < 0 ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements less than zero - %x\n",
                       remainingElements));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        if (typeCount < 0) {
            DebugPrint((1,
                       "ChangerGetElementStatus (1): Count of type %x less than zero - %x\n",
                       elementType,
                       typeCount));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;


                if (elementType == ChangerDrive) {

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                }

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                if ((changerData->DriveID == PLASMON_DSERIES) &&
                    (elementType == ChangerSlot) &&
                    ((changerData->SlotsPerMag) != 0)) {

                    ULONG magNumber;

                    //
                    // Make sure that the magazine for this slot is really there.
                    //

                    magNumber = elementStatus->Element.ElementAddress / changerData->SlotsPerMag;
                    if (!(changerData->MagazinePresent & (1 << magNumber))) {

                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_SLOT_NOT_PRESENT;
                        DebugPrint((1,
                                    "Plasmc: Slot %x in non-existant magazine (%x)\n",
                                    elementStatus->Element.ElementAddress,
                                    magNumber));

                    }
                }

                if ((readElementStatus->VolumeTagInfo) &&
                    ((changerData->DriveID) == PLASMON_FTA)) {
                    PLASMON_ELEMENT_DESCRIPTOR *plasmonDescriptor =
                        (PLASMON_ELEMENT_DESCRIPTOR *) elementDescriptor;

                    RtlFillMemory(elementStatus->PrimaryVolumeID,
                                  MAX_VOLUME_ID_SIZE,
                                  ' ');

                    RtlFillMemory(elementStatus->AlternateVolumeID,
                                  MAX_VOLUME_ID_SIZE,
                                  ' ');

                    RtlCopyMemory(elementStatus->PrimaryVolumeID,
                                  plasmonDescriptor->PLASMON_FTA_DESCRIPTOR.BarCode,
                                  32);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * totalElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{


    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status = STATUS_SUCCESS;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    ChangerClassFreePool(srb);

    DebugPrint((1,
               "MoveMedium: Returning %x\n",
               status));
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    //
    // Clear locks.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
PlasmonBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = PLAS_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = PLAS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



NTSTATUS
BuildMagazineMap(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate commands and builds a bitmap indicating
    available magazines.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA            changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSCSI_REQUEST_BLOCK    srb;
    PREAD_MAGAZINE_STATUS  cdb;
    NTSTATUS               status;
    ULONG                  length;
    PVOID                  statusBuffer;
    ULONG i;

    //
    // If we are already building magazin map, do nothing.
    // This will avoid recursion when ChangerError calls
    // BuildMagazineMap
    //
    if ((changerData->BuildMagazineMapInProgress)) {
        changerData->BuildMagazineMapInProgress = FALSE;
        return STATUS_SUCCESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PREAD_MAGAZINE_STATUS)srb->Cdb;

    length = sizeof(MAGAZINE_STATUS_HEADER) + (sizeof(MAGAZINE_DESCRIPTOR) * changerData->MagazineSlots);

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build the request.
    //

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    if ((changerData->DriveID) == PLASMON_DSERIES) {
        cdb->OperationCode = SCSIOP_READ_MAG_STATUS_DSERIES;
    } else if ((changerData->DriveID) == PLASMON_FTA) {
        cdb->OperationCode = SCSIOP_READ_MAG_STATUS_FTA;
    } else {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(statusBuffer);

        return STATUS_INVALID_DEVICE_REQUEST;
    }
    
    cdb->FirstMagazineNumber[0] = 0x00;
    cdb->FirstMagazineNumber[1] = 0x01;

    cdb->NumberOfMagazines[0] = (UCHAR)(changerData->MagazineSlots >> 8);
    cdb->NumberOfMagazines[1] = (UCHAR)(changerData->MagazineSlots & 0xFF);

    cdb->AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->AllocationLength[2] = (UCHAR)(length & 0xFF);

    changerData->BuildMagazineMapInProgress = TRUE;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (NT_SUCCESS(status)) {

        PMAGAZINE_STATUS_HEADER statusHeader;
        PMAGAZINE_DESCRIPTOR magDescriptor;
        ULONG numberMags;
        USHORT firstElement;

        statusHeader = (PMAGAZINE_STATUS_HEADER)statusBuffer;
        magDescriptor = (PMAGAZINE_DESCRIPTOR)statusHeader;
        (ULONG_PTR)magDescriptor += sizeof(MAGAZINE_STATUS_HEADER);

        //
        // Verify some information in the header.
        //

        numberMags = statusHeader->NumberOfMagazines[1];
        numberMags += (statusHeader->NumberOfMagazines[0] << 8);

        if (numberMags != changerData->MagazineSlots) {
            DebugPrint((1,
                       "Plasmc: Mismatch of magazine information. Expected %x, got %x\n",
                       changerData->MagazineSlots,
                       numberMags));

        }

        changerData->MagazinePresent = 0;
        changerData->SlotsPerMag = 0;

        //
        // Keep track of the first element of the first magazine.
        // Use this later to determine how many slots are in each
        // magazine.
        //

        firstElement = magDescriptor->FirstElementAddress[1];
        firstElement += magDescriptor->FirstElementAddress[0] << 8;

        //
        // Loop through descriptors and set appropriate bits.
        //

        for (i = 0; i < numberMags; i++) {
            if ((magDescriptor->Description) & MAGAZINE_FULL) {
                changerData->MagazinePresent |= 1 << i;
                DebugPrint((2,
                           "Plasmc: Magazine %x present\n",
                           magDescriptor->MagazineNumber));
            }

            if (!changerData->SlotsPerMag) {
                changerData->SlotsPerMag = magDescriptor->FirstElementAddress[1];
                changerData->SlotsPerMag += magDescriptor->FirstElementAddress[0] << 8;

                changerData->SlotsPerMag -= firstElement;
                DebugPrint((1,
                           "Plasmc: Slots per magazine - %x\n",
                           changerData->SlotsPerMag));

            }


            //
            // Advance to next descriptor.
            //

            magDescriptor++;
        }
    }

    changerData->BuildMagazineMapInProgress = FALSE;

    ChangerClassFreePool(statusBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        case 0x83: {
            if (ascq == 0x09) {
                exceptionCode = ERROR_LABEL_UNREADABLE;
            }

            break;
        }

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "plasmc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == PLAS_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}

                                                                                                                                                             

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to 
   // PLASMC_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate 
   // devicestatus.
   //
   changerData->DeviceStatus = PLASMC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "PLASMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != PLASMC_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case PLASMC_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         case PLASMC_CHM_MOVE_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMMoveError;
            break;
         }

         case PLASMC_TARGET_FAILURE: {
            changerDeviceError->ChangerProblemType = DeviceProblemCalibrationError;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch (changerData->DeviceStatus)
   }

   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\pnrmc\pnrmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    pnrmc.c

Abstract:

    This module contains device-specific routines for Pioneer DRM-1004 CD Library changers.

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "pnrmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, PNRBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the Pioneer changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = PNRBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"CHANGR DRM-1004X",16) == 16) {
        changerData->DeviceID = DRM_1004;
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       switch (senseBuffer->SenseKey) {
           case SCSI_SENSE_NOT_READY:
   
               if ((senseBuffer->AdditionalSenseCode == 0x53) &&
                   (senseBuffer->AdditionalSenseCodeQualifier == 0x82)) {
   
                   //
                   // Indicate that the door is open.
                   //
   
                   *Status = STATUS_DEVICE_DOOR_OPEN;
                   *Retry = FALSE;
               } else if ((senseBuffer->AdditionalSenseCode == 0x53) &&
                       (senseBuffer->AdditionalSenseCodeQualifier == 0x88)) {
   
                   //
                   // IEPORT is extended.
                   //
   
                   *Status = STATUS_DEVICE_NOT_READY;
                   *Retry = TRUE;
               }
   
               break;
   
           case SCSI_SENSE_UNIT_ATTENTION:
               if ((senseBuffer->AdditionalSenseCode == 0x28) &&
                   (senseBuffer->AdditionalSenseCodeQualifier == 0x01)) {
   
                   //
                   // Indicate that the door was opened and reclosed.
                   //
   
                   *Status = STATUS_MEDIA_CHANGED;
                   *Retry = FALSE;
               }
   
               break;
   
           case SCSI_SENSE_HARDWARE_ERROR:    {
               changerData->HardwareError = TRUE;
               break;
           }
       }
    }
    
    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    DVL changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK          srb;
    PGET_CHANGER_PARAMETERS      changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE   elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE  transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = PNR_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    changerParameters->MagazineSize = 50;
    changerParameters->DriveCleanTimeout = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_OPEN_IEPORT         |
                                   CHANGER_REPORT_IEPORT_STATE |
                                   CHANGER_CARTRIDGE_MAGAZINE  |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE;

    changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_CLOSE; 

    //
    // build device caps mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;



    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate drive type.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort/ Front panel.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Nothing can be locked and the ieport can only be extended.
    //

    if (controlOperation == EXTEND_IEPORT) {
        if (setAccess->Element.ElementType == ChangerIEPort) {

            USHORT              transport;
            USHORT              destination;

            //
            // The pioneer units use Position to Element as the method of opening the IEPort.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;

            srb->CdbLength = CDB10GENERIC_LENGTH;
            cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

            transport = addressMapping->FirstElement[ChangerTransport];
            destination = addressMapping->FirstElement[ChangerIEPort];

            DebugPrint((1,
                       "SetAccess: Transport %x, Destination %x\n",
                       transport,
                       destination));

            //
            // Build device-specific addressing.
            //

            cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
            cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

            cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
            cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

            srb->DataTransferLength = 0;
            srb->TimeOutValue = 200;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             writeToDevice);
    }

    ChangerClassFreePool(srb);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (readElementStatus->VolumeTagInfo) {

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements) {

        ULONG i;
        ULONG totalElements = 0;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;

            //
            // Add these up instead of using the number passed in the user's buffer, as the driver
            // fakes that there are no IEPorts.
            //

            totalElements += addressMapping->NumberOfElements[i];
        }

        //
        // Determine length of the descriptors expected for the elements.
        //

        length = (sizeof(PNR_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {


        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                        "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        length = (sizeof(PNR_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // Ensure that starting address is valid.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                }

                if (elementDescriptor->IdValid) {
                    elementStatus->TargetId = elementDescriptor->BusAddress;
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);


                //
                // Map the exceptions.
                //

                if (elementDescriptor->Exception) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                    if (elementStatus->ExceptionCode == 0) {

                        //
                        // The Pioneer marks an exception on No media and IEPort extended.
                        // Turn it off.
                        //

                        elementStatus->Flags &=~ELEMENT_STATUS_EXCEPT;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
PNRBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = PNR_NO_ELEMENT;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = PNR_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;
    ULONG exceptionCode = 0;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x04:
            if (ascq == 0x02) {
                exceptionCode = ERROR_INIT_STATUS_NEEDED;
            } else if (ascq == 0x03) {
                exceptionCode = ERROR_SLOT_NOT_PRESENT;
            }
        case 0x3A:
            if (ascq == 0x0) {

                DebugPrint((2,
                           "PNRMC: FW reports no media as exception\n"));
                exceptionCode = 0;

            }
        case 0x53:
            if (ascq == 0x88) {

                //
                // IEPort extended.
                //

                exceptionCode = 0;
            }
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((2,
               "PNRMC: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == PNR_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++ 

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the flag in the device extension to FALSE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set this flag to TRUE in ChangerError routine.
   //
   changerData->HardwareError = FALSE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "PNRMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
      changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\powerfil\powerfil.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    starmatx.c

Abstract:

    This module contains device-specific routines for StarMatix Powerfile
    changer device, Benchmark VS640, PV-122T, and Compaq Lib-81 AIT autoloaders.

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "powerfil.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, StarMatxBuildAddressMapping)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath,
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the StarMatix changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{
    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    if ((RtlCompareMemory(dataBuffer->ProductId, "VS640", 5) == 5) ||
        (RtlCompareMemory(dataBuffer->ProductId, "PV-122T", 7) == 7))
    {
        changerData->DriveType = BNCHMRK;

        if ((RtlCompareMemory(dataBuffer->ProductId, "PV-122T", 7) == 7))
        {
            changerData->DriveID = PV122T;
        }
        else
        {
            changerData->DriveID = BM_VS640;
        }
    }
    else if (RtlCompareMemory(dataBuffer->ProductId, "LIB-81", 6) == 6)
    {
        changerData->DriveType = COMPAQ;
        changerData->DriveID = LIB_AIT;
    }
    else
    {
        changerData->DriveType = POWERFILE_DVD;
        changerData->DriveID = DVD;
    }

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = StarMatxBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (changerData->DriveID == PV122T)
    {
        //
        // We'll try to get device identifier info. If it fails
        // this flag will be set to FALSE so that subsequently
        // we won't try to get device identifier info
        //
        changerData->ObtainDeviceIdentifier = TRUE;
    }
    else
    {
        changerData->ObtainDeviceIdentifier = FALSE;
    }

    return STATUS_SUCCESS;
}



VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));

    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. SrbStatus %x\n",
                   Srb->SrbStatus));
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    StarMatix changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    if (changerData->DriveID == PV122T || changerData->DriveID == LIB_AIT)
    {
        cdb->MODE_SENSE.Dbd = 1;
    }
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);
    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);

    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    //
    // ISSUE : nramas 02/19/2001
    //         StarMatix firmware reports that there is one transport, but
    //         the device has none. Same problem with the Benchmark and PV122T.
    //
    if (changerData->DriveType == POWERFILE_DVD || changerData->DriveType == BNCHMRK)
    {
        changerParameters->NumberTransportElements = 0;
    }

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    //
    // Hack for Powerfile C200 changer, Benchmark VS640, PV122T, and Compaq Lib-81 AIT autoloaders
    //
    changerParameters->NumberIEElements = 0;

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = 0;

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        //
        // Hack for Powerfile C200 changer, Benchmark VS640, PV122T, and Compaq Lib-81 AIT autoloaders
        //
        addressMapping->NumberOfElements[ChangerIEPort] = 0;

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        if (changerData->DriveType == BNCHMRK || changerData->DriveID == LIB_AIT)
        {
            addressMapping->NumberOfElements[ChangerKeypad] = 1;
        }

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = STARMATX_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    //
    // PowerFile C200, Benchmark VS640, and Compaq Lib-81 AIT autoloaders do not have a door
    //
    changerParameters->NumberOfDoors = 0;

    if (changerData->DriveType == BNCHMRK || changerData->DriveID == LIB_AIT)
    {
        changerParameters->MagazineSize = 8;
    }
    else
    {
        changerParameters->MagazineSize = 200;
    }

    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber = 1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    if (changerData->DriveID == PV122T || changerData->DriveID == LIB_AIT)
    {
        cdb->MODE_SENSE.Dbd = 1;
    }
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    if (changerData->DriveType == POWERFILE_DVD)
    {
        //
        // Determine if mc has 2-sided media.
        //
        changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;
    }
    else
    {
        //
        // Rotation is not appropriate for the Benchmark VS640 loader
        //
        changerParameters->Features0 = 0;
    }

    //
    // Features based on manual, nothing programatic, except barcode reader information.
    //
    if (changerData->DriveType == BNCHMRK || changerData->DriveID == LIB_AIT)
    {
        //
        // Nothing in the manual about drive clean timeout.
        // Setting to the general default of 300
        //
        changerParameters->DriveCleanTimeout = 300;

        if (changerData->DriveType == BNCHMRK)
        {
            changerParameters->Features0 |= (changerData->InquiryData.VendorSpecific[19] & 0x1) ? CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;
        }

        changerParameters->Features0 |= CHANGER_CARTRIDGE_MAGAZINE              |
                                        CHANGER_DRIVE_CLEANING_REQUIRED;

        changerParameters->Features1 = CHANGER_CLEANER_OPS_NOT_SUPPORTED;

        changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE | CHANGER_TO_SLOT);
    }
    else
    {
        changerParameters->DriveCleanTimeout = 0;

        changerParameters->Features0 |= CHANGER_STATUS_NON_VOLATILE             |
                                        CHANGER_POSITION_TO_ELEMENT             |
                                        CHANGER_VOLUME_IDENTIFICATION           |
                                        CHANGER_VOLUME_REPLACE                  |
                                        CHANGER_VOLUME_ASSERT                   |
                                        CHANGER_VOLUME_SEARCH;

        changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE |
                                                   CHANGER_TO_SLOT  |
                                                   CHANGER_TO_IEPORT);
    }

    //
    // Free buffer.
    //
    ChangerClassFreePool(modeBuffer);

    //
    // build device capabilities mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    if (changerData->DriveID == PV122T || changerData->DriveID == LIB_AIT)
    {
        cdb->MODE_SENSE.Dbd = 1;
    }
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    //
    // Issue: jaivira 06/13/2002
    // Benchmark firmware sets ST-I/E and DT-I/E even though the manual says
    // they should be both be zero
    //
    if (changerData->DriveType == BNCHMRK)
    {
        changerParameters->MoveFromIePort = 0;
    }

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    if (changerData->DriveType == POWERFILE_DVD)
    {
        //
        // ISSUE: 03/03/2000 - nramas
        // Powerfile C200 is reporting that it can move media from IEPort to Drive & IEPort.
        // It also says it cannot move from slot to IEPort or Drive. This is reveresed. Till
        // we get a firmware fix for this, let's hard code that :
        //  Capable of moving media from Slot to IEPort & Drive
        //  Capable of moving media from IEPort to Slot
        //
        changerParameters->MoveFromSlot = (CHANGER_TO_DRIVE |
                                           CHANGER_TO_IEPORT);
        changerParameters->MoveFromIePort = CHANGER_TO_SLOT;
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;

    //
    // SetAccess not supported by this changer
    //
    Irp->IoStatus.Information = 0;
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    totalElements = readElementStatus->ElementList.NumberOfElements;
    NTSTATUS status;
    PVOID    statusBuffer;
    PCHANGER_ELEMENT_STATUS_EX  elementStatusEx;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType != AllElements)
    {
        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType))
        {
            DebugPrint((1, "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }
    }

    //
    // Allocate first only for the header
    //
    length = sizeof(ELEMENT_STATUS_HEADER);
    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb)
    {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

RetrySRB:
    RtlZeroMemory(statusBuffer, length);
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements)
    {
        //
        // These devices may not have the low address as 0.
        //
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    }
    else
    {
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // ISSUE - 2002/07/22 - jaivira : Should change Reserved1 field in CDB
    // to meaningful name.
    //
    if ((elementType == ChangerDrive) && (changerData->ObtainDeviceIdentifier == TRUE) && (changerData->DriveID == PV122T))
    {
        //
        // Set this bit to retrieve device identifier information
        //
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x01;

        //
        // Since serial number info follows volume tag field,
        // we need to set VolTag bit also in the CDB
        //
        cdb->READ_ELEMENT_STATUS.VolTag = 0x01;
    }
    else
    {
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x00;
    }

    //
    // Send SCSI command (CDB) to device to get the actual allocation size reqd
    //
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) || STATUS_DATA_OVERRUN == status)
    {
        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;;

        if (STATUS_DATA_OVERRUN == status)
        {
            if ((srb->DataTransferLength) <= length)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                DebugPrint((1, "PowerFil:ReadElementStatus - Dataoverrun.\n"));
                ChangerClassFreePool(srb);
                ChangerClassFreePool(statusBuffer);

                return status;
            }
        }

        //
        // Get the actual needed length
        //
        length =  (statusHeader->ReportByteCount[2]);
        length |= (statusHeader->ReportByteCount[1] << 8);
        length |= (statusHeader->ReportByteCount[0] << 16);

        //
        // Account for the size of the status header
        //
        length += sizeof(ELEMENT_STATUS_HEADER);

        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
    }
    else if ((status == STATUS_INVALID_DEVICE_REQUEST) && (changerData->DriveID == PV122T))
    {
        //
        // Probably the device doesn't support DVCID bit
        // which retrieves Device Identifier info such as
        // serial number for drives. Try RES once more with
        // DVCID bit turned off.
        //
        if (changerData->ObtainDeviceIdentifier == TRUE)
        {
            changerData->ObtainDeviceIdentifier = FALSE;
            goto RetrySRB;
        }
    }
    else
    {
        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

RetryRequest:

    RtlZeroMemory(statusBuffer, length);

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // These devices may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // ISSUE - 2002/07/22 - jaivira : Should change Reserved1 field in CDB
    // to meaningful name.
    //
    if ((elementType == ChangerDrive) && (changerData->ObtainDeviceIdentifier == TRUE) && (changerData->DriveID == PV122T))
    {
        //
        // Set this bit to retrieve device identifier information
        //
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x01;

        //
        // Since serial number info follows volume tag field,
        // we need to set VolTag bit also in the CDB
        //
        cdb->READ_ELEMENT_STATUS.VolTag = 0x01;
    }
    else
    {
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x00;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) || STATUS_DATA_OVERRUN == status)
    {
        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        //
        // Check if the error was STATUS_DATA_OVERRUN
        //
        if (status == STATUS_DATA_OVERRUN)
        {
            //
            // Check if there was a DATA_OVERRUN, or was it just
            // DATA_UNDERRUN reported as DATA_OVERRRUN.
            //
            if (srb->DataTransferLength < length)
            {
                DebugPrint((1, "DATA_UNDERRUN reported as DATA_OVERRUN."));
                DebugPrint((1, "Expected: %d, Transferred: %d.\n", length, srb->DataTransferLength));
                status = STATUS_SUCCESS;
            }
            else
            {
                //
                // It was really DATA_OVERRUN error. Report accordingly.
                //
                ChangerClassFreePool(srb);
                ChangerClassFreePool(statusBuffer);

                return status;
            }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                if (elementDescriptor->IdValid) {
                    elementStatus->TargetId = elementDescriptor->BusAddress;
                    elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                    elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                }

                if (tagInfo)
                {
                    if (changerData->DriveType == BNCHMRK)
                    {
                        //
                        // Ensure that media is actually present. If so, get the tag info.
                        //
                        if (elementDescriptor->Full)
                        {
                            if (statusPage->PVolTag)
                            {
                                if (changerData->DriveID == PV122T)
                                {
                                    RtlMoveMemory(elementStatus->PrimaryVolumeID,
                                                  ((PBNCHMRK_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor)->VolumeTagDeviceID.VolumeTagInformation,
                                                  MAX_VOLUME_ID_SIZE);
                                }
                                else
                                {
                                    RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);

                                    if (elementType == ChangerSlot)
                                    {
                                        RtlMoveMemory(elementStatus->PrimaryVolumeID, ((PBNCHMRK_STORAGE_ELEMENT_DESCRIPTOR)elementDescriptor)->BarcodeLabel, 6);
                                    }
                                    else
                                    {
                                        RtlMoveMemory(elementStatus->PrimaryVolumeID, ((PBNCHMRK_ELEMENT_DESCRIPTOR)elementDescriptor)->BarcodeLabel, 6);
                                    }
                                }

                                elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                            }
                            else
                            {
                                DebugPrint((1, "ChangerGetElementStatus: tagInfo requested but PVoltag not set\n"));
                            }
                        }
                    }
                    else
                    {
                        if (statusPage->PVolTag) {

                            RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                            RtlMoveMemory(elementStatus->PrimaryVolumeID,
                                          ((PSTARMATX_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor)->PrimaryVolumeTag.VolumeIdentificationField,
                                          SCSI_VOLUME_ID_LENGTH);

                            elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                        }
                        if (statusPage->AVolTag) {

                            RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                            RtlMoveMemory(elementStatus->AlternateVolumeID,
                                          ((PSTARMATX_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor)->AlternateVolumeTag.VolumeIdentificationField,
                                          SCSI_VOLUME_ID_LENGTH);

                            elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                        }
                    }
                }

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // Map the exception.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                } else if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    if (changerData->DriveID == PV122T)
                    {
                        ULONG tagIndex;

                        //
                        // Verify validity of volume tag information.
                        //
                        for (tagIndex = 0; tagIndex < 14; tagIndex++)
                        {
                            if (((PBNCHMRK_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor)->VolumeTagDeviceID.VolumeTagInformation[tagIndex] != 0)
                            {
                                break;
                            }
                        }

                        if ((tagIndex == 14) && (elementStatus->Flags & ELEMENT_STATUS_FULL))
                        {
                            DebugPrint((1, "PV122T.GetElementStatus: Setting exception to LABEL_UNREADABLE\n"));

                            elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                            elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                            elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                        }
                    }
                    else
                    {
                        ULONG index;

                        //
                        // Ensure that the tag info isn't all spaces. This indicates an error.
                        //

                        for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                            if (elementStatus->PrimaryVolumeID[index] != ' ') {
                                break;
                            }
                        }

                        //
                        // Determine if the volume id was all spaces. Do an extra check to see if media is
                        // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                        //

                        if ((index == MAX_VOLUME_ID_SIZE) && (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                            DebugPrint((1,
                                       "Starmatx.GetElementStatus: Setting exception to LABEL_UNREADABLE\n"));

                            elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                            elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                            elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                        }
                    }
                }

                if (elementType == ChangerDrive && changerData->DriveID == PV122T)
                {
                    if (outputBuffLen >= (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX)))
                    {
                        PBNCHMRK_ELEMENT_DESCRIPTOR_PLUS elementDescPlus = (PBNCHMRK_ELEMENT_DESCRIPTOR_PLUS) elementDescriptor;
                        PUCHAR idField = NULL;
                        ULONG idLength = 0;

                        elementStatusEx = (PCHANGER_ELEMENT_STATUS_EX)elementStatus;

                        if (statusPage->PVolTag)
                        {
                            idField =  elementDescPlus->VolumeTagDeviceID.Identifier;
                            idLength = elementDescPlus->VolumeTagDeviceID.IdLength;
                        }
                        else
                        {
                            idField = elementDescPlus->DeviceID.Identifier;
                            idLength = elementDescPlus->DeviceID.IdLength;
                        }

                        if (idLength != 0)
                        {
                            if (idLength > SERIAL_NUMBER_LENGTH)
                            {
                                idLength = SERIAL_NUMBER_LENGTH;
                            }

                            RtlZeroMemory(elementStatusEx->SerialNumber, SERIAL_NUMBER_LENGTH);
                            RtlMoveMemory(elementStatusEx->SerialNumber, idField, idLength);

                            DebugPrint((3, "Serial number : %s\n", elementStatusEx->SerialNumber));

                            elementStatusEx->Flags |= ELEMENT_STATUS_PRODUCT_DATA;
                        }
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //
                if ((changerData->DriveID == PV122T) && (outputBuffLen >= (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))))
                {
                    DebugPrint((3, "Incrementing by sizeof(CHANGER_ELEMENT_STATUS_EX\n"));
                    (PUCHAR)elementStatus += sizeof(CHANGER_ELEMENT_STATUS_EX);
                }
                else
                {
                    elementStatus += 1;
                }

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }

                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        if (outputBuffLen >= (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX)) && changerData->DriveID == PV122T)
        {
            Irp->IoStatus.Information = totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX);
        }
        else
        {
            Irp->IoStatus.Information = totalElements * sizeof(CHANGER_ELEMENT_STATUS);
        }
    }
    else if ((status == STATUS_INVALID_DEVICE_REQUEST) && (changerData->DriveID == PV122T))
    {
        //
        // Probably the device doesn't support DVCID bit
        // which retrieves Device Identifier info such as
        // serial number for drives. Try RES once more with
        // DVCID bit turned off.
        //
        if (changerData->ObtainDeviceIdentifier == TRUE)
        {
            changerData->ObtainDeviceIdentifier = FALSE;
            goto RetryRequest;
        }
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        if (changerData->DriveType == BNCHMRK)
        {
            cdb->INIT_ELEMENT_STATUS.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;
        }

        srb->TimeOutValue = fdoExtension->TimeOutValue * 10;
        srb->DataTransferLength = 0;

    }
    else
    {
        if (changerData->DriveID == PV122T)
        {
            PCHANGER_ELEMENT_LIST elementList;
            PCHANGER_ELEMENT element;

            elementList = &initElementStatus->ElementList;
            element = &elementList->Element;

            //
            // Use the DELL vendor-unique initialize with range command
            //

            srb->CdbLength = CDB10GENERIC_LENGTH;
            cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = SCSIOP_INIT_ELEMENT_RANGE;
            cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

            //
            // Addresses of elements need to be mapped from 0-based to device-specific.
            //

            cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
            cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

            cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
            cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

            //
            // Indicate whether to use bar code scanning.
            //

            cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->DataTransferLength = 0;
        }
        else
        {
            ChangerClassFreePool(srb);
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // For now do nothing
    //
    if (changerData->DriveID != PV122T)
    {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
        return STATUS_SUCCESS;
    }

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // PV122T doesn't support 2-sided media
    //
    if (setPosition->Flip)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
   //
   // Not supported by this changer.
   //
   return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Benchmark VS640 and PV122T don't support 2-sided media
    //
    if (moveMedium->Flip && changerData->DriveType == BNCHMRK)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    //
    // Reinitialize not supported by this changer
    //
    Irp->IoStatus.Information = 0;
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
   PCHANGER_SEND_VOLUME_TAG_INFORMATION volTagInfo = Irp->AssociatedIrp.SystemBuffer;
   PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
   PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
   PCHANGER_ELEMENT    element = &volTagInfo->StartingElement;
   PSCSI_REQUEST_BLOCK srb;
   PVOID    tagBuffer;
   PCDB     cdb;
   NTSTATUS status;

   if (changerData->DriveType == BNCHMRK)
   {
       return STATUS_INVALID_DEVICE_REQUEST;
   }

   switch (volTagInfo->ActionCode) {
        case SEARCH_ALL      :
        case SEARCH_PRIMARY  :
        case SEARCH_ALTERNATE:
        case SEARCH_ALL_NO_SEQ:
        case SEARCH_PRI_NO_SEQ:
        case SEARCH_ALT_NO_SEQ:
        case UNDEFINE_PRIMARY:
        case UNDEFINE_ALTERNATE:
        case ASSERT_PRIMARY:
        case ASSERT_ALTERNATE:
             break;

        case REPLACE_PRIMARY:
        case REPLACE_ALTERNATE:

            //
            // Ensure that only one element is being specified.
            //

            if (element->ElementType == AllElements) {

                DebugPrint((1,
                           "QueryVolumeTags: Attempting REPLACE on AllElements\n"));

                return STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        default:

            DebugPrint((1,
                       "QueryVolumeTags: Unsupported operation. ActionCode %x\n",
                       volTagInfo->ActionCode));

            return STATUS_INVALID_DEVICE_REQUEST;
   }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    tagBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, MAX_VOLUME_TEMPLATE_SIZE);

    if (!srb || !tagBuffer) {

        if (srb) {
            ChangerClassFreePool(srb);
        }
        if (tagBuffer) {
            ChangerClassFreePool(tagBuffer);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(tagBuffer, MAX_VOLUME_TEMPLATE_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = MAX_VOLUME_TEMPLATE_SIZE;

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->SEND_VOLUME_TAG.OperationCode = SCSIOP_SEND_VOLUME_TAG;


    if ((volTagInfo->ActionCode == SEARCH_ALL)        ||
        (volTagInfo->ActionCode == SEARCH_PRIMARY)    ||
        (volTagInfo->ActionCode == SEARCH_ALTERNATE)  ||
        (volTagInfo->ActionCode == SEARCH_ALL_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_PRI_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_ALT_NO_SEQ)) {

        //
        // This is reserved for all other action codes.
        //

        cdb->SEND_VOLUME_TAG.ElementType = (UCHAR)element->ElementType;

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);


    } else if ((volTagInfo->ActionCode == UNDEFINE_PRIMARY)   ||
               (volTagInfo->ActionCode == UNDEFINE_ALTERNATE)) {

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = 0;

    } else if ((volTagInfo->ActionCode == REPLACE_PRIMARY)   ||
               (volTagInfo->ActionCode == REPLACE_ALTERNATE) ||
               (volTagInfo->ActionCode == ASSERT_PRIMARY)    ||
               (volTagInfo->ActionCode == ASSERT_ALTERNATE)) {


        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);
    }


    if (element->ElementType == AllElements) {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    }

    cdb->SEND_VOLUME_TAG.ActionCode = (UCHAR)volTagInfo->ActionCode;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     tagBuffer,
                                     MAX_VOLUME_TEMPLATE_SIZE,
                                     TRUE);

    ChangerClassFreePool(tagBuffer);

    if (NT_SUCCESS(status)) {

        PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
        PVOID statusBuffer;
        ULONG returnElements = irpStack->Parameters.DeviceIoControl.OutputBufferLength / sizeof(READ_ELEMENT_ADDRESS_INFO);
        ULONG requestLength;

        //
        // Size of buffer returned is based on the size of the user buffer.
        // If it's incorrectly sized, the IoStatus.Information will be updated
        // to indicate how large it should really be.
        //

        requestLength = sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE) +
                              (sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS) * returnElements);

        statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, requestLength);
        if (!statusBuffer) {
            ChangerClassFreePool(srb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(statusBuffer, requestLength);

        //
        // Build read volume element command.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = requestLength;

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.OperationCode = SCSIOP_REQUEST_VOL_ELEMENT;
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.ElementType = (UCHAR)element->ElementType;

        if (element->ElementType == AllElements) {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

        } else {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
        }

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[0] = (UCHAR)(returnElements >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[1] = (UCHAR)(returnElements & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.VolTag = 1;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[0] = (UCHAR)(requestLength >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[1] = (UCHAR)(requestLength & 0xFF);


        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             statusBuffer,
                                             requestLength,
                                             TRUE);


        if ((status == STATUS_SUCCESS) || (status == STATUS_DATA_OVERRUN)) {

            PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
            PELEMENT_STATUS_PAGE   statusPage;
            PCHANGER_ELEMENT_STATUS elementStatus;
            PELEMENT_DESCRIPTOR elementDescriptor;
            ULONG i;
            ULONG descriptorLength;
            ULONG numberElements;
            ULONG dataTransferLength = srb->DataTransferLength;

            //
            // Make it success.
            //

            status = STATUS_SUCCESS;

            //
            // Determine if ANY matches were found.
            //

            if (dataTransferLength <= sizeof(ELEMENT_STATUS_HEADER)) {
                numberElements = 0;
            } else {

                //
                // Subtract out header and page info.
                //

                dataTransferLength -= sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
                numberElements = dataTransferLength / sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS);

            }

            DebugPrint((1,
                       "QueryVolumeTags: Matches found - %x\n",
                       numberElements));

            //
            // Update IoStatus.Information to indicate the correct buffer size.
            // Account for the fact that READ_ELEMENT_ADDRESS_INFO is declared
            // with a one-element array of CHANGER_ELEMENT_STATUS.
            //

            Irp->IoStatus.Information = sizeof(READ_ELEMENT_ADDRESS_INFO) +
                                        ((numberElements - 1) *
                                         sizeof(CHANGER_ELEMENT_STATUS));

            //
            // Fill in user buffer.
            //

            readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            RtlZeroMemory(readElementAddressInfo, irpStack->Parameters.DeviceIoControl.OutputBufferLength);

            readElementAddressInfo->NumberOfElements = numberElements;

            if (numberElements) {

                ELEMENT_TYPE        elementType;

                //
                // The buffer is composed of a header, status page, and element descriptors.
                // Point each element to it's respective place in the buffer.
                //


                (PCHAR)statusPage = (PCHAR)statusHeader;
                (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

                elementType = statusPage->ElementType;

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                elementStatus = &readElementAddressInfo->ElementStatus[0];

                //
                // Set values for each element descriptor.
                //

                for (i = 0; i < numberElements; i++ ) {

                    PSTARMATX_ELEMENT_DESCRIPTOR_PLUS tmpDescriptor =
                                                            (PSTARMATX_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                    //
                    // Get the address for this element.
                    //

                    elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                    //
                    // Set the element type.
                    //

                    elementStatus->Element.ElementType = elementType;
                    elementStatus->Flags = 0;

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }


                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags |= elementDescriptor->Full;
                    elementStatus->Flags |= (elementDescriptor->Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                    elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->SValid << 23);

                    //
                    // Map any exceptions reported directly.
                    // If there is volume info returned ensure that it's not all spaces
                    // as this indicates that the label is missing or unreadable.
                    //

                    if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                        //
                        // Map the exception.
                        //

                        elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    if (statusPage->PVolTag) {

                        RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->PrimaryVolumeID,
                                      tmpDescriptor->PrimaryVolumeTag.VolumeIdentificationField,
                                      SCSI_VOLUME_ID_LENGTH);

                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {
                        RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->AlternateVolumeID,
                                      tmpDescriptor->AlternateVolumeTag.VolumeIdentificationField,
                                      SCSI_VOLUME_ID_LENGTH);

                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                    (PCHAR)elementDescriptor += descriptorLength;
                }
            }
        } else {
            DebugPrint((1,
                       "QueryVolumeTags: RequestElementAddress failed. %x\n",
                       status));
        }

        ChangerClassFreePool(statusBuffer);

    } else {
        DebugPrint((1,
                   "QueryVolumeTags: Send Volume Tag failed. %x\n",
                   status));
    }
    if (srb) {
        ChangerClassFreePool(srb);
    }
    return status;
}


NTSTATUS
StarMatxBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds
    an array of element addresses. These are used to translate between the
    device-specific addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = STARMATX_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    if (changerData->DriveID == PV122T || changerData->DriveID == LIB_AIT)
    {
        cdb->MODE_SENSE.Dbd = 1;
    }
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = STARMATX_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        //
        // Hack for Powerfile C200 changer, Benchmark VS640, and Compaq Lib-81 AIT autoloaders
        //
        addressMapping->NumberOfElements[ChangerIEPort] = 0;

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        if (changerData->DriveType == BNCHMRK || changerData->DriveID == LIB_AIT)
        {
            addressMapping->NumberOfElements[ChangerDoor] = 0;
        }
        else
        {
            addressMapping->NumberOfElements[ChangerDoor] = 1;
        }

        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "StarMatx.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == STARMATX_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
    changerDeviceError->ChangerProblemType = DeviceProblemNone;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\pnrmc\pnrmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pnrmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _PNR_MC_
#define _PNR_MC_

typedef struct _PNR_STORAGE_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR ExEnable : 1;
    UCHAR InEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 2;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 7;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} PNR_ELEMENT_DESCRIPTOR, *PPNR_ELEMENT_DESCRIPTOR;

#define PNR_NO_ELEMENT 0xFFFF

#define DRM_1004 0x01


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Indicates the unit being supported.
    //

    ULONG DeviceID;

    //
    // Flag to indicate if diagnostic command failed or not
    //
    BOOLEAN HardwareError;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
PNRBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\qualstar\qlstrmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    qlstrmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _QLSTR_MC_
#define _QLSTR_MC_

//
// Exabyte uses an addition 4 bytes on their device capabilities page...
//

typedef union _QUAL_ELEMENT_DESCRIPTOR {

    struct _QUAL_FULL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];

        union {

            struct {
                UCHAR VolumeTagInformation[36];
                UCHAR Reserved8[4];
                UCHAR SerialNumber[SERIAL_NUMBER_LENGTH];
            } VolumeTagDeviceID;
        
            struct {
                UCHAR Reserved8[4];
                UCHAR SerialNumber[SERIAL_NUMBER_LENGTH];
            } DeviceID;
        
        };

    } QUAL_FULL_ELEMENT_DESCRIPTOR, *PQUAL_FULL_ELEMENT_DESCRIPTOR;

    struct _QUAL_PARTIAL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } QUAL_PARTIAL_ELEMENT_DESCRIPTOR, *PQUAL_PARTIAL_ELEMENT_DESCRIPTOR;

} QUAL_ELEMENT_DESCRIPTOR, *PQUAL_ELEMENT_DESCRIPTOR;

typedef struct _QUAL_PARTIAL_ELEMENT_DESCRIPTOR QUAL_PARTIAL_ELEMENT_DESCRIPTOR, *PQUAL_PARTIAL_ELEMENT_DESCRIPTOR;
typedef struct _QUAL_FULL_ELEMENT_DESCRIPTOR QUAL_FULL_ELEMENT_DESCRIPTOR, *PQUAL_FULL_ELEMENT_DESCRIPTOR;

#define QUAL_PARTIAL_SIZE sizeof(QUAL_PARTIAL_ELEMENT_DESCRIPTOR)
#define QUAL_FULL_SIZE sizeof(QUAL_FULL_ELEMENT_DESCRIPTOR)


typedef struct _CONFIG_MODE_PAGE {
    UCHAR MdSelHeader[4];
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR Length : 5;
    UCHAR Type : 2;
    UCHAR Write : 1;
    UCHAR Reserved2;
    UCHAR VariableName[20];
    UCHAR Reserved3;
    UCHAR VariableValue[16];
    UCHAR Reserved4;
} CONFIG_MODE_PAGE, *PCONFIG_MODE_PAGE;

#define QLS_NO_ELEMENT 0xFFFF


// DriveID
#define TLS_2xxx      1
#define TLS_4xxx      2

// DriveType
#define D_4MM           1
#define D_8MM           2


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveType;

    //
    // Flag to indicate if Diagnostic command failed or not
    //
    BOOLEAN HardwareError;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PQUAL_ELEMENT_DESCRIPTOR ElementDescriptor
    );


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\powerfil\powerfil.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    powerfil.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _POWERFIL_H
#define _POWERFIL_H

//
// Drive type
//
#define POWERFILE_DVD   1
#define BNCHMRK         2
#define COMPAQ          3

//
// Drive id
//
#define DVD             0
#define BM_VS640        1
#define LIB_AIT         2
#define PV122T          3

#define STARMATX_NO_ELEMENT          0xFFFF

#define SCSI_VOLUME_ID_LENGTH    32
typedef struct _SCSI_VOLUME_TAG {
   UCHAR VolumeIdentificationField[SCSI_VOLUME_ID_LENGTH];
   UCHAR Reserved1[2];
   ULONG VolumeSequenceNumber;
} SCSI_VOLUME_TAG, *PSCSI_VOLUME_TAG;


typedef struct _STARMATX_ELEMENT_DESCRIPTOR {
 UCHAR ElementAddress[2];
 UCHAR Full : 1;
 UCHAR ImpExp : 1;
 UCHAR Except : 1;
 UCHAR Access : 1;
 UCHAR ExEnab : 1;
 UCHAR InEnab : 1;
 UCHAR Reserved1 : 2;
 UCHAR Reserved2;
 UCHAR AdditionalSenseCode;
 UCHAR AddSenseCodeQualifier;
 UCHAR Lun : 3;
 UCHAR Reserved3 : 1;
 UCHAR LUValid :1;
 UCHAR IDValid :1;
 UCHAR Reserved4 : 1;
 UCHAR NotBus : 1;
 UCHAR SCSIBusAddress;
 UCHAR Reserved5 ;
 UCHAR Reserved6 :6;
 UCHAR Invert : 1;
 UCHAR SValid : 1;
 UCHAR SourceStorageElementAddress[2];
 UCHAR Reserved7 [4];
} STARMATX_ELEMENT_DESCRIPTOR, *PSTARMATX_ELEMENT_DESCRIPTOR;

typedef struct _STARMATX_ELEMENT_DESCRIPTOR_PLUS {
   UCHAR ElementAddress[2];
   UCHAR Full : 1;
   UCHAR ImpExp : 1;
   UCHAR Except : 1;
   UCHAR Access : 1;
   UCHAR ExEnab : 1;
   UCHAR InEnab : 1;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR AdditionalSenseCode;
   UCHAR AddSenseCodeQualifier;
   UCHAR Lun : 3;
   UCHAR Reserved3 : 1;
   UCHAR LUValid :1;
   UCHAR IDValid :1;
   UCHAR Reserved4 : 1;
   UCHAR NotBus : 1;
   UCHAR SCSIBusAddress;
   UCHAR Reserved5 ;
   UCHAR Reserved6 :6;
   UCHAR Invert : 1;
   UCHAR SValid : 1;
   UCHAR SourceStorageElementAddress[2];
   SCSI_VOLUME_TAG PrimaryVolumeTag;
   SCSI_VOLUME_TAG AlternateVolumeTag;
   UCHAR Reserved7 [4];
} STARMATX_ELEMENT_DESCRIPTOR_PLUS, *PSTARMATX_ELEMENT_DESCRIPTOR_PLUS;

typedef struct _BNCHMRK_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR Reserved1 : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved4 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved5 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved6;
    UCHAR Reserved7 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR BarcodeLabel[6];
} BNCHMRK_ELEMENT_DESCRIPTOR, *PBNCHMRK_ELEMENT_DESCRIPTOR;

typedef struct _BNCHMRK_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR Reserved1 : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved4 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved5 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved6;
    UCHAR Reserved7 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    union
    {
        struct
        {
            UCHAR VolumeTagInformation[36];
            UCHAR CodeSet : 4;
            UCHAR Reserved8: 4;
            UCHAR IdType : 4;
            UCHAR Reserved9 : 4;
            UCHAR Reserved10;
            UCHAR IdLength;
            UCHAR Identifier[10];
        } VolumeTagDeviceID;

        struct
        {
            UCHAR CodeSet : 4;
            UCHAR Reserved8: 4;
            UCHAR IdType : 4;
            UCHAR Reserved9 : 4;
            UCHAR Reserved10;
            UCHAR IdLength;
            UCHAR Identifier[10];
        } DeviceID;
    };
} BNCHMRK_ELEMENT_DESCRIPTOR_PLUS, *PBNCHMRK_ELEMENT_DESCRIPTOR_PLUS;

typedef struct _BNCHMRK_STORAGE_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR Reserved1 : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Reserved4[3];
    UCHAR Reserved5 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR BarcodeLabel[6];
    UCHAR Reserved6[37];
} BNCHMRK_STORAGE_ELEMENT_DESCRIPTOR, *PBNCHMRK_STORAGE_ELEMENT_DESCRIPTOR;

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Lock count
    //
    ULONG LockCount;

    //
    // Flag to indicate whether or not the driver
    // should attempt to retrieve Device Identifier
    // info (serialnumber, etc). Not all devices
    // support this
    //
    BOOLEAN ObtainDeviceIdentifier;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
StarMatxBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _POWERFIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\qualstar\qlstrmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    qlstrmc.c

Abstract:

    This module contains device-specific routines for Qualstar's 
        medium changers:
            TLS-4xxx (w/Exabyte 8mm Drives, Sony SDX300 8mm Drives)
            TLS-2xxx (w/HP, Conner/Seagate, Sony 4mm Drives)

Author:

    davet (Dave Therrien)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "qlstrmc.h"


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the qualstar changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}




NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;
    PCONFIG_MODE_PAGE    modeBuffer;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4210",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4210A",9) == 9) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4220",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4420",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4440",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4480",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4660",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-46120",9) == 9) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2218",8) == 8) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2218A",9) == 9) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2236",8) == 8) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2436",8) == 8) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2472",8) == 8) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-24144",9) == 9) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 220",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 420",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 440",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 480",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 660",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 6120",12) == 12) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS 4G 236",10) == 10) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS 4G 436",10) == 10) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS 4G 472",10) == 10) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS 4G 4144",11) == 11) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-412360", 10) == 10) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        }
    }

    ChangerClassFreePool(dataBuffer);

    // 
    // -------------------------------------------------------------------------
    // 
    // THREE Library Config parameters will be set by this driver
    // 
    // 1) Config/Hndlr/DoorOpen/Hold
    //      ( to deal with someone opening the front door randomly

    
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                   sizeof(CONFIG_MODE_PAGE));
    if (!modeBuffer) {
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(CONFIG_MODE_PAGE));
    modeBuffer->PageCode = 0x3D;
    modeBuffer->PageLength = 0x28;
    modeBuffer->Length = 0;
    modeBuffer->Type = 0;
    modeBuffer->Write = 1;
    RtlMoveMemory(modeBuffer->VariableName,"HNDLR_DOOR_OPEN", 15);
    RtlMoveMemory(modeBuffer->VariableValue,"HOLD", 4);

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.TimeOutValue = 20;
    srb.DataTransferLength = sizeof(CONFIG_MODE_PAGE);
    srb.DataBuffer = modeBuffer;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
    cdb->MODE_SELECT.PFBit = 1;
    cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb.DataTransferLength;
   
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             modeBuffer,
                                             sizeof(CONFIG_MODE_PAGE),
                                             TRUE);
    ChangerClassFreePool(modeBuffer);

    // -----------------------------------------------------------
    // 2) Config/Hndlr/Io Call Key / Disabled
    //      ( to allow NTMS to timeout )
   
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                   sizeof(CONFIG_MODE_PAGE));
    if (!modeBuffer) {
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(CONFIG_MODE_PAGE));
    modeBuffer->PageCode = 0x3D;
    modeBuffer->PageLength = 0x28;
    modeBuffer->Length = 0;
    modeBuffer->Type = 0;
    modeBuffer->Write = 1;
    RtlMoveMemory(modeBuffer->VariableName,"HNDLR_IO_CALL_KEY", 17);
    RtlMoveMemory(modeBuffer->VariableValue,"DISABLE", 7);

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.TimeOutValue = 20;
    srb.DataTransferLength = sizeof(CONFIG_MODE_PAGE);
    srb.DataBuffer = modeBuffer;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
    cdb->MODE_SELECT.PFBit = 1;
    cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb.DataTransferLength;
   
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             modeBuffer,
                                             sizeof(CONFIG_MODE_PAGE),
                                             TRUE);
    ChangerClassFreePool(modeBuffer);

    // -----------------------------------------------------------
    // 3) Disable CALL key, only allow host control

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                   sizeof(CONFIG_MODE_PAGE));
    if (!modeBuffer) {
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(CONFIG_MODE_PAGE));
    modeBuffer->PageCode = 0x3D;
    modeBuffer->PageLength = 0x28;
    modeBuffer->Length = 0;
    modeBuffer->Type = 0;
    modeBuffer->Write = 1;
    RtlMoveMemory(modeBuffer->VariableName,"HNDLR_IO_SLOT_ACCESS", 20);
    RtlMoveMemory(modeBuffer->VariableValue,"HOST", 4);

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.TimeOutValue = 20;
    srb.DataTransferLength = sizeof(CONFIG_MODE_PAGE);
    srb.DataBuffer = modeBuffer;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
    cdb->MODE_SELECT.PFBit = 1;
    cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb.DataTransferLength;
   
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             modeBuffer,
                                             sizeof(CONFIG_MODE_PAGE),
                                             TRUE);
    ChangerClassFreePool(modeBuffer);

    // -----------------------------------------------------------

    return STATUS_SUCCESS;
}

VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:

            if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x83:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            if (senseBuffer->AdditionalSenseCode == 0x80) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x03:
                    case 0x04:

                        *Retry = FALSE;
                        *Status = STATUS_MAGAZINE_NOT_PRESENT;
                         break;
                    case 0x05:
                    case 0x06:
                        *Retry = TRUE;
                        *Status = STATUS_DEVICE_NOT_CONNECTED;
                        break;
                default:
                    break;
                }
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           DebugPrint((1, "Hardware Error - SenseCode %x, ASC %x, ASCQ %x\n",
                       senseBuffer->SenseKey,
                       senseBuffer->AdditionalSenseCode,
                       senseBuffer->AdditionalSenseCodeQualifier));
           changerData->HardwareError = TRUE;
           break;
        }

        default:
            break;
        }
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    qualstar changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;

    // There can be many FIXED slots in the various models of these
    // libraries and none are identified as a cleaner. 
    // This unit also numbers its slots based on the
    // front panel setting. We will suggest setting 
    // the Configure\SCSI\StorageOrder to MAG making
    // slot 1..N order be A01, A02... B01, ... F1, F2... 
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    if (changerData->DriveID == TLS_2xxx) {
        changerParameters->MagazineSize = 18;
    } else {
        changerParameters->MagazineSize = 10;
    }

    changerParameters->DriveCleanTimeout = 600;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

        
    // initialize Features1  
    changerParameters->Features1 = 0;
        // Took away Exchange capability. The device supports the command
        // but a customer may load a medium into the exchange slot and 
        // cause an exchange to fail. Since the picker does not support 
        // holding two media, this device does not really support it. 
        // CHANGER_TRUE_EXCHANGE_CAPABLE;

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;



    //
    // Qualstar indicates whether a bar-code scanner is
    // attached by setting bit-0 in this byte.
    //

    changerParameters->Features0 |= ((changerData->InquiryData.VendorSpecific[19] & 0x1)) ?
                                         CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;
    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 |= CHANGER_INIT_ELEM_STAT_WITH_RANGE     |
                                    CHANGER_CARTRIDGE_MAGAZINE            |
                                    CHANGER_PREDISMOUNT_EJECT_REQUIRED    |
                                    CHANGER_DRIVE_CLEANING_REQUIRED;
 
    if (changerParameters->NumberIEElements != 0) {
        changerParameters->Features0 |= CHANGER_CLOSE_IEPORT                  |
                                        CHANGER_OPEN_IEPORT                   |
                                        CHANGER_LOCK_UNLOCK                   |
                                        CHANGER_REPORT_IEPORT_STATE; 

        changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_IEPORT;
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Qualstar uses an addition 4 bytes...
    //

    length =  sizeof(MODE_PARAMETER_HEADER) +                            
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 0;
    changerParameters->ExchangeFromSlot = 0;
    changerParameters->ExchangeFromIePort = 0;
    changerParameters->ExchangeFromDrive = 0;


        // legal Position capabilities... 
        changerParameters->PositionCapabilities = 0;
        
                
    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    //
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, 
                  VENDOR_ID_LENGTH);

    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, 
                  PRODUCT_ID_LENGTH);

    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel,
                  REVISION_LENGTH);


    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the door or IEPort. Value can be one of the
    following:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;

    // should not be called by an app, but if it is, just return OK
    if ((setAccess->Element.ElementType == ChangerKeypad) || 
        (setAccess->Element.ElementType == ChangerDoor)) { 
                return STATUS_INVALID_DEVICE_REQUEST;
    }

    // if the unit has no IEPORT, fail the request
    if ((setAccess->Element.ElementType == ChangerIEPort) && 
        (changerData->AddressMapping.NumberOfElements[ChangerIEPort] == 0)) {
            return STATUS_INVALID_DEVICE_REQUEST;
    } 

    // Solenoid door locking is an option with this library
    // but do a prevent/allow in case it's present. 

    if (setAccess->Element.ElementType == ChangerIEPort)  {

        srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
        if (!srb) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        if (controlOperation == LOCK_ELEMENT) {

            srb->CdbLength = CDB6GENERIC_LENGTH;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            srb->DataTransferLength = 0;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            cdb->MEDIA_REMOVAL.Prevent = 1;
            cdb->MEDIA_REMOVAL.Control = 0;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            srb->CdbLength = CDB6GENERIC_LENGTH;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            srb->DataTransferLength = 0;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            cdb->MEDIA_REMOVAL.Prevent = 0;
            cdb->MEDIA_REMOVAL.Control = 0;

        } else if (controlOperation == EXTEND_IEPORT) {

            srb->CdbLength = CDB12GENERIC_LENGTH;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

            cdb->MOVE_MEDIUM.TransportElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.TransportElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.SourceElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.SourceElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.Flip = 0;

            // Indicate that the IEPORT should be extended.
            cdb->MOVE_MEDIUM.Control = 0x40;

            srb->DataTransferLength = 0;

        } else if (controlOperation == RETRACT_IEPORT) {
            srb->CdbLength = CDB12GENERIC_LENGTH;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

            cdb->MOVE_MEDIUM.TransportElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.TransportElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.SourceElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.SourceElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.Flip = 0;

            // indicate that the IEPORT must be retracted
            cdb->MOVE_MEDIUM.Control = 0x80;

            srb->DataTransferLength = 0;

         } else {
             status = STATUS_INVALID_PARAMETER;
         }
    } else { // Illegal Element Type
        return STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}




NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ULONG    totalElements = readElementStatus->ElementList.NumberOfElements;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // length will be based on whether vol. tags are returned and element type(s).
    //

    if (elementType == AllElements) {

        //
        // There should be 4 status pages in the returned buffer.
        //
        statusPages = 4;
    } else {
        statusPages = 1;
    }

    if ((readElementStatus->VolumeTagInfo) ||
        (elementType == ChangerDrive)) {

        //
        // Each descriptor will have an embedded volume tag buffer.
        //

        length = sizeof(ELEMENT_STATUS_HEADER) + 
                         (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
                 (QUAL_FULL_SIZE * readElementStatus->ElementList.NumberOfElements);
    } else {

        length = sizeof(ELEMENT_STATUS_HEADER) + 
                       (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
               (QUAL_PARTIAL_SIZE * readElementStatus->ElementList.NumberOfElements);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
       ChangerClassFreePool(statusBuffer);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {
       cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] = 0;
       cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] = 0;
    } else {
       cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
           (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
   
       cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
           (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }


    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if ((NT_SUCCESS(status)) || 
          (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PQUAL_ELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        //
        // If the status was STATUS_DATA_OVERRUN, check
        // if it was really DATA_OVERRUN or was it just
        // DATA_UNDERRUN
        //
        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                    elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                elementStatus->Element.ElementAddress |=
                    (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;


                if (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Full;
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                if (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                    elementStatus->TargetId = elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                }
                if (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                    elementStatus->Lun = elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Lun;
                }

                if (tagInfo) {
                    RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                                  elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.VolumeTagDeviceID.VolumeTagInformation, 
                                  MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                }

                if (elementType == ChangerDrive) {
                    if (outputBuffLen >=
                        (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
                    
                        PCHANGER_ELEMENT_STATUS_EX elementStatusEx;
                        PQUAL_FULL_ELEMENT_DESCRIPTOR elementDescPlus =
                            (PQUAL_FULL_ELEMENT_DESCRIPTOR) elementDescriptor;
                        PUCHAR idField = NULL;
                        ULONG inx;
                    
                        elementStatusEx = (PCHANGER_ELEMENT_STATUS_EX)elementStatus;
                    
                        if (statusPage->PVolTag) {
                            idField =  elementDescPlus->VolumeTagDeviceID.SerialNumber;
                        } else {
                            idField = elementDescPlus->DeviceID.SerialNumber;
                        }
                    
                        if ((*idField != '\0') && (*idField != ' ')) {
                    
                            RtlMoveMemory(elementStatusEx->SerialNumber,
                                          idField,
                                          SERIAL_NUMBER_LENGTH);
                    
                            DebugPrint((3, "Serial number : %s\n",
                                        elementStatusEx->SerialNumber));

                            elementStatusEx->Flags |= ELEMENT_STATUS_PRODUCT_DATA;
                        } 
                    }
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer and element descriptor array.
                //
                if (outputBuffLen >=
                    (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
                    (PUCHAR) elementStatus += sizeof(CHANGER_ELEMENT_STATUS_EX);
                } else {

                    elementStatus += 1;
                }

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        if (outputBuffLen >= 
            (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {

            Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS_EX) *
                                         numberElements;
        } else {
        
            Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;
        }

    } 

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;
        cdb->INIT_ELEMENT_STATUS.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;


        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        PCHANGER_ELEMENT_LIST elementList = &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = &elementList->Element;

        //
        // Use the vendor-unique initialize with range command
        //

        srb->CdbLength = CDB10GENERIC_LENGTH;
        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        //
        // Addresses of elements need to be mapped from 0-based to device-specific.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        //
        // Indicate whether to use bar code scanning.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    return STATUS_INVALID_DEVICE_REQUEST;
/*

    if ((setPosition->Destination.ElementType == ChangerDoor) || 
        (setPosition->Destination.ElementType == ChangerKeypad) ||
        (setPosition->Destination.ElementType == ChangerTransport)) { 
        return STATUS_ILLEGAL_ELEMENT_ADDRESS;       
    } 

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }


    //
    // This library doesn't support 2-sided media.
    //

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
*/
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    These library units support the exchange medium command but it has
    limitations since it is not a dual picker mechanism. Therefore, 
    this device will return STATUS_INVALID_DEVICE_REQUEST. 

Arguments:

    DeviceObject
    Irp

Return Value:

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    //
    // This library doesn't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    // this device does not support a Rezero Unit Command
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = QLS_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);


    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;
    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PQUAL_ELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asq = ElementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.AddSenseCodeQualifier;
    ULONG exceptionCode;

    //
    // On this library, the additional sense code is always 0x83.
    //

    switch (asq) {
        case 0x0:
            exceptionCode = ERROR_LABEL_QUESTIONABLE;
            break;

        case 0x1:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        case 0x2:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        case 0x3:
            exceptionCode = ERROR_LABEL_QUESTIONABLE;
            break;


        case 0x4:
            exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
            break;

        case 0x8:
        case 0x9:
        case 0xA:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;

}




BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == QLS_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   
   //
   // Initialize the flag in the device extension to FALSE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set this flag to TRUE in ChangerError routine.
   //
   changerData->HardwareError = FALSE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "Qlstrmc\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
      changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\quantum\qntmmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    qntmmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _QNTM_MC_
#define _QNTM_MC_

typedef struct _QNTM_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;                      // true for drives only
    UCHAR Reserved6 : 1;                // true for drives only
    UCHAR LunValid : 1;                 // true for drives only
    UCHAR IdValid : 1;                  // true for drives only
    UCHAR Reserved7 : 1;                // true for drives only
    UCHAR NotThisBus : 1;               // true for drives only
    UCHAR BusAddress;                   // true for drives only
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
    UCHAR DensityCode;
    UCHAR Unused;
} QNTM_ELEMENT_DESCRIPTOR, *PQNTM_ELEMENT_DESCRIPTOR;

typedef struct _QNTM_TRANSPORT_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;                      // true for drives only
    UCHAR Reserved6 : 1;                // true for drives only
    UCHAR LunValid : 1;                 // true for drives only
    UCHAR IdValid : 1;                  // true for drives only
    UCHAR Reserved7 : 1;                // true for drives only
    UCHAR NotThisBus : 1;               // true for drives only
    UCHAR BusAddress;                   // true for drives only
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} QNTM_TRANSPORT_ELEMENT_DESCRIPTOR, *PQNTM_TRANSPORT_ELEMENT_DESCRIPTOR;
#define QNT_NO_ELEMENT 0xFFFF

//
// Diagnostic related defines
//
// ASC
//
#define QNTMMC_ASC_POSITION_ERROR       0x15

//
// DeviceStatus defines
//
#define QNTMMC_DEVICE_PROBLEM_NONE      0x00
#define QNTMMC_HW_ERROR                 0x01
#define QNTMMC_CHM_ERROR                0x02


// DriveType
#define QNTM_DLT  1


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;



typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // DeviceStatus after diagnostic test has been completed
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
QntmBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _QNTM_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\seagate\wmi.c ===
/*++ 

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for DDS changers.

Environment:

    kernel mode only

Revision History:

--*/ 
#include "ntddk.h"
#include "mcd.h"
#include "seaddsmc.h"

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++ 

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.


Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   PUCHAR  resultBuffer;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   changerData->HardwareError = FALSE;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "SEADDSMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
        //
        // Diagnostic test failed. Do ReceiveDiagnostic to receive
        // the results of the diagnostic test
        //  
        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        cdb->CDB6GENERIC.OperationCode = SCSIOP_RECEIVE_DIAGNOSTIC;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(SEADDSMC_RECV_DIAG);

        resultBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                                sizeof(SEADDSMC_RECV_DIAG));
        if (resultBuffer == NULL) {
            //
            // No memory. Set the generic error code (DeviceProblemHardware)
            // and return STATUS_SUCCESS
            //
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            DebugPrint((1, "SEADDSMC:PerformDiagnostics - Not enough memory to ",
                        "receive diagnostic results\n"));

            ChangerClassFreePool(srb);
            return STATUS_SUCCESS;
        }

        srb->DataTransferLength = sizeof(SEADDSMC_RECV_DIAG);
        srb->DataBuffer = resultBuffer;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->TimeOutValue = 120;
        
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                srb->DataBuffer,
                                                srb->DataTransferLength,
                                                FALSE);
        if (NT_SUCCESS(status)) {
              ProcessDiagnosticResult(changerDeviceError,
                                      resultBuffer);
        }
                               
        ChangerClassFreePool(resultBuffer);
        status = STATUS_SUCCESS;
   } 

   ChangerClassFreePool(srb);
   return status;
}


VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer
    )
/*+++

Routine Description :

   This routine parses the data returned by the device on
   Receive Diagnostic command, and returns appropriate
   value for the problem type.
   
Arguements :

   changerDeviceError - Output buffer with diagnostic info
   
   resultBuffer - Buffer in which the data returned by the device
                  Receive Diagnostic command is stored.
   
Return Value :

   DeviceProblemNone - If there is no problem with the device
   Appropriate status code indicating the changer problem type.   
--*/
{
   UCHAR fraCode;
   CHANGER_DEVICE_PROBLEM_TYPE changerErrorType;
   PSEADDSMC_RECV_DIAG diagBuffer;

   changerErrorType = DeviceProblemNone;

   diagBuffer = (PSEADDSMC_RECV_DIAG)resultBuffer;
   fraCode = diagBuffer->FRA;

   DebugPrint((1, "seaddsmc\\FRACode : %x\n", fraCode));
   switch (fraCode) {
      case SEADDSMC_NO_ERROR: {
          changerErrorType = DeviceProblemNone;
          break;
      }

      case SEADDSMC_DRIVE_ERROR: {
          changerErrorType = DeviceProblemDriveError;
          break;
      }

      default: {
          changerErrorType = DeviceProblemHardware;
          break;
      }
   } // switch (fraCode) 

   changerDeviceError->ChangerProblemType = changerErrorType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\seagate\seaddsmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    sddsmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _SDDS_MC_
#define _SDDS_MC_


typedef struct _SEAGATE_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
} SEAGATE_ELEMENT_DESCRIPTOR, *PSEAGATE_ELEMENT_DESCRIPTOR;

#define DDS_NO_ELEMENT 0xFFFF


//
// Drive ID's
//

#define SEAGATE   0x00000001

#define SEAGATE_SERIAL_NUMBER_LENGTH 7

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the Lowest element address of the unit.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

    UCHAR Reserved[3];

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Indicates which device is currently supported.
    // See above.
    //

    ULONG DriveID;

    //
    // Flag to indicate if the diagnostic test failed or not.
    //
    BOOLEAN HardwareError;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[SEAGATE_SERIAL_NUMBER_LENGTH];

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;

typedef struct _SEADDSMC_RECV_DIAG {
    UCHAR PageCode;
    UCHAR Reserved1;
    UCHAR Reserved2;
    UCHAR AdditionalLength;
    UCHAR LastSuccessfulTest;
    UCHAR ErrorCode;
    UCHAR FRA;
    UCHAR TapeLoadCount;
} SEADDSMC_RECV_DIAG, *PSEADDSMC_RECV_DIAG;

//
// defines for Diagnostics
//
#define SEADDSMC_NO_ERROR       0x00
#define SEADDSMC_DRIVE_ERROR    0x01

NTSTATUS
DdsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

//
// Internal functions for wmi
//
VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\quantum\qntmmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    qntmmc.c

Abstract:

    This module contains device-specific routines for Quantum's DLT
        Changers: 
                DLT2500, DLT4500, DLT7500
                DLT2700, DLT4700, DLT7700

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "qntmmc.h"


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, QntmBuildAddressMapping)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the exabyte changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}





NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    changerData->DriveType = QNTM_DLT;

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = QntmBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
   PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
   PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   ULONG deviceStatus;

   if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
    switch (senseBuffer->SenseKey) {
      case SCSI_SENSE_HARDWARE_ERROR: {
         UCHAR qntmmcASC;
         UCHAR qntmmcASCQ;

         qntmmcASC = senseBuffer->AdditionalSenseCode;
         qntmmcASCQ = senseBuffer->AdditionalSenseCodeQualifier;
         deviceStatus = QNTMMC_HW_ERROR;

         switch (qntmmcASC) {
            case QNTMMC_ASC_POSITION_ERROR: {
               deviceStatus = QNTMMC_CHM_ERROR;
               break;
            }

            default: {
               deviceStatus = QNTMMC_HW_ERROR;
               break;
            }
         } // switch (qntmmcASC) 

         changerData->DeviceStatus = deviceStatus;
         break;
      }
    } // switch (senseBuffer->SenseKey)
   }

   return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    exabyte changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + 
                   sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;
    cdb->MODE_SENSE.Dbd = 1;
    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += (sizeof(MODE_PARAMETER_HEADER));

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[AllElements] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = elementAddressPage->MediumTransportElementAddress[1];
        if (elementAddressPage->FirstDataXFerElementAddress[1] < addressMapping->LowAddress) {
            addressMapping->LowAddress = elementAddressPage->FirstDataXFerElementAddress[1];
        }
    }
    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->DriveCleanTimeout = 300;

    changerParameters->FirstSlotNumber = 0;             
    changerParameters->FirstDriveNumber =  0;           
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;           

    changerParameters->MagazineSize = addressMapping->NumberOfElements[ChangerSlot];

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

   
    //
    // Features based on manual, nothing programatic.
    //

    // initialize Features1  
        changerParameters->Features1 = 0;


    changerParameters->Features0 = 
         CHANGER_CARTRIDGE_MAGAZINE              |
         CHANGER_DRIVE_CLEANING_REQUIRED         |
         // TODO - change to CHANGER_CLEANER_ACCESS_NOT_VALID 
         CHANGER_CLEANER_ACCESS_NOT_VALID          |
         CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;

        // door cannot be programmatically locked on this device

    //
    // build device capabilities mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + 
                   sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;
    cdb->MODE_SENSE.Dbd = 1;
    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += (sizeof(MODE_PARAMETER_HEADER));
    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

        changerParameters->PositionCapabilities = 0;


    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 
    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate drive type .
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door, Keypad and IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    // this device does not support changer locking of any kind
    return STATUS_INVALID_DEVICE_REQUEST;

}




NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages, realElements;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {
        statusPages = 3;                // only transport, slot and drive
    } else {
        statusPages = 1;
    }

    length = sizeof(ELEMENT_STATUS_HEADER) + 
                    (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

    if (readElementStatus->VolumeTagInfo) {
         return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (elementType == AllElements) {
        length +=  ( sizeof(QNTM_TRANSPORT_ELEMENT_DESCRIPTOR) +
                     ( sizeof(QNTM_ELEMENT_DESCRIPTOR) * 
                       ((readElementStatus->ElementList.NumberOfElements)-1))); 
    } else if (elementType == ChangerTransport) {
           length += (sizeof(QNTM_TRANSPORT_ELEMENT_DESCRIPTOR) * 
                              readElementStatus->ElementList.NumberOfElements); 
    } else {
        length += (sizeof(QNTM_ELEMENT_DESCRIPTOR) * 
                           readElementStatus->ElementList.NumberOfElements);
    }


    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = 0;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] = 0;
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] = 0;
    } else { 
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
             (UCHAR)((element->ElementAddress + 
              addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
             (UCHAR)((element->ElementAddress + 
             addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = 
           (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = 
           (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = 
           (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if ((NT_SUCCESS(status)) || (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements =
               readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        //
        // Check if the error was STATUS_DATA_OVERRUN
        //
        if (status == STATUS_DATA_OVERRUN) {
           //
           // Check if there was a DATA_OVERRUN, or was it just 
           // DATA_UNDERRUN reported as DATA_OVERRRUN.
           //
           if (srb->DataTransferLength < length) {
              DebugPrint((1, 
                          "DATA_UNDERRUN status reported as DATA_OVERRUN.\n"));
              status = STATUS_SUCCESS;
           } else {
              //
              // It was really DATA_OVERRUN error. Report accordingly.
              //
              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);
          
              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, a status page, 
          // and one or more element descriptors.
        // Point each element to its respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {
            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                                 elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= 
                                (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= 
                                addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                // if the element type is a drive, get SCSI Address 
                // and LUN information, also check SValid
                
                if (elementType == ChangerDrive) {
                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= 
                                           ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = 
                                     elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= 
                                          ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = 
                                            elementDescriptor->Lun;
                    }
                    
                    if (elementDescriptor->SValid) {
                        ULONG  j;
                        USHORT tmpAddress;

                        tmpAddress = 
                 elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= 
                 (elementDescriptor->SourceStorageElementAddress[0] << 8);
                        for (j = 1; j <= ChangerDrive; j++) {
                          if (addressMapping->FirstElement[j] <= 
                                                       tmpAddress) {
                             if (tmpAddress < 
                                                (addressMapping->NumberOfElements[j] 
                                                + addressMapping->FirstElement[j])){
                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                             }
                          }
                        }
                        elementStatus->SrcElementAddress.ElementAddress=
                                 tmpAddress - addressMapping->FirstElement[j];
                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                    }
                }

                //
                // Build Flags field.
                //
                elementStatus->Flags |= 
                               elementDescriptor->Full;
                elementStatus->Flags |= 
                              (elementDescriptor->Exception << 2);
                elementStatus->Flags |= 
                              (elementDescriptor->Accessible << 3);
                elementStatus->Flags |= 
                              (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= 
                              (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= 
                              (elementDescriptor->NotThisBus << 15);
                elementStatus->Flags |= 
                              (elementDescriptor->Invert << 22);
                elementStatus->Flags |= 
                              (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                //

                // for this device, access is not reported properly, so set it
                if (elementType == ChangerTransport) {
                       elementStatus->Flags |= 1 << 3;
                }
 
                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // The QNTM units don't have the 
                    // capability of reporting exceptions
                    // in this manner 
                    //
                    elementStatus->ExceptionCode =
                                MapExceptionCodes(elementDescriptor);
                }

                //
                // Get next descriptor.
                //
                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //
                elementStatus += 1;
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //
                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //
                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = 
                                statusPage->ElementDescriptorLength[1];
                descriptorLength |= 
                                (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = 
                        sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}

NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to initialize all elements

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if (initElementStatus->ElementList.Element.ElementType 
        != AllElements) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

   // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = 0;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
QntmBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = QNT_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + 
                   sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;
    cdb->MODE_SENSE.Dbd = 1;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += (sizeof(MODE_PARAMETER_HEADER));

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = elementAddressPage->MediumTransportElementAddress[1];
        if (elementAddressPage->FirstDataXFerElementAddress[1] < addressMapping->LowAddress) {
            addressMapping->LowAddress = elementAddressPage->FirstDataXFerElementAddress[1];
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->FirstElement[AllElements] = 0;


        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "qntmmc: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;




}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == QNT_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize DeviceStatusin the device extension to 
   // QNTMMC_DEVICE_PROBLEM_NONE. If the changer returns sense code 
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set appropriate 
   // DeviceStatus in ChangerError routine.
   //
   changerData->DeviceStatus = QNTMMC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "QNTMMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) == QNTMMC_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case QNTMMC_CHM_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
            break;
         }

         case QNTMMC_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch(changerData->DeviceStatus)
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\seagate\seaddsmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    seaddsmc.c

Abstract:

    This module contains device-specific routines for many DDS-2 & DDS-3 medium changers:
    - Seagate / Archive 4586
    Also for the Seagate Viper 2000 Ultrium changer.

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "seaddsmc.h"


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, DdsBuildAddressMapping)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath,
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}

typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[SEAGATE_SERIAL_NUMBER_LENGTH];
} SERIALNUMBER, *PSERIALNUMBER;




NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //


    status = DdsBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //


        if (RtlCompareMemory(changerData->InquiryData.VendorId,"ARCHIVE",7) == 7) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"Python",6)== 6) {
                changerData->DriveID = SEAGATE;
            }
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"IBM4586",7)== 7) {
                changerData->DriveID = SEAGATE;
            }
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"4586XX",6)== 6) {
                changerData->DriveID = SEAGATE;
            }
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"IBM-STL496",10)== 10) {
                changerData->DriveID = SEAGATE;
            }

        }

        if (RtlCompareMemory(changerData->InquiryData.VendorId,"SEAGATE",7) == 7) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"DAT",3)== 3) {
                changerData->DriveID = SEAGATE;
            }

            if (RtlCompareMemory(changerData->InquiryData.ProductId, "VIPER", 5) == 5)
            {
                changerData->DriveID = SEAGATE;
            }
        }
    }

    //
    // Get serial number page for Seagate/Archive
    //
    //


    if (changerData->DriveID == SEAGATE) {
        serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                   SEAGATE_SERIAL_NUMBER_LENGTH+4);
        if (!serialBuffer) {
            DebugPrint((1, "BuildAddressMapping failed. %x\n", status));
            ChangerClassFreePool(dataBuffer);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(serialBuffer, SEAGATE_SERIAL_NUMBER_LENGTH+4);

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

        srb.TimeOutValue = 10;
        srb.CdbLength = 6;
        cdb = (PCDB)srb.Cdb;
        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        //
        // Set EVPD and Unit Serial number page
        //
        cdb->CDB6INQUIRY.Reserved1 = 1;
        cdb->CDB6INQUIRY.PageCode = 0x80;

        //
        // Set allocation length to inquiry data buffer size.
        //

        cdb->CDB6INQUIRY.AllocationLength =
                                 SEAGATE_SERIAL_NUMBER_LENGTH+4;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     serialBuffer,
                                     SEAGATE_SERIAL_NUMBER_LENGTH+4,
                                     FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            ULONG i;

            RtlMoveMemory(changerData->SerialNumber,
                                 serialBuffer->SerialNumber,
                                 SEAGATE_SERIAL_NUMBER_LENGTH);

            DebugPrint((1,"DeviceType - %x\n", serialBuffer->DeviceType));
            DebugPrint((1,"PageCode - %x\n", serialBuffer->PageCode));
            DebugPrint((1,"Length - %x\n", serialBuffer->PageLength));

            DebugPrint((1,"Serial number "));

            for (i = 0; i < SEAGATE_SERIAL_NUMBER_LENGTH; i++) {
                DebugPrint((1,"%x", serialBuffer->SerialNumber[i]));
            }

            DebugPrint((1,"\n"));
        }

        ChangerClassFreePool(serialBuffer);
    }
    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}

VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY: {
            if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x3:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;
        }


        case SCSI_SENSE_HARDWARE_ERROR: {
            changerData->HardwareError = TRUE;
            break;
        }

        default:
            break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                  sizeof(MODE_PARAMETER_HEADER) +
                                  sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
       ChangerClassFreePool(srb);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                                  sizeof(MODE_ELEMENT_ADDRESS_PAGE));

    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                                  sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    // TODO - how to handle operators changing magazines from 4 slot to 12 slot
    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->NumberCleanerSlots = 0;
    changerParameters->FirstCleanerSlotAddress = 0;
    changerParameters->MagazineSize = changerParameters->NumberStorageElements;

    if (!addressMapping->Initialized) {

        ULONG i;

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = DDS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    addressMapping->NumberOfElements[ChangerTransport] = changerParameters->NumberTransportElements;
    addressMapping->NumberOfElements[ChangerDrive] = changerParameters->NumberDataTransferElements;
    addressMapping->NumberOfElements[ChangerIEPort] = changerParameters->NumberIEElements;
    addressMapping->NumberOfElements[ChangerSlot] = changerParameters->NumberStorageElements;
    addressMapping->NumberOfElements[ChangerDoor] = changerParameters->NumberOfDoors;
    addressMapping->NumberOfElements[ChangerKeypad] = 0;


    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->DriveCleanTimeout = 600;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);



    // initialize Features1
        changerParameters->Features1 = CHANGER_CLEANER_AUTODISMOUNT;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_LOCK_UNLOCK                   |
                                   CHANGER_CARTRIDGE_MAGAZINE            |
                                   CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS    |
                                   CHANGER_DRIVE_CLEANING_REQUIRED;

        // Only the DOOR can be locked and unlocked
    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_DOOR;


    // EXCHANGE MEDIUM IS SUPPORTED IN THIS DEVICE, BUT ONLY CONDITIONALLY.
    // CAN ONLY DO AN EXCHANGE BETWEEN 2 SLOTS AND THE DRIVE.
    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                        sizeof(MODE_PARAMETER_HEADER) +
                        sizeof(MODE_DEVICE_CAPABILITIES_PAGE));

    if (!modeBuffer) {
       ChangerClassFreePool(srb);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                                  sizeof(MODE_DEVICE_CAPABILITIES_PAGE));

    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                                  sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);


    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->PositionCapabilities = 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    //
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId,
                  VENDOR_ID_LENGTH);

    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId,
                  PRODUCT_ID_LENGTH);

    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel,
                  REVISION_LENGTH);

    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the loader mechanism.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (setAccess->Element.ElementType != ChangerDoor) {
                return STATUS_INVALID_DEVICE_REQUEST;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // DOOR is the only element that can really be locked
    // and unlocked, but since there is only one locking
    // SCSI command for this device, funnel all requests to lock
    // any element into this Prevent/Allow.

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    if (controlOperation == LOCK_ELEMENT) {
        cdb->MEDIA_REMOVAL.Prevent = 1;
    } else if (controlOperation == UNLOCK_ELEMENT) {
        cdb->MEDIA_REMOVAL.Prevent = 0;
    } else {
        ChangerClassFreePool(srb);
        return STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        //
        // Issue the srb.
        //
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PIO_STACK_LOCATION           irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    ELEMENT_TYPE        originalElementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    UCHAR    bitmask, bit;
    ULONG    length;
    NTSTATUS status;
    PVOID    statusBuffer;
    ULONG    totalElements = readElementStatus->ElementList.NumberOfElements;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    originalElementType = elementType;

    DebugPrint((2,
               "GetElementStatus: ElementType: %x\n",
                elementType));

    if (elementType != AllElements)
    {
        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType))
        {
            DebugPrint((1, "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }
    }

    if (readElementStatus->VolumeTagInfo) {

        //
        // These units have no Volume tag capability.
        //

        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // Allocate first only for the header
    //
    length = sizeof(ELEMENT_STATUS_HEADER);
    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb)
    {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //
    if (elementType == AllElements)
    {
        //
        // The changers may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);
    }
    else
    {
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (NT_SUCCESS(status) || STATUS_DATA_OVERRUN == status)
    {
        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;;

        if (STATUS_DATA_OVERRUN == status)
        {
            if ((srb->DataTransferLength) <= length)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                DebugPrint((1, "Seaddsmc:ReadElementStatus - Dataoverrun.\n"));
                ChangerClassFreePool(srb);
                ChangerClassFreePool(statusBuffer);

                return status;
            }
        }

        //
        // Get the actual needed length
        //
        length =  (statusHeader->ReportByteCount[2]);
        length |= (statusHeader->ReportByteCount[1] << 8);
        length |= (statusHeader->ReportByteCount[0] << 16);

        //
        // Account for the size of the status header
        //
        length += sizeof(ELEMENT_STATUS_HEADER);

        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
    }
    else
    {
        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // The changers may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        RtlZeroMemory(elementStatus, irpStack->Parameters.DeviceIoControl.OutputBufferLength);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // These units don't have the capability of reporting exceptions
                // in this manner.
                //

                elementStatus->ExceptionCode = 0;

                if (elementType == ChangerDrive) {

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                }



                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }

                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);


        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}




NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    // Seagate/Archive will eject the medium in the drive if this command
    // is issued. The unit performs inventory on its own if the mag is
    // removed and returned to the changer.

    return STATUS_SUCCESS;

}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. None of the support devices currently have this functionality.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;

}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:



--*/
{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);


    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

       DebugPrint((1, "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }


    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    //
    // DDS changers don't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }



    // Seagate unlocks the changer when a drive driver unlocks the drive.
    // close the exposure to unauthorized access to this changer by
    // relocking the changer on a drive unload.

    if ((changerData->DriveID == SEAGATE) &&
        (moveMedium->Destination.ElementType == ChangerSlot) &&
        (moveMedium->Source.ElementType == ChangerDrive))  {

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;
        ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
        // return status from Move Medium, ignore this lock operation  status
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
DdsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID                  modeBuffer;
    ULONG                  i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = DDS_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                + sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
       ChangerClassFreePool(srb);
       return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));

    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->LowAddress = DDS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == DDS_NO_ELEMENT) {

        DebugPrint((1,
                   "Element